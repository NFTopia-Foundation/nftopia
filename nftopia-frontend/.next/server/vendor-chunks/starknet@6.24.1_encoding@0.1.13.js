"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/starknet@6.24.1_encoding@0.1.13";
exports.ids = ["vendor-chunks/starknet@6.24.1_encoding@0.1.13"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AccountInterface: () => (/* binding */ AccountInterface),\n/* harmony export */   BatchClient: () => (/* binding */ BatchClient),\n/* harmony export */   BlockStatus: () => (/* binding */ BlockStatus),\n/* harmony export */   BlockTag: () => (/* binding */ BlockTag),\n/* harmony export */   CairoCustomEnum: () => (/* binding */ CairoCustomEnum),\n/* harmony export */   CairoFixedArray: () => (/* binding */ CairoFixedArray),\n/* harmony export */   CairoOption: () => (/* binding */ CairoOption),\n/* harmony export */   CairoOptionVariant: () => (/* binding */ CairoOptionVariant),\n/* harmony export */   CairoResult: () => (/* binding */ CairoResult),\n/* harmony export */   CairoResultVariant: () => (/* binding */ CairoResultVariant),\n/* harmony export */   CairoUint256: () => (/* binding */ CairoUint256),\n/* harmony export */   CairoUint512: () => (/* binding */ CairoUint512),\n/* harmony export */   CallData: () => (/* binding */ CallData),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory),\n/* harmony export */   ContractInterface: () => (/* binding */ ContractInterface),\n/* harmony export */   CustomError: () => (/* binding */ CustomError),\n/* harmony export */   ETH_ADDRESS: () => (/* binding */ ETH_ADDRESS),\n/* harmony export */   EntryPointType: () => (/* binding */ EntryPointType),\n/* harmony export */   EthSigner: () => (/* binding */ EthSigner),\n/* harmony export */   LedgerSigner: () => (/* binding */ LedgerSigner111),\n/* harmony export */   LedgerSigner111: () => (/* binding */ LedgerSigner111),\n/* harmony export */   LedgerSigner221: () => (/* binding */ LedgerSigner221),\n/* harmony export */   LibraryError: () => (/* binding */ LibraryError),\n/* harmony export */   Literal: () => (/* binding */ Literal),\n/* harmony export */   LogLevelIndex: () => (/* binding */ LogLevelIndex),\n/* harmony export */   NON_ZERO_PREFIX: () => (/* binding */ NON_ZERO_PREFIX),\n/* harmony export */   OutsideExecutionTypesV1: () => (/* binding */ OutsideExecutionTypesV1),\n/* harmony export */   OutsideExecutionTypesV2: () => (/* binding */ OutsideExecutionTypesV2),\n/* harmony export */   OutsideExecutionVersion: () => (/* binding */ OutsideExecutionVersion),\n/* harmony export */   Provider: () => (/* binding */ RpcProvider2),\n/* harmony export */   ProviderInterface: () => (/* binding */ ProviderInterface),\n/* harmony export */   RPC: () => (/* binding */ api_exports),\n/* harmony export */   RPC06: () => (/* binding */ rpc_0_6_exports),\n/* harmony export */   RPC07: () => (/* binding */ rpc_0_7_exports),\n/* harmony export */   RPCResponseParser: () => (/* binding */ RPCResponseParser),\n/* harmony export */   ReceiptTx: () => (/* binding */ ReceiptTx),\n/* harmony export */   ResponseParser: () => (/* binding */ ResponseParser),\n/* harmony export */   RpcChannel: () => (/* binding */ RpcChannel2),\n/* harmony export */   RpcError: () => (/* binding */ RpcError),\n/* harmony export */   RpcProvider: () => (/* binding */ RpcProvider2),\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   SignerInterface: () => (/* binding */ SignerInterface),\n/* harmony export */   TransactionExecutionStatus: () => (/* binding */ TransactionExecutionStatus),\n/* harmony export */   TransactionFinalityStatus: () => (/* binding */ TransactionFinalityStatus),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   TransactionType: () => (/* binding */ TransactionType),\n/* harmony export */   TypedDataRevision: () => (/* reexport safe */ starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision),\n/* harmony export */   UINT_128_MAX: () => (/* binding */ UINT_128_MAX),\n/* harmony export */   UINT_128_MIN: () => (/* binding */ UINT_128_MIN),\n/* harmony export */   UINT_256_HIGH_MAX: () => (/* binding */ UINT_256_HIGH_MAX),\n/* harmony export */   UINT_256_HIGH_MIN: () => (/* binding */ UINT_256_HIGH_MIN),\n/* harmony export */   UINT_256_LOW_MAX: () => (/* binding */ UINT_256_LOW_MAX),\n/* harmony export */   UINT_256_LOW_MIN: () => (/* binding */ UINT_256_LOW_MIN),\n/* harmony export */   UINT_256_MAX: () => (/* binding */ UINT_256_MAX),\n/* harmony export */   UINT_256_MIN: () => (/* binding */ UINT_256_MIN),\n/* harmony export */   UINT_512_MAX: () => (/* binding */ UINT_512_MAX),\n/* harmony export */   UINT_512_MIN: () => (/* binding */ UINT_512_MIN),\n/* harmony export */   Uint: () => (/* binding */ Uint),\n/* harmony export */   ValidateType: () => (/* binding */ ValidateType),\n/* harmony export */   WalletAccount: () => (/* binding */ WalletAccount),\n/* harmony export */   addAddressPadding: () => (/* binding */ addAddressPadding),\n/* harmony export */   byteArray: () => (/* binding */ byteArray_exports),\n/* harmony export */   cairo: () => (/* binding */ cairo_exports),\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   constants: () => (/* binding */ constants_exports),\n/* harmony export */   contractClassResponseToLegacyCompiledContract: () => (/* binding */ contractClassResponseToLegacyCompiledContract),\n/* harmony export */   defaultProvider: () => (/* binding */ defaultProvider),\n/* harmony export */   ec: () => (/* binding */ ec_exports),\n/* harmony export */   encode: () => (/* binding */ encode_exports),\n/* harmony export */   eth: () => (/* binding */ eth_exports),\n/* harmony export */   events: () => (/* binding */ events_exports),\n/* harmony export */   extractContractHashes: () => (/* binding */ extractContractHashes),\n/* harmony export */   fixProto: () => (/* binding */ fixProto),\n/* harmony export */   fixStack: () => (/* binding */ fixStack),\n/* harmony export */   getCalldata: () => (/* binding */ getCalldata),\n/* harmony export */   getChecksumAddress: () => (/* binding */ getChecksumAddress),\n/* harmony export */   getLedgerPathBuffer: () => (/* binding */ getLedgerPathBuffer111),\n/* harmony export */   getLedgerPathBuffer111: () => (/* binding */ getLedgerPathBuffer111),\n/* harmony export */   getLedgerPathBuffer221: () => (/* binding */ getLedgerPathBuffer221),\n/* harmony export */   hash: () => (/* binding */ hash_exports),\n/* harmony export */   isSierra: () => (/* binding */ isSierra),\n/* harmony export */   json: () => (/* binding */ json_exports),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   merkle: () => (/* binding */ merkle_exports),\n/* harmony export */   num: () => (/* binding */ num_exports),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   outsideExecution: () => (/* binding */ outsideExecution_exports),\n/* harmony export */   parseCalldataField: () => (/* binding */ parseCalldataField),\n/* harmony export */   provider: () => (/* binding */ provider_exports),\n/* harmony export */   selector: () => (/* binding */ selector_exports),\n/* harmony export */   shortString: () => (/* binding */ shortString_exports),\n/* harmony export */   splitArgsAndOptions: () => (/* binding */ splitArgsAndOptions),\n/* harmony export */   src5: () => (/* binding */ src5_exports),\n/* harmony export */   stark: () => (/* binding */ stark_exports),\n/* harmony export */   starknetId: () => (/* binding */ starknetId_exports),\n/* harmony export */   transaction: () => (/* binding */ transaction_exports),\n/* harmony export */   typedData: () => (/* binding */ typedData_exports),\n/* harmony export */   types: () => (/* binding */ types_exports),\n/* harmony export */   uint256: () => (/* binding */ uint256_exports),\n/* harmony export */   units: () => (/* binding */ units),\n/* harmony export */   v2hash: () => (/* binding */ v2_exports),\n/* harmony export */   v3hash: () => (/* binding */ v3_exports),\n/* harmony export */   validateAndParseAddress: () => (/* binding */ validateAndParseAddress),\n/* harmony export */   validateChecksumAddress: () => (/* binding */ validateChecksumAddress),\n/* harmony export */   wallet: () => (/* binding */ connect_exports)\n/* harmony export */ });\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! starknet-types-07 */ \"(ssr)/./node_modules/.pnpm/@starknet-io+types-js@0.7.10/node_modules/@starknet-io/types-js/dist/esm/index.js\");\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! starknet-types-07 */ \"(ssr)/./node_modules/.pnpm/@starknet-io+types-js@0.7.10/node_modules/@starknet-io/types-js/dist/esm/api/nonspec.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/.pnpm/@scure+base@1.2.1/node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var lossless_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lossless-json */ \"(ssr)/./node_modules/.pnpm/lossless-json@4.1.0/node_modules/lossless-json/lib/esm/index.js\");\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! starknet-types-07 */ \"(ssr)/./node_modules/.pnpm/@starknet-io+types-js@0.7.10/node_modules/@starknet-io/types-js/dist/esm/wallet-api/typedData.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.7.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.6.0/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _scure_starknet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @scure/starknet */ \"(ssr)/./node_modules/.pnpm/@scure+starknet@1.1.0/node_modules/@scure/starknet/lib/esm/index.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.6.0/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.7.0/node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.7.0/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/.pnpm/pako@2.1.0/node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.7.0/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var fetch_cookie__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! fetch-cookie */ \"(ssr)/./node_modules/.pnpm/fetch-cookie@3.0.1/node_modules/fetch-cookie/esm/index.js\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! isomorphic-fetch */ \"(ssr)/./node_modules/.pnpm/isomorphic-fetch@3.0.0_encoding@0.1.13/node_modules/isomorphic-fetch/fetch-npm-node.js\");\n/* harmony import */ var ts_mixer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ts-mixer */ \"(ssr)/./node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/index.js\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/global/constants.ts\nvar constants_exports = {};\n__export(constants_exports, {\n  ADDR_BOUND: () => ADDR_BOUND,\n  API_VERSION: () => API_VERSION,\n  BaseUrl: () => BaseUrl,\n  DEFAULT_GLOBAL_CONFIG: () => DEFAULT_GLOBAL_CONFIG,\n  FeeMarginPercentage: () => FeeMarginPercentage,\n  HARDENING_4BYTES: () => HARDENING_4BYTES,\n  HARDENING_BYTE: () => HARDENING_BYTE,\n  IS_BROWSER: () => IS_BROWSER,\n  MASK_250: () => MASK_250,\n  MASK_31: () => MASK_31,\n  MAX_STORAGE_ITEM_SIZE: () => MAX_STORAGE_ITEM_SIZE,\n  NetworkName: () => NetworkName,\n  OutsideExecutionCallerAny: () => OutsideExecutionCallerAny,\n  PRIME: () => PRIME,\n  RANGE_FELT: () => RANGE_FELT,\n  RANGE_I128: () => RANGE_I128,\n  RANGE_U128: () => RANGE_U128,\n  RPC_DEFAULT_VERSION: () => RPC_DEFAULT_VERSION,\n  RPC_NODES: () => RPC_NODES,\n  SNIP9_V1_INTERFACE_ID: () => SNIP9_V1_INTERFACE_ID,\n  SNIP9_V2_INTERFACE_ID: () => SNIP9_V2_INTERFACE_ID,\n  SYSTEM_MESSAGES: () => SYSTEM_MESSAGES,\n  StarknetChainId: () => StarknetChainId,\n  TEXT_TO_FELT_MAX_LEN: () => TEXT_TO_FELT_MAX_LEN,\n  TRANSACTION_VERSION: () => api_exports.ETransactionVersion,\n  TransactionHashPrefix: () => TransactionHashPrefix,\n  UDC: () => UDC,\n  ZERO: () => ZERO\n});\n\n// src/types/api/index.ts\nvar api_exports = {};\n__export(api_exports, {\n  JRPC: () => jsonrpc_exports,\n  RPCSPEC06: () => rpcspec_0_6_exports,\n  RPCSPEC07: () => starknet_types_07__WEBPACK_IMPORTED_MODULE_0__\n});\n\n// src/types/api/jsonrpc/index.ts\nvar jsonrpc_exports = {};\n\n// src/types/api/rpcspec_0_6/index.ts\nvar rpcspec_0_6_exports = {};\n__export(rpcspec_0_6_exports, {\n  EBlockTag: () => EBlockTag,\n  EDAMode: () => EDAMode,\n  EDataAvailabilityMode: () => EDataAvailabilityMode,\n  ESimulationFlag: () => ESimulationFlag,\n  ETransactionExecutionStatus: () => ETransactionExecutionStatus,\n  ETransactionFinalityStatus: () => ETransactionFinalityStatus,\n  ETransactionStatus: () => ETransactionStatus,\n  ETransactionType: () => ETransactionType,\n  ETransactionVersion: () => ETransactionVersion,\n  ETransactionVersion2: () => ETransactionVersion2,\n  ETransactionVersion3: () => ETransactionVersion3,\n  Errors: () => errors_exports,\n  SPEC: () => components_exports\n});\n\n// src/types/api/rpcspec_0_6/errors.ts\nvar errors_exports = {};\n\n// src/types/api/rpcspec_0_6/components.ts\nvar components_exports = {};\n\n// src/types/api/rpcspec_0_6/nonspec.ts\nvar ETransactionType = {\n  DECLARE: \"DECLARE\",\n  DEPLOY: \"DEPLOY\",\n  DEPLOY_ACCOUNT: \"DEPLOY_ACCOUNT\",\n  INVOKE: \"INVOKE\",\n  L1_HANDLER: \"L1_HANDLER\"\n};\nvar ESimulationFlag = {\n  SKIP_VALIDATE: \"SKIP_VALIDATE\",\n  SKIP_FEE_CHARGE: \"SKIP_FEE_CHARGE\"\n};\nvar ETransactionStatus = {\n  RECEIVED: \"RECEIVED\",\n  REJECTED: \"REJECTED\",\n  ACCEPTED_ON_L2: \"ACCEPTED_ON_L2\",\n  ACCEPTED_ON_L1: \"ACCEPTED_ON_L1\"\n};\nvar ETransactionFinalityStatus = {\n  ACCEPTED_ON_L2: \"ACCEPTED_ON_L2\",\n  ACCEPTED_ON_L1: \"ACCEPTED_ON_L1\"\n};\nvar ETransactionExecutionStatus = {\n  SUCCEEDED: \"SUCCEEDED\",\n  REVERTED: \"REVERTED\"\n};\nvar EBlockTag = {\n  PENDING: \"pending\",\n  LATEST: \"latest\"\n};\nvar EDataAvailabilityMode = {\n  L1: \"L1\",\n  L2: \"L2\"\n};\nvar EDAMode = {\n  L1: 0,\n  L2: 1\n};\nvar ETransactionVersion = {\n  V0: \"0x0\",\n  V1: \"0x1\",\n  V2: \"0x2\",\n  V3: \"0x3\",\n  F0: \"0x100000000000000000000000000000000\",\n  F1: \"0x100000000000000000000000000000001\",\n  F2: \"0x100000000000000000000000000000002\",\n  F3: \"0x100000000000000000000000000000003\"\n};\nvar ETransactionVersion2 = {\n  V0: \"0x0\",\n  V1: \"0x1\",\n  V2: \"0x2\",\n  F0: \"0x100000000000000000000000000000000\",\n  F1: \"0x100000000000000000000000000000001\",\n  F2: \"0x100000000000000000000000000000002\"\n};\nvar ETransactionVersion3 = {\n  V3: \"0x3\",\n  F3: \"0x100000000000000000000000000000003\"\n};\n\n// src/types/api/index.ts\n__reExport(api_exports, starknet_types_07__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n// src/utils/encode.ts\nvar encode_exports = {};\n__export(encode_exports, {\n  IS_BROWSER: () => IS_BROWSER,\n  addHexPrefix: () => addHexPrefix,\n  arrayBufferToString: () => arrayBufferToString,\n  atobUniversal: () => atobUniversal,\n  btoaUniversal: () => btoaUniversal,\n  buf2hex: () => buf2hex,\n  calcByteLength: () => calcByteLength,\n  concatenateArrayBuffer: () => concatenateArrayBuffer,\n  padLeft: () => padLeft,\n  pascalToSnake: () => pascalToSnake,\n  removeHexPrefix: () => removeHexPrefix,\n  sanitizeBytes: () => sanitizeBytes,\n  sanitizeHex: () => sanitizeHex,\n  stringToArrayBuffer: () => stringToArrayBuffer,\n  utf8ToArray: () => utf8ToArray\n});\n\nvar IS_BROWSER = typeof window !== \"undefined\";\nvar STRING_ZERO = \"0\";\nfunction arrayBufferToString(array) {\n  return new Uint8Array(array).reduce((data, byte) => data + String.fromCharCode(byte), \"\");\n}\nfunction utf8ToArray(str) {\n  return new TextEncoder().encode(str);\n}\nfunction stringToArrayBuffer(str) {\n  return utf8ToArray(str);\n}\nfunction atobUniversal(a) {\n  return _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64.decode(a);\n}\nfunction btoaUniversal(b) {\n  return _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64.encode(new Uint8Array(b));\n}\nfunction buf2hex(buffer) {\n  return buffer.reduce((r, x) => r + x.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction removeHexPrefix(hex) {\n  return hex.replace(/^0x/i, \"\");\n}\nfunction addHexPrefix(hex) {\n  return `0x${removeHexPrefix(hex)}`;\n}\nfunction padString(str, length, left, padding = STRING_ZERO) {\n  const diff = length - str.length;\n  let result = str;\n  if (diff > 0) {\n    const pad = padding.repeat(diff);\n    result = left ? pad + str : str + pad;\n  }\n  return result;\n}\nfunction padLeft(str, length, padding = STRING_ZERO) {\n  return padString(str, length, true, padding);\n}\nfunction calcByteLength(str, byteSize = 8) {\n  const { length } = str;\n  const remainder = length % byteSize;\n  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;\n}\nfunction sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {\n  return padLeft(str, calcByteLength(str, byteSize), padding);\n}\nfunction sanitizeHex(hex) {\n  const hexWithoutPrefix = removeHexPrefix(hex);\n  const sanitizedHex = sanitizeBytes(hexWithoutPrefix, 2);\n  return sanitizedHex ? addHexPrefix(sanitizedHex) : sanitizedHex;\n}\nvar pascalToSnake = (text) => /[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join(\"_\").toUpperCase() : text;\nfunction concatenateArrayBuffer(uint8arrays) {\n  const totalLength = uint8arrays.reduce((total, uint8array) => total + uint8array.byteLength, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  uint8arrays.forEach((uint8array) => {\n    result.set(uint8array, offset);\n    offset += uint8array.byteLength;\n  });\n  return result;\n}\n\n// src/global/constants.ts\nvar TEXT_TO_FELT_MAX_LEN = 31;\nvar ZERO = 0n;\nvar MASK_250 = 2n ** 250n - 1n;\nvar MASK_31 = 2n ** 31n - 1n;\nvar API_VERSION = ZERO;\nvar PRIME = 2n ** 251n + 17n * 2n ** 192n + 1n;\nvar MAX_STORAGE_ITEM_SIZE = 256n;\nvar ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;\nvar range = (min, max) => ({ min, max });\nvar RANGE_FELT = range(ZERO, PRIME - 1n);\nvar RANGE_I128 = range(-(2n ** 127n), 2n ** 127n - 1n);\nvar RANGE_U128 = range(ZERO, 2n ** 128n - 1n);\nvar BaseUrl = /* @__PURE__ */ ((BaseUrl2) => {\n  BaseUrl2[\"SN_MAIN\"] = \"https://alpha-mainnet.starknet.io\";\n  BaseUrl2[\"SN_SEPOLIA\"] = \"https://alpha-sepolia.starknet.io\";\n  return BaseUrl2;\n})(BaseUrl || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2) => {\n  NetworkName2[\"SN_MAIN\"] = \"SN_MAIN\";\n  NetworkName2[\"SN_SEPOLIA\"] = \"SN_SEPOLIA\";\n  return NetworkName2;\n})(NetworkName || {});\nvar StarknetChainId = /* @__PURE__ */ ((StarknetChainId6) => {\n  StarknetChainId6[\"SN_MAIN\"] = \"0x534e5f4d41494e\";\n  StarknetChainId6[\"SN_SEPOLIA\"] = \"0x534e5f5345504f4c4941\";\n  return StarknetChainId6;\n})(StarknetChainId || {});\nvar TransactionHashPrefix = /* @__PURE__ */ ((TransactionHashPrefix2) => {\n  TransactionHashPrefix2[\"DECLARE\"] = \"0x6465636c617265\";\n  TransactionHashPrefix2[\"DEPLOY\"] = \"0x6465706c6f79\";\n  TransactionHashPrefix2[\"DEPLOY_ACCOUNT\"] = \"0x6465706c6f795f6163636f756e74\";\n  TransactionHashPrefix2[\"INVOKE\"] = \"0x696e766f6b65\";\n  TransactionHashPrefix2[\"L1_HANDLER\"] = \"0x6c315f68616e646c6572\";\n  return TransactionHashPrefix2;\n})(TransactionHashPrefix || {});\nvar FeeMarginPercentage = /* @__PURE__ */ ((FeeMarginPercentage2) => {\n  FeeMarginPercentage2[FeeMarginPercentage2[\"L1_BOUND_MAX_AMOUNT\"] = 50] = \"L1_BOUND_MAX_AMOUNT\";\n  FeeMarginPercentage2[FeeMarginPercentage2[\"L1_BOUND_MAX_PRICE_PER_UNIT\"] = 50] = \"L1_BOUND_MAX_PRICE_PER_UNIT\";\n  FeeMarginPercentage2[FeeMarginPercentage2[\"MAX_FEE\"] = 50] = \"MAX_FEE\";\n  return FeeMarginPercentage2;\n})(FeeMarginPercentage || {});\nvar UDC = {\n  ADDRESS: \"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf\",\n  ENTRYPOINT: \"deployContract\"\n};\nvar RPC_DEFAULT_VERSION = \"v0_7\";\nvar RPC_NODES = {\n  SN_MAIN: [\n    `https://starknet-mainnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/mainnet-juno/${RPC_DEFAULT_VERSION}`\n  ],\n  SN_SEPOLIA: [\n    `https://starknet-sepolia.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/sepolia-juno/${RPC_DEFAULT_VERSION}`\n  ]\n};\nvar OutsideExecutionCallerAny = \"0x414e595f43414c4c4552\";\nvar SNIP9_V1_INTERFACE_ID = \"0x68cfd18b92d1907b8ba3cc324900277f5a3622099431ea85dd8089255e4181\";\nvar SNIP9_V2_INTERFACE_ID = \"0x1d1144bb2138366ff28d8e9ab57456b1d332ac42196230c3a602003c89872\";\nvar HARDENING_BYTE = 128;\nvar HARDENING_4BYTES = 2147483648n;\nvar DEFAULT_GLOBAL_CONFIG = {\n  legacyMode: false,\n  logLevel: \"INFO\",\n  accountTxVersion: api_exports.ETransactionVersion.V2\n};\nvar SYSTEM_MESSAGES = {\n  legacyTxWarningMessage: \"You are using a deprecated transaction version (V0,V1,V2)!\\nUpdate to the latest V3 transactions!\"\n};\n\n// src/channel/rpc_0_6.ts\nvar rpc_0_6_exports = {};\n__export(rpc_0_6_exports, {\n  RpcChannel: () => RpcChannel\n});\n\n// src/utils/json.ts\nvar json_exports = {};\n__export(json_exports, {\n  parse: () => parse2,\n  parseAlwaysAsBig: () => parseAlwaysAsBig,\n  stringify: () => stringify2,\n  stringifyAlwaysAsBig: () => stringifyAlwaysAsBig\n});\n\nvar parseIntAsNumberOrBigInt = (str) => {\n  if (!lossless_json__WEBPACK_IMPORTED_MODULE_2__.isInteger(str)) return parseFloat(str);\n  const num = parseInt(str, 10);\n  return Number.isSafeInteger(num) ? num : BigInt(str);\n};\nvar parse2 = (str) => lossless_json__WEBPACK_IMPORTED_MODULE_2__.parse(String(str), void 0, parseIntAsNumberOrBigInt);\nvar parseAlwaysAsBig = (str) => lossless_json__WEBPACK_IMPORTED_MODULE_2__.parse(String(str), void 0, lossless_json__WEBPACK_IMPORTED_MODULE_2__.parseNumberAndBigInt);\nvar stringify2 = (value, replacer, space, numberStringifiers) => lossless_json__WEBPACK_IMPORTED_MODULE_2__.stringify(value, replacer, space, numberStringifiers);\nvar stringifyAlwaysAsBig = stringify2;\n\n// src/utils/errors/rpc.ts\nvar errorCodes = {\n  FAILED_TO_RECEIVE_TXN: 1,\n  NO_TRACE_AVAILABLE: 10,\n  CONTRACT_NOT_FOUND: 20,\n  BLOCK_NOT_FOUND: 24,\n  INVALID_TXN_INDEX: 27,\n  CLASS_HASH_NOT_FOUND: 28,\n  TXN_HASH_NOT_FOUND: 29,\n  PAGE_SIZE_TOO_BIG: 31,\n  NO_BLOCKS: 32,\n  INVALID_CONTINUATION_TOKEN: 33,\n  TOO_MANY_KEYS_IN_FILTER: 34,\n  CONTRACT_ERROR: 40,\n  TRANSACTION_EXECUTION_ERROR: 41,\n  CLASS_ALREADY_DECLARED: 51,\n  INVALID_TRANSACTION_NONCE: 52,\n  INSUFFICIENT_MAX_FEE: 53,\n  INSUFFICIENT_ACCOUNT_BALANCE: 54,\n  VALIDATION_FAILURE: 55,\n  COMPILATION_FAILED: 56,\n  CONTRACT_CLASS_SIZE_IS_TOO_LARGE: 57,\n  NON_ACCOUNT: 58,\n  DUPLICATE_TX: 59,\n  COMPILED_CLASS_HASH_MISMATCH: 60,\n  UNSUPPORTED_TX_VERSION: 61,\n  UNSUPPORTED_CONTRACT_CLASS_VERSION: 62,\n  UNEXPECTED_ERROR: 63\n};\nvar rpc_default = errorCodes;\n\n// src/utils/errors/index.ts\nfunction fixStack(target, fn = target.constructor) {\n  const { captureStackTrace } = Error;\n  captureStackTrace && captureStackTrace(target, fn);\n}\nfunction fixProto(target, prototype) {\n  const { setPrototypeOf } = Object;\n  setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n}\nvar CustomError = class extends Error {\n  name;\n  constructor(message) {\n    super(message);\n    Object.defineProperty(this, \"name\", {\n      value: new.target.name,\n      enumerable: false,\n      configurable: true\n    });\n    fixProto(this, new.target.prototype);\n    fixStack(this);\n  }\n};\nvar LibraryError = class extends CustomError {\n};\nvar RpcError = class extends LibraryError {\n  constructor(baseError, method, params) {\n    super(`RPC: ${method} with params ${stringify2(params, null, 2)}\n\n      ${baseError.code}: ${baseError.message}: ${stringify2(baseError.data)}`);\n    this.baseError = baseError;\n    this.request = { method, params };\n  }\n  request;\n  get code() {\n    return this.baseError.code;\n  }\n  /**\n   * Verifies the underlying RPC error, also serves as a type guard for the _baseError_ property\n   * @example\n   * ```typescript\n   * SomeError.isType('UNEXPECTED_ERROR');\n   * ```\n   */\n  isType(typeName) {\n    return rpc_default[typeName] === this.code;\n  }\n};\n\n// src/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n  BlockStatus: () => BlockStatus,\n  BlockTag: () => BlockTag,\n  ETH_ADDRESS: () => ETH_ADDRESS,\n  EntryPointType: () => EntryPointType,\n  Literal: () => Literal,\n  NON_ZERO_PREFIX: () => NON_ZERO_PREFIX,\n  OutsideExecutionTypesV1: () => OutsideExecutionTypesV1,\n  OutsideExecutionTypesV2: () => OutsideExecutionTypesV2,\n  OutsideExecutionVersion: () => OutsideExecutionVersion,\n  RPC: () => api_exports,\n  TransactionExecutionStatus: () => TransactionExecutionStatus,\n  TransactionFinalityStatus: () => TransactionFinalityStatus,\n  TransactionStatus: () => TransactionStatus,\n  TransactionType: () => TransactionType,\n  TypedDataRevision: () => starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision,\n  Uint: () => Uint,\n  ValidateType: () => ValidateType\n});\n\n// src/types/lib/contract/index.ts\nvar EntryPointType = {\n  EXTERNAL: \"EXTERNAL\",\n  L1_HANDLER: \"L1_HANDLER\",\n  CONSTRUCTOR: \"CONSTRUCTOR\"\n};\n\n// src/types/lib/index.ts\nvar TransactionType = {\n  DECLARE: \"DECLARE\",\n  DEPLOY: \"DEPLOY\",\n  DEPLOY_ACCOUNT: \"DEPLOY_ACCOUNT\",\n  INVOKE: \"INVOKE_FUNCTION\"\n};\nvar TransactionStatus = {\n  NOT_RECEIVED: \"NOT_RECEIVED\",\n  RECEIVED: \"RECEIVED\",\n  ACCEPTED_ON_L2: \"ACCEPTED_ON_L2\",\n  ACCEPTED_ON_L1: \"ACCEPTED_ON_L1\",\n  REJECTED: \"REJECTED\",\n  REVERTED: \"REVERTED\"\n};\nvar TransactionFinalityStatus = {\n  NOT_RECEIVED: \"NOT_RECEIVED\",\n  RECEIVED: \"RECEIVED\",\n  ACCEPTED_ON_L2: \"ACCEPTED_ON_L2\",\n  ACCEPTED_ON_L1: \"ACCEPTED_ON_L1\"\n};\nvar TransactionExecutionStatus = {\n  REJECTED: \"REJECTED\",\n  REVERTED: \"REVERTED\",\n  SUCCEEDED: \"SUCCEEDED\"\n};\nvar BlockStatus = {\n  PENDING: \"PENDING\",\n  ACCEPTED_ON_L1: \"ACCEPTED_ON_L1\",\n  ACCEPTED_ON_L2: \"ACCEPTED_ON_L2\",\n  REJECTED: \"REJECTED\"\n};\nvar BlockTag = {\n  PENDING: \"pending\",\n  LATEST: \"latest\"\n};\n\n// src/types/calldata.ts\nvar ValidateType = {\n  DEPLOY: \"DEPLOY\",\n  CALL: \"CALL\",\n  INVOKE: \"INVOKE\"\n};\nvar Uint = {\n  u8: \"core::integer::u8\",\n  u16: \"core::integer::u16\",\n  u32: \"core::integer::u32\",\n  u64: \"core::integer::u64\",\n  u128: \"core::integer::u128\",\n  u256: \"core::integer::u256\",\n  // This one is struct\n  u512: \"core::integer::u512\"\n  // This one is struct\n};\nvar Literal = {\n  ClassHash: \"core::starknet::class_hash::ClassHash\",\n  ContractAddress: \"core::starknet::contract_address::ContractAddress\",\n  Secp256k1Point: \"core::starknet::secp256k1::Secp256k1Point\",\n  U96: \"core::internal::bounded_int::BoundedInt::<0, 79228162514264337593543950335>\"\n};\nvar ETH_ADDRESS = \"core::starknet::eth_address::EthAddress\";\nvar NON_ZERO_PREFIX = \"core::zeroable::NonZero::\";\n\n// src/types/outsideExecution.ts\nvar OutsideExecutionTypesV1 = {\n  StarkNetDomain: [\n    { name: \"name\", type: \"felt\" },\n    { name: \"version\", type: \"felt\" },\n    { name: \"chainId\", type: \"felt\" }\n  ],\n  OutsideExecution: [\n    { name: \"caller\", type: \"felt\" },\n    { name: \"nonce\", type: \"felt\" },\n    { name: \"execute_after\", type: \"felt\" },\n    { name: \"execute_before\", type: \"felt\" },\n    { name: \"calls_len\", type: \"felt\" },\n    { name: \"calls\", type: \"OutsideCall*\" }\n  ],\n  OutsideCall: [\n    { name: \"to\", type: \"felt\" },\n    { name: \"selector\", type: \"felt\" },\n    { name: \"calldata_len\", type: \"felt\" },\n    { name: \"calldata\", type: \"felt*\" }\n  ]\n};\nvar OutsideExecutionTypesV2 = {\n  StarknetDomain: [\n    // SNIP-12 revision 1 is used, so should be \"StarknetDomain\", not \"StarkNetDomain\"\n    { name: \"name\", type: \"shortstring\" },\n    { name: \"version\", type: \"shortstring\" },\n    // set to 2 in v2\n    { name: \"chainId\", type: \"shortstring\" },\n    { name: \"revision\", type: \"shortstring\" }\n  ],\n  OutsideExecution: [\n    { name: \"Caller\", type: \"ContractAddress\" },\n    { name: \"Nonce\", type: \"felt\" },\n    { name: \"Execute After\", type: \"u128\" },\n    { name: \"Execute Before\", type: \"u128\" },\n    { name: \"Calls\", type: \"Call*\" }\n  ],\n  Call: [\n    { name: \"To\", type: \"ContractAddress\" },\n    { name: \"Selector\", type: \"selector\" },\n    { name: \"Calldata\", type: \"felt*\" }\n  ]\n};\nvar OutsideExecutionVersion = /* @__PURE__ */ ((OutsideExecutionVersion2) => {\n  OutsideExecutionVersion2[\"UNSUPPORTED\"] = \"0\";\n  OutsideExecutionVersion2[\"V1\"] = \"1\";\n  OutsideExecutionVersion2[\"V2\"] = \"2\";\n  return OutsideExecutionVersion2;\n})(OutsideExecutionVersion || {});\n\n// src/types/typedData.ts\n\n\n// src/utils/batch/index.ts\nvar BatchClient = class {\n  nodeUrl;\n  headers;\n  interval;\n  requestId = 0;\n  pendingRequests = {};\n  batchPromises = {};\n  delayTimer;\n  delayPromise;\n  delayPromiseResolve;\n  baseFetch;\n  constructor(options) {\n    this.nodeUrl = options.nodeUrl;\n    this.headers = options.headers;\n    this.interval = options.interval;\n    this.baseFetch = options.baseFetch;\n  }\n  async wait() {\n    if (!this.delayPromise || !this.delayPromiseResolve) {\n      this.delayPromise = new Promise((resolve) => {\n        this.delayPromiseResolve = resolve;\n      });\n    }\n    if (this.delayTimer) {\n      clearTimeout(this.delayTimer);\n      this.delayTimer = void 0;\n    }\n    this.delayTimer = setTimeout(() => {\n      if (this.delayPromiseResolve) {\n        this.delayPromiseResolve();\n        this.delayPromise = void 0;\n        this.delayPromiseResolve = void 0;\n      }\n    }, this.interval);\n    return this.delayPromise;\n  }\n  addPendingRequest(method, params, id) {\n    const request = {\n      id: id ?? `batched_${this.requestId += 1}`,\n      jsonrpc: \"2.0\",\n      method,\n      params: params ?? void 0\n    };\n    this.pendingRequests[request.id] = request;\n    return request.id;\n  }\n  async sendBatch(requests) {\n    const raw = await this.baseFetch(this.nodeUrl, {\n      method: \"POST\",\n      body: stringify2(requests),\n      headers: this.headers\n    });\n    return raw.json();\n  }\n  /**\n   * Automatically batches and fetches JSON-RPC calls in a single request.\n   * @param method Method to call\n   * @param params Method parameters\n   * @param id JSON-RPC Request ID\n   * @returns JSON-RPC Response\n   */\n  async fetch(method, params, id) {\n    const requestId = this.addPendingRequest(method, params, id);\n    await this.wait();\n    const requests = this.pendingRequests;\n    this.pendingRequests = {};\n    if (!this.batchPromises[requestId]) {\n      const promise = this.sendBatch(Object.values(requests));\n      Object.keys(requests).forEach((key) => {\n        this.batchPromises[key] = promise;\n      });\n    }\n    const results = await this.batchPromises[requestId];\n    delete this.batchPromises[requestId];\n    const result = results.find((res) => res.id === requestId);\n    if (!result) throw new Error(`Couldn't find the result for the request. Method: ${method}`);\n    return result;\n  }\n};\n\n// src/utils/assert.ts\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failure\");\n  }\n}\n\n// src/utils/num.ts\nvar num_exports = {};\n__export(num_exports, {\n  addPercent: () => addPercent,\n  assertInRange: () => assertInRange,\n  bigNumberishArrayToDecimalStringArray: () => bigNumberishArrayToDecimalStringArray,\n  bigNumberishArrayToHexadecimalStringArray: () => bigNumberishArrayToHexadecimalStringArray,\n  cleanHex: () => cleanHex,\n  getDecimalString: () => getDecimalString,\n  getHexString: () => getHexString,\n  getHexStringArray: () => getHexStringArray,\n  hexToBytes: () => hexToBytes,\n  hexToDecimalString: () => hexToDecimalString,\n  isBigNumberish: () => isBigNumberish,\n  isHex: () => isHex,\n  isStringWholeNumber: () => isStringWholeNumber,\n  stringToSha256ToArrayBuff4: () => stringToSha256ToArrayBuff4,\n  toBigInt: () => toBigInt,\n  toCairoBool: () => toCairoBool,\n  toHex: () => toHex,\n  toHex64: () => toHex64,\n  toHexString: () => toHexString,\n  toStorageKey: () => toStorageKey\n});\n\n\n\n// src/utils/typed.ts\nvar isUndefined = (value) => {\n  return typeof value === \"undefined\" || value === void 0;\n};\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\nfunction isBigInt(value) {\n  return typeof value === \"bigint\";\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isObject(item) {\n  return !!item && typeof item === \"object\" && !Array.isArray(item);\n}\n\n// src/utils/num.ts\nfunction isHex(hex) {\n  return /^0x[0-9a-f]*$/i.test(hex);\n}\nfunction toBigInt(value) {\n  return BigInt(value);\n}\nfunction toHex(value) {\n  return addHexPrefix(toBigInt(value).toString(16));\n}\nvar toHexString = toHex;\nfunction toStorageKey(number2) {\n  return addHexPrefix(toBigInt(number2).toString(16).padStart(64, \"0\"));\n}\nfunction toHex64(number2) {\n  const res = addHexPrefix(toBigInt(number2).toString(16).padStart(64, \"0\"));\n  if (res.length !== 66) throw TypeError(\"number is too big for hex 0x(64) representation\");\n  return res;\n}\nfunction hexToDecimalString(hex) {\n  return BigInt(addHexPrefix(hex)).toString(10);\n}\nfunction cleanHex(hex) {\n  return hex.toLowerCase().replace(/^(0x)0+/, \"$1\");\n}\nfunction assertInRange(input, lowerBound, upperBound, inputName = \"\") {\n  const messageSuffix = inputName === \"\" ? \"invalid length\" : `invalid ${inputName} length`;\n  const inputBigInt = BigInt(input);\n  const lowerBoundBigInt = BigInt(lowerBound);\n  const upperBoundBigInt = BigInt(upperBound);\n  assert(\n    inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt,\n    `Message not signable, ${messageSuffix}.`\n  );\n}\nfunction bigNumberishArrayToDecimalStringArray(data) {\n  return data.map((x) => toBigInt(x).toString(10));\n}\nfunction bigNumberishArrayToHexadecimalStringArray(data) {\n  return data.map((x) => toHex(x));\n}\nfunction isStringWholeNumber(str) {\n  return /^\\d+$/.test(str);\n}\nfunction getDecimalString(str) {\n  if (isHex(str)) {\n    return hexToDecimalString(str);\n  }\n  if (isStringWholeNumber(str)) {\n    return str;\n  }\n  throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\nfunction getHexString(str) {\n  if (isHex(str)) {\n    return str;\n  }\n  if (isStringWholeNumber(str)) {\n    return toHexString(str);\n  }\n  throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\nfunction getHexStringArray(array) {\n  return array.map(getHexString);\n}\nfunction toCairoBool(value) {\n  return (+value).toString();\n}\nfunction hexToBytes(str) {\n  if (!isHex(str)) throw new Error(`${str} needs to be a hex-string`);\n  let adaptedValue = removeHexPrefix(str);\n  if (adaptedValue.length % 2 !== 0) {\n    adaptedValue = `0${adaptedValue}`;\n  }\n  return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.hexToBytes)(adaptedValue);\n}\nfunction addPercent(number2, percent) {\n  const bigIntNum = BigInt(number2);\n  return bigIntNum + bigIntNum * BigInt(percent) / 100n;\n}\nfunction stringToSha256ToArrayBuff4(str) {\n  const int31 = (n) => Number(n & MASK_31);\n  const result = int31(BigInt(addHexPrefix(buf2hex((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_5__.sha256)(str)))));\n  return hexToBytes(toHex(result));\n}\nfunction isBigNumberish(input) {\n  return isNumber(input) || isBigInt(input) || isString(input) && (isHex(input) || isStringWholeNumber(input));\n}\n\n// src/utils/hash/selector.ts\nvar selector_exports = {};\n__export(selector_exports, {\n  getL2MessageHash: () => getL2MessageHash,\n  getSelector: () => getSelector,\n  getSelectorFromName: () => getSelectorFromName,\n  keccakBn: () => keccakBn,\n  solidityUint256PackedKeccak256: () => solidityUint256PackedKeccak256,\n  starknetKeccak: () => starknetKeccak\n});\n\n\n\nfunction keccakBn(value) {\n  const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n  const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n  return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\nfunction keccakHex(str) {\n  return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak)(utf8ToArray(str)).toString(16));\n}\nfunction starknetKeccak(str) {\n  const hash = BigInt(keccakHex(str));\n  return hash & MASK_250;\n}\nfunction getSelectorFromName(funcName) {\n  return toHex(starknetKeccak(funcName));\n}\nfunction getSelector(value) {\n  if (isNumber(value) || isBigInt(value)) return toHex(value);\n  if (isHex(value)) return value;\n  if (isStringWholeNumber(value)) return toHex(value);\n  return getSelectorFromName(value);\n}\nfunction solidityUint256PackedKeccak256(params) {\n  const myEncode = addHexPrefix(\n    params.reduce(\n      (res, par) => res + removeHexPrefix(toHex(par)).padStart(64, \"0\"),\n      \"\"\n    )\n  );\n  return addHexPrefix((0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.bytesToHex)((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_7__.keccak_256)(hexToBytes(myEncode))));\n}\nfunction getL2MessageHash(l1FromAddress, l2ToAddress, l2Selector, l2Calldata, l1Nonce) {\n  return solidityUint256PackedKeccak256([\n    l1FromAddress,\n    l2ToAddress,\n    l1Nonce,\n    l2Selector,\n    l2Calldata.length,\n    ...l2Calldata\n  ]);\n}\n\n// src/utils/shortString.ts\nvar shortString_exports = {};\n__export(shortString_exports, {\n  decodeShortString: () => decodeShortString,\n  encodeShortString: () => encodeShortString,\n  isASCII: () => isASCII,\n  isDecimalString: () => isDecimalString,\n  isLongText: () => isLongText,\n  isShortString: () => isShortString,\n  isShortText: () => isShortText,\n  isText: () => isText,\n  splitLongString: () => splitLongString\n});\nfunction isASCII(str) {\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\nfunction isShortString(str) {\n  return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\nfunction isDecimalString(str) {\n  return /^[0-9]*$/i.test(str);\n}\nfunction isText(val) {\n  return isString(val) && !isHex(val) && !isStringWholeNumber(val);\n}\nvar isShortText = (val) => isText(val) && isShortString(val);\nvar isLongText = (val) => isText(val) && !isShortString(val);\nfunction splitLongString(longStr) {\n  const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, \"g\");\n  return longStr.match(regex) || [];\n}\nfunction encodeShortString(str) {\n  if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n  if (!isShortString(str)) throw new Error(`${str} is too long`);\n  return addHexPrefix(str.replace(/./g, (char) => char.charCodeAt(0).toString(16)));\n}\nfunction decodeShortString(str) {\n  if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n  if (isHex(str)) {\n    return removeHexPrefix(str).replace(/.{2}/g, (hex) => String.fromCharCode(parseInt(hex, 16)));\n  }\n  if (isDecimalString(str)) {\n    return decodeShortString(\"0X\".concat(BigInt(str).toString(16)));\n  }\n  throw new Error(`${str} is not Hex or decimal`);\n}\n\n// src/utils/calldata/byteArray.ts\nvar byteArray_exports = {};\n__export(byteArray_exports, {\n  byteArrayFromString: () => byteArrayFromString,\n  stringFromByteArray: () => stringFromByteArray\n});\nfunction stringFromByteArray(myByteArray) {\n  const pending_word = BigInt(myByteArray.pending_word) === 0n ? \"\" : decodeShortString(toHex(myByteArray.pending_word));\n  return myByteArray.data.reduce((cumuledString, encodedString) => {\n    const add = BigInt(encodedString) === 0n ? \"\" : decodeShortString(toHex(encodedString));\n    return cumuledString + add;\n  }, \"\") + pending_word;\n}\nfunction byteArrayFromString(targetString) {\n  const shortStrings = splitLongString(targetString);\n  const remainder = shortStrings[shortStrings.length - 1];\n  const shortStringsEncoded = shortStrings.map(encodeShortString);\n  const [pendingWord, pendingWordLength] = remainder === void 0 || remainder.length === 31 ? [\"0x00\", 0] : [shortStringsEncoded.pop(), remainder.length];\n  return {\n    data: shortStringsEncoded.length === 0 ? [] : shortStringsEncoded,\n    pending_word: pendingWord,\n    pending_word_len: pendingWordLength\n  };\n}\n\n// src/utils/calldata/cairo.ts\nvar cairo_exports = {};\n__export(cairo_exports, {\n  felt: () => felt,\n  getAbiContractVersion: () => getAbiContractVersion,\n  getArrayType: () => getArrayType,\n  isCairo1Abi: () => isCairo1Abi,\n  isCairo1Type: () => isCairo1Type,\n  isLen: () => isLen,\n  isTypeArray: () => isTypeArray,\n  isTypeBool: () => isTypeBool,\n  isTypeByteArray: () => isTypeByteArray,\n  isTypeBytes31: () => isTypeBytes31,\n  isTypeContractAddress: () => isTypeContractAddress,\n  isTypeEnum: () => isTypeEnum,\n  isTypeEthAddress: () => isTypeEthAddress,\n  isTypeFelt: () => isTypeFelt,\n  isTypeLiteral: () => isTypeLiteral,\n  isTypeNamedTuple: () => isTypeNamedTuple,\n  isTypeNonZero: () => isTypeNonZero,\n  isTypeOption: () => isTypeOption,\n  isTypeResult: () => isTypeResult,\n  isTypeSecp256k1Point: () => isTypeSecp256k1Point,\n  isTypeStruct: () => isTypeStruct,\n  isTypeTuple: () => isTypeTuple,\n  isTypeU96: () => isTypeU96,\n  isTypeUint: () => isTypeUint,\n  isTypeUint256: () => isTypeUint256,\n  tuple: () => tuple,\n  uint256: () => uint256,\n  uint512: () => uint512\n});\n\n// src/utils/cairoDataTypes/felt.ts\nfunction CairoFelt(it) {\n  if (isBigInt(it) || Number.isInteger(it)) {\n    return it.toString();\n  }\n  if (isString(it)) {\n    if (isHex(it)) {\n      return BigInt(it).toString();\n    }\n    if (isText(it)) {\n      if (!isShortString(it)) {\n        throw new Error(\n          `${it} is a long string > 31 chars. Please split it into an array of short strings.`\n        );\n      }\n      return BigInt(encodeShortString(it)).toString();\n    }\n    if (isStringWholeNumber(it)) {\n      return it;\n    }\n  }\n  if (isBoolean(it)) {\n    return `${+it}`;\n  }\n  throw new Error(`${it} can't be computed by felt()`);\n}\n\n// src/utils/cairoDataTypes/uint256.ts\nvar UINT_128_MAX = (1n << 128n) - 1n;\nvar UINT_256_MAX = (1n << 256n) - 1n;\nvar UINT_256_MIN = 0n;\nvar UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;\nvar UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;\nvar UINT_256_LOW_MIN = 0n;\nvar UINT_256_HIGH_MIN = 0n;\nvar CairoUint256 = class _CairoUint256 {\n  low;\n  high;\n  static abiSelector = \"core::integer::u256\";\n  constructor(...arr) {\n    if (typeof arr[0] === \"object\" && arr.length === 1 && \"low\" in arr[0] && \"high\" in arr[0]) {\n      const props = _CairoUint256.validateProps(arr[0].low, arr[0].high);\n      this.low = props.low;\n      this.high = props.high;\n    } else if (arr.length === 1) {\n      const bigInt = _CairoUint256.validate(arr[0]);\n      this.low = bigInt & UINT_128_MAX;\n      this.high = bigInt >> 128n;\n    } else if (arr.length === 2) {\n      const props = _CairoUint256.validateProps(arr[0], arr[1]);\n      this.low = props.low;\n      this.high = props.high;\n    } else {\n      throw Error(\"Incorrect constructor parameters\");\n    }\n  }\n  /**\n   * Validate if BigNumberish can be represented as Unit256\n   */\n  static validate(bigNumberish) {\n    const bigInt = BigInt(bigNumberish);\n    if (bigInt < UINT_256_MIN) throw Error(\"bigNumberish is smaller than UINT_256_MIN\");\n    if (bigInt > UINT_256_MAX) throw new Error(\"bigNumberish is bigger than UINT_256_MAX\");\n    return bigInt;\n  }\n  /**\n   * Validate if low and high can be represented as Unit256\n   */\n  static validateProps(low, high) {\n    const bigIntLow = BigInt(low);\n    const bigIntHigh = BigInt(high);\n    if (bigIntLow < UINT_256_LOW_MIN || bigIntLow > UINT_256_LOW_MAX) {\n      throw new Error(\"low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX\");\n    }\n    if (bigIntHigh < UINT_256_HIGH_MIN || bigIntHigh > UINT_256_HIGH_MAX) {\n      throw new Error(\"high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX\");\n    }\n    return { low: bigIntLow, high: bigIntHigh };\n  }\n  /**\n   * Check if BigNumberish can be represented as Unit256\n   */\n  static is(bigNumberish) {\n    try {\n      _CairoUint256.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType) {\n    return abiType === _CairoUint256.abiSelector;\n  }\n  /**\n   * Return bigint representation\n   */\n  toBigInt() {\n    return (this.high << 128n) + this.low;\n  }\n  /**\n   * Return Uint256 structure with HexString props\n   * {low: HexString, high: HexString}\n   */\n  toUint256HexString() {\n    return {\n      low: addHexPrefix(this.low.toString(16)),\n      high: addHexPrefix(this.high.toString(16))\n    };\n  }\n  /**\n   * Return Uint256 structure with DecimalString props\n   * {low: DecString, high: DecString}\n   */\n  toUint256DecimalString() {\n    return {\n      low: this.low.toString(10),\n      high: this.high.toString(10)\n    };\n  }\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest() {\n    return [CairoFelt(this.low), CairoFelt(this.high)];\n  }\n};\n\n// src/utils/cairoDataTypes/uint512.ts\nvar UINT_512_MAX = (1n << 512n) - 1n;\nvar UINT_512_MIN = 0n;\nvar UINT_128_MIN = 0n;\nvar CairoUint512 = class _CairoUint512 {\n  limb0;\n  limb1;\n  limb2;\n  limb3;\n  static abiSelector = \"core::integer::u512\";\n  constructor(...arr) {\n    if (typeof arr[0] === \"object\" && arr.length === 1 && \"limb0\" in arr[0] && \"limb1\" in arr[0] && \"limb2\" in arr[0] && \"limb3\" in arr[0]) {\n      const props = _CairoUint512.validateProps(\n        arr[0].limb0,\n        arr[0].limb1,\n        arr[0].limb2,\n        arr[0].limb3\n      );\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else if (arr.length === 1) {\n      const bigInt = _CairoUint512.validate(arr[0]);\n      this.limb0 = bigInt & UINT_128_MAX;\n      this.limb1 = (bigInt & UINT_128_MAX << 128n) >> 128n;\n      this.limb2 = (bigInt & UINT_128_MAX << 256n) >> 256n;\n      this.limb3 = bigInt >> 384n;\n    } else if (arr.length === 4) {\n      const props = _CairoUint512.validateProps(arr[0], arr[1], arr[2], arr[3]);\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else {\n      throw Error(\"Incorrect Uint512 constructor parameters\");\n    }\n  }\n  /**\n   * Validate if BigNumberish can be represented as Uint512\n   */\n  static validate(bigNumberish) {\n    const bigInt = BigInt(bigNumberish);\n    if (bigInt < UINT_512_MIN) throw Error(\"bigNumberish is smaller than UINT_512_MIN.\");\n    if (bigInt > UINT_512_MAX) throw Error(\"bigNumberish is bigger than UINT_512_MAX.\");\n    return bigInt;\n  }\n  /**\n   * Validate if limbs can be represented as Uint512\n   */\n  static validateProps(limb0, limb1, limb2, limb3) {\n    const l0 = BigInt(limb0);\n    const l1 = BigInt(limb1);\n    const l2 = BigInt(limb2);\n    const l3 = BigInt(limb3);\n    [l0, l1, l2, l3].forEach((value, index) => {\n      if (value < UINT_128_MIN || value > UINT_128_MAX) {\n        throw Error(`limb${index} is not in the range of a u128 number`);\n      }\n    });\n    return { limb0: l0, limb1: l1, limb2: l2, limb3: l3 };\n  }\n  /**\n   * Check if BigNumberish can be represented as Uint512\n   */\n  static is(bigNumberish) {\n    try {\n      _CairoUint512.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType) {\n    return abiType === _CairoUint512.abiSelector;\n  }\n  /**\n   * Return bigint representation\n   */\n  toBigInt() {\n    return (this.limb3 << 384n) + (this.limb2 << 256n) + (this.limb1 << 128n) + this.limb0;\n  }\n  /**\n   * Return Uint512 structure with HexString props\n   * limbx: HexString\n   */\n  toUint512HexString() {\n    return {\n      limb0: addHexPrefix(this.limb0.toString(16)),\n      limb1: addHexPrefix(this.limb1.toString(16)),\n      limb2: addHexPrefix(this.limb2.toString(16)),\n      limb3: addHexPrefix(this.limb3.toString(16))\n    };\n  }\n  /**\n   * Return Uint512 structure with DecimalString props\n   * limbx DecString\n   */\n  toUint512DecimalString() {\n    return {\n      limb0: this.limb0.toString(10),\n      limb1: this.limb1.toString(10),\n      limb2: this.limb2.toString(10),\n      limb3: this.limb3.toString(10)\n    };\n  }\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest() {\n    return [\n      CairoFelt(this.limb0),\n      CairoFelt(this.limb1),\n      CairoFelt(this.limb2),\n      CairoFelt(this.limb3)\n    ];\n  }\n};\n\n// src/utils/calldata/cairo.ts\nvar isLen = (name) => /_len$/.test(name);\nvar isTypeFelt = (type) => type === \"felt\" || type === \"core::felt252\";\nvar isTypeArray = (type) => /\\*/.test(type) || type.startsWith(\"core::array::Array::\") || type.startsWith(\"core::array::Span::\");\nvar isTypeTuple = (type) => /^\\(.*\\)$/i.test(type);\nvar isTypeNamedTuple = (type) => /\\(.*\\)/i.test(type) && type.includes(\":\");\nvar isTypeStruct = (type, structs) => type in structs;\nvar isTypeEnum = (type, enums) => type in enums;\nvar isTypeOption = (type) => type.startsWith(\"core::option::Option::\");\nvar isTypeResult = (type) => type.startsWith(\"core::result::Result::\");\nvar isTypeUint = (type) => Object.values(Uint).includes(type);\nvar isTypeUint256 = (type) => CairoUint256.isAbiType(type);\nvar isTypeLiteral = (type) => Object.values(Literal).includes(type);\nvar isTypeBool = (type) => type === \"core::bool\";\nvar isTypeContractAddress = (type) => type === Literal.ContractAddress;\nvar isTypeEthAddress = (type) => type === ETH_ADDRESS;\nvar isTypeBytes31 = (type) => type === \"core::bytes_31::bytes31\";\nvar isTypeByteArray = (type) => type === \"core::byte_array::ByteArray\";\nvar isTypeU96 = (type) => type === \"core::internal::bounded_int::BoundedInt::<0, 79228162514264337593543950335>\";\nvar isTypeSecp256k1Point = (type) => type === Literal.Secp256k1Point;\nvar isCairo1Type = (type) => type.includes(\"::\");\nvar getArrayType = (type) => {\n  return isCairo1Type(type) ? type.substring(type.indexOf(\"<\") + 1, type.lastIndexOf(\">\")) : type.replace(\"*\", \"\");\n};\nfunction isCairo1Abi(abi) {\n  const { cairo } = getAbiContractVersion(abi);\n  if (cairo === void 0) {\n    throw Error(\"Unable to determine Cairo version\");\n  }\n  return cairo === \"1\";\n}\nfunction isTypeNonZero(type) {\n  return type.startsWith(NON_ZERO_PREFIX);\n}\nfunction getAbiContractVersion(abi) {\n  if (abi.find((it) => it.type === \"interface\")) {\n    return { cairo: \"1\", compiler: \"2\" };\n  }\n  const testSubject = abi.find(\n    (it) => (it.type === \"function\" || it.type === \"constructor\") && (it.inputs.length || it.outputs.length)\n  );\n  if (!testSubject) {\n    return { cairo: void 0, compiler: void 0 };\n  }\n  const io = testSubject.inputs.length ? testSubject.inputs : testSubject.outputs;\n  if (isCairo1Type(io[0].type)) {\n    return { cairo: \"1\", compiler: \"1\" };\n  }\n  return { cairo: \"0\", compiler: \"0\" };\n}\nvar uint256 = (it) => {\n  return new CairoUint256(it).toUint256DecimalString();\n};\nvar uint512 = (it) => {\n  return new CairoUint512(it).toUint512DecimalString();\n};\nvar tuple = (...args) => ({ ...args });\nfunction felt(it) {\n  return CairoFelt(it);\n}\n\n// src/utils/calldata/enum/CairoCustomEnum.ts\nvar CairoCustomEnum = class {\n  /**\n   * direct readonly access to variants of the Cairo Custom Enum.\n   * @returns a value of type any\n   * @example\n   * ```typescript\n   * const successValue = myCairoEnum.variant.Success;\n   */\n  variant;\n  /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */\n  constructor(enumContent) {\n    const variantsList = Object.values(enumContent);\n    if (variantsList.length === 0) {\n      throw new Error(\"This Enum must have at least 1 variant\");\n    }\n    const nbActiveVariants = variantsList.filter((content) => !isUndefined(content)).length;\n    if (nbActiveVariants !== 1) {\n      throw new Error(\"This Enum must have exactly one active variant\");\n    }\n    this.variant = enumContent;\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */\n  unwrap() {\n    const variants = Object.values(this.variant);\n    return variants.find((item) => !isUndefined(item));\n  }\n  /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */\n  activeVariant() {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => !isUndefined(item[1]));\n    return isUndefined(activeVariant) ? \"\" : activeVariant[0];\n  }\n};\n\n// src/utils/calldata/enum/CairoOption.ts\nvar CairoOptionVariant = {\n  Some: 0,\n  None: 1\n};\nvar CairoOption = class {\n  Some;\n  None;\n  constructor(variant, content) {\n    if (!(variant in Object.values(CairoOptionVariant))) {\n      throw new Error(\"Wrong variant! It should be CairoOptionVariant.Some or .None.\");\n    }\n    if (variant === CairoOptionVariant.Some) {\n      if (isUndefined(content)) {\n        throw new Error(\n          'The creation of a Cairo Option with \"Some\" variant needs a content as input.'\n        );\n      }\n      this.Some = content;\n      this.None = void 0;\n    } else {\n      this.Some = void 0;\n      this.None = true;\n    }\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */\n  unwrap() {\n    return this.None ? void 0 : this.Some;\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */\n  isSome() {\n    return !isUndefined(this.Some);\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */\n  isNone() {\n    return this.None === true;\n  }\n};\n\n// src/utils/calldata/enum/CairoResult.ts\nvar CairoResultVariant = {\n  Ok: 0,\n  Err: 1\n};\nvar CairoResult = class {\n  Ok;\n  Err;\n  constructor(variant, resultContent) {\n    if (!(variant in Object.values(CairoResultVariant))) {\n      throw new Error(\"Wrong variant! It should be CairoResultVariant.Ok or .Err.\");\n    }\n    if (variant === CairoResultVariant.Ok) {\n      this.Ok = resultContent;\n      this.Err = void 0;\n    } else {\n      this.Ok = void 0;\n      this.Err = resultContent;\n    }\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */\n  unwrap() {\n    if (!isUndefined(this.Ok)) {\n      return this.Ok;\n    }\n    if (!isUndefined(this.Err)) {\n      return this.Err;\n    }\n    throw new Error(\"Both Result.Ok and .Err are undefined. Not authorized.\");\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */\n  isOk() {\n    return !isUndefined(this.Ok);\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */\n  isErr() {\n    return !isUndefined(this.Err);\n  }\n};\n\n// src/utils/calldata/formatter.ts\nvar guard = {\n  /**\n   * Checks if the data is a BigInt (BN) and throws an error if not.\n   *\n   * @param {Record<string, any>} data - The data object containing the key to check.\n   * @param {Record<string, any>} type - The type definition object.\n   * @param {string} key - The key in the data object to check.\n   * @throws {Error} If the data type does not match the expected BigInt (BN) type.\n   */\n  isBN: (data, type, key) => {\n    if (!isBigInt(data[key]))\n      throw new Error(\n        `Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`\n      );\n  },\n  /**\n   * Throws an error for unhandled formatter types.\n   *\n   * @param {Record<string, any>} data - The data object containing the key.\n   * @param {Record<string, any>} type - The type definition object.\n   * @param {string} key - The key in the data object to check.\n   * @throws {Error} If the formatter encounters an unknown type.\n   */\n  unknown: (data, type, key) => {\n    throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n  }\n};\nfunction formatter(data, type, sameType) {\n  return Object.entries(data).reduce(\n    (acc, [key, value]) => {\n      const elType = sameType ?? type[key];\n      if (!(key in type) && !sameType) {\n        acc[key] = value;\n        return acc;\n      }\n      if (elType === \"string\") {\n        if (Array.isArray(data[key])) {\n          const arrayStr = formatter(\n            data[key],\n            data[key].map((_) => elType)\n          );\n          acc[key] = Object.values(arrayStr).join(\"\");\n          return acc;\n        }\n        guard.isBN(data, type, key);\n        acc[key] = decodeShortString(value);\n        return acc;\n      }\n      if (elType === \"number\") {\n        guard.isBN(data, type, key);\n        acc[key] = Number(value);\n        return acc;\n      }\n      if (typeof elType === \"function\") {\n        acc[key] = elType(value);\n        return acc;\n      }\n      if (Array.isArray(elType)) {\n        const arrayObj = formatter(data[key], elType, elType[0]);\n        acc[key] = Object.values(arrayObj);\n        return acc;\n      }\n      if (isObject(elType)) {\n        acc[key] = formatter(data[key], elType);\n        return acc;\n      }\n      guard.unknown(data, type, key);\n      return acc;\n    },\n    {}\n  );\n}\n\n// src/utils/calldata/parser/parser-0-1.1.0.ts\nvar AbiParser1 = class {\n  abi;\n  constructor(abi) {\n    this.abi = abi;\n  }\n  /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  methodInputsLength(abiMethod) {\n    return abiMethod.inputs.reduce((acc, input) => !isLen(input.name) ? acc + 1 : acc, 0);\n  }\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  getMethod(name) {\n    return this.abi.find((it) => it.name === name);\n  }\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  getLegacyFormat() {\n    return this.abi;\n  }\n};\n\n// src/utils/calldata/parser/parser-2.0.0.ts\nvar AbiParser2 = class {\n  abi;\n  constructor(abi) {\n    this.abi = abi;\n  }\n  /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  methodInputsLength(abiMethod) {\n    return abiMethod.inputs.length;\n  }\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  getMethod(name) {\n    const intf = this.abi.find(\n      (it) => it.type === \"interface\"\n    );\n    return intf?.items?.find((it) => it.name === name);\n  }\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  getLegacyFormat() {\n    return this.abi.flatMap((it) => {\n      return it.type === \"interface\" ? it.items : it;\n    });\n  }\n};\n\n// src/utils/calldata/parser/index.ts\nfunction createAbiParser(abi) {\n  const version = getAbiVersion(abi);\n  if (version === 0 || version === 1) {\n    return new AbiParser1(abi);\n  }\n  if (version === 2) {\n    return new AbiParser2(abi);\n  }\n  throw Error(`Unsupported ABI version ${version}`);\n}\nfunction getAbiVersion(abi) {\n  if (abi.find((it) => it.type === \"interface\")) return 2;\n  if (isCairo1Abi(abi)) return 1;\n  return 0;\n}\nfunction isNoConstructorValid(method, argsCalldata, abiMethod) {\n  return method === \"constructor\" && !abiMethod && !argsCalldata.length;\n}\n\n// src/utils/calldata/tuple.ts\nfunction parseNamedTuple(namedTuple) {\n  const name = namedTuple.substring(0, namedTuple.indexOf(\":\"));\n  const type = namedTuple.substring(name.length + \":\".length);\n  return { name, type };\n}\nfunction parseSubTuple(s) {\n  if (!s.includes(\"(\")) return { subTuple: [], result: s };\n  const subTuple = [];\n  let result = \"\";\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === \"(\") {\n      let counter = 1;\n      const lBracket = i;\n      i++;\n      while (counter) {\n        if (s[i] === \")\") counter--;\n        if (s[i] === \"(\") counter++;\n        i++;\n      }\n      subTuple.push(s.substring(lBracket, i));\n      result += \" \";\n      i--;\n    } else {\n      result += s[i];\n    }\n    i++;\n  }\n  return {\n    subTuple,\n    result\n  };\n}\nfunction extractCairo0Tuple(type) {\n  const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n  const { subTuple, result } = parseSubTuple(cleanType);\n  let recomposed = result.split(\",\").map((it) => {\n    return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n  });\n  if (isTypeNamedTuple(type)) {\n    recomposed = recomposed.reduce((acc, it) => {\n      return acc.concat(parseNamedTuple(it));\n    }, []);\n  }\n  return recomposed;\n}\nfunction getClosureOffset(input, open, close) {\n  for (let i = 0, counter = 0; i < input.length; i++) {\n    if (input[i] === open) {\n      counter++;\n    } else if (input[i] === close && --counter === 0) {\n      return i;\n    }\n  }\n  return Number.POSITIVE_INFINITY;\n}\nfunction extractCairo1Tuple(type) {\n  const input = type.slice(1, -1);\n  const result = [];\n  let currentIndex = 0;\n  let limitIndex;\n  while (currentIndex < input.length) {\n    switch (true) {\n      // Tuple\n      case input[currentIndex] === \"(\": {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), \"(\", \")\") + 1;\n        break;\n      }\n      case (input.startsWith(\"core::result::Result::<\", currentIndex) || input.startsWith(\"core::array::Array::<\", currentIndex) || input.startsWith(\"core::option::Option::<\", currentIndex)): {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), \"<\", \">\") + 1;\n        break;\n      }\n      default: {\n        const commaIndex = input.indexOf(\",\", currentIndex);\n        limitIndex = commaIndex !== -1 ? commaIndex : Number.POSITIVE_INFINITY;\n      }\n    }\n    result.push(input.slice(currentIndex, limitIndex));\n    currentIndex = limitIndex + 2;\n  }\n  return result;\n}\nfunction extractTupleMemberTypes(type) {\n  return isCairo1Type(type) ? extractCairo1Tuple(type) : extractCairo0Tuple(type);\n}\n\n// src/utils/cairoDataTypes/fixedArray.ts\nvar CairoFixedArray = class _CairoFixedArray {\n  /**\n   * JS array representing a Cairo fixed array.\n   */\n  content;\n  /**\n   * Cairo fixed array type.\n   */\n  arrayType;\n  /**\n   * Create an instance representing a Cairo fixed Array.\n   * @param {any[]} content JS array representing a Cairo fixed array.\n   * @param {string} arrayType Cairo fixed array type.\n   */\n  constructor(content, arrayType) {\n    assert(\n      _CairoFixedArray.isTypeFixedArray(arrayType),\n      `The type ${arrayType} is not a Cairo fixed array. Needs [type; length].`\n    );\n    try {\n      _CairoFixedArray.getFixedArrayType(arrayType);\n    } catch {\n      throw new Error(\n        `The type ${arrayType} do not includes any content type. Needs [type; length].`\n      );\n    }\n    try {\n      _CairoFixedArray.getFixedArraySize(arrayType);\n    } catch {\n      throw new Error(\n        `The type ${arrayType} type do not includes any length. Needs [type; length].`\n      );\n    }\n    assert(\n      _CairoFixedArray.getFixedArraySize(arrayType) === content.length,\n      `The ABI type ${arrayType} is expecting ${_CairoFixedArray.getFixedArraySize(arrayType)} items. ${content.length} items provided.`\n    );\n    this.content = content;\n    this.arrayType = arrayType;\n  }\n  /**\n   * Retrieves the array size from the given type string representing a Cairo fixed array.\n   * @param {string} type - The Cairo fixed array type.\n   * @returns {number} The array size.\n   * @example\n   * ```typescript\n   * const result = CairoFixedArray.getFixedArraySize(\"[core::integer::u32; 8]\");\n   * // result = 8\n   * ```\n   */\n  static getFixedArraySize(type) {\n    const matchArray = type.match(/(?<=; )\\d+(?=\\])/);\n    if (matchArray === null)\n      throw new Error(`ABI type ${type} do not includes a valid number after ';' character.`);\n    return Number(matchArray[0]);\n  }\n  /**\n   * Retrieves the Cairo fixed array size from the CairoFixedArray instance.\n   * @returns {number} The fixed array size.\n   * @example\n   * ```typescript\n   * const fArray = new CairoFixedArray([10,20,30], \"[core::integer::u32; 3]\");\n   * const result = fArray.getFixedArraySize();\n   * // result = 3\n   * ```\n   */\n  getFixedArraySize() {\n    return _CairoFixedArray.getFixedArraySize(this.arrayType);\n  }\n  /**\n   * Retrieve the Cairo content type from a Cairo fixed array type.\n   * @param {string} type - The type string.\n   * @returns {string} The fixed-array type.\n   * @example\n   * ```typescript\n   * const result = CairoFixedArray.getFixedArrayType(\"[core::integer::u32; 8]\");\n   * // result = \"core::integer::u32\"\n   * ```\n   */\n  static getFixedArrayType = (type) => {\n    const matchArray = type.match(/(?<=\\[).+(?=;)/);\n    if (matchArray === null)\n      throw new Error(`ABI type ${type} do not includes a valid type of data.`);\n    return matchArray[0];\n  };\n  /**\n   * Retrieve the Cairo content type of the Cairo fixed array.\n   * @returns {string} The fixed-array content type.\n   * @example\n   * ```typescript\n   * const fArray = new CairoFixedArray([10,20,30], \"[core::integer::u32; 3]\");\n   * const result = fArray.getFixedArrayType();\n   * // result = \"core::integer::u32\"\n   * ```\n   */\n  getFixedArrayType() {\n    return _CairoFixedArray.getFixedArrayType(this.arrayType);\n  }\n  /**\n   * Create an object from a Cairo fixed array.\n   * Be sure to have an array length conform to the ABI.\n   * To be used with CallData.compile().\n   * @param {Array<any>} input JS array representing a Cairo fixed array.\n   * @returns {Object} a specific struct representing a fixed Array.\n   * @example\n   * ```typescript\n   * const result = CairoFixedArray.compile([10,20,30]);\n   * // result = { '0': 10, '1': 20, '2': 30 }\n   * ```\n   */\n  static compile(input) {\n    return input.reduce((acc, item, idx) => {\n      acc[idx] = item;\n      return acc;\n    }, {});\n  }\n  /**\n   * Generate an object from the Cairo fixed array instance.\n   * To be used with CallData.compile().\n   * @returns a specific struct representing a fixed array.\n   * @example\n   * ```typescript\n   * const fArray = new CairoFixedArray([10,20,30], \"[core::integer::u32; 3]\");\n   * const result = fArray.compile();\n   * // result = { '0': 10, '1': 20, '2': 30 }\n   * ```\n   */\n  compile() {\n    return _CairoFixedArray.compile(this.content);\n  }\n  /**\n   * Checks if the given Cairo type is a fixed-array type.\n   *\n   * @param {string} type - The type to check.\n   * @returns - `true` if the type is a fixed array type, `false` otherwise.\n   * ```typescript\n   * const result = CairoFixedArray.isTypeFixedArray(\"[core::integer::u32; 8]\");\n   * // result = true\n   */\n  static isTypeFixedArray(type) {\n    return /^\\[.*;\\s.*\\]$/.test(type) && /(?<=\\[).+(?=;)/.test(type) && /(?<=; )\\d+(?=\\])/.test(type);\n  }\n};\n\n// src/utils/calldata/propertyOrder.ts\nfunction errorU256(key) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`\n  );\n}\nfunction errorU512(key) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint512 object without the 'limb0' to 'limb3' keys.`\n  );\n}\nfunction orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {\n  const orderInput = (unorderedItem, abiType) => {\n    if (CairoFixedArray.isTypeFixedArray(abiType)) {\n      return orderFixedArray(unorderedItem, abiType);\n    }\n    if (isTypeArray(abiType)) {\n      return orderArray(unorderedItem, abiType);\n    }\n    if (isTypeEnum(abiType, enums)) {\n      const abiObj = enums[abiType];\n      return orderEnum(unorderedItem, abiObj);\n    }\n    if (isTypeTuple(abiType)) {\n      return orderTuple(unorderedItem, abiType);\n    }\n    if (isTypeEthAddress(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeNonZero(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeByteArray(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeU96(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeSecp256k1Point(abiType)) {\n      return unorderedItem;\n    }\n    if (CairoUint256.isAbiType(abiType)) {\n      const u256 = unorderedItem;\n      if (typeof u256 !== \"object\") {\n        return u256;\n      }\n      if (!(\"low\" in u256 && \"high\" in u256)) {\n        throw errorU256(abiType);\n      }\n      return { low: u256.low, high: u256.high };\n    }\n    if (CairoUint512.isAbiType(abiType)) {\n      const u512 = unorderedItem;\n      if (typeof u512 !== \"object\") {\n        return u512;\n      }\n      if (![\"limb0\", \"limb1\", \"limb2\", \"limb3\"].every((key) => key in u512)) {\n        throw errorU512(abiType);\n      }\n      return { limb0: u512.limb0, limb1: u512.limb1, limb2: u512.limb2, limb3: u512.limb3 };\n    }\n    if (isTypeStruct(abiType, structs)) {\n      const abiOfStruct = structs[abiType].members;\n      return orderStruct(unorderedItem, abiOfStruct);\n    }\n    return unorderedItem;\n  };\n  const orderStruct = (unorderedObject2, abiObject) => {\n    const orderedObject2 = abiObject.reduce((orderedObject, abiParam) => {\n      const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {\n        enumerable: true,\n        value: value ?? unorderedObject2[abiParam.name]\n      });\n      if (unorderedObject2[abiParam.name] === \"undefined\") {\n        if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n          throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n        }\n      }\n      setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  };\n  function orderArray(myArray, abiParam) {\n    const typeInArray = getArrayType(abiParam);\n    if (isString(myArray)) {\n      return myArray;\n    }\n    return myArray.map((myElem) => orderInput(myElem, typeInArray));\n  }\n  function orderFixedArray(input, abiParam) {\n    const typeInFixedArray = CairoFixedArray.getFixedArrayType(abiParam);\n    const arraySize = CairoFixedArray.getFixedArraySize(abiParam);\n    if (Array.isArray(input)) {\n      if (arraySize !== input.length) {\n        throw new Error(\n          `ABI type ${abiParam}: array provided do not includes  ${arraySize} items. ${input.length} items provided.`\n        );\n      }\n      return input.map((myElem) => orderInput(myElem, typeInFixedArray));\n    }\n    if (arraySize !== Object.keys(input).length) {\n      throw new Error(\n        `ABI type ${abiParam}: object provided do not includes  ${arraySize} properties. ${Object.keys(input).length} items provided.`\n      );\n    }\n    return orderInput(input, typeInFixedArray);\n  }\n  function orderTuple(unorderedObject2, abiParam) {\n    const typeList = extractTupleMemberTypes(abiParam);\n    const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index) => {\n      const myObjKeys = Object.keys(unorderedObject2);\n      const setProperty = (value) => Object.defineProperty(orderedObject, index.toString(), {\n        enumerable: true,\n        value: value ?? unorderedObject2[myObjKeys[index]]\n      });\n      const abiType = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX;\n      setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  }\n  const orderEnum = (unorderedObject2, abiObject) => {\n    if (isTypeResult(abiObject.name)) {\n      const unorderedResult = unorderedObject2;\n      const resultOkType = abiObject.name.substring(\n        abiObject.name.indexOf(\"<\") + 1,\n        abiObject.name.lastIndexOf(\",\")\n      );\n      const resultErrType = abiObject.name.substring(\n        abiObject.name.indexOf(\",\") + 1,\n        abiObject.name.lastIndexOf(\">\")\n      );\n      if (unorderedResult.isOk()) {\n        return new CairoResult(\n          CairoResultVariant.Ok,\n          orderInput(unorderedObject2.unwrap(), resultOkType)\n        );\n      }\n      return new CairoResult(\n        CairoResultVariant.Err,\n        orderInput(unorderedObject2.unwrap(), resultErrType)\n      );\n    }\n    if (isTypeOption(abiObject.name)) {\n      const unorderedOption = unorderedObject2;\n      const resultSomeType = abiObject.name.substring(\n        abiObject.name.indexOf(\"<\") + 1,\n        abiObject.name.lastIndexOf(\">\")\n      );\n      if (unorderedOption.isSome()) {\n        return new CairoOption(\n          CairoOptionVariant.Some,\n          orderInput(unorderedOption.unwrap(), resultSomeType)\n        );\n      }\n      return new CairoOption(CairoOptionVariant.None, {});\n    }\n    const unorderedCustomEnum = unorderedObject2;\n    const variants = Object.entries(unorderedCustomEnum.variant);\n    const newEntries = variants.map((variant) => {\n      if (isUndefined(variant[1])) {\n        return variant;\n      }\n      const variantType = abiObject.type.substring(\n        abiObject.type.lastIndexOf(\"<\") + 1,\n        abiObject.type.lastIndexOf(\">\")\n      );\n      if (variantType === \"()\") {\n        return variant;\n      }\n      return [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)];\n    });\n    return new CairoCustomEnum(Object.fromEntries(newEntries));\n  };\n  const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam) => {\n    const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {\n      enumerable: true,\n      value\n    });\n    if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n      return orderedObject;\n    }\n    setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n    return orderedObject;\n  }, {});\n  return finalOrderedObject;\n}\n\n// src/utils/calldata/requestParser.ts\nfunction parseBaseTypes(type, val) {\n  switch (true) {\n    case CairoUint256.isAbiType(type):\n      return new CairoUint256(val).toApiRequest();\n    case CairoUint512.isAbiType(type):\n      return new CairoUint512(val).toApiRequest();\n    case isTypeBytes31(type):\n      return encodeShortString(val.toString());\n    case isTypeSecp256k1Point(type): {\n      const pubKeyETH = removeHexPrefix(toHex(val)).padStart(128, \"0\");\n      const pubKeyETHy = uint256(addHexPrefix(pubKeyETH.slice(-64)));\n      const pubKeyETHx = uint256(addHexPrefix(pubKeyETH.slice(0, -64)));\n      return [\n        felt(pubKeyETHx.low),\n        felt(pubKeyETHx.high),\n        felt(pubKeyETHy.low),\n        felt(pubKeyETHy.high)\n      ];\n    }\n    default:\n      return felt(val);\n  }\n}\nfunction parseTuple(element, typeStr) {\n  const memberTypes = extractTupleMemberTypes(typeStr);\n  const elements = Object.values(element);\n  if (elements.length !== memberTypes.length) {\n    throw Error(\n      `ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements}\n      expected: ${memberTypes}`\n    );\n  }\n  return memberTypes.map((it, dx) => {\n    return {\n      element: elements[dx],\n      type: it.type ?? it\n    };\n  });\n}\nfunction parseByteArray(element) {\n  const myByteArray = byteArrayFromString(element);\n  return [\n    myByteArray.data.length.toString(),\n    ...myByteArray.data.map((bn) => bn.toString()),\n    myByteArray.pending_word.toString(),\n    myByteArray.pending_word_len.toString()\n  ];\n}\nfunction parseCalldataValue(element, type, structs, enums) {\n  if (element === void 0) {\n    throw Error(`Missing parameter for type ${type}`);\n  }\n  if (CairoFixedArray.isTypeFixedArray(type)) {\n    const arrayType = CairoFixedArray.getFixedArrayType(type);\n    let values = [];\n    if (Array.isArray(element)) {\n      const array = new CairoFixedArray(element, type);\n      values = array.content;\n    } else if (typeof element === \"object\") {\n      values = Object.values(element);\n      assert(\n        values.length === CairoFixedArray.getFixedArraySize(type),\n        `ABI type ${type}: object provided do not includes  ${CairoFixedArray.getFixedArraySize(type)} items. ${values.length} items provided.`\n      );\n    } else {\n      throw new Error(`ABI type ${type}: not an Array representing a cairo.fixedArray() provided.`);\n    }\n    return values.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n    }, []);\n  }\n  if (Array.isArray(element)) {\n    const result = [];\n    result.push(felt(element.length));\n    const arrayType = getArrayType(type);\n    return element.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n    }, result);\n  }\n  if (structs[type] && structs[type].members.length) {\n    if (CairoUint256.isAbiType(type)) {\n      return new CairoUint256(element).toApiRequest();\n    }\n    if (CairoUint512.isAbiType(type)) {\n      return new CairoUint512(element).toApiRequest();\n    }\n    if (isTypeEthAddress(type)) return parseBaseTypes(type, element);\n    if (isTypeByteArray(type)) return parseByteArray(element);\n    const { members } = structs[type];\n    const subElement = element;\n    return members.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n    }, []);\n  }\n  if (isTypeTuple(type)) {\n    const tupled = parseTuple(element, type);\n    return tupled.reduce((acc, it) => {\n      const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n      return acc.concat(parsedData);\n    }, []);\n  }\n  if (CairoUint256.isAbiType(type)) {\n    return new CairoUint256(element).toApiRequest();\n  }\n  if (CairoUint512.isAbiType(type)) {\n    return new CairoUint512(element).toApiRequest();\n  }\n  if (isTypeEnum(type, enums)) {\n    const { variants } = enums[type];\n    if (isTypeOption(type)) {\n      const myOption = element;\n      if (myOption.isSome()) {\n        const listTypeVariant2 = variants.find((variant) => variant.name === \"Some\");\n        if (isUndefined(listTypeVariant2)) {\n          throw Error(`Error in abi : Option has no 'Some' variant.`);\n        }\n        const typeVariantSome = listTypeVariant2.type;\n        if (typeVariantSome === \"()\") {\n          return CairoOptionVariant.Some.toString();\n        }\n        const parsedParameter2 = parseCalldataValue(\n          myOption.unwrap(),\n          typeVariantSome,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter2)) {\n          return [CairoOptionVariant.Some.toString(), ...parsedParameter2];\n        }\n        return [CairoOptionVariant.Some.toString(), parsedParameter2];\n      }\n      return CairoOptionVariant.None.toString();\n    }\n    if (isTypeResult(type)) {\n      const myResult = element;\n      if (myResult.isOk()) {\n        const listTypeVariant3 = variants.find((variant) => variant.name === \"Ok\");\n        if (isUndefined(listTypeVariant3)) {\n          throw Error(`Error in abi : Result has no 'Ok' variant.`);\n        }\n        const typeVariantOk = listTypeVariant3.type;\n        if (typeVariantOk === \"()\") {\n          return CairoResultVariant.Ok.toString();\n        }\n        const parsedParameter3 = parseCalldataValue(\n          myResult.unwrap(),\n          typeVariantOk,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter3)) {\n          return [CairoResultVariant.Ok.toString(), ...parsedParameter3];\n        }\n        return [CairoResultVariant.Ok.toString(), parsedParameter3];\n      }\n      const listTypeVariant2 = variants.find((variant) => variant.name === \"Err\");\n      if (isUndefined(listTypeVariant2)) {\n        throw Error(`Error in abi : Result has no 'Err' variant.`);\n      }\n      const typeVariantErr = listTypeVariant2.type;\n      if (typeVariantErr === \"()\") {\n        return CairoResultVariant.Err.toString();\n      }\n      const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n      if (Array.isArray(parsedParameter2)) {\n        return [CairoResultVariant.Err.toString(), ...parsedParameter2];\n      }\n      return [CairoResultVariant.Err.toString(), parsedParameter2];\n    }\n    const myEnum = element;\n    const activeVariant = myEnum.activeVariant();\n    const listTypeVariant = variants.find((variant) => variant.name === activeVariant);\n    if (isUndefined(listTypeVariant)) {\n      throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n    }\n    const typeActiveVariant = listTypeVariant.type;\n    const numActiveVariant = variants.findIndex((variant) => variant.name === activeVariant);\n    if (typeActiveVariant === \"()\") {\n      return numActiveVariant.toString();\n    }\n    const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n    if (Array.isArray(parsedParameter)) {\n      return [numActiveVariant.toString(), ...parsedParameter];\n    }\n    return [numActiveVariant.toString(), parsedParameter];\n  }\n  if (isTypeNonZero(type)) {\n    return parseBaseTypes(getArrayType(type), element);\n  }\n  if (typeof element === \"object\") {\n    throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n  }\n  return parseBaseTypes(type, element);\n}\nfunction parseCalldataField(argsIterator, input, structs, enums) {\n  const { name, type } = input;\n  let { value } = argsIterator.next();\n  switch (true) {\n    // Fixed array\n    case CairoFixedArray.isTypeFixedArray(type):\n      if (!Array.isArray(value) && !(typeof value === \"object\")) {\n        throw Error(`ABI expected parameter ${name} to be an array or an object, got ${value}`);\n      }\n      return parseCalldataValue(value, input.type, structs, enums);\n    // Normal Array\n    case isTypeArray(type):\n      if (!Array.isArray(value) && !isText(value)) {\n        throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n      }\n      if (isString(value)) {\n        value = splitLongString(value);\n      }\n      return parseCalldataValue(value, input.type, structs, enums);\n    case isTypeNonZero(type):\n      return parseBaseTypes(getArrayType(type), value);\n    case isTypeEthAddress(type):\n      return parseBaseTypes(type, value);\n    // Struct or Tuple\n    case (isTypeStruct(type, structs) || isTypeTuple(type) || CairoUint256.isAbiType(type)):\n      return parseCalldataValue(value, type, structs, enums);\n    // Enums\n    case isTypeEnum(type, enums):\n      return parseCalldataValue(\n        value,\n        type,\n        structs,\n        enums\n      );\n    // Felt or unhandled\n    default:\n      return parseBaseTypes(type, value);\n  }\n}\n\n// src/utils/calldata/responseParser.ts\nfunction parseBaseTypes2(type, it) {\n  let temp;\n  switch (true) {\n    case isTypeBool(type):\n      temp = it.next().value;\n      return Boolean(BigInt(temp));\n    case CairoUint256.isAbiType(type):\n      const low = it.next().value;\n      const high = it.next().value;\n      return new CairoUint256(low, high).toBigInt();\n    case CairoUint512.isAbiType(type):\n      const limb0 = it.next().value;\n      const limb1 = it.next().value;\n      const limb2 = it.next().value;\n      const limb3 = it.next().value;\n      return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n    case isTypeEthAddress(type):\n      temp = it.next().value;\n      return BigInt(temp);\n    case isTypeBytes31(type):\n      temp = it.next().value;\n      return decodeShortString(temp);\n    case isTypeSecp256k1Point(type):\n      const xLow = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const xHigh = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const yLow = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const yHigh = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const pubK = BigInt(addHexPrefix(xHigh + xLow + yHigh + yLow));\n      return pubK;\n    default:\n      temp = it.next().value;\n      return BigInt(temp);\n  }\n}\nfunction parseResponseValue(responseIterator, element, structs, enums) {\n  if (element.type === \"()\") {\n    return {};\n  }\n  if (CairoUint256.isAbiType(element.type)) {\n    const low = responseIterator.next().value;\n    const high = responseIterator.next().value;\n    return new CairoUint256(low, high).toBigInt();\n  }\n  if (CairoUint512.isAbiType(element.type)) {\n    const limb0 = responseIterator.next().value;\n    const limb1 = responseIterator.next().value;\n    const limb2 = responseIterator.next().value;\n    const limb3 = responseIterator.next().value;\n    return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n  }\n  if (isTypeByteArray(element.type)) {\n    const parsedBytes31Arr = [];\n    const bytes31ArrLen = BigInt(responseIterator.next().value);\n    while (parsedBytes31Arr.length < bytes31ArrLen) {\n      parsedBytes31Arr.push(toHex(responseIterator.next().value));\n    }\n    const pending_word = toHex(responseIterator.next().value);\n    const pending_word_len = BigInt(responseIterator.next().value);\n    const myByteArray = {\n      data: parsedBytes31Arr,\n      pending_word,\n      pending_word_len\n    };\n    return stringFromByteArray(myByteArray);\n  }\n  if (CairoFixedArray.isTypeFixedArray(element.type)) {\n    const parsedDataArr = [];\n    const el = { name: \"\", type: CairoFixedArray.getFixedArrayType(element.type) };\n    const arraySize = CairoFixedArray.getFixedArraySize(element.type);\n    while (parsedDataArr.length < arraySize) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n  if (isTypeArray(element.type)) {\n    const parsedDataArr = [];\n    const el = { name: \"\", type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value);\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n  if (isTypeNonZero(element.type)) {\n    const el = { name: \"\", type: getArrayType(element.type) };\n    return parseResponseValue(responseIterator, el, structs, enums);\n  }\n  if (structs && element.type in structs && structs[element.type]) {\n    if (isTypeEthAddress(element.type)) {\n      return parseBaseTypes2(element.type, responseIterator);\n    }\n    return structs[element.type].members.reduce((acc, el) => {\n      acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {});\n  }\n  if (enums && element.type in enums && enums[element.type]) {\n    const variantNum = Number(responseIterator.next().value);\n    const rawEnum = enums[element.type].variants.reduce((acc, variant, num) => {\n      if (num === variantNum) {\n        acc[variant.name] = parseResponseValue(\n          responseIterator,\n          { name: \"\", type: variant.type },\n          structs,\n          enums\n        );\n        return acc;\n      }\n      acc[variant.name] = void 0;\n      return acc;\n    }, {});\n    if (element.type.startsWith(\"core::option::Option\")) {\n      const content = variantNum === CairoOptionVariant.Some ? rawEnum.Some : void 0;\n      return new CairoOption(variantNum, content);\n    }\n    if (element.type.startsWith(\"core::result::Result\")) {\n      let content;\n      if (variantNum === CairoResultVariant.Ok) {\n        content = rawEnum.Ok;\n      } else {\n        content = rawEnum.Err;\n      }\n      return new CairoResult(variantNum, content);\n    }\n    const customEnum = new CairoCustomEnum(rawEnum);\n    return customEnum;\n  }\n  if (isTypeTuple(element.type)) {\n    const memberTypes = extractTupleMemberTypes(element.type);\n    return memberTypes.reduce((acc, it, idx) => {\n      const name = it?.name ? it.name : idx;\n      const type = it?.type ? it.type : it;\n      const el = { name, type };\n      acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {});\n  }\n  if (isTypeArray(element.type)) {\n    const parsedDataArr = [];\n    const el = { name: \"\", type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value);\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n  return parseBaseTypes2(element.type, responseIterator);\n}\nfunction responseParser(responseIterator, output, structs, enums, parsedResult) {\n  const { name, type } = output;\n  let temp;\n  switch (true) {\n    case isLen(name):\n      temp = responseIterator.next().value;\n      return BigInt(temp);\n    case (structs && type in structs || isTypeTuple(type)):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    case (enums && isTypeEnum(type, enums)):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    case CairoFixedArray.isTypeFixedArray(type):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    case isTypeArray(type):\n      if (isCairo1Type(type)) {\n        return parseResponseValue(responseIterator, output, structs, enums);\n      }\n      const parsedDataArr = [];\n      if (parsedResult && parsedResult[`${name}_len`]) {\n        const arrLen = parsedResult[`${name}_len`];\n        while (parsedDataArr.length < arrLen) {\n          parsedDataArr.push(\n            parseResponseValue(\n              responseIterator,\n              { name, type: output.type.replace(\"*\", \"\") },\n              structs,\n              enums\n            )\n          );\n        }\n      }\n      return parsedDataArr;\n    case isTypeNonZero(type):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    default:\n      return parseBaseTypes2(type, responseIterator);\n  }\n}\n\n// src/utils/calldata/validate.ts\nvar validateFelt = (parameter, input) => {\n  assert(\n    isString(parameter) || isNumber(parameter) || isBigInt(parameter),\n    `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`\n  );\n  if (isString(parameter) && !isHex(parameter)) return;\n  const param = BigInt(parameter.toString(10));\n  assert(\n    // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n  );\n};\nvar validateBytes31 = (parameter, input) => {\n  assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n  assert(\n    parameter.length < 32,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be a string of less than 32 characters.`\n  );\n};\nvar validateByteArray = (parameter, input) => {\n  assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n};\nvar validateUint = (parameter, input) => {\n  if (isNumber(parameter)) {\n    assert(\n      parameter <= Number.MAX_SAFE_INTEGER,\n      \"Validation: Parameter is too large to be typed as Number use (BigInt or String)\"\n    );\n  }\n  assert(\n    isString(parameter) || isNumber(parameter) || isBigInt(parameter) || isObject(parameter) && \"low\" in parameter && \"high\" in parameter || isObject(parameter) && [\"limb0\", \"limb1\", \"limb2\", \"limb3\"].every((key) => key in parameter),\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`\n  );\n  let param;\n  switch (input.type) {\n    case Uint.u256:\n      param = new CairoUint256(parameter).toBigInt();\n      break;\n    case Uint.u512:\n      param = new CairoUint512(parameter).toBigInt();\n      break;\n    default:\n      param = toBigInt(parameter);\n  }\n  switch (input.type) {\n    case Uint.u8:\n      assert(\n        param >= 0n && param <= 255n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`\n      );\n      break;\n    case Uint.u16:\n      assert(\n        param >= 0n && param <= 65535n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`\n      );\n      break;\n    case Uint.u32:\n      assert(\n        param >= 0n && param <= 4294967295n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`\n      );\n      break;\n    case Uint.u64:\n      assert(\n        param >= 0n && param <= 2n ** 64n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`\n      );\n      break;\n    case Uint.u128:\n      assert(\n        param >= 0n && param <= 2n ** 128n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`\n      );\n      break;\n    case Uint.u256:\n      assert(\n        param >= 0n && param <= 2n ** 256n - 1n,\n        `Validate: arg ${input.name} is ${input.type} should be in range 0 - 2^256-1`\n      );\n      break;\n    case Uint.u512:\n      assert(\n        CairoUint512.is(param),\n        `Validate: arg ${input.name} is ${input.type} should be in range 0 - 2^512-1`\n      );\n      break;\n    case Literal.ClassHash:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    case Literal.ContractAddress:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    case Literal.Secp256k1Point: {\n      assert(\n        param >= 0n && param <= 2n ** 512n - 1n,\n        `Validate: arg ${input.name} must be ${input.type} : a 512 bits number.`\n      );\n      break;\n    }\n    case Literal.U96: {\n      assert(\n        param >= 0n && param <= 2n ** 96n - 1n,\n        `Validate: arg ${input.name} must be ${input.type} : a 96 bits number.`\n      );\n      break;\n    }\n    default:\n      break;\n  }\n};\nvar validateBool = (parameter, input) => {\n  assert(\n    isBoolean(parameter),\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`\n  );\n};\nvar validateStruct = (parameter, input, structs) => {\n  if (input.type === Uint.u256 || input.type === Uint.u512) {\n    validateUint(parameter, input);\n    return;\n  }\n  if (isTypeEthAddress(input.type)) {\n    assert(!isObject(parameter), `EthAddress type is waiting a BigNumberish. Got \"${parameter}\"`);\n    const param = BigInt(parameter.toString(10));\n    assert(\n      // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n      param >= 0n && param <= 2n ** 160n - 1n,\n      `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`\n    );\n    return;\n  }\n  assert(\n    isObject(parameter),\n    `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as a js object (not array)`\n  );\n  structs[input.type].members.forEach(({ name }) => {\n    assert(\n      Object.keys(parameter).includes(name),\n      `Validate: arg ${input.name} should have a property ${name}`\n    );\n  });\n};\nvar validateEnum = (parameter, input) => {\n  assert(\n    isObject(parameter),\n    `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as a js object (not array)`\n  );\n  const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n  const keys = [...Object.getOwnPropertyNames(parameter), ...methodsKeys];\n  if (isTypeOption(input.type) && keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n    return;\n  }\n  if (isTypeResult(input.type) && keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n    return;\n  }\n  if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n    return;\n  }\n  throw new Error(\n    `Validate Enum: argument ${input.name}, type ${input.type}, value received \"${parameter}\", is not an Enum.`\n  );\n};\nvar validateTuple = (parameter, input) => {\n  assert(isObject(parameter), `Validate: arg ${input.name} should be a tuple (defined as object)`);\n};\nvar validateArray = (parameterArray, input, structs, enums) => {\n  const isNormalArray = isTypeArray(input.type);\n  const baseType = isNormalArray ? getArrayType(input.type) : CairoFixedArray.getFixedArrayType(input.type);\n  if (isNormalArray && isTypeFelt(baseType) && isLongText(parameterArray)) {\n    return;\n  }\n  let parameter = [];\n  if (isNormalArray) {\n    assert(Array.isArray(parameterArray), `Validate: arg ${input.name} should be an Array`);\n    parameter = parameterArray;\n  } else {\n    switch (true) {\n      case Array.isArray(parameterArray):\n        parameter = parameterArray;\n        break;\n      case typeof parameterArray === \"object\":\n        parameter = Object.values(parameterArray);\n        break;\n      default:\n        throw new Error(`Validate: arg ${input.name} should be an Array or an object.`);\n    }\n  }\n  switch (true) {\n    case isTypeFelt(baseType):\n      parameter.forEach((param) => validateFelt(param, input));\n      break;\n    case isTypeTuple(baseType):\n      parameter.forEach((it) => validateTuple(it, { name: input.name, type: baseType }));\n      break;\n    case isTypeArray(baseType):\n      parameter.forEach(\n        (param) => validateArray(param, { name: \"\", type: baseType }, structs, enums)\n      );\n      break;\n    case isTypeStruct(baseType, structs):\n      parameter.forEach(\n        (it) => validateStruct(it, { name: input.name, type: baseType }, structs)\n      );\n      break;\n    case isTypeEnum(baseType, enums):\n      parameter.forEach((it) => validateEnum(it, { name: input.name, type: baseType }));\n      break;\n    case (isTypeUint(baseType) || isTypeLiteral(baseType)):\n      parameter.forEach((param) => validateUint(param, { name: \"\", type: baseType }));\n      break;\n    case isTypeBool(baseType):\n      parameter.forEach((param) => validateBool(param, input));\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n      );\n  }\n};\nvar validateNonZero = (parameter, input) => {\n  const baseType = getArrayType(input.type);\n  assert(\n    isTypeUint(baseType) && baseType !== CairoUint512.abiSelector || isTypeFelt(baseType),\n    `Validate: ${input.name} type is not authorized for NonZero type.`\n  );\n  switch (true) {\n    case isTypeFelt(baseType):\n      validateFelt(parameter, input);\n      assert(\n        BigInt(parameter.toString(10)) > 0,\n        \"Validate: value 0 is not authorized in NonZero felt252 type.\"\n      );\n      break;\n    case isTypeUint(baseType):\n      validateUint(parameter, { name: \"\", type: baseType });\n      switch (baseType) {\n        case Uint.u256:\n          assert(\n            new CairoUint256(parameter).toBigInt() > 0,\n            \"Validate: value 0 is not authorized in NonZero uint256 type.\"\n          );\n          break;\n        default:\n          assert(\n            toBigInt(parameter) > 0,\n            \"Validate: value 0 is not authorized in NonZero uint type.\"\n          );\n      }\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value \"${parameter}\"`\n      );\n  }\n};\nfunction validateFields(abiMethod, args, structs, enums) {\n  abiMethod.inputs.reduce((acc, input) => {\n    const parameter = args[acc];\n    switch (true) {\n      case isLen(input.name):\n        return acc;\n      case isTypeFelt(input.type):\n        validateFelt(parameter, input);\n        break;\n      case isTypeBytes31(input.type):\n        validateBytes31(parameter, input);\n        break;\n      case (isTypeUint(input.type) || isTypeLiteral(input.type)):\n        validateUint(parameter, input);\n        break;\n      case isTypeBool(input.type):\n        validateBool(parameter, input);\n        break;\n      case isTypeByteArray(input.type):\n        validateByteArray(parameter, input);\n        break;\n      case (isTypeArray(input.type) || CairoFixedArray.isTypeFixedArray(input.type)):\n        validateArray(parameter, input, structs, enums);\n        break;\n      case isTypeStruct(input.type, structs):\n        validateStruct(parameter, input, structs);\n        break;\n      case isTypeEnum(input.type, enums):\n        validateEnum(parameter, input);\n        break;\n      case isTypeTuple(input.type):\n        validateTuple(parameter, input);\n        break;\n      case isTypeNonZero(input.type):\n        validateNonZero(parameter, input);\n        break;\n      default:\n        throw new Error(\n          `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n        );\n    }\n    return acc + 1;\n  }, 0);\n}\n\n// src/utils/calldata/index.ts\nvar CallData = class _CallData {\n  abi;\n  parser;\n  structs;\n  enums;\n  constructor(abi) {\n    this.structs = _CallData.getAbiStruct(abi);\n    this.enums = _CallData.getAbiEnum(abi);\n    this.parser = createAbiParser(abi);\n    this.abi = this.parser.getLegacyFormat();\n  }\n  /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */\n  validate(type, method, args = []) {\n    if (type !== ValidateType.DEPLOY) {\n      const invocableFunctionNames = this.abi.filter((abi) => {\n        if (abi.type !== \"function\") return false;\n        const isView = abi.stateMutability === \"view\" || abi.state_mutability === \"view\";\n        return type === ValidateType.INVOKE ? !isView : isView;\n      }).map((abi) => abi.name);\n      assert(\n        invocableFunctionNames.includes(method),\n        `${type === ValidateType.INVOKE ? \"invocable\" : \"viewable\"} method not found in abi`\n      );\n    }\n    const abiMethod = this.abi.find(\n      (abi) => type === ValidateType.DEPLOY ? abi.name === method && abi.type === \"constructor\" : abi.name === method && abi.type === \"function\"\n    );\n    if (isNoConstructorValid(method, args, abiMethod)) {\n      return;\n    }\n    const inputsLength = this.parser.methodInputsLength(abiMethod);\n    if (args.length !== inputsLength) {\n      throw Error(\n        `Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`\n      );\n    }\n    validateFields(abiMethod, args, this.structs, this.enums);\n  }\n  /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param argsCalldata RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */\n  compile(method, argsCalldata) {\n    const abiMethod = this.abi.find((abiFunction) => abiFunction.name === method);\n    if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n      return [];\n    }\n    let args;\n    if (Array.isArray(argsCalldata)) {\n      args = argsCalldata;\n    } else {\n      const orderedObject = orderPropsByAbi(\n        argsCalldata,\n        abiMethod.inputs,\n        this.structs,\n        this.enums\n      );\n      args = Object.values(orderedObject);\n      validateFields(abiMethod, args, this.structs, this.enums);\n    }\n    const argsIterator = args[Symbol.iterator]();\n    const callArray = abiMethod.inputs.reduce(\n      (acc, input) => isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)),\n      []\n    );\n    Object.defineProperty(callArray, \"__compiled__\", {\n      enumerable: false,\n      writable: false,\n      value: true\n    });\n    return callArray;\n  }\n  /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */\n  static compile(rawArgs) {\n    const createTree = (obj) => {\n      const getEntries = (o, prefix = \".\") => {\n        const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;\n        return Object.entries(oe).flatMap(([k, v]) => {\n          let value = v;\n          if (k === \"entrypoint\") value = getSelectorFromName(value);\n          else if (isLongText(value)) value = byteArrayFromString(value);\n          const kk = Array.isArray(oe) && k === \"0\" ? \"$$len\" : k;\n          if (isBigInt(value)) return [[`${prefix}${kk}`, felt(value)]];\n          if (Object(value) === value) {\n            const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n            const keys = [...Object.getOwnPropertyNames(value), ...methodsKeys];\n            if (keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n              const myOption = value;\n              const variantNb = myOption.isSome() ? CairoOptionVariant.Some : CairoOptionVariant.None;\n              if (myOption.isSome())\n                return getEntries({ 0: variantNb, 1: myOption.unwrap() }, `${prefix}${kk}.`);\n              return [[`${prefix}${kk}`, felt(variantNb)]];\n            }\n            if (keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n              const myResult = value;\n              const variantNb = myResult.isOk() ? CairoResultVariant.Ok : CairoResultVariant.Err;\n              return getEntries({ 0: variantNb, 1: myResult.unwrap() }, `${prefix}${kk}.`);\n            }\n            if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n              const myEnum = value;\n              const activeVariant = myEnum.activeVariant();\n              const listVariants = Object.keys(myEnum.variant);\n              const activeVariantNb = listVariants.findIndex(\n                (variant) => variant === activeVariant\n              );\n              if (typeof myEnum.unwrap() === \"object\" && Object.keys(myEnum.unwrap()).length === 0) {\n                return [[`${prefix}${kk}`, felt(activeVariantNb)]];\n              }\n              return getEntries({ 0: activeVariantNb, 1: myEnum.unwrap() }, `${prefix}${kk}.`);\n            }\n            return getEntries(value, `${prefix}${kk}.`);\n          }\n          return [[`${prefix}${kk}`, felt(value)]];\n        });\n      };\n      const result = Object.fromEntries(getEntries(obj));\n      return result;\n    };\n    let callTreeArray;\n    if (!Array.isArray(rawArgs)) {\n      const callTree = createTree(rawArgs);\n      callTreeArray = Object.values(callTree);\n    } else {\n      const callObj = { ...rawArgs };\n      const callTree = createTree(callObj);\n      callTreeArray = Object.values(callTree);\n    }\n    Object.defineProperty(callTreeArray, \"__compiled__\", {\n      enumerable: false,\n      writable: false,\n      value: true\n    });\n    return callTreeArray;\n  }\n  /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */\n  parse(method, response) {\n    const { outputs } = this.abi.find((abi) => abi.name === method);\n    const responseIterator = response.flat()[Symbol.iterator]();\n    const parsed = outputs.flat().reduce((acc, output, idx) => {\n      const propName = output.name ?? idx;\n      acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n      if (acc[propName] && acc[`${propName}_len`]) {\n        delete acc[`${propName}_len`];\n      }\n      return acc;\n    }, {});\n    return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;\n  }\n  /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */\n  format(method, response, format) {\n    const parsed = this.parse(method, response);\n    return formatter(parsed, format);\n  }\n  /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */\n  static getAbiStruct(abi) {\n    return abi.filter((abiEntry) => abiEntry.type === \"struct\").reduce(\n      (acc, abiEntry) => ({\n        ...acc,\n        [abiEntry.name]: abiEntry\n      }),\n      {}\n    );\n  }\n  /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */\n  static getAbiEnum(abi) {\n    const fullEnumList = abi.filter((abiEntry) => abiEntry.type === \"enum\").reduce(\n      (acc, abiEntry) => ({\n        ...acc,\n        [abiEntry.name]: abiEntry\n      }),\n      {}\n    );\n    delete fullEnumList[\"core::bool\"];\n    return fullEnumList;\n  }\n  /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */\n  static toCalldata(rawCalldata = []) {\n    return _CallData.compile(rawCalldata);\n  }\n  /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */\n  static toHex(raw = []) {\n    const calldata = _CallData.compile(raw);\n    return calldata.map((it) => toHex(it));\n  }\n  /**\n   * Parse the elements of a contract response and structure them into one or several Result.\n   * In Cairo 0, arrays are not supported.\n   * @param typeCairo string or string[] - Cairo type name, ex : \"hello::hello::UserData\"\n   * @param response string[] - serialized data corresponding to typeCairo.\n   * @return Result or Result[] - parsed response corresponding to typeData.\n   * @example\n   * const res2=helloCallData.decodeParameters(\"hello::hello::UserData\",[\"0x123456\",\"0x1\"]);\n   * result = { address: 1193046n, is_claimed: true }\n   */\n  decodeParameters(typeCairo, response) {\n    const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [typeCairo];\n    const responseIterator = response.flat()[Symbol.iterator]();\n    const decodedArray = typeCairoArray.map(\n      (typeParam) => responseParser(\n        responseIterator,\n        { name: \"\", type: typeParam },\n        this.structs,\n        this.enums\n      )\n    );\n    return decodedArray.length === 1 ? decodedArray[0] : decodedArray;\n  }\n};\n\n// src/utils/hash/index.ts\nvar hash_exports = {};\n__export(hash_exports, {\n  calculateContractAddressFromHash: () => calculateContractAddressFromHash,\n  calculateDeclareTransactionHash: () => calculateDeclareTransactionHash3,\n  calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash3,\n  calculateInvokeTransactionHash: () => calculateInvokeTransactionHash2,\n  calculateL2MessageTxHash: () => calculateL2MessageTxHash,\n  computeCompiledClassHash: () => computeCompiledClassHash,\n  computeContractClassHash: () => computeContractClassHash,\n  computeHashOnElements: () => computeHashOnElements2,\n  computeHintedClassHash: () => computeHintedClassHash,\n  computeLegacyContractClassHash: () => computeLegacyContractClassHash,\n  computePedersenHash: () => computePedersenHash,\n  computePedersenHashOnElements: () => computePedersenHashOnElements,\n  computePoseidonHash: () => computePoseidonHash,\n  computePoseidonHashOnElements: () => computePoseidonHashOnElements,\n  computeSierraContractClassHash: () => computeSierraContractClassHash,\n  formatSpaces: () => formatSpaces,\n  getL2MessageHash: () => getL2MessageHash,\n  getSelector: () => getSelector,\n  getSelectorFromName: () => getSelectorFromName,\n  hashByteCodeSegments: () => hashByteCodeSegments,\n  keccakBn: () => keccakBn,\n  poseidon: () => _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_8__,\n  solidityUint256PackedKeccak256: () => solidityUint256PackedKeccak256,\n  starknetKeccak: () => starknetKeccak\n});\n\n\n// src/utils/hash/transactionHash/v2.ts\nvar v2_exports = {};\n__export(v2_exports, {\n  calculateDeclareTransactionHash: () => calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash,\n  calculateL2MessageTxHash: () => calculateL2MessageTxHash,\n  calculateTransactionHash: () => calculateTransactionHash,\n  calculateTransactionHashCommon: () => calculateTransactionHashCommon,\n  computeHashOnElements: () => computeHashOnElements\n});\n\n// src/utils/ec.ts\nvar ec_exports = {};\n__export(ec_exports, {\n  starkCurve: () => _scure_starknet__WEBPACK_IMPORTED_MODULE_6__,\n  weierstrass: () => _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_9__\n});\n\n\n\n// src/utils/hash/transactionHash/v2.ts\nfunction computeHashOnElements(data) {\n  return [...data, data.length].reduce((x, y) => _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.pedersen(toBigInt(x), toBigInt(y)), 0).toString();\n}\nfunction calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {\n  const calldataHash = computeHashOnElements(calldata);\n  const dataToHash = [\n    txHashPrefix,\n    version,\n    contractAddress,\n    entryPointSelector,\n    calldataHash,\n    maxFee,\n    chainId,\n    ...additionalData\n  ];\n  return computeHashOnElements(dataToHash);\n}\nfunction calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {\n  return calculateTransactionHashCommon(\n    \"0x6465636c617265\" /* DECLARE */,\n    version,\n    senderAddress,\n    0,\n    [classHash],\n    maxFee,\n    chainId,\n    [nonce, ...compiledClassHash ? [compiledClassHash] : []]\n  );\n}\nfunction calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {\n  const calldata = [classHash, salt, ...constructorCalldata];\n  return calculateTransactionHashCommon(\n    \"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\nfunction calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {\n  return calculateTransactionHashCommon(\n    \"0x696e766f6b65\" /* INVOKE */,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\nfunction calculateL2MessageTxHash(l1FromAddress, l2ToAddress, l2Selector, l2Calldata, l2ChainId, l1Nonce) {\n  const payload = [l1FromAddress, ...l2Calldata];\n  return calculateTransactionHashCommon(\n    \"0x6c315f68616e646c6572\" /* L1_HANDLER */,\n    0,\n    l2ToAddress,\n    getSelector(l2Selector),\n    payload,\n    0,\n    l2ChainId,\n    [l1Nonce]\n  );\n}\n\n// src/utils/hash/transactionHash/v3.ts\nvar v3_exports = {};\n__export(v3_exports, {\n  calculateDeclareTransactionHash: () => calculateDeclareTransactionHash2,\n  calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash2,\n  calculateInvokeTransactionHash: () => calculateInvokeTransactionHash,\n  calculateTransactionHashCommon: () => calculateTransactionHashCommon2,\n  encodeResourceBoundsL1: () => encodeResourceBoundsL1,\n  encodeResourceBoundsL2: () => encodeResourceBoundsL2,\n  hashDAMode: () => hashDAMode,\n  hashFeeField: () => hashFeeField\n});\n\nvar AToBI = (array) => array.map((it) => BigInt(it));\nvar DATA_AVAILABILITY_MODE_BITS = 32n;\nvar MAX_AMOUNT_BITS = 64n;\nvar MAX_PRICE_PER_UNIT_BITS = 128n;\nvar RESOURCE_VALUE_OFFSET = MAX_AMOUNT_BITS + MAX_PRICE_PER_UNIT_BITS;\nvar L1_GAS_NAME = BigInt(encodeShortString(\"L1_GAS\"));\nvar L2_GAS_NAME = BigInt(encodeShortString(\"L2_GAS\"));\nfunction hashDAMode(nonceDAMode, feeDAMode) {\n  return (BigInt(nonceDAMode) << DATA_AVAILABILITY_MODE_BITS) + BigInt(feeDAMode);\n}\nfunction encodeResourceBoundsL1(bounds) {\n  return (L1_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l1_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l1_gas.max_price_per_unit);\n}\nfunction encodeResourceBoundsL2(bounds) {\n  return (L2_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l2_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l2_gas.max_price_per_unit);\n}\nfunction hashFeeField(tip, bounds) {\n  const L1Bound = encodeResourceBoundsL1(bounds);\n  const L2Bound = encodeResourceBoundsL2(bounds);\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)([BigInt(tip), L1Bound, L2Bound]);\n}\nfunction calculateTransactionHashCommon2(txHashPrefix, version, senderAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, additionalData = []) {\n  const feeFieldHash = hashFeeField(tip, resourceBounds);\n  const dAModeHash = hashDAMode(nonceDataAvailabilityMode, feeDataAvailabilityMode);\n  const dataToHash = AToBI([\n    txHashPrefix,\n    version,\n    senderAddress,\n    feeFieldHash,\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(AToBI(paymasterData)),\n    chainId,\n    nonce,\n    dAModeHash,\n    ...AToBI(additionalData)\n  ]);\n  return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(dataToHash));\n}\nfunction calculateDeployAccountTransactionHash2(contractAddress, classHash, compiledConstructorCalldata, salt, version, chainId, nonce, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n  return calculateTransactionHashCommon2(\n    \"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */,\n    version,\n    contractAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [(0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(AToBI(compiledConstructorCalldata)), classHash, salt]\n  );\n}\nfunction calculateDeclareTransactionHash2(classHash, compiledClassHash, senderAddress, version, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n  return calculateTransactionHashCommon2(\n    \"0x6465636c617265\" /* DECLARE */,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    AToBI(paymasterData),\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [(0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(AToBI(accountDeploymentData)), classHash, compiledClassHash]\n  );\n}\nfunction calculateInvokeTransactionHash(senderAddress, version, compiledCalldata, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n  return calculateTransactionHashCommon2(\n    \"0x696e766f6b65\" /* INVOKE */,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [(0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(AToBI(accountDeploymentData)), (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(AToBI(compiledCalldata))]\n  );\n}\n\n// src/utils/hash/transactionHash/index.ts\nfunction isV3InvokeTx(args) {\n  return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);\n}\nfunction calculateInvokeTransactionHash2(args) {\n  if (isV3InvokeTx(args)) {\n    return calculateInvokeTransactionHash(\n      args.senderAddress,\n      args.version,\n      args.compiledCalldata,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return calculateTransactionHash(\n    args.senderAddress,\n    args.version,\n    args.compiledCalldata,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\nfunction isV3DeclareTx(args) {\n  return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);\n}\nfunction calculateDeclareTransactionHash3(args) {\n  if (isV3DeclareTx(args)) {\n    return calculateDeclareTransactionHash2(\n      args.classHash,\n      args.compiledClassHash,\n      args.senderAddress,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return calculateDeclareTransactionHash(\n    args.classHash,\n    args.senderAddress,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce,\n    args.compiledClassHash\n  );\n}\nfunction isV3DeployAccountTx(args) {\n  return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);\n}\nfunction calculateDeployAccountTransactionHash3(args) {\n  if (isV3DeployAccountTx(args)) {\n    return calculateDeployAccountTransactionHash2(\n      args.contractAddress,\n      args.classHash,\n      args.compiledConstructorCalldata,\n      args.salt,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return calculateDeployAccountTransactionHash(\n    args.contractAddress,\n    args.classHash,\n    args.constructorCalldata,\n    args.salt,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\n\n// src/utils/hash/classHash.ts\n\nfunction computePedersenHash(a, b) {\n  return _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.pedersen(BigInt(a), BigInt(b));\n}\nfunction computePoseidonHash(a, b) {\n  return toHex(_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHash(BigInt(a), BigInt(b)));\n}\nfunction computeHashOnElements2(data) {\n  return [...data, data.length].reduce((x, y) => _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.pedersen(BigInt(x), BigInt(y)), 0).toString();\n}\nvar computePedersenHashOnElements = computeHashOnElements2;\nfunction computePoseidonHashOnElements(data) {\n  return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(data.map((x) => BigInt(x))));\n}\nfunction calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {\n  const compiledCalldata = CallData.compile(constructorCalldata);\n  const constructorCalldataHash = computeHashOnElements2(compiledCalldata);\n  const CONTRACT_ADDRESS_PREFIX = felt(\"0x535441524b4e45545f434f4e54524143545f41444452455353\");\n  const hash = computeHashOnElements2([\n    CONTRACT_ADDRESS_PREFIX,\n    deployerAddress,\n    salt,\n    classHash,\n    constructorCalldataHash\n  ]);\n  return toHex(BigInt(hash) % ADDR_BOUND);\n}\nfunction nullSkipReplacer(key, value) {\n  if (key === \"attributes\" || key === \"accessible_scopes\") {\n    return Array.isArray(value) && value.length === 0 ? void 0 : value;\n  }\n  if (key === \"debug_info\") {\n    return null;\n  }\n  return value === null ? void 0 : value;\n}\nfunction formatSpaces(json2) {\n  let insideQuotes = false;\n  const newString = [];\n  for (const char of json2) {\n    if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === \"\\\\\") === false) {\n      insideQuotes = !insideQuotes;\n    }\n    if (insideQuotes) {\n      newString.push(char);\n    } else {\n      newString.push(char === \":\" ? \": \" : char === \",\" ? \", \" : char);\n    }\n  }\n  return newString.join(\"\");\n}\nfunction computeHintedClassHash(compiledContract) {\n  const { abi, program } = compiledContract;\n  const contractClass = { abi, program };\n  const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));\n  return addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak(utf8ToArray(serializedJson)).toString(16));\n}\nfunction computeLegacyContractClassHash(contract) {\n  const compiledContract = isString(contract) ? parse2(contract) : contract;\n  const apiVersion = toHex(API_VERSION);\n  const externalEntryPointsHash = computeHashOnElements2(\n    compiledContract.entry_points_by_type.EXTERNAL.flatMap((e) => [e.selector, e.offset])\n  );\n  const l1HandlerEntryPointsHash = computeHashOnElements2(\n    compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e) => [e.selector, e.offset])\n  );\n  const constructorEntryPointHash = computeHashOnElements2(\n    compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e) => [e.selector, e.offset])\n  );\n  const builtinsHash = computeHashOnElements2(\n    compiledContract.program.builtins.map((s) => encodeShortString(s))\n  );\n  const hintedClassHash = computeHintedClassHash(compiledContract);\n  const dataHash = computeHashOnElements2(compiledContract.program.data);\n  return computeHashOnElements2([\n    apiVersion,\n    externalEntryPointsHash,\n    l1HandlerEntryPointsHash,\n    constructorEntryPointHash,\n    builtinsHash,\n    hintedClassHash,\n    dataHash\n  ]);\n}\nfunction hashBuiltins(builtins) {\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(\n    builtins.flatMap((it) => {\n      return BigInt(encodeShortString(it));\n    })\n  );\n}\nfunction hashEntryPoint(data) {\n  const base = data.flatMap((it) => {\n    return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];\n  });\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(base);\n}\nfunction hashByteCodeSegments(casm) {\n  const byteCode = casm.bytecode.map((n) => BigInt(n));\n  const bytecodeSegmentLengths = casm.bytecode_segment_lengths ?? [];\n  let segmentStart = 0;\n  const hashLeaves = bytecodeSegmentLengths.flatMap((len) => {\n    const segment = byteCode.slice(segmentStart, segmentStart += len);\n    return [BigInt(len), (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(segment)];\n  });\n  return 1n + (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(hashLeaves);\n}\nfunction computeCompiledClassHash(casm) {\n  const COMPILED_CLASS_VERSION = \"COMPILED_CLASS_V1\";\n  const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n  const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n  const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n  const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n  const bytecode = casm.bytecode_segment_lengths ? hashByteCodeSegments(casm) : (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(casm.bytecode.map((it) => BigInt(it)));\n  return toHex(\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      bytecode\n    ])\n  );\n}\nfunction hashEntryPointSierra(data) {\n  const base = data.flatMap((it) => {\n    return [BigInt(it.selector), BigInt(it.function_idx)];\n  });\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(base);\n}\nfunction hashAbi(sierra) {\n  const indentString = formatSpaces(stringify2(sierra.abi, null));\n  return BigInt(addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak(utf8ToArray(indentString)).toString(16)));\n}\nfunction computeSierraContractClassHash(sierra) {\n  const CONTRACT_CLASS_VERSION = \"CONTRACT_CLASS_V0.1.0\";\n  const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n  const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n  const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n  const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n  const abiHash = hashAbi(sierra);\n  const sierraProgram = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(sierra.sierra_program.map((it) => BigInt(it)));\n  return toHex(\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      abiHash,\n      sierraProgram\n    ])\n  );\n}\nfunction computeContractClassHash(contract) {\n  const compiledContract = isString(contract) ? parse2(contract) : contract;\n  if (\"sierra_program\" in compiledContract) {\n    return computeSierraContractClassHash(compiledContract);\n  }\n  return computeLegacyContractClassHash(compiledContract);\n}\n\n// src/utils/stark.ts\nvar stark_exports = {};\n__export(stark_exports, {\n  compressProgram: () => compressProgram,\n  decompressProgram: () => decompressProgram,\n  estimateFeeToBounds: () => estimateFeeToBounds,\n  estimatedFeeToMaxFee: () => estimatedFeeToMaxFee,\n  formatSignature: () => formatSignature,\n  getFullPublicKey: () => getFullPublicKey,\n  intDAM: () => intDAM,\n  makeAddress: () => makeAddress,\n  randomAddress: () => randomAddress,\n  reduceV2: () => reduceV2,\n  signatureToDecimalArray: () => signatureToDecimalArray,\n  signatureToHexArray: () => signatureToHexArray,\n  toFeeVersion: () => toFeeVersion,\n  toTransactionVersion: () => toTransactionVersion,\n  v3Details: () => v3Details\n});\n\n\nfunction compressProgram(jsonProgram) {\n  const stringified = isString(jsonProgram) ? jsonProgram : stringify2(jsonProgram);\n  const compressedProgram = (0,pako__WEBPACK_IMPORTED_MODULE_10__.gzip)(stringified);\n  return btoaUniversal(compressedProgram);\n}\nfunction decompressProgram(base642) {\n  if (Array.isArray(base642)) return base642;\n  const decompressed = arrayBufferToString((0,pako__WEBPACK_IMPORTED_MODULE_10__.ungzip)(atobUniversal(base642)));\n  return parse2(decompressed);\n}\nfunction randomAddress() {\n  const randomKeyPair = _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.utils.randomPrivateKey();\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.getStarkKey)(randomKeyPair);\n}\nfunction makeAddress(input) {\n  return addHexPrefix(input).toLowerCase();\n}\nfunction formatSignature(sig) {\n  if (!sig) throw Error(\"formatSignature: provided signature is undefined\");\n  if (Array.isArray(sig)) {\n    return sig.map((it) => toHex(it));\n  }\n  try {\n    const { r, s } = sig;\n    return [toHex(r), toHex(s)];\n  } catch (e) {\n    throw new Error(\"Signature need to be weierstrass.SignatureType or an array for custom\");\n  }\n}\nfunction signatureToDecimalArray(sig) {\n  return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\nfunction signatureToHexArray(sig) {\n  return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\nfunction estimatedFeeToMaxFee(estimatedFee, overhead = 50 /* MAX_FEE */) {\n  return addPercent(estimatedFee, overhead);\n}\nfunction estimateFeeToBounds(estimate, amountOverhead = 50 /* L1_BOUND_MAX_AMOUNT */, priceOverhead = 50 /* L1_BOUND_MAX_PRICE_PER_UNIT */) {\n  if (isBigInt(estimate)) {\n    return {\n      l2_gas: { max_amount: \"0x0\", max_price_per_unit: \"0x0\" },\n      l1_gas: { max_amount: \"0x0\", max_price_per_unit: \"0x0\" }\n    };\n  }\n  if (isUndefined(estimate.gas_consumed) || isUndefined(estimate.gas_price)) {\n    throw Error(\"estimateFeeToBounds: estimate is undefined\");\n  }\n  const maxUnits = estimate.data_gas_consumed !== void 0 && estimate.data_gas_price !== void 0 ? toHex(addPercent(BigInt(estimate.overall_fee) / BigInt(estimate.gas_price), amountOverhead)) : toHex(addPercent(estimate.gas_consumed, amountOverhead));\n  const maxUnitPrice = toHex(addPercent(estimate.gas_price, priceOverhead));\n  return {\n    l2_gas: { max_amount: \"0x0\", max_price_per_unit: \"0x0\" },\n    l1_gas: { max_amount: maxUnits, max_price_per_unit: maxUnitPrice }\n  };\n}\nfunction intDAM(dam) {\n  if (dam === api_exports.EDataAvailabilityMode.L1) return api_exports.EDAMode.L1;\n  if (dam === api_exports.EDataAvailabilityMode.L2) return api_exports.EDAMode.L2;\n  throw Error(\"EDAM conversion\");\n}\nfunction toTransactionVersion(defaultVersion, providedVersion) {\n  const providedVersion0xs = providedVersion ? toHex(providedVersion) : void 0;\n  const defaultVersion0xs = toHex(defaultVersion);\n  if (providedVersion && !Object.values(api_exports.ETransactionVersion).includes(providedVersion0xs)) {\n    throw Error(`providedVersion ${providedVersion} is not ETransactionVersion`);\n  }\n  if (!Object.values(api_exports.ETransactionVersion).includes(defaultVersion0xs)) {\n    throw Error(`defaultVersion ${defaultVersion} is not ETransactionVersion`);\n  }\n  return providedVersion ? providedVersion0xs : defaultVersion0xs;\n}\nfunction toFeeVersion(providedVersion) {\n  if (!providedVersion) return void 0;\n  const version = toHex(providedVersion);\n  if (version === api_exports.ETransactionVersion.V0) return api_exports.ETransactionVersion.F0;\n  if (version === api_exports.ETransactionVersion.V1) return api_exports.ETransactionVersion.F1;\n  if (version === api_exports.ETransactionVersion.V2) return api_exports.ETransactionVersion.F2;\n  if (version === api_exports.ETransactionVersion.V3) return api_exports.ETransactionVersion.F3;\n  throw Error(`toFeeVersion: ${version} is not supported`);\n}\nfunction v3Details(details) {\n  return {\n    tip: details.tip || 0,\n    paymasterData: details.paymasterData || [],\n    accountDeploymentData: details.accountDeploymentData || [],\n    nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,\n    feeDataAvailabilityMode: details.feeDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,\n    resourceBounds: details.resourceBounds ?? estimateFeeToBounds(ZERO)\n  };\n}\nfunction reduceV2(providedVersion) {\n  if (providedVersion === api_exports.ETransactionVersion.F2) return api_exports.ETransactionVersion.F1;\n  if (providedVersion === api_exports.ETransactionVersion.V2) return api_exports.ETransactionVersion.V1;\n  return providedVersion;\n}\nfunction getFullPublicKey(privateKey) {\n  const privKey = toHex(privateKey);\n  const fullPrivKey = addHexPrefix(buf2hex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.getPublicKey)(privKey, false)));\n  return fullPrivKey;\n}\n\n// src/utils/contract.ts\nfunction isSierra(contract) {\n  const compiledContract = isString(contract) ? parse2(contract) : contract;\n  return \"sierra_program\" in compiledContract;\n}\nfunction extractContractHashes(payload) {\n  const response = { ...payload };\n  if (isSierra(payload.contract)) {\n    if (!payload.compiledClassHash && payload.casm) {\n      response.compiledClassHash = computeCompiledClassHash(payload.casm);\n    }\n    if (!response.compiledClassHash)\n      throw new Error(\n        \"Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash\"\n      );\n  }\n  response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n  if (!response.classHash)\n    throw new Error(\"Extract classHash failed, provide (CompiledContract).json file or classHash\");\n  return response;\n}\nfunction contractClassResponseToLegacyCompiledContract(ccr) {\n  if (isSierra(ccr)) {\n    throw Error(\"ContractClassResponse need to be LegacyContractClass (cairo0 response class)\");\n  }\n  const contract = ccr;\n  return { ...contract, program: decompressProgram(contract.program) };\n}\n\n// src/utils/eth.ts\nvar eth_exports = {};\n__export(eth_exports, {\n  ethRandomPrivateKey: () => ethRandomPrivateKey,\n  validateAndParseEthAddress: () => validateAndParseEthAddress\n});\n\nfunction ethRandomPrivateKey() {\n  return sanitizeHex(buf2hex(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__.secp256k1.utils.randomPrivateKey()));\n}\nfunction validateAndParseEthAddress(address) {\n  assertInRange(address, ZERO, 2n ** 160n - 1n, \"Ethereum Address \");\n  const result = addHexPrefix(removeHexPrefix(toHex(address)).padStart(40, \"0\"));\n  assert(Boolean(result.match(/^(0x)?[0-9a-f]{40}$/)), \"Invalid Ethereum Address Format\");\n  return result;\n}\n\n// src/utils/fetchPonyfill.ts\n\n\nvar fetchPonyfill_default = IS_BROWSER && window.fetch.bind(window) || // use built-in fetch in browser if available\n!isUndefined(global) && (0,fetch_cookie__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(global.fetch) || // use built-in fetch in node, react-native and service worker if available\nisomorphic_fetch__WEBPACK_IMPORTED_MODULE_13__;\n\n// src/utils/provider.ts\nvar provider_exports = {};\n__export(provider_exports, {\n  Block: () => Block,\n  createSierraContractClass: () => createSierraContractClass,\n  getDefaultNodeUrl: () => getDefaultNodeUrl,\n  isPendingBlock: () => isPendingBlock,\n  isPendingStateUpdate: () => isPendingStateUpdate,\n  isPendingTransaction: () => isPendingTransaction,\n  isV3Tx: () => isV3Tx,\n  isVersion: () => isVersion,\n  parseContract: () => parseContract,\n  validBlockTags: () => validBlockTags,\n  wait: () => wait\n});\n\n// src/global/config.ts\nvar Configuration = class _Configuration {\n  static instance;\n  config;\n  constructor() {\n    this.initialize();\n  }\n  initialize() {\n    this.config = { ...DEFAULT_GLOBAL_CONFIG };\n  }\n  static getInstance() {\n    if (!_Configuration.instance) {\n      _Configuration.instance = new _Configuration();\n    }\n    return _Configuration.instance;\n  }\n  get(key, defaultValue) {\n    return this.config[key] ?? defaultValue;\n  }\n  set(key, value) {\n    this.config[key] = value;\n  }\n  update(configData) {\n    this.config = {\n      ...this.config,\n      ...configData\n    };\n  }\n  getAll() {\n    return { ...this.config };\n  }\n  reset() {\n    this.initialize();\n  }\n  delete(key) {\n    delete this.config[key];\n  }\n  hasKey(key) {\n    return key in this.config;\n  }\n};\nvar config = Configuration.getInstance();\n\n// src/global/logger.type.ts\nvar LogLevelIndex = {\n  DEBUG: 5,\n  INFO: 4,\n  WARN: 3,\n  ERROR: 2,\n  FATAL: 1,\n  OFF: 0\n};\n\n// src/global/logger.ts\nvar Logger = class _Logger {\n  static instance;\n  config;\n  constructor() {\n    this.config = config;\n  }\n  static getInstance() {\n    if (!_Logger.instance) {\n      _Logger.instance = new _Logger();\n    }\n    return _Logger.instance;\n  }\n  getTimestamp() {\n    return (/* @__PURE__ */ new Date()).toISOString();\n  }\n  shouldLog(messageLevel) {\n    const configLevel = this.config.get(\"logLevel\", \"INFO\");\n    return messageLevel <= LogLevelIndex[configLevel];\n  }\n  formatMessage(logMessage) {\n    const { level, message, timestamp, data } = logMessage;\n    let formattedMessage = `[${timestamp}] ${level}: ${message}`;\n    if (data) {\n      try {\n        formattedMessage += `\n${JSON.stringify(data, null, 2)}`;\n      } catch (error) {\n        formattedMessage += `\n[JSON.stringify Error/Circular]: ${error}`;\n      }\n    }\n    return formattedMessage;\n  }\n  log(level, message, data) {\n    if (!this.shouldLog(LogLevelIndex[level])) {\n      return;\n    }\n    const logMessage = {\n      level,\n      message,\n      timestamp: this.getTimestamp(),\n      data\n    };\n    const formattedMessage = this.formatMessage(logMessage);\n    switch (level) {\n      case \"DEBUG\":\n        console.debug(formattedMessage);\n        break;\n      case \"INFO\":\n        console.info(formattedMessage);\n        break;\n      case \"WARN\":\n        console.warn(formattedMessage);\n        break;\n      case \"ERROR\":\n      case \"FATAL\":\n        console.error(formattedMessage);\n        break;\n      case \"OFF\":\n        break;\n      default:\n        console.log(formattedMessage);\n        break;\n    }\n  }\n  /**\n   * debug will be displayed when LogLevel level is set to DEBUG(5)\n   */\n  debug(message, data) {\n    this.log(\"DEBUG\", message, data);\n  }\n  /**\n   * info will be displayed when LogLevel level is set to DEBUG(5), INFO(4)\n   */\n  info(message, data) {\n    this.log(\"INFO\", message, data);\n  }\n  /**\n   * warn will be displayed when LogLevel level is set to DEBUG(5), INFO(4), WARN(3)\n   */\n  warn(message, data) {\n    this.log(\"WARN\", message, data);\n  }\n  /**\n   * error will be displayed when LogLevel level is set to DEBUG(5), INFO(4), WARN(3), ERROR(2)\n   */\n  error(message, data) {\n    this.log(\"ERROR\", message, data);\n  }\n  /**\n   * fatal will be displayed when LogLevel level is set to DEBUG(5), INFO(4), WARN(3), ERROR(2), FATAL(1)\n   */\n  fatal(message, data) {\n    this.log(\"FATAL\", message, data);\n  }\n  /**\n   * Set the logging level you would like system to display\n   * * 5 DEBUG  - show all logs\n   * * 4 INFO\n   * * 3 WARN\n   * * 2 ERROR\n   * * 1 FATAL\n   * * 0 OFF    - disable logs\n   */\n  setLogLevel(level) {\n    this.config.set(\"logLevel\", level);\n  }\n  getLogLevel() {\n    return this.config.get(\"logLevel\", \"INFO\");\n  }\n  /**\n   *\n   * @returns logs levels displayed on the configured LogLevel\n   */\n  getEnabledLogLevels() {\n    return Object.keys(LogLevelIndex).filter((s) => {\n      return this.shouldLog(LogLevelIndex[s]) && s !== \"OFF\";\n    });\n  }\n};\nvar logger = Logger.getInstance();\n\n// src/utils/provider.ts\nfunction wait(delay) {\n  return new Promise((res) => {\n    setTimeout(res, delay);\n  });\n}\nfunction createSierraContractClass(contract) {\n  const result = { ...contract };\n  delete result.sierra_program_debug_info;\n  result.abi = formatSpaces(stringify2(contract.abi));\n  result.sierra_program = formatSpaces(stringify2(contract.sierra_program));\n  result.sierra_program = compressProgram(result.sierra_program);\n  return result;\n}\nfunction parseContract(contract) {\n  const parsedContract = isString(contract) ? parse2(contract) : contract;\n  if (!isSierra(contract)) {\n    return {\n      ...parsedContract,\n      ...\"program\" in parsedContract && { program: compressProgram(parsedContract.program) }\n    };\n  }\n  return createSierraContractClass(parsedContract);\n}\nvar getDefaultNodeUrl = (networkName, mute = false) => {\n  if (!mute) {\n    logger.info(\"Using default public node url, please provide nodeUrl in provider options!\");\n  }\n  const nodes = RPC_NODES[networkName ?? \"SN_SEPOLIA\" /* SN_SEPOLIA */];\n  const randIdx = Math.floor(Math.random() * nodes.length);\n  return nodes[randIdx];\n};\nvar validBlockTags = Object.values(BlockTag);\nvar Block = class {\n  /**\n   * @param {BlockIdentifier} hash if not null, contains the block hash\n   */\n  hash = null;\n  /**\n   * @param {BlockIdentifier} number if not null, contains the block number\n   */\n  number = null;\n  /**\n   * @param {BlockIdentifier} tag if not null, contains \"pending\" or \"latest\"\n   */\n  tag = null;\n  setIdentifier(__identifier) {\n    if (isString(__identifier)) {\n      if (isDecimalString(__identifier)) {\n        this.number = parseInt(__identifier, 10);\n      } else if (isHex(__identifier)) {\n        this.hash = __identifier;\n      } else if (validBlockTags.includes(__identifier)) {\n        this.tag = __identifier;\n      } else {\n        throw TypeError(`Block identifier unmanaged: ${__identifier}`);\n      }\n    } else if (isBigInt(__identifier)) {\n      this.hash = toHex(__identifier);\n    } else if (isNumber(__identifier)) {\n      this.number = __identifier;\n    } else {\n      this.tag = BlockTag.PENDING;\n    }\n    if (isNumber(this.number) && this.number < 0) {\n      throw TypeError(`Block number (${this.number}) can't be negative`);\n    }\n  }\n  /**\n   * Create a Block instance\n   * @param {BlockIdentifier} _identifier  hex string and BigInt are detected as block hashes.\n   * decimal string and number are detected as block numbers.\n   * text string are detected as block tag.\n   * null is considered as a 'pending' block tag.\n   */\n  constructor(_identifier) {\n    this.setIdentifier(_identifier);\n  }\n  // TODO: fix any\n  /**\n   * @returns {any} the identifier as a string\n   * @example\n   * ```typescript\n   * const result = new provider.Block(123456n).queryIdentifier;\n   * // result = \"blockHash=0x1e240\"\n   * ```\n   */\n  get queryIdentifier() {\n    if (this.number !== null) {\n      return `blockNumber=${this.number}`;\n    }\n    if (this.hash !== null) {\n      return `blockHash=${this.hash}`;\n    }\n    return `blockNumber=${this.tag}`;\n  }\n  // TODO: fix any\n  /**\n   * @returns {any} the identifier as an object\n   * @example\n   * ```typescript\n   * const result = new provider.Block(56789).identifier;\n   * // result = { block_number: 56789 }\n   * ```\n   */\n  get identifier() {\n    if (this.number !== null) {\n      return { block_number: this.number };\n    }\n    if (this.hash !== null) {\n      return { block_hash: this.hash };\n    }\n    return this.tag;\n  }\n  /**\n   * change the identifier of an existing Block instance\n   * @example\n   * ```typescript\n   * const myBlock = new provider.Block(\"latest\");\n   * myBlock.identifier =\"0x3456789abc\";\n   * const result = myBlock.identifier;\n   * // result = { block_hash: '0x3456789abc' }\n   * ```\n   */\n  set identifier(_identifier) {\n    this.setIdentifier(_identifier);\n  }\n  valueOf = () => this.number;\n  toString = () => this.hash;\n};\nfunction isV3Tx(details) {\n  const version = details.version ? toHex(details.version) : api_exports.ETransactionVersion.V3;\n  return version === api_exports.ETransactionVersion.V3 || version === api_exports.ETransactionVersion.F3;\n}\nfunction isVersion(version, response) {\n  const [majorS, minorS] = version.split(\".\");\n  const [majorR, minorR] = response.split(\".\");\n  return majorS === majorR && minorS === minorR;\n}\nfunction isPendingBlock(response) {\n  return response.status === \"PENDING\";\n}\nfunction isPendingTransaction(response) {\n  return !(\"block_hash\" in response);\n}\nfunction isPendingStateUpdate(response) {\n  return !(\"block_hash\" in response);\n}\n\n// src/utils/transaction.ts\nvar transaction_exports = {};\n__export(transaction_exports, {\n  buildUDCCall: () => buildUDCCall,\n  fromCallsToExecuteCalldata: () => fromCallsToExecuteCalldata,\n  fromCallsToExecuteCalldataWithNonce: () => fromCallsToExecuteCalldataWithNonce,\n  fromCallsToExecuteCalldata_cairo1: () => fromCallsToExecuteCalldata_cairo1,\n  getExecuteCalldata: () => getExecuteCalldata,\n  getVersionsByType: () => getVersionsByType,\n  transformCallsToMulticallArrays: () => transformCallsToMulticallArrays,\n  transformCallsToMulticallArrays_cairo1: () => transformCallsToMulticallArrays_cairo1\n});\nvar transformCallsToMulticallArrays = (calls) => {\n  const callArray = [];\n  const calldata = [];\n  calls.forEach((call) => {\n    const data = CallData.compile(call.calldata || []);\n    callArray.push({\n      to: toBigInt(call.contractAddress).toString(10),\n      selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n      data_offset: calldata.length.toString(),\n      data_len: data.length.toString()\n    });\n    calldata.push(...data);\n  });\n  return {\n    callArray,\n    calldata: CallData.compile({ calldata })\n  };\n};\nvar fromCallsToExecuteCalldata = (calls) => {\n  const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n  const compiledCalls = CallData.compile({ callArray });\n  return [...compiledCalls, ...calldata];\n};\nvar fromCallsToExecuteCalldataWithNonce = (calls, nonce) => {\n  return [...fromCallsToExecuteCalldata(calls), toBigInt(nonce).toString()];\n};\nvar transformCallsToMulticallArrays_cairo1 = (calls) => {\n  const callArray = calls.map((call) => ({\n    to: toBigInt(call.contractAddress).toString(10),\n    selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n    calldata: CallData.compile(call.calldata || [])\n  }));\n  return callArray;\n};\nvar fromCallsToExecuteCalldata_cairo1 = (calls) => {\n  const orderCalls = calls.map((call) => ({\n    contractAddress: call.contractAddress,\n    entrypoint: call.entrypoint,\n    calldata: Array.isArray(call.calldata) && \"__compiled__\" in call.calldata ? call.calldata : CallData.compile(call.calldata)\n    // RawArgsObject | RawArgsArray type\n  }));\n  return CallData.compile({ orderCalls });\n};\nvar getExecuteCalldata = (calls, cairoVersion = \"0\") => {\n  if (cairoVersion === \"1\") {\n    return fromCallsToExecuteCalldata_cairo1(calls);\n  }\n  return fromCallsToExecuteCalldata(calls);\n};\nfunction buildUDCCall(payload, address) {\n  const params = [].concat(payload).map((it) => {\n    const {\n      classHash,\n      salt,\n      unique = true,\n      constructorCalldata = []\n    } = it;\n    const compiledConstructorCallData = CallData.compile(constructorCalldata);\n    const deploySalt = salt ?? randomAddress();\n    return {\n      call: {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          deploySalt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData\n        ]\n      },\n      address: calculateContractAddressFromHash(\n        unique ? _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.pedersen(address, deploySalt) : deploySalt,\n        classHash,\n        compiledConstructorCallData,\n        unique ? UDC.ADDRESS : 0\n      )\n    };\n  });\n  return {\n    calls: params.map((it) => it.call),\n    addresses: params.map((it) => it.address)\n  };\n}\nfunction getVersionsByType(versionType) {\n  return versionType === \"fee\" ? {\n    v1: api_exports.ETransactionVersion.F1,\n    v2: api_exports.ETransactionVersion.F2,\n    v3: api_exports.ETransactionVersion.F3\n  } : { v1: api_exports.ETransactionVersion.V1, v2: api_exports.ETransactionVersion.V2, v3: api_exports.ETransactionVersion.V3 };\n}\n\n// src/channel/rpc_0_6.ts\nvar defaultOptions = {\n  headers: { \"Content-Type\": \"application/json\" },\n  blockIdentifier: BlockTag.PENDING,\n  retries: 200\n};\nvar RpcChannel = class {\n  nodeUrl;\n  headers;\n  requestId;\n  blockIdentifier;\n  retries;\n  waitMode;\n  // behave like web2 rpc and return when tx is processed\n  chainId;\n  specVersion;\n  transactionRetryIntervalFallback;\n  batchClient;\n  baseFetch;\n  constructor(optionsOrProvider) {\n    const {\n      baseFetch,\n      batch,\n      blockIdentifier,\n      chainId,\n      headers,\n      nodeUrl,\n      retries,\n      specVersion,\n      transactionRetryIntervalFallback,\n      waitMode\n    } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);\n    }\n    this.baseFetch = baseFetch ?? fetchPonyfill_default;\n    this.blockIdentifier = blockIdentifier ?? defaultOptions.blockIdentifier;\n    this.chainId = chainId;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.retries = retries ?? defaultOptions.retries;\n    this.specVersion = specVersion;\n    this.transactionRetryIntervalFallback = transactionRetryIntervalFallback;\n    this.waitMode = waitMode ?? false;\n    this.requestId = 0;\n    if (typeof batch === \"number\") {\n      this.batchClient = new BatchClient({\n        nodeUrl: this.nodeUrl,\n        headers: this.headers,\n        interval: batch,\n        baseFetch: this.baseFetch\n      });\n    }\n  }\n  get transactionRetryIntervalDefault() {\n    return this.transactionRetryIntervalFallback ?? 5e3;\n  }\n  setChainId(chainId) {\n    this.chainId = chainId;\n  }\n  fetch(method, params, id = 0) {\n    const rpcRequestBody = {\n      id,\n      jsonrpc: \"2.0\",\n      method,\n      ...params && { params }\n    };\n    return this.baseFetch(this.nodeUrl, {\n      method: \"POST\",\n      body: stringify2(rpcRequestBody),\n      headers: this.headers\n    });\n  }\n  errorHandler(method, params, rpcError, otherError) {\n    if (rpcError) {\n      throw new RpcError(rpcError, method, params);\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n  async fetchEndpoint(method, params) {\n    try {\n      if (this.batchClient) {\n        const { error: error2, result: result2 } = await this.batchClient.fetch(\n          method,\n          params,\n          this.requestId += 1\n        );\n        this.errorHandler(method, params, error2);\n        return result2;\n      }\n      const rawResult = await this.fetch(method, params, this.requestId += 1);\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result;\n    } catch (error) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n  async getChainId() {\n    this.chainId ??= await this.fetchEndpoint(\"starknet_chainId\");\n    return this.chainId;\n  }\n  async getSpecVersion() {\n    this.specVersion ??= await this.fetchEndpoint(\"starknet_specVersion\");\n    return this.specVersion;\n  }\n  getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getNonce\", {\n      contract_address,\n      block_id\n    });\n  }\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  getBlockLatestAccepted() {\n    return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n  }\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  getBlockNumber() {\n    return this.fetchEndpoint(\"starknet_blockNumber\");\n  }\n  getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", { block_id });\n  }\n  getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxs\", { block_id });\n  }\n  getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStateUpdate\", { block_id });\n  }\n  getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_traceBlockTransactions\", { block_id });\n  }\n  getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", { block_id });\n  }\n  getTransactionByHash(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n      transaction_hash\n    });\n  }\n  getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", { block_id, index });\n  }\n  getTransactionReceipt(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionReceipt\", { transaction_hash });\n  }\n  getTransactionTrace(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_traceTransaction\", { transaction_hash });\n  }\n  /**\n   * Get the status of a transaction\n   */\n  getTransactionStatus(transactionHash) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint(\"starknet_getTransactionStatus\", { transaction_hash });\n  }\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  simulateTransaction(invocations, simulateTransactionOptions = {}) {\n    const {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true\n    } = simulateTransactionOptions;\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags = [];\n    if (skipValidate) simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge) simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_FEE_CHARGE);\n    return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags\n    });\n  }\n  async waitForTransaction(txHash, options) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? this.transactionRetryIntervalDefault;\n    const errorStates = options?.errorStates ?? [\n      rpcspec_0_6_exports.ETransactionStatus.REJECTED\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates = options?.successStates ?? [\n      rpcspec_0_6_exports.ETransactionExecutionStatus.SUCCEEDED,\n      rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L2,\n      rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L1\n    ];\n    let txStatus;\n    while (!onchain) {\n      await wait(retryInterval);\n      try {\n        txStatus = await this.getTransactionStatus(transactionHash);\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n        if (!finalityStatus) {\n          const error = new Error(\"waiting for transaction status\");\n          throw error;\n        }\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message);\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n    }\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      await wait(retryInterval);\n    }\n    return txReceipt;\n  }\n  getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStorageAt\", {\n      contract_address,\n      key: parsedKey,\n      block_id\n    });\n  }\n  getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  getClass(classHash, blockIdentifier = this.blockIdentifier) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClass\", {\n      class_hash,\n      block_id\n    });\n  }\n  getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion(\"0.5\", await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE] : []\n      };\n    }\n    return this.fetchEndpoint(\"starknet_estimateFee\", {\n      request: invocations.map((it) => this.buildTransaction(it, \"fee\")),\n      block_id,\n      ...flags\n    });\n  }\n  async invoke(functionInvocation, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: rpcspec_0_6_exports.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: rpcspec_0_6_exports.ETransactionVersion.V1,\n        type: rpcspec_0_6_exports.ETransactionType.INVOKE\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: rpcspec_0_6_exports.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async declare({ contract, signature, senderAddress, compiledClassHash }, details) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          version: rpcspec_0_6_exports.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: rpcspec_0_6_exports.ETransactionVersion.V1,\n        type: rpcspec_0_6_exports.ETransactionType.DECLARE\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          compiled_class_hash: compiledClassHash || \"\",\n          version: rpcspec_0_6_exports.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: rpcspec_0_6_exports.ETransactionVersion.V2,\n        type: rpcspec_0_6_exports.ETransactionType.DECLARE\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || \"\",\n          version: rpcspec_0_6_exports.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    } else {\n      throw Error(\"declare unspotted parameters\");\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: rpcspec_0_6_exports.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: rpcspec_0_6_exports.ETransactionVersion.V1,\n        type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,\n          version: rpcspec_0_6_exports.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  callContract(call, blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_call\", {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata)\n      },\n      block_id\n    });\n  }\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload)\n    };\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n      message: formattedMessage,\n      block_id\n    });\n  }\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  getSyncingStats() {\n    return this.fetchEndpoint(\"starknet_syncing\");\n  }\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  getEvents(eventFilter) {\n    return this.fetchEndpoint(\"starknet_getEvents\", { filter: eventFilter });\n  }\n  buildTransaction(invocation, versionType) {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n    if (!isV3Tx(invocation)) {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0)\n      };\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: invocation.version,\n        type: invocation.type\n      });\n    } else {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it))\n      };\n    }\n    if (invocation.type === TransactionType.INVOKE) {\n      return {\n        // v0 v1 v3\n        type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === TransactionType.DECLARE) {\n      if (!isSierra(invocation.contract)) {\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details\n        };\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program)\n        },\n        compiled_class_hash: invocation.compiledClassHash || \"\",\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === TransactionType.DEPLOY_ACCOUNT) {\n      const { account_deployment_data, ...restDetails } = details;\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...restDetails\n      };\n    }\n    throw Error(\"RPC buildTransaction received unknown TransactionType\");\n  }\n};\n\n// src/channel/rpc_0_7.ts\nvar rpc_0_7_exports = {};\n__export(rpc_0_7_exports, {\n  RpcChannel: () => RpcChannel2\n});\nvar defaultOptions2 = {\n  headers: { \"Content-Type\": \"application/json\" },\n  blockIdentifier: BlockTag.PENDING,\n  retries: 200\n};\nvar RpcChannel2 = class {\n  nodeUrl;\n  headers;\n  requestId;\n  blockIdentifier;\n  retries;\n  waitMode;\n  // behave like web2 rpc and return when tx is processed\n  chainId;\n  specVersion;\n  transactionRetryIntervalFallback;\n  batchClient;\n  baseFetch;\n  constructor(optionsOrProvider) {\n    const {\n      baseFetch,\n      batch,\n      blockIdentifier,\n      chainId,\n      headers,\n      nodeUrl,\n      retries,\n      specVersion,\n      transactionRetryIntervalFallback,\n      waitMode\n    } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);\n    }\n    this.baseFetch = baseFetch ?? fetchPonyfill_default;\n    this.blockIdentifier = blockIdentifier ?? defaultOptions2.blockIdentifier;\n    this.chainId = chainId;\n    this.headers = { ...defaultOptions2.headers, ...headers };\n    this.retries = retries ?? defaultOptions2.retries;\n    this.specVersion = specVersion;\n    this.transactionRetryIntervalFallback = transactionRetryIntervalFallback;\n    this.waitMode = waitMode ?? false;\n    this.requestId = 0;\n    if (typeof batch === \"number\") {\n      this.batchClient = new BatchClient({\n        nodeUrl: this.nodeUrl,\n        headers: this.headers,\n        interval: batch,\n        baseFetch: this.baseFetch\n      });\n    }\n  }\n  get transactionRetryIntervalDefault() {\n    return this.transactionRetryIntervalFallback ?? 5e3;\n  }\n  setChainId(chainId) {\n    this.chainId = chainId;\n  }\n  fetch(method, params, id = 0) {\n    const rpcRequestBody = {\n      id,\n      jsonrpc: \"2.0\",\n      method,\n      ...params && { params }\n    };\n    return this.baseFetch(this.nodeUrl, {\n      method: \"POST\",\n      body: stringify2(rpcRequestBody),\n      headers: this.headers\n    });\n  }\n  errorHandler(method, params, rpcError, otherError) {\n    if (rpcError) {\n      throw new RpcError(rpcError, method, params);\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n  async fetchEndpoint(method, params) {\n    try {\n      if (this.batchClient) {\n        const { error: error2, result: result2 } = await this.batchClient.fetch(\n          method,\n          params,\n          this.requestId += 1\n        );\n        this.errorHandler(method, params, error2);\n        return result2;\n      }\n      const rawResult = await this.fetch(method, params, this.requestId += 1);\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result;\n    } catch (error) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n  async getChainId() {\n    this.chainId ??= await this.fetchEndpoint(\"starknet_chainId\");\n    return this.chainId;\n  }\n  async getSpecVersion() {\n    this.specVersion ??= await this.fetchEndpoint(\"starknet_specVersion\");\n    return this.specVersion;\n  }\n  getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getNonce\", {\n      contract_address,\n      block_id\n    });\n  }\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  getBlockLatestAccepted() {\n    return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n  }\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  getBlockNumber() {\n    return this.fetchEndpoint(\"starknet_blockNumber\");\n  }\n  getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", { block_id });\n  }\n  getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxs\", { block_id });\n  }\n  getBlockWithReceipts(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithReceipts\", { block_id });\n  }\n  getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStateUpdate\", { block_id });\n  }\n  getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_traceBlockTransactions\", { block_id });\n  }\n  getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", { block_id });\n  }\n  getTransactionByHash(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n      transaction_hash\n    });\n  }\n  getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", { block_id, index });\n  }\n  getTransactionReceipt(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionReceipt\", { transaction_hash });\n  }\n  getTransactionTrace(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_traceTransaction\", { transaction_hash });\n  }\n  /**\n   * Get the status of a transaction\n   */\n  getTransactionStatus(transactionHash) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint(\"starknet_getTransactionStatus\", { transaction_hash });\n  }\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  simulateTransaction(invocations, simulateTransactionOptions = {}) {\n    const {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true\n    } = simulateTransactionOptions;\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags = [];\n    if (skipValidate) simulationFlags.push(starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge) simulationFlags.push(starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ESimulationFlag.SKIP_FEE_CHARGE);\n    return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags\n    });\n  }\n  async waitForTransaction(txHash, options) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? this.transactionRetryIntervalDefault;\n    const errorStates = options?.errorStates ?? [\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionStatus.REJECTED\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates = options?.successStates ?? [\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionExecutionStatus.SUCCEEDED,\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionStatus.ACCEPTED_ON_L2,\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionStatus.ACCEPTED_ON_L1\n    ];\n    let txStatus;\n    while (!onchain) {\n      await wait(retryInterval);\n      try {\n        txStatus = await this.getTransactionStatus(transactionHash);\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n        if (!finalityStatus) {\n          const error = new Error(\"waiting for transaction status\");\n          throw error;\n        }\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message);\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n    }\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      await wait(retryInterval);\n    }\n    return txReceipt;\n  }\n  getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStorageAt\", {\n      contract_address,\n      key: parsedKey,\n      block_id\n    });\n  }\n  getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  getClass(classHash, blockIdentifier = this.blockIdentifier) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClass\", {\n      class_hash,\n      block_id\n    });\n  }\n  getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion(\"0.5\", await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ESimulationFlag.SKIP_VALIDATE] : []\n      };\n    }\n    return this.fetchEndpoint(\"starknet_estimateFee\", {\n      request: invocations.map((it) => this.buildTransaction(it, \"fee\")),\n      block_id,\n      ...flags\n    });\n  }\n  async invoke(functionInvocation, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V1,\n        type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.INVOKE\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async declare({ contract, signature, senderAddress, compiledClassHash }, details) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V1,\n        type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.DECLARE\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          compiled_class_hash: compiledClassHash || \"\",\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V2,\n        type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.DECLARE\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || \"\",\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    } else {\n      throw Error(\"declare unspotted parameters\");\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V1,\n        type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.DEPLOY_ACCOUNT\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.DEPLOY_ACCOUNT,\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  callContract(call, blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_call\", {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata)\n      },\n      block_id\n    });\n  }\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload)\n    };\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n      message: formattedMessage,\n      block_id\n    });\n  }\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  getSyncingStats() {\n    return this.fetchEndpoint(\"starknet_syncing\");\n  }\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  getEvents(eventFilter) {\n    return this.fetchEndpoint(\"starknet_getEvents\", { filter: eventFilter });\n  }\n  buildTransaction(invocation, versionType) {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n    if (!isV3Tx(invocation)) {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0)\n      };\n      logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage, {\n        version: invocation.version,\n        type: invocation.type\n      });\n    } else {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it))\n      };\n    }\n    if (invocation.type === TransactionType.INVOKE) {\n      return {\n        // v0 v1 v3\n        type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === TransactionType.DECLARE) {\n      if (!isSierra(invocation.contract)) {\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details\n        };\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program)\n        },\n        compiled_class_hash: invocation.compiledClassHash || \"\",\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === TransactionType.DEPLOY_ACCOUNT) {\n      const { account_deployment_data, ...restDetails } = details;\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...restDetails\n      };\n    }\n    throw Error(\"RPC buildTransaction received unknown TransactionType\");\n  }\n};\n\n// src/utils/responseParser/rpc.ts\nvar RPCResponseParser = class {\n  margin;\n  constructor(margin) {\n    this.margin = margin;\n  }\n  estimatedFeeToMaxFee(estimatedFee) {\n    return estimatedFeeToMaxFee(estimatedFee, this.margin?.maxFee);\n  }\n  estimateFeeToBounds(estimate) {\n    return estimateFeeToBounds(\n      estimate,\n      this.margin?.l1BoundMaxAmount,\n      this.margin?.l1BoundMaxPricePerUnit\n    );\n  }\n  parseGetBlockResponse(res) {\n    return { status: \"PENDING\", ...res };\n  }\n  parseTransactionReceipt(res) {\n    if (\"actual_fee\" in res && isString(res.actual_fee)) {\n      return {\n        ...res,\n        actual_fee: {\n          amount: res.actual_fee,\n          unit: \"FRI\"\n        }\n      };\n    }\n    return res;\n  }\n  parseFeeEstimateResponse(res) {\n    const val = res[0];\n    return {\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n      data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n      data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n\n    };\n  }\n  parseFeeEstimateBulkResponse(res) {\n    return res.map((val) => ({\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n      data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n      data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n\n    }));\n  }\n  parseSimulateTransactionResponse(res) {\n    return res.map((it) => {\n      return {\n        ...it,\n        suggestedMaxFee: this.estimatedFeeToMaxFee(it.fee_estimation.overall_fee),\n        resourceBounds: this.estimateFeeToBounds(it.fee_estimation)\n      };\n    });\n  }\n  parseContractClassResponse(res) {\n    return {\n      ...res,\n      abi: isString(res.abi) ? JSON.parse(res.abi) : res.abi\n    };\n  }\n  parseL1GasPriceResponse(res) {\n    return res.l1_gas_price.price_in_wei;\n  }\n};\n\n// src/utils/transactionReceipt.ts\nvar ReceiptTx = class _ReceiptTx {\n  statusReceipt;\n  value;\n  constructor(receipt) {\n    [this.statusReceipt, this.value] = _ReceiptTx.isSuccess(receipt) ? [\"success\", receipt] : _ReceiptTx.isReverted(receipt) ? [\"reverted\", receipt] : _ReceiptTx.isRejected(receipt) ? [\"rejected\", receipt] : [\"error\", new Error(\"Unknown response type\")];\n    for (const [key] of Object.entries(this)) {\n      Object.defineProperty(this, key, {\n        enumerable: false\n      });\n    }\n    for (const [key, value] of Object.entries(receipt)) {\n      Object.defineProperty(this, key, {\n        enumerable: true,\n        writable: false,\n        value\n      });\n    }\n  }\n  match(callbacks) {\n    if (this.statusReceipt in callbacks) {\n      return callbacks[this.statusReceipt](this.value);\n    }\n    return callbacks._();\n  }\n  isSuccess() {\n    return this.statusReceipt === \"success\";\n  }\n  isReverted() {\n    return this.statusReceipt === \"reverted\";\n  }\n  isRejected() {\n    return this.statusReceipt === \"rejected\";\n  }\n  isError() {\n    return this.statusReceipt === \"error\";\n  }\n  static isSuccess(transactionReceipt) {\n    return transactionReceipt.execution_status === TransactionExecutionStatus.SUCCEEDED;\n  }\n  static isReverted(transactionReceipt) {\n    return transactionReceipt.execution_status === TransactionExecutionStatus.REVERTED;\n  }\n  static isRejected(transactionReceipt) {\n    return transactionReceipt.status === TransactionExecutionStatus.REJECTED;\n  }\n};\n\n// src/utils/typedData.ts\nvar typedData_exports = {};\n__export(typedData_exports, {\n  TypedDataRevision: () => starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision,\n  encodeData: () => encodeData,\n  encodeType: () => encodeType,\n  encodeValue: () => encodeValue,\n  getDependencies: () => getDependencies,\n  getMessageHash: () => getMessageHash,\n  getStructHash: () => getStructHash,\n  getTypeHash: () => getTypeHash,\n  isMerkleTreeType: () => isMerkleTreeType,\n  prepareSelector: () => prepareSelector,\n  validateTypedData: () => validateTypedData,\n  verifyMessage: () => verifyMessage\n});\n\n// src/utils/merkle.ts\nvar merkle_exports = {};\n__export(merkle_exports, {\n  MerkleTree: () => MerkleTree,\n  proofMerklePath: () => proofMerklePath\n});\nvar MerkleTree = class _MerkleTree {\n  leaves;\n  branches = [];\n  root;\n  hashMethod;\n  /**\n   * Create a Merkle tree\n   *\n   * @param leafHashes hex-string array\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns created Merkle tree\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * // tree = {\n   * //   branches: [['0x5bb9440e2...', '0x262697b88...', ...], ['0x38118a340...', ...], ...],\n   * //   leaves: ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'],\n   * //   root: '0x7f748c75e5bdb7ae28013f076b8ab650c4e01d3530c6e5ab665f9f1accbe7d4',\n   * //   hashMethod: [Function computePedersenHash],\n   * // }\n   * ```\n   */\n  constructor(leafHashes, hashMethod = computePedersenHash) {\n    this.hashMethod = hashMethod;\n    this.leaves = leafHashes;\n    this.root = this.build(leafHashes);\n  }\n  /** @ignore */\n  build(leaves) {\n    if (leaves.length === 1) {\n      return leaves[0];\n    }\n    if (leaves.length !== this.leaves.length) {\n      this.branches.push(leaves);\n    }\n    const newLeaves = [];\n    for (let i = 0; i < leaves.length; i += 2) {\n      if (i + 1 === leaves.length) {\n        newLeaves.push(_MerkleTree.hash(leaves[i], \"0x0\", this.hashMethod));\n      } else {\n        newLeaves.push(_MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));\n      }\n    }\n    return this.build(newLeaves);\n  }\n  /**\n   * Calculate hash from ordered a and b, Pedersen hash default\n   *\n   * @param a first value\n   * @param b second value\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns result of the hash function\n   * @example\n   * ```typescript\n   * const result1 = MerkleTree.hash('0xabc', '0xdef');\n   * // result1 = '0x484f029da7914ada038b1adf67fc83632364a3ebc2cd9349b41ab61626d9e82'\n   *\n   * const customHashMethod = (a, b) => `custom_${a}_${b}`;\n   * const result2 = MerkleTree.hash('0xabc', '0xdef', customHashMethod);\n   * // result2 = 'custom_2748_3567'\n   * ```\n   */\n  static hash(a, b, hashMethod = computePedersenHash) {\n    const [aSorted, bSorted] = [BigInt(a), BigInt(b)].sort((x, y) => x >= y ? 1 : -1);\n    return hashMethod(aSorted, bSorted);\n  }\n  /**\n   * Calculates the merkle membership proof path\n   *\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns collection of merkle proof hex-string hashes\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * const result = tree.getProof('0x3');\n   * // result = [\n   * //   '0x4',\n   * //   '0x5bb9440e27889a364bcb678b1f679ecd1347acdedcbf36e83494f857cc58026',\n   * //   '0x8c0e46dd2df9aaf3a8ebfbc25408a582ad7fa7171f0698ddbbc5130b4b4e60',\n   * // ]\n   * ```\n   */\n  getProof(leaf, branch = this.leaves, hashPath = []) {\n    const index = branch.indexOf(leaf);\n    if (index === -1) {\n      throw new Error(\"leaf not found\");\n    }\n    if (branch.length === 1) {\n      return hashPath;\n    }\n    const isLeft = index % 2 === 0;\n    const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? \"0x0\";\n    const newHashPath = [...hashPath, neededBranch];\n    const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b) => b.length === branch.length);\n    const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];\n    return this.getProof(\n      _MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod),\n      nextBranch,\n      newHashPath\n    );\n  }\n};\nfunction proofMerklePath(root, leaf, path, hashMethod = computePedersenHash) {\n  if (path.length === 0) {\n    return root === leaf;\n  }\n  const [next, ...rest] = path;\n  return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);\n}\n\n// src/utils/typedData.ts\nvar presetTypes = {\n  u256: JSON.parse('[{ \"name\": \"low\", \"type\": \"u128\" }, { \"name\": \"high\", \"type\": \"u128\" }]'),\n  TokenAmount: JSON.parse(\n    '[{ \"name\": \"token_address\", \"type\": \"ContractAddress\" }, { \"name\": \"amount\", \"type\": \"u256\" }]'\n  ),\n  NftId: JSON.parse(\n    '[{ \"name\": \"collection_address\", \"type\": \"ContractAddress\" }, { \"name\": \"token_id\", \"type\": \"u256\" }]'\n  )\n};\nvar revisionConfiguration = {\n  [starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE]: {\n    domain: \"StarknetDomain\",\n    hashMethod: computePoseidonHashOnElements,\n    hashMerkleMethod: computePoseidonHash,\n    escapeTypeString: (s) => `\"${s}\"`,\n    presetTypes\n  },\n  [starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.LEGACY]: {\n    domain: \"StarkNetDomain\",\n    hashMethod: computePedersenHashOnElements,\n    hashMerkleMethod: computePedersenHash,\n    escapeTypeString: (s) => s,\n    presetTypes: {}\n  }\n};\nfunction assertRange(data, type, { min, max }) {\n  const value = BigInt(data);\n  assert(value >= min && value <= max, `${value} (${type}) is out of bounds [${min}, ${max}]`);\n}\nfunction identifyRevision({ types, domain }) {\n  if (revisionConfiguration[starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE].domain in types && domain.revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE)\n    return starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE;\n  if (revisionConfiguration[starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.LEGACY].domain in types && (domain.revision ?? starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.LEGACY) === starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.LEGACY)\n    return starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.LEGACY;\n  return void 0;\n}\nfunction getHex(value) {\n  try {\n    return toHex(value);\n  } catch (e) {\n    if (isString(value)) {\n      return toHex(encodeShortString(value));\n    }\n    throw new Error(`Invalid BigNumberish: ${value}`);\n  }\n}\nfunction validateTypedData(data) {\n  const typedData = data;\n  return Boolean(\n    typedData.message && typedData.primaryType && typedData.types && identifyRevision(typedData)\n  );\n}\nfunction prepareSelector(selector) {\n  return isHex(selector) ? selector : getSelectorFromName(selector);\n}\nfunction isMerkleTreeType(type) {\n  return type.type === \"merkletree\";\n}\nfunction getDependencies(types, type, dependencies = [], contains = \"\", revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.LEGACY) {\n  let dependencyTypes = [type];\n  if (type[type.length - 1] === \"*\") {\n    dependencyTypes = [type.slice(0, -1)];\n  } else if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE) {\n    if (type === \"enum\") {\n      dependencyTypes = [contains];\n    } else if (type.match(/^\\(.*\\)$/)) {\n      dependencyTypes = type.slice(1, -1).split(\",\").map((depType) => depType[depType.length - 1] === \"*\" ? depType.slice(0, -1) : depType);\n    }\n  }\n  return dependencyTypes.filter((t) => !dependencies.includes(t) && types[t]).reduce(\n    // This comment prevents prettier from rolling everything here into a single line.\n    (p, depType) => [\n      ...p,\n      ...[\n        depType,\n        ...types[depType].reduce(\n          (previous, t) => [\n            ...previous,\n            ...getDependencies(types, t.type, previous, t.contains, revision).filter(\n              (dependency) => !previous.includes(dependency)\n            )\n          ],\n          []\n        )\n      ].filter((dependency) => !p.includes(dependency))\n    ],\n    []\n  );\n}\nfunction getMerkleTreeType(types, ctx) {\n  if (ctx.parent && ctx.key) {\n    const parentType = types[ctx.parent];\n    const merkleType = parentType.find((t) => t.name === ctx.key);\n    const isMerkleTree = isMerkleTreeType(merkleType);\n    if (!isMerkleTree) {\n      throw new Error(`${ctx.key} is not a merkle tree`);\n    }\n    if (merkleType.contains.endsWith(\"*\")) {\n      throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n    }\n    return merkleType.contains;\n  }\n  return \"raw\";\n}\nfunction encodeType(types, type, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.LEGACY) {\n  const allTypes = revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE ? { ...types, ...revisionConfiguration[revision].presetTypes } : types;\n  const [primary, ...dependencies] = getDependencies(\n    allTypes,\n    type,\n    void 0,\n    void 0,\n    revision\n  );\n  const newTypes = !primary ? [] : [primary, ...dependencies.sort()];\n  const esc = revisionConfiguration[revision].escapeTypeString;\n  return newTypes.map((dependency) => {\n    const dependencyElements = allTypes[dependency].map((t) => {\n      const targetType = t.type === \"enum\" && revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE ? t.contains : t.type;\n      const typeString = targetType.match(/^\\(.*\\)$/) ? `(${targetType.slice(1, -1).split(\",\").map((e) => e ? esc(e) : e).join(\",\")})` : esc(targetType);\n      return `${esc(t.name)}:${typeString}`;\n    });\n    return `${esc(dependency)}(${dependencyElements})`;\n  }).join(\"\");\n}\nfunction getTypeHash(types, type, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.LEGACY) {\n  return getSelectorFromName(encodeType(types, type, revision));\n}\nfunction encodeValue(types, type, data, ctx = {}, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.LEGACY) {\n  if (types[type]) {\n    return [type, getStructHash(types, type, data, revision)];\n  }\n  if (revisionConfiguration[revision].presetTypes[type]) {\n    return [\n      type,\n      getStructHash(\n        revisionConfiguration[revision].presetTypes,\n        type,\n        data,\n        revision\n      )\n    ];\n  }\n  if (type.endsWith(\"*\")) {\n    const hashes = data.map(\n      (entry) => encodeValue(types, type.slice(0, -1), entry, void 0, revision)[1]\n    );\n    return [type, revisionConfiguration[revision].hashMethod(hashes)];\n  }\n  switch (type) {\n    case \"enum\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE) {\n        const [variantKey, variantData] = Object.entries(data)[0];\n        const parentType = types[ctx.parent].find((t) => t.name === ctx.key);\n        const enumType = types[parentType.contains];\n        const variantType = enumType.find((t) => t.name === variantKey);\n        const variantIndex = enumType.indexOf(variantType);\n        const encodedSubtypes = variantType.type.slice(1, -1).split(\",\").map((subtype, index) => {\n          if (!subtype) return subtype;\n          const subtypeData = variantData[index];\n          return encodeValue(types, subtype, subtypeData, void 0, revision)[1];\n        });\n        return [\n          type,\n          revisionConfiguration[revision].hashMethod([variantIndex, ...encodedSubtypes])\n        ];\n      }\n      return [type, getHex(data)];\n    }\n    case \"merkletree\": {\n      const merkleTreeType = getMerkleTreeType(types, ctx);\n      const structHashes = data.map((struct) => {\n        return encodeValue(types, merkleTreeType, struct, void 0, revision)[1];\n      });\n      const { root } = new MerkleTree(\n        structHashes,\n        revisionConfiguration[revision].hashMerkleMethod\n      );\n      return [\"felt\", root];\n    }\n    case \"selector\": {\n      return [\"felt\", prepareSelector(data)];\n    }\n    case \"string\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE) {\n        const byteArray = byteArrayFromString(data);\n        const elements = [\n          byteArray.data.length,\n          ...byteArray.data,\n          byteArray.pending_word,\n          byteArray.pending_word_len\n        ];\n        return [type, revisionConfiguration[revision].hashMethod(elements)];\n      }\n      return [type, getHex(data)];\n    }\n    case \"i128\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE) {\n        const value = BigInt(data);\n        assertRange(value, type, RANGE_I128);\n        return [type, getHex(value < 0n ? PRIME + value : value)];\n      }\n      return [type, getHex(data)];\n    }\n    case \"timestamp\":\n    case \"u128\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE) {\n        assertRange(data, type, RANGE_U128);\n      }\n      return [type, getHex(data)];\n    }\n    case \"felt\":\n    case \"shortstring\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE) {\n        assertRange(getHex(data), type, RANGE_FELT);\n      }\n      return [type, getHex(data)];\n    }\n    case \"ClassHash\":\n    case \"ContractAddress\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE) {\n        assertRange(data, type, RANGE_FELT);\n      }\n      return [type, getHex(data)];\n    }\n    case \"bool\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE) {\n        assert(isBoolean(data), `Type mismatch for ${type} ${data}`);\n      }\n      return [type, getHex(data)];\n    }\n    default: {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.ACTIVE) {\n        throw new Error(`Unsupported type: ${type}`);\n      }\n      return [type, getHex(data)];\n    }\n  }\n}\nfunction encodeData(types, type, data, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.LEGACY) {\n  const targetType = types[type] ?? revisionConfiguration[revision].presetTypes[type];\n  const [returnTypes, values] = targetType.reduce(\n    ([ts, vs], field) => {\n      if (data[field.name] === void 0 || data[field.name] === null && field.type !== \"enum\") {\n        throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n      }\n      const value = data[field.name];\n      const ctx = { parent: type, key: field.name };\n      const [t, encodedValue] = encodeValue(types, field.type, value, ctx, revision);\n      return [\n        [...ts, t],\n        [...vs, encodedValue]\n      ];\n    },\n    [[\"felt\"], [getTypeHash(types, type, revision)]]\n  );\n  return [returnTypes, values];\n}\nfunction getStructHash(types, type, data, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_3__.TypedDataRevision.LEGACY) {\n  return revisionConfiguration[revision].hashMethod(encodeData(types, type, data, revision)[1]);\n}\nfunction getMessageHash(typedData, account) {\n  if (!validateTypedData(typedData)) {\n    throw new Error(\"Typed data does not match JSON schema\");\n  }\n  const revision = identifyRevision(typedData);\n  const { domain, hashMethod } = revisionConfiguration[revision];\n  const message = [\n    encodeShortString(\"StarkNet Message\"),\n    getStructHash(typedData.types, domain, typedData.domain, revision),\n    account,\n    getStructHash(typedData.types, typedData.primaryType, typedData.message, revision)\n  ];\n  return hashMethod(message);\n}\nfunction verifyMessage(message, signature, fullPublicKey, accountAddress) {\n  const isTypedData = validateTypedData(message);\n  if (!isBigNumberish(message) && !isTypedData) {\n    throw new Error(\"message has a wrong format.\");\n  }\n  if (isTypedData && accountAddress === void 0) {\n    throw new Error(\n      \"When providing a TypedData in message parameter, the accountAddress parameter has to be provided.\"\n    );\n  }\n  if (isTypedData && !isBigNumberish(accountAddress)) {\n    throw new Error(\"accountAddress shall be a BigNumberish\");\n  }\n  const messageHash = isTypedData ? getMessageHash(message, accountAddress) : toHex(message);\n  const sign = Array.isArray(signature) ? new _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.Signature(BigInt(signature[0]), BigInt(signature[1])) : signature;\n  const fullPubKey = toHex(fullPublicKey);\n  const isValid = _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.verify(sign, messageHash, fullPubKey);\n  return isValid;\n}\n\n// src/provider/rpc.ts\nvar RpcProvider = class {\n  responseParser;\n  channel;\n  constructor(optionsOrProvider) {\n    if (optionsOrProvider && \"channel\" in optionsOrProvider) {\n      this.channel = optionsOrProvider.channel;\n      this.responseParser = \"responseParser\" in optionsOrProvider ? optionsOrProvider.responseParser : new RPCResponseParser();\n    } else {\n      this.channel = new RpcChannel2({ ...optionsOrProvider, waitMode: false });\n      this.responseParser = new RPCResponseParser(optionsOrProvider?.feeMarginPercentage);\n    }\n  }\n  fetch(method, params, id = 0) {\n    return this.channel.fetch(method, params, id);\n  }\n  async getChainId() {\n    return this.channel.getChainId();\n  }\n  async getSpecVersion() {\n    return this.channel.getSpecVersion();\n  }\n  async getNonceForAddress(contractAddress, blockIdentifier) {\n    return this.channel.getNonceForAddress(contractAddress, blockIdentifier);\n  }\n  async getBlock(blockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse);\n  }\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  async getBlockLatestAccepted() {\n    return this.channel.getBlockLatestAccepted();\n  }\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  async getBlockNumber() {\n    return this.channel.getBlockNumber();\n  }\n  async getBlockWithTxHashes(blockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier);\n  }\n  async getBlockWithTxs(blockIdentifier) {\n    return this.channel.getBlockWithTxs(blockIdentifier);\n  }\n  /**\n   * Pause the execution of the script until a specified block is created.\n   * @param {BlockIdentifier} blockIdentifier bloc number (BigNumberish) or 'pending' or 'latest'.\n   * Use of 'latest\" or of a block already created will generate no pause.\n   * @param {number} [retryInterval] number of milliseconds between 2 requests to the node\n   * @example\n   * ```typescript\n   * await myProvider.waitForBlock();\n   * // wait the creation of the pending block\n   * ```\n   */\n  async waitForBlock(blockIdentifier = \"pending\", retryInterval = 5e3) {\n    if (blockIdentifier === BlockTag.LATEST) return;\n    const currentBlock = await this.getBlockNumber();\n    const targetBlock = blockIdentifier === BlockTag.PENDING ? currentBlock + 1 : Number(toHex(blockIdentifier));\n    if (targetBlock <= currentBlock) return;\n    const { retries } = this.channel;\n    let retriesCount = retries;\n    let isTargetBlock = false;\n    while (!isTargetBlock) {\n      const currBlock = await this.getBlockNumber();\n      if (currBlock === targetBlock) {\n        isTargetBlock = true;\n      } else {\n        await wait(retryInterval);\n      }\n      retriesCount -= 1;\n      if (retriesCount <= 0) {\n        throw new Error(`waitForBlock() timed-out after ${retries} tries.`);\n      }\n    }\n  }\n  async getL1GasPrice(blockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseL1GasPriceResponse);\n  }\n  async getL1MessageHash(l2TxHash) {\n    const transaction = await this.channel.getTransactionByHash(l2TxHash);\n    assert(transaction.type === \"L1_HANDLER\", \"This L2 transaction is not a L1 message.\");\n    const { calldata, contract_address, entry_point_selector, nonce } = transaction;\n    const params = [\n      calldata[0],\n      contract_address,\n      nonce,\n      entry_point_selector,\n      calldata.length - 1,\n      ...calldata.slice(1)\n    ];\n    return solidityUint256PackedKeccak256(params);\n  }\n  async getBlockWithReceipts(blockIdentifier) {\n    if (this.channel instanceof rpc_0_6_exports.RpcChannel)\n      throw new LibraryError(\"Unsupported method for RPC version\");\n    return this.channel.getBlockWithReceipts(blockIdentifier);\n  }\n  getStateUpdate = this.getBlockStateUpdate;\n  async getBlockStateUpdate(blockIdentifier) {\n    return this.channel.getBlockStateUpdate(blockIdentifier);\n  }\n  async getBlockTransactionsTraces(blockIdentifier) {\n    return this.channel.getBlockTransactionsTraces(blockIdentifier);\n  }\n  async getBlockTransactionCount(blockIdentifier) {\n    return this.channel.getBlockTransactionCount(blockIdentifier);\n  }\n  /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.PENDING); (will be removed in next minor version)\n   * Utility method, same result can be achieved using getBlockWithTxHashes(BlockTag.pending);\n   */\n  async getPendingTransactions() {\n    const { transactions } = await this.getBlockWithTxHashes(BlockTag.PENDING).then(\n      this.responseParser.parseGetBlockResponse\n    );\n    return Promise.all(transactions.map((it) => this.getTransactionByHash(it)));\n  }\n  async getTransaction(txHash) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n  async getTransactionByHash(txHash) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n  async getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n    return this.channel.getTransactionByBlockIdAndIndex(blockIdentifier, index);\n  }\n  async getTransactionReceipt(txHash) {\n    const txReceiptWoHelper = await this.channel.getTransactionReceipt(txHash);\n    const txReceiptWoHelperModified = this.responseParser.parseTransactionReceipt(txReceiptWoHelper);\n    return new ReceiptTx(txReceiptWoHelperModified);\n  }\n  async getTransactionTrace(txHash) {\n    return this.channel.getTransactionTrace(txHash);\n  }\n  /**\n   * Get the status of a transaction\n   */\n  async getTransactionStatus(transactionHash) {\n    return this.channel.getTransactionStatus(transactionHash);\n  }\n  /**\n   * @param invocations AccountInvocations\n   * @param options blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  async getSimulateTransaction(invocations, options) {\n    return this.channel.simulateTransaction(invocations, options).then((r) => this.responseParser.parseSimulateTransactionResponse(r));\n  }\n  async waitForTransaction(txHash, options) {\n    const receiptWoHelper = await this.channel.waitForTransaction(\n      txHash,\n      options\n    );\n    return new ReceiptTx(receiptWoHelper);\n  }\n  async getStorageAt(contractAddress, key, blockIdentifier) {\n    return this.channel.getStorageAt(contractAddress, key, blockIdentifier);\n  }\n  async getClassHashAt(contractAddress, blockIdentifier) {\n    return this.channel.getClassHashAt(contractAddress, blockIdentifier);\n  }\n  async getClassByHash(classHash) {\n    return this.getClass(classHash);\n  }\n  async getClass(classHash, blockIdentifier) {\n    return this.channel.getClass(classHash, blockIdentifier).then(this.responseParser.parseContractClassResponse);\n  }\n  async getClassAt(contractAddress, blockIdentifier) {\n    return this.channel.getClassAt(contractAddress, blockIdentifier).then(this.responseParser.parseContractClassResponse);\n  }\n  async getContractVersion(contractAddress, classHash, {\n    blockIdentifier = this.channel.blockIdentifier,\n    compiler = true\n  } = {}) {\n    let contractClass;\n    if (contractAddress) {\n      contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n    } else if (classHash) {\n      contractClass = await this.getClass(classHash, blockIdentifier);\n    } else {\n      throw Error(\"getContractVersion require contractAddress or classHash\");\n    }\n    if (isSierra(contractClass)) {\n      if (compiler) {\n        const abiTest = getAbiContractVersion(contractClass.abi);\n        return { cairo: \"1\", compiler: abiTest.compiler };\n      }\n      return { cairo: \"1\", compiler: void 0 };\n    }\n    return { cairo: \"0\", compiler: \"0\" };\n  }\n  /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */\n  async getEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {\n    return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n  }\n  async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {\n    return this.channel.getEstimateFee(\n      [\n        {\n          type: TransactionType.INVOKE,\n          ...invocation,\n          ...invocationDetails\n        }\n      ],\n      { blockIdentifier, skipValidate }\n    ).then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n  async getDeclareEstimateFee(invocation, details, blockIdentifier, skipValidate) {\n    return this.channel.getEstimateFee(\n      [\n        {\n          type: TransactionType.DECLARE,\n          ...invocation,\n          ...details\n        }\n      ],\n      { blockIdentifier, skipValidate }\n    ).then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n  async getDeployAccountEstimateFee(invocation, details, blockIdentifier, skipValidate) {\n    return this.channel.getEstimateFee(\n      [\n        {\n          type: TransactionType.DEPLOY_ACCOUNT,\n          ...invocation,\n          ...details\n        }\n      ],\n      { blockIdentifier, skipValidate }\n    ).then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n  async getEstimateFeeBulk(invocations, options) {\n    return this.channel.getEstimateFee(invocations, options).then((r) => this.responseParser.parseFeeEstimateBulkResponse(r));\n  }\n  async invokeFunction(functionInvocation, details) {\n    return this.channel.invoke(functionInvocation, details);\n  }\n  async declareContract(transaction, details) {\n    return this.channel.declare(transaction, details);\n  }\n  async deployAccountContract(transaction, details) {\n    return this.channel.deployAccount(\n      transaction,\n      details\n    );\n  }\n  async callContract(call, blockIdentifier) {\n    return this.channel.callContract(call, blockIdentifier);\n  }\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  async estimateMessageFee(message, blockIdentifier) {\n    return this.channel.estimateMessageFee(message, blockIdentifier);\n  }\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  async getSyncingStats() {\n    return this.channel.getSyncingStats();\n  }\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  async getEvents(eventFilter) {\n    return this.channel.getEvents(eventFilter);\n  }\n  /**\n   * Verify in Starknet a signature of a TypedData object or of a given hash.\n   * @param {BigNumberish | TypedData} message TypedData object to be verified, or message hash to be verified.\n   * @param {Signature} signature signature of the message.\n   * @param {BigNumberish} accountAddress address of the account that has signed the message.\n   * @param {string} [signatureVerificationFunctionName] if account contract with non standard account verification function name.\n   * @param { okResponse: string[]; nokResponse: string[]; error: string[] } [signatureVerificationResponse] if account contract with non standard response of verification function.\n   * @returns\n   * ```typescript\n   * const myTypedMessage: TypedMessage = .... ;\n   * const messageHash = typedData.getMessageHash(myTypedMessage,accountAddress);\n   * const sign: WeierstrassSignatureType = ec.starkCurve.sign(messageHash, privateKey);\n   * const accountAddress = \"0x43b7240d227aa2fb8434350b3321c40ac1b88c7067982549e7609870621b535\";\n   * const result1 = myRpcProvider.verifyMessageInStarknet(myTypedMessage, sign, accountAddress);\n   * const result2 = myRpcProvider.verifyMessageInStarknet(messageHash, sign, accountAddress);\n   * // result1 = result2 = true\n   * ```\n   */\n  async verifyMessageInStarknet(message, signature, accountAddress, signatureVerificationFunctionName, signatureVerificationResponse) {\n    const isTypedData = validateTypedData(message);\n    if (!isBigNumberish(message) && !isTypedData) {\n      throw new Error(\"message has a wrong format.\");\n    }\n    if (!isBigNumberish(accountAddress)) {\n      throw new Error(\"accountAddress shall be a BigNumberish\");\n    }\n    const messageHash = isTypedData ? getMessageHash(message, accountAddress) : toHex(message);\n    const knownSigVerificationFName = signatureVerificationFunctionName ? [signatureVerificationFunctionName] : [\"isValidSignature\", \"is_valid_signature\"];\n    const knownSignatureResponse = signatureVerificationResponse || {\n      okResponse: [\n        // any non-nok response is true\n      ],\n      nokResponse: [\n        \"0x0\",\n        // Devnet\n        \"0x00\"\n        // OpenZeppelin 0.7.0 to 0.9.0 invalid signature\n      ],\n      error: [\n        \"argent/invalid-signature\",\n        // ArgentX 0.3.0 to 0.3.1\n        \"is invalid, with respect to the public key\",\n        // OpenZeppelin until 0.6.1, Braavos 0.0.11\n        \"INVALID_SIG\"\n        // Braavos 1.0.0\n      ]\n    };\n    let error;\n    for (const SigVerificationFName of knownSigVerificationFName) {\n      try {\n        const resp = await this.callContract({\n          contractAddress: toHex(accountAddress),\n          entrypoint: SigVerificationFName,\n          calldata: CallData.compile({\n            hash: toBigInt(messageHash).toString(),\n            signature: formatSignature(signature)\n          })\n        });\n        if (knownSignatureResponse.nokResponse.includes(resp[0].toString())) {\n          return false;\n        }\n        if (knownSignatureResponse.okResponse.length === 0 || knownSignatureResponse.okResponse.includes(resp[0].toString())) {\n          return true;\n        }\n        throw Error(\"signatureVerificationResponse Error: response is not part of known responses\");\n      } catch (err) {\n        if (knownSignatureResponse.error.some(\n          (errMessage) => err.message.includes(errMessage)\n        )) {\n          return false;\n        }\n        error = err;\n      }\n    }\n    throw Error(`Signature verification Error: ${error}`);\n  }\n  /**\n   * Test if class is already declared from ContractClassIdentifier\n   * Helper method using getClass\n   * @param ContractClassIdentifier\n   * @param blockIdentifier\n   */\n  async isClassDeclared(contractClassIdentifier, blockIdentifier) {\n    let classHash;\n    if (!contractClassIdentifier.classHash && \"contract\" in contractClassIdentifier) {\n      const hashes = extractContractHashes(contractClassIdentifier);\n      classHash = hashes.classHash;\n    } else if (contractClassIdentifier.classHash) {\n      classHash = contractClassIdentifier.classHash;\n    } else {\n      throw Error(\"contractClassIdentifier type not satisfied\");\n    }\n    try {\n      const result = await this.getClass(classHash, blockIdentifier);\n      return result instanceof Object;\n    } catch (error) {\n      if (error instanceof LibraryError) {\n        return false;\n      }\n      throw error;\n    }\n  }\n  /**\n   * Build bulk invocations with auto-detect declared class\n   * 1. Test if class is declared if not declare it preventing already declared class error and not declared class errors\n   * 2. Order declarations first\n   * @param invocations\n   */\n  async prepareInvocations(invocations) {\n    const bulk = [];\n    for (const invocation of invocations) {\n      if (invocation.type === TransactionType.DECLARE) {\n        const isDeclared = await this.isClassDeclared(\n          \"payload\" in invocation ? invocation.payload : invocation\n        );\n        if (!isDeclared) {\n          bulk.unshift(invocation);\n        }\n      } else {\n        bulk.push(invocation);\n      }\n    }\n    return bulk;\n  }\n};\n\n// src/provider/extensions/default.ts\n\n\n// src/utils/starknetId.ts\nvar starknetId_exports = {};\n__export(starknetId_exports, {\n  StarknetIdContract: () => StarknetIdContract,\n  StarknetIdIdentityContract: () => StarknetIdIdentityContract,\n  StarknetIdMulticallContract: () => StarknetIdMulticallContract,\n  StarknetIdPfpContract: () => StarknetIdPfpContract,\n  StarknetIdPopContract: () => StarknetIdPopContract,\n  StarknetIdVerifierContract: () => StarknetIdVerifierContract,\n  dynamicCallData: () => dynamicCallData,\n  dynamicFelt: () => dynamicFelt,\n  execution: () => execution,\n  getStarknetIdContract: () => getStarknetIdContract,\n  getStarknetIdIdentityContract: () => getStarknetIdIdentityContract,\n  getStarknetIdMulticallContract: () => getStarknetIdMulticallContract,\n  getStarknetIdPfpContract: () => getStarknetIdPfpContract,\n  getStarknetIdPopContract: () => getStarknetIdPopContract,\n  getStarknetIdVerifierContract: () => getStarknetIdVerifierContract,\n  isStarkDomain: () => isStarkDomain,\n  useDecoded: () => useDecoded,\n  useEncoded: () => useEncoded\n});\nvar basicAlphabet = \"abcdefghijklmnopqrstuvwxyz0123456789-\";\nvar basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nvar bigAlphabet = \"\\u8FD9\\u6765\";\nvar basicAlphabetSize = BigInt(basicAlphabet.length);\nvar bigAlphabetSize = BigInt(bigAlphabet.length);\nvar bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\nfunction extractStars(str) {\n  let k = 0;\n  while (str.endsWith(bigAlphabet[bigAlphabet.length - 1])) {\n    str = str.substring(0, str.length - 1);\n    k += 1;\n  }\n  return [str, k];\n}\nfunction useDecoded(encoded) {\n  let decoded = \"\";\n  encoded.forEach((subdomain) => {\n    while (subdomain !== ZERO) {\n      const code = subdomain % basicSizePlusOne;\n      subdomain /= basicSizePlusOne;\n      if (code === BigInt(basicAlphabet.length)) {\n        const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n        if (nextSubdomain === ZERO) {\n          const code2 = subdomain % bigAlphabetSizePlusOne;\n          subdomain = nextSubdomain;\n          if (code2 === ZERO) decoded += basicAlphabet[0];\n          else decoded += bigAlphabet[Number(code2) - 1];\n        } else {\n          const code2 = subdomain % bigAlphabetSize;\n          decoded += bigAlphabet[Number(code2)];\n          subdomain /= bigAlphabetSize;\n        }\n      } else decoded += basicAlphabet[Number(code)];\n    }\n    const [str, k] = extractStars(decoded);\n    if (k)\n      decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n    decoded += \".\";\n  });\n  if (!decoded) {\n    return decoded;\n  }\n  return decoded.concat(\"stark\");\n}\nfunction useEncoded(decoded) {\n  let encoded = BigInt(0);\n  let multiplier = BigInt(1);\n  if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n    const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n    decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n  } else {\n    const [str, k] = extractStars(decoded);\n    if (k) decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n  }\n  for (let i = 0; i < decoded.length; i += 1) {\n    const char = decoded[i];\n    const index = basicAlphabet.indexOf(char);\n    const bnIndex = BigInt(basicAlphabet.indexOf(char));\n    if (index !== -1) {\n      if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n        encoded += multiplier * basicAlphabetSize;\n        multiplier *= basicSizePlusOne;\n        multiplier *= basicSizePlusOne;\n      } else {\n        encoded += multiplier * bnIndex;\n        multiplier *= basicSizePlusOne;\n      }\n    } else if (bigAlphabet.indexOf(char) !== -1) {\n      encoded += multiplier * basicAlphabetSize;\n      multiplier *= basicSizePlusOne;\n      const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n      encoded += multiplier * BigInt(newid);\n      multiplier *= bigAlphabetSize;\n    }\n  }\n  return encoded;\n}\nvar StarknetIdContract = {\n  MAINNET: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\",\n  TESTNET_SEPOLIA: \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\"\n};\nfunction getStarknetIdContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return StarknetIdContract.MAINNET;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return StarknetIdContract.TESTNET_SEPOLIA;\n    default:\n      throw new Error(\"Starknet.id is not yet deployed on this network\");\n  }\n}\nvar StarknetIdIdentityContract = {\n  MAINNET: \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\",\n  TESTNET_SEPOLIA: \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\"\n};\nfunction getStarknetIdIdentityContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return StarknetIdIdentityContract.MAINNET;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return StarknetIdIdentityContract.TESTNET_SEPOLIA;\n    default:\n      throw new Error(\"Starknet.id verifier contract is not yet deployed on this network\");\n  }\n}\nvar StarknetIdMulticallContract = \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\";\nfunction getStarknetIdMulticallContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return StarknetIdMulticallContract;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return StarknetIdMulticallContract;\n    default:\n      throw new Error(\"Starknet.id multicall contract is not yet deployed on this network\");\n  }\n}\nvar StarknetIdVerifierContract = {\n  MAINNET: \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\",\n  TESTNET_SEPOLIA: \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\"\n};\nfunction getStarknetIdVerifierContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return StarknetIdVerifierContract.MAINNET;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return StarknetIdVerifierContract.TESTNET_SEPOLIA;\n    default:\n      throw new Error(\"Starknet.id verifier contract is not yet deployed on this network\");\n  }\n}\nvar StarknetIdPfpContract = {\n  MAINNET: \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\",\n  TESTNET_SEPOLIA: \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\"\n};\nfunction getStarknetIdPfpContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return StarknetIdPfpContract.MAINNET;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return StarknetIdPfpContract.TESTNET_SEPOLIA;\n    default:\n      throw new Error(\n        \"Starknet.id profile picture verifier contract is not yet deployed on this network\"\n      );\n  }\n}\nvar StarknetIdPopContract = {\n  MAINNET: \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\",\n  TESTNET_SEPOLIA: \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\"\n};\nfunction getStarknetIdPopContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return StarknetIdPopContract.MAINNET;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return StarknetIdPopContract.TESTNET_SEPOLIA;\n    default:\n      throw new Error(\n        \"Starknet.id proof of personhood verifier contract is not yet deployed on this network\"\n      );\n  }\n}\nfunction execution(staticEx, ifEqual = void 0, ifNotEqual = void 0) {\n  return new CairoCustomEnum({\n    Static: staticEx,\n    IfEqual: ifEqual ? tuple(ifEqual[0], ifEqual[1], ifEqual[2]) : void 0,\n    IfNotEqual: ifNotEqual ? tuple(ifNotEqual[0], ifNotEqual[1], ifNotEqual[2]) : void 0\n  });\n}\nfunction dynamicFelt(hardcoded, reference = void 0) {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : void 0\n  });\n}\nfunction dynamicCallData(hardcoded, reference = void 0, arrayReference = void 0) {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : void 0,\n    ArrayReference: arrayReference ? tuple(arrayReference[0], arrayReference[1]) : void 0\n  });\n}\nfunction isStarkDomain(domain) {\n  return /^(?:[a-z0-9-]{1,48}(?:[a-z0-9-]{1,48}[a-z0-9-])?\\.)*[a-z0-9-]{1,48}\\.stark$/.test(domain);\n}\n\n// src/provider/extensions/starknetId.ts\nvar StarknetId = class _StarknetId {\n  async getStarkName(address, StarknetIdContract2) {\n    return _StarknetId.getStarkName(\n      // After Mixin, this is ProviderInterface\n      this,\n      address,\n      StarknetIdContract2\n    );\n  }\n  async getAddressFromStarkName(name, StarknetIdContract2) {\n    return _StarknetId.getAddressFromStarkName(\n      // After Mixin, this is ProviderInterface\n      this,\n      name,\n      StarknetIdContract2\n    );\n  }\n  async getStarkProfile(address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {\n    return _StarknetId.getStarkProfile(\n      // After Mixin, this is ProviderInterface\n      this,\n      address,\n      StarknetIdContract2,\n      StarknetIdIdentityContract2,\n      StarknetIdVerifierContract2,\n      StarknetIdPfpContract2,\n      StarknetIdPopContract2,\n      StarknetIdMulticallContract2\n    );\n  }\n  static async getStarkName(provider, address, StarknetIdContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n      const hexDomain = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: \"address_to_domain\",\n        calldata: CallData.compile({\n          address,\n          hint: []\n        })\n      });\n      const decimalDomain = hexDomain.map((element) => BigInt(element)).slice(1);\n      const stringDomain = useDecoded(decimalDomain);\n      if (!stringDomain) {\n        throw Error(\"Starkname not found\");\n      }\n      return stringDomain;\n    } catch (e) {\n      if (e instanceof Error && e.message === \"Starkname not found\") {\n        throw e;\n      }\n      throw Error(\"Could not get stark name\");\n    }\n  }\n  static async getAddressFromStarkName(provider, name, StarknetIdContract2) {\n    const starkName = name.endsWith(\".stark\") ? name : `${name}.stark`;\n    if (!isStarkDomain(starkName)) {\n      throw new Error(\"Invalid domain, must be a valid .stark domain\");\n    }\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n      const encodedDomain = starkName.replace(\".stark\", \"\").split(\".\").map((part) => useEncoded(part).toString(10));\n      const addressData = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: \"domain_to_address\",\n        calldata: CallData.compile({ domain: encodedDomain, hint: [] })\n      });\n      return addressData[0];\n    } catch {\n      throw Error(\"Could not get address from stark name\");\n    }\n  }\n  static async getStarkProfile(provider, address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    const identityContract = StarknetIdIdentityContract2 ?? getStarknetIdIdentityContract(chainId);\n    const verifierContract = StarknetIdVerifierContract2 ?? getStarknetIdVerifierContract(chainId);\n    const pfpContract = StarknetIdPfpContract2 ?? getStarknetIdPfpContract(chainId);\n    const popContract = StarknetIdPopContract2 ?? getStarknetIdPopContract(chainId);\n    const multicallAddress = StarknetIdMulticallContract2 ?? getStarknetIdMulticallContract(chainId);\n    try {\n      const calls = [\n        {\n          execution: execution({}),\n          to: dynamicCallData(contract),\n          selector: dynamicCallData(getSelectorFromName(\"address_to_domain\")),\n          calldata: [dynamicCallData(address), dynamicCallData(\"0\")]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(contract),\n          selector: dynamicFelt(getSelectorFromName(\"domain_to_id\")),\n          calldata: [dynamicCallData(void 0, void 0, [0, 0])]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"twitter\")),\n            dynamicCallData(verifierContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"github\")),\n            dynamicCallData(verifierContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"discord\")),\n            dynamicCallData(verifierContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"proof_of_personhood\")),\n            dynamicCallData(popContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        // PFP\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"nft_pp_contract\")),\n            dynamicCallData(pfpContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_extended_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"nft_pp_id\")),\n            dynamicCallData(\"2\"),\n            dynamicCallData(pfpContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution(void 0, void 0, [6, 0, 0]),\n          to: dynamicFelt(void 0, [6, 0]),\n          selector: dynamicFelt(getSelectorFromName(\"tokenURI\")),\n          calldata: [dynamicCallData(void 0, [7, 1]), dynamicCallData(void 0, [7, 2])]\n        }\n      ];\n      const data = await provider.callContract({\n        contractAddress: multicallAddress,\n        entrypoint: \"aggregate\",\n        calldata: CallData.compile({\n          calls\n        })\n      });\n      if (Array.isArray(data)) {\n        const size = parseInt(data[0], 16);\n        const finalArray = [];\n        let index = 1;\n        for (let i = 0; i < size; i += 1) {\n          if (index < data.length) {\n            const subArraySize = parseInt(data[index], 16);\n            index += 1;\n            const subArray = data.slice(index, index + subArraySize);\n            finalArray.push(subArray);\n            index += subArraySize;\n          } else {\n            break;\n          }\n        }\n        const name = useDecoded(finalArray[0].slice(1).map((hexString) => BigInt(hexString)));\n        const twitter = finalArray[2][0] !== \"0x0\" ? BigInt(finalArray[2][0]).toString() : void 0;\n        const github = finalArray[3][0] !== \"0x0\" ? BigInt(finalArray[3][0]).toString() : void 0;\n        const discord = finalArray[4][0] !== \"0x0\" ? BigInt(finalArray[4][0]).toString() : void 0;\n        const proofOfPersonhood = finalArray[5][0] === \"0x1\";\n        const profilePictureMetadata = data[0] === \"0x9\" ? finalArray[8].slice(1).map((val) => decodeShortString(val)).join(\"\") : void 0;\n        const profilePicture = profilePictureMetadata || `https://starknet.id/api/identicons/${BigInt(finalArray[1][0]).toString()}`;\n        return {\n          name,\n          twitter,\n          github,\n          discord,\n          proofOfPersonhood,\n          profilePicture\n        };\n      }\n      throw Error(\"Error while calling aggregate function\");\n    } catch (e) {\n      if (e instanceof Error) {\n        throw e;\n      }\n      throw Error(\"Could not get user stark profile data from address\");\n    }\n  }\n};\n\n// src/provider/extensions/default.ts\nvar RpcProvider2 = class extends (0,ts_mixer__WEBPACK_IMPORTED_MODULE_15__.Mixin)(RpcProvider, StarknetId) {\n};\n\n// src/provider/interface.ts\nvar ProviderInterface = class {\n};\n\n// src/provider/index.ts\nvar defaultProvider = new RpcProvider({ default: true });\n\n// src/signer/interface.ts\nvar SignerInterface = class {\n};\n\n// src/signer/default.ts\nvar Signer = class {\n  pk;\n  constructor(pk = _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.utils.randomPrivateKey()) {\n    this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n  }\n  async getPubKey() {\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.getStarkKey(this.pk);\n  }\n  async signMessage(typedData, accountAddress) {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    return this.signRaw(msgHash);\n  }\n  async signTransaction(transactions, details) {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signDeployAccountTransaction(details) {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeployAccountTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signDeclareTransaction(details) {\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeclareTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signRaw(msgHash) {\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.sign(msgHash, this.pk);\n  }\n};\n\n// src/signer/ethSigner.ts\n\n\n// src/utils/uint256.ts\nvar uint256_exports = {};\n__export(uint256_exports, {\n  UINT_128_MAX: () => UINT_128_MAX,\n  UINT_256_MAX: () => UINT_256_MAX,\n  bnToUint256: () => bnToUint256,\n  isUint256: () => isUint256,\n  uint256ToBN: () => uint256ToBN\n});\nfunction uint256ToBN(uint2562) {\n  return new CairoUint256(uint2562).toBigInt();\n}\nfunction isUint256(bn) {\n  return CairoUint256.is(bn);\n}\nfunction bnToUint256(bn) {\n  return new CairoUint256(bn).toUint256HexString();\n}\n\n// src/signer/ethSigner.ts\nvar EthSigner = class {\n  pk;\n  // hex string without 0x and with an odd number of characters\n  constructor(pk = ethRandomPrivateKey()) {\n    this.pk = pk instanceof Uint8Array ? buf2hex(pk).padStart(64, \"0\") : removeHexPrefix(toHex(pk)).padStart(64, \"0\");\n  }\n  /**\n   * provides the Ethereum full public key (without parity prefix)\n   * @returns an hex string : 64 first characters are Point X coordinate. 64 last characters are Point Y coordinate.\n   */\n  async getPubKey() {\n    return addHexPrefix(\n      buf2hex(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__.secp256k1.getPublicKey(this.pk, false)).padStart(130, \"0\").slice(2)\n    );\n  }\n  async signMessage(typedData, accountAddress) {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  async signTransaction(transactions, details) {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signTransaction version\");\n    }\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  async signDeployAccountTransaction(details) {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeployAccountTransaction version\");\n    }\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  async signDeclareTransaction(details) {\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeclareTransaction version\");\n    }\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  /**\n   * Serialize the signature in conformity with starknet::eth_signature::Signature\n   * @param ethSignature secp256k1 signature from Noble curves library\n   * @return an array of felts, representing a Cairo Eth Signature.\n   */\n  formatEthSignature(ethSignature) {\n    const r = bnToUint256(ethSignature.r);\n    const s = bnToUint256(ethSignature.s);\n    return [\n      toHex(r.low),\n      toHex(r.high),\n      toHex(s.low),\n      toHex(s.high),\n      toHex(ethSignature.recovery)\n    ];\n  }\n};\n\n// src/signer/ledgerSigner111.ts\nvar LedgerSigner111 = class {\n  transporter;\n  // this is a hack to allow the '@ledgerhq/hw-transport' type to be used as a dev dependency but not exposed in the production build\n  _transporter;\n  accountID;\n  eip2645applicationName;\n  pathBuffer;\n  appVersion;\n  pubKey;\n  fullPubKey;\n  /**\n   * constructor of the LedgerSigner class.\n   * @param {Transport} transport 5 transports are available to handle USB, bluetooth, Node, Web, Mobile.\n   * See Guides for more details.\n   * @param {number} accountID ID of Ledger Nano (can handle 2**31 accounts).\n   * @param {string} [eip2645application='LedgerW'] A wallet is defined by an ERC2645 derivation path (6 items),\n   * and one item is the `application` and can be customized.\n   * Default value is `LedgerW`.\n   * @param {LedgerPathCalculation} [pathFunction=getLedgerPathBuffer111]\n   * defines the function that will calculate the path. By default `getLedgerPathBuffer111` is selected.\n   * @example\n   * ```typescript\n   * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\n   * const myNodeTransport = await TransportNodeHid.create();\n   * const myLedgerSigner = new LedgerSigner111(myNodeTransport, 0);\n   * ```\n   */\n  constructor(transport, accountID, eip2645application = \"LedgerW\", pathFunction = getLedgerPathBuffer111) {\n    assert(accountID >= 0, \"Ledger account ID shall not be a negative number.\");\n    assert(accountID <= MASK_31, \"Ledger account ID shall be < 2**31.\");\n    assert(!!eip2645application, \"Ledger application name shall not be empty.\");\n    this.transporter = transport;\n    this._transporter = this.transporter;\n    this.accountID = accountID;\n    this.pubKey = \"\";\n    this.fullPubKey = \"\";\n    this.eip2645applicationName = eip2645application;\n    this.appVersion = \"\";\n    this.pathBuffer = pathFunction(this.accountID, this.eip2645applicationName);\n  }\n  /**\n   * provides the Starknet public key\n   * @returns an hex string : 64 characters are Point X coordinate.\n   * @example\n   * ```typescript\n   * const result = await myLedgerSigner.getPubKey();\n   * // result= \"0x03681417ba3e1f050dd3ccdceb8d22b5e44fa70ee7844d472c6a768bded5174e\"\n   * ```\n   */\n  async getPubKey() {\n    if (!this.pubKey) await this.getPublicKeys();\n    return this.pubKey;\n  }\n  /**\n   * provides the full public key (with parity prefix)\n   * @returns an hex string : 2 first characters are the parity, the 64 following characters are Point X coordinate. 64 last characters are Point Y coordinate.\n   * @example\n   * ```typescript\n   * const result = await myLedgerSigner.getFullPubKey();\n   * // result= \"0x0403681417ba3e1f050dd3ccdceb8d22b5e44fa70ee7844d472c6a768bded5174e03cbc86f805dcfcb0c1922dd4daf181afa289d86223a18bc856276615bcc7787\"\n   * ```\n   */\n  async getFullPubKey() {\n    if (!this.fullPubKey) await this.getPublicKeys();\n    return this.fullPubKey;\n  }\n  /**\n   * Returns the version of the Starknet APP implemented in the Ledger.\n   * @returns {string} version.\n   * @example\n   * ```typescript\n   * const result = await myLedgerSigner.getAppVersion();\n   * // result= \"1.1.1\"\n   * ```\n   */\n  async getAppVersion() {\n    if (!this.appVersion) {\n      const resp = await this._transporter.send(Number(\"0x5a\"), 0, 0, 0);\n      this.appVersion = `${resp[0]}.${resp[1]}.${resp[2]}`;\n    }\n    return this.appVersion;\n  }\n  /**\n   * Sign a TypedData message (SNIP-12) in a Ledger.\n   * @param {typedDataToHash} typedDataToHash A TypedData message compatible with SNIP-12.\n   * @param {string} accountAddress Signer account address (Hex or num string)\n   * @returns {Signature} The signed message.\n   * @example\n   * ```typescript\n   * const result = myLedgerSigner.signMessage(snip12Message, account0.address);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  async signMessage(typedDataToHash, accountAddress) {\n    const msgHash = getMessageHash(typedDataToHash, accountAddress);\n    return this.signRaw(msgHash);\n  }\n  /**\n   * Sign in a Ledger a V1 or a V3 transaction. This is a blind sign on the Ledger screen.\n   * @param {Call1[]} transactions An array of `Call` transactions (generated for example by `myContract.populate()`).\n   * @param {InvocationsSignerDetails} transactionsDetail An object that includes all the necessary inputs to hash the transaction. Can be `V2InvocationsSignerDetails` or `V3InvocationsSignerDetails` type.\n   * @returns {Signature} The signed transaction.\n   * @example\n   * ```typescript\n   * const txDetailsV3: V3InvocationsSignerDetails = {\n   * chainId: constants.StarknetChainId.SN_MAIN,\n   * nonce: \"28\",\n   * accountDeploymentData: [],\n   * paymasterData: [],\n   * cairoVersion: \"1\",\n   * feeDataAvailabilityMode: \"L1\",\n   * nonceDataAvailabilityMode: \"L1\",\n   * resourceBounds: {\n   *   l1_gas: {\n   *     max_amount: \"0x2a00\",\n   *     max_price_per_unit: \"0x5c00000\"\n   *   },\n   *   l2_gas: {\n   *     max_amount: \"0x00\",\n   *     max_price_per_unit: \"0x00\"\n   *   },\n   * },\n   * tip: 0,\n   * version: \"0x3\",\n   * walletAddress: account0.address\n   * }\n   * const result = myLedgerSigner.signTransaction([call0, call1], txDetailsV3);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  async signTransaction(transactions, transactionsDetail) {\n    const compiledCalldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion);\n    let msgHash;\n    if (Object.values(ETransactionVersion2).includes(transactionsDetail.version)) {\n      const det = transactionsDetail;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(transactionsDetail.version)) {\n      const det = transactionsDetail;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  /**\n   * Sign in a Ledger the deployment of a new account. This is a blind sign on the Ledger screen.\n   * @param {DeployAccountSignerDetails} details An object that includes all necessary data to calculate the Hash. It can be `V2DeployAccountSignerDetails` or `V3DeployAccountSignerDetails` types.\n   * @returns {Signature} The deploy account signature.\n   * @example\n   * ```typescript\n   * const result = myLedgerSigner.signDeployAccountTransaction(details);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  async signDeployAccountTransaction(details) {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    let msgHash;\n    if (Object.values(ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeployAccountTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  /**\n   * Sign in a Ledger the declaration of a new class. This is a blind sign on the Ledger screen.\n   * @param {DeclareSignerDetails} details An object that includes all necessary data to calculate the Hash. It can be `V3DeclareSignerDetails` or `V2DeclareSignerDetails` types.\n   * @returns {Signature} The declare Signature.\n   * @example\n   * ```typescript\n   * const result = myLedgerSigner.signDeclareTransaction(details);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  async signDeclareTransaction(details) {\n    let msgHash;\n    if (Object.values(ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeclareTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  /**\n   * Internal function to sign a hash in a Ledger Nano.\n   * This is a blind sign in the Ledger ; no display of what you are signing.\n   */\n  async signRaw(msgHash) {\n    addHexPrefix(\n      buf2hex(await this._transporter.send(Number(\"0x5a\"), 2, 0, 0, Buffer.from(this.pathBuffer)))\n    );\n    const shiftedHash = toHex(BigInt(msgHash) << 4n);\n    const buff2 = hexToBytes(shiftedHash);\n    const respSign2 = Uint8Array.from(\n      await this._transporter.send(Number(\"0x5a\"), 2, 1, 0, Buffer.from(buff2))\n    );\n    const r = BigInt(addHexPrefix(buf2hex(respSign2.subarray(1, 33))));\n    const s = BigInt(addHexPrefix(buf2hex(respSign2.subarray(33, 65))));\n    const v = respSign2[65];\n    const sign0 = new _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.Signature(r, s);\n    const sign1 = sign0.addRecoveryBit(v);\n    return sign1;\n  }\n  /** internal function to get both the Starknet public key and the full public key */\n  async getPublicKeys() {\n    const pathBuff = this.pathBuffer;\n    const respGetPublic = Uint8Array.from(\n      await this._transporter.send(Number(\"0x5a\"), 1, 0, 0, Buffer.from(pathBuff))\n    );\n    this.pubKey = addHexPrefix(buf2hex(respGetPublic.subarray(1, 33)));\n    this.fullPubKey = addHexPrefix(buf2hex(respGetPublic.subarray(0, 65)));\n  }\n};\nfunction getLedgerPathBuffer111(accountId, applicationName = \"LedgerW\") {\n  const path0buff = new Uint8Array([128, 0, 10, 85]);\n  const path1buff = new Uint8Array([71, 65, 233, 201]);\n  const path2buff = applicationName === \"LedgerW\" ? new Uint8Array([43, 206, 231, 219]) : stringToSha256ToArrayBuff4(applicationName);\n  const path3buff = new Uint8Array([0, 0, 0, 0]);\n  const hex = toHex(accountId);\n  const padded = addHexPrefix(removeHexPrefix(hex).padStart(8, \"0\"));\n  const path4buff = hexToBytes(padded);\n  const path5buff = new Uint8Array([0, 0, 0, 0]);\n  const pathBuff = concatenateArrayBuffer([\n    path0buff,\n    path1buff,\n    path2buff,\n    path3buff,\n    path4buff,\n    path5buff\n  ]);\n  return pathBuff;\n}\n\n// src/utils/address.ts\n\nfunction addAddressPadding(address) {\n  const hex = toHex(addHexPrefix(address.toString()));\n  const padded = removeHexPrefix(hex).padStart(64, \"0\");\n  return addHexPrefix(padded);\n}\nfunction validateAndParseAddress(address) {\n  const result = addAddressPadding(address);\n  if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n    throw new Error(\"Invalid Address Format\");\n  }\n  assertInRange(result, ZERO, ADDR_BOUND - 1n, \"Starknet Address\");\n  return result;\n}\nfunction getChecksumAddress(address) {\n  const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split(\"\");\n  const hex = removeHexPrefix(keccakBn(address));\n  const hashed = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.hexToBytes)(hex.padStart(64, \"0\"));\n  for (let i = 0; i < chars.length; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 15) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n  return addHexPrefix(chars.join(\"\"));\n}\nfunction validateChecksumAddress(address) {\n  return getChecksumAddress(address) === address;\n}\n\n// src/signer/ledgerSigner221.ts\nvar LedgerSigner221 = class extends LedgerSigner111 {\n  /**\n   * constructor of the LedgerSigner class.\n   * @param {Transport} transport 5 transports are available to handle USB, bluetooth, Node, Web, Mobile.\n   * See Guides for more details.\n   * @param {number} accountID ID of Ledger Nano (can handle 2**31 accounts).\n   * @param {string} [eip2645application='LedgerW'] A wallet is defined by an ERC2645 derivation path (6 items).\n   * One item is called `application` and can be customized.\n   * Default value is `LedgerW`.\n   * @param {LedgerPathCalculation} [pathFunction=getLedgerPathBuffer221]\n   * defines the function that will calculate the path. By default `getLedgerPathBuffer221` is selected.\n   *\n   * If you are using APP v2.2.1 with an account created with the v1.1.1, you need to use :\n   * ```typescript\n   * const myLedgerSigner = new LedgerSigner211(myNodeTransport, 0, undefined, getLedgerPathBuffer111);\n   * ```\n   * @example\n   * ```typescript\n   * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\n   * const myNodeTransport = await TransportNodeHid.create();\n   * const myLedgerSigner = new LedgerSigner211(myNodeTransport, 0);\n   * ```\n   */\n  constructor(transport, accountID, eip2645application = \"LedgerW\", pathFunction = getLedgerPathBuffer221) {\n    super(transport, accountID, eip2645application, pathFunction);\n  }\n  /**\n   * Sign in a Ledger a V1 or a V3 transaction. The details are displayed on the Ledger screen.\n   * @param {Call[]} transactions An array of `Call` transactions (generated for example by `myContract.populate()`).\n   * @param {InvocationsSignerDetails} transactionsDetail An object that includes all the necessary inputs to hash the transaction. Can be `V2InvocationsSignerDetails` or `V3InvocationsSignerDetails` type.\n   * @returns {Signature} The signed transaction.\n   * @example\n   * ```typescript\n   * const txDetailsV3: V3InvocationsSignerDetails = {\n   * chainId: constants.StarknetChainId.SN_MAIN,\n   * nonce: \"28\",\n   * accountDeploymentData: [],\n   * paymasterData: [],\n   * cairoVersion: \"1\",\n   * feeDataAvailabilityMode: \"L1\",\n   * nonceDataAvailabilityMode: \"L1\",\n   * resourceBounds: {\n   *   l1_gas: {\n   *     max_amount: \"0x2a00\",\n   *     max_price_per_unit: \"0x5c00000\"\n   *   },\n   *   l2_gas: {\n   *     max_amount: \"0x00\",\n   *     max_price_per_unit: \"0x00\"\n   *   },\n   * },\n   * tip: 0,\n   * version: \"0x3\",\n   * walletAddress: account0.address\n   * }\n   * const result = myLedgerSigner.signTransaction([call0, call1], txDetailsV3);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  async signTransaction(transactions, transactionsDetail) {\n    const compiledCalldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion);\n    if (Object.values(ETransactionVersion2).includes(transactionsDetail.version)) {\n      const det = transactionsDetail;\n      const msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version\n      });\n      const ledgerResponse = await this.signTxV1(det, transactions);\n      assert(\n        toBigInt(msgHash) === ledgerResponse.hash,\n        \"The transaction hash calculated by Starknet.js is different from the one calculated by the Ledger.\"\n      );\n      return ledgerResponse.signature;\n    }\n    if (Object.values(api_exports.ETransactionVersion3).includes(transactionsDetail.version)) {\n      const det = transactionsDetail;\n      const msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n      const ledgerResponse = await this.signTxV3(det, transactions);\n      assert(\n        toBigInt(msgHash) === ledgerResponse.hash,\n        \"The transaction hash calculated by Starknet.js is different from the one calculated by the Ledger.\"\n      );\n      return ledgerResponse.signature;\n    }\n    throw Error(\"unsupported signTransaction version\");\n  }\n  /**\n   * Sign in a Ledger the deployment of a new account. The details are displayed on the Ledger screen.\n   * @param {DeployAccountSignerDetails} details An object that includes all necessary data to calculate the Hash. It can be `V2DeployAccountSignerDetails` or `V3DeployAccountSignerDetails` types.\n   * @returns {Signature} The deploy account signature.\n   * @example\n   * ```typescript\n   * const result = myLedgerSigner.signDeployAccountTransaction(details);\n   * // result = Signature { r: 611475243393396148729326917410546146405234155928298353899191529090923298688n,\n   * // s: 798839819213540985856952481651392652149797817551686626114697493101433761982n,\n   * // recovery: 0}\n   * ```\n   */\n  async signDeployAccountTransaction(details) {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    let msgHash;\n    if (Object.values(ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version\n      });\n      const ledgerResponse = await this.signDeployAccountV1(det);\n      assert(\n        toBigInt(msgHash) === ledgerResponse.hash,\n        \"The transaction hash calculated by Starknet.js is different from the one calculated by the Ledger.\"\n      );\n      return ledgerResponse.signature;\n    }\n    if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n      const ledgerResponse = await this.signDeployAccountV3(det);\n      assert(\n        toBigInt(msgHash) === ledgerResponse.hash,\n        \"The transaction hash calculated by Starknet.js is different from the one calculated by the Ledger.\"\n      );\n      return ledgerResponse.signature;\n    }\n    throw Error(\"unsupported signDeployAccountTransaction version\");\n  }\n  /**\n   * Internal function to convert a bigNumberish to an Uint8array of 256 bits\n   * @param {BigNumberish} input input value\n   * @returns {Uint8Array} a Uint8Array containing 32 bytes.\n   */\n  convertBnToLedger(input) {\n    return hexToBytes(addAddressPadding(toHex(input)));\n  }\n  /**\n   * Internal function to decode the response of the Ledger signature\n   * @param {Uint8Array} respSign the Buffer response of the Ledger\n   * @returns { hash: bigint; signature: Signature } transaction hash & signature\n   */\n  decodeSignatureLedger(respSign) {\n    const h = BigInt(addHexPrefix(buf2hex(respSign.subarray(0, 32))));\n    const r = BigInt(addHexPrefix(buf2hex(respSign.subarray(33, 65))));\n    const s = BigInt(addHexPrefix(buf2hex(respSign.subarray(65, 97))));\n    const v = respSign[97];\n    const sign0 = new _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.Signature(r, s);\n    const sign1 = sign0.addRecoveryBit(v);\n    return { hash: h, signature: sign1 };\n  }\n  /** Internal function to convert a Call to an array of Uint8Array.\n   * @param {Call} call A Call to convert.\n   * @return {Uint8Array[]} Call encoded in an array of Uint8Array (each containing 7 u256).\n   */\n  encodeCall(call) {\n    const toBuf = this.convertBnToLedger(call.contractAddress);\n    const selectorBuf = hexToBytes(addAddressPadding(getSelector(call.entrypoint)));\n    let calldataBuf = new Uint8Array([]);\n    if (call.calldata) {\n      const compiledCalldata = CallData.compile(call.calldata);\n      calldataBuf = concatenateArrayBuffer(\n        compiledCalldata.map((parameter) => {\n          const a = this.convertBnToLedger(parameter);\n          return a;\n        })\n      );\n    }\n    const callBuf = concatenateArrayBuffer([toBuf, selectorBuf, calldataBuf]);\n    const calldatas = [];\n    const chunkSize = 7 * 32;\n    for (let i = 0; i < callBuf.length; i += chunkSize)\n      calldatas.push(callBuf.subarray(i, i + chunkSize));\n    return calldatas;\n  }\n  /**\n   * Ask the Ledger Nano to display and sign a Starknet V1 transaction.\n   * @param {V2InvocationsSignerDetails} txDetails All the details needed for a txV1.\n   * @param {Call[]} calls array of Starknet invocations\n   * @returns an object including the transaction Hash and the signature\n   * @example\n   * ```typescript\n   * const calls: Call[] = [{contractAddress: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n   *      entrypoint: \"transfer\",\n   *      calldata:[\"0x11f5fc2a92ac03434a7937fe982f5e5293b65ad438a989c5b78fb8f04a12016\",\n   *        \"0x9184e72a000\", \"0x0\"]}];\n   * const txDet: V2InvocationsSignerDetails = {\n   *    walletAddress: txDetails.accountAddress,\n   *    chainId: constants.StarknetChainId.SN_MAIN,\n   *    cairoVersion: \"1\", maxFee: txDetails.max_fee,\n   *    nonce: txDetails.nonce, version: \"0x1\"\n   *  };\n   * const res = await myLedgerSigner.signTxV1(txDet, calls);\n   * // res = {hash:\n   * //   signature:\n   * // }\n   * ```\n   */\n  async signTxV1(txDetails, calls) {\n    await this._transporter.send(Number(\"0x5a\"), 4, 0, 0, Buffer.from(this.pathBuffer));\n    const accountAddressBuf = this.convertBnToLedger(txDetails.walletAddress);\n    const maxFeeBuf = this.convertBnToLedger(txDetails.maxFee);\n    const chainIdBuf = this.convertBnToLedger(txDetails.chainId);\n    const nonceBuf = this.convertBnToLedger(txDetails.nonce);\n    const dataBuf = concatenateArrayBuffer([\n      accountAddressBuf,\n      maxFeeBuf,\n      chainIdBuf,\n      nonceBuf\n    ]);\n    await this._transporter.send(Number(\"0x5a\"), 4, 1, 0, Buffer.from(dataBuf));\n    const nbCallsBuf = this.convertBnToLedger(calls.length);\n    await this._transporter.send(Number(\"0x5a\"), 4, 2, 0, Buffer.from(nbCallsBuf));\n    let respSign = new Uint8Array(0);\n    for (const call of calls) {\n      const calldatas = this.encodeCall(call);\n      await this._transporter.send(Number(\"0x5a\"), 4, 3, 0, Buffer.from(calldatas[0]));\n      if (calldatas.length > 1) {\n        calldatas.slice(1).forEach(async (part) => {\n          await this._transporter.send(Number(\"0x5a\"), 4, 3, 1, Buffer.from(part));\n        });\n      }\n      respSign = await this._transporter.send(Number(\"0x5a\"), 4, 3, 2);\n    }\n    return this.decodeSignatureLedger(respSign);\n  }\n  /**\n   * Ask to the Ledger Nano to display and sign a Starknet V3 transaction.\n   * @param {V3InvocationsSignerDetails} txDetails All the details needed for a txV3.\n   * @param {Call[]} calls array of Starknet invocations\n   * @returns an object including the transaction Hash and the signature\n   * @example\n   * ```typescript\n   * const calls: Call[] = [{contractAddress: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n   *      entrypoint: \"transfer\",\n   *      calldata:[\"0x11f5fc2a92ac03434a7937fe982f5e5293b65ad438a989c5b78fb8f04a12016\",\n   *        \"0x9184e72a000\", \"0x0\"]}];\n   * const txDetailsV3: V3InvocationsSignerDetails = {\n   *   chainId: constants.StarknetChainId.SN_MAIN,\n   *   nonce: \"28\", accountDeploymentData: [],\n   *   paymasterData: [], cairoVersion: \"1\",\n   *   feeDataAvailabilityMode: \"L1\", nonceDataAvailabilityMode: \"L1\",\n   *   resourceBounds: {\n   *     l1_gas: { max_amount: \"0x2a00\", max_price_per_unit: \"0x5c00000\"\n   *     },\n   *     l2_gas: { max_amount: \"0x00\", max_price_per_unit: \"0x00\"},\n   *   }, tip: 0, version: \"0x3\", walletAddress: account0.address\n   *  };\n   * const res = await myLedgerSigner.signTxV3(txDetailsV3, calls);\n   * // res = {hash:\n   * //   signature:\n   * // }\n   * ```\n   */\n  async signTxV3(txDetails, calls) {\n    assert(txDetails.paymasterData.length <= 7, \"Paymaster data includes more than 7 items.\");\n    assert(\n      txDetails.accountDeploymentData.length <= 7,\n      \"accountDeploymentData includes more than 7 items\"\n    );\n    await this._transporter.send(Number(\"0x5a\"), 3, 0, 0, Buffer.from(this.pathBuffer));\n    const accountAddressBuf = this.convertBnToLedger(txDetails.walletAddress);\n    const tipBuf = this.convertBnToLedger(txDetails.tip);\n    const chainIdBuf = this.convertBnToLedger(txDetails.chainId);\n    const nonceBuf = this.convertBnToLedger(txDetails.nonce);\n    const dAModeHashBuf = this.convertBnToLedger(\n      hashDAMode(\n        txDetails.nonceDataAvailabilityMode === api_exports.EDataAvailabilityMode.L1 ? api_exports.EDAMode.L1 : api_exports.EDAMode.L2,\n        txDetails.feeDataAvailabilityMode === api_exports.EDataAvailabilityMode.L1 ? api_exports.EDAMode.L1 : api_exports.EDAMode.L2\n      )\n    );\n    const l1_gasBuf = this.convertBnToLedger(encodeResourceBoundsL1(txDetails.resourceBounds));\n    const l2_gasBuf = this.convertBnToLedger(encodeResourceBoundsL2(txDetails.resourceBounds));\n    const dataBuf = concatenateArrayBuffer([\n      accountAddressBuf,\n      tipBuf,\n      l1_gasBuf,\n      l2_gasBuf,\n      chainIdBuf,\n      nonceBuf,\n      dAModeHashBuf\n    ]);\n    await this._transporter.send(Number(\"0x5a\"), 3, 1, 0, Buffer.from(dataBuf));\n    const paymasterBuf = concatenateArrayBuffer(\n      txDetails.paymasterData.map((value) => {\n        const a = this.convertBnToLedger(value);\n        return a;\n      })\n    );\n    await this._transporter.send(Number(\"0x5a\"), 3, 2, 0, Buffer.from(paymasterBuf));\n    const accountDeployDataBuf = concatenateArrayBuffer(\n      txDetails.paymasterData.map((value) => {\n        const a = this.convertBnToLedger(value);\n        return a;\n      })\n    );\n    await this._transporter.send(Number(\"0x5a\"), 3, 3, 0, Buffer.from(accountDeployDataBuf));\n    const nbCallsBuf = this.convertBnToLedger(calls.length);\n    await this._transporter.send(Number(\"0x5a\"), 3, 4, 0, Buffer.from(nbCallsBuf));\n    let respSign = new Uint8Array(0);\n    for (const call of calls) {\n      const calldatas = this.encodeCall(call);\n      await this._transporter.send(Number(\"0x5a\"), 3, 5, 0, Buffer.from(calldatas[0]));\n      if (calldatas.length > 1) {\n        calldatas.slice(1).forEach(async (part) => {\n          await this._transporter.send(Number(\"0x5a\"), 3, 5, 1, Buffer.from(part));\n        });\n      }\n      respSign = await this._transporter.send(Number(\"0x5a\"), 3, 5, 2);\n    }\n    return this.decodeSignatureLedger(respSign);\n  }\n  /**\n   * Ask the Ledger Nano to display and sign a Starknet V1 account deployment.\n   * @param {V2DeployAccountSignerDetails} deployAccountDetail All the details needed for a V1 deploy account.\n   * @returns an object including the transaction Hash and the signature\n   * @example\n   * ```typescript\n   * const deployData: V2DeployAccountSignerDetails =\n   * {\n   *  tip: 0, paymasterData: [], accountDeploymentData: [],\n   *  nonceDataAvailabilityMode: 'L1', feeDataAvailabilityMode: 'L1',\n   *  resourceBounds: {\n   *    l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n   *    l1_gas: { max_amount: '0x0', max_price_per_unit: '0x0' }\n   *   },\n   *  classHash: '0x540d7f5ec7ecf317e68d48564934cb99259781b1ee3cedbbc37ec5337f8e688',\n   *  constructorCalldata: [\n   *    '89832696000889662999767022750851886674077821293893187900664573372145410755'\n   *  ],\n   *  contractAddress: '0x32c60fba64eb96831d064bbb2319375b7b7381543abe66da872e4344bcd72a0',\n   *  addressSalt: '0x0032d7efe2a9232f9b463e7206c68fdea4aeb13fec0cb308c6ba1d197d5922c3',\n   *  chainId: '0x534e5f5345504f4c4941', maxFee: 55050000000000n,\n   *  version: '0x1', nonce: 0n\n   *}\n   * const res = await myLedgerSigner.signDeployAccountV1(deployData);\n   * // res = {hash:\n   * //   signature:\n   * // }\n   * ```\n   */\n  async signDeployAccountV1(deployAccountDetail) {\n    await this._transporter.send(Number(\"0x5a\"), 6, 0, 0, Buffer.from(this.pathBuffer));\n    const accountAddressBuf = this.convertBnToLedger(\n      deployAccountDetail.contractAddress\n    );\n    const classHashBuf = this.convertBnToLedger(deployAccountDetail.classHash);\n    const saltBuf = this.convertBnToLedger(deployAccountDetail.addressSalt);\n    const chainIdBuf = this.convertBnToLedger(deployAccountDetail.chainId);\n    const nonceBuf = this.convertBnToLedger(deployAccountDetail.nonce);\n    const dataBuf = concatenateArrayBuffer([\n      accountAddressBuf,\n      classHashBuf,\n      saltBuf,\n      chainIdBuf,\n      nonceBuf\n    ]);\n    await this._transporter.send(Number(\"0x5a\"), 6, 1, 0, Buffer.from(dataBuf));\n    const maxFreeBuf = this.convertBnToLedger(deployAccountDetail.maxFee);\n    await this._transporter.send(Number(\"0x5a\"), 6, 2, 0, Buffer.from(maxFreeBuf));\n    const compiledConstructor = CallData.compile(deployAccountDetail.constructorCalldata);\n    const constructorLengthBuf = this.convertBnToLedger(compiledConstructor.length);\n    await this._transporter.send(Number(\"0x5a\"), 6, 3, 0, Buffer.from(constructorLengthBuf));\n    const constructorBuf = concatenateArrayBuffer(\n      compiledConstructor.map((parameter) => {\n        const a = this.convertBnToLedger(parameter);\n        return a;\n      })\n    );\n    const constructorChunks = [];\n    const chunkSize = 7 * 32;\n    for (let i = 0; i < constructorBuf.length; i += chunkSize)\n      constructorChunks.push(constructorBuf.subarray(i, i + chunkSize));\n    let respSign = new Uint8Array(0);\n    for (const chunk of constructorChunks) {\n      respSign = await this._transporter.send(Number(\"0x5a\"), 6, 4, 0, Buffer.from(chunk));\n    }\n    return this.decodeSignatureLedger(respSign);\n  }\n  /**\n   *Ask the Ledger Nano to display and sign a Starknet V3 account deployment.\n   * @param {V3DeployAccountSignerDetails} deployAccountDetail All the details needed for a V3 deploy account.\n   * @returns an object including the transaction Hash and the signature\n   * @example\n   * ```typescript\n   * const deployData: V3DeployAccountSignerDetails =\n   * {\n   *  tip: 0, paymasterData: [], accountDeploymentData: [],\n   *  nonceDataAvailabilityMode: 'L1', feeDataAvailabilityMode: 'L1',\n   *  resourceBounds: {\n   *    l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n   *    l1_gas: { max_amount: '0x226', max_price_per_unit: '0x22ecb25c00' }\n   *   },\n   *  classHash: '0x540d7f5ec7ecf317e68d48564934cb99259781b1ee3cedbbc37ec5337f8e688',\n   *  constructorCalldata: [\n   *    '3571125127744830445572285574469842579401255431821644822726857471463672199621'\n   *  ],\n   *  contractAddress: '0x4ca062add1cf12a107be1107af17981cf6e544a24d987693230ea481d3d5e34',\n   *  addressSalt: '0x07e52f68e3160e1ef698211cdf6d3792368fe347e7e2d4a8ace14d9b248f39c5',\n   *  chainId: '0x534e5f5345504f4c4941', maxFee: 0,\n   *  version: '0x3', nonce: 0n\n   *}\n   * const res = await myLedgerSigner.signDeployAccountV3(deployData);\n   * // res = {hash:\n   * //   signature:\n   * // }\n   * ```\n   */\n  async signDeployAccountV3(deployAccountDetail) {\n    await this._transporter.send(Number(\"0x5a\"), 5, 0, 0, Buffer.from(this.pathBuffer));\n    const accountAddressBuf = this.convertBnToLedger(\n      deployAccountDetail.contractAddress\n    );\n    const chainIdBuf = this.convertBnToLedger(deployAccountDetail.chainId);\n    const nonceBuf = this.convertBnToLedger(deployAccountDetail.nonce);\n    const dAModeHashBuf = this.convertBnToLedger(\n      hashDAMode(\n        deployAccountDetail.nonceDataAvailabilityMode === api_exports.EDataAvailabilityMode.L1 ? api_exports.EDAMode.L1 : api_exports.EDAMode.L2,\n        deployAccountDetail.feeDataAvailabilityMode === api_exports.EDataAvailabilityMode.L1 ? api_exports.EDAMode.L1 : api_exports.EDAMode.L2\n      )\n    );\n    const classHashBuf = this.convertBnToLedger(deployAccountDetail.classHash);\n    const saltBuf = this.convertBnToLedger(deployAccountDetail.addressSalt);\n    const dataBuf = concatenateArrayBuffer([\n      accountAddressBuf,\n      chainIdBuf,\n      nonceBuf,\n      dAModeHashBuf,\n      classHashBuf,\n      saltBuf\n    ]);\n    await this._transporter.send(Number(\"0x5a\"), 5, 1, 0, Buffer.from(dataBuf));\n    const tipBuf = this.convertBnToLedger(deployAccountDetail.tip);\n    const l1_gasBuf = this.convertBnToLedger(\n      encodeResourceBoundsL1(deployAccountDetail.resourceBounds)\n    );\n    const l2_gasBuf = this.convertBnToLedger(\n      encodeResourceBoundsL2(deployAccountDetail.resourceBounds)\n    );\n    const feeBuf = concatenateArrayBuffer([tipBuf, l1_gasBuf, l2_gasBuf]);\n    await this._transporter.send(Number(\"0x5a\"), 5, 2, 0, Buffer.from(feeBuf));\n    const paymasterBuf = concatenateArrayBuffer(\n      deployAccountDetail.paymasterData.map((value) => {\n        const a = this.convertBnToLedger(value);\n        return a;\n      })\n    );\n    await this._transporter.send(Number(\"0x5a\"), 5, 3, 0, Buffer.from(paymasterBuf));\n    const compiledConstructor = CallData.compile(deployAccountDetail.constructorCalldata);\n    const constructorLengthBuf = this.convertBnToLedger(compiledConstructor.length);\n    await this._transporter.send(Number(\"0x5a\"), 5, 4, 0, Buffer.from(constructorLengthBuf));\n    const constructorBuf = concatenateArrayBuffer(\n      compiledConstructor.map((parameter) => {\n        const a = this.convertBnToLedger(parameter);\n        return a;\n      })\n    );\n    const constructorChunks = [];\n    const chunkSize = 7 * 32;\n    for (let i = 0; i < constructorBuf.length; i += chunkSize)\n      constructorChunks.push(constructorBuf.subarray(i, i + chunkSize));\n    let respSign = new Uint8Array(0);\n    for (const chunk of constructorChunks) {\n      respSign = await this._transporter.send(Number(\"0x5a\"), 5, 5, 0, Buffer.from(chunk));\n    }\n    return this.decodeSignatureLedger(respSign);\n  }\n};\nfunction getLedgerPathBuffer221(accountId, applicationName = \"LedgerW\") {\n  const path0buff = new Uint8Array([HARDENING_BYTE, 0, 10, 85]);\n  const path1buff = new Uint8Array([71 | HARDENING_BYTE, 65, 233, 201]);\n  const path2Base = applicationName === \"LedgerW\" ? new Uint8Array([43, 206, 231, 219]) : stringToSha256ToArrayBuff4(applicationName);\n  const path2buff = concatenateArrayBuffer([\n    new Uint8Array([path2Base[0] | HARDENING_BYTE]),\n    path2Base.subarray(1)\n  ]);\n  const path3buff = new Uint8Array([HARDENING_BYTE, 0, 0, 0]);\n  const hex = toHex(BigInt(accountId) | HARDENING_4BYTES);\n  const padded = addHexPrefix(removeHexPrefix(hex).padStart(8, \"0\"));\n  const path4buff = hexToBytes(padded);\n  const path5buff = new Uint8Array([0, 0, 0, 0]);\n  const pathBuff = concatenateArrayBuffer([\n    path0buff,\n    path1buff,\n    path2buff,\n    path3buff,\n    path4buff,\n    path5buff\n  ]);\n  return pathBuff;\n}\n\n// src/utils/events/index.ts\nvar events_exports = {};\n__export(events_exports, {\n  getAbiEvents: () => getAbiEvents,\n  isAbiEvent: () => isAbiEvent,\n  parseEvents: () => parseEvents,\n  parseUDCEvent: () => parseUDCEvent\n});\nfunction isAbiEvent(object) {\n  return object.type === \"event\";\n}\nfunction getCairo0AbiEvents(abi) {\n  return abi.filter((abiEntry) => abiEntry.type === \"event\").reduce((acc, abiEntry) => {\n    const entryName = abiEntry.name;\n    const abiEntryMod = { ...abiEntry };\n    abiEntryMod.name = entryName;\n    return {\n      ...acc,\n      [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod\n    };\n  }, {});\n}\nfunction getCairo1AbiEvents(abi) {\n  const abiEventsStructs = abi.filter((obj) => isAbiEvent(obj) && obj.kind === \"struct\");\n  const abiEventsEnums = abi.filter((obj) => isAbiEvent(obj) && obj.kind === \"enum\");\n  const abiEventsData = abiEventsStructs.reduce((acc, event) => {\n    let nameList = [];\n    let { name } = event;\n    let flat = false;\n    const findName = (variant) => variant.type === name;\n    while (true) {\n      const eventEnum = abiEventsEnums.find((eventE) => eventE.variants.some(findName));\n      if (isUndefined(eventEnum)) break;\n      const variant = eventEnum.variants.find(findName);\n      nameList.unshift(variant.name);\n      if (variant.kind === \"flat\") flat = true;\n      name = eventEnum.name;\n    }\n    if (nameList.length === 0) {\n      throw new Error(\"inconsistency in ABI events definition.\");\n    }\n    if (flat) nameList = [nameList[nameList.length - 1]];\n    const final = nameList.pop();\n    let result = {\n      [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak(utf8ToArray(final)).toString(16))]: event\n    };\n    while (nameList.length > 0) {\n      result = {\n        [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak(utf8ToArray(nameList.pop())).toString(16))]: result\n      };\n    }\n    result = { ...result };\n    return mergeAbiEvents(acc, result);\n  }, {});\n  return abiEventsData;\n}\nfunction getAbiEvents(abi) {\n  return isCairo1Abi(abi) ? getCairo1AbiEvents(abi) : getCairo0AbiEvents(abi);\n}\nfunction mergeAbiEvents(target, source) {\n  const output = { ...target };\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isObject(source[key])) {\n        if (!(key in target)) Object.assign(output, { [key]: source[key] });\n        else output[key] = mergeAbiEvents(target[key], source[key]);\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n  return output;\n}\nfunction parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {\n  const ret = providerReceivedEvents.flat().reduce((acc, recEvent) => {\n    let abiEvent = abiEvents[recEvent.keys.shift() ?? 0];\n    if (!abiEvent) {\n      return acc;\n    }\n    while (!abiEvent.name) {\n      const hashName = recEvent.keys.shift();\n      assert(!!hashName, 'Not enough data in \"keys\" property of this event.');\n      abiEvent = abiEvent[hashName];\n    }\n    const parsedEvent = {};\n    parsedEvent[abiEvent.name] = {};\n    const keysIter = recEvent.keys[Symbol.iterator]();\n    const dataIter = recEvent.data[Symbol.iterator]();\n    const abiEventKeys = abiEvent.members?.filter((it) => it.kind === \"key\") || abiEvent.keys;\n    const abiEventData = abiEvent.members?.filter((it) => it.kind === \"data\") || abiEvent.data;\n    abiEventKeys.forEach((key) => {\n      parsedEvent[abiEvent.name][key.name] = responseParser(\n        keysIter,\n        key,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name]\n      );\n    });\n    abiEventData.forEach((data) => {\n      parsedEvent[abiEvent.name][data.name] = responseParser(\n        dataIter,\n        data,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name]\n      );\n    });\n    if (\"block_hash\" in recEvent) parsedEvent.block_hash = recEvent.block_hash;\n    if (\"block_number\" in recEvent) parsedEvent.block_number = recEvent.block_number;\n    if (\"transaction_hash\" in recEvent) parsedEvent.transaction_hash = recEvent.transaction_hash;\n    acc.push(parsedEvent);\n    return acc;\n  }, []);\n  return ret;\n}\nfunction parseUDCEvent(txReceipt) {\n  if (!txReceipt.events?.length) {\n    throw new Error(\"UDC emitted event is empty\");\n  }\n  const event = txReceipt.events.find(\n    (it) => cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)\n  ) || {\n    data: []\n  };\n  return {\n    transaction_hash: txReceipt.transaction_hash,\n    contract_address: event.data[0],\n    address: event.data[0],\n    deployer: event.data[1],\n    unique: event.data[2],\n    classHash: event.data[3],\n    calldata_len: event.data[4],\n    calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n    salt: event.data[event.data.length - 1]\n  };\n}\n\n// src/utils/outsideExecution.ts\nvar outsideExecution_exports = {};\n__export(outsideExecution_exports, {\n  buildExecuteFromOutsideCall: () => buildExecuteFromOutsideCall,\n  buildExecuteFromOutsideCallData: () => buildExecuteFromOutsideCallData,\n  getOutsideCall: () => getOutsideCall,\n  getTypedData: () => getTypedData\n});\nfunction getOutsideCall(call) {\n  const callData = call.calldata ?? [];\n  const callDataCompiled = Array.isArray(callData) ? callData : CallData.compile(callData);\n  return {\n    to: call.contractAddress,\n    selector: getSelectorFromName(call.entrypoint),\n    calldata: callDataCompiled\n  };\n}\nfunction callToTypedData(call, version) {\n  const outsideCall = getOutsideCall(call);\n  if (version === \"1\") {\n    return {\n      ...outsideCall,\n      calldata_len: outsideCall.calldata.length,\n      calldata: outsideCall.calldata\n    };\n  }\n  return {\n    To: outsideCall.to,\n    Selector: outsideCall.selector,\n    Calldata: outsideCall.calldata\n  };\n}\nfunction getDomain(chainId, version) {\n  return {\n    name: \"Account.execute_from_outside\",\n    version,\n    chainId,\n    ...version === \"2\" ? { revision: \"1\" } : {}\n  };\n}\nfunction getTypedData(chainId, options, nonce, myCalls, version) {\n  if (version === \"1\") {\n    return {\n      types: OutsideExecutionTypesV1,\n      primaryType: \"OutsideExecution\",\n      domain: getDomain(chainId, version),\n      message: {\n        ...options,\n        nonce,\n        calls_len: myCalls.length,\n        calls: myCalls.map((call) => callToTypedData(call, version))\n      }\n    };\n  }\n  return {\n    types: OutsideExecutionTypesV2,\n    primaryType: \"OutsideExecution\",\n    domain: getDomain(chainId, version),\n    message: {\n      Caller: options.caller,\n      Nonce: nonce,\n      \"Execute After\": options.execute_after,\n      \"Execute Before\": options.execute_before,\n      Calls: myCalls.map((call) => callToTypedData(call, version))\n    }\n  };\n}\nfunction buildExecuteFromOutsideCallData(outsideTransaction) {\n  const execution2 = outsideTransaction.outsideExecution;\n  const formattedSignature = formatSignature(outsideTransaction.signature);\n  return CallData.compile({\n    outside_execution: execution2,\n    signature: formattedSignature\n  });\n}\nfunction buildExecuteFromOutsideCall(outsideTransaction) {\n  const myOutsideTransactions = Array.isArray(outsideTransaction) ? outsideTransaction : [outsideTransaction];\n  const multiCall = myOutsideTransactions.map((outsideTx) => {\n    let entrypoint;\n    if (outsideTx.version === \"1\" /* V1 */) {\n      entrypoint = \"execute_from_outside\";\n    } else if (outsideTx.version === \"2\" /* V2 */) {\n      entrypoint = \"execute_from_outside_v2\";\n    } else {\n      throw new Error(\"Unsupported OutsideExecution version\");\n    }\n    return {\n      contractAddress: toHex(outsideTx.signerAddress),\n      entrypoint,\n      calldata: buildExecuteFromOutsideCallData(outsideTx)\n    };\n  });\n  return multiCall;\n}\n\n// src/utils/src5.ts\nvar src5_exports = {};\n__export(src5_exports, {\n  supportsInterface: () => supportsInterface\n});\nasync function supportsInterface(provider, contractAddress, interfaceId) {\n  const call = {\n    contractAddress: toHex(contractAddress),\n    entrypoint: \"supports_interface\",\n    calldata: [toHex(interfaceId)]\n  };\n  try {\n    const resp = await provider.callContract(call);\n    return BigInt(resp[0]) !== 0n;\n  } catch {\n    return false;\n  }\n}\n\n// src/account/default.ts\nvar Account = class extends RpcProvider2 {\n  signer;\n  address;\n  cairoVersion;\n  transactionVersion;\n  constructor(providerOrOptions, address, pkOrSigner, cairoVersion, transactionVersion = config.get(\n    \"accountTxVersion\"\n  )) {\n    super(providerOrOptions);\n    this.address = address.toLowerCase();\n    this.signer = isString(pkOrSigner) || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;\n    if (cairoVersion) {\n      this.cairoVersion = cairoVersion.toString();\n    }\n    this.transactionVersion = transactionVersion;\n  }\n  // provided version or contract based preferred transactionVersion\n  getPreferredVersion(type12, type3) {\n    if (this.transactionVersion === api_exports.ETransactionVersion.V3) return type3;\n    if (this.transactionVersion === api_exports.ETransactionVersion.V2) return type12;\n    return api_exports.ETransactionVersion.V3;\n  }\n  async getNonce(blockIdentifier) {\n    return super.getNonceForAddress(this.address, blockIdentifier);\n  }\n  async getNonceSafe(nonce) {\n    try {\n      return toBigInt(nonce ?? await this.getNonce());\n    } catch (error) {\n      return 0n;\n    }\n  }\n  /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor.\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */\n  async getCairoVersion(classHash) {\n    if (!this.cairoVersion) {\n      const { cairo } = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);\n      this.cairoVersion = cairo;\n    }\n    return this.cairoVersion;\n  }\n  async estimateFee(calls, estimateFeeDetails = {}) {\n    return this.estimateInvokeFee(calls, estimateFeeDetails);\n  }\n  async estimateInvokeFee(calls, details = {}) {\n    const {\n      nonce: providedNonce,\n      blockIdentifier,\n      version: providedVersion,\n      skipValidate = true\n    } = details;\n    const transactions = Array.isArray(calls) ? calls : [calls];\n    const nonce = toBigInt(providedNonce ?? await this.getNonce());\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n    const signerDetails = {\n      ...v3Details(details),\n      walletAddress: this.address,\n      nonce,\n      maxFee: ZERO,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion(),\n      skipValidate\n    };\n    const invocation = await this.buildInvocation(transactions, signerDetails);\n    return super.getInvokeEstimateFee(\n      { ...invocation },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n  async estimateDeclareFee(payload, details = {}) {\n    const {\n      blockIdentifier,\n      nonce: providedNonce,\n      version: providedVersion,\n      skipValidate = true\n    } = details;\n    const nonce = toBigInt(providedNonce ?? await this.getNonce());\n    const version = toTransactionVersion(\n      !isSierra(payload.contract) ? api_exports.ETransactionVersion.F1 : this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n    const declareContractTransaction = await this.buildDeclarePayload(payload, {\n      ...v3Details(details),\n      nonce,\n      chainId,\n      version,\n      walletAddress: this.address,\n      maxFee: ZERO,\n      cairoVersion: void 0,\n      // unused parameter\n      skipValidate\n    });\n    return super.getDeclareEstimateFee(\n      declareContractTransaction,\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n  async estimateAccountDeployFee({\n    classHash,\n    addressSalt = 0,\n    constructorCalldata = [],\n    contractAddress\n  }, details = {}) {\n    const { blockIdentifier, version: providedVersion, skipValidate = true } = details;\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const nonce = ZERO;\n    const chainId = await this.getChainId();\n    const payload = await this.buildAccountDeployPayload(\n      { classHash, addressSalt, constructorCalldata, contractAddress },\n      {\n        ...v3Details(details),\n        nonce,\n        chainId,\n        version,\n        walletAddress: this.address,\n        // unused parameter\n        maxFee: ZERO,\n        cairoVersion: void 0,\n        // unused parameter,\n        skipValidate\n      }\n    );\n    return super.getDeployAccountEstimateFee(\n      { ...payload },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n  async estimateDeployFee(payload, details = {}) {\n    const calls = this.buildUDCContractPayload(payload);\n    return this.estimateInvokeFee(calls, details);\n  }\n  async estimateFeeBulk(invocations, details = {}) {\n    if (!invocations.length) throw TypeError(\"Invocations should be non-empty array\");\n    const { nonce, blockIdentifier, version, skipValidate } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        api_exports.ETransactionVersion.F1,\n        // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3),\n          version\n        )\n        // sierra\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate\n    });\n    return super.getEstimateFeeBulk(accountInvocations, {\n      blockIdentifier,\n      skipValidate\n    });\n  }\n  async simulateTransaction(invocations, details = {}) {\n    if (!invocations.length) throw TypeError(\"Invocations should be non-empty array\");\n    const { nonce, blockIdentifier, skipValidate = true, skipExecute, version } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        api_exports.ETransactionVersion.V1,\n        // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3),\n          version\n        )\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate\n    });\n    return super.getSimulateTransaction(accountInvocations, {\n      blockIdentifier,\n      skipValidate,\n      skipExecute\n    });\n  }\n  async execute(transactions, arg2, transactionsDetail = {}) {\n    const details = arg2 === void 0 || Array.isArray(arg2) ? transactionsDetail : arg2;\n    const calls = Array.isArray(transactions) ? transactions : [transactions];\n    const nonce = toBigInt(details.nonce ?? await this.getNonce());\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3),\n      // TODO: does this depend on cairo version ?\n      details.version\n    );\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      { type: TransactionType.INVOKE, payload: transactions },\n      {\n        ...details,\n        version\n      }\n    );\n    const chainId = await this.getChainId();\n    const signerDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      walletAddress: this.address,\n      nonce,\n      maxFee: estimate.maxFee,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion()\n    };\n    const signature = await this.signer.signTransaction(calls, signerDetails);\n    const calldata = getExecuteCalldata(calls, await this.getCairoVersion());\n    return this.invokeFunction(\n      { contractAddress: this.address, calldata, signature },\n      {\n        ...v3Details(details),\n        resourceBounds: estimate.resourceBounds,\n        nonce,\n        maxFee: estimate.maxFee,\n        version\n      }\n    );\n  }\n  /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */\n  async declareIfNot(payload, transactionsDetail = {}) {\n    const declareContractPayload = extractContractHashes(payload);\n    try {\n      await this.getClassByHash(declareContractPayload.classHash);\n    } catch (error) {\n      return this.declare(payload, transactionsDetail);\n    }\n    return {\n      transaction_hash: \"\",\n      class_hash: declareContractPayload.classHash\n    };\n  }\n  async declare(payload, details = {}) {\n    const declareContractPayload = extractContractHashes(payload);\n    const { nonce, version: providedVersion } = details;\n    const version = toTransactionVersion(\n      !isSierra(payload.contract) ? api_exports.ETransactionVersion.V1 : this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3),\n      providedVersion\n    );\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: TransactionType.DECLARE,\n        payload: declareContractPayload\n      },\n      {\n        ...details,\n        version\n      }\n    );\n    const declareDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      nonce: toBigInt(nonce ?? await this.getNonce()),\n      version,\n      chainId: await this.getChainId(),\n      walletAddress: this.address,\n      cairoVersion: void 0\n    };\n    const declareContractTransaction = await this.buildDeclarePayload(\n      declareContractPayload,\n      declareDetails\n    );\n    return this.declareContract(declareContractTransaction, declareDetails);\n  }\n  async deploy(payload, details = {}) {\n    const { calls, addresses } = buildUDCCall(payload, this.address);\n    const invokeResponse = await this.execute(calls, void 0, details);\n    return {\n      ...invokeResponse,\n      contract_address: addresses\n    };\n  }\n  async deployContract(payload, details = {}) {\n    const deployTx = await this.deploy(payload, details);\n    const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n    return parseUDCEvent(txReceipt);\n  }\n  async declareAndDeploy(payload, details = {}) {\n    const { constructorCalldata, salt, unique } = payload;\n    let declare = await this.declareIfNot(payload, details);\n    if (declare.transaction_hash !== \"\") {\n      const tx = await this.waitForTransaction(declare.transaction_hash);\n      declare = { ...declare, ...tx };\n    }\n    const deploy = await this.deployContract(\n      { classHash: declare.class_hash, salt, unique, constructorCalldata },\n      details\n    );\n    return { declare: { ...declare }, deploy };\n  }\n  deploySelf = this.deployAccount;\n  async deployAccount({\n    classHash,\n    constructorCalldata = [],\n    addressSalt = 0,\n    contractAddress: providedContractAddress\n  }, details = {}) {\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3),\n      details.version\n    );\n    const nonce = ZERO;\n    const chainId = await this.getChainId();\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: TransactionType.DEPLOY_ACCOUNT,\n        payload: {\n          classHash,\n          constructorCalldata: compiledCalldata,\n          addressSalt,\n          contractAddress\n        }\n      },\n      details\n    );\n    const signature = await this.signer.signDeployAccountTransaction({\n      ...v3Details(details),\n      classHash,\n      constructorCalldata: compiledCalldata,\n      contractAddress,\n      addressSalt,\n      chainId,\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      version,\n      nonce\n    });\n    return this.deployAccountContract(\n      { classHash, addressSalt, constructorCalldata, signature },\n      {\n        ...v3Details(details),\n        nonce,\n        resourceBounds: estimate.resourceBounds,\n        maxFee: estimate.maxFee,\n        version\n      }\n    );\n  }\n  async signMessage(typedData) {\n    return this.signer.signMessage(typedData, this.address);\n  }\n  async hashMessage(typedData) {\n    return getMessageHash(typedData, this.address);\n  }\n  /**\n   * @deprecated To replace by `myRpcProvider.verifyMessageInStarknet()`\n   */\n  async verifyMessageHash(hash, signature, signatureVerificationFunctionName, signatureVerificationResponse) {\n    return this.verifyMessageInStarknet(\n      hash,\n      signature,\n      this.address,\n      signatureVerificationFunctionName,\n      signatureVerificationResponse\n    );\n  }\n  /**\n   * @deprecated To replace by `myRpcProvider.verifyMessageInStarknet()`\n   */\n  async verifyMessage(typedData, signature, signatureVerificationFunctionName, signatureVerificationResponse) {\n    return this.verifyMessageInStarknet(\n      typedData,\n      signature,\n      this.address,\n      signatureVerificationFunctionName,\n      signatureVerificationResponse\n    );\n  }\n  /**\n   * Verify if an account is compatible with SNIP-9 outside execution, and with which version of this standard.\n   * @returns {OutsideExecutionVersion} Not compatible, V1, V2.\n   * @example\n   * ```typescript\n   * const result = myAccount.getSnip9Version();\n   * // result = \"V1\"\n   * ```\n   */\n  async getSnip9Version() {\n    if (await supportsInterface(this, this.address, SNIP9_V2_INTERFACE_ID)) {\n      return \"2\" /* V2 */;\n    }\n    if (await supportsInterface(this, this.address, SNIP9_V1_INTERFACE_ID)) {\n      return \"1\" /* V1 */;\n    }\n    return \"0\" /* UNSUPPORTED */;\n  }\n  /**\n   * Verify if a SNIP-9 nonce has not yet been used by the account.\n   * @param {BigNumberish} nonce SNIP-9 nonce to test.\n   * @returns  {boolean} true if SNIP-9 nonce not yet used.\n   * @example\n   * ```typescript\n   * const result = myAccount.isValidSnip9Nonce(1234);\n   * // result = true\n   * ```\n   */\n  async isValidSnip9Nonce(nonce) {\n    try {\n      const call = {\n        contractAddress: this.address,\n        entrypoint: \"is_valid_outside_execution_nonce\",\n        calldata: [toHex(nonce)]\n      };\n      const resp = await this.callContract(call);\n      return BigInt(resp[0]) !== 0n;\n    } catch (error) {\n      throw new Error(`Failed to check if nonce is valid: ${error}`);\n    }\n  }\n  /**\n   * Outside transaction needs a specific SNIP-9 nonce, that we get in this function.\n   * A SNIP-9 nonce can be any number not yet used ; no ordering is needed.\n   * @returns  {string} an Hex string of a SNIP-9 nonce.\n   * @example\n   * ```typescript\n   * const result = myAccount.getSnip9Nonce();\n   * // result = \"0x28a612590dbc36927933c8ee0f357eee639c8b22b3d3aa86949eed3ada4ac55\"\n   * ```\n   */\n  async getSnip9Nonce() {\n    const nonce = randomAddress();\n    const isValidNonce = await this.isValidSnip9Nonce(nonce);\n    if (!isValidNonce) {\n      return this.getSnip9Nonce();\n    }\n    return nonce;\n  }\n  /**\n   * Creates an object containing transaction(s) that can be executed by an other account with` Account.executeFromOutside()`, called Outside Transaction.\n   * @param {OutsideExecutionOptions} options Parameters of the transaction(s).\n   * @param {AllowArray<Call>} calls Transaction(s) to execute.\n   * @param {OutsideExecutionVersion} [version] SNIP-9 version of the Account that creates the outside transaction.\n   * @param {BigNumberish} [nonce] Outside Nonce.\n   * @returns {OutsideTransaction} and object that can be used in `Account.executeFromOutside()`\n   * @example\n   * ```typescript\n   * const now_seconds = Math.floor(Date.now() / 1000);\n   * const callOptions: OutsideExecutionOptions = {\n      caller: executorAccount.address, execute_after: now_seconds - 3600, execute_before: now_seconds + 3600 };\n   * const call1: Call = { contractAddress: ethAddress, entrypoint: 'transfer', calldata: {\n   *     recipient: recipientAccount.address, amount: cairo.uint256(100) } };\n   * const outsideTransaction1: OutsideTransaction = await signerAccount.getOutsideTransaction(callOptions, call3);\n   * // result = {\n   * // outsideExecution: {\n   * // caller: '0x64b48806902a367c8598f4f95c305e8c1a1acba5f082d294a43793113115691',\n   * // nonce: '0x28a612590dbc36927933c8ee0f357eee639c8b22b3d3aa86949eed3ada4ac55',\n   * // execute_after: 1723650229, execute_before: 1723704229, calls: [[Object]] },\n   * // signature: Signature {\n   * // r: 67518627037915514985321278857825384106482999609634873287406612756843916814n,\n   * // s: 737198738569840639192844101690009498983611654458636624293579534560862067709n, recovery: 0 },\n   * // signerAddress: '0x655f8fd7c4013c07cf12a92184aa6c314d181443913e21f7e209a18f0c78492',\n   * // version: '2'\n   * // }\n   * ```\n   */\n  async getOutsideTransaction(options, calls, version, nonce) {\n    if (!isHex(options.caller) && options.caller !== \"ANY_CALLER\") {\n      throw new Error(`The caller ${options.caller} is not valid.`);\n    }\n    const codedCaller = isHex(options.caller) ? options.caller : OutsideExecutionCallerAny;\n    const myCalls = Array.isArray(calls) ? calls : [calls];\n    const supportedVersion = version ?? await this.getSnip9Version();\n    if (!supportedVersion) {\n      throw new Error(\"This account is not handling outside transactions.\");\n    }\n    const myNonce = nonce ? toHex(nonce) : await this.getSnip9Nonce();\n    const message = getTypedData(\n      await this.getChainId(),\n      {\n        caller: codedCaller,\n        execute_after: options.execute_after,\n        execute_before: options.execute_before\n      },\n      myNonce,\n      myCalls,\n      supportedVersion\n    );\n    const sign = await this.signMessage(message);\n    const toExecute = {\n      caller: codedCaller,\n      nonce: myNonce,\n      execute_after: options.execute_after,\n      execute_before: options.execute_before,\n      calls: myCalls.map(getOutsideCall)\n    };\n    return {\n      outsideExecution: toExecute,\n      signature: sign,\n      signerAddress: this.address,\n      version: supportedVersion\n    };\n  }\n  /**\n   * An account B executes a transaction that has been signed by an account A.\n   * Fees are paid by B.\n   * @param {AllowArray<OutsideTransaction>} outsideTransaction the signed transaction generated by `Account.getOutsideTransaction()`.\n   * @param {UniversalDetails} [opts] same options than `Account.execute()`.\n   * @returns {InvokeFunctionResponse} same response than `Account.execute()`.\n   * @example\n   * ```typescript\n   * const outsideTransaction1: OutsideTransaction = await signerAccount.getOutsideTransaction(callOptions, call1);\n   * const outsideTransaction2: OutsideTransaction = await signerAccount.getOutsideTransaction(callOptions4, call4);\n   * const result = await myAccount.executeFromOutside([\n      outsideTransaction1,\n      outsideTransaction2,\n    ]);\n   * // result = { transaction_hash: '0x11233...`}\n   * ```\n   */\n  async executeFromOutside(outsideTransaction, opts) {\n    const multiCall = buildExecuteFromOutsideCall(outsideTransaction);\n    return this.execute(multiCall, opts);\n  }\n  /*\n   * Support methods\n   */\n  async getUniversalSuggestedFee(version, { type, payload }, details) {\n    let maxFee = 0;\n    let resourceBounds = estimateFeeToBounds(ZERO);\n    if (version === api_exports.ETransactionVersion.V3) {\n      resourceBounds = details.resourceBounds ?? (await this.getSuggestedFee({ type, payload }, details)).resourceBounds;\n    } else {\n      maxFee = details.maxFee ?? (await this.getSuggestedFee({ type, payload }, details)).suggestedMaxFee;\n    }\n    return {\n      maxFee,\n      resourceBounds\n    };\n  }\n  async getSuggestedFee({ type, payload }, details) {\n    switch (type) {\n      case TransactionType.INVOKE:\n        return this.estimateInvokeFee(payload, details);\n      case TransactionType.DECLARE:\n        return this.estimateDeclareFee(payload, details);\n      case TransactionType.DEPLOY_ACCOUNT:\n        return this.estimateAccountDeployFee(payload, details);\n      case TransactionType.DEPLOY:\n        return this.estimateDeployFee(payload, details);\n      default:\n        return {\n          gas_consumed: 0n,\n          gas_price: 0n,\n          overall_fee: ZERO,\n          unit: \"FRI\",\n          suggestedMaxFee: ZERO,\n          resourceBounds: estimateFeeToBounds(ZERO),\n          data_gas_consumed: 0n,\n          data_gas_price: 0n\n        };\n    }\n  }\n  async buildInvocation(call, details) {\n    const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n    const signature = !details.skipValidate ? await this.signer.signTransaction(call, details) : [];\n    return {\n      ...v3Details(details),\n      contractAddress: this.address,\n      calldata,\n      signature\n    };\n  }\n  async buildDeclarePayload(payload, details) {\n    const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n    const compressedCompiledContract = parseContract(contract);\n    if (isUndefined(compiledClassHash) && (details.version === api_exports.ETransactionVersion3.F3 || details.version === api_exports.ETransactionVersion3.V3)) {\n      throw Error(\"V3 Transaction work with Cairo1 Contracts and require compiledClassHash\");\n    }\n    const signature = !details.skipValidate ? await this.signer.signDeclareTransaction({\n      ...details,\n      ...v3Details(details),\n      classHash,\n      compiledClassHash,\n      // TODO: TS, cast because optional for v2 and required for v3, thrown if not present\n      senderAddress: details.walletAddress\n    }) : [];\n    return {\n      senderAddress: details.walletAddress,\n      signature,\n      contract: compressedCompiledContract,\n      compiledClassHash\n    };\n  }\n  async buildAccountDeployPayload({\n    classHash,\n    addressSalt = 0,\n    constructorCalldata = [],\n    contractAddress: providedContractAddress\n  }, details) {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n    const signature = !details.skipValidate ? await this.signer.signDeployAccountTransaction({\n      ...details,\n      ...v3Details(details),\n      classHash,\n      contractAddress,\n      addressSalt,\n      constructorCalldata: compiledCalldata\n    }) : [];\n    return {\n      ...v3Details(details),\n      classHash,\n      addressSalt,\n      constructorCalldata: compiledCalldata,\n      signature\n    };\n  }\n  buildUDCContractPayload(payload) {\n    const calls = [].concat(payload).map((it) => {\n      const {\n        classHash,\n        salt = \"0\",\n        unique = true,\n        constructorCalldata = []\n      } = it;\n      const compiledConstructorCallData = CallData.compile(constructorCalldata);\n      return {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          salt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData\n        ]\n      };\n    });\n    return calls;\n  }\n  async accountInvocationsFactory(invocations, details) {\n    const { nonce, blockIdentifier, skipValidate = true } = details;\n    const safeNonce = await this.getNonceSafe(nonce);\n    const chainId = await this.getChainId();\n    const versions = details.versions.map((it) => toTransactionVersion(it));\n    const tx0Payload = \"payload\" in invocations[0] ? invocations[0].payload : invocations[0];\n    const cairoVersion = invocations[0].type === TransactionType.DEPLOY_ACCOUNT ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();\n    return Promise.all(\n      [].concat(invocations).map(async (transaction, index) => {\n        const txPayload = \"payload\" in transaction ? transaction.payload : transaction;\n        const signerDetails = {\n          ...v3Details(details),\n          walletAddress: this.address,\n          nonce: toBigInt(Number(safeNonce) + index),\n          maxFee: ZERO,\n          chainId,\n          cairoVersion,\n          version: \"\",\n          skipValidate\n        };\n        const common = {\n          type: transaction.type,\n          nonce: toBigInt(Number(safeNonce) + index),\n          blockIdentifier,\n          version: \"\"\n        };\n        if (transaction.type === TransactionType.INVOKE) {\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const payload = await this.buildInvocation(\n            [].concat(txPayload),\n            signerDetails\n          );\n          return {\n            ...common,\n            ...payload,\n            ...signerDetails\n          };\n        }\n        if (transaction.type === TransactionType.DEPLOY) {\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const calls = this.buildUDCContractPayload(txPayload);\n          const payload = await this.buildInvocation(calls, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            ...signerDetails,\n            type: TransactionType.INVOKE\n          };\n        }\n        if (transaction.type === TransactionType.DECLARE) {\n          const versionX = !isSierra(txPayload.contract) ? versions[0] : versions[1];\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            ...signerDetails\n          };\n        }\n        if (transaction.type === TransactionType.DEPLOY_ACCOUNT) {\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            ...signerDetails\n          };\n        }\n        throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n      })\n    );\n  }\n  async getStarkName(address = this.address, StarknetIdContract2) {\n    return super.getStarkName(address, StarknetIdContract2);\n  }\n};\n\n// src/account/interface.ts\nvar AccountInterface = class extends ProviderInterface {\n};\n\n// src/wallet/connect.ts\nvar connect_exports = {};\n__export(connect_exports, {\n  addDeclareTransaction: () => addDeclareTransaction,\n  addInvokeTransaction: () => addInvokeTransaction,\n  addStarknetChain: () => addStarknetChain,\n  deploymentData: () => deploymentData,\n  getPermissions: () => getPermissions,\n  onAccountChange: () => onAccountChange,\n  onNetworkChanged: () => onNetworkChanged,\n  requestAccounts: () => requestAccounts,\n  requestChainId: () => requestChainId,\n  signMessage: () => signMessage,\n  supportedSpecs: () => supportedSpecs,\n  switchStarknetChain: () => switchStarknetChain,\n  watchAsset: () => watchAsset\n});\nfunction requestAccounts(swo, silent_mode = false) {\n  return swo.request({\n    type: \"wallet_requestAccounts\",\n    params: { silent_mode }\n  });\n}\nfunction getPermissions(swo) {\n  return swo.request({ type: \"wallet_getPermissions\" });\n}\nfunction watchAsset(swo, asset) {\n  return swo.request({ type: \"wallet_watchAsset\", params: asset });\n}\nfunction addStarknetChain(swo, chain) {\n  return swo.request({ type: \"wallet_addStarknetChain\", params: chain });\n}\nfunction switchStarknetChain(swo, chainId) {\n  return swo.request({\n    type: \"wallet_switchStarknetChain\",\n    params: { chainId }\n  });\n}\nfunction requestChainId(swo) {\n  return swo.request({ type: \"wallet_requestChainId\" });\n}\nfunction deploymentData(swo) {\n  return swo.request({ type: \"wallet_deploymentData\" });\n}\nfunction addInvokeTransaction(swo, params) {\n  return swo.request({ type: \"wallet_addInvokeTransaction\", params });\n}\nfunction addDeclareTransaction(swo, params) {\n  return swo.request({ type: \"wallet_addDeclareTransaction\", params });\n}\nfunction signMessage(swo, typedData) {\n  return swo.request({ type: \"wallet_signTypedData\", params: typedData });\n}\nfunction supportedSpecs(swo) {\n  return swo.request({ type: \"wallet_supportedSpecs\" });\n}\nfunction onAccountChange(swo, callback) {\n  swo.on(\"accountsChanged\", callback);\n}\nfunction onNetworkChanged(swo, callback) {\n  swo.on(\"networkChanged\", callback);\n}\n\n// src/wallet/account.ts\nvar WalletAccount = class _WalletAccount extends Account {\n  walletProvider;\n  constructor(providerOrOptions, walletProvider, cairoVersion, address = \"\") {\n    super(providerOrOptions, address, \"\", cairoVersion);\n    this.walletProvider = walletProvider;\n    this.walletProvider.on(\"accountsChanged\", (res) => {\n      if (!res) return;\n      this.address = res[0].toLowerCase();\n    });\n    this.walletProvider.on(\"networkChanged\", (res) => {\n      if (!res) return;\n      this.channel.setChainId(res);\n    });\n    if (!address.length) {\n      logger.warn(\n        \"@deprecated Use static method WalletAccount.connect or WalletAccount.connectSilent instead. Constructor {@link WalletAccount.(format:2)}.\"\n      );\n      requestAccounts(this.walletProvider).then(([accountAddress]) => {\n        this.address = accountAddress.toLowerCase();\n      });\n    }\n  }\n  /**\n   * WALLET EVENTS\n   */\n  onAccountChange(callback) {\n    onAccountChange(this.walletProvider, callback);\n  }\n  onNetworkChanged(callback) {\n    onNetworkChanged(this.walletProvider, callback);\n  }\n  /**\n   * WALLET SPECIFIC METHODS\n   */\n  requestAccounts(silentMode = false) {\n    return requestAccounts(this.walletProvider, silentMode);\n  }\n  getPermissions() {\n    return getPermissions(this.walletProvider);\n  }\n  switchStarknetChain(chainId) {\n    return switchStarknetChain(this.walletProvider, chainId);\n  }\n  watchAsset(asset) {\n    return watchAsset(this.walletProvider, asset);\n  }\n  addStarknetChain(chain) {\n    return addStarknetChain(this.walletProvider, chain);\n  }\n  /**\n   * ACCOUNT METHODS\n   */\n  execute(calls) {\n    const txCalls = [].concat(calls).map((it) => {\n      const { contractAddress, entrypoint, calldata } = it;\n      return {\n        contract_address: contractAddress,\n        entry_point: entrypoint,\n        calldata\n      };\n    });\n    const params = {\n      calls: txCalls\n    };\n    return addInvokeTransaction(this.walletProvider, params);\n  }\n  declare(payload) {\n    const declareContractPayload = extractContractHashes(payload);\n    const pContract = payload.contract;\n    const cairo1Contract = {\n      ...pContract,\n      abi: stringify2(pContract.abi)\n    };\n    if (!declareContractPayload.compiledClassHash) {\n      throw Error(\"compiledClassHash is required\");\n    }\n    const params = {\n      compiled_class_hash: declareContractPayload.compiledClassHash,\n      contract_class: cairo1Contract\n    };\n    return addDeclareTransaction(this.walletProvider, params);\n  }\n  async deploy(payload) {\n    const { calls, addresses } = buildUDCCall(payload, this.address);\n    const invokeResponse = await this.execute(calls);\n    return {\n      ...invokeResponse,\n      contract_address: addresses\n    };\n  }\n  signMessage(typedData) {\n    return signMessage(this.walletProvider, typedData);\n  }\n  static async connect(provider, walletProvider, cairoVersion, silentMode = false) {\n    const [accountAddress] = await requestAccounts(walletProvider, silentMode);\n    return new _WalletAccount(provider, walletProvider, cairoVersion, accountAddress);\n  }\n  static async connectSilent(provider, walletProvider, cairoVersion) {\n    return _WalletAccount.connect(provider, walletProvider, cairoVersion, true);\n  }\n  // TODO: MISSING ESTIMATES\n};\n\n// src/contract/default.ts\nvar splitArgsAndOptions = (args) => {\n  const options = [\n    \"blockIdentifier\",\n    \"parseRequest\",\n    \"parseResponse\",\n    \"formatResponse\",\n    \"maxFee\",\n    \"nonce\",\n    \"signature\",\n    \"addressSalt\"\n  ];\n  const lastArg = args[args.length - 1];\n  if (typeof lastArg === \"object\" && options.some((x) => x in lastArg)) {\n    return { args, options: args.pop() };\n  }\n  return { args };\n};\nfunction buildCall(contract, functionAbi) {\n  return async function(...args) {\n    const params = splitArgsAndOptions(args);\n    return contract.call(functionAbi.name, params.args, {\n      parseRequest: true,\n      parseResponse: true,\n      ...params.options\n    });\n  };\n}\nfunction buildInvoke(contract, functionAbi) {\n  return async function(...args) {\n    const params = splitArgsAndOptions(args);\n    return contract.invoke(functionAbi.name, params.args, {\n      parseRequest: true,\n      ...params.options\n    });\n  };\n}\nfunction buildDefault(contract, functionAbi) {\n  if (functionAbi.stateMutability === \"view\" || functionAbi.state_mutability === \"view\") {\n    return buildCall(contract, functionAbi);\n  }\n  return buildInvoke(contract, functionAbi);\n}\nfunction buildPopulate(contract, functionAbi) {\n  return function(...args) {\n    return contract.populate(functionAbi.name, args);\n  };\n}\nfunction buildEstimate(contract, functionAbi) {\n  return function(...args) {\n    return contract.estimate(functionAbi.name, args);\n  };\n}\nfunction getCalldata(args, callback) {\n  if (Array.isArray(args) && \"__compiled__\" in args) return args;\n  if (Array.isArray(args) && Array.isArray(args[0]) && \"__compiled__\" in args[0])\n    return args[0];\n  return callback();\n}\nvar Contract = class {\n  abi;\n  address;\n  providerOrAccount;\n  deployTransactionHash;\n  structs;\n  events;\n  functions;\n  callStatic;\n  populateTransaction;\n  estimateFee;\n  callData;\n  /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */\n  constructor(abi, address, providerOrAccount = defaultProvider) {\n    this.address = address && address.toLowerCase();\n    this.providerOrAccount = providerOrAccount;\n    this.callData = new CallData(abi);\n    this.structs = CallData.getAbiStruct(abi);\n    this.events = getAbiEvents(abi);\n    const parser = createAbiParser(abi);\n    this.abi = parser.getLegacyFormat();\n    const options = { enumerable: true, value: {}, writable: false };\n    Object.defineProperties(this, {\n      functions: { enumerable: true, value: {}, writable: false },\n      callStatic: { enumerable: true, value: {}, writable: false },\n      populateTransaction: { enumerable: true, value: {}, writable: false },\n      estimateFee: { enumerable: true, value: {}, writable: false }\n    });\n    this.abi.forEach((abiElement) => {\n      if (abiElement.type !== \"function\") return;\n      const signature = abiElement.name;\n      if (!this[signature]) {\n        Object.defineProperty(this, signature, {\n          ...options,\n          value: buildDefault(this, abiElement)\n        });\n      }\n      if (!this.functions[signature]) {\n        Object.defineProperty(this.functions, signature, {\n          ...options,\n          value: buildDefault(this, abiElement)\n        });\n      }\n      if (!this.callStatic[signature]) {\n        Object.defineProperty(this.callStatic, signature, {\n          ...options,\n          value: buildCall(this, abiElement)\n        });\n      }\n      if (!this.populateTransaction[signature]) {\n        Object.defineProperty(this.populateTransaction, signature, {\n          ...options,\n          value: buildPopulate(this, abiElement)\n        });\n      }\n      if (!this.estimateFee[signature]) {\n        Object.defineProperty(this.estimateFee, signature, {\n          ...options,\n          value: buildEstimate(this, abiElement)\n        });\n      }\n    });\n  }\n  attach(address) {\n    this.address = address;\n  }\n  connect(providerOrAccount) {\n    this.providerOrAccount = providerOrAccount;\n  }\n  async deployed() {\n    if (this.deployTransactionHash) {\n      await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n      this.deployTransactionHash = void 0;\n    }\n    return this;\n  }\n  async call(method, args = [], {\n    parseRequest = true,\n    parseResponse = true,\n    formatResponse = void 0,\n    blockIdentifier = void 0\n  } = {}) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(ValidateType.CALL, method, args);\n        return this.callData.compile(method, args);\n      }\n      logger.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n      return args;\n    });\n    return this.providerOrAccount.callContract(\n      {\n        contractAddress: this.address,\n        calldata,\n        entrypoint: method\n      },\n      blockIdentifier\n    ).then((it) => {\n      if (!parseResponse) {\n        return it;\n      }\n      if (formatResponse) {\n        return this.callData.format(method, it, formatResponse);\n      }\n      return this.callData.parse(method, it);\n    });\n  }\n  invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(ValidateType.INVOKE, method, args);\n        return this.callData.compile(method, args);\n      }\n      logger.warn(\"Invoke skipped parsing but provided rawArgs, possible malfunction request\");\n      return args;\n    });\n    const invocation = {\n      contractAddress: this.address,\n      calldata,\n      entrypoint: method\n    };\n    if (\"execute\" in this.providerOrAccount) {\n      return this.providerOrAccount.execute(invocation, void 0, {\n        maxFee,\n        nonce\n      });\n    }\n    if (!nonce) throw new Error(`Nonce is required when invoking a function without an account`);\n    logger.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n    return this.providerOrAccount.invokeFunction(\n      {\n        ...invocation,\n        signature\n      },\n      {\n        nonce\n      }\n    );\n  }\n  async estimate(method, args = []) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    if (!getCalldata(args, () => false)) {\n      this.callData.validate(ValidateType.INVOKE, method, args);\n    }\n    const invocation = this.populate(method, args);\n    if (\"estimateInvokeFee\" in this.providerOrAccount) {\n      return this.providerOrAccount.estimateInvokeFee(invocation);\n    }\n    throw Error(\"Contract must be connected to the account contract to estimate\");\n  }\n  populate(method, args = []) {\n    const calldata = getCalldata(args, () => this.callData.compile(method, args));\n    return {\n      contractAddress: this.address,\n      entrypoint: method,\n      calldata\n    };\n  }\n  parseEvents(receipt) {\n    let parsed;\n    receipt.match({\n      success: (txR) => {\n        const emittedEvents = txR.events?.map((event) => {\n          return {\n            block_hash: txR.block_hash,\n            block_number: txR.block_number,\n            transaction_hash: txR.transaction_hash,\n            ...event\n          };\n        }).filter((event) => cleanHex(event.from_address) === cleanHex(this.address), []) || [];\n        parsed = parseEvents(\n          emittedEvents,\n          this.events,\n          this.structs,\n          CallData.getAbiEnum(this.abi)\n        );\n      },\n      _: () => {\n        throw Error(\"This transaction was not successful.\");\n      }\n    });\n    return parsed;\n  }\n  isCairo1() {\n    return cairo_exports.isCairo1Abi(this.abi);\n  }\n  async getVersion() {\n    return this.providerOrAccount.getContractVersion(this.address);\n  }\n  typedv2(tAbi) {\n    return this;\n  }\n};\n\n// src/contract/interface.ts\nvar ContractInterface = class {\n  functions;\n  callStatic;\n  populateTransaction;\n  estimateFee;\n};\n\n// src/contract/contractFactory.ts\nvar ContractFactory = class {\n  compiledContract;\n  account;\n  abi;\n  classHash;\n  casm;\n  compiledClassHash;\n  CallData;\n  /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */\n  constructor(params) {\n    this.compiledContract = params.compiledContract;\n    this.account = params.account;\n    this.casm = params.casm;\n    this.abi = params.abi ?? params.compiledContract.abi;\n    this.classHash = params.classHash;\n    this.compiledClassHash = params.compiledClassHash;\n    this.CallData = new CallData(this.abi);\n  }\n  /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */\n  async deploy(...args) {\n    const { args: param, options = { parseRequest: true } } = splitArgsAndOptions(args);\n    const constructorCalldata = getCalldata(param, () => {\n      if (options.parseRequest) {\n        this.CallData.validate(ValidateType.DEPLOY, \"constructor\", param);\n        return this.CallData.compile(\"constructor\", param);\n      }\n      logger.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n      return param;\n    });\n    const {\n      deploy: { contract_address, transaction_hash }\n    } = await this.account.declareAndDeploy({\n      contract: this.compiledContract,\n      casm: this.casm,\n      classHash: this.classHash,\n      compiledClassHash: this.compiledClassHash,\n      constructorCalldata,\n      salt: options.addressSalt\n    });\n    assert(Boolean(contract_address), \"Deployment of the contract failed\");\n    const contractInstance = new Contract(\n      this.compiledContract.abi,\n      contract_address,\n      this.account\n    );\n    contractInstance.deployTransactionHash = transaction_hash;\n    return contractInstance;\n  }\n  /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */\n  connect(account) {\n    this.account = account;\n    return this;\n  }\n  /**\n   * Attaches current abi and account to the new address\n   */\n  attach(address) {\n    return new Contract(this.abi, address, this.account);\n  }\n  // ethers.js' getDeployTransaction can't be supported as it requires the account or signer to return a signed transaction which is not possible with the current implementation\n};\n\n// src/utils/responseParser/interface.ts\nvar ResponseParser = class {\n};\n\n// src/utils/units.ts\nfunction units(amount, simbol = \"fri\") {\n  if (simbol === \"strk\") {\n    let numStr = \"\";\n    if (typeof amount === \"bigint\") numStr = amount.toString();\n    else if (typeof amount === \"string\") {\n      if (isHex(amount)) {\n        numStr = BigInt(amount).toString();\n      } else {\n        numStr = amount;\n      }\n    }\n    const [integer, decimal = \"0\"] = numStr.split(\".\");\n    const pdec = decimal.padEnd(18, \"0\");\n    return `${integer}${pdec}`.replace(/\\b0+/g, \"\");\n  }\n  const bis = BigInt(amount).toString();\n  let strk;\n  if (bis.length <= 18) {\n    strk = `0.${bis.padStart(18, \"0\")}`;\n  } else {\n    strk = `${bis.slice(0, bis.length - 18)}.${bis.slice(bis.length - 18)}`;\n  }\n  return strk.replace(/(\\.[0-9]*[1-9])0+$|\\.0*$/, \"$1\");\n}\n\n// src/index.ts\nvar number = num_exports;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xMy9ub2RlX21vZHVsZXMvc3RhcmtuZXQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBUztBQUM1QixDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJLEdBQUcsVUFBVSwyQkFBMkIsSUFBSSxHQUFHLFdBQVcseUJBQXlCLGlCQUFpQjtBQUNsSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLFFBQVE7QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxtREFBbUQsSUFBSSxHQUFHLFdBQVcsV0FBVyxJQUFJLEdBQUcsVUFBVTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcseUNBQXlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9CQUFvQixXQUFXLCtDQUErQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9CQUFvQixXQUFXLDhDQUE4QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXLGVBQWUsK0NBQStDLFNBQVMsZ0JBQWdCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLGtDQUFrQyxNQUFNLHVDQUF1QztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFDLHdCQUF3QjtBQUMvRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsaUVBQWlFLGVBQWU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUyxvQ0FBb0MsV0FBVyxTQUFTLGNBQWM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVMscUNBQXFDLFdBQVcsY0FBYywyQkFBMkI7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUsscUNBQXFDLHlDQUF5QyxTQUFTLGVBQWU7QUFDL0g7QUFDQSxNQUFNO0FBQ04sa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVMsa0NBQWtDLEtBQUs7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkIsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU0sbUNBQW1DLE1BQU07QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNLGtDQUFrQyxNQUFNO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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b0I7O0FBRWxFO0FBQ0E7QUFDQSxpREFBaUQscURBQW1CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDa0Q7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlFQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlFQUFnQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxpRUFBZ0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQTBEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBDQUEwQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxhQUFhLG9DQUFvQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFB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QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0VBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFLEdBQUcsRUFBRTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0IsSUFBSSxnQ0FBZ0M7QUFDMUY7QUFDQSxRQUFRLG9EQUFvRCxJQUFJLGtDQUFrQztBQUNsRztBQUNBO0FBQ0EsUUFBUSx5REFBeUQsSUFBSSxvQ0FBb0M7QUFDekc7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnRUFBaUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEVBQUU7QUFDbkM7QUFDQSxHQUFHO0FBQ0gsR0FBRyxnRUFBaUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBLDBDQUEwQyxPQUFPLEdBQUcsS0FBSyxzQkFBc0IsSUFBSSxJQUFJLElBQUk7QUFDM0Y7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQyw0QkFBNEIsZ0VBQWlCLGdEQUFnRCxnRUFBaUI7QUFDOUcsV0FBVyxnRUFBaUI7QUFDNUIsNEJBQTRCLGdFQUFpQixnREFBZ0QsZ0VBQWlCLGFBQWEsZ0VBQWlCO0FBQzVJLFdBQVcsZ0VBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixnRUFBaUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzQkFBc0IsZ0VBQWlCO0FBQzNDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQSx5RkFBeUYsUUFBUTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdFQUFpQjtBQUM3RCxnQ0FBZ0MsZ0VBQWlCLFlBQVksMkRBQTJEO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0VBQWlCO0FBQzVFLDREQUE0RCx3RUFBd0U7QUFDcEksZ0JBQWdCLFlBQVksR0FBRyxXQUFXO0FBQzFDLEtBQUs7QUFDTCxjQUFjLGdCQUFnQixHQUFHLG1CQUFtQjtBQUNwRCxHQUFHO0FBQ0g7QUFDQSw2Q0FBNkMsZ0VBQWlCO0FBQzlEO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYSxnRUFBaUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnRUFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnRUFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWlCO0FBQ3hDLHFEQUFxRCxNQUFNLEVBQUUsS0FBSztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnRUFBaUI7QUFDeEMsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnRUFBaUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsV0FBVztBQUM1RTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0VBQWlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0RBQW9CO0FBQ2xFO0FBQ0Esa0JBQWtCLG1EQUFpQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBMEQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkMsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsY0FBYztBQUMzQixhQUFhLFFBQVE7QUFDckIsY0FBYyxzQkFBc0IsdUJBQXVCLGtCQUFrQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3QixLQUFLLGFBQWEsS0FBSyx5QkFBeUIsS0FBSztBQUM3RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsS0FBSztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEUsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNB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QUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZTtBQUM5RixNQUFNO0FBQ04sK0RBQStELGVBQWU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5Q0FBeUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsWUFBWTtBQUM1RixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQSx1QkFBdUIsMENBQTBDO0FBQ2pFO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQWdEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0EsdUJBQXVCLDZDQUE2QztBQUNwRTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUE4QztBQUNyRTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFpRDtBQUN4RTtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrSEFBa0gsK0JBQStCO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0NBQXdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNq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bmQvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xMy9ub2RlX21vZHVsZXMvc3RhcmtuZXQvZGlzdC9pbmRleC5tanM/MjNjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kLCBzZWNvbmRUYXJnZXQpID0+IChfX2NvcHlQcm9wcyh0YXJnZXQsIG1vZCwgXCJkZWZhdWx0XCIpLCBzZWNvbmRUYXJnZXQgJiYgX19jb3B5UHJvcHMoc2Vjb25kVGFyZ2V0LCBtb2QsIFwiZGVmYXVsdFwiKSk7XG5cbi8vIHNyYy9nbG9iYWwvY29uc3RhbnRzLnRzXG52YXIgY29uc3RhbnRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbnN0YW50c19leHBvcnRzLCB7XG4gIEFERFJfQk9VTkQ6ICgpID0+IEFERFJfQk9VTkQsXG4gIEFQSV9WRVJTSU9OOiAoKSA9PiBBUElfVkVSU0lPTixcbiAgQmFzZVVybDogKCkgPT4gQmFzZVVybCxcbiAgREVGQVVMVF9HTE9CQUxfQ09ORklHOiAoKSA9PiBERUZBVUxUX0dMT0JBTF9DT05GSUcsXG4gIEZlZU1hcmdpblBlcmNlbnRhZ2U6ICgpID0+IEZlZU1hcmdpblBlcmNlbnRhZ2UsXG4gIEhBUkRFTklOR180QllURVM6ICgpID0+IEhBUkRFTklOR180QllURVMsXG4gIEhBUkRFTklOR19CWVRFOiAoKSA9PiBIQVJERU5JTkdfQllURSxcbiAgSVNfQlJPV1NFUjogKCkgPT4gSVNfQlJPV1NFUixcbiAgTUFTS18yNTA6ICgpID0+IE1BU0tfMjUwLFxuICBNQVNLXzMxOiAoKSA9PiBNQVNLXzMxLFxuICBNQVhfU1RPUkFHRV9JVEVNX1NJWkU6ICgpID0+IE1BWF9TVE9SQUdFX0lURU1fU0laRSxcbiAgTmV0d29ya05hbWU6ICgpID0+IE5ldHdvcmtOYW1lLFxuICBPdXRzaWRlRXhlY3V0aW9uQ2FsbGVyQW55OiAoKSA9PiBPdXRzaWRlRXhlY3V0aW9uQ2FsbGVyQW55LFxuICBQUklNRTogKCkgPT4gUFJJTUUsXG4gIFJBTkdFX0ZFTFQ6ICgpID0+IFJBTkdFX0ZFTFQsXG4gIFJBTkdFX0kxMjg6ICgpID0+IFJBTkdFX0kxMjgsXG4gIFJBTkdFX1UxMjg6ICgpID0+IFJBTkdFX1UxMjgsXG4gIFJQQ19ERUZBVUxUX1ZFUlNJT046ICgpID0+IFJQQ19ERUZBVUxUX1ZFUlNJT04sXG4gIFJQQ19OT0RFUzogKCkgPT4gUlBDX05PREVTLFxuICBTTklQOV9WMV9JTlRFUkZBQ0VfSUQ6ICgpID0+IFNOSVA5X1YxX0lOVEVSRkFDRV9JRCxcbiAgU05JUDlfVjJfSU5URVJGQUNFX0lEOiAoKSA9PiBTTklQOV9WMl9JTlRFUkZBQ0VfSUQsXG4gIFNZU1RFTV9NRVNTQUdFUzogKCkgPT4gU1lTVEVNX01FU1NBR0VTLFxuICBTdGFya25ldENoYWluSWQ6ICgpID0+IFN0YXJrbmV0Q2hhaW5JZCxcbiAgVEVYVF9UT19GRUxUX01BWF9MRU46ICgpID0+IFRFWFRfVE9fRkVMVF9NQVhfTEVOLFxuICBUUkFOU0FDVElPTl9WRVJTSU9OOiAoKSA9PiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLFxuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXg6ICgpID0+IFRyYW5zYWN0aW9uSGFzaFByZWZpeCxcbiAgVURDOiAoKSA9PiBVREMsXG4gIFpFUk86ICgpID0+IFpFUk9cbn0pO1xuXG4vLyBzcmMvdHlwZXMvYXBpL2luZGV4LnRzXG52YXIgYXBpX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGFwaV9leHBvcnRzLCB7XG4gIEpSUEM6ICgpID0+IGpzb25ycGNfZXhwb3J0cyxcbiAgUlBDU1BFQzA2OiAoKSA9PiBycGNzcGVjXzBfNl9leHBvcnRzLFxuICBSUENTUEVDMDc6ICgpID0+IFJQQ1NQRUMwN1xufSk7XG5cbi8vIHNyYy90eXBlcy9hcGkvanNvbnJwYy9pbmRleC50c1xudmFyIGpzb25ycGNfZXhwb3J0cyA9IHt9O1xuXG4vLyBzcmMvdHlwZXMvYXBpL3JwY3NwZWNfMF82L2luZGV4LnRzXG52YXIgcnBjc3BlY18wXzZfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocnBjc3BlY18wXzZfZXhwb3J0cywge1xuICBFQmxvY2tUYWc6ICgpID0+IEVCbG9ja1RhZyxcbiAgRURBTW9kZTogKCkgPT4gRURBTW9kZSxcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlOiAoKSA9PiBFRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gIEVTaW11bGF0aW9uRmxhZzogKCkgPT4gRVNpbXVsYXRpb25GbGFnLFxuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzLFxuICBFVHJhbnNhY3Rpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uVHlwZTogKCkgPT4gRVRyYW5zYWN0aW9uVHlwZSxcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjogKCkgPT4gRVRyYW5zYWN0aW9uVmVyc2lvbixcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjI6ICgpID0+IEVUcmFuc2FjdGlvblZlcnNpb24yLFxuICBFVHJhbnNhY3Rpb25WZXJzaW9uMzogKCkgPT4gRVRyYW5zYWN0aW9uVmVyc2lvbjMsXG4gIEVycm9yczogKCkgPT4gZXJyb3JzX2V4cG9ydHMsXG4gIFNQRUM6ICgpID0+IGNvbXBvbmVudHNfZXhwb3J0c1xufSk7XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlY18wXzYvZXJyb3JzLnRzXG52YXIgZXJyb3JzX2V4cG9ydHMgPSB7fTtcblxuLy8gc3JjL3R5cGVzL2FwaS9ycGNzcGVjXzBfNi9jb21wb25lbnRzLnRzXG52YXIgY29tcG9uZW50c19leHBvcnRzID0ge307XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlY18wXzYvbm9uc3BlYy50c1xudmFyIEVUcmFuc2FjdGlvblR5cGUgPSB7XG4gIERFQ0xBUkU6IFwiREVDTEFSRVwiLFxuICBERVBMT1k6IFwiREVQTE9ZXCIsXG4gIERFUExPWV9BQ0NPVU5UOiBcIkRFUExPWV9BQ0NPVU5UXCIsXG4gIElOVk9LRTogXCJJTlZPS0VcIixcbiAgTDFfSEFORExFUjogXCJMMV9IQU5ETEVSXCJcbn07XG52YXIgRVNpbXVsYXRpb25GbGFnID0ge1xuICBTS0lQX1ZBTElEQVRFOiBcIlNLSVBfVkFMSURBVEVcIixcbiAgU0tJUF9GRUVfQ0hBUkdFOiBcIlNLSVBfRkVFX0NIQVJHRVwiXG59O1xudmFyIEVUcmFuc2FjdGlvblN0YXR1cyA9IHtcbiAgUkVDRUlWRUQ6IFwiUkVDRUlWRURcIixcbiAgUkVKRUNURUQ6IFwiUkVKRUNURURcIixcbiAgQUNDRVBURURfT05fTDI6IFwiQUNDRVBURURfT05fTDJcIixcbiAgQUNDRVBURURfT05fTDE6IFwiQUNDRVBURURfT05fTDFcIlxufTtcbnZhciBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyA9IHtcbiAgQUNDRVBURURfT05fTDI6IFwiQUNDRVBURURfT05fTDJcIixcbiAgQUNDRVBURURfT05fTDE6IFwiQUNDRVBURURfT05fTDFcIlxufTtcbnZhciBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMgPSB7XG4gIFNVQ0NFRURFRDogXCJTVUNDRUVERURcIixcbiAgUkVWRVJURUQ6IFwiUkVWRVJURURcIlxufTtcbnZhciBFQmxvY2tUYWcgPSB7XG4gIFBFTkRJTkc6IFwicGVuZGluZ1wiLFxuICBMQVRFU1Q6IFwibGF0ZXN0XCJcbn07XG52YXIgRURhdGFBdmFpbGFiaWxpdHlNb2RlID0ge1xuICBMMTogXCJMMVwiLFxuICBMMjogXCJMMlwiXG59O1xudmFyIEVEQU1vZGUgPSB7XG4gIEwxOiAwLFxuICBMMjogMVxufTtcbnZhciBFVHJhbnNhY3Rpb25WZXJzaW9uID0ge1xuICBWMDogXCIweDBcIixcbiAgVjE6IFwiMHgxXCIsXG4gIFYyOiBcIjB4MlwiLFxuICBWMzogXCIweDNcIixcbiAgRjA6IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgRjE6IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFcIixcbiAgRjI6IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJcIixcbiAgRjM6IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNcIlxufTtcbnZhciBFVHJhbnNhY3Rpb25WZXJzaW9uMiA9IHtcbiAgVjA6IFwiMHgwXCIsXG4gIFYxOiBcIjB4MVwiLFxuICBWMjogXCIweDJcIixcbiAgRjA6IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgRjE6IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFcIixcbiAgRjI6IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJcIlxufTtcbnZhciBFVHJhbnNhY3Rpb25WZXJzaW9uMyA9IHtcbiAgVjM6IFwiMHgzXCIsXG4gIEYzOiBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzXCJcbn07XG5cbi8vIHNyYy90eXBlcy9hcGkvaW5kZXgudHNcbl9fcmVFeHBvcnQoYXBpX2V4cG9ydHMsIHN0YXJrbmV0X3R5cGVzXzA3X3N0YXIpO1xuaW1wb3J0ICogYXMgUlBDU1BFQzA3IGZyb20gXCJzdGFya25ldC10eXBlcy0wN1wiO1xuaW1wb3J0ICogYXMgc3RhcmtuZXRfdHlwZXNfMDdfc3RhciBmcm9tIFwic3RhcmtuZXQtdHlwZXMtMDdcIjtcblxuLy8gc3JjL3V0aWxzL2VuY29kZS50c1xudmFyIGVuY29kZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChlbmNvZGVfZXhwb3J0cywge1xuICBJU19CUk9XU0VSOiAoKSA9PiBJU19CUk9XU0VSLFxuICBhZGRIZXhQcmVmaXg6ICgpID0+IGFkZEhleFByZWZpeCxcbiAgYXJyYXlCdWZmZXJUb1N0cmluZzogKCkgPT4gYXJyYXlCdWZmZXJUb1N0cmluZyxcbiAgYXRvYlVuaXZlcnNhbDogKCkgPT4gYXRvYlVuaXZlcnNhbCxcbiAgYnRvYVVuaXZlcnNhbDogKCkgPT4gYnRvYVVuaXZlcnNhbCxcbiAgYnVmMmhleDogKCkgPT4gYnVmMmhleCxcbiAgY2FsY0J5dGVMZW5ndGg6ICgpID0+IGNhbGNCeXRlTGVuZ3RoLFxuICBjb25jYXRlbmF0ZUFycmF5QnVmZmVyOiAoKSA9PiBjb25jYXRlbmF0ZUFycmF5QnVmZmVyLFxuICBwYWRMZWZ0OiAoKSA9PiBwYWRMZWZ0LFxuICBwYXNjYWxUb1NuYWtlOiAoKSA9PiBwYXNjYWxUb1NuYWtlLFxuICByZW1vdmVIZXhQcmVmaXg6ICgpID0+IHJlbW92ZUhleFByZWZpeCxcbiAgc2FuaXRpemVCeXRlczogKCkgPT4gc2FuaXRpemVCeXRlcyxcbiAgc2FuaXRpemVIZXg6ICgpID0+IHNhbml0aXplSGV4LFxuICBzdHJpbmdUb0FycmF5QnVmZmVyOiAoKSA9PiBzdHJpbmdUb0FycmF5QnVmZmVyLFxuICB1dGY4VG9BcnJheTogKCkgPT4gdXRmOFRvQXJyYXlcbn0pO1xuaW1wb3J0IHsgYmFzZTY0IH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG52YXIgSVNfQlJPV1NFUiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgU1RSSU5HX1pFUk8gPSBcIjBcIjtcbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9TdHJpbmcoYXJyYXkpIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFycmF5KS5yZWR1Y2UoKGRhdGEsIGJ5dGUpID0+IGRhdGEgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHV0ZjhUb0FycmF5KHN0cikge1xuICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5QnVmZmVyKHN0cikge1xuICByZXR1cm4gdXRmOFRvQXJyYXkoc3RyKTtcbn1cbmZ1bmN0aW9uIGF0b2JVbml2ZXJzYWwoYSkge1xuICByZXR1cm4gYmFzZTY0LmRlY29kZShhKTtcbn1cbmZ1bmN0aW9uIGJ0b2FVbml2ZXJzYWwoYikge1xuICByZXR1cm4gYmFzZTY0LmVuY29kZShuZXcgVWludDhBcnJheShiKSk7XG59XG5mdW5jdGlvbiBidWYyaGV4KGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnJlZHVjZSgociwgeCkgPT4gciArIHgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgXCJcIik7XG59XG5mdW5jdGlvbiByZW1vdmVIZXhQcmVmaXgoaGV4KSB7XG4gIHJldHVybiBoZXgucmVwbGFjZSgvXjB4L2ksIFwiXCIpO1xufVxuZnVuY3Rpb24gYWRkSGV4UHJlZml4KGhleCkge1xuICByZXR1cm4gYDB4JHtyZW1vdmVIZXhQcmVmaXgoaGV4KX1gO1xufVxuZnVuY3Rpb24gcGFkU3RyaW5nKHN0ciwgbGVuZ3RoLCBsZWZ0LCBwYWRkaW5nID0gU1RSSU5HX1pFUk8pIHtcbiAgY29uc3QgZGlmZiA9IGxlbmd0aCAtIHN0ci5sZW5ndGg7XG4gIGxldCByZXN1bHQgPSBzdHI7XG4gIGlmIChkaWZmID4gMCkge1xuICAgIGNvbnN0IHBhZCA9IHBhZGRpbmcucmVwZWF0KGRpZmYpO1xuICAgIHJlc3VsdCA9IGxlZnQgPyBwYWQgKyBzdHIgOiBzdHIgKyBwYWQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhZExlZnQoc3RyLCBsZW5ndGgsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICByZXR1cm4gcGFkU3RyaW5nKHN0ciwgbGVuZ3RoLCB0cnVlLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIGNhbGNCeXRlTGVuZ3RoKHN0ciwgYnl0ZVNpemUgPSA4KSB7XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBzdHI7XG4gIGNvbnN0IHJlbWFpbmRlciA9IGxlbmd0aCAlIGJ5dGVTaXplO1xuICByZXR1cm4gcmVtYWluZGVyID8gKGxlbmd0aCAtIHJlbWFpbmRlcikgLyBieXRlU2l6ZSAqIGJ5dGVTaXplICsgYnl0ZVNpemUgOiBsZW5ndGg7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUJ5dGVzKHN0ciwgYnl0ZVNpemUgPSA4LCBwYWRkaW5nID0gU1RSSU5HX1pFUk8pIHtcbiAgcmV0dXJuIHBhZExlZnQoc3RyLCBjYWxjQnl0ZUxlbmd0aChzdHIsIGJ5dGVTaXplKSwgcGFkZGluZyk7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUhleChoZXgpIHtcbiAgY29uc3QgaGV4V2l0aG91dFByZWZpeCA9IHJlbW92ZUhleFByZWZpeChoZXgpO1xuICBjb25zdCBzYW5pdGl6ZWRIZXggPSBzYW5pdGl6ZUJ5dGVzKGhleFdpdGhvdXRQcmVmaXgsIDIpO1xuICByZXR1cm4gc2FuaXRpemVkSGV4ID8gYWRkSGV4UHJlZml4KHNhbml0aXplZEhleCkgOiBzYW5pdGl6ZWRIZXg7XG59XG52YXIgcGFzY2FsVG9TbmFrZSA9ICh0ZXh0KSA9PiAvW2Etel0vLnRlc3QodGV4dCkgPyB0ZXh0LnNwbGl0KC8oPz1bQS1aXSkvKS5qb2luKFwiX1wiKS50b1VwcGVyQ2FzZSgpIDogdGV4dDtcbmZ1bmN0aW9uIGNvbmNhdGVuYXRlQXJyYXlCdWZmZXIodWludDhhcnJheXMpIHtcbiAgY29uc3QgdG90YWxMZW5ndGggPSB1aW50OGFycmF5cy5yZWR1Y2UoKHRvdGFsLCB1aW50OGFycmF5KSA9PiB0b3RhbCArIHVpbnQ4YXJyYXkuYnl0ZUxlbmd0aCwgMCk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIHVpbnQ4YXJyYXlzLmZvckVhY2goKHVpbnQ4YXJyYXkpID0+IHtcbiAgICByZXN1bHQuc2V0KHVpbnQ4YXJyYXksIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHVpbnQ4YXJyYXkuYnl0ZUxlbmd0aDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9nbG9iYWwvY29uc3RhbnRzLnRzXG52YXIgVEVYVF9UT19GRUxUX01BWF9MRU4gPSAzMTtcbnZhciBaRVJPID0gMG47XG52YXIgTUFTS18yNTAgPSAybiAqKiAyNTBuIC0gMW47XG52YXIgTUFTS18zMSA9IDJuICoqIDMxbiAtIDFuO1xudmFyIEFQSV9WRVJTSU9OID0gWkVSTztcbnZhciBQUklNRSA9IDJuICoqIDI1MW4gKyAxN24gKiAybiAqKiAxOTJuICsgMW47XG52YXIgTUFYX1NUT1JBR0VfSVRFTV9TSVpFID0gMjU2bjtcbnZhciBBRERSX0JPVU5EID0gMm4gKiogMjUxbiAtIE1BWF9TVE9SQUdFX0lURU1fU0laRTtcbnZhciByYW5nZSA9IChtaW4sIG1heCkgPT4gKHsgbWluLCBtYXggfSk7XG52YXIgUkFOR0VfRkVMVCA9IHJhbmdlKFpFUk8sIFBSSU1FIC0gMW4pO1xudmFyIFJBTkdFX0kxMjggPSByYW5nZSgtKDJuICoqIDEyN24pLCAybiAqKiAxMjduIC0gMW4pO1xudmFyIFJBTkdFX1UxMjggPSByYW5nZShaRVJPLCAybiAqKiAxMjhuIC0gMW4pO1xudmFyIEJhc2VVcmwgPSAvKiBAX19QVVJFX18gKi8gKChCYXNlVXJsMikgPT4ge1xuICBCYXNlVXJsMltcIlNOX01BSU5cIl0gPSBcImh0dHBzOi8vYWxwaGEtbWFpbm5ldC5zdGFya25ldC5pb1wiO1xuICBCYXNlVXJsMltcIlNOX1NFUE9MSUFcIl0gPSBcImh0dHBzOi8vYWxwaGEtc2Vwb2xpYS5zdGFya25ldC5pb1wiO1xuICByZXR1cm4gQmFzZVVybDI7XG59KShCYXNlVXJsIHx8IHt9KTtcbnZhciBOZXR3b3JrTmFtZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ldHdvcmtOYW1lMikgPT4ge1xuICBOZXR3b3JrTmFtZTJbXCJTTl9NQUlOXCJdID0gXCJTTl9NQUlOXCI7XG4gIE5ldHdvcmtOYW1lMltcIlNOX1NFUE9MSUFcIl0gPSBcIlNOX1NFUE9MSUFcIjtcbiAgcmV0dXJuIE5ldHdvcmtOYW1lMjtcbn0pKE5ldHdvcmtOYW1lIHx8IHt9KTtcbnZhciBTdGFya25ldENoYWluSWQgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldENoYWluSWQ2KSA9PiB7XG4gIFN0YXJrbmV0Q2hhaW5JZDZbXCJTTl9NQUlOXCJdID0gXCIweDUzNGU1ZjRkNDE0OTRlXCI7XG4gIFN0YXJrbmV0Q2hhaW5JZDZbXCJTTl9TRVBPTElBXCJdID0gXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCI7XG4gIHJldHVybiBTdGFya25ldENoYWluSWQ2O1xufSkoU3RhcmtuZXRDaGFpbklkIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvbkhhc2hQcmVmaXggPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvbkhhc2hQcmVmaXgyKSA9PiB7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERUNMQVJFXCJdID0gXCIweDY0NjU2MzZjNjE3MjY1XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERVBMT1lcIl0gPSBcIjB4NjQ2NTcwNmM2Zjc5XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERVBMT1lfQUNDT1VOVFwiXSA9IFwiMHg2NDY1NzA2YzZmNzk1ZjYxNjM2MzZmNzU2ZTc0XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJJTlZPS0VcIl0gPSBcIjB4Njk2ZTc2NmY2YjY1XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJMMV9IQU5ETEVSXCJdID0gXCIweDZjMzE1ZjY4NjE2ZTY0NmM2NTcyXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyO1xufSkoVHJhbnNhY3Rpb25IYXNoUHJlZml4IHx8IHt9KTtcbnZhciBGZWVNYXJnaW5QZXJjZW50YWdlID0gLyogQF9fUFVSRV9fICovICgoRmVlTWFyZ2luUGVyY2VudGFnZTIpID0+IHtcbiAgRmVlTWFyZ2luUGVyY2VudGFnZTJbRmVlTWFyZ2luUGVyY2VudGFnZTJbXCJMMV9CT1VORF9NQVhfQU1PVU5UXCJdID0gNTBdID0gXCJMMV9CT1VORF9NQVhfQU1PVU5UXCI7XG4gIEZlZU1hcmdpblBlcmNlbnRhZ2UyW0ZlZU1hcmdpblBlcmNlbnRhZ2UyW1wiTDFfQk9VTkRfTUFYX1BSSUNFX1BFUl9VTklUXCJdID0gNTBdID0gXCJMMV9CT1VORF9NQVhfUFJJQ0VfUEVSX1VOSVRcIjtcbiAgRmVlTWFyZ2luUGVyY2VudGFnZTJbRmVlTWFyZ2luUGVyY2VudGFnZTJbXCJNQVhfRkVFXCJdID0gNTBdID0gXCJNQVhfRkVFXCI7XG4gIHJldHVybiBGZWVNYXJnaW5QZXJjZW50YWdlMjtcbn0pKEZlZU1hcmdpblBlcmNlbnRhZ2UgfHwge30pO1xudmFyIFVEQyA9IHtcbiAgQUREUkVTUzogXCIweDA0MWE3OGU3NDFlNWFmMmZlYzM0YjY5NTY3OWJjNjg5MTc0MjQzOWY3YWZiODQ4NGVjZDc3NjY2NjFhZDAyYmZcIixcbiAgRU5UUllQT0lOVDogXCJkZXBsb3lDb250cmFjdFwiXG59O1xudmFyIFJQQ19ERUZBVUxUX1ZFUlNJT04gPSBcInYwXzdcIjtcbnZhciBSUENfTk9ERVMgPSB7XG4gIFNOX01BSU46IFtcbiAgICBgaHR0cHM6Ly9zdGFya25ldC1tYWlubmV0LnB1YmxpYy5ibGFzdGFwaS5pby9ycGMvJHtSUENfREVGQVVMVF9WRVJTSU9OfWAsXG4gICAgYGh0dHBzOi8vZnJlZS1ycGMubmV0aGVybWluZC5pby9tYWlubmV0LWp1bm8vJHtSUENfREVGQVVMVF9WRVJTSU9OfWBcbiAgXSxcbiAgU05fU0VQT0xJQTogW1xuICAgIGBodHRwczovL3N0YXJrbmV0LXNlcG9saWEucHVibGljLmJsYXN0YXBpLmlvL3JwYy8ke1JQQ19ERUZBVUxUX1ZFUlNJT059YCxcbiAgICBgaHR0cHM6Ly9mcmVlLXJwYy5uZXRoZXJtaW5kLmlvL3NlcG9saWEtanVuby8ke1JQQ19ERUZBVUxUX1ZFUlNJT059YFxuICBdXG59O1xudmFyIE91dHNpZGVFeGVjdXRpb25DYWxsZXJBbnkgPSBcIjB4NDE0ZTU5NWY0MzQxNGM0YzQ1NTJcIjtcbnZhciBTTklQOV9WMV9JTlRFUkZBQ0VfSUQgPSBcIjB4NjhjZmQxOGI5MmQxOTA3YjhiYTNjYzMyNDkwMDI3N2Y1YTM2MjIwOTk0MzFlYTg1ZGQ4MDg5MjU1ZTQxODFcIjtcbnZhciBTTklQOV9WMl9JTlRFUkZBQ0VfSUQgPSBcIjB4MWQxMTQ0YmIyMTM4MzY2ZmYyOGQ4ZTlhYjU3NDU2YjFkMzMyYWM0MjE5NjIzMGMzYTYwMjAwM2M4OTg3MlwiO1xudmFyIEhBUkRFTklOR19CWVRFID0gMTI4O1xudmFyIEhBUkRFTklOR180QllURVMgPSAyMTQ3NDgzNjQ4bjtcbnZhciBERUZBVUxUX0dMT0JBTF9DT05GSUcgPSB7XG4gIGxlZ2FjeU1vZGU6IGZhbHNlLFxuICBsb2dMZXZlbDogXCJJTkZPXCIsXG4gIGFjY291bnRUeFZlcnNpb246IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjJcbn07XG52YXIgU1lTVEVNX01FU1NBR0VTID0ge1xuICBsZWdhY3lUeFdhcm5pbmdNZXNzYWdlOiBcIllvdSBhcmUgdXNpbmcgYSBkZXByZWNhdGVkIHRyYW5zYWN0aW9uIHZlcnNpb24gKFYwLFYxLFYyKSFcXG5VcGRhdGUgdG8gdGhlIGxhdGVzdCBWMyB0cmFuc2FjdGlvbnMhXCJcbn07XG5cbi8vIHNyYy9jaGFubmVsL3JwY18wXzYudHNcbnZhciBycGNfMF82X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHJwY18wXzZfZXhwb3J0cywge1xuICBScGNDaGFubmVsOiAoKSA9PiBScGNDaGFubmVsXG59KTtcblxuLy8gc3JjL3V0aWxzL2pzb24udHNcbnZhciBqc29uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGpzb25fZXhwb3J0cywge1xuICBwYXJzZTogKCkgPT4gcGFyc2UyLFxuICBwYXJzZUFsd2F5c0FzQmlnOiAoKSA9PiBwYXJzZUFsd2F5c0FzQmlnLFxuICBzdHJpbmdpZnk6ICgpID0+IHN0cmluZ2lmeTIsXG4gIHN0cmluZ2lmeUFsd2F5c0FzQmlnOiAoKSA9PiBzdHJpbmdpZnlBbHdheXNBc0JpZ1xufSk7XG5pbXBvcnQgKiBhcyBqc29uIGZyb20gXCJsb3NzbGVzcy1qc29uXCI7XG52YXIgcGFyc2VJbnRBc051bWJlck9yQmlnSW50ID0gKHN0cikgPT4ge1xuICBpZiAoIWpzb24uaXNJbnRlZ2VyKHN0cikpIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gIGNvbnN0IG51bSA9IHBhcnNlSW50KHN0ciwgMTApO1xuICByZXR1cm4gTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSA/IG51bSA6IEJpZ0ludChzdHIpO1xufTtcbnZhciBwYXJzZTIgPSAoc3RyKSA9PiBqc29uLnBhcnNlKFN0cmluZyhzdHIpLCB2b2lkIDAsIHBhcnNlSW50QXNOdW1iZXJPckJpZ0ludCk7XG52YXIgcGFyc2VBbHdheXNBc0JpZyA9IChzdHIpID0+IGpzb24ucGFyc2UoU3RyaW5nKHN0ciksIHZvaWQgMCwganNvbi5wYXJzZU51bWJlckFuZEJpZ0ludCk7XG52YXIgc3RyaW5naWZ5MiA9ICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlLCBudW1iZXJTdHJpbmdpZmllcnMpID0+IGpzb24uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UsIG51bWJlclN0cmluZ2lmaWVycyk7XG52YXIgc3RyaW5naWZ5QWx3YXlzQXNCaWcgPSBzdHJpbmdpZnkyO1xuXG4vLyBzcmMvdXRpbHMvZXJyb3JzL3JwYy50c1xudmFyIGVycm9yQ29kZXMgPSB7XG4gIEZBSUxFRF9UT19SRUNFSVZFX1RYTjogMSxcbiAgTk9fVFJBQ0VfQVZBSUxBQkxFOiAxMCxcbiAgQ09OVFJBQ1RfTk9UX0ZPVU5EOiAyMCxcbiAgQkxPQ0tfTk9UX0ZPVU5EOiAyNCxcbiAgSU5WQUxJRF9UWE5fSU5ERVg6IDI3LFxuICBDTEFTU19IQVNIX05PVF9GT1VORDogMjgsXG4gIFRYTl9IQVNIX05PVF9GT1VORDogMjksXG4gIFBBR0VfU0laRV9UT09fQklHOiAzMSxcbiAgTk9fQkxPQ0tTOiAzMixcbiAgSU5WQUxJRF9DT05USU5VQVRJT05fVE9LRU46IDMzLFxuICBUT09fTUFOWV9LRVlTX0lOX0ZJTFRFUjogMzQsXG4gIENPTlRSQUNUX0VSUk9SOiA0MCxcbiAgVFJBTlNBQ1RJT05fRVhFQ1VUSU9OX0VSUk9SOiA0MSxcbiAgQ0xBU1NfQUxSRUFEWV9ERUNMQVJFRDogNTEsXG4gIElOVkFMSURfVFJBTlNBQ1RJT05fTk9OQ0U6IDUyLFxuICBJTlNVRkZJQ0lFTlRfTUFYX0ZFRTogNTMsXG4gIElOU1VGRklDSUVOVF9BQ0NPVU5UX0JBTEFOQ0U6IDU0LFxuICBWQUxJREFUSU9OX0ZBSUxVUkU6IDU1LFxuICBDT01QSUxBVElPTl9GQUlMRUQ6IDU2LFxuICBDT05UUkFDVF9DTEFTU19TSVpFX0lTX1RPT19MQVJHRTogNTcsXG4gIE5PTl9BQ0NPVU5UOiA1OCxcbiAgRFVQTElDQVRFX1RYOiA1OSxcbiAgQ09NUElMRURfQ0xBU1NfSEFTSF9NSVNNQVRDSDogNjAsXG4gIFVOU1VQUE9SVEVEX1RYX1ZFUlNJT046IDYxLFxuICBVTlNVUFBPUlRFRF9DT05UUkFDVF9DTEFTU19WRVJTSU9OOiA2MixcbiAgVU5FWFBFQ1RFRF9FUlJPUjogNjNcbn07XG52YXIgcnBjX2RlZmF1bHQgPSBlcnJvckNvZGVzO1xuXG4vLyBzcmMvdXRpbHMvZXJyb3JzL2luZGV4LnRzXG5mdW5jdGlvbiBmaXhTdGFjayh0YXJnZXQsIGZuID0gdGFyZ2V0LmNvbnN0cnVjdG9yKSB7XG4gIGNvbnN0IHsgY2FwdHVyZVN0YWNrVHJhY2UgfSA9IEVycm9yO1xuICBjYXB0dXJlU3RhY2tUcmFjZSAmJiBjYXB0dXJlU3RhY2tUcmFjZSh0YXJnZXQsIGZuKTtcbn1cbmZ1bmN0aW9uIGZpeFByb3RvKHRhcmdldCwgcHJvdG90eXBlKSB7XG4gIGNvbnN0IHsgc2V0UHJvdG90eXBlT2YgfSA9IE9iamVjdDtcbiAgc2V0UHJvdG90eXBlT2YgPyBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvdHlwZSkgOiB0YXJnZXQuX19wcm90b19fID0gcHJvdG90eXBlO1xufVxudmFyIEN1c3RvbUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWU7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIHZhbHVlOiBuZXcudGFyZ2V0Lm5hbWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGZpeFByb3RvKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICBmaXhTdGFjayh0aGlzKTtcbiAgfVxufTtcbnZhciBMaWJyYXJ5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEN1c3RvbUVycm9yIHtcbn07XG52YXIgUnBjRXJyb3IgPSBjbGFzcyBleHRlbmRzIExpYnJhcnlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGJhc2VFcnJvciwgbWV0aG9kLCBwYXJhbXMpIHtcbiAgICBzdXBlcihgUlBDOiAke21ldGhvZH0gd2l0aCBwYXJhbXMgJHtzdHJpbmdpZnkyKHBhcmFtcywgbnVsbCwgMil9XG5cbiAgICAgICR7YmFzZUVycm9yLmNvZGV9OiAke2Jhc2VFcnJvci5tZXNzYWdlfTogJHtzdHJpbmdpZnkyKGJhc2VFcnJvci5kYXRhKX1gKTtcbiAgICB0aGlzLmJhc2VFcnJvciA9IGJhc2VFcnJvcjtcbiAgICB0aGlzLnJlcXVlc3QgPSB7IG1ldGhvZCwgcGFyYW1zIH07XG4gIH1cbiAgcmVxdWVzdDtcbiAgZ2V0IGNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZUVycm9yLmNvZGU7XG4gIH1cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoZSB1bmRlcmx5aW5nIFJQQyBlcnJvciwgYWxzbyBzZXJ2ZXMgYXMgYSB0eXBlIGd1YXJkIGZvciB0aGUgX2Jhc2VFcnJvcl8gcHJvcGVydHlcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBTb21lRXJyb3IuaXNUeXBlKCdVTkVYUEVDVEVEX0VSUk9SJyk7XG4gICAqIGBgYFxuICAgKi9cbiAgaXNUeXBlKHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuIHJwY19kZWZhdWx0W3R5cGVOYW1lXSA9PT0gdGhpcy5jb2RlO1xuICB9XG59O1xuXG4vLyBzcmMvdHlwZXMvaW5kZXgudHNcbnZhciB0eXBlc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh0eXBlc19leHBvcnRzLCB7XG4gIEJsb2NrU3RhdHVzOiAoKSA9PiBCbG9ja1N0YXR1cyxcbiAgQmxvY2tUYWc6ICgpID0+IEJsb2NrVGFnLFxuICBFVEhfQUREUkVTUzogKCkgPT4gRVRIX0FERFJFU1MsXG4gIEVudHJ5UG9pbnRUeXBlOiAoKSA9PiBFbnRyeVBvaW50VHlwZSxcbiAgTGl0ZXJhbDogKCkgPT4gTGl0ZXJhbCxcbiAgTk9OX1pFUk9fUFJFRklYOiAoKSA9PiBOT05fWkVST19QUkVGSVgsXG4gIE91dHNpZGVFeGVjdXRpb25UeXBlc1YxOiAoKSA9PiBPdXRzaWRlRXhlY3V0aW9uVHlwZXNWMSxcbiAgT3V0c2lkZUV4ZWN1dGlvblR5cGVzVjI6ICgpID0+IE91dHNpZGVFeGVjdXRpb25UeXBlc1YyLFxuICBPdXRzaWRlRXhlY3V0aW9uVmVyc2lvbjogKCkgPT4gT3V0c2lkZUV4ZWN1dGlvblZlcnNpb24sXG4gIFJQQzogKCkgPT4gYXBpX2V4cG9ydHMsXG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzOiAoKSA9PiBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czogKCkgPT4gVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyxcbiAgVHJhbnNhY3Rpb25TdGF0dXM6ICgpID0+IFRyYW5zYWN0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvblR5cGU6ICgpID0+IFRyYW5zYWN0aW9uVHlwZSxcbiAgVHlwZWREYXRhUmV2aXNpb246ICgpID0+IFR5cGVkRGF0YVJldmlzaW9uLFxuICBVaW50OiAoKSA9PiBVaW50LFxuICBWYWxpZGF0ZVR5cGU6ICgpID0+IFZhbGlkYXRlVHlwZVxufSk7XG5cbi8vIHNyYy90eXBlcy9saWIvY29udHJhY3QvaW5kZXgudHNcbnZhciBFbnRyeVBvaW50VHlwZSA9IHtcbiAgRVhURVJOQUw6IFwiRVhURVJOQUxcIixcbiAgTDFfSEFORExFUjogXCJMMV9IQU5ETEVSXCIsXG4gIENPTlNUUlVDVE9SOiBcIkNPTlNUUlVDVE9SXCJcbn07XG5cbi8vIHNyYy90eXBlcy9saWIvaW5kZXgudHNcbnZhciBUcmFuc2FjdGlvblR5cGUgPSB7XG4gIERFQ0xBUkU6IFwiREVDTEFSRVwiLFxuICBERVBMT1k6IFwiREVQTE9ZXCIsXG4gIERFUExPWV9BQ0NPVU5UOiBcIkRFUExPWV9BQ0NPVU5UXCIsXG4gIElOVk9LRTogXCJJTlZPS0VfRlVOQ1RJT05cIlxufTtcbnZhciBUcmFuc2FjdGlvblN0YXR1cyA9IHtcbiAgTk9UX1JFQ0VJVkVEOiBcIk5PVF9SRUNFSVZFRFwiLFxuICBSRUNFSVZFRDogXCJSRUNFSVZFRFwiLFxuICBBQ0NFUFRFRF9PTl9MMjogXCJBQ0NFUFRFRF9PTl9MMlwiLFxuICBBQ0NFUFRFRF9PTl9MMTogXCJBQ0NFUFRFRF9PTl9MMVwiLFxuICBSRUpFQ1RFRDogXCJSRUpFQ1RFRFwiLFxuICBSRVZFUlRFRDogXCJSRVZFUlRFRFwiXG59O1xudmFyIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMgPSB7XG4gIE5PVF9SRUNFSVZFRDogXCJOT1RfUkVDRUlWRURcIixcbiAgUkVDRUlWRUQ6IFwiUkVDRUlWRURcIixcbiAgQUNDRVBURURfT05fTDI6IFwiQUNDRVBURURfT05fTDJcIixcbiAgQUNDRVBURURfT05fTDE6IFwiQUNDRVBURURfT05fTDFcIlxufTtcbnZhciBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyA9IHtcbiAgUkVKRUNURUQ6IFwiUkVKRUNURURcIixcbiAgUkVWRVJURUQ6IFwiUkVWRVJURURcIixcbiAgU1VDQ0VFREVEOiBcIlNVQ0NFRURFRFwiXG59O1xudmFyIEJsb2NrU3RhdHVzID0ge1xuICBQRU5ESU5HOiBcIlBFTkRJTkdcIixcbiAgQUNDRVBURURfT05fTDE6IFwiQUNDRVBURURfT05fTDFcIixcbiAgQUNDRVBURURfT05fTDI6IFwiQUNDRVBURURfT05fTDJcIixcbiAgUkVKRUNURUQ6IFwiUkVKRUNURURcIlxufTtcbnZhciBCbG9ja1RhZyA9IHtcbiAgUEVORElORzogXCJwZW5kaW5nXCIsXG4gIExBVEVTVDogXCJsYXRlc3RcIlxufTtcblxuLy8gc3JjL3R5cGVzL2NhbGxkYXRhLnRzXG52YXIgVmFsaWRhdGVUeXBlID0ge1xuICBERVBMT1k6IFwiREVQTE9ZXCIsXG4gIENBTEw6IFwiQ0FMTFwiLFxuICBJTlZPS0U6IFwiSU5WT0tFXCJcbn07XG52YXIgVWludCA9IHtcbiAgdTg6IFwiY29yZTo6aW50ZWdlcjo6dThcIixcbiAgdTE2OiBcImNvcmU6OmludGVnZXI6OnUxNlwiLFxuICB1MzI6IFwiY29yZTo6aW50ZWdlcjo6dTMyXCIsXG4gIHU2NDogXCJjb3JlOjppbnRlZ2VyOjp1NjRcIixcbiAgdTEyODogXCJjb3JlOjppbnRlZ2VyOjp1MTI4XCIsXG4gIHUyNTY6IFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiLFxuICAvLyBUaGlzIG9uZSBpcyBzdHJ1Y3RcbiAgdTUxMjogXCJjb3JlOjppbnRlZ2VyOjp1NTEyXCJcbiAgLy8gVGhpcyBvbmUgaXMgc3RydWN0XG59O1xudmFyIExpdGVyYWwgPSB7XG4gIENsYXNzSGFzaDogXCJjb3JlOjpzdGFya25ldDo6Y2xhc3NfaGFzaDo6Q2xhc3NIYXNoXCIsXG4gIENvbnRyYWN0QWRkcmVzczogXCJjb3JlOjpzdGFya25ldDo6Y29udHJhY3RfYWRkcmVzczo6Q29udHJhY3RBZGRyZXNzXCIsXG4gIFNlY3AyNTZrMVBvaW50OiBcImNvcmU6OnN0YXJrbmV0OjpzZWNwMjU2azE6OlNlY3AyNTZrMVBvaW50XCIsXG4gIFU5NjogXCJjb3JlOjppbnRlcm5hbDo6Ym91bmRlZF9pbnQ6OkJvdW5kZWRJbnQ6OjwwLCA3OTIyODE2MjUxNDI2NDMzNzU5MzU0Mzk1MDMzNT5cIlxufTtcbnZhciBFVEhfQUREUkVTUyA9IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCI7XG52YXIgTk9OX1pFUk9fUFJFRklYID0gXCJjb3JlOjp6ZXJvYWJsZTo6Tm9uWmVybzo6XCI7XG5cbi8vIHNyYy90eXBlcy9vdXRzaWRlRXhlY3V0aW9uLnRzXG52YXIgT3V0c2lkZUV4ZWN1dGlvblR5cGVzVjEgPSB7XG4gIFN0YXJrTmV0RG9tYWluOiBbXG4gICAgeyBuYW1lOiBcIm5hbWVcIiwgdHlwZTogXCJmZWx0XCIgfSxcbiAgICB7IG5hbWU6IFwidmVyc2lvblwiLCB0eXBlOiBcImZlbHRcIiB9LFxuICAgIHsgbmFtZTogXCJjaGFpbklkXCIsIHR5cGU6IFwiZmVsdFwiIH1cbiAgXSxcbiAgT3V0c2lkZUV4ZWN1dGlvbjogW1xuICAgIHsgbmFtZTogXCJjYWxsZXJcIiwgdHlwZTogXCJmZWx0XCIgfSxcbiAgICB7IG5hbWU6IFwibm9uY2VcIiwgdHlwZTogXCJmZWx0XCIgfSxcbiAgICB7IG5hbWU6IFwiZXhlY3V0ZV9hZnRlclwiLCB0eXBlOiBcImZlbHRcIiB9LFxuICAgIHsgbmFtZTogXCJleGVjdXRlX2JlZm9yZVwiLCB0eXBlOiBcImZlbHRcIiB9LFxuICAgIHsgbmFtZTogXCJjYWxsc19sZW5cIiwgdHlwZTogXCJmZWx0XCIgfSxcbiAgICB7IG5hbWU6IFwiY2FsbHNcIiwgdHlwZTogXCJPdXRzaWRlQ2FsbCpcIiB9XG4gIF0sXG4gIE91dHNpZGVDYWxsOiBbXG4gICAgeyBuYW1lOiBcInRvXCIsIHR5cGU6IFwiZmVsdFwiIH0sXG4gICAgeyBuYW1lOiBcInNlbGVjdG9yXCIsIHR5cGU6IFwiZmVsdFwiIH0sXG4gICAgeyBuYW1lOiBcImNhbGxkYXRhX2xlblwiLCB0eXBlOiBcImZlbHRcIiB9LFxuICAgIHsgbmFtZTogXCJjYWxsZGF0YVwiLCB0eXBlOiBcImZlbHQqXCIgfVxuICBdXG59O1xudmFyIE91dHNpZGVFeGVjdXRpb25UeXBlc1YyID0ge1xuICBTdGFya25ldERvbWFpbjogW1xuICAgIC8vIFNOSVAtMTIgcmV2aXNpb24gMSBpcyB1c2VkLCBzbyBzaG91bGQgYmUgXCJTdGFya25ldERvbWFpblwiLCBub3QgXCJTdGFya05ldERvbWFpblwiXG4gICAgeyBuYW1lOiBcIm5hbWVcIiwgdHlwZTogXCJzaG9ydHN0cmluZ1wiIH0sXG4gICAgeyBuYW1lOiBcInZlcnNpb25cIiwgdHlwZTogXCJzaG9ydHN0cmluZ1wiIH0sXG4gICAgLy8gc2V0IHRvIDIgaW4gdjJcbiAgICB7IG5hbWU6IFwiY2hhaW5JZFwiLCB0eXBlOiBcInNob3J0c3RyaW5nXCIgfSxcbiAgICB7IG5hbWU6IFwicmV2aXNpb25cIiwgdHlwZTogXCJzaG9ydHN0cmluZ1wiIH1cbiAgXSxcbiAgT3V0c2lkZUV4ZWN1dGlvbjogW1xuICAgIHsgbmFtZTogXCJDYWxsZXJcIiwgdHlwZTogXCJDb250cmFjdEFkZHJlc3NcIiB9LFxuICAgIHsgbmFtZTogXCJOb25jZVwiLCB0eXBlOiBcImZlbHRcIiB9LFxuICAgIHsgbmFtZTogXCJFeGVjdXRlIEFmdGVyXCIsIHR5cGU6IFwidTEyOFwiIH0sXG4gICAgeyBuYW1lOiBcIkV4ZWN1dGUgQmVmb3JlXCIsIHR5cGU6IFwidTEyOFwiIH0sXG4gICAgeyBuYW1lOiBcIkNhbGxzXCIsIHR5cGU6IFwiQ2FsbCpcIiB9XG4gIF0sXG4gIENhbGw6IFtcbiAgICB7IG5hbWU6IFwiVG9cIiwgdHlwZTogXCJDb250cmFjdEFkZHJlc3NcIiB9LFxuICAgIHsgbmFtZTogXCJTZWxlY3RvclwiLCB0eXBlOiBcInNlbGVjdG9yXCIgfSxcbiAgICB7IG5hbWU6IFwiQ2FsbGRhdGFcIiwgdHlwZTogXCJmZWx0KlwiIH1cbiAgXVxufTtcbnZhciBPdXRzaWRlRXhlY3V0aW9uVmVyc2lvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKE91dHNpZGVFeGVjdXRpb25WZXJzaW9uMikgPT4ge1xuICBPdXRzaWRlRXhlY3V0aW9uVmVyc2lvbjJbXCJVTlNVUFBPUlRFRFwiXSA9IFwiMFwiO1xuICBPdXRzaWRlRXhlY3V0aW9uVmVyc2lvbjJbXCJWMVwiXSA9IFwiMVwiO1xuICBPdXRzaWRlRXhlY3V0aW9uVmVyc2lvbjJbXCJWMlwiXSA9IFwiMlwiO1xuICByZXR1cm4gT3V0c2lkZUV4ZWN1dGlvblZlcnNpb24yO1xufSkoT3V0c2lkZUV4ZWN1dGlvblZlcnNpb24gfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvdHlwZWREYXRhLnRzXG5pbXBvcnQge1xuICBUeXBlZERhdGFSZXZpc2lvblxufSBmcm9tIFwic3RhcmtuZXQtdHlwZXMtMDdcIjtcblxuLy8gc3JjL3V0aWxzL2JhdGNoL2luZGV4LnRzXG52YXIgQmF0Y2hDbGllbnQgPSBjbGFzcyB7XG4gIG5vZGVVcmw7XG4gIGhlYWRlcnM7XG4gIGludGVydmFsO1xuICByZXF1ZXN0SWQgPSAwO1xuICBwZW5kaW5nUmVxdWVzdHMgPSB7fTtcbiAgYmF0Y2hQcm9taXNlcyA9IHt9O1xuICBkZWxheVRpbWVyO1xuICBkZWxheVByb21pc2U7XG4gIGRlbGF5UHJvbWlzZVJlc29sdmU7XG4gIGJhc2VGZXRjaDtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMubm9kZVVybCA9IG9wdGlvbnMubm9kZVVybDtcbiAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgdGhpcy5pbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWw7XG4gICAgdGhpcy5iYXNlRmV0Y2ggPSBvcHRpb25zLmJhc2VGZXRjaDtcbiAgfVxuICBhc3luYyB3YWl0KCkge1xuICAgIGlmICghdGhpcy5kZWxheVByb21pc2UgfHwgIXRoaXMuZGVsYXlQcm9taXNlUmVzb2x2ZSkge1xuICAgICAgdGhpcy5kZWxheVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzLmRlbGF5UHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGF5VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZXIpO1xuICAgICAgdGhpcy5kZWxheVRpbWVyID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLmRlbGF5VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlbGF5UHJvbWlzZVJlc29sdmUpIHtcbiAgICAgICAgdGhpcy5kZWxheVByb21pc2VSZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuZGVsYXlQcm9taXNlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmRlbGF5UHJvbWlzZVJlc29sdmUgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pbnRlcnZhbCk7XG4gICAgcmV0dXJuIHRoaXMuZGVsYXlQcm9taXNlO1xuICB9XG4gIGFkZFBlbmRpbmdSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zLCBpZCkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBpZDogaWQgPz8gYGJhdGNoZWRfJHt0aGlzLnJlcXVlc3RJZCArPSAxfWAsXG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgbWV0aG9kLFxuICAgICAgcGFyYW1zOiBwYXJhbXMgPz8gdm9pZCAwXG4gICAgfTtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0c1tyZXF1ZXN0LmlkXSA9IHJlcXVlc3Q7XG4gICAgcmV0dXJuIHJlcXVlc3QuaWQ7XG4gIH1cbiAgYXN5bmMgc2VuZEJhdGNoKHJlcXVlc3RzKSB7XG4gICAgY29uc3QgcmF3ID0gYXdhaXQgdGhpcy5iYXNlRmV0Y2godGhpcy5ub2RlVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogc3RyaW5naWZ5MihyZXF1ZXN0cyksXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gcmF3Lmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogQXV0b21hdGljYWxseSBiYXRjaGVzIGFuZCBmZXRjaGVzIEpTT04tUlBDIGNhbGxzIGluIGEgc2luZ2xlIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBtZXRob2QgTWV0aG9kIHRvIGNhbGxcbiAgICogQHBhcmFtIHBhcmFtcyBNZXRob2QgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gaWQgSlNPTi1SUEMgUmVxdWVzdCBJRFxuICAgKiBAcmV0dXJucyBKU09OLVJQQyBSZXNwb25zZVxuICAgKi9cbiAgYXN5bmMgZmV0Y2gobWV0aG9kLCBwYXJhbXMsIGlkKSB7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdGhpcy5hZGRQZW5kaW5nUmVxdWVzdChtZXRob2QsIHBhcmFtcywgaWQpO1xuICAgIGF3YWl0IHRoaXMud2FpdCgpO1xuICAgIGNvbnN0IHJlcXVlc3RzID0gdGhpcy5wZW5kaW5nUmVxdWVzdHM7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSB7fTtcbiAgICBpZiAoIXRoaXMuYmF0Y2hQcm9taXNlc1tyZXF1ZXN0SWRdKSB7XG4gICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5zZW5kQmF0Y2goT2JqZWN0LnZhbHVlcyhyZXF1ZXN0cykpO1xuICAgICAgT2JqZWN0LmtleXMocmVxdWVzdHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICB0aGlzLmJhdGNoUHJvbWlzZXNba2V5XSA9IHByb21pc2U7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuYmF0Y2hQcm9taXNlc1tyZXF1ZXN0SWRdO1xuICAgIGRlbGV0ZSB0aGlzLmJhdGNoUHJvbWlzZXNbcmVxdWVzdElkXTtcbiAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzLmZpbmQoKHJlcykgPT4gcmVzLmlkID09PSByZXF1ZXN0SWQpO1xuICAgIGlmICghcmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgdGhlIHJlc3VsdCBmb3IgdGhlIHJlcXVlc3QuIE1ldGhvZDogJHttZXRob2R9YCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2Fzc2VydC50c1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwiQXNzZXJ0aW9uIGZhaWx1cmVcIik7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL251bS50c1xudmFyIG51bV9leHBvcnRzID0ge307XG5fX2V4cG9ydChudW1fZXhwb3J0cywge1xuICBhZGRQZXJjZW50OiAoKSA9PiBhZGRQZXJjZW50LFxuICBhc3NlcnRJblJhbmdlOiAoKSA9PiBhc3NlcnRJblJhbmdlLFxuICBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5OiAoKSA9PiBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5LFxuICBiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheTogKCkgPT4gYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXksXG4gIGNsZWFuSGV4OiAoKSA9PiBjbGVhbkhleCxcbiAgZ2V0RGVjaW1hbFN0cmluZzogKCkgPT4gZ2V0RGVjaW1hbFN0cmluZyxcbiAgZ2V0SGV4U3RyaW5nOiAoKSA9PiBnZXRIZXhTdHJpbmcsXG4gIGdldEhleFN0cmluZ0FycmF5OiAoKSA9PiBnZXRIZXhTdHJpbmdBcnJheSxcbiAgaGV4VG9CeXRlczogKCkgPT4gaGV4VG9CeXRlcyxcbiAgaGV4VG9EZWNpbWFsU3RyaW5nOiAoKSA9PiBoZXhUb0RlY2ltYWxTdHJpbmcsXG4gIGlzQmlnTnVtYmVyaXNoOiAoKSA9PiBpc0JpZ051bWJlcmlzaCxcbiAgaXNIZXg6ICgpID0+IGlzSGV4LFxuICBpc1N0cmluZ1dob2xlTnVtYmVyOiAoKSA9PiBpc1N0cmluZ1dob2xlTnVtYmVyLFxuICBzdHJpbmdUb1NoYTI1NlRvQXJyYXlCdWZmNDogKCkgPT4gc3RyaW5nVG9TaGEyNTZUb0FycmF5QnVmZjQsXG4gIHRvQmlnSW50OiAoKSA9PiB0b0JpZ0ludCxcbiAgdG9DYWlyb0Jvb2w6ICgpID0+IHRvQ2Fpcm9Cb29sLFxuICB0b0hleDogKCkgPT4gdG9IZXgsXG4gIHRvSGV4NjQ6ICgpID0+IHRvSGV4NjQsXG4gIHRvSGV4U3RyaW5nOiAoKSA9PiB0b0hleFN0cmluZyxcbiAgdG9TdG9yYWdlS2V5OiAoKSA9PiB0b1N0b3JhZ2VLZXlcbn0pO1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzTm9ibGUgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5cbi8vIHNyYy91dGlscy90eXBlZC50c1xudmFyIGlzVW5kZWZpbmVkID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsdWUgPT09IHZvaWQgMDtcbn07XG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gaXNCaWdJbnQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIjtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc09iamVjdChpdGVtKSB7XG4gIHJldHVybiAhIWl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoaXRlbSk7XG59XG5cbi8vIHNyYy91dGlscy9udW0udHNcbmZ1bmN0aW9uIGlzSGV4KGhleCkge1xuICByZXR1cm4gL14weFswLTlhLWZdKiQvaS50ZXN0KGhleCk7XG59XG5mdW5jdGlvbiB0b0JpZ0ludCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRvSGV4KHZhbHVlKSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgodG9CaWdJbnQodmFsdWUpLnRvU3RyaW5nKDE2KSk7XG59XG52YXIgdG9IZXhTdHJpbmcgPSB0b0hleDtcbmZ1bmN0aW9uIHRvU3RvcmFnZUtleShudW1iZXIyKSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgodG9CaWdJbnQobnVtYmVyMikudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCBcIjBcIikpO1xufVxuZnVuY3Rpb24gdG9IZXg2NChudW1iZXIyKSB7XG4gIGNvbnN0IHJlcyA9IGFkZEhleFByZWZpeCh0b0JpZ0ludChudW1iZXIyKS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsIFwiMFwiKSk7XG4gIGlmIChyZXMubGVuZ3RoICE9PSA2NikgdGhyb3cgVHlwZUVycm9yKFwibnVtYmVyIGlzIHRvbyBiaWcgZm9yIGhleCAweCg2NCkgcmVwcmVzZW50YXRpb25cIik7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBoZXhUb0RlY2ltYWxTdHJpbmcoaGV4KSB7XG4gIHJldHVybiBCaWdJbnQoYWRkSGV4UHJlZml4KGhleCkpLnRvU3RyaW5nKDEwKTtcbn1cbmZ1bmN0aW9uIGNsZWFuSGV4KGhleCkge1xuICByZXR1cm4gaGV4LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXigweCkwKy8sIFwiJDFcIik7XG59XG5mdW5jdGlvbiBhc3NlcnRJblJhbmdlKGlucHV0LCBsb3dlckJvdW5kLCB1cHBlckJvdW5kLCBpbnB1dE5hbWUgPSBcIlwiKSB7XG4gIGNvbnN0IG1lc3NhZ2VTdWZmaXggPSBpbnB1dE5hbWUgPT09IFwiXCIgPyBcImludmFsaWQgbGVuZ3RoXCIgOiBgaW52YWxpZCAke2lucHV0TmFtZX0gbGVuZ3RoYDtcbiAgY29uc3QgaW5wdXRCaWdJbnQgPSBCaWdJbnQoaW5wdXQpO1xuICBjb25zdCBsb3dlckJvdW5kQmlnSW50ID0gQmlnSW50KGxvd2VyQm91bmQpO1xuICBjb25zdCB1cHBlckJvdW5kQmlnSW50ID0gQmlnSW50KHVwcGVyQm91bmQpO1xuICBhc3NlcnQoXG4gICAgaW5wdXRCaWdJbnQgPj0gbG93ZXJCb3VuZEJpZ0ludCAmJiBpbnB1dEJpZ0ludCA8PSB1cHBlckJvdW5kQmlnSW50LFxuICAgIGBNZXNzYWdlIG5vdCBzaWduYWJsZSwgJHttZXNzYWdlU3VmZml4fS5gXG4gICk7XG59XG5mdW5jdGlvbiBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5KGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEubWFwKCh4KSA9PiB0b0JpZ0ludCh4KS50b1N0cmluZygxMCkpO1xufVxuZnVuY3Rpb24gYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXkoZGF0YSkge1xuICByZXR1cm4gZGF0YS5tYXAoKHgpID0+IHRvSGV4KHgpKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nV2hvbGVOdW1iZXIoc3RyKSB7XG4gIHJldHVybiAvXlxcZCskLy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBnZXREZWNpbWFsU3RyaW5nKHN0cikge1xuICBpZiAoaXNIZXgoc3RyKSkge1xuICAgIHJldHVybiBoZXhUb0RlY2ltYWxTdHJpbmcoc3RyKTtcbiAgfVxuICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcihzdHIpKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBuZWVkcyB0byBiZSBhIGhleC1zdHJpbmcgb3Igd2hvbGUtbnVtYmVyLXN0cmluZ2ApO1xufVxuZnVuY3Rpb24gZ2V0SGV4U3RyaW5nKHN0cikge1xuICBpZiAoaXNIZXgoc3RyKSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgaWYgKGlzU3RyaW5nV2hvbGVOdW1iZXIoc3RyKSkge1xuICAgIHJldHVybiB0b0hleFN0cmluZyhzdHIpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IG5lZWRzIHRvIGJlIGEgaGV4LXN0cmluZyBvciB3aG9sZS1udW1iZXItc3RyaW5nYCk7XG59XG5mdW5jdGlvbiBnZXRIZXhTdHJpbmdBcnJheShhcnJheSkge1xuICByZXR1cm4gYXJyYXkubWFwKGdldEhleFN0cmluZyk7XG59XG5mdW5jdGlvbiB0b0NhaXJvQm9vbCh2YWx1ZSkge1xuICByZXR1cm4gKCt2YWx1ZSkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoc3RyKSB7XG4gIGlmICghaXNIZXgoc3RyKSkgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gbmVlZHMgdG8gYmUgYSBoZXgtc3RyaW5nYCk7XG4gIGxldCBhZGFwdGVkVmFsdWUgPSByZW1vdmVIZXhQcmVmaXgoc3RyKTtcbiAgaWYgKGFkYXB0ZWRWYWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgYWRhcHRlZFZhbHVlID0gYDAke2FkYXB0ZWRWYWx1ZX1gO1xuICB9XG4gIHJldHVybiBoZXhUb0J5dGVzTm9ibGUoYWRhcHRlZFZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFkZFBlcmNlbnQobnVtYmVyMiwgcGVyY2VudCkge1xuICBjb25zdCBiaWdJbnROdW0gPSBCaWdJbnQobnVtYmVyMik7XG4gIHJldHVybiBiaWdJbnROdW0gKyBiaWdJbnROdW0gKiBCaWdJbnQocGVyY2VudCkgLyAxMDBuO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9TaGEyNTZUb0FycmF5QnVmZjQoc3RyKSB7XG4gIGNvbnN0IGludDMxID0gKG4pID0+IE51bWJlcihuICYgTUFTS18zMSk7XG4gIGNvbnN0IHJlc3VsdCA9IGludDMxKEJpZ0ludChhZGRIZXhQcmVmaXgoYnVmMmhleChzaGEyNTYoc3RyKSkpKSk7XG4gIHJldHVybiBoZXhUb0J5dGVzKHRvSGV4KHJlc3VsdCkpO1xufVxuZnVuY3Rpb24gaXNCaWdOdW1iZXJpc2goaW5wdXQpIHtcbiAgcmV0dXJuIGlzTnVtYmVyKGlucHV0KSB8fCBpc0JpZ0ludChpbnB1dCkgfHwgaXNTdHJpbmcoaW5wdXQpICYmIChpc0hleChpbnB1dCkgfHwgaXNTdHJpbmdXaG9sZU51bWJlcihpbnB1dCkpO1xufVxuXG4vLyBzcmMvdXRpbHMvaGFzaC9zZWxlY3Rvci50c1xudmFyIHNlbGVjdG9yX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNlbGVjdG9yX2V4cG9ydHMsIHtcbiAgZ2V0TDJNZXNzYWdlSGFzaDogKCkgPT4gZ2V0TDJNZXNzYWdlSGFzaCxcbiAgZ2V0U2VsZWN0b3I6ICgpID0+IGdldFNlbGVjdG9yLFxuICBnZXRTZWxlY3RvckZyb21OYW1lOiAoKSA9PiBnZXRTZWxlY3RvckZyb21OYW1lLFxuICBrZWNjYWtCbjogKCkgPT4ga2VjY2FrQm4sXG4gIHNvbGlkaXR5VWludDI1NlBhY2tlZEtlY2NhazI1NjogKCkgPT4gc29saWRpdHlVaW50MjU2UGFja2VkS2VjY2FrMjU2LFxuICBzdGFya25ldEtlY2NhazogKCkgPT4gc3RhcmtuZXRLZWNjYWtcbn0pO1xuaW1wb3J0IHsga2VjY2FrIH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xuaW1wb3J0IHsga2VjY2FrXzI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTNcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiO1xuZnVuY3Rpb24ga2VjY2FrQm4odmFsdWUpIHtcbiAgY29uc3QgaGV4V2l0aG91dFByZWZpeCA9IHJlbW92ZUhleFByZWZpeCh0b0hleChCaWdJbnQodmFsdWUpKSk7XG4gIGNvbnN0IGV2ZW5IZXggPSBoZXhXaXRob3V0UHJlZml4Lmxlbmd0aCAlIDIgPT09IDAgPyBoZXhXaXRob3V0UHJlZml4IDogYDAke2hleFdpdGhvdXRQcmVmaXh9YDtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChrZWNjYWsoaGV4VG9CeXRlcyhhZGRIZXhQcmVmaXgoZXZlbkhleCkpKS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24ga2VjY2FrSGV4KHN0cikge1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGtlY2Nhayh1dGY4VG9BcnJheShzdHIpKS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24gc3RhcmtuZXRLZWNjYWsoc3RyKSB7XG4gIGNvbnN0IGhhc2ggPSBCaWdJbnQoa2VjY2FrSGV4KHN0cikpO1xuICByZXR1cm4gaGFzaCAmIE1BU0tfMjUwO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0b3JGcm9tTmFtZShmdW5jTmFtZSkge1xuICByZXR1cm4gdG9IZXgoc3RhcmtuZXRLZWNjYWsoZnVuY05hbWUpKTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yKHZhbHVlKSB7XG4gIGlmIChpc051bWJlcih2YWx1ZSkgfHwgaXNCaWdJbnQodmFsdWUpKSByZXR1cm4gdG9IZXgodmFsdWUpO1xuICBpZiAoaXNIZXgodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gIGlmIChpc1N0cmluZ1dob2xlTnVtYmVyKHZhbHVlKSkgcmV0dXJuIHRvSGV4KHZhbHVlKTtcbiAgcmV0dXJuIGdldFNlbGVjdG9yRnJvbU5hbWUodmFsdWUpO1xufVxuZnVuY3Rpb24gc29saWRpdHlVaW50MjU2UGFja2VkS2VjY2FrMjU2KHBhcmFtcykge1xuICBjb25zdCBteUVuY29kZSA9IGFkZEhleFByZWZpeChcbiAgICBwYXJhbXMucmVkdWNlKFxuICAgICAgKHJlcywgcGFyKSA9PiByZXMgKyByZW1vdmVIZXhQcmVmaXgodG9IZXgocGFyKSkucGFkU3RhcnQoNjQsIFwiMFwiKSxcbiAgICAgIFwiXCJcbiAgICApXG4gICk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoYnl0ZXNUb0hleChrZWNjYWtfMjU2KGhleFRvQnl0ZXMobXlFbmNvZGUpKSkpO1xufVxuZnVuY3Rpb24gZ2V0TDJNZXNzYWdlSGFzaChsMUZyb21BZGRyZXNzLCBsMlRvQWRkcmVzcywgbDJTZWxlY3RvciwgbDJDYWxsZGF0YSwgbDFOb25jZSkge1xuICByZXR1cm4gc29saWRpdHlVaW50MjU2UGFja2VkS2VjY2FrMjU2KFtcbiAgICBsMUZyb21BZGRyZXNzLFxuICAgIGwyVG9BZGRyZXNzLFxuICAgIGwxTm9uY2UsXG4gICAgbDJTZWxlY3RvcixcbiAgICBsMkNhbGxkYXRhLmxlbmd0aCxcbiAgICAuLi5sMkNhbGxkYXRhXG4gIF0pO1xufVxuXG4vLyBzcmMvdXRpbHMvc2hvcnRTdHJpbmcudHNcbnZhciBzaG9ydFN0cmluZ19leHBvcnRzID0ge307XG5fX2V4cG9ydChzaG9ydFN0cmluZ19leHBvcnRzLCB7XG4gIGRlY29kZVNob3J0U3RyaW5nOiAoKSA9PiBkZWNvZGVTaG9ydFN0cmluZyxcbiAgZW5jb2RlU2hvcnRTdHJpbmc6ICgpID0+IGVuY29kZVNob3J0U3RyaW5nLFxuICBpc0FTQ0lJOiAoKSA9PiBpc0FTQ0lJLFxuICBpc0RlY2ltYWxTdHJpbmc6ICgpID0+IGlzRGVjaW1hbFN0cmluZyxcbiAgaXNMb25nVGV4dDogKCkgPT4gaXNMb25nVGV4dCxcbiAgaXNTaG9ydFN0cmluZzogKCkgPT4gaXNTaG9ydFN0cmluZyxcbiAgaXNTaG9ydFRleHQ6ICgpID0+IGlzU2hvcnRUZXh0LFxuICBpc1RleHQ6ICgpID0+IGlzVGV4dCxcbiAgc3BsaXRMb25nU3RyaW5nOiAoKSA9PiBzcGxpdExvbmdTdHJpbmdcbn0pO1xuZnVuY3Rpb24gaXNBU0NJSShzdHIpIHtcbiAgcmV0dXJuIC9eW1xceDAwLVxceDdGXSokLy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBpc1Nob3J0U3RyaW5nKHN0cikge1xuICByZXR1cm4gc3RyLmxlbmd0aCA8PSBURVhUX1RPX0ZFTFRfTUFYX0xFTjtcbn1cbmZ1bmN0aW9uIGlzRGVjaW1hbFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIC9eWzAtOV0qJC9pLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzVGV4dCh2YWwpIHtcbiAgcmV0dXJuIGlzU3RyaW5nKHZhbCkgJiYgIWlzSGV4KHZhbCkgJiYgIWlzU3RyaW5nV2hvbGVOdW1iZXIodmFsKTtcbn1cbnZhciBpc1Nob3J0VGV4dCA9ICh2YWwpID0+IGlzVGV4dCh2YWwpICYmIGlzU2hvcnRTdHJpbmcodmFsKTtcbnZhciBpc0xvbmdUZXh0ID0gKHZhbCkgPT4gaXNUZXh0KHZhbCkgJiYgIWlzU2hvcnRTdHJpbmcodmFsKTtcbmZ1bmN0aW9uIHNwbGl0TG9uZ1N0cmluZyhsb25nU3RyKSB7XG4gIGNvbnN0IHJlZ2V4ID0gUmVnRXhwKGBbXl17MSwke1RFWFRfVE9fRkVMVF9NQVhfTEVOfX1gLCBcImdcIik7XG4gIHJldHVybiBsb25nU3RyLm1hdGNoKHJlZ2V4KSB8fCBbXTtcbn1cbmZ1bmN0aW9uIGVuY29kZVNob3J0U3RyaW5nKHN0cikge1xuICBpZiAoIWlzQVNDSUkoc3RyKSkgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgbm90IGFuIEFTQ0lJIHN0cmluZ2ApO1xuICBpZiAoIWlzU2hvcnRTdHJpbmcoc3RyKSkgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgdG9vIGxvbmdgKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChzdHIucmVwbGFjZSgvLi9nLCAoY2hhcikgPT4gY2hhci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkpO1xufVxuZnVuY3Rpb24gZGVjb2RlU2hvcnRTdHJpbmcoc3RyKSB7XG4gIGlmICghaXNBU0NJSShzdHIpKSB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyBub3QgYW4gQVNDSUkgc3RyaW5nYCk7XG4gIGlmIChpc0hleChzdHIpKSB7XG4gICAgcmV0dXJuIHJlbW92ZUhleFByZWZpeChzdHIpLnJlcGxhY2UoLy57Mn0vZywgKGhleCkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSkpO1xuICB9XG4gIGlmIChpc0RlY2ltYWxTdHJpbmcoc3RyKSkge1xuICAgIHJldHVybiBkZWNvZGVTaG9ydFN0cmluZyhcIjBYXCIuY29uY2F0KEJpZ0ludChzdHIpLnRvU3RyaW5nKDE2KSkpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIG5vdCBIZXggb3IgZGVjaW1hbGApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvYnl0ZUFycmF5LnRzXG52YXIgYnl0ZUFycmF5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGJ5dGVBcnJheV9leHBvcnRzLCB7XG4gIGJ5dGVBcnJheUZyb21TdHJpbmc6ICgpID0+IGJ5dGVBcnJheUZyb21TdHJpbmcsXG4gIHN0cmluZ0Zyb21CeXRlQXJyYXk6ICgpID0+IHN0cmluZ0Zyb21CeXRlQXJyYXlcbn0pO1xuZnVuY3Rpb24gc3RyaW5nRnJvbUJ5dGVBcnJheShteUJ5dGVBcnJheSkge1xuICBjb25zdCBwZW5kaW5nX3dvcmQgPSBCaWdJbnQobXlCeXRlQXJyYXkucGVuZGluZ193b3JkKSA9PT0gMG4gPyBcIlwiIDogZGVjb2RlU2hvcnRTdHJpbmcodG9IZXgobXlCeXRlQXJyYXkucGVuZGluZ193b3JkKSk7XG4gIHJldHVybiBteUJ5dGVBcnJheS5kYXRhLnJlZHVjZSgoY3VtdWxlZFN0cmluZywgZW5jb2RlZFN0cmluZykgPT4ge1xuICAgIGNvbnN0IGFkZCA9IEJpZ0ludChlbmNvZGVkU3RyaW5nKSA9PT0gMG4gPyBcIlwiIDogZGVjb2RlU2hvcnRTdHJpbmcodG9IZXgoZW5jb2RlZFN0cmluZykpO1xuICAgIHJldHVybiBjdW11bGVkU3RyaW5nICsgYWRkO1xuICB9LCBcIlwiKSArIHBlbmRpbmdfd29yZDtcbn1cbmZ1bmN0aW9uIGJ5dGVBcnJheUZyb21TdHJpbmcodGFyZ2V0U3RyaW5nKSB7XG4gIGNvbnN0IHNob3J0U3RyaW5ncyA9IHNwbGl0TG9uZ1N0cmluZyh0YXJnZXRTdHJpbmcpO1xuICBjb25zdCByZW1haW5kZXIgPSBzaG9ydFN0cmluZ3Nbc2hvcnRTdHJpbmdzLmxlbmd0aCAtIDFdO1xuICBjb25zdCBzaG9ydFN0cmluZ3NFbmNvZGVkID0gc2hvcnRTdHJpbmdzLm1hcChlbmNvZGVTaG9ydFN0cmluZyk7XG4gIGNvbnN0IFtwZW5kaW5nV29yZCwgcGVuZGluZ1dvcmRMZW5ndGhdID0gcmVtYWluZGVyID09PSB2b2lkIDAgfHwgcmVtYWluZGVyLmxlbmd0aCA9PT0gMzEgPyBbXCIweDAwXCIsIDBdIDogW3Nob3J0U3RyaW5nc0VuY29kZWQucG9wKCksIHJlbWFpbmRlci5sZW5ndGhdO1xuICByZXR1cm4ge1xuICAgIGRhdGE6IHNob3J0U3RyaW5nc0VuY29kZWQubGVuZ3RoID09PSAwID8gW10gOiBzaG9ydFN0cmluZ3NFbmNvZGVkLFxuICAgIHBlbmRpbmdfd29yZDogcGVuZGluZ1dvcmQsXG4gICAgcGVuZGluZ193b3JkX2xlbjogcGVuZGluZ1dvcmRMZW5ndGhcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2NhaXJvLnRzXG52YXIgY2Fpcm9fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY2Fpcm9fZXhwb3J0cywge1xuICBmZWx0OiAoKSA9PiBmZWx0LFxuICBnZXRBYmlDb250cmFjdFZlcnNpb246ICgpID0+IGdldEFiaUNvbnRyYWN0VmVyc2lvbixcbiAgZ2V0QXJyYXlUeXBlOiAoKSA9PiBnZXRBcnJheVR5cGUsXG4gIGlzQ2Fpcm8xQWJpOiAoKSA9PiBpc0NhaXJvMUFiaSxcbiAgaXNDYWlybzFUeXBlOiAoKSA9PiBpc0NhaXJvMVR5cGUsXG4gIGlzTGVuOiAoKSA9PiBpc0xlbixcbiAgaXNUeXBlQXJyYXk6ICgpID0+IGlzVHlwZUFycmF5LFxuICBpc1R5cGVCb29sOiAoKSA9PiBpc1R5cGVCb29sLFxuICBpc1R5cGVCeXRlQXJyYXk6ICgpID0+IGlzVHlwZUJ5dGVBcnJheSxcbiAgaXNUeXBlQnl0ZXMzMTogKCkgPT4gaXNUeXBlQnl0ZXMzMSxcbiAgaXNUeXBlQ29udHJhY3RBZGRyZXNzOiAoKSA9PiBpc1R5cGVDb250cmFjdEFkZHJlc3MsXG4gIGlzVHlwZUVudW06ICgpID0+IGlzVHlwZUVudW0sXG4gIGlzVHlwZUV0aEFkZHJlc3M6ICgpID0+IGlzVHlwZUV0aEFkZHJlc3MsXG4gIGlzVHlwZUZlbHQ6ICgpID0+IGlzVHlwZUZlbHQsXG4gIGlzVHlwZUxpdGVyYWw6ICgpID0+IGlzVHlwZUxpdGVyYWwsXG4gIGlzVHlwZU5hbWVkVHVwbGU6ICgpID0+IGlzVHlwZU5hbWVkVHVwbGUsXG4gIGlzVHlwZU5vblplcm86ICgpID0+IGlzVHlwZU5vblplcm8sXG4gIGlzVHlwZU9wdGlvbjogKCkgPT4gaXNUeXBlT3B0aW9uLFxuICBpc1R5cGVSZXN1bHQ6ICgpID0+IGlzVHlwZVJlc3VsdCxcbiAgaXNUeXBlU2VjcDI1NmsxUG9pbnQ6ICgpID0+IGlzVHlwZVNlY3AyNTZrMVBvaW50LFxuICBpc1R5cGVTdHJ1Y3Q6ICgpID0+IGlzVHlwZVN0cnVjdCxcbiAgaXNUeXBlVHVwbGU6ICgpID0+IGlzVHlwZVR1cGxlLFxuICBpc1R5cGVVOTY6ICgpID0+IGlzVHlwZVU5NixcbiAgaXNUeXBlVWludDogKCkgPT4gaXNUeXBlVWludCxcbiAgaXNUeXBlVWludDI1NjogKCkgPT4gaXNUeXBlVWludDI1NixcbiAgdHVwbGU6ICgpID0+IHR1cGxlLFxuICB1aW50MjU2OiAoKSA9PiB1aW50MjU2LFxuICB1aW50NTEyOiAoKSA9PiB1aW50NTEyXG59KTtcblxuLy8gc3JjL3V0aWxzL2NhaXJvRGF0YVR5cGVzL2ZlbHQudHNcbmZ1bmN0aW9uIENhaXJvRmVsdChpdCkge1xuICBpZiAoaXNCaWdJbnQoaXQpIHx8IE51bWJlci5pc0ludGVnZXIoaXQpKSB7XG4gICAgcmV0dXJuIGl0LnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKGlzU3RyaW5nKGl0KSkge1xuICAgIGlmIChpc0hleChpdCkpIHtcbiAgICAgIHJldHVybiBCaWdJbnQoaXQpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc1RleHQoaXQpKSB7XG4gICAgICBpZiAoIWlzU2hvcnRTdHJpbmcoaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtpdH0gaXMgYSBsb25nIHN0cmluZyA+IDMxIGNoYXJzLiBQbGVhc2Ugc3BsaXQgaXQgaW50byBhbiBhcnJheSBvZiBzaG9ydCBzdHJpbmdzLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoaXQpKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcihpdCkpIHtcbiAgICAgIHJldHVybiBpdDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQm9vbGVhbihpdCkpIHtcbiAgICByZXR1cm4gYCR7K2l0fWA7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAke2l0fSBjYW4ndCBiZSBjb21wdXRlZCBieSBmZWx0KClgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhaXJvRGF0YVR5cGVzL3VpbnQyNTYudHNcbnZhciBVSU5UXzEyOF9NQVggPSAoMW4gPDwgMTI4bikgLSAxbjtcbnZhciBVSU5UXzI1Nl9NQVggPSAoMW4gPDwgMjU2bikgLSAxbjtcbnZhciBVSU5UXzI1Nl9NSU4gPSAwbjtcbnZhciBVSU5UXzI1Nl9MT1dfTUFYID0gMzQwMjgyMzY2OTIwOTM4NDYzNDYzMzc0NjA3NDMxNzY4MjExNDU1bjtcbnZhciBVSU5UXzI1Nl9ISUdIX01BWCA9IDM0MDI4MjM2NjkyMDkzODQ2MzQ2MzM3NDYwNzQzMTc2ODIxMTQ1NW47XG52YXIgVUlOVF8yNTZfTE9XX01JTiA9IDBuO1xudmFyIFVJTlRfMjU2X0hJR0hfTUlOID0gMG47XG52YXIgQ2Fpcm9VaW50MjU2ID0gY2xhc3MgX0NhaXJvVWludDI1NiB7XG4gIGxvdztcbiAgaGlnaDtcbiAgc3RhdGljIGFiaVNlbGVjdG9yID0gXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCI7XG4gIGNvbnN0cnVjdG9yKC4uLmFycikge1xuICAgIGlmICh0eXBlb2YgYXJyWzBdID09PSBcIm9iamVjdFwiICYmIGFyci5sZW5ndGggPT09IDEgJiYgXCJsb3dcIiBpbiBhcnJbMF0gJiYgXCJoaWdoXCIgaW4gYXJyWzBdKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IF9DYWlyb1VpbnQyNTYudmFsaWRhdGVQcm9wcyhhcnJbMF0ubG93LCBhcnJbMF0uaGlnaCk7XG4gICAgICB0aGlzLmxvdyA9IHByb3BzLmxvdztcbiAgICAgIHRoaXMuaGlnaCA9IHByb3BzLmhpZ2g7XG4gICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBiaWdJbnQgPSBfQ2Fpcm9VaW50MjU2LnZhbGlkYXRlKGFyclswXSk7XG4gICAgICB0aGlzLmxvdyA9IGJpZ0ludCAmIFVJTlRfMTI4X01BWDtcbiAgICAgIHRoaXMuaGlnaCA9IGJpZ0ludCA+PiAxMjhuO1xuICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgcHJvcHMgPSBfQ2Fpcm9VaW50MjU2LnZhbGlkYXRlUHJvcHMoYXJyWzBdLCBhcnJbMV0pO1xuICAgICAgdGhpcy5sb3cgPSBwcm9wcy5sb3c7XG4gICAgICB0aGlzLmhpZ2ggPSBwcm9wcy5oaWdoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkluY29ycmVjdCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgaWYgQmlnTnVtYmVyaXNoIGNhbiBiZSByZXByZXNlbnRlZCBhcyBVbml0MjU2XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGUoYmlnTnVtYmVyaXNoKSB7XG4gICAgY29uc3QgYmlnSW50ID0gQmlnSW50KGJpZ051bWJlcmlzaCk7XG4gICAgaWYgKGJpZ0ludCA8IFVJTlRfMjU2X01JTikgdGhyb3cgRXJyb3IoXCJiaWdOdW1iZXJpc2ggaXMgc21hbGxlciB0aGFuIFVJTlRfMjU2X01JTlwiKTtcbiAgICBpZiAoYmlnSW50ID4gVUlOVF8yNTZfTUFYKSB0aHJvdyBuZXcgRXJyb3IoXCJiaWdOdW1iZXJpc2ggaXMgYmlnZ2VyIHRoYW4gVUlOVF8yNTZfTUFYXCIpO1xuICAgIHJldHVybiBiaWdJbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGlmIGxvdyBhbmQgaGlnaCBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgVW5pdDI1NlxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlUHJvcHMobG93LCBoaWdoKSB7XG4gICAgY29uc3QgYmlnSW50TG93ID0gQmlnSW50KGxvdyk7XG4gICAgY29uc3QgYmlnSW50SGlnaCA9IEJpZ0ludChoaWdoKTtcbiAgICBpZiAoYmlnSW50TG93IDwgVUlOVF8yNTZfTE9XX01JTiB8fCBiaWdJbnRMb3cgPiBVSU5UXzI1Nl9MT1dfTUFYKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb3cgaXMgb3V0IG9mIHJhbmdlIFVJTlRfMjU2X0xPV19NSU4gLSBVSU5UXzI1Nl9MT1dfTUFYXCIpO1xuICAgIH1cbiAgICBpZiAoYmlnSW50SGlnaCA8IFVJTlRfMjU2X0hJR0hfTUlOIHx8IGJpZ0ludEhpZ2ggPiBVSU5UXzI1Nl9ISUdIX01BWCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGlnaCBpcyBvdXQgb2YgcmFuZ2UgVUlOVF8yNTZfSElHSF9NSU4gLSBVSU5UXzI1Nl9ISUdIX01BWFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbG93OiBiaWdJbnRMb3csIGhpZ2g6IGJpZ0ludEhpZ2ggfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgQmlnTnVtYmVyaXNoIGNhbiBiZSByZXByZXNlbnRlZCBhcyBVbml0MjU2XG4gICAqL1xuICBzdGF0aWMgaXMoYmlnTnVtYmVyaXNoKSB7XG4gICAgdHJ5IHtcbiAgICAgIF9DYWlyb1VpbnQyNTYudmFsaWRhdGUoYmlnTnVtYmVyaXNoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcHJvdmlkZWQgYWJpIHR5cGUgaXMgdGhpcyBkYXRhIHR5cGVcbiAgICovXG4gIHN0YXRpYyBpc0FiaVR5cGUoYWJpVHlwZSkge1xuICAgIHJldHVybiBhYmlUeXBlID09PSBfQ2Fpcm9VaW50MjU2LmFiaVNlbGVjdG9yO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYmlnaW50IHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICB0b0JpZ0ludCgpIHtcbiAgICByZXR1cm4gKHRoaXMuaGlnaCA8PCAxMjhuKSArIHRoaXMubG93O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVWludDI1NiBzdHJ1Y3R1cmUgd2l0aCBIZXhTdHJpbmcgcHJvcHNcbiAgICoge2xvdzogSGV4U3RyaW5nLCBoaWdoOiBIZXhTdHJpbmd9XG4gICAqL1xuICB0b1VpbnQyNTZIZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvdzogYWRkSGV4UHJlZml4KHRoaXMubG93LnRvU3RyaW5nKDE2KSksXG4gICAgICBoaWdoOiBhZGRIZXhQcmVmaXgodGhpcy5oaWdoLnRvU3RyaW5nKDE2KSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVWludDI1NiBzdHJ1Y3R1cmUgd2l0aCBEZWNpbWFsU3RyaW5nIHByb3BzXG4gICAqIHtsb3c6IERlY1N0cmluZywgaGlnaDogRGVjU3RyaW5nfVxuICAgKi9cbiAgdG9VaW50MjU2RGVjaW1hbFN0cmluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG93OiB0aGlzLmxvdy50b1N0cmluZygxMCksXG4gICAgICBoaWdoOiB0aGlzLmhpZ2gudG9TdHJpbmcoMTApXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFwaSByZXF1ZXN0cyByZXByZXNlbnRhdGlvbiB3aXRjaCBpcyBmZWx0IGFycmF5XG4gICAqL1xuICB0b0FwaVJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIFtDYWlyb0ZlbHQodGhpcy5sb3cpLCBDYWlyb0ZlbHQodGhpcy5oaWdoKV07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWlyb0RhdGFUeXBlcy91aW50NTEyLnRzXG52YXIgVUlOVF81MTJfTUFYID0gKDFuIDw8IDUxMm4pIC0gMW47XG52YXIgVUlOVF81MTJfTUlOID0gMG47XG52YXIgVUlOVF8xMjhfTUlOID0gMG47XG52YXIgQ2Fpcm9VaW50NTEyID0gY2xhc3MgX0NhaXJvVWludDUxMiB7XG4gIGxpbWIwO1xuICBsaW1iMTtcbiAgbGltYjI7XG4gIGxpbWIzO1xuICBzdGF0aWMgYWJpU2VsZWN0b3IgPSBcImNvcmU6OmludGVnZXI6OnU1MTJcIjtcbiAgY29uc3RydWN0b3IoLi4uYXJyKSB7XG4gICAgaWYgKHR5cGVvZiBhcnJbMF0gPT09IFwib2JqZWN0XCIgJiYgYXJyLmxlbmd0aCA9PT0gMSAmJiBcImxpbWIwXCIgaW4gYXJyWzBdICYmIFwibGltYjFcIiBpbiBhcnJbMF0gJiYgXCJsaW1iMlwiIGluIGFyclswXSAmJiBcImxpbWIzXCIgaW4gYXJyWzBdKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IF9DYWlyb1VpbnQ1MTIudmFsaWRhdGVQcm9wcyhcbiAgICAgICAgYXJyWzBdLmxpbWIwLFxuICAgICAgICBhcnJbMF0ubGltYjEsXG4gICAgICAgIGFyclswXS5saW1iMixcbiAgICAgICAgYXJyWzBdLmxpbWIzXG4gICAgICApO1xuICAgICAgdGhpcy5saW1iMCA9IHByb3BzLmxpbWIwO1xuICAgICAgdGhpcy5saW1iMSA9IHByb3BzLmxpbWIxO1xuICAgICAgdGhpcy5saW1iMiA9IHByb3BzLmxpbWIyO1xuICAgICAgdGhpcy5saW1iMyA9IHByb3BzLmxpbWIzO1xuICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgYmlnSW50ID0gX0NhaXJvVWludDUxMi52YWxpZGF0ZShhcnJbMF0pO1xuICAgICAgdGhpcy5saW1iMCA9IGJpZ0ludCAmIFVJTlRfMTI4X01BWDtcbiAgICAgIHRoaXMubGltYjEgPSAoYmlnSW50ICYgVUlOVF8xMjhfTUFYIDw8IDEyOG4pID4+IDEyOG47XG4gICAgICB0aGlzLmxpbWIyID0gKGJpZ0ludCAmIFVJTlRfMTI4X01BWCA8PCAyNTZuKSA+PiAyNTZuO1xuICAgICAgdGhpcy5saW1iMyA9IGJpZ0ludCA+PiAzODRuO1xuICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY29uc3QgcHJvcHMgPSBfQ2Fpcm9VaW50NTEyLnZhbGlkYXRlUHJvcHMoYXJyWzBdLCBhcnJbMV0sIGFyclsyXSwgYXJyWzNdKTtcbiAgICAgIHRoaXMubGltYjAgPSBwcm9wcy5saW1iMDtcbiAgICAgIHRoaXMubGltYjEgPSBwcm9wcy5saW1iMTtcbiAgICAgIHRoaXMubGltYjIgPSBwcm9wcy5saW1iMjtcbiAgICAgIHRoaXMubGltYjMgPSBwcm9wcy5saW1iMztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbmNvcnJlY3QgVWludDUxMiBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgaWYgQmlnTnVtYmVyaXNoIGNhbiBiZSByZXByZXNlbnRlZCBhcyBVaW50NTEyXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGUoYmlnTnVtYmVyaXNoKSB7XG4gICAgY29uc3QgYmlnSW50ID0gQmlnSW50KGJpZ051bWJlcmlzaCk7XG4gICAgaWYgKGJpZ0ludCA8IFVJTlRfNTEyX01JTikgdGhyb3cgRXJyb3IoXCJiaWdOdW1iZXJpc2ggaXMgc21hbGxlciB0aGFuIFVJTlRfNTEyX01JTi5cIik7XG4gICAgaWYgKGJpZ0ludCA+IFVJTlRfNTEyX01BWCkgdGhyb3cgRXJyb3IoXCJiaWdOdW1iZXJpc2ggaXMgYmlnZ2VyIHRoYW4gVUlOVF81MTJfTUFYLlwiKTtcbiAgICByZXR1cm4gYmlnSW50O1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBpZiBsaW1icyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgVWludDUxMlxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlUHJvcHMobGltYjAsIGxpbWIxLCBsaW1iMiwgbGltYjMpIHtcbiAgICBjb25zdCBsMCA9IEJpZ0ludChsaW1iMCk7XG4gICAgY29uc3QgbDEgPSBCaWdJbnQobGltYjEpO1xuICAgIGNvbnN0IGwyID0gQmlnSW50KGxpbWIyKTtcbiAgICBjb25zdCBsMyA9IEJpZ0ludChsaW1iMyk7XG4gICAgW2wwLCBsMSwgbDIsIGwzXS5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA8IFVJTlRfMTI4X01JTiB8fCB2YWx1ZSA+IFVJTlRfMTI4X01BWCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgbGltYiR7aW5kZXh9IGlzIG5vdCBpbiB0aGUgcmFuZ2Ugb2YgYSB1MTI4IG51bWJlcmApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7IGxpbWIwOiBsMCwgbGltYjE6IGwxLCBsaW1iMjogbDIsIGxpbWIzOiBsMyB9O1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBCaWdOdW1iZXJpc2ggY2FuIGJlIHJlcHJlc2VudGVkIGFzIFVpbnQ1MTJcbiAgICovXG4gIHN0YXRpYyBpcyhiaWdOdW1iZXJpc2gpIHtcbiAgICB0cnkge1xuICAgICAgX0NhaXJvVWludDUxMi52YWxpZGF0ZShiaWdOdW1iZXJpc2gpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwcm92aWRlZCBhYmkgdHlwZSBpcyB0aGlzIGRhdGEgdHlwZVxuICAgKi9cbiAgc3RhdGljIGlzQWJpVHlwZShhYmlUeXBlKSB7XG4gICAgcmV0dXJuIGFiaVR5cGUgPT09IF9DYWlyb1VpbnQ1MTIuYWJpU2VsZWN0b3I7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBiaWdpbnQgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIHRvQmlnSW50KCkge1xuICAgIHJldHVybiAodGhpcy5saW1iMyA8PCAzODRuKSArICh0aGlzLmxpbWIyIDw8IDI1Nm4pICsgKHRoaXMubGltYjEgPDwgMTI4bikgKyB0aGlzLmxpbWIwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVWludDUxMiBzdHJ1Y3R1cmUgd2l0aCBIZXhTdHJpbmcgcHJvcHNcbiAgICogbGltYng6IEhleFN0cmluZ1xuICAgKi9cbiAgdG9VaW50NTEySGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW1iMDogYWRkSGV4UHJlZml4KHRoaXMubGltYjAudG9TdHJpbmcoMTYpKSxcbiAgICAgIGxpbWIxOiBhZGRIZXhQcmVmaXgodGhpcy5saW1iMS50b1N0cmluZygxNikpLFxuICAgICAgbGltYjI6IGFkZEhleFByZWZpeCh0aGlzLmxpbWIyLnRvU3RyaW5nKDE2KSksXG4gICAgICBsaW1iMzogYWRkSGV4UHJlZml4KHRoaXMubGltYjMudG9TdHJpbmcoMTYpKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBVaW50NTEyIHN0cnVjdHVyZSB3aXRoIERlY2ltYWxTdHJpbmcgcHJvcHNcbiAgICogbGltYnggRGVjU3RyaW5nXG4gICAqL1xuICB0b1VpbnQ1MTJEZWNpbWFsU3RyaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW1iMDogdGhpcy5saW1iMC50b1N0cmluZygxMCksXG4gICAgICBsaW1iMTogdGhpcy5saW1iMS50b1N0cmluZygxMCksXG4gICAgICBsaW1iMjogdGhpcy5saW1iMi50b1N0cmluZygxMCksXG4gICAgICBsaW1iMzogdGhpcy5saW1iMy50b1N0cmluZygxMClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYXBpIHJlcXVlc3RzIHJlcHJlc2VudGF0aW9uIHdpdGNoIGlzIGZlbHQgYXJyYXlcbiAgICovXG4gIHRvQXBpUmVxdWVzdCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgQ2Fpcm9GZWx0KHRoaXMubGltYjApLFxuICAgICAgQ2Fpcm9GZWx0KHRoaXMubGltYjEpLFxuICAgICAgQ2Fpcm9GZWx0KHRoaXMubGltYjIpLFxuICAgICAgQ2Fpcm9GZWx0KHRoaXMubGltYjMpXG4gICAgXTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2NhaXJvLnRzXG52YXIgaXNMZW4gPSAobmFtZSkgPT4gL19sZW4kLy50ZXN0KG5hbWUpO1xudmFyIGlzVHlwZUZlbHQgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJmZWx0XCIgfHwgdHlwZSA9PT0gXCJjb3JlOjpmZWx0MjUyXCI7XG52YXIgaXNUeXBlQXJyYXkgPSAodHlwZSkgPT4gL1xcKi8udGVzdCh0eXBlKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6QXJyYXk6OlwiKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6U3Bhbjo6XCIpO1xudmFyIGlzVHlwZVR1cGxlID0gKHR5cGUpID0+IC9eXFwoLipcXCkkL2kudGVzdCh0eXBlKTtcbnZhciBpc1R5cGVOYW1lZFR1cGxlID0gKHR5cGUpID0+IC9cXCguKlxcKS9pLnRlc3QodHlwZSkgJiYgdHlwZS5pbmNsdWRlcyhcIjpcIik7XG52YXIgaXNUeXBlU3RydWN0ID0gKHR5cGUsIHN0cnVjdHMpID0+IHR5cGUgaW4gc3RydWN0cztcbnZhciBpc1R5cGVFbnVtID0gKHR5cGUsIGVudW1zKSA9PiB0eXBlIGluIGVudW1zO1xudmFyIGlzVHlwZU9wdGlvbiA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpvcHRpb246Ok9wdGlvbjo6XCIpO1xudmFyIGlzVHlwZVJlc3VsdCA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdDo6XCIpO1xudmFyIGlzVHlwZVVpbnQgPSAodHlwZSkgPT4gT2JqZWN0LnZhbHVlcyhVaW50KS5pbmNsdWRlcyh0eXBlKTtcbnZhciBpc1R5cGVVaW50MjU2ID0gKHR5cGUpID0+IENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSk7XG52YXIgaXNUeXBlTGl0ZXJhbCA9ICh0eXBlKSA9PiBPYmplY3QudmFsdWVzKExpdGVyYWwpLmluY2x1ZGVzKHR5cGUpO1xudmFyIGlzVHlwZUJvb2wgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpib29sXCI7XG52YXIgaXNUeXBlQ29udHJhY3RBZGRyZXNzID0gKHR5cGUpID0+IHR5cGUgPT09IExpdGVyYWwuQ29udHJhY3RBZGRyZXNzO1xudmFyIGlzVHlwZUV0aEFkZHJlc3MgPSAodHlwZSkgPT4gdHlwZSA9PT0gRVRIX0FERFJFU1M7XG52YXIgaXNUeXBlQnl0ZXMzMSA9ICh0eXBlKSA9PiB0eXBlID09PSBcImNvcmU6OmJ5dGVzXzMxOjpieXRlczMxXCI7XG52YXIgaXNUeXBlQnl0ZUFycmF5ID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6Ynl0ZV9hcnJheTo6Qnl0ZUFycmF5XCI7XG52YXIgaXNUeXBlVTk2ID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6aW50ZXJuYWw6OmJvdW5kZWRfaW50OjpCb3VuZGVkSW50Ojo8MCwgNzkyMjgxNjI1MTQyNjQzMzc1OTM1NDM5NTAzMzU+XCI7XG52YXIgaXNUeXBlU2VjcDI1NmsxUG9pbnQgPSAodHlwZSkgPT4gdHlwZSA9PT0gTGl0ZXJhbC5TZWNwMjU2azFQb2ludDtcbnZhciBpc0NhaXJvMVR5cGUgPSAodHlwZSkgPT4gdHlwZS5pbmNsdWRlcyhcIjo6XCIpO1xudmFyIGdldEFycmF5VHlwZSA9ICh0eXBlKSA9PiB7XG4gIHJldHVybiBpc0NhaXJvMVR5cGUodHlwZSkgPyB0eXBlLnN1YnN0cmluZyh0eXBlLmluZGV4T2YoXCI8XCIpICsgMSwgdHlwZS5sYXN0SW5kZXhPZihcIj5cIikpIDogdHlwZS5yZXBsYWNlKFwiKlwiLCBcIlwiKTtcbn07XG5mdW5jdGlvbiBpc0NhaXJvMUFiaShhYmkpIHtcbiAgY29uc3QgeyBjYWlybyB9ID0gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGFiaSk7XG4gIGlmIChjYWlybyA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZGV0ZXJtaW5lIENhaXJvIHZlcnNpb25cIik7XG4gIH1cbiAgcmV0dXJuIGNhaXJvID09PSBcIjFcIjtcbn1cbmZ1bmN0aW9uIGlzVHlwZU5vblplcm8odHlwZSkge1xuICByZXR1cm4gdHlwZS5zdGFydHNXaXRoKE5PTl9aRVJPX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBnZXRBYmlDb250cmFjdFZlcnNpb24oYWJpKSB7XG4gIGlmIChhYmkuZmluZCgoaXQpID0+IGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpKSB7XG4gICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogXCIyXCIgfTtcbiAgfVxuICBjb25zdCB0ZXN0U3ViamVjdCA9IGFiaS5maW5kKFxuICAgIChpdCkgPT4gKGl0LnR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBpdC50eXBlID09PSBcImNvbnN0cnVjdG9yXCIpICYmIChpdC5pbnB1dHMubGVuZ3RoIHx8IGl0Lm91dHB1dHMubGVuZ3RoKVxuICApO1xuICBpZiAoIXRlc3RTdWJqZWN0KSB7XG4gICAgcmV0dXJuIHsgY2Fpcm86IHZvaWQgMCwgY29tcGlsZXI6IHZvaWQgMCB9O1xuICB9XG4gIGNvbnN0IGlvID0gdGVzdFN1YmplY3QuaW5wdXRzLmxlbmd0aCA/IHRlc3RTdWJqZWN0LmlucHV0cyA6IHRlc3RTdWJqZWN0Lm91dHB1dHM7XG4gIGlmIChpc0NhaXJvMVR5cGUoaW9bMF0udHlwZSkpIHtcbiAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiBcIjFcIiB9O1xuICB9XG4gIHJldHVybiB7IGNhaXJvOiBcIjBcIiwgY29tcGlsZXI6IFwiMFwiIH07XG59XG52YXIgdWludDI1NiA9IChpdCkgPT4ge1xuICByZXR1cm4gbmV3IENhaXJvVWludDI1NihpdCkudG9VaW50MjU2RGVjaW1hbFN0cmluZygpO1xufTtcbnZhciB1aW50NTEyID0gKGl0KSA9PiB7XG4gIHJldHVybiBuZXcgQ2Fpcm9VaW50NTEyKGl0KS50b1VpbnQ1MTJEZWNpbWFsU3RyaW5nKCk7XG59O1xudmFyIHR1cGxlID0gKC4uLmFyZ3MpID0+ICh7IC4uLmFyZ3MgfSk7XG5mdW5jdGlvbiBmZWx0KGl0KSB7XG4gIHJldHVybiBDYWlyb0ZlbHQoaXQpO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZW51bS9DYWlyb0N1c3RvbUVudW0udHNcbnZhciBDYWlyb0N1c3RvbUVudW0gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBkaXJlY3QgcmVhZG9ubHkgYWNjZXNzIHRvIHZhcmlhbnRzIG9mIHRoZSBDYWlybyBDdXN0b20gRW51bS5cbiAgICogQHJldHVybnMgYSB2YWx1ZSBvZiB0eXBlIGFueVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHN1Y2Nlc3NWYWx1ZSA9IG15Q2Fpcm9FbnVtLnZhcmlhbnQuU3VjY2VzcztcbiAgICovXG4gIHZhcmlhbnQ7XG4gIC8qKlxuICAgKiBAcGFyYW0gZW51bUNvbnRlbnQgYW4gb2JqZWN0IHdpdGggdGhlIHZhcmlhbnRzIGFzIGtleXMgYW5kIHRoZSBjb250ZW50IGFzIHZhbHVlLiBPbmx5IG9uZSBjb250ZW50IHNoYWxsIGJlIGRlZmluZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbnVtQ29udGVudCkge1xuICAgIGNvbnN0IHZhcmlhbnRzTGlzdCA9IE9iamVjdC52YWx1ZXMoZW51bUNvbnRlbnQpO1xuICAgIGlmICh2YXJpYW50c0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEVudW0gbXVzdCBoYXZlIGF0IGxlYXN0IDEgdmFyaWFudFwiKTtcbiAgICB9XG4gICAgY29uc3QgbmJBY3RpdmVWYXJpYW50cyA9IHZhcmlhbnRzTGlzdC5maWx0ZXIoKGNvbnRlbnQpID0+ICFpc1VuZGVmaW5lZChjb250ZW50KSkubGVuZ3RoO1xuICAgIGlmIChuYkFjdGl2ZVZhcmlhbnRzICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEVudW0gbXVzdCBoYXZlIGV4YWN0bHkgb25lIGFjdGl2ZSB2YXJpYW50XCIpO1xuICAgIH1cbiAgICB0aGlzLnZhcmlhbnQgPSBlbnVtQ29udGVudDtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBjdXN0b20gRW51bS5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC52YWx1ZXModGhpcy52YXJpYW50KTtcbiAgICByZXR1cm4gdmFyaWFudHMuZmluZCgoaXRlbSkgPT4gIWlzVW5kZWZpbmVkKGl0ZW0pKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBjdXN0b20gRW51bS5cbiAgICovXG4gIGFjdGl2ZVZhcmlhbnQoKSB7XG4gICAgY29uc3QgdmFyaWFudHMgPSBPYmplY3QuZW50cmllcyh0aGlzLnZhcmlhbnQpO1xuICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kKChpdGVtKSA9PiAhaXNVbmRlZmluZWQoaXRlbVsxXSkpO1xuICAgIHJldHVybiBpc1VuZGVmaW5lZChhY3RpdmVWYXJpYW50KSA/IFwiXCIgOiBhY3RpdmVWYXJpYW50WzBdO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZW51bS9DYWlyb09wdGlvbi50c1xudmFyIENhaXJvT3B0aW9uVmFyaWFudCA9IHtcbiAgU29tZTogMCxcbiAgTm9uZTogMVxufTtcbnZhciBDYWlyb09wdGlvbiA9IGNsYXNzIHtcbiAgU29tZTtcbiAgTm9uZTtcbiAgY29uc3RydWN0b3IodmFyaWFudCwgY29udGVudCkge1xuICAgIGlmICghKHZhcmlhbnQgaW4gT2JqZWN0LnZhbHVlcyhDYWlyb09wdGlvblZhcmlhbnQpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgdmFyaWFudCEgSXQgc2hvdWxkIGJlIENhaXJvT3B0aW9uVmFyaWFudC5Tb21lIG9yIC5Ob25lLlwiKTtcbiAgICB9XG4gICAgaWYgKHZhcmlhbnQgPT09IENhaXJvT3B0aW9uVmFyaWFudC5Tb21lKSB7XG4gICAgICBpZiAoaXNVbmRlZmluZWQoY29udGVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgY3JlYXRpb24gb2YgYSBDYWlybyBPcHRpb24gd2l0aCBcIlNvbWVcIiB2YXJpYW50IG5lZWRzIGEgY29udGVudCBhcyBpbnB1dC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLlNvbWUgPSBjb250ZW50O1xuICAgICAgdGhpcy5Ob25lID0gdm9pZCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLlNvbWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLk5vbmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBjdXN0b20gRW51bS5cbiAgICogIElmIE5vbmUsIHJldHVybnMgJ3VuZGVmaW5lZCcuXG4gICAqL1xuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuTm9uZSA/IHZvaWQgMCA6IHRoaXMuU29tZTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsaWQgdmFyaWFudCBpcyAnaXNTb21lJy5cbiAgICovXG4gIGlzU29tZSgpIHtcbiAgICByZXR1cm4gIWlzVW5kZWZpbmVkKHRoaXMuU29tZSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzTm9uZScuXG4gICAqL1xuICBpc05vbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuTm9uZSA9PT0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2VudW0vQ2Fpcm9SZXN1bHQudHNcbnZhciBDYWlyb1Jlc3VsdFZhcmlhbnQgPSB7XG4gIE9rOiAwLFxuICBFcnI6IDFcbn07XG52YXIgQ2Fpcm9SZXN1bHQgPSBjbGFzcyB7XG4gIE9rO1xuICBFcnI7XG4gIGNvbnN0cnVjdG9yKHZhcmlhbnQsIHJlc3VsdENvbnRlbnQpIHtcbiAgICBpZiAoISh2YXJpYW50IGluIE9iamVjdC52YWx1ZXMoQ2Fpcm9SZXN1bHRWYXJpYW50KSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIHZhcmlhbnQhIEl0IHNob3VsZCBiZSBDYWlyb1Jlc3VsdFZhcmlhbnQuT2sgb3IgLkVyci5cIik7XG4gICAgfVxuICAgIGlmICh2YXJpYW50ID09PSBDYWlyb1Jlc3VsdFZhcmlhbnQuT2spIHtcbiAgICAgIHRoaXMuT2sgPSByZXN1bHRDb250ZW50O1xuICAgICAgdGhpcy5FcnIgPSB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuT2sgPSB2b2lkIDA7XG4gICAgICB0aGlzLkVyciA9IHJlc3VsdENvbnRlbnQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIFJlc3VsdC5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuT2spKSB7XG4gICAgICByZXR1cm4gdGhpcy5PaztcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLkVycikpIHtcbiAgICAgIHJldHVybiB0aGlzLkVycjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBSZXN1bHQuT2sgYW5kIC5FcnIgYXJlIHVuZGVmaW5lZC4gTm90IGF1dGhvcml6ZWQuXCIpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdPaycuXG4gICAqL1xuICBpc09rKCkge1xuICAgIHJldHVybiAhaXNVbmRlZmluZWQodGhpcy5Payk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzRXJyJy5cbiAgICovXG4gIGlzRXJyKCkge1xuICAgIHJldHVybiAhaXNVbmRlZmluZWQodGhpcy5FcnIpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZm9ybWF0dGVyLnRzXG52YXIgZ3VhcmQgPSB7XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGRhdGEgaXMgYSBCaWdJbnQgKEJOKSBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGtleSB0byBjaGVjay5cbiAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSB0eXBlIC0gVGhlIHR5cGUgZGVmaW5pdGlvbiBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IGluIHRoZSBkYXRhIG9iamVjdCB0byBjaGVjay5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkYXRhIHR5cGUgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIEJpZ0ludCAoQk4pIHR5cGUuXG4gICAqL1xuICBpc0JOOiAoZGF0YSwgdHlwZSwga2V5KSA9PiB7XG4gICAgaWYgKCFpc0JpZ0ludChkYXRhW2tleV0pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRGF0YSBhbmQgZm9ybWF0dGVyIG1pc21hdGNoIG9uICR7a2V5fToke3R5cGVba2V5XX0sIGV4cGVjdGVkIHJlc3BvbnNlIGRhdGEgJHtrZXl9OiR7ZGF0YVtrZXldfSB0byBiZSBCTiBpbnN0ZWFkIGl0IGlzICR7dHlwZW9mIGRhdGFba2V5XX1gXG4gICAgICApO1xuICB9LFxuICAvKipcbiAgICogVGhyb3dzIGFuIGVycm9yIGZvciB1bmhhbmRsZWQgZm9ybWF0dGVyIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUga2V5LlxuICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IHR5cGUgLSBUaGUgdHlwZSBkZWZpbml0aW9uIG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgaW4gdGhlIGRhdGEgb2JqZWN0IHRvIGNoZWNrLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZvcm1hdHRlciBlbmNvdW50ZXJzIGFuIHVua25vd24gdHlwZS5cbiAgICovXG4gIHVua25vd246IChkYXRhLCB0eXBlLCBrZXkpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBmb3JtYXR0ZXIgdHlwZSBvbiAke2tleX06JHt0eXBlW2tleV19IGZvciBkYXRhICR7a2V5fToke2RhdGFba2V5XX1gKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZvcm1hdHRlcihkYXRhLCB0eXBlLCBzYW1lVHlwZSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKFxuICAgIChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgY29uc3QgZWxUeXBlID0gc2FtZVR5cGUgPz8gdHlwZVtrZXldO1xuICAgICAgaWYgKCEoa2V5IGluIHR5cGUpICYmICFzYW1lVHlwZSkge1xuICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKGVsVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleV0pKSB7XG4gICAgICAgICAgY29uc3QgYXJyYXlTdHIgPSBmb3JtYXR0ZXIoXG4gICAgICAgICAgICBkYXRhW2tleV0sXG4gICAgICAgICAgICBkYXRhW2tleV0ubWFwKChfKSA9PiBlbFR5cGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhY2Nba2V5XSA9IE9iamVjdC52YWx1ZXMoYXJyYXlTdHIpLmpvaW4oXCJcIik7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfVxuICAgICAgICBndWFyZC5pc0JOKGRhdGEsIHR5cGUsIGtleSk7XG4gICAgICAgIGFjY1trZXldID0gZGVjb2RlU2hvcnRTdHJpbmcodmFsdWUpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKGVsVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBndWFyZC5pc0JOKGRhdGEsIHR5cGUsIGtleSk7XG4gICAgICAgIGFjY1trZXldID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZWxUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYWNjW2tleV0gPSBlbFR5cGUodmFsdWUpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxUeXBlKSkge1xuICAgICAgICBjb25zdCBhcnJheU9iaiA9IGZvcm1hdHRlcihkYXRhW2tleV0sIGVsVHlwZSwgZWxUeXBlWzBdKTtcbiAgICAgICAgYWNjW2tleV0gPSBPYmplY3QudmFsdWVzKGFycmF5T2JqKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdChlbFR5cGUpKSB7XG4gICAgICAgIGFjY1trZXldID0gZm9ybWF0dGVyKGRhdGFba2V5XSwgZWxUeXBlKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGd1YXJkLnVua25vd24oZGF0YSwgdHlwZSwga2V5KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICB7fVxuICApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcGFyc2VyL3BhcnNlci0wLTEuMS4wLnRzXG52YXIgQWJpUGFyc2VyMSA9IGNsYXNzIHtcbiAgYWJpO1xuICBjb25zdHJ1Y3RvcihhYmkpIHtcbiAgICB0aGlzLmFiaSA9IGFiaTtcbiAgfVxuICAvKipcbiAgICogYWJpIG1ldGhvZCBpbnB1dHMgbGVuZ3RoIHdpdGhvdXQgJ19sZW4nIGlucHV0c1xuICAgKiBjYWlybyAwIHJlZHVjZXJcbiAgICogQHBhcmFtIGFiaU1ldGhvZCBGdW5jdGlvbkFiaVxuICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICovXG4gIG1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpIHtcbiAgICByZXR1cm4gYWJpTWV0aG9kLmlucHV0cy5yZWR1Y2UoKGFjYywgaW5wdXQpID0+ICFpc0xlbihpbnB1dC5uYW1lKSA/IGFjYyArIDEgOiBhY2MsIDApO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgbWV0aG9kIGRlZmluaXRpb24gZnJvbSBhYmlcbiAgICogQHBhcmFtIG5hbWUgc3RyaW5nXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uQWJpIHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRNZXRob2QobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFiaS5maW5kKChpdCkgPT4gaXQubmFtZSA9PT0gbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBBYmkgaW4gbGVnYWN5IGZvcm1hdFxuICAgKiBAcmV0dXJucyBBYmlcbiAgICovXG4gIGdldExlZ2FjeUZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYmk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvcGFyc2VyLTIuMC4wLnRzXG52YXIgQWJpUGFyc2VyMiA9IGNsYXNzIHtcbiAgYWJpO1xuICBjb25zdHJ1Y3RvcihhYmkpIHtcbiAgICB0aGlzLmFiaSA9IGFiaTtcbiAgfVxuICAvKipcbiAgICogYWJpIG1ldGhvZCBpbnB1dHMgbGVuZ3RoXG4gICAqIEBwYXJhbSBhYmlNZXRob2QgRnVuY3Rpb25BYmlcbiAgICogQHJldHVybnMgbnVtYmVyXG4gICAqL1xuICBtZXRob2RJbnB1dHNMZW5ndGgoYWJpTWV0aG9kKSB7XG4gICAgcmV0dXJuIGFiaU1ldGhvZC5pbnB1dHMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgbWV0aG9kIGRlZmluaXRpb24gZnJvbSBhYmlcbiAgICogQHBhcmFtIG5hbWUgc3RyaW5nXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uQWJpIHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRNZXRob2QobmFtZSkge1xuICAgIGNvbnN0IGludGYgPSB0aGlzLmFiaS5maW5kKFxuICAgICAgKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiXG4gICAgKTtcbiAgICByZXR1cm4gaW50Zj8uaXRlbXM/LmZpbmQoKGl0KSA9PiBpdC5uYW1lID09PSBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IEFiaSBpbiBsZWdhY3kgZm9ybWF0XG4gICAqIEByZXR1cm5zIEFiaVxuICAgKi9cbiAgZ2V0TGVnYWN5Rm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmFiaS5mbGF0TWFwKChpdCkgPT4ge1xuICAgICAgcmV0dXJuIGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCIgPyBpdC5pdGVtcyA6IGl0O1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcGFyc2VyL2luZGV4LnRzXG5mdW5jdGlvbiBjcmVhdGVBYmlQYXJzZXIoYWJpKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBnZXRBYmlWZXJzaW9uKGFiaSk7XG4gIGlmICh2ZXJzaW9uID09PSAwIHx8IHZlcnNpb24gPT09IDEpIHtcbiAgICByZXR1cm4gbmV3IEFiaVBhcnNlcjEoYWJpKTtcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gMikge1xuICAgIHJldHVybiBuZXcgQWJpUGFyc2VyMihhYmkpO1xuICB9XG4gIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBBQkkgdmVyc2lvbiAke3ZlcnNpb259YCk7XG59XG5mdW5jdGlvbiBnZXRBYmlWZXJzaW9uKGFiaSkge1xuICBpZiAoYWJpLmZpbmQoKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiKSkgcmV0dXJuIDI7XG4gIGlmIChpc0NhaXJvMUFiaShhYmkpKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc05vQ29uc3RydWN0b3JWYWxpZChtZXRob2QsIGFyZ3NDYWxsZGF0YSwgYWJpTWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgPT09IFwiY29uc3RydWN0b3JcIiAmJiAhYWJpTWV0aG9kICYmICFhcmdzQ2FsbGRhdGEubGVuZ3RoO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvdHVwbGUudHNcbmZ1bmN0aW9uIHBhcnNlTmFtZWRUdXBsZShuYW1lZFR1cGxlKSB7XG4gIGNvbnN0IG5hbWUgPSBuYW1lZFR1cGxlLnN1YnN0cmluZygwLCBuYW1lZFR1cGxlLmluZGV4T2YoXCI6XCIpKTtcbiAgY29uc3QgdHlwZSA9IG5hbWVkVHVwbGUuc3Vic3RyaW5nKG5hbWUubGVuZ3RoICsgXCI6XCIubGVuZ3RoKTtcbiAgcmV0dXJuIHsgbmFtZSwgdHlwZSB9O1xufVxuZnVuY3Rpb24gcGFyc2VTdWJUdXBsZShzKSB7XG4gIGlmICghcy5pbmNsdWRlcyhcIihcIikpIHJldHVybiB7IHN1YlR1cGxlOiBbXSwgcmVzdWx0OiBzIH07XG4gIGNvbnN0IHN1YlR1cGxlID0gW107XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICBpZiAoc1tpXSA9PT0gXCIoXCIpIHtcbiAgICAgIGxldCBjb3VudGVyID0gMTtcbiAgICAgIGNvbnN0IGxCcmFja2V0ID0gaTtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjb3VudGVyKSB7XG4gICAgICAgIGlmIChzW2ldID09PSBcIilcIikgY291bnRlci0tO1xuICAgICAgICBpZiAoc1tpXSA9PT0gXCIoXCIpIGNvdW50ZXIrKztcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgc3ViVHVwbGUucHVzaChzLnN1YnN0cmluZyhsQnJhY2tldCwgaSkpO1xuICAgICAgcmVzdWx0ICs9IFwiIFwiO1xuICAgICAgaS0tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gc1tpXTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3ViVHVwbGUsXG4gICAgcmVzdWx0XG4gIH07XG59XG5mdW5jdGlvbiBleHRyYWN0Q2Fpcm8wVHVwbGUodHlwZSkge1xuICBjb25zdCBjbGVhblR5cGUgPSB0eXBlLnJlcGxhY2UoL1xccy9nLCBcIlwiKS5zbGljZSgxLCAtMSk7XG4gIGNvbnN0IHsgc3ViVHVwbGUsIHJlc3VsdCB9ID0gcGFyc2VTdWJUdXBsZShjbGVhblR5cGUpO1xuICBsZXQgcmVjb21wb3NlZCA9IHJlc3VsdC5zcGxpdChcIixcIikubWFwKChpdCkgPT4ge1xuICAgIHJldHVybiBzdWJUdXBsZS5sZW5ndGggPyBpdC5yZXBsYWNlKFwiIFwiLCBzdWJUdXBsZS5zaGlmdCgpKSA6IGl0O1xuICB9KTtcbiAgaWYgKGlzVHlwZU5hbWVkVHVwbGUodHlwZSkpIHtcbiAgICByZWNvbXBvc2VkID0gcmVjb21wb3NlZC5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlTmFtZWRUdXBsZShpdCkpO1xuICAgIH0sIFtdKTtcbiAgfVxuICByZXR1cm4gcmVjb21wb3NlZDtcbn1cbmZ1bmN0aW9uIGdldENsb3N1cmVPZmZzZXQoaW5wdXQsIG9wZW4sIGNsb3NlKSB7XG4gIGZvciAobGV0IGkgPSAwLCBjb3VudGVyID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlucHV0W2ldID09PSBvcGVuKSB7XG4gICAgICBjb3VudGVyKys7XG4gICAgfSBlbHNlIGlmIChpbnB1dFtpXSA9PT0gY2xvc2UgJiYgLS1jb3VudGVyID09PSAwKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDYWlybzFUdXBsZSh0eXBlKSB7XG4gIGNvbnN0IGlucHV0ID0gdHlwZS5zbGljZSgxLCAtMSk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgbGV0IGxpbWl0SW5kZXg7XG4gIHdoaWxlIChjdXJyZW50SW5kZXggPCBpbnB1dC5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIC8vIFR1cGxlXG4gICAgICBjYXNlIGlucHV0W2N1cnJlbnRJbmRleF0gPT09IFwiKFwiOiB7XG4gICAgICAgIGxpbWl0SW5kZXggPSBjdXJyZW50SW5kZXggKyBnZXRDbG9zdXJlT2Zmc2V0KGlucHV0LnNsaWNlKGN1cnJlbnRJbmRleCksIFwiKFwiLCBcIilcIikgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgKGlucHV0LnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdDo6PFwiLCBjdXJyZW50SW5kZXgpIHx8IGlucHV0LnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6QXJyYXk6OjxcIiwgY3VycmVudEluZGV4KSB8fCBpbnB1dC5zdGFydHNXaXRoKFwiY29yZTo6b3B0aW9uOjpPcHRpb246OjxcIiwgY3VycmVudEluZGV4KSk6IHtcbiAgICAgICAgbGltaXRJbmRleCA9IGN1cnJlbnRJbmRleCArIGdldENsb3N1cmVPZmZzZXQoaW5wdXQuc2xpY2UoY3VycmVudEluZGV4KSwgXCI8XCIsIFwiPlwiKSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBjb21tYUluZGV4ID0gaW5wdXQuaW5kZXhPZihcIixcIiwgY3VycmVudEluZGV4KTtcbiAgICAgICAgbGltaXRJbmRleCA9IGNvbW1hSW5kZXggIT09IC0xID8gY29tbWFJbmRleCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2goaW5wdXQuc2xpY2UoY3VycmVudEluZGV4LCBsaW1pdEluZGV4KSk7XG4gICAgY3VycmVudEluZGV4ID0gbGltaXRJbmRleCArIDI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKHR5cGUpIHtcbiAgcmV0dXJuIGlzQ2Fpcm8xVHlwZSh0eXBlKSA/IGV4dHJhY3RDYWlybzFUdXBsZSh0eXBlKSA6IGV4dHJhY3RDYWlybzBUdXBsZSh0eXBlKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhaXJvRGF0YVR5cGVzL2ZpeGVkQXJyYXkudHNcbnZhciBDYWlyb0ZpeGVkQXJyYXkgPSBjbGFzcyBfQ2Fpcm9GaXhlZEFycmF5IHtcbiAgLyoqXG4gICAqIEpTIGFycmF5IHJlcHJlc2VudGluZyBhIENhaXJvIGZpeGVkIGFycmF5LlxuICAgKi9cbiAgY29udGVudDtcbiAgLyoqXG4gICAqIENhaXJvIGZpeGVkIGFycmF5IHR5cGUuXG4gICAqL1xuICBhcnJheVR5cGU7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2UgcmVwcmVzZW50aW5nIGEgQ2Fpcm8gZml4ZWQgQXJyYXkuXG4gICAqIEBwYXJhbSB7YW55W119IGNvbnRlbnQgSlMgYXJyYXkgcmVwcmVzZW50aW5nIGEgQ2Fpcm8gZml4ZWQgYXJyYXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcnJheVR5cGUgQ2Fpcm8gZml4ZWQgYXJyYXkgdHlwZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRlbnQsIGFycmF5VHlwZSkge1xuICAgIGFzc2VydChcbiAgICAgIF9DYWlyb0ZpeGVkQXJyYXkuaXNUeXBlRml4ZWRBcnJheShhcnJheVR5cGUpLFxuICAgICAgYFRoZSB0eXBlICR7YXJyYXlUeXBlfSBpcyBub3QgYSBDYWlybyBmaXhlZCBhcnJheS4gTmVlZHMgW3R5cGU7IGxlbmd0aF0uYFxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIF9DYWlyb0ZpeGVkQXJyYXkuZ2V0Rml4ZWRBcnJheVR5cGUoYXJyYXlUeXBlKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZSB0eXBlICR7YXJyYXlUeXBlfSBkbyBub3QgaW5jbHVkZXMgYW55IGNvbnRlbnQgdHlwZS4gTmVlZHMgW3R5cGU7IGxlbmd0aF0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIF9DYWlyb0ZpeGVkQXJyYXkuZ2V0Rml4ZWRBcnJheVNpemUoYXJyYXlUeXBlKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZSB0eXBlICR7YXJyYXlUeXBlfSB0eXBlIGRvIG5vdCBpbmNsdWRlcyBhbnkgbGVuZ3RoLiBOZWVkcyBbdHlwZTsgbGVuZ3RoXS5gXG4gICAgICApO1xuICAgIH1cbiAgICBhc3NlcnQoXG4gICAgICBfQ2Fpcm9GaXhlZEFycmF5LmdldEZpeGVkQXJyYXlTaXplKGFycmF5VHlwZSkgPT09IGNvbnRlbnQubGVuZ3RoLFxuICAgICAgYFRoZSBBQkkgdHlwZSAke2FycmF5VHlwZX0gaXMgZXhwZWN0aW5nICR7X0NhaXJvRml4ZWRBcnJheS5nZXRGaXhlZEFycmF5U2l6ZShhcnJheVR5cGUpfSBpdGVtcy4gJHtjb250ZW50Lmxlbmd0aH0gaXRlbXMgcHJvdmlkZWQuYFxuICAgICk7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLmFycmF5VHlwZSA9IGFycmF5VHlwZTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBhcnJheSBzaXplIGZyb20gdGhlIGdpdmVuIHR5cGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIENhaXJvIGZpeGVkIGFycmF5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBDYWlybyBmaXhlZCBhcnJheSB0eXBlLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgYXJyYXkgc2l6ZS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQgPSBDYWlyb0ZpeGVkQXJyYXkuZ2V0Rml4ZWRBcnJheVNpemUoXCJbY29yZTo6aW50ZWdlcjo6dTMyOyA4XVwiKTtcbiAgICogLy8gcmVzdWx0ID0gOFxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBnZXRGaXhlZEFycmF5U2l6ZSh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2hBcnJheSA9IHR5cGUubWF0Y2goLyg/PD07IClcXGQrKD89XFxdKS8pO1xuICAgIGlmIChtYXRjaEFycmF5ID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBQkkgdHlwZSAke3R5cGV9IGRvIG5vdCBpbmNsdWRlcyBhIHZhbGlkIG51bWJlciBhZnRlciAnOycgY2hhcmFjdGVyLmApO1xuICAgIHJldHVybiBOdW1iZXIobWF0Y2hBcnJheVswXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgQ2Fpcm8gZml4ZWQgYXJyYXkgc2l6ZSBmcm9tIHRoZSBDYWlyb0ZpeGVkQXJyYXkgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBmaXhlZCBhcnJheSBzaXplLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGZBcnJheSA9IG5ldyBDYWlyb0ZpeGVkQXJyYXkoWzEwLDIwLDMwXSwgXCJbY29yZTo6aW50ZWdlcjo6dTMyOyAzXVwiKTtcbiAgICogY29uc3QgcmVzdWx0ID0gZkFycmF5LmdldEZpeGVkQXJyYXlTaXplKCk7XG4gICAqIC8vIHJlc3VsdCA9IDNcbiAgICogYGBgXG4gICAqL1xuICBnZXRGaXhlZEFycmF5U2l6ZSgpIHtcbiAgICByZXR1cm4gX0NhaXJvRml4ZWRBcnJheS5nZXRGaXhlZEFycmF5U2l6ZSh0aGlzLmFycmF5VHlwZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBDYWlybyBjb250ZW50IHR5cGUgZnJvbSBhIENhaXJvIGZpeGVkIGFycmF5IHR5cGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZml4ZWQtYXJyYXkgdHlwZS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQgPSBDYWlyb0ZpeGVkQXJyYXkuZ2V0Rml4ZWRBcnJheVR5cGUoXCJbY29yZTo6aW50ZWdlcjo6dTMyOyA4XVwiKTtcbiAgICogLy8gcmVzdWx0ID0gXCJjb3JlOjppbnRlZ2VyOjp1MzJcIlxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBnZXRGaXhlZEFycmF5VHlwZSA9ICh0eXBlKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hBcnJheSA9IHR5cGUubWF0Y2goLyg/PD1cXFspLisoPz07KS8pO1xuICAgIGlmIChtYXRjaEFycmF5ID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBQkkgdHlwZSAke3R5cGV9IGRvIG5vdCBpbmNsdWRlcyBhIHZhbGlkIHR5cGUgb2YgZGF0YS5gKTtcbiAgICByZXR1cm4gbWF0Y2hBcnJheVswXTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBDYWlybyBjb250ZW50IHR5cGUgb2YgdGhlIENhaXJvIGZpeGVkIGFycmF5LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZml4ZWQtYXJyYXkgY29udGVudCB0eXBlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGZBcnJheSA9IG5ldyBDYWlyb0ZpeGVkQXJyYXkoWzEwLDIwLDMwXSwgXCJbY29yZTo6aW50ZWdlcjo6dTMyOyAzXVwiKTtcbiAgICogY29uc3QgcmVzdWx0ID0gZkFycmF5LmdldEZpeGVkQXJyYXlUeXBlKCk7XG4gICAqIC8vIHJlc3VsdCA9IFwiY29yZTo6aW50ZWdlcjo6dTMyXCJcbiAgICogYGBgXG4gICAqL1xuICBnZXRGaXhlZEFycmF5VHlwZSgpIHtcbiAgICByZXR1cm4gX0NhaXJvRml4ZWRBcnJheS5nZXRGaXhlZEFycmF5VHlwZSh0aGlzLmFycmF5VHlwZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBvYmplY3QgZnJvbSBhIENhaXJvIGZpeGVkIGFycmF5LlxuICAgKiBCZSBzdXJlIHRvIGhhdmUgYW4gYXJyYXkgbGVuZ3RoIGNvbmZvcm0gdG8gdGhlIEFCSS5cbiAgICogVG8gYmUgdXNlZCB3aXRoIENhbGxEYXRhLmNvbXBpbGUoKS5cbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBpbnB1dCBKUyBhcnJheSByZXByZXNlbnRpbmcgYSBDYWlybyBmaXhlZCBhcnJheS5cbiAgICogQHJldHVybnMge09iamVjdH0gYSBzcGVjaWZpYyBzdHJ1Y3QgcmVwcmVzZW50aW5nIGEgZml4ZWQgQXJyYXkuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgcmVzdWx0ID0gQ2Fpcm9GaXhlZEFycmF5LmNvbXBpbGUoWzEwLDIwLDMwXSk7XG4gICAqIC8vIHJlc3VsdCA9IHsgJzAnOiAxMCwgJzEnOiAyMCwgJzInOiAzMCB9XG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGNvbXBpbGUoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQucmVkdWNlKChhY2MsIGl0ZW0sIGlkeCkgPT4ge1xuICAgICAgYWNjW2lkeF0gPSBpdGVtO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIG9iamVjdCBmcm9tIHRoZSBDYWlybyBmaXhlZCBhcnJheSBpbnN0YW5jZS5cbiAgICogVG8gYmUgdXNlZCB3aXRoIENhbGxEYXRhLmNvbXBpbGUoKS5cbiAgICogQHJldHVybnMgYSBzcGVjaWZpYyBzdHJ1Y3QgcmVwcmVzZW50aW5nIGEgZml4ZWQgYXJyYXkuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgZkFycmF5ID0gbmV3IENhaXJvRml4ZWRBcnJheShbMTAsMjAsMzBdLCBcIltjb3JlOjppbnRlZ2VyOjp1MzI7IDNdXCIpO1xuICAgKiBjb25zdCByZXN1bHQgPSBmQXJyYXkuY29tcGlsZSgpO1xuICAgKiAvLyByZXN1bHQgPSB7ICcwJzogMTAsICcxJzogMjAsICcyJzogMzAgfVxuICAgKiBgYGBcbiAgICovXG4gIGNvbXBpbGUoKSB7XG4gICAgcmV0dXJuIF9DYWlyb0ZpeGVkQXJyYXkuY29tcGlsZSh0aGlzLmNvbnRlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIENhaXJvIHR5cGUgaXMgYSBmaXhlZC1hcnJheSB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyAtIGB0cnVlYCBpZiB0aGUgdHlwZSBpcyBhIGZpeGVkIGFycmF5IHR5cGUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3VsdCA9IENhaXJvRml4ZWRBcnJheS5pc1R5cGVGaXhlZEFycmF5KFwiW2NvcmU6OmludGVnZXI6OnUzMjsgOF1cIik7XG4gICAqIC8vIHJlc3VsdCA9IHRydWVcbiAgICovXG4gIHN0YXRpYyBpc1R5cGVGaXhlZEFycmF5KHR5cGUpIHtcbiAgICByZXR1cm4gL15cXFsuKjtcXHMuKlxcXSQvLnRlc3QodHlwZSkgJiYgLyg/PD1cXFspLisoPz07KS8udGVzdCh0eXBlKSAmJiAvKD88PTsgKVxcZCsoPz1cXF0pLy50ZXN0KHR5cGUpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcHJvcGVydHlPcmRlci50c1xuZnVuY3Rpb24gZXJyb3JVMjU2KGtleSkge1xuICByZXR1cm4gRXJyb3IoXG4gICAgYFlvdXIgb2JqZWN0IGluY2x1ZGVzIHRoZSBwcm9wZXJ0eSA6ICR7a2V5fSwgY29udGFpbmluZyBhbiBVaW50MjU2IG9iamVjdCB3aXRob3V0IHRoZSAnbG93JyBhbmQgJ2hpZ2gnIGtleXMuYFxuICApO1xufVxuZnVuY3Rpb24gZXJyb3JVNTEyKGtleSkge1xuICByZXR1cm4gRXJyb3IoXG4gICAgYFlvdXIgb2JqZWN0IGluY2x1ZGVzIHRoZSBwcm9wZXJ0eSA6ICR7a2V5fSwgY29udGFpbmluZyBhbiBVaW50NTEyIG9iamVjdCB3aXRob3V0IHRoZSAnbGltYjAnIHRvICdsaW1iMycga2V5cy5gXG4gICk7XG59XG5mdW5jdGlvbiBvcmRlclByb3BzQnlBYmkodW5vcmRlcmVkT2JqZWN0LCBhYmlPZk9iamVjdCwgc3RydWN0cywgZW51bXMpIHtcbiAgY29uc3Qgb3JkZXJJbnB1dCA9ICh1bm9yZGVyZWRJdGVtLCBhYmlUeXBlKSA9PiB7XG4gICAgaWYgKENhaXJvRml4ZWRBcnJheS5pc1R5cGVGaXhlZEFycmF5KGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gb3JkZXJGaXhlZEFycmF5KHVub3JkZXJlZEl0ZW0sIGFiaVR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlQXJyYXkoYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiBvcmRlckFycmF5KHVub3JkZXJlZEl0ZW0sIGFiaVR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlRW51bShhYmlUeXBlLCBlbnVtcykpIHtcbiAgICAgIGNvbnN0IGFiaU9iaiA9IGVudW1zW2FiaVR5cGVdO1xuICAgICAgcmV0dXJuIG9yZGVyRW51bSh1bm9yZGVyZWRJdGVtLCBhYmlPYmopO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlVHVwbGUoYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiBvcmRlclR1cGxlKHVub3JkZXJlZEl0ZW0sIGFiaVR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlRXRoQWRkcmVzcyhhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIHVub3JkZXJlZEl0ZW07XG4gICAgfVxuICAgIGlmIChpc1R5cGVOb25aZXJvKGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZUJ5dGVBcnJheShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIHVub3JkZXJlZEl0ZW07XG4gICAgfVxuICAgIGlmIChpc1R5cGVVOTYoYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiB1bm9yZGVyZWRJdGVtO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlU2VjcDI1NmsxUG9pbnQoYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiB1bm9yZGVyZWRJdGVtO1xuICAgIH1cbiAgICBpZiAoQ2Fpcm9VaW50MjU2LmlzQWJpVHlwZShhYmlUeXBlKSkge1xuICAgICAgY29uc3QgdTI1NiA9IHVub3JkZXJlZEl0ZW07XG4gICAgICBpZiAodHlwZW9mIHUyNTYgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHUyNTY7XG4gICAgICB9XG4gICAgICBpZiAoIShcImxvd1wiIGluIHUyNTYgJiYgXCJoaWdoXCIgaW4gdTI1NikpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JVMjU2KGFiaVR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbG93OiB1MjU2LmxvdywgaGlnaDogdTI1Ni5oaWdoIH07XG4gICAgfVxuICAgIGlmIChDYWlyb1VpbnQ1MTIuaXNBYmlUeXBlKGFiaVR5cGUpKSB7XG4gICAgICBjb25zdCB1NTEyID0gdW5vcmRlcmVkSXRlbTtcbiAgICAgIGlmICh0eXBlb2YgdTUxMiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gdTUxMjtcbiAgICAgIH1cbiAgICAgIGlmICghW1wibGltYjBcIiwgXCJsaW1iMVwiLCBcImxpbWIyXCIsIFwibGltYjNcIl0uZXZlcnkoKGtleSkgPT4ga2V5IGluIHU1MTIpKSB7XG4gICAgICAgIHRocm93IGVycm9yVTUxMihhYmlUeXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGxpbWIwOiB1NTEyLmxpbWIwLCBsaW1iMTogdTUxMi5saW1iMSwgbGltYjI6IHU1MTIubGltYjIsIGxpbWIzOiB1NTEyLmxpbWIzIH07XG4gICAgfVxuICAgIGlmIChpc1R5cGVTdHJ1Y3QoYWJpVHlwZSwgc3RydWN0cykpIHtcbiAgICAgIGNvbnN0IGFiaU9mU3RydWN0ID0gc3RydWN0c1thYmlUeXBlXS5tZW1iZXJzO1xuICAgICAgcmV0dXJuIG9yZGVyU3RydWN0KHVub3JkZXJlZEl0ZW0sIGFiaU9mU3RydWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHVub3JkZXJlZEl0ZW07XG4gIH07XG4gIGNvbnN0IG9yZGVyU3RydWN0ID0gKHVub3JkZXJlZE9iamVjdDIsIGFiaU9iamVjdCkgPT4ge1xuICAgIGNvbnN0IG9yZGVyZWRPYmplY3QyID0gYWJpT2JqZWN0LnJlZHVjZSgob3JkZXJlZE9iamVjdCwgYWJpUGFyYW0pID0+IHtcbiAgICAgIGNvbnN0IHNldFByb3BlcnR5ID0gKHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkob3JkZXJlZE9iamVjdCwgYWJpUGFyYW0ubmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWUgPz8gdW5vcmRlcmVkT2JqZWN0MlthYmlQYXJhbS5uYW1lXVxuICAgICAgfSk7XG4gICAgICBpZiAodW5vcmRlcmVkT2JqZWN0MlthYmlQYXJhbS5uYW1lXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoaXNDYWlybzFUeXBlKGFiaVBhcmFtLnR5cGUpIHx8ICFpc0xlbihhYmlQYXJhbS5uYW1lKSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBZb3VyIG9iamVjdCBuZWVkcyBhIHByb3BlcnR5IHdpdGgga2V5IDogJHthYmlQYXJhbS5uYW1lfSAuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldFByb3BlcnR5KG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0MlthYmlQYXJhbS5uYW1lXSwgYWJpUGFyYW0udHlwZSkpO1xuICAgICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBvcmRlcmVkT2JqZWN0MjtcbiAgfTtcbiAgZnVuY3Rpb24gb3JkZXJBcnJheShteUFycmF5LCBhYmlQYXJhbSkge1xuICAgIGNvbnN0IHR5cGVJbkFycmF5ID0gZ2V0QXJyYXlUeXBlKGFiaVBhcmFtKTtcbiAgICBpZiAoaXNTdHJpbmcobXlBcnJheSkpIHtcbiAgICAgIHJldHVybiBteUFycmF5O1xuICAgIH1cbiAgICByZXR1cm4gbXlBcnJheS5tYXAoKG15RWxlbSkgPT4gb3JkZXJJbnB1dChteUVsZW0sIHR5cGVJbkFycmF5KSk7XG4gIH1cbiAgZnVuY3Rpb24gb3JkZXJGaXhlZEFycmF5KGlucHV0LCBhYmlQYXJhbSkge1xuICAgIGNvbnN0IHR5cGVJbkZpeGVkQXJyYXkgPSBDYWlyb0ZpeGVkQXJyYXkuZ2V0Rml4ZWRBcnJheVR5cGUoYWJpUGFyYW0pO1xuICAgIGNvbnN0IGFycmF5U2l6ZSA9IENhaXJvRml4ZWRBcnJheS5nZXRGaXhlZEFycmF5U2l6ZShhYmlQYXJhbSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICBpZiAoYXJyYXlTaXplICE9PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBBQkkgdHlwZSAke2FiaVBhcmFtfTogYXJyYXkgcHJvdmlkZWQgZG8gbm90IGluY2x1ZGVzICAke2FycmF5U2l6ZX0gaXRlbXMuICR7aW5wdXQubGVuZ3RofSBpdGVtcyBwcm92aWRlZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXQubWFwKChteUVsZW0pID0+IG9yZGVySW5wdXQobXlFbGVtLCB0eXBlSW5GaXhlZEFycmF5KSk7XG4gICAgfVxuICAgIGlmIChhcnJheVNpemUgIT09IE9iamVjdC5rZXlzKGlucHV0KS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEFCSSB0eXBlICR7YWJpUGFyYW19OiBvYmplY3QgcHJvdmlkZWQgZG8gbm90IGluY2x1ZGVzICAke2FycmF5U2l6ZX0gcHJvcGVydGllcy4gJHtPYmplY3Qua2V5cyhpbnB1dCkubGVuZ3RofSBpdGVtcyBwcm92aWRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gb3JkZXJJbnB1dChpbnB1dCwgdHlwZUluRml4ZWRBcnJheSk7XG4gIH1cbiAgZnVuY3Rpb24gb3JkZXJUdXBsZSh1bm9yZGVyZWRPYmplY3QyLCBhYmlQYXJhbSkge1xuICAgIGNvbnN0IHR5cGVMaXN0ID0gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXMoYWJpUGFyYW0pO1xuICAgIGNvbnN0IG9yZGVyZWRPYmplY3QyID0gdHlwZUxpc3QucmVkdWNlKChvcmRlcmVkT2JqZWN0LCBhYmlUeXBlQ2Fpcm9YLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgbXlPYmpLZXlzID0gT2JqZWN0LmtleXModW5vcmRlcmVkT2JqZWN0Mik7XG4gICAgICBjb25zdCBzZXRQcm9wZXJ0eSA9ICh2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9yZGVyZWRPYmplY3QsIGluZGV4LnRvU3RyaW5nKCksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlID8/IHVub3JkZXJlZE9iamVjdDJbbXlPYmpLZXlzW2luZGV4XV1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWJpVHlwZSA9IGFiaVR5cGVDYWlyb1g/LnR5cGUgPyBhYmlUeXBlQ2Fpcm9YLnR5cGUgOiBhYmlUeXBlQ2Fpcm9YO1xuICAgICAgc2V0UHJvcGVydHkob3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyW215T2JqS2V5c1tpbmRleF1dLCBhYmlUeXBlKSk7XG4gICAgICByZXR1cm4gb3JkZXJlZE9iamVjdDtcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIG9yZGVyZWRPYmplY3QyO1xuICB9XG4gIGNvbnN0IG9yZGVyRW51bSA9ICh1bm9yZGVyZWRPYmplY3QyLCBhYmlPYmplY3QpID0+IHtcbiAgICBpZiAoaXNUeXBlUmVzdWx0KGFiaU9iamVjdC5uYW1lKSkge1xuICAgICAgY29uc3QgdW5vcmRlcmVkUmVzdWx0ID0gdW5vcmRlcmVkT2JqZWN0MjtcbiAgICAgIGNvbnN0IHJlc3VsdE9rVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIjxcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIixcIilcbiAgICAgICk7XG4gICAgICBjb25zdCByZXN1bHRFcnJUeXBlID0gYWJpT2JqZWN0Lm5hbWUuc3Vic3RyaW5nKFxuICAgICAgICBhYmlPYmplY3QubmFtZS5pbmRleE9mKFwiLFwiKSArIDEsXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmxhc3RJbmRleE9mKFwiPlwiKVxuICAgICAgKTtcbiAgICAgIGlmICh1bm9yZGVyZWRSZXN1bHQuaXNPaygpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2Fpcm9SZXN1bHQoXG4gICAgICAgICAgQ2Fpcm9SZXN1bHRWYXJpYW50Lk9rLFxuICAgICAgICAgIG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0Mi51bndyYXAoKSwgcmVzdWx0T2tUeXBlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDYWlyb1Jlc3VsdChcbiAgICAgICAgQ2Fpcm9SZXN1bHRWYXJpYW50LkVycixcbiAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyLnVud3JhcCgpLCByZXN1bHRFcnJUeXBlKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZU9wdGlvbihhYmlPYmplY3QubmFtZSkpIHtcbiAgICAgIGNvbnN0IHVub3JkZXJlZE9wdGlvbiA9IHVub3JkZXJlZE9iamVjdDI7XG4gICAgICBjb25zdCByZXN1bHRTb21lVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIjxcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIj5cIilcbiAgICAgICk7XG4gICAgICBpZiAodW5vcmRlcmVkT3B0aW9uLmlzU29tZSgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2Fpcm9PcHRpb24oXG4gICAgICAgICAgQ2Fpcm9PcHRpb25WYXJpYW50LlNvbWUsXG4gICAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPcHRpb24udW53cmFwKCksIHJlc3VsdFNvbWVUeXBlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDYWlyb09wdGlvbihDYWlyb09wdGlvblZhcmlhbnQuTm9uZSwge30pO1xuICAgIH1cbiAgICBjb25zdCB1bm9yZGVyZWRDdXN0b21FbnVtID0gdW5vcmRlcmVkT2JqZWN0MjtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHVub3JkZXJlZEN1c3RvbUVudW0udmFyaWFudCk7XG4gICAgY29uc3QgbmV3RW50cmllcyA9IHZhcmlhbnRzLm1hcCgodmFyaWFudCkgPT4ge1xuICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhcmlhbnRbMV0pKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50O1xuICAgICAgfVxuICAgICAgY29uc3QgdmFyaWFudFR5cGUgPSBhYmlPYmplY3QudHlwZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC50eXBlLmxhc3RJbmRleE9mKFwiPFwiKSArIDEsXG4gICAgICAgIGFiaU9iamVjdC50eXBlLmxhc3RJbmRleE9mKFwiPlwiKVxuICAgICAgKTtcbiAgICAgIGlmICh2YXJpYW50VHlwZSA9PT0gXCIoKVwiKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt2YXJpYW50WzBdLCBvcmRlcklucHV0KHVub3JkZXJlZEN1c3RvbUVudW0udW53cmFwKCksIHZhcmlhbnRUeXBlKV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBDYWlyb0N1c3RvbUVudW0oT2JqZWN0LmZyb21FbnRyaWVzKG5ld0VudHJpZXMpKTtcbiAgfTtcbiAgY29uc3QgZmluYWxPcmRlcmVkT2JqZWN0ID0gYWJpT2ZPYmplY3QucmVkdWNlKChvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbSkgPT4ge1xuICAgIGNvbnN0IHNldFByb3BlcnR5ID0gKHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkob3JkZXJlZE9iamVjdCwgYWJpUGFyYW0ubmFtZSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgaWYgKGlzTGVuKGFiaVBhcmFtLm5hbWUpICYmICFpc0NhaXJvMVR5cGUoYWJpUGFyYW0udHlwZSkpIHtcbiAgICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICAgIH1cbiAgICBzZXRQcm9wZXJ0eShvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdFthYmlQYXJhbS5uYW1lXSwgYWJpUGFyYW0udHlwZSkpO1xuICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICB9LCB7fSk7XG4gIHJldHVybiBmaW5hbE9yZGVyZWRPYmplY3Q7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9yZXF1ZXN0UGFyc2VyLnRzXG5mdW5jdGlvbiBwYXJzZUJhc2VUeXBlcyh0eXBlLCB2YWwpIHtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKHR5cGUpOlxuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYodmFsKS50b0FwaVJlcXVlc3QoKTtcbiAgICBjYXNlIENhaXJvVWludDUxMi5pc0FiaVR5cGUodHlwZSk6XG4gICAgICByZXR1cm4gbmV3IENhaXJvVWludDUxMih2YWwpLnRvQXBpUmVxdWVzdCgpO1xuICAgIGNhc2UgaXNUeXBlQnl0ZXMzMSh0eXBlKTpcbiAgICAgIHJldHVybiBlbmNvZGVTaG9ydFN0cmluZyh2YWwudG9TdHJpbmcoKSk7XG4gICAgY2FzZSBpc1R5cGVTZWNwMjU2azFQb2ludCh0eXBlKToge1xuICAgICAgY29uc3QgcHViS2V5RVRIID0gcmVtb3ZlSGV4UHJlZml4KHRvSGV4KHZhbCkpLnBhZFN0YXJ0KDEyOCwgXCIwXCIpO1xuICAgICAgY29uc3QgcHViS2V5RVRIeSA9IHVpbnQyNTYoYWRkSGV4UHJlZml4KHB1YktleUVUSC5zbGljZSgtNjQpKSk7XG4gICAgICBjb25zdCBwdWJLZXlFVEh4ID0gdWludDI1NihhZGRIZXhQcmVmaXgocHViS2V5RVRILnNsaWNlKDAsIC02NCkpKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGZlbHQocHViS2V5RVRIeC5sb3cpLFxuICAgICAgICBmZWx0KHB1YktleUVUSHguaGlnaCksXG4gICAgICAgIGZlbHQocHViS2V5RVRIeS5sb3cpLFxuICAgICAgICBmZWx0KHB1YktleUVUSHkuaGlnaClcbiAgICAgIF07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmVsdCh2YWwpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVR1cGxlKGVsZW1lbnQsIHR5cGVTdHIpIHtcbiAgY29uc3QgbWVtYmVyVHlwZXMgPSBleHRyYWN0VHVwbGVNZW1iZXJUeXBlcyh0eXBlU3RyKTtcbiAgY29uc3QgZWxlbWVudHMgPSBPYmplY3QudmFsdWVzKGVsZW1lbnQpO1xuICBpZiAoZWxlbWVudHMubGVuZ3RoICE9PSBtZW1iZXJUeXBlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGBQYXJzZVR1cGxlOiBwcm92aWRlZCBhbmQgZXhwZWN0ZWQgYWJpIHR1cGxlIHNpemUgZG8gbm90IG1hdGNoLlxuICAgICAgcHJvdmlkZWQ6ICR7ZWxlbWVudHN9XG4gICAgICBleHBlY3RlZDogJHttZW1iZXJUeXBlc31gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWVtYmVyVHlwZXMubWFwKChpdCwgZHgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudDogZWxlbWVudHNbZHhdLFxuICAgICAgdHlwZTogaXQudHlwZSA/PyBpdFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VCeXRlQXJyYXkoZWxlbWVudCkge1xuICBjb25zdCBteUJ5dGVBcnJheSA9IGJ5dGVBcnJheUZyb21TdHJpbmcoZWxlbWVudCk7XG4gIHJldHVybiBbXG4gICAgbXlCeXRlQXJyYXkuZGF0YS5sZW5ndGgudG9TdHJpbmcoKSxcbiAgICAuLi5teUJ5dGVBcnJheS5kYXRhLm1hcCgoYm4pID0+IGJuLnRvU3RyaW5nKCkpLFxuICAgIG15Qnl0ZUFycmF5LnBlbmRpbmdfd29yZC50b1N0cmluZygpLFxuICAgIG15Qnl0ZUFycmF5LnBlbmRpbmdfd29yZF9sZW4udG9TdHJpbmcoKVxuICBdO1xufVxuZnVuY3Rpb24gcGFyc2VDYWxsZGF0YVZhbHVlKGVsZW1lbnQsIHR5cGUsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGlmIChlbGVtZW50ID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBFcnJvcihgTWlzc2luZyBwYXJhbWV0ZXIgZm9yIHR5cGUgJHt0eXBlfWApO1xuICB9XG4gIGlmIChDYWlyb0ZpeGVkQXJyYXkuaXNUeXBlRml4ZWRBcnJheSh0eXBlKSkge1xuICAgIGNvbnN0IGFycmF5VHlwZSA9IENhaXJvRml4ZWRBcnJheS5nZXRGaXhlZEFycmF5VHlwZSh0eXBlKTtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGFycmF5ID0gbmV3IENhaXJvRml4ZWRBcnJheShlbGVtZW50LCB0eXBlKTtcbiAgICAgIHZhbHVlcyA9IGFycmF5LmNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhlbGVtZW50KTtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdmFsdWVzLmxlbmd0aCA9PT0gQ2Fpcm9GaXhlZEFycmF5LmdldEZpeGVkQXJyYXlTaXplKHR5cGUpLFxuICAgICAgICBgQUJJIHR5cGUgJHt0eXBlfTogb2JqZWN0IHByb3ZpZGVkIGRvIG5vdCBpbmNsdWRlcyAgJHtDYWlyb0ZpeGVkQXJyYXkuZ2V0Rml4ZWRBcnJheVNpemUodHlwZSl9IGl0ZW1zLiAke3ZhbHVlcy5sZW5ndGh9IGl0ZW1zIHByb3ZpZGVkLmBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUJJIHR5cGUgJHt0eXBlfTogbm90IGFuIEFycmF5IHJlcHJlc2VudGluZyBhIGNhaXJvLmZpeGVkQXJyYXkoKSBwcm92aWRlZC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlQ2FsbGRhdGFWYWx1ZShpdCwgYXJyYXlUeXBlLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH0sIFtdKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5wdXNoKGZlbHQoZWxlbWVudC5sZW5ndGgpKTtcbiAgICBjb25zdCBhcnJheVR5cGUgPSBnZXRBcnJheVR5cGUodHlwZSk7XG4gICAgcmV0dXJuIGVsZW1lbnQucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZUNhbGxkYXRhVmFsdWUoaXQsIGFycmF5VHlwZSwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9LCByZXN1bHQpO1xuICB9XG4gIGlmIChzdHJ1Y3RzW3R5cGVdICYmIHN0cnVjdHNbdHlwZV0ubWVtYmVycy5sZW5ndGgpIHtcbiAgICBpZiAoQ2Fpcm9VaW50MjU2LmlzQWJpVHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYoZWxlbWVudCkudG9BcGlSZXF1ZXN0KCk7XG4gICAgfVxuICAgIGlmIChDYWlyb1VpbnQ1MTIuaXNBYmlUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gbmV3IENhaXJvVWludDUxMihlbGVtZW50KS50b0FwaVJlcXVlc3QoKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZUV0aEFkZHJlc3ModHlwZSkpIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCBlbGVtZW50KTtcbiAgICBpZiAoaXNUeXBlQnl0ZUFycmF5KHR5cGUpKSByZXR1cm4gcGFyc2VCeXRlQXJyYXkoZWxlbWVudCk7XG4gICAgY29uc3QgeyBtZW1iZXJzIH0gPSBzdHJ1Y3RzW3R5cGVdO1xuICAgIGNvbnN0IHN1YkVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHJldHVybiBtZW1iZXJzLnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQocGFyc2VDYWxsZGF0YVZhbHVlKHN1YkVsZW1lbnRbaXQubmFtZV0sIGl0LnR5cGUsIHN0cnVjdHMsIGVudW1zKSk7XG4gICAgfSwgW10pO1xuICB9XG4gIGlmIChpc1R5cGVUdXBsZSh0eXBlKSkge1xuICAgIGNvbnN0IHR1cGxlZCA9IHBhcnNlVHVwbGUoZWxlbWVudCwgdHlwZSk7XG4gICAgcmV0dXJuIHR1cGxlZC5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBwYXJzZUNhbGxkYXRhVmFsdWUoaXQuZWxlbWVudCwgaXQudHlwZSwgc3RydWN0cywgZW51bXMpO1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQocGFyc2VkRGF0YSk7XG4gICAgfSwgW10pO1xuICB9XG4gIGlmIChDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYoZWxlbWVudCkudG9BcGlSZXF1ZXN0KCk7XG4gIH1cbiAgaWYgKENhaXJvVWludDUxMi5pc0FiaVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gbmV3IENhaXJvVWludDUxMihlbGVtZW50KS50b0FwaVJlcXVlc3QoKTtcbiAgfVxuICBpZiAoaXNUeXBlRW51bSh0eXBlLCBlbnVtcykpIHtcbiAgICBjb25zdCB7IHZhcmlhbnRzIH0gPSBlbnVtc1t0eXBlXTtcbiAgICBpZiAoaXNUeXBlT3B0aW9uKHR5cGUpKSB7XG4gICAgICBjb25zdCBteU9wdGlvbiA9IGVsZW1lbnQ7XG4gICAgICBpZiAobXlPcHRpb24uaXNTb21lKCkpIHtcbiAgICAgICAgY29uc3QgbGlzdFR5cGVWYXJpYW50MiA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gXCJTb21lXCIpO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQobGlzdFR5cGVWYXJpYW50MikpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXJyb3IgaW4gYWJpIDogT3B0aW9uIGhhcyBubyAnU29tZScgdmFyaWFudC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlVmFyaWFudFNvbWUgPSBsaXN0VHlwZVZhcmlhbnQyLnR5cGU7XG4gICAgICAgIGlmICh0eXBlVmFyaWFudFNvbWUgPT09IFwiKClcIikge1xuICAgICAgICAgIHJldHVybiBDYWlyb09wdGlvblZhcmlhbnQuU29tZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlcjIgPSBwYXJzZUNhbGxkYXRhVmFsdWUoXG4gICAgICAgICAgbXlPcHRpb24udW53cmFwKCksXG4gICAgICAgICAgdHlwZVZhcmlhbnRTb21lLFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgZW51bXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyMikpIHtcbiAgICAgICAgICByZXR1cm4gW0NhaXJvT3B0aW9uVmFyaWFudC5Tb21lLnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcjJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbQ2Fpcm9PcHRpb25WYXJpYW50LlNvbWUudG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gQ2Fpcm9PcHRpb25WYXJpYW50Lk5vbmUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVJlc3VsdCh0eXBlKSkge1xuICAgICAgY29uc3QgbXlSZXN1bHQgPSBlbGVtZW50O1xuICAgICAgaWYgKG15UmVzdWx0LmlzT2soKSkge1xuICAgICAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQzID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBcIk9rXCIpO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQobGlzdFR5cGVWYXJpYW50MykpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXJyb3IgaW4gYWJpIDogUmVzdWx0IGhhcyBubyAnT2snIHZhcmlhbnQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZVZhcmlhbnRPayA9IGxpc3RUeXBlVmFyaWFudDMudHlwZTtcbiAgICAgICAgaWYgKHR5cGVWYXJpYW50T2sgPT09IFwiKClcIikge1xuICAgICAgICAgIHJldHVybiBDYWlyb1Jlc3VsdFZhcmlhbnQuT2sudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIzID0gcGFyc2VDYWxsZGF0YVZhbHVlKFxuICAgICAgICAgIG15UmVzdWx0LnVud3JhcCgpLFxuICAgICAgICAgIHR5cGVWYXJpYW50T2ssXG4gICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICBlbnVtc1xuICAgICAgICApO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIzKSkge1xuICAgICAgICAgIHJldHVybiBbQ2Fpcm9SZXN1bHRWYXJpYW50Lk9rLnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcjNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbQ2Fpcm9SZXN1bHRWYXJpYW50Lk9rLnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcjNdO1xuICAgICAgfVxuICAgICAgY29uc3QgbGlzdFR5cGVWYXJpYW50MiA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gXCJFcnJcIik7XG4gICAgICBpZiAoaXNVbmRlZmluZWQobGlzdFR5cGVWYXJpYW50MikpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIGluIGFiaSA6IFJlc3VsdCBoYXMgbm8gJ0VycicgdmFyaWFudC5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGVWYXJpYW50RXJyID0gbGlzdFR5cGVWYXJpYW50Mi50eXBlO1xuICAgICAgaWYgKHR5cGVWYXJpYW50RXJyID09PSBcIigpXCIpIHtcbiAgICAgICAgcmV0dXJuIENhaXJvUmVzdWx0VmFyaWFudC5FcnIudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlcjIgPSBwYXJzZUNhbGxkYXRhVmFsdWUobXlSZXN1bHQudW53cmFwKCksIHR5cGVWYXJpYW50RXJyLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIyKSkge1xuICAgICAgICByZXR1cm4gW0NhaXJvUmVzdWx0VmFyaWFudC5FcnIudG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gW0NhaXJvUmVzdWx0VmFyaWFudC5FcnIudG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyMl07XG4gICAgfVxuICAgIGNvbnN0IG15RW51bSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IG15RW51bS5hY3RpdmVWYXJpYW50KCk7XG4gICAgY29uc3QgbGlzdFR5cGVWYXJpYW50ID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBhY3RpdmVWYXJpYW50KTtcbiAgICBpZiAoaXNVbmRlZmluZWQobGlzdFR5cGVWYXJpYW50KSkge1xuICAgICAgdGhyb3cgRXJyb3IoYE5vdCBmaW5kIGluIGFiaSA6IEVudW0gaGFzIG5vICcke2FjdGl2ZVZhcmlhbnR9JyB2YXJpYW50LmApO1xuICAgIH1cbiAgICBjb25zdCB0eXBlQWN0aXZlVmFyaWFudCA9IGxpc3RUeXBlVmFyaWFudC50eXBlO1xuICAgIGNvbnN0IG51bUFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kSW5kZXgoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gYWN0aXZlVmFyaWFudCk7XG4gICAgaWYgKHR5cGVBY3RpdmVWYXJpYW50ID09PSBcIigpXCIpIHtcbiAgICAgIHJldHVybiBudW1BY3RpdmVWYXJpYW50LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlciA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShteUVudW0udW53cmFwKCksIHR5cGVBY3RpdmVWYXJpYW50LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyKSkge1xuICAgICAgcmV0dXJuIFtudW1BY3RpdmVWYXJpYW50LnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcl07XG4gICAgfVxuICAgIHJldHVybiBbbnVtQWN0aXZlVmFyaWFudC50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXJdO1xuICB9XG4gIGlmIChpc1R5cGVOb25aZXJvKHR5cGUpKSB7XG4gICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKGdldEFycmF5VHlwZSh0eXBlKSwgZWxlbWVudCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgRXJyb3IoYFBhcmFtZXRlciAke2VsZW1lbnR9IGRvIG5vdCBhbGlnbiB3aXRoIGFiaSBwYXJhbWV0ZXIgJHt0eXBlfWApO1xuICB9XG4gIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FsbGRhdGFGaWVsZChhcmdzSXRlcmF0b3IsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IGlucHV0O1xuICBsZXQgeyB2YWx1ZSB9ID0gYXJnc0l0ZXJhdG9yLm5leHQoKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgLy8gRml4ZWQgYXJyYXlcbiAgICBjYXNlIENhaXJvRml4ZWRBcnJheS5pc1R5cGVGaXhlZEFycmF5KHR5cGUpOlxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAhKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEFCSSBleHBlY3RlZCBwYXJhbWV0ZXIgJHtuYW1lfSB0byBiZSBhbiBhcnJheSBvciBhbiBvYmplY3QsIGdvdCAke3ZhbHVlfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlQ2FsbGRhdGFWYWx1ZSh2YWx1ZSwgaW5wdXQudHlwZSwgc3RydWN0cywgZW51bXMpO1xuICAgIC8vIE5vcm1hbCBBcnJheVxuICAgIGNhc2UgaXNUeXBlQXJyYXkodHlwZSk6XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpICYmICFpc1RleHQodmFsdWUpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBBQkkgZXhwZWN0ZWQgcGFyYW1ldGVyICR7bmFtZX0gdG8gYmUgYXJyYXkgb3IgbG9uZyBzdHJpbmcsIGdvdCAke3ZhbHVlfWApO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHNwbGl0TG9uZ1N0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VDYWxsZGF0YVZhbHVlKHZhbHVlLCBpbnB1dC50eXBlLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgY2FzZSBpc1R5cGVOb25aZXJvKHR5cGUpOlxuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKGdldEFycmF5VHlwZSh0eXBlKSwgdmFsdWUpO1xuICAgIGNhc2UgaXNUeXBlRXRoQWRkcmVzcyh0eXBlKTpcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCB2YWx1ZSk7XG4gICAgLy8gU3RydWN0IG9yIFR1cGxlXG4gICAgY2FzZSAoaXNUeXBlU3RydWN0KHR5cGUsIHN0cnVjdHMpIHx8IGlzVHlwZVR1cGxlKHR5cGUpIHx8IENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSkpOlxuICAgICAgcmV0dXJuIHBhcnNlQ2FsbGRhdGFWYWx1ZSh2YWx1ZSwgdHlwZSwgc3RydWN0cywgZW51bXMpO1xuICAgIC8vIEVudW1zXG4gICAgY2FzZSBpc1R5cGVFbnVtKHR5cGUsIGVudW1zKTpcbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICBlbnVtc1xuICAgICAgKTtcbiAgICAvLyBGZWx0IG9yIHVuaGFuZGxlZFxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgdmFsdWUpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9yZXNwb25zZVBhcnNlci50c1xuZnVuY3Rpb24gcGFyc2VCYXNlVHlwZXMyKHR5cGUsIGl0KSB7XG4gIGxldCB0ZW1wO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUJvb2wodHlwZSk6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oQmlnSW50KHRlbXApKTtcbiAgICBjYXNlIENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSk6XG4gICAgICBjb25zdCBsb3cgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCBoaWdoID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYobG93LCBoaWdoKS50b0JpZ0ludCgpO1xuICAgIGNhc2UgQ2Fpcm9VaW50NTEyLmlzQWJpVHlwZSh0eXBlKTpcbiAgICAgIGNvbnN0IGxpbWIwID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgY29uc3QgbGltYjEgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCBsaW1iMiA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IGxpbWIzID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQ1MTIobGltYjAsIGxpbWIxLCBsaW1iMiwgbGltYjMpLnRvQmlnSW50KCk7XG4gICAgY2FzZSBpc1R5cGVFdGhBZGRyZXNzKHR5cGUpOlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gICAgY2FzZSBpc1R5cGVCeXRlczMxKHR5cGUpOlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBkZWNvZGVTaG9ydFN0cmluZyh0ZW1wKTtcbiAgICBjYXNlIGlzVHlwZVNlY3AyNTZrMVBvaW50KHR5cGUpOlxuICAgICAgY29uc3QgeExvdyA9IHJlbW92ZUhleFByZWZpeChpdC5uZXh0KCkudmFsdWUpLnBhZFN0YXJ0KDMyLCBcIjBcIik7XG4gICAgICBjb25zdCB4SGlnaCA9IHJlbW92ZUhleFByZWZpeChpdC5uZXh0KCkudmFsdWUpLnBhZFN0YXJ0KDMyLCBcIjBcIik7XG4gICAgICBjb25zdCB5TG93ID0gcmVtb3ZlSGV4UHJlZml4KGl0Lm5leHQoKS52YWx1ZSkucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgICAgIGNvbnN0IHlIaWdoID0gcmVtb3ZlSGV4UHJlZml4KGl0Lm5leHQoKS52YWx1ZSkucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgICAgIGNvbnN0IHB1YksgPSBCaWdJbnQoYWRkSGV4UHJlZml4KHhIaWdoICsgeExvdyArIHlIaWdoICsgeUxvdykpO1xuICAgICAgcmV0dXJuIHB1Yks7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRlbXAgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gQmlnSW50KHRlbXApO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWxlbWVudCwgc3RydWN0cywgZW51bXMpIHtcbiAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCIoKVwiKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGlmIChDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKGVsZW1lbnQudHlwZSkpIHtcbiAgICBjb25zdCBsb3cgPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICBjb25zdCBoaWdoID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYobG93LCBoaWdoKS50b0JpZ0ludCgpO1xuICB9XG4gIGlmIChDYWlyb1VpbnQ1MTIuaXNBYmlUeXBlKGVsZW1lbnQudHlwZSkpIHtcbiAgICBjb25zdCBsaW1iMCA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIGNvbnN0IGxpbWIxID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgY29uc3QgbGltYjIgPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICBjb25zdCBsaW1iMyA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50NTEyKGxpbWIwLCBsaW1iMSwgbGltYjIsIGxpbWIzKS50b0JpZ0ludCgpO1xuICB9XG4gIGlmIChpc1R5cGVCeXRlQXJyYXkoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IHBhcnNlZEJ5dGVzMzFBcnIgPSBbXTtcbiAgICBjb25zdCBieXRlczMxQXJyTGVuID0gQmlnSW50KHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICB3aGlsZSAocGFyc2VkQnl0ZXMzMUFyci5sZW5ndGggPCBieXRlczMxQXJyTGVuKSB7XG4gICAgICBwYXJzZWRCeXRlczMxQXJyLnB1c2godG9IZXgocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZ193b3JkID0gdG9IZXgocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIGNvbnN0IHBlbmRpbmdfd29yZF9sZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIGNvbnN0IG15Qnl0ZUFycmF5ID0ge1xuICAgICAgZGF0YTogcGFyc2VkQnl0ZXMzMUFycixcbiAgICAgIHBlbmRpbmdfd29yZCxcbiAgICAgIHBlbmRpbmdfd29yZF9sZW5cbiAgICB9O1xuICAgIHJldHVybiBzdHJpbmdGcm9tQnl0ZUFycmF5KG15Qnl0ZUFycmF5KTtcbiAgfVxuICBpZiAoQ2Fpcm9GaXhlZEFycmF5LmlzVHlwZUZpeGVkQXJyYXkoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICBjb25zdCBlbCA9IHsgbmFtZTogXCJcIiwgdHlwZTogQ2Fpcm9GaXhlZEFycmF5LmdldEZpeGVkQXJyYXlUeXBlKGVsZW1lbnQudHlwZSkgfTtcbiAgICBjb25zdCBhcnJheVNpemUgPSBDYWlyb0ZpeGVkQXJyYXkuZ2V0Rml4ZWRBcnJheVNpemUoZWxlbWVudC50eXBlKTtcbiAgICB3aGlsZSAocGFyc2VkRGF0YUFyci5sZW5ndGggPCBhcnJheVNpemUpIHtcbiAgICAgIHBhcnNlZERhdGFBcnIucHVzaChwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWwsIHN0cnVjdHMsIGVudW1zKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWREYXRhQXJyO1xuICB9XG4gIGlmIChpc1R5cGVBcnJheShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgcGFyc2VkRGF0YUFyciA9IFtdO1xuICAgIGNvbnN0IGVsID0geyBuYW1lOiBcIlwiLCB0eXBlOiBnZXRBcnJheVR5cGUoZWxlbWVudC50eXBlKSB9O1xuICAgIGNvbnN0IGxlbiA9IEJpZ0ludChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgd2hpbGUgKHBhcnNlZERhdGFBcnIubGVuZ3RoIDwgbGVuKSB7XG4gICAgICBwYXJzZWREYXRhQXJyLnB1c2gocGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkRGF0YUFycjtcbiAgfVxuICBpZiAoaXNUeXBlTm9uWmVybyhlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgZWwgPSB7IG5hbWU6IFwiXCIsIHR5cGU6IGdldEFycmF5VHlwZShlbGVtZW50LnR5cGUpIH07XG4gICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpO1xuICB9XG4gIGlmIChzdHJ1Y3RzICYmIGVsZW1lbnQudHlwZSBpbiBzdHJ1Y3RzICYmIHN0cnVjdHNbZWxlbWVudC50eXBlXSkge1xuICAgIGlmIChpc1R5cGVFdGhBZGRyZXNzKGVsZW1lbnQudHlwZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlczIoZWxlbWVudC50eXBlLCByZXNwb25zZUl0ZXJhdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdHNbZWxlbWVudC50eXBlXS5tZW1iZXJzLnJlZHVjZSgoYWNjLCBlbCkgPT4ge1xuICAgICAgYWNjW2VsLm5hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuICBpZiAoZW51bXMgJiYgZWxlbWVudC50eXBlIGluIGVudW1zICYmIGVudW1zW2VsZW1lbnQudHlwZV0pIHtcbiAgICBjb25zdCB2YXJpYW50TnVtID0gTnVtYmVyKHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICBjb25zdCByYXdFbnVtID0gZW51bXNbZWxlbWVudC50eXBlXS52YXJpYW50cy5yZWR1Y2UoKGFjYywgdmFyaWFudCwgbnVtKSA9PiB7XG4gICAgICBpZiAobnVtID09PSB2YXJpYW50TnVtKSB7XG4gICAgICAgIGFjY1t2YXJpYW50Lm5hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKFxuICAgICAgICAgIHJlc3BvbnNlSXRlcmF0b3IsXG4gICAgICAgICAgeyBuYW1lOiBcIlwiLCB0eXBlOiB2YXJpYW50LnR5cGUgfSxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIGVudW1zXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBhY2NbdmFyaWFudC5uYW1lXSA9IHZvaWQgMDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGlmIChlbGVtZW50LnR5cGUuc3RhcnRzV2l0aChcImNvcmU6Om9wdGlvbjo6T3B0aW9uXCIpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdmFyaWFudE51bSA9PT0gQ2Fpcm9PcHRpb25WYXJpYW50LlNvbWUgPyByYXdFbnVtLlNvbWUgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gbmV3IENhaXJvT3B0aW9uKHZhcmlhbnROdW0sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC50eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdFwiKSkge1xuICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICBpZiAodmFyaWFudE51bSA9PT0gQ2Fpcm9SZXN1bHRWYXJpYW50Lk9rKSB7XG4gICAgICAgIGNvbnRlbnQgPSByYXdFbnVtLk9rO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudCA9IHJhd0VudW0uRXJyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDYWlyb1Jlc3VsdCh2YXJpYW50TnVtLCBjb250ZW50KTtcbiAgICB9XG4gICAgY29uc3QgY3VzdG9tRW51bSA9IG5ldyBDYWlyb0N1c3RvbUVudW0ocmF3RW51bSk7XG4gICAgcmV0dXJuIGN1c3RvbUVudW07XG4gIH1cbiAgaWYgKGlzVHlwZVR1cGxlKGVsZW1lbnQudHlwZSkpIHtcbiAgICBjb25zdCBtZW1iZXJUeXBlcyA9IGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKGVsZW1lbnQudHlwZSk7XG4gICAgcmV0dXJuIG1lbWJlclR5cGVzLnJlZHVjZSgoYWNjLCBpdCwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gaXQ/Lm5hbWUgPyBpdC5uYW1lIDogaWR4O1xuICAgICAgY29uc3QgdHlwZSA9IGl0Py50eXBlID8gaXQudHlwZSA6IGl0O1xuICAgICAgY29uc3QgZWwgPSB7IG5hbWUsIHR5cGUgfTtcbiAgICAgIGFjY1tuYW1lXSA9IHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH1cbiAgaWYgKGlzVHlwZUFycmF5KGVsZW1lbnQudHlwZSkpIHtcbiAgICBjb25zdCBwYXJzZWREYXRhQXJyID0gW107XG4gICAgY29uc3QgZWwgPSB7IG5hbWU6IFwiXCIsIHR5cGU6IGdldEFycmF5VHlwZShlbGVtZW50LnR5cGUpIH07XG4gICAgY29uc3QgbGVuID0gQmlnSW50KHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICB3aGlsZSAocGFyc2VkRGF0YUFyci5sZW5ndGggPCBsZW4pIHtcbiAgICAgIHBhcnNlZERhdGFBcnIucHVzaChwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWwsIHN0cnVjdHMsIGVudW1zKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWREYXRhQXJyO1xuICB9XG4gIHJldHVybiBwYXJzZUJhc2VUeXBlczIoZWxlbWVudC50eXBlLCByZXNwb25zZUl0ZXJhdG9yKTtcbn1cbmZ1bmN0aW9uIHJlc3BvbnNlUGFyc2VyKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMsIHBhcnNlZFJlc3VsdCkge1xuICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IG91dHB1dDtcbiAgbGV0IHRlbXA7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgaXNMZW4obmFtZSk6XG4gICAgICB0ZW1wID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gQmlnSW50KHRlbXApO1xuICAgIGNhc2UgKHN0cnVjdHMgJiYgdHlwZSBpbiBzdHJ1Y3RzIHx8IGlzVHlwZVR1cGxlKHR5cGUpKTpcbiAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgY2FzZSAoZW51bXMgJiYgaXNUeXBlRW51bSh0eXBlLCBlbnVtcykpOlxuICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIENhaXJvRml4ZWRBcnJheS5pc1R5cGVGaXhlZEFycmF5KHR5cGUpOlxuICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIGlzVHlwZUFycmF5KHR5cGUpOlxuICAgICAgaWYgKGlzQ2Fpcm8xVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyc2VkRGF0YUFyciA9IFtdO1xuICAgICAgaWYgKHBhcnNlZFJlc3VsdCAmJiBwYXJzZWRSZXN1bHRbYCR7bmFtZX1fbGVuYF0pIHtcbiAgICAgICAgY29uc3QgYXJyTGVuID0gcGFyc2VkUmVzdWx0W2Ake25hbWV9X2xlbmBdO1xuICAgICAgICB3aGlsZSAocGFyc2VkRGF0YUFyci5sZW5ndGggPCBhcnJMZW4pIHtcbiAgICAgICAgICBwYXJzZWREYXRhQXJyLnB1c2goXG4gICAgICAgICAgICBwYXJzZVJlc3BvbnNlVmFsdWUoXG4gICAgICAgICAgICAgIHJlc3BvbnNlSXRlcmF0b3IsXG4gICAgICAgICAgICAgIHsgbmFtZSwgdHlwZTogb3V0cHV0LnR5cGUucmVwbGFjZShcIipcIiwgXCJcIikgfSxcbiAgICAgICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICAgICAgZW51bXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkRGF0YUFycjtcbiAgICBjYXNlIGlzVHlwZU5vblplcm8odHlwZSk6XG4gICAgICByZXR1cm4gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXMyKHR5cGUsIHJlc3BvbnNlSXRlcmF0b3IpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS92YWxpZGF0ZS50c1xudmFyIHZhbGlkYXRlRmVsdCA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydChcbiAgICBpc1N0cmluZyhwYXJhbWV0ZXIpIHx8IGlzTnVtYmVyKHBhcmFtZXRlcikgfHwgaXNCaWdJbnQocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhIGZlbHQgdHlwZWQgYXMgKFN0cmluZywgTnVtYmVyIG9yIEJpZ0ludClgXG4gICk7XG4gIGlmIChpc1N0cmluZyhwYXJhbWV0ZXIpICYmICFpc0hleChwYXJhbWV0ZXIpKSByZXR1cm47XG4gIGNvbnN0IHBhcmFtID0gQmlnSW50KHBhcmFtZXRlci50b1N0cmluZygxMCkpO1xuICBhc3NlcnQoXG4gICAgLy8gZnJvbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdGFya3dhcmUtbGlicy9zdGFya25ldC1zcGVjcy9ibG9iLzI5YmFiNjUwYmU2YjE4NDdjOTJkNDQ2MWQ0YzMzMDA4YjVlNTBiMWEvYXBpL3N0YXJrbmV0X2FwaV9vcGVucnBjLmpzb24jTDEyNjZcbiAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAyNTJuIC0gMW4sXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4yNTItMV1gXG4gICk7XG59O1xudmFyIHZhbGlkYXRlQnl0ZXMzMSA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydChpc1N0cmluZyhwYXJhbWV0ZXIpLCBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhIHN0cmluZy5gKTtcbiAgYXNzZXJ0KFxuICAgIHBhcmFtZXRlci5sZW5ndGggPCAzMixcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGEgc3RyaW5nIG9mIGxlc3MgdGhhbiAzMiBjaGFyYWN0ZXJzLmBcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVCeXRlQXJyYXkgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoaXNTdHJpbmcocGFyYW1ldGVyKSwgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgYmUgYSBzdHJpbmcuYCk7XG59O1xudmFyIHZhbGlkYXRlVWludCA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGlmIChpc051bWJlcihwYXJhbWV0ZXIpKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgcGFyYW1ldGVyIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgXCJWYWxpZGF0aW9uOiBQYXJhbWV0ZXIgaXMgdG9vIGxhcmdlIHRvIGJlIHR5cGVkIGFzIE51bWJlciB1c2UgKEJpZ0ludCBvciBTdHJpbmcpXCJcbiAgICApO1xuICB9XG4gIGFzc2VydChcbiAgICBpc1N0cmluZyhwYXJhbWV0ZXIpIHx8IGlzTnVtYmVyKHBhcmFtZXRlcikgfHwgaXNCaWdJbnQocGFyYW1ldGVyKSB8fCBpc09iamVjdChwYXJhbWV0ZXIpICYmIFwibG93XCIgaW4gcGFyYW1ldGVyICYmIFwiaGlnaFwiIGluIHBhcmFtZXRlciB8fCBpc09iamVjdChwYXJhbWV0ZXIpICYmIFtcImxpbWIwXCIsIFwibGltYjFcIiwgXCJsaW1iMlwiLCBcImxpbWIzXCJdLmV2ZXJ5KChrZXkpID0+IGtleSBpbiBwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gb2YgY2Fpcm8gdHlwZSAke2lucHV0LnR5cGV9IHNob3VsZCBiZSB0eXBlIChTdHJpbmcsIE51bWJlciBvciBCaWdJbnQpLCBidXQgaXMgJHt0eXBlb2YgcGFyYW1ldGVyfSAke3BhcmFtZXRlcn0uYFxuICApO1xuICBsZXQgcGFyYW07XG4gIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgIGNhc2UgVWludC51MjU2OlxuICAgICAgcGFyYW0gPSBuZXcgQ2Fpcm9VaW50MjU2KHBhcmFtZXRlcikudG9CaWdJbnQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVWludC51NTEyOlxuICAgICAgcGFyYW0gPSBuZXcgQ2Fpcm9VaW50NTEyKHBhcmFtZXRlcikudG9CaWdJbnQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwYXJhbSA9IHRvQmlnSW50KHBhcmFtZXRlcik7XG4gIH1cbiAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgY2FzZSBVaW50LnU4OlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAyNTVuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswIC0gMjU1XWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVpbnQudTE2OlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSA2NTUzNW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDY1NTM1XWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVpbnQudTMyOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSA0Mjk0OTY3Mjk1bixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgNDI5NDk2NzI5NV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVaW50LnU2NDpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogNjRuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeNjQtMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVaW50LnUxMjg6XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDEyOG4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4xMjgtMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVaW50LnUyNTY6XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Nm4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBpcyAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSAwIC0gMl4yNTYtMWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVpbnQudTUxMjpcbiAgICAgIGFzc2VydChcbiAgICAgICAgQ2Fpcm9VaW50NTEyLmlzKHBhcmFtKSxcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBpcyAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSAwIC0gMl41MTItMWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIExpdGVyYWwuQ2xhc3NIYXNoOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTY3MFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAyNTJuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMjUyLTFdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTGl0ZXJhbC5Db250cmFjdEFkZHJlc3M6XG4gICAgICBhc3NlcnQoXG4gICAgICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjQ1XG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Mm4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4yNTItMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMaXRlcmFsLlNlY3AyNTZrMVBvaW50OiB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDUxMm4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBtdXN0IGJlICR7aW5wdXQudHlwZX0gOiBhIDUxMiBiaXRzIG51bWJlci5gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgTGl0ZXJhbC5VOTY6IHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogOTZuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gbXVzdCBiZSAke2lucHV0LnR5cGV9IDogYSA5NiBiaXRzIG51bWJlci5gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxufTtcbnZhciB2YWxpZGF0ZUJvb2wgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgaXNCb29sZWFuKHBhcmFtZXRlciksXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBvZiBjYWlybyB0eXBlICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIHR5cGUgKEJvb2xlYW4pYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVN0cnVjdCA9IChwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzKSA9PiB7XG4gIGlmIChpbnB1dC50eXBlID09PSBVaW50LnUyNTYgfHwgaW5wdXQudHlwZSA9PT0gVWludC51NTEyKSB7XG4gICAgdmFsaWRhdGVVaW50KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNUeXBlRXRoQWRkcmVzcyhpbnB1dC50eXBlKSkge1xuICAgIGFzc2VydCghaXNPYmplY3QocGFyYW1ldGVyKSwgYEV0aEFkZHJlc3MgdHlwZSBpcyB3YWl0aW5nIGEgQmlnTnVtYmVyaXNoLiBHb3QgXCIke3BhcmFtZXRlcn1cImApO1xuICAgIGNvbnN0IHBhcmFtID0gQmlnSW50KHBhcmFtZXRlci50b1N0cmluZygxMCkpO1xuICAgIGFzc2VydChcbiAgICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjU5XG4gICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAxNjBuIC0gMW4sXG4gICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjE2MC0xXWBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnQoXG4gICAgaXNPYmplY3QocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGlzIGNhaXJvIHR5cGUgc3RydWN0ICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGEganMgb2JqZWN0IChub3QgYXJyYXkpYFxuICApO1xuICBzdHJ1Y3RzW2lucHV0LnR5cGVdLm1lbWJlcnMuZm9yRWFjaCgoeyBuYW1lIH0pID0+IHtcbiAgICBhc3NlcnQoXG4gICAgICBPYmplY3Qua2V5cyhwYXJhbWV0ZXIpLmluY2x1ZGVzKG5hbWUpLFxuICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgaGF2ZSBhIHByb3BlcnR5ICR7bmFtZX1gXG4gICAgKTtcbiAgfSk7XG59O1xudmFyIHZhbGlkYXRlRW51bSA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydChcbiAgICBpc09iamVjdChwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgY2Fpcm8gdHlwZSBFbnVtICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGEganMgb2JqZWN0IChub3QgYXJyYXkpYFxuICApO1xuICBjb25zdCBtZXRob2RzS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJhbWV0ZXIpKTtcbiAgY29uc3Qga2V5cyA9IFsuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwYXJhbWV0ZXIpLCAuLi5tZXRob2RzS2V5c107XG4gIGlmIChpc1R5cGVPcHRpb24oaW5wdXQudHlwZSkgJiYga2V5cy5pbmNsdWRlcyhcImlzU29tZVwiKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNOb25lXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc1R5cGVSZXN1bHQoaW5wdXQudHlwZSkgJiYga2V5cy5pbmNsdWRlcyhcImlzT2tcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzRXJyXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChrZXlzLmluY2x1ZGVzKFwidmFyaWFudFwiKSAmJiBrZXlzLmluY2x1ZGVzKFwiYWN0aXZlVmFyaWFudFwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFZhbGlkYXRlIEVudW06IGFyZ3VtZW50ICR7aW5wdXQubmFtZX0sIHR5cGUgJHtpbnB1dC50eXBlfSwgdmFsdWUgcmVjZWl2ZWQgXCIke3BhcmFtZXRlcn1cIiwgaXMgbm90IGFuIEVudW0uYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVR1cGxlID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KGlzT2JqZWN0KHBhcmFtZXRlciksIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgdHVwbGUgKGRlZmluZWQgYXMgb2JqZWN0KWApO1xufTtcbnZhciB2YWxpZGF0ZUFycmF5ID0gKHBhcmFtZXRlckFycmF5LCBpbnB1dCwgc3RydWN0cywgZW51bXMpID0+IHtcbiAgY29uc3QgaXNOb3JtYWxBcnJheSA9IGlzVHlwZUFycmF5KGlucHV0LnR5cGUpO1xuICBjb25zdCBiYXNlVHlwZSA9IGlzTm9ybWFsQXJyYXkgPyBnZXRBcnJheVR5cGUoaW5wdXQudHlwZSkgOiBDYWlyb0ZpeGVkQXJyYXkuZ2V0Rml4ZWRBcnJheVR5cGUoaW5wdXQudHlwZSk7XG4gIGlmIChpc05vcm1hbEFycmF5ICYmIGlzVHlwZUZlbHQoYmFzZVR5cGUpICYmIGlzTG9uZ1RleHQocGFyYW1ldGVyQXJyYXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBwYXJhbWV0ZXIgPSBbXTtcbiAgaWYgKGlzTm9ybWFsQXJyYXkpIHtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJBcnJheSksIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGFuIEFycmF5YCk7XG4gICAgcGFyYW1ldGVyID0gcGFyYW1ldGVyQXJyYXk7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIEFycmF5LmlzQXJyYXkocGFyYW1ldGVyQXJyYXkpOlxuICAgICAgICBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJBcnJheTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHR5cGVvZiBwYXJhbWV0ZXJBcnJheSA9PT0gXCJvYmplY3RcIjpcbiAgICAgICAgcGFyYW1ldGVyID0gT2JqZWN0LnZhbHVlcyhwYXJhbWV0ZXJBcnJheSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGFuIEFycmF5IG9yIGFuIG9iamVjdC5gKTtcbiAgICB9XG4gIH1cbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVGZWx0KGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChwYXJhbSkgPT4gdmFsaWRhdGVGZWx0KHBhcmFtLCBpbnB1dCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVUdXBsZShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlVHVwbGUoaXQsIHsgbmFtZTogaW5wdXQubmFtZSwgdHlwZTogYmFzZVR5cGUgfSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVBcnJheShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaChcbiAgICAgICAgKHBhcmFtKSA9PiB2YWxpZGF0ZUFycmF5KHBhcmFtLCB7IG5hbWU6IFwiXCIsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMsIGVudW1zKVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaXNUeXBlU3RydWN0KGJhc2VUeXBlLCBzdHJ1Y3RzKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKFxuICAgICAgICAoaXQpID0+IHZhbGlkYXRlU3RydWN0KGl0LCB7IG5hbWU6IGlucHV0Lm5hbWUsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVFbnVtKGJhc2VUeXBlLCBlbnVtcyk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlRW51bShpdCwgeyBuYW1lOiBpbnB1dC5uYW1lLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIChpc1R5cGVVaW50KGJhc2VUeXBlKSB8fCBpc1R5cGVMaXRlcmFsKGJhc2VUeXBlKSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgocGFyYW0pID0+IHZhbGlkYXRlVWludChwYXJhbSwgeyBuYW1lOiBcIlwiLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZUJvb2woYmFzZVR5cGUpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKHBhcmFtKSA9PiB2YWxpZGF0ZUJvb2wocGFyYW0sIGlucHV0KSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICk7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVOb25aZXJvID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgY29uc3QgYmFzZVR5cGUgPSBnZXRBcnJheVR5cGUoaW5wdXQudHlwZSk7XG4gIGFzc2VydChcbiAgICBpc1R5cGVVaW50KGJhc2VUeXBlKSAmJiBiYXNlVHlwZSAhPT0gQ2Fpcm9VaW50NTEyLmFiaVNlbGVjdG9yIHx8IGlzVHlwZUZlbHQoYmFzZVR5cGUpLFxuICAgIGBWYWxpZGF0ZTogJHtpbnB1dC5uYW1lfSB0eXBlIGlzIG5vdCBhdXRob3JpemVkIGZvciBOb25aZXJvIHR5cGUuYFxuICApO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUZlbHQoYmFzZVR5cGUpOlxuICAgICAgdmFsaWRhdGVGZWx0KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBCaWdJbnQocGFyYW1ldGVyLnRvU3RyaW5nKDEwKSkgPiAwLFxuICAgICAgICBcIlZhbGlkYXRlOiB2YWx1ZSAwIGlzIG5vdCBhdXRob3JpemVkIGluIE5vblplcm8gZmVsdDI1MiB0eXBlLlwiXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVVaW50KGJhc2VUeXBlKTpcbiAgICAgIHZhbGlkYXRlVWludChwYXJhbWV0ZXIsIHsgbmFtZTogXCJcIiwgdHlwZTogYmFzZVR5cGUgfSk7XG4gICAgICBzd2l0Y2ggKGJhc2VUeXBlKSB7XG4gICAgICAgIGNhc2UgVWludC51MjU2OlxuICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgIG5ldyBDYWlyb1VpbnQyNTYocGFyYW1ldGVyKS50b0JpZ0ludCgpID4gMCxcbiAgICAgICAgICAgIFwiVmFsaWRhdGU6IHZhbHVlIDAgaXMgbm90IGF1dGhvcml6ZWQgaW4gTm9uWmVybyB1aW50MjU2IHR5cGUuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgIHRvQmlnSW50KHBhcmFtZXRlcikgPiAwLFxuICAgICAgICAgICAgXCJWYWxpZGF0ZTogdmFsdWUgMCBpcyBub3QgYXV0aG9yaXplZCBpbiBOb25aZXJvIHVpbnQgdHlwZS5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlIFwiJHtwYXJhbWV0ZXJ9XCJgXG4gICAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZHMoYWJpTWV0aG9kLCBhcmdzLCBzdHJ1Y3RzLCBlbnVtcykge1xuICBhYmlNZXRob2QuaW5wdXRzLnJlZHVjZSgoYWNjLCBpbnB1dCkgPT4ge1xuICAgIGNvbnN0IHBhcmFtZXRlciA9IGFyZ3NbYWNjXTtcbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgaXNMZW4oaW5wdXQubmFtZSk6XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICBjYXNlIGlzVHlwZUZlbHQoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlRmVsdChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUJ5dGVzMzEoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlQnl0ZXMzMShwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIChpc1R5cGVVaW50KGlucHV0LnR5cGUpIHx8IGlzVHlwZUxpdGVyYWwoaW5wdXQudHlwZSkpOlxuICAgICAgICB2YWxpZGF0ZVVpbnQocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVCb29sKGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZUJvb2wocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVCeXRlQXJyYXkoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlQnl0ZUFycmF5KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgKGlzVHlwZUFycmF5KGlucHV0LnR5cGUpIHx8IENhaXJvRml4ZWRBcnJheS5pc1R5cGVGaXhlZEFycmF5KGlucHV0LnR5cGUpKTpcbiAgICAgICAgdmFsaWRhdGVBcnJheShwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVTdHJ1Y3QoaW5wdXQudHlwZSwgc3RydWN0cyk6XG4gICAgICAgIHZhbGlkYXRlU3RydWN0KHBhcmFtZXRlciwgaW5wdXQsIHN0cnVjdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlRW51bShpbnB1dC50eXBlLCBlbnVtcyk6XG4gICAgICAgIHZhbGlkYXRlRW51bShwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZVR1cGxlKGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZVR1cGxlKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlTm9uWmVybyhpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVOb25aZXJvKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYyArIDE7XG4gIH0sIDApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvaW5kZXgudHNcbnZhciBDYWxsRGF0YSA9IGNsYXNzIF9DYWxsRGF0YSB7XG4gIGFiaTtcbiAgcGFyc2VyO1xuICBzdHJ1Y3RzO1xuICBlbnVtcztcbiAgY29uc3RydWN0b3IoYWJpKSB7XG4gICAgdGhpcy5zdHJ1Y3RzID0gX0NhbGxEYXRhLmdldEFiaVN0cnVjdChhYmkpO1xuICAgIHRoaXMuZW51bXMgPSBfQ2FsbERhdGEuZ2V0QWJpRW51bShhYmkpO1xuICAgIHRoaXMucGFyc2VyID0gY3JlYXRlQWJpUGFyc2VyKGFiaSk7XG4gICAgdGhpcy5hYmkgPSB0aGlzLnBhcnNlci5nZXRMZWdhY3lGb3JtYXQoKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kIGFzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9uZXMgaW4gdGhlIGFiaVxuICAgKiBAcGFyYW0gdHlwZSBWYWxpZGF0ZVR5cGUgLSB0eXBlIG9mIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBuYW1lIG9mIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIGFyZ3MgQXJnc09yQ2FsbGRhdGEgLSBhcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICovXG4gIHZhbGlkYXRlKHR5cGUsIG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgaWYgKHR5cGUgIT09IFZhbGlkYXRlVHlwZS5ERVBMT1kpIHtcbiAgICAgIGNvbnN0IGludm9jYWJsZUZ1bmN0aW9uTmFtZXMgPSB0aGlzLmFiaS5maWx0ZXIoKGFiaSkgPT4ge1xuICAgICAgICBpZiAoYWJpLnR5cGUgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpc1ZpZXcgPSBhYmkuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBhYmkuc3RhdGVfbXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCI7XG4gICAgICAgIHJldHVybiB0eXBlID09PSBWYWxpZGF0ZVR5cGUuSU5WT0tFID8gIWlzVmlldyA6IGlzVmlldztcbiAgICAgIH0pLm1hcCgoYWJpKSA9PiBhYmkubmFtZSk7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIGludm9jYWJsZUZ1bmN0aW9uTmFtZXMuaW5jbHVkZXMobWV0aG9kKSxcbiAgICAgICAgYCR7dHlwZSA9PT0gVmFsaWRhdGVUeXBlLklOVk9LRSA/IFwiaW52b2NhYmxlXCIgOiBcInZpZXdhYmxlXCJ9IG1ldGhvZCBub3QgZm91bmQgaW4gYWJpYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYWJpTWV0aG9kID0gdGhpcy5hYmkuZmluZChcbiAgICAgIChhYmkpID0+IHR5cGUgPT09IFZhbGlkYXRlVHlwZS5ERVBMT1kgPyBhYmkubmFtZSA9PT0gbWV0aG9kICYmIGFiaS50eXBlID09PSBcImNvbnN0cnVjdG9yXCIgOiBhYmkubmFtZSA9PT0gbWV0aG9kICYmIGFiaS50eXBlID09PSBcImZ1bmN0aW9uXCJcbiAgICApO1xuICAgIGlmIChpc05vQ29uc3RydWN0b3JWYWxpZChtZXRob2QsIGFyZ3MsIGFiaU1ldGhvZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRzTGVuZ3RoID0gdGhpcy5wYXJzZXIubWV0aG9kSW5wdXRzTGVuZ3RoKGFiaU1ldGhvZCk7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSBpbnB1dHNMZW5ndGgpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzLCBleHBlY3RlZCAke2lucHV0c0xlbmd0aH0gYXJndW1lbnRzLCBidXQgZ290ICR7YXJncy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgdmFsaWRhdGVGaWVsZHMoYWJpTWV0aG9kLCBhcmdzLCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpO1xuICB9XG4gIC8qKlxuICAgKiBDb21waWxlIGNvbnRyYWN0IGNhbGxEYXRhIHdpdGggYWJpXG4gICAqIFBhcnNlIHRoZSBjYWxsZGF0YSBieSB1c2luZyBpbnB1dCBmaWVsZHMgZnJvbSB0aGUgYWJpIGZvciB0aGF0IG1ldGhvZFxuICAgKiBAcGFyYW0gbWV0aG9kIHN0cmluZyAtIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSBhcmdzQ2FsbGRhdGEgUmF3QXJncyAtIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1ldGhvZC4gQ2FuIGJlIGFuIGFycmF5IG9mIGFyZ3VtZW50cyAoaW4gdGhlIG9yZGVyIG9mIGFiaSBkZWZpbml0aW9uKSwgb3IgYW4gb2JqZWN0IGNvbnN0cnVjdGVkIGluIGNvbmZvcm1pdHkgd2l0aCBhYmkgKGluIHRoaXMgY2FzZSwgdGhlIHBhcmFtZXRlciBjYW4gYmUgaW4gYSB3cm9uZyBvcmRlcikuXG4gICAqIEByZXR1cm4gQ2FsbGRhdGEgLSBwYXJzZWQgYXJndW1lbnRzIGluIGZvcm1hdCB0aGF0IGNvbnRyYWN0IGlzIGV4cGVjdGluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGNhbGxkYXRhID0gbXlDYWxsRGF0YS5jb21waWxlKFwiY29uc3RydWN0b3JcIiwgW1wiMHgzNGFcIiwgWzEsIDNuXV0pO1xuICAgKiBgYGBcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBjYWxsZGF0YTIgPSBteUNhbGxEYXRhLmNvbXBpbGUoXCJjb25zdHJ1Y3RvclwiLCB7bGlzdDpbMSwgM25dLCBiYWxhbmNlOlwiMHgzNFwifSk7IC8vIHdyb25nIG9yZGVyIGlzIHZhbGlkXG4gICAqIGBgYFxuICAgKi9cbiAgY29tcGlsZShtZXRob2QsIGFyZ3NDYWxsZGF0YSkge1xuICAgIGNvbnN0IGFiaU1ldGhvZCA9IHRoaXMuYWJpLmZpbmQoKGFiaUZ1bmN0aW9uKSA9PiBhYmlGdW5jdGlvbi5uYW1lID09PSBtZXRob2QpO1xuICAgIGlmIChpc05vQ29uc3RydWN0b3JWYWxpZChtZXRob2QsIGFyZ3NDYWxsZGF0YSwgYWJpTWV0aG9kKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgYXJncztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzQ2FsbGRhdGEpKSB7XG4gICAgICBhcmdzID0gYXJnc0NhbGxkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcmRlcmVkT2JqZWN0ID0gb3JkZXJQcm9wc0J5QWJpKFxuICAgICAgICBhcmdzQ2FsbGRhdGEsXG4gICAgICAgIGFiaU1ldGhvZC5pbnB1dHMsXG4gICAgICAgIHRoaXMuc3RydWN0cyxcbiAgICAgICAgdGhpcy5lbnVtc1xuICAgICAgKTtcbiAgICAgIGFyZ3MgPSBPYmplY3QudmFsdWVzKG9yZGVyZWRPYmplY3QpO1xuICAgICAgdmFsaWRhdGVGaWVsZHMoYWJpTWV0aG9kLCBhcmdzLCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpO1xuICAgIH1cbiAgICBjb25zdCBhcmdzSXRlcmF0b3IgPSBhcmdzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBjYWxsQXJyYXkgPSBhYmlNZXRob2QuaW5wdXRzLnJlZHVjZShcbiAgICAgIChhY2MsIGlucHV0KSA9PiBpc0xlbihpbnB1dC5uYW1lKSAmJiAhaXNDYWlybzFUeXBlKGlucHV0LnR5cGUpID8gYWNjIDogYWNjLmNvbmNhdChwYXJzZUNhbGxkYXRhRmllbGQoYXJnc0l0ZXJhdG9yLCBpbnB1dCwgdGhpcy5zdHJ1Y3RzLCB0aGlzLmVudW1zKSksXG4gICAgICBbXVxuICAgICk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhbGxBcnJheSwgXCJfX2NvbXBpbGVkX19cIiwge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBjYWxsQXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXBpbGUgY29udHJhY3QgY2FsbERhdGEgd2l0aG91dCBhYmlcbiAgICogQHBhcmFtIHJhd0FyZ3MgUmF3QXJncyByZXByZXNlbnRpbmcgY2Fpcm8gbWV0aG9kIGFyZ3VtZW50cyBvciBzdHJpbmcgYXJyYXkgb2YgY29tcGlsZWQgZGF0YVxuICAgKiBAcmV0dXJucyBDYWxsZGF0YVxuICAgKi9cbiAgc3RhdGljIGNvbXBpbGUocmF3QXJncykge1xuICAgIGNvbnN0IGNyZWF0ZVRyZWUgPSAob2JqKSA9PiB7XG4gICAgICBjb25zdCBnZXRFbnRyaWVzID0gKG8sIHByZWZpeCA9IFwiLlwiKSA9PiB7XG4gICAgICAgIGNvbnN0IG9lID0gQXJyYXkuaXNBcnJheShvKSA/IFtvLmxlbmd0aC50b1N0cmluZygpLCAuLi5vXSA6IG87XG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhvZSkuZmxhdE1hcCgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gdjtcbiAgICAgICAgICBpZiAoayA9PT0gXCJlbnRyeXBvaW50XCIpIHZhbHVlID0gZ2V0U2VsZWN0b3JGcm9tTmFtZSh2YWx1ZSk7XG4gICAgICAgICAgZWxzZSBpZiAoaXNMb25nVGV4dCh2YWx1ZSkpIHZhbHVlID0gYnl0ZUFycmF5RnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgY29uc3Qga2sgPSBBcnJheS5pc0FycmF5KG9lKSAmJiBrID09PSBcIjBcIiA/IFwiJCRsZW5cIiA6IGs7XG4gICAgICAgICAgaWYgKGlzQmlnSW50KHZhbHVlKSkgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdCh2YWx1ZSldXTtcbiAgICAgICAgICBpZiAoT2JqZWN0KHZhbHVlKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZHNLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gWy4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSwgLi4ubWV0aG9kc0tleXNdO1xuICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoXCJpc1NvbWVcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzTm9uZVwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBteU9wdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICBjb25zdCB2YXJpYW50TmIgPSBteU9wdGlvbi5pc1NvbWUoKSA/IENhaXJvT3B0aW9uVmFyaWFudC5Tb21lIDogQ2Fpcm9PcHRpb25WYXJpYW50Lk5vbmU7XG4gICAgICAgICAgICAgIGlmIChteU9wdGlvbi5pc1NvbWUoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh7IDA6IHZhcmlhbnROYiwgMTogbXlPcHRpb24udW53cmFwKCkgfSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KHZhcmlhbnROYildXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKFwiaXNPa1wiKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNFcnJcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXlSZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgY29uc3QgdmFyaWFudE5iID0gbXlSZXN1bHQuaXNPaygpID8gQ2Fpcm9SZXN1bHRWYXJpYW50Lk9rIDogQ2Fpcm9SZXN1bHRWYXJpYW50LkVycjtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVudHJpZXMoeyAwOiB2YXJpYW50TmIsIDE6IG15UmVzdWx0LnVud3JhcCgpIH0sIGAke3ByZWZpeH0ke2trfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKFwidmFyaWFudFwiKSAmJiBrZXlzLmluY2x1ZGVzKFwiYWN0aXZlVmFyaWFudFwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBteUVudW0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IG15RW51bS5hY3RpdmVWYXJpYW50KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGxpc3RWYXJpYW50cyA9IE9iamVjdC5rZXlzKG15RW51bS52YXJpYW50KTtcbiAgICAgICAgICAgICAgY29uc3QgYWN0aXZlVmFyaWFudE5iID0gbGlzdFZhcmlhbnRzLmZpbmRJbmRleChcbiAgICAgICAgICAgICAgICAodmFyaWFudCkgPT4gdmFyaWFudCA9PT0gYWN0aXZlVmFyaWFudFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG15RW51bS51bndyYXAoKSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhteUVudW0udW53cmFwKCkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQoYWN0aXZlVmFyaWFudE5iKV1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHsgMDogYWN0aXZlVmFyaWFudE5iLCAxOiBteUVudW0udW53cmFwKCkgfSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldEVudHJpZXModmFsdWUsIGAke3ByZWZpeH0ke2trfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdCh2YWx1ZSldXTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmZyb21FbnRyaWVzKGdldEVudHJpZXMob2JqKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgbGV0IGNhbGxUcmVlQXJyYXk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJhd0FyZ3MpKSB7XG4gICAgICBjb25zdCBjYWxsVHJlZSA9IGNyZWF0ZVRyZWUocmF3QXJncyk7XG4gICAgICBjYWxsVHJlZUFycmF5ID0gT2JqZWN0LnZhbHVlcyhjYWxsVHJlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNhbGxPYmogPSB7IC4uLnJhd0FyZ3MgfTtcbiAgICAgIGNvbnN0IGNhbGxUcmVlID0gY3JlYXRlVHJlZShjYWxsT2JqKTtcbiAgICAgIGNhbGxUcmVlQXJyYXkgPSBPYmplY3QudmFsdWVzKGNhbGxUcmVlKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhbGxUcmVlQXJyYXksIFwiX19jb21waWxlZF9fXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbFRyZWVBcnJheTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgZWxlbWVudHMgb2YgdGhlIHJlc3BvbnNlIGFycmF5IGFuZCBzdHJ1Y3R1cmluZyB0aGVtIGludG8gcmVzcG9uc2Ugb2JqZWN0XG4gICAqIEBwYXJhbSBtZXRob2Qgc3RyaW5nIC0gbWV0aG9kIG5hbWVcbiAgICogQHBhcmFtIHJlc3BvbnNlIHN0cmluZ1tdIC0gcmVzcG9uc2UgZnJvbSB0aGUgbWV0aG9kXG4gICAqIEByZXR1cm4gUmVzdWx0IC0gcGFyc2VkIHJlc3BvbnNlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGFiaVxuICAgKi9cbiAgcGFyc2UobWV0aG9kLCByZXNwb25zZSkge1xuICAgIGNvbnN0IHsgb3V0cHV0cyB9ID0gdGhpcy5hYmkuZmluZCgoYWJpKSA9PiBhYmkubmFtZSA9PT0gbWV0aG9kKTtcbiAgICBjb25zdCByZXNwb25zZUl0ZXJhdG9yID0gcmVzcG9uc2UuZmxhdCgpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBwYXJzZWQgPSBvdXRwdXRzLmZsYXQoKS5yZWR1Y2UoKGFjYywgb3V0cHV0LCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IHByb3BOYW1lID0gb3V0cHV0Lm5hbWUgPz8gaWR4O1xuICAgICAgYWNjW3Byb3BOYW1lXSA9IHJlc3BvbnNlUGFyc2VyKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgdGhpcy5zdHJ1Y3RzLCB0aGlzLmVudW1zLCBhY2MpO1xuICAgICAgaWYgKGFjY1twcm9wTmFtZV0gJiYgYWNjW2Ake3Byb3BOYW1lfV9sZW5gXSkge1xuICAgICAgICBkZWxldGUgYWNjW2Ake3Byb3BOYW1lfV9sZW5gXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJzZWQpLmxlbmd0aCA9PT0gMSAmJiAwIGluIHBhcnNlZCA/IHBhcnNlZFswXSA6IHBhcnNlZDtcbiAgfVxuICAvKipcbiAgICogRm9ybWF0IGNhaXJvIG1ldGhvZCByZXNwb25zZSBkYXRhIHRvIG5hdGl2ZSBqcyB2YWx1ZXMgYmFzZWQgb24gcHJvdmlkZWQgZm9ybWF0IHNjaGVtYVxuICAgKiBAcGFyYW0gbWV0aG9kIHN0cmluZyAtIGNhaXJvIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSByZXNwb25zZSBzdHJpbmdbXSAtIGNhaXJvIG1ldGhvZCByZXNwb25zZVxuICAgKiBAcGFyYW0gZm9ybWF0IG9iamVjdCAtIGZvcm1hdHRlciBvYmplY3Qgc2NoZW1hXG4gICAqIEByZXR1cm5zIFJlc3VsdCAtIHBhcnNlZCBhbmQgZm9ybWF0dGVkIHJlc3BvbnNlIG9iamVjdFxuICAgKi9cbiAgZm9ybWF0KG1ldGhvZCwgcmVzcG9uc2UsIGZvcm1hdCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2UobWV0aG9kLCByZXNwb25zZSk7XG4gICAgcmV0dXJuIGZvcm1hdHRlcihwYXJzZWQsIGZvcm1hdCk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciB0byBleHRyYWN0IHN0cnVjdHMgZnJvbSBhYmlcbiAgICogQHBhcmFtIGFiaSBBYmlcbiAgICogQHJldHVybnMgQWJpU3RydWN0cyAtIHN0cnVjdHMgZnJvbSBhYmlcbiAgICovXG4gIHN0YXRpYyBnZXRBYmlTdHJ1Y3QoYWJpKSB7XG4gICAgcmV0dXJuIGFiaS5maWx0ZXIoKGFiaUVudHJ5KSA9PiBhYmlFbnRyeS50eXBlID09PSBcInN0cnVjdFwiKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBhYmlFbnRyeSkgPT4gKHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBbYWJpRW50cnkubmFtZV06IGFiaUVudHJ5XG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIHRvIGV4dHJhY3QgZW51bXMgZnJvbSBhYmlcbiAgICogQHBhcmFtIGFiaSBBYmlcbiAgICogQHJldHVybnMgQWJpRW51bXMgLSBlbnVtcyBmcm9tIGFiaVxuICAgKi9cbiAgc3RhdGljIGdldEFiaUVudW0oYWJpKSB7XG4gICAgY29uc3QgZnVsbEVudW1MaXN0ID0gYWJpLmZpbHRlcigoYWJpRW50cnkpID0+IGFiaUVudHJ5LnR5cGUgPT09IFwiZW51bVwiKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBhYmlFbnRyeSkgPT4gKHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBbYWJpRW50cnkubmFtZV06IGFiaUVudHJ5XG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICBkZWxldGUgZnVsbEVudW1MaXN0W1wiY29yZTo6Ym9vbFwiXTtcbiAgICByZXR1cm4gZnVsbEVudW1MaXN0O1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXI6IENvbXBpbGUgSGV4Q2FsbGRhdGEgfCBSYXdDYWxsZGF0YSB8IFJhd0FyZ3NcbiAgICogQHBhcmFtIHJhd0NhbGxkYXRhIEhleENhbGxkYXRhIHwgUmF3Q2FsbGRhdGEgfCBSYXdBcmdzXG4gICAqIEByZXR1cm5zIENhbGxkYXRhXG4gICAqL1xuICBzdGF0aWMgdG9DYWxsZGF0YShyYXdDYWxsZGF0YSA9IFtdKSB7XG4gICAgcmV0dXJuIF9DYWxsRGF0YS5jb21waWxlKHJhd0NhbGxkYXRhKTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyOiBDb252ZXJ0IHJhdyB0byBIZXhDYWxsZGF0YVxuICAgKiBAcGFyYW0gcmF3IEhleENhbGxkYXRhIHwgUmF3Q2FsbGRhdGEgfCBSYXdBcmdzXG4gICAqIEByZXR1cm5zIEhleENhbGxkYXRhXG4gICAqL1xuICBzdGF0aWMgdG9IZXgocmF3ID0gW10pIHtcbiAgICBjb25zdCBjYWxsZGF0YSA9IF9DYWxsRGF0YS5jb21waWxlKHJhdyk7XG4gICAgcmV0dXJuIGNhbGxkYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBlbGVtZW50cyBvZiBhIGNvbnRyYWN0IHJlc3BvbnNlIGFuZCBzdHJ1Y3R1cmUgdGhlbSBpbnRvIG9uZSBvciBzZXZlcmFsIFJlc3VsdC5cbiAgICogSW4gQ2Fpcm8gMCwgYXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgKiBAcGFyYW0gdHlwZUNhaXJvIHN0cmluZyBvciBzdHJpbmdbXSAtIENhaXJvIHR5cGUgbmFtZSwgZXggOiBcImhlbGxvOjpoZWxsbzo6VXNlckRhdGFcIlxuICAgKiBAcGFyYW0gcmVzcG9uc2Ugc3RyaW5nW10gLSBzZXJpYWxpemVkIGRhdGEgY29ycmVzcG9uZGluZyB0byB0eXBlQ2Fpcm8uXG4gICAqIEByZXR1cm4gUmVzdWx0IG9yIFJlc3VsdFtdIC0gcGFyc2VkIHJlc3BvbnNlIGNvcnJlc3BvbmRpbmcgdG8gdHlwZURhdGEuXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlczI9aGVsbG9DYWxsRGF0YS5kZWNvZGVQYXJhbWV0ZXJzKFwiaGVsbG86OmhlbGxvOjpVc2VyRGF0YVwiLFtcIjB4MTIzNDU2XCIsXCIweDFcIl0pO1xuICAgKiByZXN1bHQgPSB7IGFkZHJlc3M6IDExOTMwNDZuLCBpc19jbGFpbWVkOiB0cnVlIH1cbiAgICovXG4gIGRlY29kZVBhcmFtZXRlcnModHlwZUNhaXJvLCByZXNwb25zZSkge1xuICAgIGNvbnN0IHR5cGVDYWlyb0FycmF5ID0gQXJyYXkuaXNBcnJheSh0eXBlQ2Fpcm8pID8gdHlwZUNhaXJvIDogW3R5cGVDYWlyb107XG4gICAgY29uc3QgcmVzcG9uc2VJdGVyYXRvciA9IHJlc3BvbnNlLmZsYXQoKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgZGVjb2RlZEFycmF5ID0gdHlwZUNhaXJvQXJyYXkubWFwKFxuICAgICAgKHR5cGVQYXJhbSkgPT4gcmVzcG9uc2VQYXJzZXIoXG4gICAgICAgIHJlc3BvbnNlSXRlcmF0b3IsXG4gICAgICAgIHsgbmFtZTogXCJcIiwgdHlwZTogdHlwZVBhcmFtIH0sXG4gICAgICAgIHRoaXMuc3RydWN0cyxcbiAgICAgICAgdGhpcy5lbnVtc1xuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIGRlY29kZWRBcnJheS5sZW5ndGggPT09IDEgPyBkZWNvZGVkQXJyYXlbMF0gOiBkZWNvZGVkQXJyYXk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9oYXNoL2luZGV4LnRzXG52YXIgaGFzaF9leHBvcnRzID0ge307XG5fX2V4cG9ydChoYXNoX2V4cG9ydHMsIHtcbiAgY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2g6ICgpID0+IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoLFxuICBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMyxcbiAgY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMsXG4gIGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMixcbiAgY2FsY3VsYXRlTDJNZXNzYWdlVHhIYXNoOiAoKSA9PiBjYWxjdWxhdGVMMk1lc3NhZ2VUeEhhc2gsXG4gIGNvbXB1dGVDb21waWxlZENsYXNzSGFzaDogKCkgPT4gY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoLFxuICBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVDb250cmFjdENsYXNzSGFzaCxcbiAgY29tcHV0ZUhhc2hPbkVsZW1lbnRzOiAoKSA9PiBjb21wdXRlSGFzaE9uRWxlbWVudHMyLFxuICBjb21wdXRlSGludGVkQ2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlSGludGVkQ2xhc3NIYXNoLFxuICBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaCxcbiAgY29tcHV0ZVBlZGVyc2VuSGFzaDogKCkgPT4gY29tcHV0ZVBlZGVyc2VuSGFzaCxcbiAgY29tcHV0ZVBlZGVyc2VuSGFzaE9uRWxlbWVudHM6ICgpID0+IGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzLFxuICBjb21wdXRlUG9zZWlkb25IYXNoOiAoKSA9PiBjb21wdXRlUG9zZWlkb25IYXNoLFxuICBjb21wdXRlUG9zZWlkb25IYXNoT25FbGVtZW50czogKCkgPT4gY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHMsXG4gIGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaDogKCkgPT4gY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoLFxuICBmb3JtYXRTcGFjZXM6ICgpID0+IGZvcm1hdFNwYWNlcyxcbiAgZ2V0TDJNZXNzYWdlSGFzaDogKCkgPT4gZ2V0TDJNZXNzYWdlSGFzaCxcbiAgZ2V0U2VsZWN0b3I6ICgpID0+IGdldFNlbGVjdG9yLFxuICBnZXRTZWxlY3RvckZyb21OYW1lOiAoKSA9PiBnZXRTZWxlY3RvckZyb21OYW1lLFxuICBoYXNoQnl0ZUNvZGVTZWdtZW50czogKCkgPT4gaGFzaEJ5dGVDb2RlU2VnbWVudHMsXG4gIGtlY2Nha0JuOiAoKSA9PiBrZWNjYWtCbixcbiAgcG9zZWlkb246ICgpID0+IHBvc2VpZG9uLFxuICBzb2xpZGl0eVVpbnQyNTZQYWNrZWRLZWNjYWsyNTY6ICgpID0+IHNvbGlkaXR5VWludDI1NlBhY2tlZEtlY2NhazI1NixcbiAgc3RhcmtuZXRLZWNjYWs6ICgpID0+IHN0YXJrbmV0S2VjY2FrXG59KTtcbmltcG9ydCAqIGFzIHBvc2VpZG9uIGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3Bvc2VpZG9uXCI7XG5cbi8vIHNyYy91dGlscy9oYXNoL3RyYW5zYWN0aW9uSGFzaC92Mi50c1xudmFyIHYyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHYyX2V4cG9ydHMsIHtcbiAgY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlTDJNZXNzYWdlVHhIYXNoOiAoKSA9PiBjYWxjdWxhdGVMMk1lc3NhZ2VUeEhhc2gsXG4gIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb246ICgpID0+IGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbixcbiAgY29tcHV0ZUhhc2hPbkVsZW1lbnRzOiAoKSA9PiBjb21wdXRlSGFzaE9uRWxlbWVudHNcbn0pO1xuXG4vLyBzcmMvdXRpbHMvZWMudHNcbnZhciBlY19leHBvcnRzID0ge307XG5fX2V4cG9ydChlY19leHBvcnRzLCB7XG4gIHN0YXJrQ3VydmU6ICgpID0+IHN0YXJrQ3VydmUsXG4gIHdlaWVyc3RyYXNzOiAoKSA9PiB3ZWllcnN0cmFzc1xufSk7XG5pbXBvcnQgKiBhcyBzdGFya0N1cnZlIGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcbmltcG9ydCAqIGFzIHdlaWVyc3RyYXNzIGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3dlaWVyc3RyYXNzXCI7XG5cbi8vIHNyYy91dGlscy9oYXNoL3RyYW5zYWN0aW9uSGFzaC92Mi50c1xuZnVuY3Rpb24gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGRhdGEpIHtcbiAgcmV0dXJuIFsuLi5kYXRhLCBkYXRhLmxlbmd0aF0ucmVkdWNlKCh4LCB5KSA9PiBzdGFya0N1cnZlLnBlZGVyc2VuKHRvQmlnSW50KHgpLCB0b0JpZ0ludCh5KSksIDApLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24odHhIYXNoUHJlZml4LCB2ZXJzaW9uLCBjb250cmFjdEFkZHJlc3MsIGVudHJ5UG9pbnRTZWxlY3RvciwgY2FsbGRhdGEsIG1heEZlZSwgY2hhaW5JZCwgYWRkaXRpb25hbERhdGEgPSBbXSkge1xuICBjb25zdCBjYWxsZGF0YUhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMoY2FsbGRhdGEpO1xuICBjb25zdCBkYXRhVG9IYXNoID0gW1xuICAgIHR4SGFzaFByZWZpeCxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICBlbnRyeVBvaW50U2VsZWN0b3IsXG4gICAgY2FsbGRhdGFIYXNoLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIC4uLmFkZGl0aW9uYWxEYXRhXG4gIF07XG4gIHJldHVybiBjb21wdXRlSGFzaE9uRWxlbWVudHMoZGF0YVRvSGFzaCk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoKGNsYXNzSGFzaCwgc2VuZGVyQWRkcmVzcywgdmVyc2lvbiwgbWF4RmVlLCBjaGFpbklkLCBub25jZSwgY29tcGlsZWRDbGFzc0hhc2gpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbihcbiAgICBcIjB4NjQ2NTYzNmM2MTcyNjVcIiAvKiBERUNMQVJFICovLFxuICAgIHZlcnNpb24sXG4gICAgc2VuZGVyQWRkcmVzcyxcbiAgICAwLFxuICAgIFtjbGFzc0hhc2hdLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZSwgLi4uY29tcGlsZWRDbGFzc0hhc2ggPyBbY29tcGlsZWRDbGFzc0hhc2hdIDogW11dXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBzYWx0LCB2ZXJzaW9uLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlKSB7XG4gIGNvbnN0IGNhbGxkYXRhID0gW2NsYXNzSGFzaCwgc2FsdCwgLi4uY29uc3RydWN0b3JDYWxsZGF0YV07XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY0NjU3MDZjNmY3OTVmNjE2MzYzNmY3NTZlNzRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAwLFxuICAgIGNhbGxkYXRhLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaChjb250cmFjdEFkZHJlc3MsIHZlcnNpb24sIGNhbGxkYXRhLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY5NmU3NjZmNmI2NVwiIC8qIElOVk9LRSAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAwLFxuICAgIGNhbGxkYXRhLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUwyTWVzc2FnZVR4SGFzaChsMUZyb21BZGRyZXNzLCBsMlRvQWRkcmVzcywgbDJTZWxlY3RvciwgbDJDYWxsZGF0YSwgbDJDaGFpbklkLCBsMU5vbmNlKSB7XG4gIGNvbnN0IHBheWxvYWQgPSBbbDFGcm9tQWRkcmVzcywgLi4ubDJDYWxsZGF0YV07XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDZjMzE1ZjY4NjE2ZTY0NmM2NTcyXCIgLyogTDFfSEFORExFUiAqLyxcbiAgICAwLFxuICAgIGwyVG9BZGRyZXNzLFxuICAgIGdldFNlbGVjdG9yKGwyU2VsZWN0b3IpLFxuICAgIHBheWxvYWQsXG4gICAgMCxcbiAgICBsMkNoYWluSWQsXG4gICAgW2wxTm9uY2VdXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9oYXNoL3RyYW5zYWN0aW9uSGFzaC92My50c1xudmFyIHYzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHYzX2V4cG9ydHMsIHtcbiAgY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDIsXG4gIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gyLFxuICBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uOiAoKSA9PiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yLFxuICBlbmNvZGVSZXNvdXJjZUJvdW5kc0wxOiAoKSA9PiBlbmNvZGVSZXNvdXJjZUJvdW5kc0wxLFxuICBlbmNvZGVSZXNvdXJjZUJvdW5kc0wyOiAoKSA9PiBlbmNvZGVSZXNvdXJjZUJvdW5kc0wyLFxuICBoYXNoREFNb2RlOiAoKSA9PiBoYXNoREFNb2RlLFxuICBoYXNoRmVlRmllbGQ6ICgpID0+IGhhc2hGZWVGaWVsZFxufSk7XG5pbXBvcnQgeyBwb3NlaWRvbkhhc2hNYW55IH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xudmFyIEFUb0JJID0gKGFycmF5KSA9PiBhcnJheS5tYXAoKGl0KSA9PiBCaWdJbnQoaXQpKTtcbnZhciBEQVRBX0FWQUlMQUJJTElUWV9NT0RFX0JJVFMgPSAzMm47XG52YXIgTUFYX0FNT1VOVF9CSVRTID0gNjRuO1xudmFyIE1BWF9QUklDRV9QRVJfVU5JVF9CSVRTID0gMTI4bjtcbnZhciBSRVNPVVJDRV9WQUxVRV9PRkZTRVQgPSBNQVhfQU1PVU5UX0JJVFMgKyBNQVhfUFJJQ0VfUEVSX1VOSVRfQklUUztcbnZhciBMMV9HQVNfTkFNRSA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhcIkwxX0dBU1wiKSk7XG52YXIgTDJfR0FTX05BTUUgPSBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoXCJMMl9HQVNcIikpO1xuZnVuY3Rpb24gaGFzaERBTW9kZShub25jZURBTW9kZSwgZmVlREFNb2RlKSB7XG4gIHJldHVybiAoQmlnSW50KG5vbmNlREFNb2RlKSA8PCBEQVRBX0FWQUlMQUJJTElUWV9NT0RFX0JJVFMpICsgQmlnSW50KGZlZURBTW9kZSk7XG59XG5mdW5jdGlvbiBlbmNvZGVSZXNvdXJjZUJvdW5kc0wxKGJvdW5kcykge1xuICByZXR1cm4gKEwxX0dBU19OQU1FIDw8IFJFU09VUkNFX1ZBTFVFX09GRlNFVCkgKyAoQmlnSW50KGJvdW5kcy5sMV9nYXMubWF4X2Ftb3VudCkgPDwgTUFYX1BSSUNFX1BFUl9VTklUX0JJVFMpICsgQmlnSW50KGJvdW5kcy5sMV9nYXMubWF4X3ByaWNlX3Blcl91bml0KTtcbn1cbmZ1bmN0aW9uIGVuY29kZVJlc291cmNlQm91bmRzTDIoYm91bmRzKSB7XG4gIHJldHVybiAoTDJfR0FTX05BTUUgPDwgUkVTT1VSQ0VfVkFMVUVfT0ZGU0VUKSArIChCaWdJbnQoYm91bmRzLmwyX2dhcy5tYXhfYW1vdW50KSA8PCBNQVhfUFJJQ0VfUEVSX1VOSVRfQklUUykgKyBCaWdJbnQoYm91bmRzLmwyX2dhcy5tYXhfcHJpY2VfcGVyX3VuaXQpO1xufVxuZnVuY3Rpb24gaGFzaEZlZUZpZWxkKHRpcCwgYm91bmRzKSB7XG4gIGNvbnN0IEwxQm91bmQgPSBlbmNvZGVSZXNvdXJjZUJvdW5kc0wxKGJvdW5kcyk7XG4gIGNvbnN0IEwyQm91bmQgPSBlbmNvZGVSZXNvdXJjZUJvdW5kc0wyKGJvdW5kcyk7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55KFtCaWdJbnQodGlwKSwgTDFCb3VuZCwgTDJCb3VuZF0pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uMih0eEhhc2hQcmVmaXgsIHZlcnNpb24sIHNlbmRlckFkZHJlc3MsIGNoYWluSWQsIG5vbmNlLCB0aXAsIHBheW1hc3RlckRhdGEsIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLCByZXNvdXJjZUJvdW5kcywgYWRkaXRpb25hbERhdGEgPSBbXSkge1xuICBjb25zdCBmZWVGaWVsZEhhc2ggPSBoYXNoRmVlRmllbGQodGlwLCByZXNvdXJjZUJvdW5kcyk7XG4gIGNvbnN0IGRBTW9kZUhhc2ggPSBoYXNoREFNb2RlKG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKTtcbiAgY29uc3QgZGF0YVRvSGFzaCA9IEFUb0JJKFtcbiAgICB0eEhhc2hQcmVmaXgsXG4gICAgdmVyc2lvbixcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIGZlZUZpZWxkSGFzaCxcbiAgICBwb3NlaWRvbkhhc2hNYW55KEFUb0JJKHBheW1hc3RlckRhdGEpKSxcbiAgICBjaGFpbklkLFxuICAgIG5vbmNlLFxuICAgIGRBTW9kZUhhc2gsXG4gICAgLi4uQVRvQkkoYWRkaXRpb25hbERhdGEpXG4gIF0pO1xuICByZXR1cm4gdG9IZXgocG9zZWlkb25IYXNoTWFueShkYXRhVG9IYXNoKSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLCBzYWx0LCB2ZXJzaW9uLCBjaGFpbklkLCBub25jZSwgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSwgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIHJlc291cmNlQm91bmRzLCB0aXAsIHBheW1hc3RlckRhdGEpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjIoXG4gICAgXCIweDY0NjU3MDZjNmY3OTVmNjE2MzYzNmY3NTZlNzRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICBjaGFpbklkLFxuICAgIG5vbmNlLFxuICAgIHRpcCxcbiAgICBwYXltYXN0ZXJEYXRhLFxuICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgcmVzb3VyY2VCb3VuZHMsXG4gICAgW3Bvc2VpZG9uSGFzaE1hbnkoQVRvQkkoY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhKSksIGNsYXNzSGFzaCwgc2FsdF1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gyKGNsYXNzSGFzaCwgY29tcGlsZWRDbGFzc0hhc2gsIHNlbmRlckFkZHJlc3MsIHZlcnNpb24sIGNoYWluSWQsIG5vbmNlLCBhY2NvdW50RGVwbG95bWVudERhdGEsIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLCByZXNvdXJjZUJvdW5kcywgdGlwLCBwYXltYXN0ZXJEYXRhKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yKFxuICAgIFwiMHg2NDY1NjM2YzYxNzI2NVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgdmVyc2lvbixcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIGNoYWluSWQsXG4gICAgbm9uY2UsXG4gICAgdGlwLFxuICAgIEFUb0JJKHBheW1hc3RlckRhdGEpLFxuICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgcmVzb3VyY2VCb3VuZHMsXG4gICAgW3Bvc2VpZG9uSGFzaE1hbnkoQVRvQkkoYWNjb3VudERlcGxveW1lbnREYXRhKSksIGNsYXNzSGFzaCwgY29tcGlsZWRDbGFzc0hhc2hdXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2goc2VuZGVyQWRkcmVzcywgdmVyc2lvbiwgY29tcGlsZWRDYWxsZGF0YSwgY2hhaW5JZCwgbm9uY2UsIGFjY291bnREZXBsb3ltZW50RGF0YSwgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSwgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIHJlc291cmNlQm91bmRzLCB0aXAsIHBheW1hc3RlckRhdGEpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjIoXG4gICAgXCIweDY5NmU3NjZmNmI2NVwiIC8qIElOVk9LRSAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIHNlbmRlckFkZHJlc3MsXG4gICAgY2hhaW5JZCxcbiAgICBub25jZSxcbiAgICB0aXAsXG4gICAgcGF5bWFzdGVyRGF0YSxcbiAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIHJlc291cmNlQm91bmRzLFxuICAgIFtwb3NlaWRvbkhhc2hNYW55KEFUb0JJKGFjY291bnREZXBsb3ltZW50RGF0YSkpLCBwb3NlaWRvbkhhc2hNYW55KEFUb0JJKGNvbXBpbGVkQ2FsbGRhdGEpKV1cbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2hhc2gvdHJhbnNhY3Rpb25IYXNoL2luZGV4LnRzXG5mdW5jdGlvbiBpc1YzSW52b2tlVHgoYXJncykge1xuICByZXR1cm4gW2FwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjNdLmluY2x1ZGVzKGFyZ3MudmVyc2lvbik7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2gyKGFyZ3MpIHtcbiAgaWYgKGlzVjNJbnZva2VUeChhcmdzKSkge1xuICAgIHJldHVybiBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2goXG4gICAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgICBhcmdzLnZlcnNpb24sXG4gICAgICBhcmdzLmNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICBhcmdzLmNoYWluSWQsXG4gICAgICBhcmdzLm5vbmNlLFxuICAgICAgYXJncy5hY2NvdW50RGVwbG95bWVudERhdGEsXG4gICAgICBhcmdzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICBhcmdzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgYXJncy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIGFyZ3MudGlwLFxuICAgICAgYXJncy5wYXltYXN0ZXJEYXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoKFxuICAgIGFyZ3Muc2VuZGVyQWRkcmVzcyxcbiAgICBhcmdzLnZlcnNpb24sXG4gICAgYXJncy5jb21waWxlZENhbGxkYXRhLFxuICAgIGFyZ3MubWF4RmVlLFxuICAgIGFyZ3MuY2hhaW5JZCxcbiAgICBhcmdzLm5vbmNlXG4gICk7XG59XG5mdW5jdGlvbiBpc1YzRGVjbGFyZVR4KGFyZ3MpIHtcbiAgcmV0dXJuIFthcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzXS5pbmNsdWRlcyhhcmdzLnZlcnNpb24pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMoYXJncykge1xuICBpZiAoaXNWM0RlY2xhcmVUeChhcmdzKSkge1xuICAgIHJldHVybiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMihcbiAgICAgIGFyZ3MuY2xhc3NIYXNoLFxuICAgICAgYXJncy5jb21waWxlZENsYXNzSGFzaCxcbiAgICAgIGFyZ3Muc2VuZGVyQWRkcmVzcyxcbiAgICAgIGFyZ3MudmVyc2lvbixcbiAgICAgIGFyZ3MuY2hhaW5JZCxcbiAgICAgIGFyZ3Mubm9uY2UsXG4gICAgICBhcmdzLmFjY291bnREZXBsb3ltZW50RGF0YSxcbiAgICAgIGFyZ3Mubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgIGFyZ3MuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICBhcmdzLnJlc291cmNlQm91bmRzLFxuICAgICAgYXJncy50aXAsXG4gICAgICBhcmdzLnBheW1hc3RlckRhdGFcbiAgICApO1xuICB9XG4gIHJldHVybiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoKFxuICAgIGFyZ3MuY2xhc3NIYXNoLFxuICAgIGFyZ3Muc2VuZGVyQWRkcmVzcyxcbiAgICBhcmdzLnZlcnNpb24sXG4gICAgYXJncy5tYXhGZWUsXG4gICAgYXJncy5jaGFpbklkLFxuICAgIGFyZ3Mubm9uY2UsXG4gICAgYXJncy5jb21waWxlZENsYXNzSGFzaFxuICApO1xufVxuZnVuY3Rpb24gaXNWM0RlcGxveUFjY291bnRUeChhcmdzKSB7XG4gIHJldHVybiBbYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMywgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GM10uaW5jbHVkZXMoYXJncy52ZXJzaW9uKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gzKGFyZ3MpIHtcbiAgaWYgKGlzVjNEZXBsb3lBY2NvdW50VHgoYXJncykpIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDIoXG4gICAgICBhcmdzLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGFyZ3MuY2xhc3NIYXNoLFxuICAgICAgYXJncy5jb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICBhcmdzLnNhbHQsXG4gICAgICBhcmdzLnZlcnNpb24sXG4gICAgICBhcmdzLmNoYWluSWQsXG4gICAgICBhcmdzLm5vbmNlLFxuICAgICAgYXJncy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgYXJncy5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgIGFyZ3MucmVzb3VyY2VCb3VuZHMsXG4gICAgICBhcmdzLnRpcCxcbiAgICAgIGFyZ3MucGF5bWFzdGVyRGF0YVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2goXG4gICAgYXJncy5jb250cmFjdEFkZHJlc3MsXG4gICAgYXJncy5jbGFzc0hhc2gsXG4gICAgYXJncy5jb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgIGFyZ3Muc2FsdCxcbiAgICBhcmdzLnZlcnNpb24sXG4gICAgYXJncy5tYXhGZWUsXG4gICAgYXJncy5jaGFpbklkLFxuICAgIGFyZ3Mubm9uY2VcbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2hhc2gvY2xhc3NIYXNoLnRzXG5pbXBvcnQgeyBwb3NlaWRvbkhhc2hNYW55IGFzIHBvc2VpZG9uSGFzaE1hbnkyIH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xuZnVuY3Rpb24gY29tcHV0ZVBlZGVyc2VuSGFzaChhLCBiKSB7XG4gIHJldHVybiBzdGFya0N1cnZlLnBlZGVyc2VuKEJpZ0ludChhKSwgQmlnSW50KGIpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVQb3NlaWRvbkhhc2goYSwgYikge1xuICByZXR1cm4gdG9IZXgoc3RhcmtDdXJ2ZS5wb3NlaWRvbkhhc2goQmlnSW50KGEpLCBCaWdJbnQoYikpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIYXNoT25FbGVtZW50czIoZGF0YSkge1xuICByZXR1cm4gWy4uLmRhdGEsIGRhdGEubGVuZ3RoXS5yZWR1Y2UoKHgsIHkpID0+IHN0YXJrQ3VydmUucGVkZXJzZW4oQmlnSW50KHgpLCBCaWdJbnQoeSkpLCAwKS50b1N0cmluZygpO1xufVxudmFyIGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMjtcbmZ1bmN0aW9uIGNvbXB1dGVQb3NlaWRvbkhhc2hPbkVsZW1lbnRzKGRhdGEpIHtcbiAgcmV0dXJuIHRvSGV4KHBvc2VpZG9uSGFzaE1hbnkyKGRhdGEubWFwKCh4KSA9PiBCaWdJbnQoeCkpKSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaChzYWx0LCBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGRlcGxveWVyQWRkcmVzcykge1xuICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgY29uc3QgY29uc3RydWN0b3JDYWxsZGF0YUhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKGNvbXBpbGVkQ2FsbGRhdGEpO1xuICBjb25zdCBDT05UUkFDVF9BRERSRVNTX1BSRUZJWCA9IGZlbHQoXCIweDUzNTQ0MTUyNGI0ZTQ1NTQ1ZjQzNGY0ZTU0NTI0MTQzNTQ1ZjQxNDQ0NDUyNDU1MzUzXCIpO1xuICBjb25zdCBoYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihbXG4gICAgQ09OVFJBQ1RfQUREUkVTU19QUkVGSVgsXG4gICAgZGVwbG95ZXJBZGRyZXNzLFxuICAgIHNhbHQsXG4gICAgY2xhc3NIYXNoLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGFIYXNoXG4gIF0pO1xuICByZXR1cm4gdG9IZXgoQmlnSW50KGhhc2gpICUgQUREUl9CT1VORCk7XG59XG5mdW5jdGlvbiBudWxsU2tpcFJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PT0gXCJhdHRyaWJ1dGVzXCIgfHwga2V5ID09PSBcImFjY2Vzc2libGVfc2NvcGVzXCIpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwID8gdm9pZCAwIDogdmFsdWU7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJkZWJ1Z19pbmZvXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNwYWNlcyhqc29uMikge1xuICBsZXQgaW5zaWRlUXVvdGVzID0gZmFsc2U7XG4gIGNvbnN0IG5ld1N0cmluZyA9IFtdO1xuICBmb3IgKGNvbnN0IGNoYXIgb2YganNvbjIpIHtcbiAgICBpZiAoY2hhciA9PT0gJ1wiJyAmJiAobmV3U3RyaW5nLmxlbmd0aCA+IDAgJiYgbmV3U3RyaW5nLnNsaWNlKC0xKVswXSA9PT0gXCJcXFxcXCIpID09PSBmYWxzZSkge1xuICAgICAgaW5zaWRlUXVvdGVzID0gIWluc2lkZVF1b3RlcztcbiAgICB9XG4gICAgaWYgKGluc2lkZVF1b3Rlcykge1xuICAgICAgbmV3U3RyaW5nLnB1c2goY2hhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0cmluZy5wdXNoKGNoYXIgPT09IFwiOlwiID8gXCI6IFwiIDogY2hhciA9PT0gXCIsXCIgPyBcIiwgXCIgOiBjaGFyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1N0cmluZy5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUhpbnRlZENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KSB7XG4gIGNvbnN0IHsgYWJpLCBwcm9ncmFtIH0gPSBjb21waWxlZENvbnRyYWN0O1xuICBjb25zdCBjb250cmFjdENsYXNzID0geyBhYmksIHByb2dyYW0gfTtcbiAgY29uc3Qgc2VyaWFsaXplZEpzb24gPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5Mihjb250cmFjdENsYXNzLCBudWxsU2tpcFJlcGxhY2VyKSk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoc2VyaWFsaXplZEpzb24pKS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSBpc1N0cmluZyhjb250cmFjdCkgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIGNvbnN0IGFwaVZlcnNpb24gPSB0b0hleChBUElfVkVSU0lPTik7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihcbiAgICBjb21waWxlZENvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLkVYVEVSTkFMLmZsYXRNYXAoKGUpID0+IFtlLnNlbGVjdG9yLCBlLm9mZnNldF0pXG4gICk7XG4gIGNvbnN0IGwxSGFuZGxlckVudHJ5UG9pbnRzSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50czIoXG4gICAgY29tcGlsZWRDb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZS5MMV9IQU5ETEVSLmZsYXRNYXAoKGUpID0+IFtlLnNlbGVjdG9yLCBlLm9mZnNldF0pXG4gICk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKFxuICAgIGNvbXBpbGVkQ29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IuZmxhdE1hcCgoZSkgPT4gW2Uuc2VsZWN0b3IsIGUub2Zmc2V0XSlcbiAgKTtcbiAgY29uc3QgYnVpbHRpbnNIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihcbiAgICBjb21waWxlZENvbnRyYWN0LnByb2dyYW0uYnVpbHRpbnMubWFwKChzKSA9PiBlbmNvZGVTaG9ydFN0cmluZyhzKSlcbiAgKTtcbiAgY29uc3QgaGludGVkQ2xhc3NIYXNoID0gY29tcHV0ZUhpbnRlZENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KTtcbiAgY29uc3QgZGF0YUhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKGNvbXBpbGVkQ29udHJhY3QucHJvZ3JhbS5kYXRhKTtcbiAgcmV0dXJuIGNvbXB1dGVIYXNoT25FbGVtZW50czIoW1xuICAgIGFwaVZlcnNpb24sXG4gICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgbDFIYW5kbGVyRW50cnlQb2ludHNIYXNoLFxuICAgIGNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2gsXG4gICAgYnVpbHRpbnNIYXNoLFxuICAgIGhpbnRlZENsYXNzSGFzaCxcbiAgICBkYXRhSGFzaFxuICBdKTtcbn1cbmZ1bmN0aW9uIGhhc2hCdWlsdGlucyhidWlsdGlucykge1xuICByZXR1cm4gcG9zZWlkb25IYXNoTWFueTIoXG4gICAgYnVpbHRpbnMuZmxhdE1hcCgoaXQpID0+IHtcbiAgICAgIHJldHVybiBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoaXQpKTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gaGFzaEVudHJ5UG9pbnQoZGF0YSkge1xuICBjb25zdCBiYXNlID0gZGF0YS5mbGF0TWFwKChpdCkgPT4ge1xuICAgIHJldHVybiBbQmlnSW50KGl0LnNlbGVjdG9yKSwgQmlnSW50KGl0Lm9mZnNldCksIGhhc2hCdWlsdGlucyhpdC5idWlsdGlucyldO1xuICB9KTtcbiAgcmV0dXJuIHBvc2VpZG9uSGFzaE1hbnkyKGJhc2UpO1xufVxuZnVuY3Rpb24gaGFzaEJ5dGVDb2RlU2VnbWVudHMoY2FzbSkge1xuICBjb25zdCBieXRlQ29kZSA9IGNhc20uYnl0ZWNvZGUubWFwKChuKSA9PiBCaWdJbnQobikpO1xuICBjb25zdCBieXRlY29kZVNlZ21lbnRMZW5ndGhzID0gY2FzbS5ieXRlY29kZV9zZWdtZW50X2xlbmd0aHMgPz8gW107XG4gIGxldCBzZWdtZW50U3RhcnQgPSAwO1xuICBjb25zdCBoYXNoTGVhdmVzID0gYnl0ZWNvZGVTZWdtZW50TGVuZ3Rocy5mbGF0TWFwKChsZW4pID0+IHtcbiAgICBjb25zdCBzZWdtZW50ID0gYnl0ZUNvZGUuc2xpY2Uoc2VnbWVudFN0YXJ0LCBzZWdtZW50U3RhcnQgKz0gbGVuKTtcbiAgICByZXR1cm4gW0JpZ0ludChsZW4pLCBwb3NlaWRvbkhhc2hNYW55MihzZWdtZW50KV07XG4gIH0pO1xuICByZXR1cm4gMW4gKyBwb3NlaWRvbkhhc2hNYW55MihoYXNoTGVhdmVzKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb21waWxlZENsYXNzSGFzaChjYXNtKSB7XG4gIGNvbnN0IENPTVBJTEVEX0NMQVNTX1ZFUlNJT04gPSBcIkNPTVBJTEVEX0NMQVNTX1YxXCI7XG4gIGNvbnN0IGNvbXBpbGVkQ2xhc3NWZXJzaW9uID0gQmlnSW50KGVuY29kZVNob3J0U3RyaW5nKENPTVBJTEVEX0NMQVNTX1ZFUlNJT04pKTtcbiAgY29uc3QgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2ggPSBoYXNoRW50cnlQb2ludChjYXNtLmVudHJ5X3BvaW50c19ieV90eXBlLkVYVEVSTkFMKTtcbiAgY29uc3QgbDFIYW5kbGVycyA9IGhhc2hFbnRyeVBvaW50KGNhc20uZW50cnlfcG9pbnRzX2J5X3R5cGUuTDFfSEFORExFUik7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gaGFzaEVudHJ5UG9pbnQoY2FzbS5lbnRyeV9wb2ludHNfYnlfdHlwZS5DT05TVFJVQ1RPUik7XG4gIGNvbnN0IGJ5dGVjb2RlID0gY2FzbS5ieXRlY29kZV9zZWdtZW50X2xlbmd0aHMgPyBoYXNoQnl0ZUNvZGVTZWdtZW50cyhjYXNtKSA6IHBvc2VpZG9uSGFzaE1hbnkyKGNhc20uYnl0ZWNvZGUubWFwKChpdCkgPT4gQmlnSW50KGl0KSkpO1xuICByZXR1cm4gdG9IZXgoXG4gICAgcG9zZWlkb25IYXNoTWFueTIoW1xuICAgICAgY29tcGlsZWRDbGFzc1ZlcnNpb24sXG4gICAgICBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCxcbiAgICAgIGwxSGFuZGxlcnMsXG4gICAgICBjb25zdHJ1Y3RvcixcbiAgICAgIGJ5dGVjb2RlXG4gICAgXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhc2hFbnRyeVBvaW50U2llcnJhKGRhdGEpIHtcbiAgY29uc3QgYmFzZSA9IGRhdGEuZmxhdE1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gW0JpZ0ludChpdC5zZWxlY3RvciksIEJpZ0ludChpdC5mdW5jdGlvbl9pZHgpXTtcbiAgfSk7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55MihiYXNlKTtcbn1cbmZ1bmN0aW9uIGhhc2hBYmkoc2llcnJhKSB7XG4gIGNvbnN0IGluZGVudFN0cmluZyA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKHNpZXJyYS5hYmksIG51bGwpKTtcbiAgcmV0dXJuIEJpZ0ludChhZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoaW5kZW50U3RyaW5nKSkudG9TdHJpbmcoMTYpKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2goc2llcnJhKSB7XG4gIGNvbnN0IENPTlRSQUNUX0NMQVNTX1ZFUlNJT04gPSBcIkNPTlRSQUNUX0NMQVNTX1YwLjEuMFwiO1xuICBjb25zdCBjb21waWxlZENsYXNzVmVyc2lvbiA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhDT05UUkFDVF9DTEFTU19WRVJTSU9OKSk7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gaGFzaEVudHJ5UG9pbnRTaWVycmEoc2llcnJhLmVudHJ5X3BvaW50c19ieV90eXBlLkVYVEVSTkFMKTtcbiAgY29uc3QgbDFIYW5kbGVycyA9IGhhc2hFbnRyeVBvaW50U2llcnJhKHNpZXJyYS5lbnRyeV9wb2ludHNfYnlfdHlwZS5MMV9IQU5ETEVSKTtcbiAgY29uc3QgY29uc3RydWN0b3IgPSBoYXNoRW50cnlQb2ludFNpZXJyYShzaWVycmEuZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IpO1xuICBjb25zdCBhYmlIYXNoID0gaGFzaEFiaShzaWVycmEpO1xuICBjb25zdCBzaWVycmFQcm9ncmFtID0gcG9zZWlkb25IYXNoTWFueTIoc2llcnJhLnNpZXJyYV9wcm9ncmFtLm1hcCgoaXQpID0+IEJpZ0ludChpdCkpKTtcbiAgcmV0dXJuIHRvSGV4KFxuICAgIHBvc2VpZG9uSGFzaE1hbnkyKFtcbiAgICAgIGNvbXBpbGVkQ2xhc3NWZXJzaW9uLFxuICAgICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgICBsMUhhbmRsZXJzLFxuICAgICAgY29uc3RydWN0b3IsXG4gICAgICBhYmlIYXNoLFxuICAgICAgc2llcnJhUHJvZ3JhbVxuICAgIF0pXG4gICk7XG59XG5mdW5jdGlvbiBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2goY29udHJhY3QpIHtcbiAgY29uc3QgY29tcGlsZWRDb250cmFjdCA9IGlzU3RyaW5nKGNvbnRyYWN0KSA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgaWYgKFwic2llcnJhX3Byb2dyYW1cIiBpbiBjb21waWxlZENvbnRyYWN0KSB7XG4gICAgcmV0dXJuIGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoKGNvbXBpbGVkQ29udHJhY3QpO1xufVxuXG4vLyBzcmMvdXRpbHMvc3RhcmsudHNcbnZhciBzdGFya19leHBvcnRzID0ge307XG5fX2V4cG9ydChzdGFya19leHBvcnRzLCB7XG4gIGNvbXByZXNzUHJvZ3JhbTogKCkgPT4gY29tcHJlc3NQcm9ncmFtLFxuICBkZWNvbXByZXNzUHJvZ3JhbTogKCkgPT4gZGVjb21wcmVzc1Byb2dyYW0sXG4gIGVzdGltYXRlRmVlVG9Cb3VuZHM6ICgpID0+IGVzdGltYXRlRmVlVG9Cb3VuZHMsXG4gIGVzdGltYXRlZEZlZVRvTWF4RmVlOiAoKSA9PiBlc3RpbWF0ZWRGZWVUb01heEZlZSxcbiAgZm9ybWF0U2lnbmF0dXJlOiAoKSA9PiBmb3JtYXRTaWduYXR1cmUsXG4gIGdldEZ1bGxQdWJsaWNLZXk6ICgpID0+IGdldEZ1bGxQdWJsaWNLZXksXG4gIGludERBTTogKCkgPT4gaW50REFNLFxuICBtYWtlQWRkcmVzczogKCkgPT4gbWFrZUFkZHJlc3MsXG4gIHJhbmRvbUFkZHJlc3M6ICgpID0+IHJhbmRvbUFkZHJlc3MsXG4gIHJlZHVjZVYyOiAoKSA9PiByZWR1Y2VWMixcbiAgc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXk6ICgpID0+IHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5LFxuICBzaWduYXR1cmVUb0hleEFycmF5OiAoKSA9PiBzaWduYXR1cmVUb0hleEFycmF5LFxuICB0b0ZlZVZlcnNpb246ICgpID0+IHRvRmVlVmVyc2lvbixcbiAgdG9UcmFuc2FjdGlvblZlcnNpb246ICgpID0+IHRvVHJhbnNhY3Rpb25WZXJzaW9uLFxuICB2M0RldGFpbHM6ICgpID0+IHYzRGV0YWlsc1xufSk7XG5pbXBvcnQgeyBnZXRQdWJsaWNLZXksIGdldFN0YXJrS2V5LCB1dGlscyB9IGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcbmltcG9ydCB7IGd6aXAsIHVuZ3ppcCB9IGZyb20gXCJwYWtvXCI7XG5mdW5jdGlvbiBjb21wcmVzc1Byb2dyYW0oanNvblByb2dyYW0pIHtcbiAgY29uc3Qgc3RyaW5naWZpZWQgPSBpc1N0cmluZyhqc29uUHJvZ3JhbSkgPyBqc29uUHJvZ3JhbSA6IHN0cmluZ2lmeTIoanNvblByb2dyYW0pO1xuICBjb25zdCBjb21wcmVzc2VkUHJvZ3JhbSA9IGd6aXAoc3RyaW5naWZpZWQpO1xuICByZXR1cm4gYnRvYVVuaXZlcnNhbChjb21wcmVzc2VkUHJvZ3JhbSk7XG59XG5mdW5jdGlvbiBkZWNvbXByZXNzUHJvZ3JhbShiYXNlNjQyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJhc2U2NDIpKSByZXR1cm4gYmFzZTY0MjtcbiAgY29uc3QgZGVjb21wcmVzc2VkID0gYXJyYXlCdWZmZXJUb1N0cmluZyh1bmd6aXAoYXRvYlVuaXZlcnNhbChiYXNlNjQyKSkpO1xuICByZXR1cm4gcGFyc2UyKGRlY29tcHJlc3NlZCk7XG59XG5mdW5jdGlvbiByYW5kb21BZGRyZXNzKCkge1xuICBjb25zdCByYW5kb21LZXlQYWlyID0gdXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICByZXR1cm4gZ2V0U3RhcmtLZXkocmFuZG9tS2V5UGFpcik7XG59XG5mdW5jdGlvbiBtYWtlQWRkcmVzcyhpbnB1dCkge1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGlucHV0KS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gZm9ybWF0U2lnbmF0dXJlKHNpZykge1xuICBpZiAoIXNpZykgdGhyb3cgRXJyb3IoXCJmb3JtYXRTaWduYXR1cmU6IHByb3ZpZGVkIHNpZ25hdHVyZSBpcyB1bmRlZmluZWRcIik7XG4gIGlmIChBcnJheS5pc0FycmF5KHNpZykpIHtcbiAgICByZXR1cm4gc2lnLm1hcCgoaXQpID0+IHRvSGV4KGl0KSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCB7IHIsIHMgfSA9IHNpZztcbiAgICByZXR1cm4gW3RvSGV4KHIpLCB0b0hleChzKV07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduYXR1cmUgbmVlZCB0byBiZSB3ZWllcnN0cmFzcy5TaWduYXR1cmVUeXBlIG9yIGFuIGFycmF5IGZvciBjdXN0b21cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5KHNpZykge1xuICByZXR1cm4gYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheShmb3JtYXRTaWduYXR1cmUoc2lnKSk7XG59XG5mdW5jdGlvbiBzaWduYXR1cmVUb0hleEFycmF5KHNpZykge1xuICByZXR1cm4gYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXkoZm9ybWF0U2lnbmF0dXJlKHNpZykpO1xufVxuZnVuY3Rpb24gZXN0aW1hdGVkRmVlVG9NYXhGZWUoZXN0aW1hdGVkRmVlLCBvdmVyaGVhZCA9IDUwIC8qIE1BWF9GRUUgKi8pIHtcbiAgcmV0dXJuIGFkZFBlcmNlbnQoZXN0aW1hdGVkRmVlLCBvdmVyaGVhZCk7XG59XG5mdW5jdGlvbiBlc3RpbWF0ZUZlZVRvQm91bmRzKGVzdGltYXRlLCBhbW91bnRPdmVyaGVhZCA9IDUwIC8qIEwxX0JPVU5EX01BWF9BTU9VTlQgKi8sIHByaWNlT3ZlcmhlYWQgPSA1MCAvKiBMMV9CT1VORF9NQVhfUFJJQ0VfUEVSX1VOSVQgKi8pIHtcbiAgaWYgKGlzQmlnSW50KGVzdGltYXRlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBsMl9nYXM6IHsgbWF4X2Ftb3VudDogXCIweDBcIiwgbWF4X3ByaWNlX3Blcl91bml0OiBcIjB4MFwiIH0sXG4gICAgICBsMV9nYXM6IHsgbWF4X2Ftb3VudDogXCIweDBcIiwgbWF4X3ByaWNlX3Blcl91bml0OiBcIjB4MFwiIH1cbiAgICB9O1xuICB9XG4gIGlmIChpc1VuZGVmaW5lZChlc3RpbWF0ZS5nYXNfY29uc3VtZWQpIHx8IGlzVW5kZWZpbmVkKGVzdGltYXRlLmdhc19wcmljZSkpIHtcbiAgICB0aHJvdyBFcnJvcihcImVzdGltYXRlRmVlVG9Cb3VuZHM6IGVzdGltYXRlIGlzIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBjb25zdCBtYXhVbml0cyA9IGVzdGltYXRlLmRhdGFfZ2FzX2NvbnN1bWVkICE9PSB2b2lkIDAgJiYgZXN0aW1hdGUuZGF0YV9nYXNfcHJpY2UgIT09IHZvaWQgMCA/IHRvSGV4KGFkZFBlcmNlbnQoQmlnSW50KGVzdGltYXRlLm92ZXJhbGxfZmVlKSAvIEJpZ0ludChlc3RpbWF0ZS5nYXNfcHJpY2UpLCBhbW91bnRPdmVyaGVhZCkpIDogdG9IZXgoYWRkUGVyY2VudChlc3RpbWF0ZS5nYXNfY29uc3VtZWQsIGFtb3VudE92ZXJoZWFkKSk7XG4gIGNvbnN0IG1heFVuaXRQcmljZSA9IHRvSGV4KGFkZFBlcmNlbnQoZXN0aW1hdGUuZ2FzX3ByaWNlLCBwcmljZU92ZXJoZWFkKSk7XG4gIHJldHVybiB7XG4gICAgbDJfZ2FzOiB7IG1heF9hbW91bnQ6IFwiMHgwXCIsIG1heF9wcmljZV9wZXJfdW5pdDogXCIweDBcIiB9LFxuICAgIGwxX2dhczogeyBtYXhfYW1vdW50OiBtYXhVbml0cywgbWF4X3ByaWNlX3Blcl91bml0OiBtYXhVbml0UHJpY2UgfVxuICB9O1xufVxuZnVuY3Rpb24gaW50REFNKGRhbSkge1xuICBpZiAoZGFtID09PSBhcGlfZXhwb3J0cy5FRGF0YUF2YWlsYWJpbGl0eU1vZGUuTDEpIHJldHVybiBhcGlfZXhwb3J0cy5FREFNb2RlLkwxO1xuICBpZiAoZGFtID09PSBhcGlfZXhwb3J0cy5FRGF0YUF2YWlsYWJpbGl0eU1vZGUuTDIpIHJldHVybiBhcGlfZXhwb3J0cy5FREFNb2RlLkwyO1xuICB0aHJvdyBFcnJvcihcIkVEQU0gY29udmVyc2lvblwiKTtcbn1cbmZ1bmN0aW9uIHRvVHJhbnNhY3Rpb25WZXJzaW9uKGRlZmF1bHRWZXJzaW9uLCBwcm92aWRlZFZlcnNpb24pIHtcbiAgY29uc3QgcHJvdmlkZWRWZXJzaW9uMHhzID0gcHJvdmlkZWRWZXJzaW9uID8gdG9IZXgocHJvdmlkZWRWZXJzaW9uKSA6IHZvaWQgMDtcbiAgY29uc3QgZGVmYXVsdFZlcnNpb24weHMgPSB0b0hleChkZWZhdWx0VmVyc2lvbik7XG4gIGlmIChwcm92aWRlZFZlcnNpb24gJiYgIU9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbikuaW5jbHVkZXMocHJvdmlkZWRWZXJzaW9uMHhzKSkge1xuICAgIHRocm93IEVycm9yKGBwcm92aWRlZFZlcnNpb24gJHtwcm92aWRlZFZlcnNpb259IGlzIG5vdCBFVHJhbnNhY3Rpb25WZXJzaW9uYCk7XG4gIH1cbiAgaWYgKCFPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24pLmluY2x1ZGVzKGRlZmF1bHRWZXJzaW9uMHhzKSkge1xuICAgIHRocm93IEVycm9yKGBkZWZhdWx0VmVyc2lvbiAke2RlZmF1bHRWZXJzaW9ufSBpcyBub3QgRVRyYW5zYWN0aW9uVmVyc2lvbmApO1xuICB9XG4gIHJldHVybiBwcm92aWRlZFZlcnNpb24gPyBwcm92aWRlZFZlcnNpb24weHMgOiBkZWZhdWx0VmVyc2lvbjB4cztcbn1cbmZ1bmN0aW9uIHRvRmVlVmVyc2lvbihwcm92aWRlZFZlcnNpb24pIHtcbiAgaWYgKCFwcm92aWRlZFZlcnNpb24pIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IHZlcnNpb24gPSB0b0hleChwcm92aWRlZFZlcnNpb24pO1xuICBpZiAodmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMCkgcmV0dXJuIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjA7XG4gIGlmICh2ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxKSByZXR1cm4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMTtcbiAgaWYgKHZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIpIHJldHVybiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYyO1xuICBpZiAodmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMykgcmV0dXJuIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjM7XG4gIHRocm93IEVycm9yKGB0b0ZlZVZlcnNpb246ICR7dmVyc2lvbn0gaXMgbm90IHN1cHBvcnRlZGApO1xufVxuZnVuY3Rpb24gdjNEZXRhaWxzKGRldGFpbHMpIHtcbiAgcmV0dXJuIHtcbiAgICB0aXA6IGRldGFpbHMudGlwIHx8IDAsXG4gICAgcGF5bWFzdGVyRGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhIHx8IFtdLFxuICAgIGFjY291bnREZXBsb3ltZW50RGF0YTogZGV0YWlscy5hY2NvdW50RGVwbG95bWVudERhdGEgfHwgW10sXG4gICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlIHx8IGFwaV9leHBvcnRzLkVEYXRhQXZhaWxhYmlsaXR5TW9kZS5MMSxcbiAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogZGV0YWlscy5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSB8fCBhcGlfZXhwb3J0cy5FRGF0YUF2YWlsYWJpbGl0eU1vZGUuTDEsXG4gICAgcmVzb3VyY2VCb3VuZHM6IGRldGFpbHMucmVzb3VyY2VCb3VuZHMgPz8gZXN0aW1hdGVGZWVUb0JvdW5kcyhaRVJPKVxuICB9O1xufVxuZnVuY3Rpb24gcmVkdWNlVjIocHJvdmlkZWRWZXJzaW9uKSB7XG4gIGlmIChwcm92aWRlZFZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjIpIHJldHVybiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxO1xuICBpZiAocHJvdmlkZWRWZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYyKSByZXR1cm4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMTtcbiAgcmV0dXJuIHByb3ZpZGVkVmVyc2lvbjtcbn1cbmZ1bmN0aW9uIGdldEZ1bGxQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICBjb25zdCBwcml2S2V5ID0gdG9IZXgocHJpdmF0ZUtleSk7XG4gIGNvbnN0IGZ1bGxQcml2S2V5ID0gYWRkSGV4UHJlZml4KGJ1ZjJoZXgoZ2V0UHVibGljS2V5KHByaXZLZXksIGZhbHNlKSkpO1xuICByZXR1cm4gZnVsbFByaXZLZXk7XG59XG5cbi8vIHNyYy91dGlscy9jb250cmFjdC50c1xuZnVuY3Rpb24gaXNTaWVycmEoY29udHJhY3QpIHtcbiAgY29uc3QgY29tcGlsZWRDb250cmFjdCA9IGlzU3RyaW5nKGNvbnRyYWN0KSA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgcmV0dXJuIFwic2llcnJhX3Byb2dyYW1cIiBpbiBjb21waWxlZENvbnRyYWN0O1xufVxuZnVuY3Rpb24gZXh0cmFjdENvbnRyYWN0SGFzaGVzKHBheWxvYWQpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSB7IC4uLnBheWxvYWQgfTtcbiAgaWYgKGlzU2llcnJhKHBheWxvYWQuY29udHJhY3QpKSB7XG4gICAgaWYgKCFwYXlsb2FkLmNvbXBpbGVkQ2xhc3NIYXNoICYmIHBheWxvYWQuY2FzbSkge1xuICAgICAgcmVzcG9uc2UuY29tcGlsZWRDbGFzc0hhc2ggPSBjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2gocGF5bG9hZC5jYXNtKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5jb21waWxlZENsYXNzSGFzaClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHRyYWN0IGNvbXBpbGVkQ2xhc3NIYXNoIGZhaWxlZCwgcHJvdmlkZSAoQ2Fpcm9Bc3NlbWJseSkuY2FzbSBmaWxlIG9yIGNvbXBpbGVkQ2xhc3NIYXNoXCJcbiAgICAgICk7XG4gIH1cbiAgcmVzcG9uc2UuY2xhc3NIYXNoID0gcGF5bG9hZC5jbGFzc0hhc2ggPz8gY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoKHBheWxvYWQuY29udHJhY3QpO1xuICBpZiAoIXJlc3BvbnNlLmNsYXNzSGFzaClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRyYWN0IGNsYXNzSGFzaCBmYWlsZWQsIHByb3ZpZGUgKENvbXBpbGVkQ29udHJhY3QpLmpzb24gZmlsZSBvciBjbGFzc0hhc2hcIik7XG4gIHJldHVybiByZXNwb25zZTtcbn1cbmZ1bmN0aW9uIGNvbnRyYWN0Q2xhc3NSZXNwb25zZVRvTGVnYWN5Q29tcGlsZWRDb250cmFjdChjY3IpIHtcbiAgaWYgKGlzU2llcnJhKGNjcikpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNvbnRyYWN0Q2xhc3NSZXNwb25zZSBuZWVkIHRvIGJlIExlZ2FjeUNvbnRyYWN0Q2xhc3MgKGNhaXJvMCByZXNwb25zZSBjbGFzcylcIik7XG4gIH1cbiAgY29uc3QgY29udHJhY3QgPSBjY3I7XG4gIHJldHVybiB7IC4uLmNvbnRyYWN0LCBwcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShjb250cmFjdC5wcm9ncmFtKSB9O1xufVxuXG4vLyBzcmMvdXRpbHMvZXRoLnRzXG52YXIgZXRoX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGV0aF9leHBvcnRzLCB7XG4gIGV0aFJhbmRvbVByaXZhdGVLZXk6ICgpID0+IGV0aFJhbmRvbVByaXZhdGVLZXksXG4gIHZhbGlkYXRlQW5kUGFyc2VFdGhBZGRyZXNzOiAoKSA9PiB2YWxpZGF0ZUFuZFBhcnNlRXRoQWRkcmVzc1xufSk7XG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmZ1bmN0aW9uIGV0aFJhbmRvbVByaXZhdGVLZXkoKSB7XG4gIHJldHVybiBzYW5pdGl6ZUhleChidWYyaGV4KHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQW5kUGFyc2VFdGhBZGRyZXNzKGFkZHJlc3MpIHtcbiAgYXNzZXJ0SW5SYW5nZShhZGRyZXNzLCBaRVJPLCAybiAqKiAxNjBuIC0gMW4sIFwiRXRoZXJldW0gQWRkcmVzcyBcIik7XG4gIGNvbnN0IHJlc3VsdCA9IGFkZEhleFByZWZpeChyZW1vdmVIZXhQcmVmaXgodG9IZXgoYWRkcmVzcykpLnBhZFN0YXJ0KDQwLCBcIjBcIikpO1xuICBhc3NlcnQoQm9vbGVhbihyZXN1bHQubWF0Y2goL14oMHgpP1swLTlhLWZdezQwfSQvKSksIFwiSW52YWxpZCBFdGhlcmV1bSBBZGRyZXNzIEZvcm1hdFwiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3V0aWxzL2ZldGNoUG9ueWZpbGwudHNcbmltcG9ydCBtYWtlRmV0Y2hDb29raWUgZnJvbSBcImZldGNoLWNvb2tpZVwiO1xuaW1wb3J0IGlzb21vcnBoaWNGZXRjaCBmcm9tIFwiaXNvbW9ycGhpYy1mZXRjaFwiO1xudmFyIGZldGNoUG9ueWZpbGxfZGVmYXVsdCA9IElTX0JST1dTRVIgJiYgd2luZG93LmZldGNoLmJpbmQod2luZG93KSB8fCAvLyB1c2UgYnVpbHQtaW4gZmV0Y2ggaW4gYnJvd3NlciBpZiBhdmFpbGFibGVcbiFpc1VuZGVmaW5lZChnbG9iYWwpICYmIG1ha2VGZXRjaENvb2tpZShnbG9iYWwuZmV0Y2gpIHx8IC8vIHVzZSBidWlsdC1pbiBmZXRjaCBpbiBub2RlLCByZWFjdC1uYXRpdmUgYW5kIHNlcnZpY2Ugd29ya2VyIGlmIGF2YWlsYWJsZVxuaXNvbW9ycGhpY0ZldGNoO1xuXG4vLyBzcmMvdXRpbHMvcHJvdmlkZXIudHNcbnZhciBwcm92aWRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChwcm92aWRlcl9leHBvcnRzLCB7XG4gIEJsb2NrOiAoKSA9PiBCbG9jayxcbiAgY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzczogKCkgPT4gY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyxcbiAgZ2V0RGVmYXVsdE5vZGVVcmw6ICgpID0+IGdldERlZmF1bHROb2RlVXJsLFxuICBpc1BlbmRpbmdCbG9jazogKCkgPT4gaXNQZW5kaW5nQmxvY2ssXG4gIGlzUGVuZGluZ1N0YXRlVXBkYXRlOiAoKSA9PiBpc1BlbmRpbmdTdGF0ZVVwZGF0ZSxcbiAgaXNQZW5kaW5nVHJhbnNhY3Rpb246ICgpID0+IGlzUGVuZGluZ1RyYW5zYWN0aW9uLFxuICBpc1YzVHg6ICgpID0+IGlzVjNUeCxcbiAgaXNWZXJzaW9uOiAoKSA9PiBpc1ZlcnNpb24sXG4gIHBhcnNlQ29udHJhY3Q6ICgpID0+IHBhcnNlQ29udHJhY3QsXG4gIHZhbGlkQmxvY2tUYWdzOiAoKSA9PiB2YWxpZEJsb2NrVGFncyxcbiAgd2FpdDogKCkgPT4gd2FpdFxufSk7XG5cbi8vIHNyYy9nbG9iYWwvY29uZmlnLnRzXG52YXIgQ29uZmlndXJhdGlvbiA9IGNsYXNzIF9Db25maWd1cmF0aW9uIHtcbiAgc3RhdGljIGluc3RhbmNlO1xuICBjb25maWc7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5jb25maWcgPSB7IC4uLkRFRkFVTFRfR0xPQkFMX0NPTkZJRyB9O1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcbiAgICBpZiAoIV9Db25maWd1cmF0aW9uLmluc3RhbmNlKSB7XG4gICAgICBfQ29uZmlndXJhdGlvbi5pbnN0YW5jZSA9IG5ldyBfQ29uZmlndXJhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gX0NvbmZpZ3VyYXRpb24uaW5zdGFuY2U7XG4gIH1cbiAgZ2V0KGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnW2tleV0gPz8gZGVmYXVsdFZhbHVlO1xuICB9XG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5jb25maWdba2V5XSA9IHZhbHVlO1xuICB9XG4gIHVwZGF0ZShjb25maWdEYXRhKSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIC4uLmNvbmZpZ0RhdGFcbiAgICB9O1xuICB9XG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLmNvbmZpZyB9O1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIGRlbGV0ZShrZXkpIHtcbiAgICBkZWxldGUgdGhpcy5jb25maWdba2V5XTtcbiAgfVxuICBoYXNLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiB0aGlzLmNvbmZpZztcbiAgfVxufTtcbnZhciBjb25maWcgPSBDb25maWd1cmF0aW9uLmdldEluc3RhbmNlKCk7XG5cbi8vIHNyYy9nbG9iYWwvbG9nZ2VyLnR5cGUudHNcbnZhciBMb2dMZXZlbEluZGV4ID0ge1xuICBERUJVRzogNSxcbiAgSU5GTzogNCxcbiAgV0FSTjogMyxcbiAgRVJST1I6IDIsXG4gIEZBVEFMOiAxLFxuICBPRkY6IDBcbn07XG5cbi8vIHNyYy9nbG9iYWwvbG9nZ2VyLnRzXG52YXIgTG9nZ2VyID0gY2xhc3MgX0xvZ2dlciB7XG4gIHN0YXRpYyBpbnN0YW5jZTtcbiAgY29uZmlnO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgaWYgKCFfTG9nZ2VyLmluc3RhbmNlKSB7XG4gICAgICBfTG9nZ2VyLmluc3RhbmNlID0gbmV3IF9Mb2dnZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9Mb2dnZXIuaW5zdGFuY2U7XG4gIH1cbiAgZ2V0VGltZXN0YW1wKCkge1xuICAgIHJldHVybiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCk7XG4gIH1cbiAgc2hvdWxkTG9nKG1lc3NhZ2VMZXZlbCkge1xuICAgIGNvbnN0IGNvbmZpZ0xldmVsID0gdGhpcy5jb25maWcuZ2V0KFwibG9nTGV2ZWxcIiwgXCJJTkZPXCIpO1xuICAgIHJldHVybiBtZXNzYWdlTGV2ZWwgPD0gTG9nTGV2ZWxJbmRleFtjb25maWdMZXZlbF07XG4gIH1cbiAgZm9ybWF0TWVzc2FnZShsb2dNZXNzYWdlKSB7XG4gICAgY29uc3QgeyBsZXZlbCwgbWVzc2FnZSwgdGltZXN0YW1wLCBkYXRhIH0gPSBsb2dNZXNzYWdlO1xuICAgIGxldCBmb3JtYXR0ZWRNZXNzYWdlID0gYFske3RpbWVzdGFtcH1dICR7bGV2ZWx9OiAke21lc3NhZ2V9YDtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9ybWF0dGVkTWVzc2FnZSArPSBgXG4ke0pTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpfWA7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBmb3JtYXR0ZWRNZXNzYWdlICs9IGBcbltKU09OLnN0cmluZ2lmeSBFcnJvci9DaXJjdWxhcl06ICR7ZXJyb3J9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZE1lc3NhZ2U7XG4gIH1cbiAgbG9nKGxldmVsLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnNob3VsZExvZyhMb2dMZXZlbEluZGV4W2xldmVsXSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbG9nTWVzc2FnZSA9IHtcbiAgICAgIGxldmVsLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHRpbWVzdGFtcDogdGhpcy5nZXRUaW1lc3RhbXAoKSxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2UgPSB0aGlzLmZvcm1hdE1lc3NhZ2UobG9nTWVzc2FnZSk7XG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgY2FzZSBcIkRFQlVHXCI6XG4gICAgICAgIGNvbnNvbGUuZGVidWcoZm9ybWF0dGVkTWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIklORk9cIjpcbiAgICAgICAgY29uc29sZS5pbmZvKGZvcm1hdHRlZE1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJXQVJOXCI6XG4gICAgICAgIGNvbnNvbGUud2Fybihmb3JtYXR0ZWRNZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRVJST1JcIjpcbiAgICAgIGNhc2UgXCJGQVRBTFwiOlxuICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdHRlZE1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJPRkZcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLmxvZyhmb3JtYXR0ZWRNZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBkZWJ1ZyB3aWxsIGJlIGRpc3BsYXllZCB3aGVuIExvZ0xldmVsIGxldmVsIGlzIHNldCB0byBERUJVRyg1KVxuICAgKi9cbiAgZGVidWcobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubG9nKFwiREVCVUdcIiwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIGluZm8gd2lsbCBiZSBkaXNwbGF5ZWQgd2hlbiBMb2dMZXZlbCBsZXZlbCBpcyBzZXQgdG8gREVCVUcoNSksIElORk8oNClcbiAgICovXG4gIGluZm8obWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubG9nKFwiSU5GT1wiLCBtZXNzYWdlLCBkYXRhKTtcbiAgfVxuICAvKipcbiAgICogd2FybiB3aWxsIGJlIGRpc3BsYXllZCB3aGVuIExvZ0xldmVsIGxldmVsIGlzIHNldCB0byBERUJVRyg1KSwgSU5GTyg0KSwgV0FSTigzKVxuICAgKi9cbiAgd2FybihtZXNzYWdlLCBkYXRhKSB7XG4gICAgdGhpcy5sb2coXCJXQVJOXCIsIG1lc3NhZ2UsIGRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBlcnJvciB3aWxsIGJlIGRpc3BsYXllZCB3aGVuIExvZ0xldmVsIGxldmVsIGlzIHNldCB0byBERUJVRyg1KSwgSU5GTyg0KSwgV0FSTigzKSwgRVJST1IoMilcbiAgICovXG4gIGVycm9yKG1lc3NhZ2UsIGRhdGEpIHtcbiAgICB0aGlzLmxvZyhcIkVSUk9SXCIsIG1lc3NhZ2UsIGRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBmYXRhbCB3aWxsIGJlIGRpc3BsYXllZCB3aGVuIExvZ0xldmVsIGxldmVsIGlzIHNldCB0byBERUJVRyg1KSwgSU5GTyg0KSwgV0FSTigzKSwgRVJST1IoMiksIEZBVEFMKDEpXG4gICAqL1xuICBmYXRhbChtZXNzYWdlLCBkYXRhKSB7XG4gICAgdGhpcy5sb2coXCJGQVRBTFwiLCBtZXNzYWdlLCBkYXRhKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBsb2dnaW5nIGxldmVsIHlvdSB3b3VsZCBsaWtlIHN5c3RlbSB0byBkaXNwbGF5XG4gICAqICogNSBERUJVRyAgLSBzaG93IGFsbCBsb2dzXG4gICAqICogNCBJTkZPXG4gICAqICogMyBXQVJOXG4gICAqICogMiBFUlJPUlxuICAgKiAqIDEgRkFUQUxcbiAgICogKiAwIE9GRiAgICAtIGRpc2FibGUgbG9nc1xuICAgKi9cbiAgc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgICB0aGlzLmNvbmZpZy5zZXQoXCJsb2dMZXZlbFwiLCBsZXZlbCk7XG4gIH1cbiAgZ2V0TG9nTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmdldChcImxvZ0xldmVsXCIsIFwiSU5GT1wiKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgbG9ncyBsZXZlbHMgZGlzcGxheWVkIG9uIHRoZSBjb25maWd1cmVkIExvZ0xldmVsXG4gICAqL1xuICBnZXRFbmFibGVkTG9nTGV2ZWxzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhMb2dMZXZlbEluZGV4KS5maWx0ZXIoKHMpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnNob3VsZExvZyhMb2dMZXZlbEluZGV4W3NdKSAmJiBzICE9PSBcIk9GRlwiO1xuICAgIH0pO1xuICB9XG59O1xudmFyIGxvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xuXG4vLyBzcmMvdXRpbHMvcHJvdmlkZXIudHNcbmZ1bmN0aW9uIHdhaXQoZGVsYXkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlcywgZGVsYXkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3MoY29udHJhY3QpIHtcbiAgY29uc3QgcmVzdWx0ID0geyAuLi5jb250cmFjdCB9O1xuICBkZWxldGUgcmVzdWx0LnNpZXJyYV9wcm9ncmFtX2RlYnVnX2luZm87XG4gIHJlc3VsdC5hYmkgPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5Mihjb250cmFjdC5hYmkpKTtcbiAgcmVzdWx0LnNpZXJyYV9wcm9ncmFtID0gZm9ybWF0U3BhY2VzKHN0cmluZ2lmeTIoY29udHJhY3Quc2llcnJhX3Byb2dyYW0pKTtcbiAgcmVzdWx0LnNpZXJyYV9wcm9ncmFtID0gY29tcHJlc3NQcm9ncmFtKHJlc3VsdC5zaWVycmFfcHJvZ3JhbSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUNvbnRyYWN0KGNvbnRyYWN0KSB7XG4gIGNvbnN0IHBhcnNlZENvbnRyYWN0ID0gaXNTdHJpbmcoY29udHJhY3QpID8gcGFyc2UyKGNvbnRyYWN0KSA6IGNvbnRyYWN0O1xuICBpZiAoIWlzU2llcnJhKGNvbnRyYWN0KSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wYXJzZWRDb250cmFjdCxcbiAgICAgIC4uLlwicHJvZ3JhbVwiIGluIHBhcnNlZENvbnRyYWN0ICYmIHsgcHJvZ3JhbTogY29tcHJlc3NQcm9ncmFtKHBhcnNlZENvbnRyYWN0LnByb2dyYW0pIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBjcmVhdGVTaWVycmFDb250cmFjdENsYXNzKHBhcnNlZENvbnRyYWN0KTtcbn1cbnZhciBnZXREZWZhdWx0Tm9kZVVybCA9IChuZXR3b3JrTmFtZSwgbXV0ZSA9IGZhbHNlKSA9PiB7XG4gIGlmICghbXV0ZSkge1xuICAgIGxvZ2dlci5pbmZvKFwiVXNpbmcgZGVmYXVsdCBwdWJsaWMgbm9kZSB1cmwsIHBsZWFzZSBwcm92aWRlIG5vZGVVcmwgaW4gcHJvdmlkZXIgb3B0aW9ucyFcIik7XG4gIH1cbiAgY29uc3Qgbm9kZXMgPSBSUENfTk9ERVNbbmV0d29ya05hbWUgPz8gXCJTTl9TRVBPTElBXCIgLyogU05fU0VQT0xJQSAqL107XG4gIGNvbnN0IHJhbmRJZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpO1xuICByZXR1cm4gbm9kZXNbcmFuZElkeF07XG59O1xudmFyIHZhbGlkQmxvY2tUYWdzID0gT2JqZWN0LnZhbHVlcyhCbG9ja1RhZyk7XG52YXIgQmxvY2sgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jsb2NrSWRlbnRpZmllcn0gaGFzaCBpZiBub3QgbnVsbCwgY29udGFpbnMgdGhlIGJsb2NrIGhhc2hcbiAgICovXG4gIGhhc2ggPSBudWxsO1xuICAvKipcbiAgICogQHBhcmFtIHtCbG9ja0lkZW50aWZpZXJ9IG51bWJlciBpZiBub3QgbnVsbCwgY29udGFpbnMgdGhlIGJsb2NrIG51bWJlclxuICAgKi9cbiAgbnVtYmVyID0gbnVsbDtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QmxvY2tJZGVudGlmaWVyfSB0YWcgaWYgbm90IG51bGwsIGNvbnRhaW5zIFwicGVuZGluZ1wiIG9yIFwibGF0ZXN0XCJcbiAgICovXG4gIHRhZyA9IG51bGw7XG4gIHNldElkZW50aWZpZXIoX19pZGVudGlmaWVyKSB7XG4gICAgaWYgKGlzU3RyaW5nKF9faWRlbnRpZmllcikpIHtcbiAgICAgIGlmIChpc0RlY2ltYWxTdHJpbmcoX19pZGVudGlmaWVyKSkge1xuICAgICAgICB0aGlzLm51bWJlciA9IHBhcnNlSW50KF9faWRlbnRpZmllciwgMTApO1xuICAgICAgfSBlbHNlIGlmIChpc0hleChfX2lkZW50aWZpZXIpKSB7XG4gICAgICAgIHRoaXMuaGFzaCA9IF9faWRlbnRpZmllcjtcbiAgICAgIH0gZWxzZSBpZiAodmFsaWRCbG9ja1RhZ3MuaW5jbHVkZXMoX19pZGVudGlmaWVyKSkge1xuICAgICAgICB0aGlzLnRhZyA9IF9faWRlbnRpZmllcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihgQmxvY2sgaWRlbnRpZmllciB1bm1hbmFnZWQ6ICR7X19pZGVudGlmaWVyfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNCaWdJbnQoX19pZGVudGlmaWVyKSkge1xuICAgICAgdGhpcy5oYXNoID0gdG9IZXgoX19pZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKF9faWRlbnRpZmllcikpIHtcbiAgICAgIHRoaXMubnVtYmVyID0gX19pZGVudGlmaWVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZyA9IEJsb2NrVGFnLlBFTkRJTkc7XG4gICAgfVxuICAgIGlmIChpc051bWJlcih0aGlzLm51bWJlcikgJiYgdGhpcy5udW1iZXIgPCAwKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoYEJsb2NrIG51bWJlciAoJHt0aGlzLm51bWJlcn0pIGNhbid0IGJlIG5lZ2F0aXZlYCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBCbG9jayBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0Jsb2NrSWRlbnRpZmllcn0gX2lkZW50aWZpZXIgIGhleCBzdHJpbmcgYW5kIEJpZ0ludCBhcmUgZGV0ZWN0ZWQgYXMgYmxvY2sgaGFzaGVzLlxuICAgKiBkZWNpbWFsIHN0cmluZyBhbmQgbnVtYmVyIGFyZSBkZXRlY3RlZCBhcyBibG9jayBudW1iZXJzLlxuICAgKiB0ZXh0IHN0cmluZyBhcmUgZGV0ZWN0ZWQgYXMgYmxvY2sgdGFnLlxuICAgKiBudWxsIGlzIGNvbnNpZGVyZWQgYXMgYSAncGVuZGluZycgYmxvY2sgdGFnLlxuICAgKi9cbiAgY29uc3RydWN0b3IoX2lkZW50aWZpZXIpIHtcbiAgICB0aGlzLnNldElkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICB9XG4gIC8vIFRPRE86IGZpeCBhbnlcbiAgLyoqXG4gICAqIEByZXR1cm5zIHthbnl9IHRoZSBpZGVudGlmaWVyIGFzIGEgc3RyaW5nXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgcmVzdWx0ID0gbmV3IHByb3ZpZGVyLkJsb2NrKDEyMzQ1Nm4pLnF1ZXJ5SWRlbnRpZmllcjtcbiAgICogLy8gcmVzdWx0ID0gXCJibG9ja0hhc2g9MHgxZTI0MFwiXG4gICAqIGBgYFxuICAgKi9cbiAgZ2V0IHF1ZXJ5SWRlbnRpZmllcigpIHtcbiAgICBpZiAodGhpcy5udW1iZXIgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBgYmxvY2tOdW1iZXI9JHt0aGlzLm51bWJlcn1gO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYGJsb2NrSGFzaD0ke3RoaXMuaGFzaH1gO1xuICAgIH1cbiAgICByZXR1cm4gYGJsb2NrTnVtYmVyPSR7dGhpcy50YWd9YDtcbiAgfVxuICAvLyBUT0RPOiBmaXggYW55XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7YW55fSB0aGUgaWRlbnRpZmllciBhcyBhbiBvYmplY3RcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQgPSBuZXcgcHJvdmlkZXIuQmxvY2soNTY3ODkpLmlkZW50aWZpZXI7XG4gICAqIC8vIHJlc3VsdCA9IHsgYmxvY2tfbnVtYmVyOiA1Njc4OSB9XG4gICAqIGBgYFxuICAgKi9cbiAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgaWYgKHRoaXMubnVtYmVyICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBibG9ja19udW1iZXI6IHRoaXMubnVtYmVyIH07XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGJsb2NrX2hhc2g6IHRoaXMuaGFzaCB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50YWc7XG4gIH1cbiAgLyoqXG4gICAqIGNoYW5nZSB0aGUgaWRlbnRpZmllciBvZiBhbiBleGlzdGluZyBCbG9jayBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IG15QmxvY2sgPSBuZXcgcHJvdmlkZXIuQmxvY2soXCJsYXRlc3RcIik7XG4gICAqIG15QmxvY2suaWRlbnRpZmllciA9XCIweDM0NTY3ODlhYmNcIjtcbiAgICogY29uc3QgcmVzdWx0ID0gbXlCbG9jay5pZGVudGlmaWVyO1xuICAgKiAvLyByZXN1bHQgPSB7IGJsb2NrX2hhc2g6ICcweDM0NTY3ODlhYmMnIH1cbiAgICogYGBgXG4gICAqL1xuICBzZXQgaWRlbnRpZmllcihfaWRlbnRpZmllcikge1xuICAgIHRoaXMuc2V0SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gIH1cbiAgdmFsdWVPZiA9ICgpID0+IHRoaXMubnVtYmVyO1xuICB0b1N0cmluZyA9ICgpID0+IHRoaXMuaGFzaDtcbn07XG5mdW5jdGlvbiBpc1YzVHgoZGV0YWlscykge1xuICBjb25zdCB2ZXJzaW9uID0gZGV0YWlscy52ZXJzaW9uID8gdG9IZXgoZGV0YWlscy52ZXJzaW9uKSA6IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjM7XG4gIHJldHVybiB2ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzIHx8IHZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjM7XG59XG5mdW5jdGlvbiBpc1ZlcnNpb24odmVyc2lvbiwgcmVzcG9uc2UpIHtcbiAgY29uc3QgW21ham9yUywgbWlub3JTXSA9IHZlcnNpb24uc3BsaXQoXCIuXCIpO1xuICBjb25zdCBbbWFqb3JSLCBtaW5vclJdID0gcmVzcG9uc2Uuc3BsaXQoXCIuXCIpO1xuICByZXR1cm4gbWFqb3JTID09PSBtYWpvclIgJiYgbWlub3JTID09PSBtaW5vclI7XG59XG5mdW5jdGlvbiBpc1BlbmRpbmdCbG9jayhyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2Uuc3RhdHVzID09PSBcIlBFTkRJTkdcIjtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZ1RyYW5zYWN0aW9uKHJlc3BvbnNlKSB7XG4gIHJldHVybiAhKFwiYmxvY2tfaGFzaFwiIGluIHJlc3BvbnNlKTtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZ1N0YXRlVXBkYXRlKHJlc3BvbnNlKSB7XG4gIHJldHVybiAhKFwiYmxvY2tfaGFzaFwiIGluIHJlc3BvbnNlKTtcbn1cblxuLy8gc3JjL3V0aWxzL3RyYW5zYWN0aW9uLnRzXG52YXIgdHJhbnNhY3Rpb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHJhbnNhY3Rpb25fZXhwb3J0cywge1xuICBidWlsZFVEQ0NhbGw6ICgpID0+IGJ1aWxkVURDQ2FsbCxcbiAgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGE6ICgpID0+IGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhLFxuICBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZTogKCkgPT4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFXaXRoTm9uY2UsXG4gIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMTogKCkgPT4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xLFxuICBnZXRFeGVjdXRlQ2FsbGRhdGE6ICgpID0+IGdldEV4ZWN1dGVDYWxsZGF0YSxcbiAgZ2V0VmVyc2lvbnNCeVR5cGU6ICgpID0+IGdldFZlcnNpb25zQnlUeXBlLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzOiAoKSA9PiB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMTogKCkgPT4gdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzFcbn0pO1xudmFyIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gW107XG4gIGNvbnN0IGNhbGxkYXRhID0gW107XG4gIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICBjb25zdCBkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKTtcbiAgICBjYWxsQXJyYXkucHVzaCh7XG4gICAgICB0bzogdG9CaWdJbnQoY2FsbC5jb250cmFjdEFkZHJlc3MpLnRvU3RyaW5nKDEwKSxcbiAgICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICAgIGRhdGFfb2Zmc2V0OiBjYWxsZGF0YS5sZW5ndGgudG9TdHJpbmcoKSxcbiAgICAgIGRhdGFfbGVuOiBkYXRhLmxlbmd0aC50b1N0cmluZygpXG4gICAgfSk7XG4gICAgY2FsbGRhdGEucHVzaCguLi5kYXRhKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsbEFycmF5LFxuICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHsgY2FsbGRhdGEgfSlcbiAgfTtcbn07XG52YXIgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgeyBjYWxsQXJyYXksIGNhbGxkYXRhIH0gPSB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzKGNhbGxzKTtcbiAgY29uc3QgY29tcGlsZWRDYWxscyA9IENhbGxEYXRhLmNvbXBpbGUoeyBjYWxsQXJyYXkgfSk7XG4gIHJldHVybiBbLi4uY29tcGlsZWRDYWxscywgLi4uY2FsbGRhdGFdO1xufTtcbnZhciBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSA9IChjYWxscywgbm9uY2UpID0+IHtcbiAgcmV0dXJuIFsuLi5mcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YShjYWxscyksIHRvQmlnSW50KG5vbmNlKS50b1N0cmluZygpXTtcbn07XG52YXIgdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIHRvOiB0b0JpZ0ludChjYWxsLmNvbnRyYWN0QWRkcmVzcykudG9TdHJpbmcoMTApLFxuICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKVxuICB9KSk7XG4gIHJldHVybiBjYWxsQXJyYXk7XG59O1xudmFyIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMSA9IChjYWxscykgPT4ge1xuICBjb25zdCBvcmRlckNhbGxzID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIGNvbnRyYWN0QWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgZW50cnlwb2ludDogY2FsbC5lbnRyeXBvaW50LFxuICAgIGNhbGxkYXRhOiBBcnJheS5pc0FycmF5KGNhbGwuY2FsbGRhdGEpICYmIFwiX19jb21waWxlZF9fXCIgaW4gY2FsbC5jYWxsZGF0YSA/IGNhbGwuY2FsbGRhdGEgOiBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEpXG4gICAgLy8gUmF3QXJnc09iamVjdCB8IFJhd0FyZ3NBcnJheSB0eXBlXG4gIH0pKTtcbiAgcmV0dXJuIENhbGxEYXRhLmNvbXBpbGUoeyBvcmRlckNhbGxzIH0pO1xufTtcbnZhciBnZXRFeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMsIGNhaXJvVmVyc2lvbiA9IFwiMFwiKSA9PiB7XG4gIGlmIChjYWlyb1ZlcnNpb24gPT09IFwiMVwiKSB7XG4gICAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMShjYWxscyk7XG4gIH1cbiAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhKGNhbGxzKTtcbn07XG5mdW5jdGlvbiBidWlsZFVEQ0NhbGwocGF5bG9hZCwgYWRkcmVzcykge1xuICBjb25zdCBwYXJhbXMgPSBbXS5jb25jYXQocGF5bG9hZCkubWFwKChpdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIHNhbHQsXG4gICAgICB1bmlxdWUgPSB0cnVlLFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdXG4gICAgfSA9IGl0O1xuICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgY29uc3QgZGVwbG95U2FsdCA9IHNhbHQgPz8gcmFuZG9tQWRkcmVzcygpO1xuICAgIHJldHVybiB7XG4gICAgICBjYWxsOiB7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogVURDLkFERFJFU1MsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFVEQy5FTlRSWVBPSU5ULFxuICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgICBkZXBsb3lTYWx0LFxuICAgICAgICAgIHRvQ2Fpcm9Cb29sKHVuaXF1ZSksXG4gICAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhLmxlbmd0aCxcbiAgICAgICAgICAuLi5jb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGFcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGFkZHJlc3M6IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKFxuICAgICAgICB1bmlxdWUgPyBzdGFya0N1cnZlLnBlZGVyc2VuKGFkZHJlc3MsIGRlcGxveVNhbHQpIDogZGVwbG95U2FsdCxcbiAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEsXG4gICAgICAgIHVuaXF1ZSA/IFVEQy5BRERSRVNTIDogMFxuICAgICAgKVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNhbGxzOiBwYXJhbXMubWFwKChpdCkgPT4gaXQuY2FsbCksXG4gICAgYWRkcmVzc2VzOiBwYXJhbXMubWFwKChpdCkgPT4gaXQuYWRkcmVzcylcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFZlcnNpb25zQnlUeXBlKHZlcnNpb25UeXBlKSB7XG4gIHJldHVybiB2ZXJzaW9uVHlwZSA9PT0gXCJmZWVcIiA/IHtcbiAgICB2MTogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMSxcbiAgICB2MjogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMixcbiAgICB2MzogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GM1xuICB9IDogeyB2MTogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSwgdjI6IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIsIHYzOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzIH07XG59XG5cbi8vIHNyYy9jaGFubmVsL3JwY18wXzYudHNcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICBibG9ja0lkZW50aWZpZXI6IEJsb2NrVGFnLlBFTkRJTkcsXG4gIHJldHJpZXM6IDIwMFxufTtcbnZhciBScGNDaGFubmVsID0gY2xhc3Mge1xuICBub2RlVXJsO1xuICBoZWFkZXJzO1xuICByZXF1ZXN0SWQ7XG4gIGJsb2NrSWRlbnRpZmllcjtcbiAgcmV0cmllcztcbiAgd2FpdE1vZGU7XG4gIC8vIGJlaGF2ZSBsaWtlIHdlYjIgcnBjIGFuZCByZXR1cm4gd2hlbiB0eCBpcyBwcm9jZXNzZWRcbiAgY2hhaW5JZDtcbiAgc3BlY1ZlcnNpb247XG4gIHRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbEZhbGxiYWNrO1xuICBiYXRjaENsaWVudDtcbiAgYmFzZUZldGNoO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zT3JQcm92aWRlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2VGZXRjaCxcbiAgICAgIGJhdGNoLFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBub2RlVXJsLFxuICAgICAgcmV0cmllcyxcbiAgICAgIHNwZWNWZXJzaW9uLFxuICAgICAgdHJhbnNhY3Rpb25SZXRyeUludGVydmFsRmFsbGJhY2ssXG4gICAgICB3YWl0TW9kZVxuICAgIH0gPSBvcHRpb25zT3JQcm92aWRlciB8fCB7fTtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhOZXR3b3JrTmFtZSkuaW5jbHVkZXMobm9kZVVybCkpIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IGdldERlZmF1bHROb2RlVXJsKG5vZGVVcmwsIG9wdGlvbnNPclByb3ZpZGVyPy5kZWZhdWx0KTtcbiAgICB9IGVsc2UgaWYgKG5vZGVVcmwpIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IG5vZGVVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IGdldERlZmF1bHROb2RlVXJsKHZvaWQgMCwgb3B0aW9uc09yUHJvdmlkZXI/LmRlZmF1bHQpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VGZXRjaCA9IGJhc2VGZXRjaCA/PyBmZXRjaFBvbnlmaWxsX2RlZmF1bHQ7XG4gICAgdGhpcy5ibG9ja0lkZW50aWZpZXIgPSBibG9ja0lkZW50aWZpZXIgPz8gZGVmYXVsdE9wdGlvbnMuYmxvY2tJZGVudGlmaWVyO1xuICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgdGhpcy5oZWFkZXJzID0geyAuLi5kZWZhdWx0T3B0aW9ucy5oZWFkZXJzLCAuLi5oZWFkZXJzIH07XG4gICAgdGhpcy5yZXRyaWVzID0gcmV0cmllcyA/PyBkZWZhdWx0T3B0aW9ucy5yZXRyaWVzO1xuICAgIHRoaXMuc3BlY1ZlcnNpb24gPSBzcGVjVmVyc2lvbjtcbiAgICB0aGlzLnRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbEZhbGxiYWNrID0gdHJhbnNhY3Rpb25SZXRyeUludGVydmFsRmFsbGJhY2s7XG4gICAgdGhpcy53YWl0TW9kZSA9IHdhaXRNb2RlID8/IGZhbHNlO1xuICAgIHRoaXMucmVxdWVzdElkID0gMDtcbiAgICBpZiAodHlwZW9mIGJhdGNoID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLmJhdGNoQ2xpZW50ID0gbmV3IEJhdGNoQ2xpZW50KHtcbiAgICAgICAgbm9kZVVybDogdGhpcy5ub2RlVXJsLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIGludGVydmFsOiBiYXRjaCxcbiAgICAgICAgYmFzZUZldGNoOiB0aGlzLmJhc2VGZXRjaFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCB0cmFuc2FjdGlvblJldHJ5SW50ZXJ2YWxEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbEZhbGxiYWNrID8/IDVlMztcbiAgfVxuICBzZXRDaGFpbklkKGNoYWluSWQpIHtcbiAgICB0aGlzLmNoYWluSWQgPSBjaGFpbklkO1xuICB9XG4gIGZldGNoKG1ldGhvZCwgcGFyYW1zLCBpZCA9IDApIHtcbiAgICBjb25zdCBycGNSZXF1ZXN0Qm9keSA9IHtcbiAgICAgIGlkLFxuICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgIG1ldGhvZCxcbiAgICAgIC4uLnBhcmFtcyAmJiB7IHBhcmFtcyB9XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5iYXNlRmV0Y2godGhpcy5ub2RlVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogc3RyaW5naWZ5MihycGNSZXF1ZXN0Qm9keSksXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICB9KTtcbiAgfVxuICBlcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIHJwY0Vycm9yLCBvdGhlckVycm9yKSB7XG4gICAgaWYgKHJwY0Vycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUnBjRXJyb3IocnBjRXJyb3IsIG1ldGhvZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgaWYgKG90aGVyRXJyb3IgaW5zdGFuY2VvZiBMaWJyYXJ5RXJyb3IpIHtcbiAgICAgIHRocm93IG90aGVyRXJyb3I7XG4gICAgfVxuICAgIGlmIChvdGhlckVycm9yKSB7XG4gICAgICB0aHJvdyBFcnJvcihvdGhlckVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmZXRjaEVuZHBvaW50KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmJhdGNoQ2xpZW50KSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IGVycm9yMiwgcmVzdWx0OiByZXN1bHQyIH0gPSBhd2FpdCB0aGlzLmJhdGNoQ2xpZW50LmZldGNoKFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgdGhpcy5yZXF1ZXN0SWQgKz0gMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgZXJyb3IyKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICB9XG4gICAgICBjb25zdCByYXdSZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoKG1ldGhvZCwgcGFyYW1zLCB0aGlzLnJlcXVlc3RJZCArPSAxKTtcbiAgICAgIGNvbnN0IHsgZXJyb3IsIHJlc3VsdCB9ID0gYXdhaXQgcmF3UmVzdWx0Lmpzb24oKTtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgZXJyb3I/LnJlc3BvbnNlPy5kYXRhLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICB0aGlzLmNoYWluSWQgPz89IGF3YWl0IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2NoYWluSWRcIik7XG4gICAgcmV0dXJuIHRoaXMuY2hhaW5JZDtcbiAgfVxuICBhc3luYyBnZXRTcGVjVmVyc2lvbigpIHtcbiAgICB0aGlzLnNwZWNWZXJzaW9uID8/PSBhd2FpdCB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9zcGVjVmVyc2lvblwiKTtcbiAgICByZXR1cm4gdGhpcy5zcGVjVmVyc2lvbjtcbiAgfVxuICBnZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Tm9uY2VcIiwge1xuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgaGFzaCBhbmQgbnVtYmVyXG4gICAqL1xuICBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9ibG9ja0hhc2hBbmROdW1iZXJcIik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgbnVtYmVyXG4gICAqIHJlZHVuZGFudCB1c2UgZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpO1xuICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgdGhlIGxhdGVzdCBibG9ja1xuICAgKi9cbiAgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2Jsb2NrTnVtYmVyXCIpO1xuICB9XG4gIGdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhUeEhhc2hlc1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrV2l0aFR4cyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tXaXRoVHhzXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0U3RhdGVVcGRhdGVcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1RyYW5zYWN0aW9uc1RyYWNlcyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfdHJhY2VCbG9ja1RyYW5zYWN0aW9uc1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudChibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50XCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25CeUhhc2godHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2hcbiAgICB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4KGJsb2NrSWRlbnRpZmllciwgaW5kZXgpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXhcIiwgeyBibG9ja19pZCwgaW5kZXggfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgeyB0cmFuc2FjdGlvbl9oYXNoIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uVHJhY2UodHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3RyYWNlVHJhbnNhY3Rpb25cIiwgeyB0cmFuc2FjdGlvbl9oYXNoIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YXR1cyBvZiBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHJhbnNhY3Rpb25IYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25TdGF0dXNcIiwgeyB0cmFuc2FjdGlvbl9oYXNoIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gaW52b2NhdGlvbnMgQWNjb3VudEludm9jYXRpb25zXG4gICAqIEBwYXJhbSBzaW11bGF0ZVRyYW5zYWN0aW9uT3B0aW9ucyBibG9ja0lkZW50aWZpZXIgYW5kIGZsYWdzIHRvIHNraXAgdmFsaWRhdGlvbiBhbmQgZmVlIGNoYXJnZTxici8+XG4gICAqIC0gYmxvY2tJZGVudGlmaWVyPGJyLz5cbiAgICogLSBza2lwVmFsaWRhdGUgKGRlZmF1bHQgZmFsc2UpPGJyLz5cbiAgICogLSBza2lwRmVlQ2hhcmdlIChkZWZhdWx0IHRydWUpPGJyLz5cbiAgICovXG4gIHNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZSA9IHRydWUsXG4gICAgICBza2lwRmVlQ2hhcmdlID0gdHJ1ZVxuICAgIH0gPSBzaW11bGF0ZVRyYW5zYWN0aW9uT3B0aW9ucztcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgY29uc3Qgc2ltdWxhdGlvbkZsYWdzID0gW107XG4gICAgaWYgKHNraXBWYWxpZGF0ZSkgc2ltdWxhdGlvbkZsYWdzLnB1c2gocnBjc3BlY18wXzZfZXhwb3J0cy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9WQUxJREFURSk7XG4gICAgaWYgKHNraXBGZWVDaGFyZ2UpIHNpbXVsYXRpb25GbGFncy5wdXNoKHJwY3NwZWNfMF82X2V4cG9ydHMuRVNpbXVsYXRpb25GbGFnLlNLSVBfRkVFX0NIQVJHRSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3NpbXVsYXRlVHJhbnNhY3Rpb25zXCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgdHJhbnNhY3Rpb25zOiBpbnZvY2F0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oaXQpKSxcbiAgICAgIHNpbXVsYXRpb25fZmxhZ3M6IHNpbXVsYXRpb25GbGFnc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbih0eEhhc2gsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIGxldCB7IHJldHJpZXMgfSA9IHRoaXM7XG4gICAgbGV0IG9uY2hhaW4gPSBmYWxzZTtcbiAgICBsZXQgaXNFcnJvclN0YXRlID0gZmFsc2U7XG4gICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IG9wdGlvbnM/LnJldHJ5SW50ZXJ2YWwgPz8gdGhpcy50cmFuc2FjdGlvblJldHJ5SW50ZXJ2YWxEZWZhdWx0O1xuICAgIGNvbnN0IGVycm9yU3RhdGVzID0gb3B0aW9ucz8uZXJyb3JTdGF0ZXMgPz8gW1xuICAgICAgcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25TdGF0dXMuUkVKRUNURURcbiAgICAgIC8vIFRPRE86IGNvbW1lbnRlZCBvdXQgdG8gcHJlc2VydmUgdGhlIGxvbmctc3RhbmRpbmcgYmVoYXZpb3Igb2YgXCJyZXZlcnRlZFwiIG5vdCBiZWluZyB0cmVhdGVkIGFzIGFuIGVycm9yIGJ5IGRlZmF1bHRcbiAgICAgIC8vIHNob3VsZCBkZWNpZGUgd2hpY2ggYmVoYXZpb3IgdG8ga2VlcCBpbiB0aGUgZnV0dXJlXG4gICAgICAvLyBSUEMuRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLlJFVkVSVEVELFxuICAgIF07XG4gICAgY29uc3Qgc3VjY2Vzc1N0YXRlcyA9IG9wdGlvbnM/LnN1Y2Nlc3NTdGF0ZXMgPz8gW1xuICAgICAgcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMuU1VDQ0VFREVELFxuICAgICAgcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25TdGF0dXMuQUNDRVBURURfT05fTDIsXG4gICAgICBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMVxuICAgIF07XG4gICAgbGV0IHR4U3RhdHVzO1xuICAgIHdoaWxlICghb25jaGFpbikge1xuICAgICAgYXdhaXQgd2FpdChyZXRyeUludGVydmFsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHR4U3RhdHVzID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICBjb25zdCBleGVjdXRpb25TdGF0dXMgPSB0eFN0YXR1cy5leGVjdXRpb25fc3RhdHVzO1xuICAgICAgICBjb25zdCBmaW5hbGl0eVN0YXR1cyA9IHR4U3RhdHVzLmZpbmFsaXR5X3N0YXR1cztcbiAgICAgICAgaWYgKCFmaW5hbGl0eVN0YXR1cykge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwid2FpdGluZyBmb3IgdHJhbnNhY3Rpb24gc3RhdHVzXCIpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvclN0YXRlcy5pbmNsdWRlcyhleGVjdXRpb25TdGF0dXMpIHx8IGVycm9yU3RhdGVzLmluY2x1ZGVzKGZpbmFsaXR5U3RhdHVzKSkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHtleGVjdXRpb25TdGF0dXN9OiAke2ZpbmFsaXR5U3RhdHVzfWA7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSB0eFN0YXR1cztcbiAgICAgICAgICBpc0Vycm9yU3RhdGUgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGVsc2UgaWYgKHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMoZXhlY3V0aW9uU3RhdHVzKSB8fCBzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKGZpbmFsaXR5U3RhdHVzKSkge1xuICAgICAgICAgIG9uY2hhaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBpc0Vycm9yU3RhdGUpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0cmllcyA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3YWl0Rm9yVHJhbnNhY3Rpb24gdGltZWQtb3V0IHdpdGggcmV0cmllcyAke3RoaXMucmV0cmllc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0cmllcyAtPSAxO1xuICAgIH1cbiAgICBsZXQgdHhSZWNlaXB0ID0gbnVsbDtcbiAgICB3aGlsZSAodHhSZWNlaXB0ID09PSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0eFJlY2VpcHQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHJldHJpZXMgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2FpdEZvclRyYW5zYWN0aW9uIHRpbWVkLW91dCB3aXRoIHJldHJpZXMgJHt0aGlzLnJldHJpZXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHJpZXMgLT0gMTtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgfVxuICAgIHJldHVybiB0eFJlY2VpcHQ7XG4gIH1cbiAgZ2V0U3RvcmFnZUF0KGNvbnRyYWN0QWRkcmVzcywga2V5LCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IHRvU3RvcmFnZUtleShrZXkpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0U3RvcmFnZUF0XCIsIHtcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICBrZXk6IHBhcnNlZEtleSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2xhc3NIYXNoQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NIYXNoQXRcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICBjb250cmFjdF9hZGRyZXNzXG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNsYXNzX2hhc2ggPSB0b0hleChjbGFzc0hhc2gpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NcIiwge1xuICAgICAgY2xhc3NfaGFzaCxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2xhc3NBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc0F0XCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgY29udHJhY3RfYWRkcmVzc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlKGludm9jYXRpb25zLCB7IGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSB0cnVlIH0pIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgbGV0IGZsYWdzID0ge307XG4gICAgaWYgKCFpc1ZlcnNpb24oXCIwLjVcIiwgYXdhaXQgdGhpcy5nZXRTcGVjVmVyc2lvbigpKSkge1xuICAgICAgZmxhZ3MgPSB7XG4gICAgICAgIHNpbXVsYXRpb25fZmxhZ3M6IHNraXBWYWxpZGF0ZSA/IFtycGNzcGVjXzBfNl9leHBvcnRzLkVTaW11bGF0aW9uRmxhZy5TS0lQX1ZBTElEQVRFXSA6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogaW52b2NhdGlvbnMubWFwKChpdCkgPT4gdGhpcy5idWlsZFRyYW5zYWN0aW9uKGl0LCBcImZlZVwiKSksXG4gICAgICBibG9ja19pZCxcbiAgICAgIC4uLmZsYWdzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgaW52b2tlKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBpbnZva2VfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogZnVuY3Rpb25JbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuSU5WT0tFLFxuICAgICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICAgIHZlcnNpb246IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoZnVuY3Rpb25JbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbG9nZ2VyLndhcm4oU1lTVEVNX01FU1NBR0VTLmxlZ2FjeVR4V2FybmluZ01lc3NhZ2UsIHtcbiAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuSU5WT0tFXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZEludm9rZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgaW52b2tlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLklOVk9LRSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogZnVuY3Rpb25JbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgICB2ZXJzaW9uOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KGZ1bmN0aW9uSW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICByZXNvdXJjZV9ib3VuZHM6IGRldGFpbHMucmVzb3VyY2VCb3VuZHMsXG4gICAgICAgICAgdGlwOiB0b0hleChkZXRhaWxzLnRpcCksXG4gICAgICAgICAgcGF5bWFzdGVyX2RhdGE6IGRldGFpbHMucGF5bWFzdGVyRGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICAgIGFjY291bnRfZGVwbG95bWVudF9kYXRhOiBkZXRhaWxzLmFjY291bnREZXBsb3ltZW50RGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICAgIG5vbmNlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgICBmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FpdE1vZGUgPyB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbigoYXdhaXQgcHJvbWlzZSkudHJhbnNhY3Rpb25faGFzaCkgOiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlY2xhcmUoeyBjb250cmFjdCwgc2lnbmF0dXJlLCBzZW5kZXJBZGRyZXNzLCBjb21waWxlZENsYXNzSGFzaCB9LCBkZXRhaWxzKSB7XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKCFpc1NpZXJyYShjb250cmFjdCkgJiYgIWlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgcHJvZ3JhbTogY29udHJhY3QucHJvZ3JhbSxcbiAgICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICAgIGFiaTogY29udHJhY3QuYWJpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZXJzaW9uOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbG9nZ2VyLndhcm4oU1lTVEVNX01FU1NBR0VTLmxlZ2FjeVR4V2FybmluZ01lc3NhZ2UsIHtcbiAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1NpZXJyYShjb250cmFjdCkgJiYgIWlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSxcbiAgICAgICAgICAgIGNvbnRyYWN0X2NsYXNzX3ZlcnNpb246IGNvbnRyYWN0LmNvbnRyYWN0X2NsYXNzX3ZlcnNpb24sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgICB2ZXJzaW9uOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbG9nZ2VyLndhcm4oU1lTVEVNX01FU1NBR0VTLmxlZ2FjeVR4V2FybmluZ01lc3NhZ2UsIHtcbiAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYyLFxuICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1NpZXJyYShjb250cmFjdCkgJiYgaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSxcbiAgICAgICAgICAgIGNvbnRyYWN0X2NsYXNzX3ZlcnNpb246IGNvbnRyYWN0LmNvbnRyYWN0X2NsYXNzX3ZlcnNpb24sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogZGV0YWlscy5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiZGVjbGFyZSB1bnNwb3R0ZWQgcGFyYW1ldGVyc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FpdE1vZGUgPyB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbigoYXdhaXQgcHJvbWlzZSkudHJhbnNhY3Rpb25faGFzaCkgOiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnQoeyBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGFkZHJlc3NTYWx0LCBzaWduYXR1cmUgfSwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVwbG95X2FjY291bnRfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoY2xhc3NIYXNoKSxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERVBMT1lfQUNDT1VOVCxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICB2ZXJzaW9uOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbG9nZ2VyLndhcm4oU1lTVEVNX01FU1NBR0VTLmxlZ2FjeVR4V2FybmluZ01lc3NhZ2UsIHtcbiAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVwbG95X2FjY291bnRfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQsXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgICBjbGFzc19oYXNoOiB0b0hleChjbGFzc0hhc2gpLFxuICAgICAgICAgIHJlc291cmNlX2JvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgICB0aXA6IHRvSGV4KGRldGFpbHMudGlwKSxcbiAgICAgICAgICBwYXltYXN0ZXJfZGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWl0TW9kZSA/IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKChhd2FpdCBwcm9taXNlKS50cmFuc2FjdGlvbl9oYXNoKSA6IHByb21pc2U7XG4gIH1cbiAgY2FsbENvbnRyYWN0KGNhbGwsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9jYWxsXCIsIHtcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCksXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjYWxsLmNhbGxkYXRhKVxuICAgICAgfSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE5FVzogRXN0aW1hdGUgdGhlIGZlZSBmb3IgYSBtZXNzYWdlIGZyb20gTDFcbiAgICogQHBhcmFtIG1lc3NhZ2UgTWVzc2FnZSBGcm9tIEwxXG4gICAqL1xuICBlc3RpbWF0ZU1lc3NhZ2VGZWUobWVzc2FnZSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCB7IGZyb21fYWRkcmVzcywgdG9fYWRkcmVzcywgZW50cnlfcG9pbnRfc2VsZWN0b3IsIHBheWxvYWQgfSA9IG1lc3NhZ2U7XG4gICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IHtcbiAgICAgIGZyb21fYWRkcmVzczogdmFsaWRhdGVBbmRQYXJzZUV0aEFkZHJlc3MoZnJvbV9hZGRyZXNzKSxcbiAgICAgIHRvX2FkZHJlc3M6IHRvSGV4KHRvX2FkZHJlc3MpLFxuICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3I6IGdldFNlbGVjdG9yKGVudHJ5X3BvaW50X3NlbGVjdG9yKSxcbiAgICAgIHBheWxvYWQ6IGdldEhleFN0cmluZ0FycmF5KHBheWxvYWQpXG4gICAgfTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlTWVzc2FnZUZlZVwiLCB7XG4gICAgICBtZXNzYWdlOiBmb3JtYXR0ZWRNZXNzYWdlLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYWJvdXQgdGhlIHN5bmMgc3RhdHVzLCBvciBmYWxzZSBpZiB0aGUgbm9kZSBpcyBub3Qgc3luY2hpbmdcbiAgICogQHJldHVybnMgT2JqZWN0IHdpdGggdGhlIHN0YXRzIGRhdGFcbiAgICovXG4gIGdldFN5bmNpbmdTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc3luY2luZ1wiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZXZlbnRzIG1hdGNoaW5nIHRoZSBnaXZlbiBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGFuZCB0aGUgcGFnaW5hdGlvbiBvZiB0aGUgZXZlbnRzXG4gICAqL1xuICBnZXRFdmVudHMoZXZlbnRGaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0RXZlbnRzXCIsIHsgZmlsdGVyOiBldmVudEZpbHRlciB9KTtcbiAgfVxuICBidWlsZFRyYW5zYWN0aW9uKGludm9jYXRpb24sIHZlcnNpb25UeXBlKSB7XG4gICAgY29uc3QgZGVmYXVsdFZlcnNpb25zID0gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpO1xuICAgIGxldCBkZXRhaWxzO1xuICAgIGlmICghaXNWM1R4KGludm9jYXRpb24pKSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGludm9jYXRpb24ubWF4RmVlIHx8IDApXG4gICAgICB9O1xuICAgICAgbG9nZ2VyLndhcm4oU1lTVEVNX01FU1NBR0VTLmxlZ2FjeVR4V2FybmluZ01lc3NhZ2UsIHtcbiAgICAgICAgdmVyc2lvbjogaW52b2NhdGlvbi52ZXJzaW9uLFxuICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIHJlc291cmNlX2JvdW5kczogaW52b2NhdGlvbi5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgdGlwOiB0b0hleChpbnZvY2F0aW9uLnRpcCksXG4gICAgICAgIHBheW1hc3Rlcl9kYXRhOiBpbnZvY2F0aW9uLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICBmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgYWNjb3VudF9kZXBsb3ltZW50X2RhdGE6IGludm9jYXRpb24uYWNjb3VudERlcGxveW1lbnREYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5JTlZPS0UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIHYwIHYxIHYzXG4gICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYzKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUpIHtcbiAgICAgIGlmICghaXNTaWVycmEoaW52b2NhdGlvbi5jb250cmFjdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IGludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgICAuLi5kZXRhaWxzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBDYWlybyAxIC0gdjIgdjNcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgIC4uLmludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGludm9jYXRpb24uY29udHJhY3Quc2llcnJhX3Byb2dyYW0pXG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGludm9jYXRpb24uY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MyksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5ERVBMT1lfQUNDT1VOVCkge1xuICAgICAgY29uc3QgeyBhY2NvdW50X2RlcGxveW1lbnRfZGF0YSwgLi4ucmVzdERldGFpbHMgfSA9IGRldGFpbHM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChpbnZvY2F0aW9uLmNvbnN0cnVjdG9yQ2FsbGRhdGEgfHwgW10pLFxuICAgICAgICBjbGFzc19oYXNoOiB0b0hleChpbnZvY2F0aW9uLmNsYXNzSGFzaCksXG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogdG9IZXgoaW52b2NhdGlvbi5hZGRyZXNzU2FsdCB8fCAwKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MyksXG4gICAgICAgIC4uLnJlc3REZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIlJQQyBidWlsZFRyYW5zYWN0aW9uIHJlY2VpdmVkIHVua25vd24gVHJhbnNhY3Rpb25UeXBlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvY2hhbm5lbC9ycGNfMF83LnRzXG52YXIgcnBjXzBfN19leHBvcnRzID0ge307XG5fX2V4cG9ydChycGNfMF83X2V4cG9ydHMsIHtcbiAgUnBjQ2hhbm5lbDogKCkgPT4gUnBjQ2hhbm5lbDJcbn0pO1xudmFyIGRlZmF1bHRPcHRpb25zMiA9IHtcbiAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICBibG9ja0lkZW50aWZpZXI6IEJsb2NrVGFnLlBFTkRJTkcsXG4gIHJldHJpZXM6IDIwMFxufTtcbnZhciBScGNDaGFubmVsMiA9IGNsYXNzIHtcbiAgbm9kZVVybDtcbiAgaGVhZGVycztcbiAgcmVxdWVzdElkO1xuICBibG9ja0lkZW50aWZpZXI7XG4gIHJldHJpZXM7XG4gIHdhaXRNb2RlO1xuICAvLyBiZWhhdmUgbGlrZSB3ZWIyIHJwYyBhbmQgcmV0dXJuIHdoZW4gdHggaXMgcHJvY2Vzc2VkXG4gIGNoYWluSWQ7XG4gIHNwZWNWZXJzaW9uO1xuICB0cmFuc2FjdGlvblJldHJ5SW50ZXJ2YWxGYWxsYmFjaztcbiAgYmF0Y2hDbGllbnQ7XG4gIGJhc2VGZXRjaDtcbiAgY29uc3RydWN0b3Iob3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlRmV0Y2gsXG4gICAgICBiYXRjaCxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIGNoYWluSWQsXG4gICAgICBoZWFkZXJzLFxuICAgICAgbm9kZVVybCxcbiAgICAgIHJldHJpZXMsXG4gICAgICBzcGVjVmVyc2lvbixcbiAgICAgIHRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbEZhbGxiYWNrLFxuICAgICAgd2FpdE1vZGVcbiAgICB9ID0gb3B0aW9uc09yUHJvdmlkZXIgfHwge307XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoTmV0d29ya05hbWUpLmluY2x1ZGVzKG5vZGVVcmwpKSB7XG4gICAgICB0aGlzLm5vZGVVcmwgPSBnZXREZWZhdWx0Tm9kZVVybChub2RlVXJsLCBvcHRpb25zT3JQcm92aWRlcj8uZGVmYXVsdCk7XG4gICAgfSBlbHNlIGlmIChub2RlVXJsKSB7XG4gICAgICB0aGlzLm5vZGVVcmwgPSBub2RlVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vZGVVcmwgPSBnZXREZWZhdWx0Tm9kZVVybCh2b2lkIDAsIG9wdGlvbnNPclByb3ZpZGVyPy5kZWZhdWx0KTtcbiAgICB9XG4gICAgdGhpcy5iYXNlRmV0Y2ggPSBiYXNlRmV0Y2ggPz8gZmV0Y2hQb255ZmlsbF9kZWZhdWx0O1xuICAgIHRoaXMuYmxvY2tJZGVudGlmaWVyID0gYmxvY2tJZGVudGlmaWVyID8/IGRlZmF1bHRPcHRpb25zMi5ibG9ja0lkZW50aWZpZXI7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB0aGlzLmhlYWRlcnMgPSB7IC4uLmRlZmF1bHRPcHRpb25zMi5oZWFkZXJzLCAuLi5oZWFkZXJzIH07XG4gICAgdGhpcy5yZXRyaWVzID0gcmV0cmllcyA/PyBkZWZhdWx0T3B0aW9uczIucmV0cmllcztcbiAgICB0aGlzLnNwZWNWZXJzaW9uID0gc3BlY1ZlcnNpb247XG4gICAgdGhpcy50cmFuc2FjdGlvblJldHJ5SW50ZXJ2YWxGYWxsYmFjayA9IHRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbEZhbGxiYWNrO1xuICAgIHRoaXMud2FpdE1vZGUgPSB3YWl0TW9kZSA/PyBmYWxzZTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IDA7XG4gICAgaWYgKHR5cGVvZiBiYXRjaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5iYXRjaENsaWVudCA9IG5ldyBCYXRjaENsaWVudCh7XG4gICAgICAgIG5vZGVVcmw6IHRoaXMubm9kZVVybCxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBpbnRlcnZhbDogYmF0Y2gsXG4gICAgICAgIGJhc2VGZXRjaDogdGhpcy5iYXNlRmV0Y2hcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgdHJhbnNhY3Rpb25SZXRyeUludGVydmFsRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvblJldHJ5SW50ZXJ2YWxGYWxsYmFjayA/PyA1ZTM7XG4gIH1cbiAgc2V0Q2hhaW5JZChjaGFpbklkKSB7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgfVxuICBmZXRjaChtZXRob2QsIHBhcmFtcywgaWQgPSAwKSB7XG4gICAgY29uc3QgcnBjUmVxdWVzdEJvZHkgPSB7XG4gICAgICBpZCxcbiAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICBtZXRob2QsXG4gICAgICAuLi5wYXJhbXMgJiYgeyBwYXJhbXMgfVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuYmFzZUZldGNoKHRoaXMubm9kZVVybCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHN0cmluZ2lmeTIocnBjUmVxdWVzdEJvZHkpLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgfSk7XG4gIH1cbiAgZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBycGNFcnJvciwgb3RoZXJFcnJvcikge1xuICAgIGlmIChycGNFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFJwY0Vycm9yKHJwY0Vycm9yLCBtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxuICAgIGlmIChvdGhlckVycm9yIGluc3RhbmNlb2YgTGlicmFyeUVycm9yKSB7XG4gICAgICB0aHJvdyBvdGhlckVycm9yO1xuICAgIH1cbiAgICBpZiAob3RoZXJFcnJvcikge1xuICAgICAgdGhyb3cgRXJyb3Iob3RoZXJFcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZmV0Y2hFbmRwb2ludChtZXRob2QsIHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5iYXRjaENsaWVudCkge1xuICAgICAgICBjb25zdCB7IGVycm9yOiBlcnJvcjIsIHJlc3VsdDogcmVzdWx0MiB9ID0gYXdhaXQgdGhpcy5iYXRjaENsaWVudC5mZXRjaChcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgIHRoaXMucmVxdWVzdElkICs9IDFcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIGVycm9yMik7XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgfVxuICAgICAgY29uc3QgcmF3UmVzdWx0ID0gYXdhaXQgdGhpcy5mZXRjaChtZXRob2QsIHBhcmFtcywgdGhpcy5yZXF1ZXN0SWQgKz0gMSk7XG4gICAgICBjb25zdCB7IGVycm9yLCByZXN1bHQgfSA9IGF3YWl0IHJhd1Jlc3VsdC5qc29uKCk7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIGVycm9yPy5yZXNwb25zZT8uZGF0YSwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgdGhpcy5jaGFpbklkID8/PSBhd2FpdCB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9jaGFpbklkXCIpO1xuICAgIHJldHVybiB0aGlzLmNoYWluSWQ7XG4gIH1cbiAgYXN5bmMgZ2V0U3BlY1ZlcnNpb24oKSB7XG4gICAgdGhpcy5zcGVjVmVyc2lvbiA/Pz0gYXdhaXQgdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc3BlY1ZlcnNpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuc3BlY1ZlcnNpb247XG4gIH1cbiAgZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldE5vbmNlXCIsIHtcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IGFjY2VwdGVkIGJsb2NrIGhhc2ggYW5kIG51bWJlclxuICAgKi9cbiAgZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYmxvY2tIYXNoQW5kTnVtYmVyXCIpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IGFjY2VwdGVkIGJsb2NrIG51bWJlclxuICAgKiByZWR1bmRhbnQgdXNlIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKTtcbiAgICogQHJldHVybnMgTnVtYmVyIG9mIHRoZSBsYXRlc3QgYmxvY2tcbiAgICovXG4gIGdldEJsb2NrTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9ibG9ja051bWJlclwiKTtcbiAgfVxuICBnZXRCbG9ja1dpdGhUeEhhc2hlcyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tXaXRoVHhIYXNoZXNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1dpdGhUeHMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrV2l0aFR4c1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrV2l0aFJlY2VpcHRzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhSZWNlaXB0c1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrU3RhdGVVcGRhdGUoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFN0YXRlVXBkYXRlXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3RyYWNlQmxvY2tUcmFuc2FjdGlvbnNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudFwiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uQnlIYXNoKHR4SGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLCB7XG4gICAgICB0cmFuc2FjdGlvbl9oYXNoXG4gICAgfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleChibG9ja0lkZW50aWZpZXIsIGluZGV4KSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4XCIsIHsgYmxvY2tfaWQsIGluZGV4IH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIHsgdHJhbnNhY3Rpb25faGFzaCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvblRyYWNlKHR4SGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF90cmFjZVRyYW5zYWN0aW9uXCIsIHsgdHJhbnNhY3Rpb25faGFzaCB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0dXMgb2YgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uU3RhdHVzXCIsIHsgdHJhbnNhY3Rpb25faGFzaCB9KTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIGludm9jYXRpb25zIEFjY291bnRJbnZvY2F0aW9uc1xuICAgKiBAcGFyYW0gc2ltdWxhdGVUcmFuc2FjdGlvbk9wdGlvbnMgYmxvY2tJZGVudGlmaWVyIGFuZCBmbGFncyB0byBza2lwIHZhbGlkYXRpb24gYW5kIGZlZSBjaGFyZ2U8YnIvPlxuICAgKiAtIGJsb2NrSWRlbnRpZmllcjxici8+XG4gICAqIC0gc2tpcFZhbGlkYXRlIChkZWZhdWx0IGZhbHNlKTxici8+XG4gICAqIC0gc2tpcEZlZUNoYXJnZSAoZGVmYXVsdCB0cnVlKTxici8+XG4gICAqL1xuICBzaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCBzaW11bGF0ZVRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGUgPSB0cnVlLFxuICAgICAgc2tpcEZlZUNoYXJnZSA9IHRydWVcbiAgICB9ID0gc2ltdWxhdGVUcmFuc2FjdGlvbk9wdGlvbnM7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGNvbnN0IHNpbXVsYXRpb25GbGFncyA9IFtdO1xuICAgIGlmIChza2lwVmFsaWRhdGUpIHNpbXVsYXRpb25GbGFncy5wdXNoKFJQQ1NQRUMwNy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9WQUxJREFURSk7XG4gICAgaWYgKHNraXBGZWVDaGFyZ2UpIHNpbXVsYXRpb25GbGFncy5wdXNoKFJQQ1NQRUMwNy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9GRUVfQ0hBUkdFKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc2ltdWxhdGVUcmFuc2FjdGlvbnNcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICB0cmFuc2FjdGlvbnM6IGludm9jYXRpb25zLm1hcCgoaXQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpdCkpLFxuICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2ltdWxhdGlvbkZsYWdzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgbGV0IHsgcmV0cmllcyB9ID0gdGhpcztcbiAgICBsZXQgb25jaGFpbiA9IGZhbHNlO1xuICAgIGxldCBpc0Vycm9yU3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gb3B0aW9ucz8ucmV0cnlJbnRlcnZhbCA/PyB0aGlzLnRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbERlZmF1bHQ7XG4gICAgY29uc3QgZXJyb3JTdGF0ZXMgPSBvcHRpb25zPy5lcnJvclN0YXRlcyA/PyBbXG4gICAgICBSUENTUEVDMDcuRVRyYW5zYWN0aW9uU3RhdHVzLlJFSkVDVEVEXG4gICAgICAvLyBUT0RPOiBjb21tZW50ZWQgb3V0IHRvIHByZXNlcnZlIHRoZSBsb25nLXN0YW5kaW5nIGJlaGF2aW9yIG9mIFwicmV2ZXJ0ZWRcIiBub3QgYmVpbmcgdHJlYXRlZCBhcyBhbiBlcnJvciBieSBkZWZhdWx0XG4gICAgICAvLyBzaG91bGQgZGVjaWRlIHdoaWNoIGJlaGF2aW9yIHRvIGtlZXAgaW4gdGhlIGZ1dHVyZVxuICAgICAgLy8gUlBDLkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cy5SRVZFUlRFRCxcbiAgICBdO1xuICAgIGNvbnN0IHN1Y2Nlc3NTdGF0ZXMgPSBvcHRpb25zPy5zdWNjZXNzU3RhdGVzID8/IFtcbiAgICAgIFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMuU1VDQ0VFREVELFxuICAgICAgUlBDU1BFQzA3LkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMixcbiAgICAgIFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25TdGF0dXMuQUNDRVBURURfT05fTDFcbiAgICBdO1xuICAgIGxldCB0eFN0YXR1cztcbiAgICB3aGlsZSAoIW9uY2hhaW4pIHtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICB0cnkge1xuICAgICAgICB0eFN0YXR1cyA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uU3RhdHVzID0gdHhTdGF0dXMuZXhlY3V0aW9uX3N0YXR1cztcbiAgICAgICAgY29uc3QgZmluYWxpdHlTdGF0dXMgPSB0eFN0YXR1cy5maW5hbGl0eV9zdGF0dXM7XG4gICAgICAgIGlmICghZmluYWxpdHlTdGF0dXMpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIndhaXRpbmcgZm9yIHRyYW5zYWN0aW9uIHN0YXR1c1wiKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JTdGF0ZXMuaW5jbHVkZXMoZXhlY3V0aW9uU3RhdHVzKSB8fCBlcnJvclN0YXRlcy5pbmNsdWRlcyhmaW5hbGl0eVN0YXR1cykpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7ZXhlY3V0aW9uU3RhdHVzfTogJHtmaW5hbGl0eVN0YXR1c31gO1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGVycm9yLnJlc3BvbnNlID0gdHhTdGF0dXM7XG4gICAgICAgICAgaXNFcnJvclN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBlbHNlIGlmIChzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKGV4ZWN1dGlvblN0YXR1cykgfHwgc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhmaW5hbGl0eVN0YXR1cykpIHtcbiAgICAgICAgICBvbmNoYWluID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgaXNFcnJvclN0YXRlKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldHJpZXMgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2FpdEZvclRyYW5zYWN0aW9uIHRpbWVkLW91dCB3aXRoIHJldHJpZXMgJHt0aGlzLnJldHJpZXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHJpZXMgLT0gMTtcbiAgICB9XG4gICAgbGV0IHR4UmVjZWlwdCA9IG51bGw7XG4gICAgd2hpbGUgKHR4UmVjZWlwdCA9PT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHhSZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChyZXRyaWVzIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhaXRGb3JUcmFuc2FjdGlvbiB0aW1lZC1vdXQgd2l0aCByZXRyaWVzICR7dGhpcy5yZXRyaWVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXRyaWVzIC09IDE7XG4gICAgICBhd2FpdCB3YWl0KHJldHJ5SW50ZXJ2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdHhSZWNlaXB0O1xuICB9XG4gIGdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBwYXJzZWRLZXkgPSB0b1N0b3JhZ2VLZXkoa2V5KTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFN0b3JhZ2VBdFwiLCB7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAga2V5OiBwYXJzZWRLZXksXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIGdldENsYXNzSGFzaEF0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzSGFzaEF0XCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgY29udHJhY3RfYWRkcmVzc1xuICAgIH0pO1xuICB9XG4gIGdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjbGFzc19oYXNoID0gdG9IZXgoY2xhc3NIYXNoKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzXCIsIHtcbiAgICAgIGNsYXNzX2hhc2gsXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NBdFwiLCB7XG4gICAgICBibG9ja19pZCxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3NcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRFc3RpbWF0ZUZlZShpbnZvY2F0aW9ucywgeyBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gdHJ1ZSB9KSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGxldCBmbGFncyA9IHt9O1xuICAgIGlmICghaXNWZXJzaW9uKFwiMC41XCIsIGF3YWl0IHRoaXMuZ2V0U3BlY1ZlcnNpb24oKSkpIHtcbiAgICAgIGZsYWdzID0ge1xuICAgICAgICBzaW11bGF0aW9uX2ZsYWdzOiBza2lwVmFsaWRhdGUgPyBbUlBDU1BFQzA3LkVTaW11bGF0aW9uRmxhZy5TS0lQX1ZBTElEQVRFXSA6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogaW52b2NhdGlvbnMubWFwKChpdCkgPT4gdGhpcy5idWlsZFRyYW5zYWN0aW9uKGl0LCBcImZlZVwiKSksXG4gICAgICBibG9ja19pZCxcbiAgICAgIC4uLmZsYWdzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgaW52b2tlKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBpbnZva2VfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogZnVuY3Rpb25JbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KGZ1bmN0aW9uSW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxvZ2dlci53YXJuKFNZU1RFTV9NRVNTQUdFUy5sZWdhY3lUeFdhcm5pbmdNZXNzYWdlLCB7XG4gICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBpbnZva2VfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGZ1bmN0aW9uSW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGZ1bmN0aW9uSW52b2NhdGlvbi5jYWxsZGF0YSksXG4gICAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjMsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KGZ1bmN0aW9uSW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICByZXNvdXJjZV9ib3VuZHM6IGRldGFpbHMucmVzb3VyY2VCb3VuZHMsXG4gICAgICAgICAgdGlwOiB0b0hleChkZXRhaWxzLnRpcCksXG4gICAgICAgICAgcGF5bWFzdGVyX2RhdGE6IGRldGFpbHMucGF5bWFzdGVyRGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICAgIGFjY291bnRfZGVwbG95bWVudF9kYXRhOiBkZXRhaWxzLmFjY291bnREZXBsb3ltZW50RGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICAgIG5vbmNlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgICBmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FpdE1vZGUgPyB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbigoYXdhaXQgcHJvbWlzZSkudHJhbnNhY3Rpb25faGFzaCkgOiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlY2xhcmUoeyBjb250cmFjdCwgc2lnbmF0dXJlLCBzZW5kZXJBZGRyZXNzLCBjb21waWxlZENsYXNzSGFzaCB9LCBkZXRhaWxzKSB7XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKCFpc1NpZXJyYShjb250cmFjdCkgJiYgIWlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgICBwcm9ncmFtOiBjb250cmFjdC5wcm9ncmFtLFxuICAgICAgICAgICAgZW50cnlfcG9pbnRzX2J5X3R5cGU6IGNvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLFxuICAgICAgICAgICAgYWJpOiBjb250cmFjdC5hYmlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxvZ2dlci53YXJuKFNZU1RFTV9NRVNTQUdFUy5sZWdhY3lUeFdhcm5pbmdNZXNzYWdlLCB7XG4gICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzU2llcnJhKGNvbnRyYWN0KSAmJiAhaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShjb250cmFjdC5zaWVycmFfcHJvZ3JhbSksXG4gICAgICAgICAgICBjb250cmFjdF9jbGFzc192ZXJzaW9uOiBjb250cmFjdC5jb250cmFjdF9jbGFzc192ZXJzaW9uLFxuICAgICAgICAgICAgZW50cnlfcG9pbnRzX2J5X3R5cGU6IGNvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLFxuICAgICAgICAgICAgYWJpOiBjb250cmFjdC5hYmlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjIsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbG9nZ2VyLndhcm4oU1lTVEVNX01FU1NBR0VTLmxlZ2FjeVR4V2FybmluZ01lc3NhZ2UsIHtcbiAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjIsXG4gICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNTaWVycmEoY29udHJhY3QpICYmIGlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjMsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgICBzaWVycmFfcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oY29udHJhY3Quc2llcnJhX3Byb2dyYW0pLFxuICAgICAgICAgICAgY29udHJhY3RfY2xhc3NfdmVyc2lvbjogY29udHJhY3QuY29udHJhY3RfY2xhc3NfdmVyc2lvbixcbiAgICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICAgIGFiaTogY29udHJhY3QuYWJpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNvdXJjZV9ib3VuZHM6IGRldGFpbHMucmVzb3VyY2VCb3VuZHMsXG4gICAgICAgICAgdGlwOiB0b0hleChkZXRhaWxzLnRpcCksXG4gICAgICAgICAgcGF5bWFzdGVyX2RhdGE6IGRldGFpbHMucGF5bWFzdGVyRGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICAgIGFjY291bnRfZGVwbG95bWVudF9kYXRhOiBkZXRhaWxzLmFjY291bnREZXBsb3ltZW50RGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICAgIG5vbmNlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgICBmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJkZWNsYXJlIHVuc3BvdHRlZCBwYXJhbWV0ZXJzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWl0TW9kZSA/IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKChhd2FpdCBwcm9taXNlKS50cmFuc2FjdGlvbl9oYXNoKSA6IHByb21pc2U7XG4gIH1cbiAgYXN5bmMgZGVwbG95QWNjb3VudCh7IGNsYXNzSGFzaCwgY29uc3RydWN0b3JDYWxsZGF0YSwgYWRkcmVzc1NhbHQsIHNpZ25hdHVyZSB9LCBkZXRhaWxzKSB7XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKCFpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBkZXBsb3lfYWNjb3VudF90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgICBjbGFzc19oYXNoOiB0b0hleChjbGFzc0hhc2gpLFxuICAgICAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogdG9IZXgoYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbG9nZ2VyLndhcm4oU1lTVEVNX01FU1NBR0VTLmxlZ2FjeVR4V2FybmluZ01lc3NhZ2UsIHtcbiAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLkRFUExPWV9BQ0NPVU5UXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlcGxveUFjY291bnRUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlcGxveV9hY2NvdW50X3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQsXG4gICAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjMsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogdG9IZXgoYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGNvbnN0cnVjdG9yQ2FsbGRhdGEgfHwgW10pLFxuICAgICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGNsYXNzSGFzaCksXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhaXRNb2RlID8gdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oKGF3YWl0IHByb21pc2UpLnRyYW5zYWN0aW9uX2hhc2gpIDogcHJvbWlzZTtcbiAgfVxuICBjYWxsQ29udHJhY3QoY2FsbCwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2NhbGxcIiwge1xuICAgICAgcmVxdWVzdDoge1xuICAgICAgICBjb250cmFjdF9hZGRyZXNzOiBjYWxsLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3I6IGdldFNlbGVjdG9yRnJvbU5hbWUoY2FsbC5lbnRyeXBvaW50KSxcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGNhbGwuY2FsbGRhdGEpXG4gICAgICB9LFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTkVXOiBFc3RpbWF0ZSB0aGUgZmVlIGZvciBhIG1lc3NhZ2UgZnJvbSBMMVxuICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIEZyb20gTDFcbiAgICovXG4gIGVzdGltYXRlTWVzc2FnZUZlZShtZXNzYWdlLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IHsgZnJvbV9hZGRyZXNzLCB0b19hZGRyZXNzLCBlbnRyeV9wb2ludF9zZWxlY3RvciwgcGF5bG9hZCB9ID0gbWVzc2FnZTtcbiAgICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlID0ge1xuICAgICAgZnJvbV9hZGRyZXNzOiB2YWxpZGF0ZUFuZFBhcnNlRXRoQWRkcmVzcyhmcm9tX2FkZHJlc3MpLFxuICAgICAgdG9fYWRkcmVzczogdG9IZXgodG9fYWRkcmVzcyksXG4gICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3IoZW50cnlfcG9pbnRfc2VsZWN0b3IpLFxuICAgICAgcGF5bG9hZDogZ2V0SGV4U3RyaW5nQXJyYXkocGF5bG9hZClcbiAgICB9O1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVNZXNzYWdlRmVlXCIsIHtcbiAgICAgIG1lc3NhZ2U6IGZvcm1hdHRlZE1lc3NhZ2UsXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBhYm91dCB0aGUgc3luYyBzdGF0dXMsIG9yIGZhbHNlIGlmIHRoZSBub2RlIGlzIG5vdCBzeW5jaGluZ1xuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCB0aGUgc3RhdHMgZGF0YVxuICAgKi9cbiAgZ2V0U3luY2luZ1N0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9zeW5jaW5nXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBldmVudHMgbWF0Y2hpbmcgdGhlIGdpdmVuIGZpbHRlclxuICAgKiBAcmV0dXJucyBldmVudHMgYW5kIHRoZSBwYWdpbmF0aW9uIG9mIHRoZSBldmVudHNcbiAgICovXG4gIGdldEV2ZW50cyhldmVudEZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRFdmVudHNcIiwgeyBmaWx0ZXI6IGV2ZW50RmlsdGVyIH0pO1xuICB9XG4gIGJ1aWxkVHJhbnNhY3Rpb24oaW52b2NhdGlvbiwgdmVyc2lvblR5cGUpIHtcbiAgICBjb25zdCBkZWZhdWx0VmVyc2lvbnMgPSBnZXRWZXJzaW9uc0J5VHlwZSh2ZXJzaW9uVHlwZSk7XG4gICAgbGV0IGRldGFpbHM7XG4gICAgaWYgKCFpc1YzVHgoaW52b2NhdGlvbikpIHtcbiAgICAgIGRldGFpbHMgPSB7XG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShpbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgIG5vbmNlOiB0b0hleChpbnZvY2F0aW9uLm5vbmNlKSxcbiAgICAgICAgbWF4X2ZlZTogdG9IZXgoaW52b2NhdGlvbi5tYXhGZWUgfHwgMClcbiAgICAgIH07XG4gICAgICBsb2dnZXIud2FybihTWVNURU1fTUVTU0FHRVMubGVnYWN5VHhXYXJuaW5nTWVzc2FnZSwge1xuICAgICAgICB2ZXJzaW9uOiBpbnZvY2F0aW9uLnZlcnNpb24sXG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFpbHMgPSB7XG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShpbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgIG5vbmNlOiB0b0hleChpbnZvY2F0aW9uLm5vbmNlKSxcbiAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBpbnZvY2F0aW9uLnJlc291cmNlQm91bmRzLFxuICAgICAgICB0aXA6IHRvSGV4KGludm9jYXRpb24udGlwKSxcbiAgICAgICAgcGF5bWFzdGVyX2RhdGE6IGludm9jYXRpb24ucGF5bWFzdGVyRGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBpbnZvY2F0aW9uLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBpbnZvY2F0aW9uLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogaW52b2NhdGlvbi5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLklOVk9LRSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gdjAgdjEgdjNcbiAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuSU5WT0tFLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChpbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MyksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFKSB7XG4gICAgICBpZiAoIWlzU2llcnJhKGludm9jYXRpb24uY29udHJhY3QpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MSksXG4gICAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gQ2Fpcm8gMSAtIHYyIHYzXG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShpbnZvY2F0aW9uLmNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKVxuICAgICAgICB9LFxuICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBpbnZvY2F0aW9uLmNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjMpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQpIHtcbiAgICAgIGNvbnN0IHsgYWNjb3VudF9kZXBsb3ltZW50X2RhdGEsIC4uLnJlc3REZXRhaWxzIH0gPSBkZXRhaWxzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoaW52b2NhdGlvbi5jb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoaW52b2NhdGlvbi5jbGFzc0hhc2gpLFxuICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGludm9jYXRpb24uYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjMpLFxuICAgICAgICAuLi5yZXN0RGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJSUEMgYnVpbGRUcmFuc2FjdGlvbiByZWNlaXZlZCB1bmtub3duIFRyYW5zYWN0aW9uVHlwZVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3Jlc3BvbnNlUGFyc2VyL3JwYy50c1xudmFyIFJQQ1Jlc3BvbnNlUGFyc2VyID0gY2xhc3Mge1xuICBtYXJnaW47XG4gIGNvbnN0cnVjdG9yKG1hcmdpbikge1xuICAgIHRoaXMubWFyZ2luID0gbWFyZ2luO1xuICB9XG4gIGVzdGltYXRlZEZlZVRvTWF4RmVlKGVzdGltYXRlZEZlZSkge1xuICAgIHJldHVybiBlc3RpbWF0ZWRGZWVUb01heEZlZShlc3RpbWF0ZWRGZWUsIHRoaXMubWFyZ2luPy5tYXhGZWUpO1xuICB9XG4gIGVzdGltYXRlRmVlVG9Cb3VuZHMoZXN0aW1hdGUpIHtcbiAgICByZXR1cm4gZXN0aW1hdGVGZWVUb0JvdW5kcyhcbiAgICAgIGVzdGltYXRlLFxuICAgICAgdGhpcy5tYXJnaW4/LmwxQm91bmRNYXhBbW91bnQsXG4gICAgICB0aGlzLm1hcmdpbj8ubDFCb3VuZE1heFByaWNlUGVyVW5pdFxuICAgICk7XG4gIH1cbiAgcGFyc2VHZXRCbG9ja1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7IHN0YXR1czogXCJQRU5ESU5HXCIsIC4uLnJlcyB9O1xuICB9XG4gIHBhcnNlVHJhbnNhY3Rpb25SZWNlaXB0KHJlcykge1xuICAgIGlmIChcImFjdHVhbF9mZWVcIiBpbiByZXMgJiYgaXNTdHJpbmcocmVzLmFjdHVhbF9mZWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXMsXG4gICAgICAgIGFjdHVhbF9mZWU6IHtcbiAgICAgICAgICBhbW91bnQ6IHJlcy5hY3R1YWxfZmVlLFxuICAgICAgICAgIHVuaXQ6IFwiRlJJXCJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBwYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UocmVzKSB7XG4gICAgY29uc3QgdmFsID0gcmVzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQodmFsLmdhc19jb25zdW1lZCksXG4gICAgICBnYXNfcHJpY2U6IHRvQmlnSW50KHZhbC5nYXNfcHJpY2UpLFxuICAgICAgdW5pdDogdmFsLnVuaXQsXG4gICAgICBzdWdnZXN0ZWRNYXhGZWU6IHRoaXMuZXN0aW1hdGVkRmVlVG9NYXhGZWUodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIHJlc291cmNlQm91bmRzOiB0aGlzLmVzdGltYXRlRmVlVG9Cb3VuZHModmFsKSxcbiAgICAgIGRhdGFfZ2FzX2NvbnN1bWVkOiB2YWwuZGF0YV9nYXNfY29uc3VtZWQgPyB0b0JpZ0ludCh2YWwuZGF0YV9nYXNfY29uc3VtZWQpIDogMG4sXG4gICAgICBkYXRhX2dhc19wcmljZTogdmFsLmRhdGFfZ2FzX3ByaWNlID8gdG9CaWdJbnQodmFsLmRhdGFfZ2FzX3ByaWNlKSA6IDBuXG4gICAgfTtcbiAgfVxuICBwYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubWFwKCh2YWwpID0+ICh7XG4gICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQodmFsLmdhc19jb25zdW1lZCksXG4gICAgICBnYXNfcHJpY2U6IHRvQmlnSW50KHZhbC5nYXNfcHJpY2UpLFxuICAgICAgdW5pdDogdmFsLnVuaXQsXG4gICAgICBzdWdnZXN0ZWRNYXhGZWU6IHRoaXMuZXN0aW1hdGVkRmVlVG9NYXhGZWUodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIHJlc291cmNlQm91bmRzOiB0aGlzLmVzdGltYXRlRmVlVG9Cb3VuZHModmFsKSxcbiAgICAgIGRhdGFfZ2FzX2NvbnN1bWVkOiB2YWwuZGF0YV9nYXNfY29uc3VtZWQgPyB0b0JpZ0ludCh2YWwuZGF0YV9nYXNfY29uc3VtZWQpIDogMG4sXG4gICAgICBkYXRhX2dhc19wcmljZTogdmFsLmRhdGFfZ2FzX3ByaWNlID8gdG9CaWdJbnQodmFsLmRhdGFfZ2FzX3ByaWNlKSA6IDBuXG4gICAgfSkpO1xuICB9XG4gIHBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubWFwKChpdCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXQsXG4gICAgICAgIHN1Z2dlc3RlZE1heEZlZTogdGhpcy5lc3RpbWF0ZWRGZWVUb01heEZlZShpdC5mZWVfZXN0aW1hdGlvbi5vdmVyYWxsX2ZlZSksXG4gICAgICAgIHJlc291cmNlQm91bmRzOiB0aGlzLmVzdGltYXRlRmVlVG9Cb3VuZHMoaXQuZmVlX2VzdGltYXRpb24pXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXMsXG4gICAgICBhYmk6IGlzU3RyaW5nKHJlcy5hYmkpID8gSlNPTi5wYXJzZShyZXMuYWJpKSA6IHJlcy5hYmlcbiAgICB9O1xuICB9XG4gIHBhcnNlTDFHYXNQcmljZVJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubDFfZ2FzX3ByaWNlLnByaWNlX2luX3dlaTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3RyYW5zYWN0aW9uUmVjZWlwdC50c1xudmFyIFJlY2VpcHRUeCA9IGNsYXNzIF9SZWNlaXB0VHgge1xuICBzdGF0dXNSZWNlaXB0O1xuICB2YWx1ZTtcbiAgY29uc3RydWN0b3IocmVjZWlwdCkge1xuICAgIFt0aGlzLnN0YXR1c1JlY2VpcHQsIHRoaXMudmFsdWVdID0gX1JlY2VpcHRUeC5pc1N1Y2Nlc3MocmVjZWlwdCkgPyBbXCJzdWNjZXNzXCIsIHJlY2VpcHRdIDogX1JlY2VpcHRUeC5pc1JldmVydGVkKHJlY2VpcHQpID8gW1wicmV2ZXJ0ZWRcIiwgcmVjZWlwdF0gOiBfUmVjZWlwdFR4LmlzUmVqZWN0ZWQocmVjZWlwdCkgPyBbXCJyZWplY3RlZFwiLCByZWNlaXB0XSA6IFtcImVycm9yXCIsIG5ldyBFcnJvcihcIlVua25vd24gcmVzcG9uc2UgdHlwZVwiKV07XG4gICAgZm9yIChjb25zdCBba2V5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlY2VpcHQpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBtYXRjaChjYWxsYmFja3MpIHtcbiAgICBpZiAodGhpcy5zdGF0dXNSZWNlaXB0IGluIGNhbGxiYWNrcykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrc1t0aGlzLnN0YXR1c1JlY2VpcHRdKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2tzLl8oKTtcbiAgfVxuICBpc1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzUmVjZWlwdCA9PT0gXCJzdWNjZXNzXCI7XG4gIH1cbiAgaXNSZXZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXNSZWNlaXB0ID09PSBcInJldmVydGVkXCI7XG4gIH1cbiAgaXNSZWplY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXNSZWNlaXB0ID09PSBcInJlamVjdGVkXCI7XG4gIH1cbiAgaXNFcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXNSZWNlaXB0ID09PSBcImVycm9yXCI7XG4gIH1cbiAgc3RhdGljIGlzU3VjY2Vzcyh0cmFuc2FjdGlvblJlY2VpcHQpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25SZWNlaXB0LmV4ZWN1dGlvbl9zdGF0dXMgPT09IFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLlNVQ0NFRURFRDtcbiAgfVxuICBzdGF0aWMgaXNSZXZlcnRlZCh0cmFuc2FjdGlvblJlY2VpcHQpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25SZWNlaXB0LmV4ZWN1dGlvbl9zdGF0dXMgPT09IFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLlJFVkVSVEVEO1xuICB9XG4gIHN0YXRpYyBpc1JlamVjdGVkKHRyYW5zYWN0aW9uUmVjZWlwdCkge1xuICAgIHJldHVybiB0cmFuc2FjdGlvblJlY2VpcHQuc3RhdHVzID09PSBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cy5SRUpFQ1RFRDtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3R5cGVkRGF0YS50c1xudmFyIHR5cGVkRGF0YV9leHBvcnRzID0ge307XG5fX2V4cG9ydCh0eXBlZERhdGFfZXhwb3J0cywge1xuICBUeXBlZERhdGFSZXZpc2lvbjogKCkgPT4gVHlwZWREYXRhUmV2aXNpb24sXG4gIGVuY29kZURhdGE6ICgpID0+IGVuY29kZURhdGEsXG4gIGVuY29kZVR5cGU6ICgpID0+IGVuY29kZVR5cGUsXG4gIGVuY29kZVZhbHVlOiAoKSA9PiBlbmNvZGVWYWx1ZSxcbiAgZ2V0RGVwZW5kZW5jaWVzOiAoKSA9PiBnZXREZXBlbmRlbmNpZXMsXG4gIGdldE1lc3NhZ2VIYXNoOiAoKSA9PiBnZXRNZXNzYWdlSGFzaCxcbiAgZ2V0U3RydWN0SGFzaDogKCkgPT4gZ2V0U3RydWN0SGFzaCxcbiAgZ2V0VHlwZUhhc2g6ICgpID0+IGdldFR5cGVIYXNoLFxuICBpc01lcmtsZVRyZWVUeXBlOiAoKSA9PiBpc01lcmtsZVRyZWVUeXBlLFxuICBwcmVwYXJlU2VsZWN0b3I6ICgpID0+IHByZXBhcmVTZWxlY3RvcixcbiAgdmFsaWRhdGVUeXBlZERhdGE6ICgpID0+IHZhbGlkYXRlVHlwZWREYXRhLFxuICB2ZXJpZnlNZXNzYWdlOiAoKSA9PiB2ZXJpZnlNZXNzYWdlXG59KTtcblxuLy8gc3JjL3V0aWxzL21lcmtsZS50c1xudmFyIG1lcmtsZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChtZXJrbGVfZXhwb3J0cywge1xuICBNZXJrbGVUcmVlOiAoKSA9PiBNZXJrbGVUcmVlLFxuICBwcm9vZk1lcmtsZVBhdGg6ICgpID0+IHByb29mTWVya2xlUGF0aFxufSk7XG52YXIgTWVya2xlVHJlZSA9IGNsYXNzIF9NZXJrbGVUcmVlIHtcbiAgbGVhdmVzO1xuICBicmFuY2hlcyA9IFtdO1xuICByb290O1xuICBoYXNoTWV0aG9kO1xuICAvKipcbiAgICogQ3JlYXRlIGEgTWVya2xlIHRyZWVcbiAgICpcbiAgICogQHBhcmFtIGxlYWZIYXNoZXMgaGV4LXN0cmluZyBhcnJheVxuICAgKiBAcGFyYW0gaGFzaE1ldGhvZCBoYXNoIG1ldGhvZCB0byB1c2UsIGRlZmF1bHQ6IFBlZGVyc2VuXG4gICAqIEByZXR1cm5zIGNyZWF0ZWQgTWVya2xlIHRyZWVcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBsZWF2ZXMgPSBbJzB4MScsICcweDInLCAnMHgzJywgJzB4NCcsICcweDUnLCAnMHg2JywgJzB4NyddO1xuICAgKiBjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUobGVhdmVzKTtcbiAgICogLy8gdHJlZSA9IHtcbiAgICogLy8gICBicmFuY2hlczogW1snMHg1YmI5NDQwZTIuLi4nLCAnMHgyNjI2OTdiODguLi4nLCAuLi5dLCBbJzB4MzgxMThhMzQwLi4uJywgLi4uXSwgLi4uXSxcbiAgICogLy8gICBsZWF2ZXM6IFsnMHgxJywgJzB4MicsICcweDMnLCAnMHg0JywgJzB4NScsICcweDYnLCAnMHg3J10sXG4gICAqIC8vICAgcm9vdDogJzB4N2Y3NDhjNzVlNWJkYjdhZTI4MDEzZjA3NmI4YWI2NTBjNGUwMWQzNTMwYzZlNWFiNjY1ZjlmMWFjY2JlN2Q0JyxcbiAgICogLy8gICBoYXNoTWV0aG9kOiBbRnVuY3Rpb24gY29tcHV0ZVBlZGVyc2VuSGFzaF0sXG4gICAqIC8vIH1cbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsZWFmSGFzaGVzLCBoYXNoTWV0aG9kID0gY29tcHV0ZVBlZGVyc2VuSGFzaCkge1xuICAgIHRoaXMuaGFzaE1ldGhvZCA9IGhhc2hNZXRob2Q7XG4gICAgdGhpcy5sZWF2ZXMgPSBsZWFmSGFzaGVzO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuYnVpbGQobGVhZkhhc2hlcyk7XG4gIH1cbiAgLyoqIEBpZ25vcmUgKi9cbiAgYnVpbGQobGVhdmVzKSB7XG4gICAgaWYgKGxlYXZlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBsZWF2ZXNbMF07XG4gICAgfVxuICAgIGlmIChsZWF2ZXMubGVuZ3RoICE9PSB0aGlzLmxlYXZlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYnJhbmNoZXMucHVzaChsZWF2ZXMpO1xuICAgIH1cbiAgICBjb25zdCBuZXdMZWF2ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlYXZlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKGkgKyAxID09PSBsZWF2ZXMubGVuZ3RoKSB7XG4gICAgICAgIG5ld0xlYXZlcy5wdXNoKF9NZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBcIjB4MFwiLCB0aGlzLmhhc2hNZXRob2QpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0xlYXZlcy5wdXNoKF9NZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBsZWF2ZXNbaSArIDFdLCB0aGlzLmhhc2hNZXRob2QpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVpbGQobmV3TGVhdmVzKTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlIGhhc2ggZnJvbSBvcmRlcmVkIGEgYW5kIGIsIFBlZGVyc2VuIGhhc2ggZGVmYXVsdFxuICAgKlxuICAgKiBAcGFyYW0gYSBmaXJzdCB2YWx1ZVxuICAgKiBAcGFyYW0gYiBzZWNvbmQgdmFsdWVcbiAgICogQHBhcmFtIGhhc2hNZXRob2QgaGFzaCBtZXRob2QgdG8gdXNlLCBkZWZhdWx0OiBQZWRlcnNlblxuICAgKiBAcmV0dXJucyByZXN1bHQgb2YgdGhlIGhhc2ggZnVuY3Rpb25cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQxID0gTWVya2xlVHJlZS5oYXNoKCcweGFiYycsICcweGRlZicpO1xuICAgKiAvLyByZXN1bHQxID0gJzB4NDg0ZjAyOWRhNzkxNGFkYTAzOGIxYWRmNjdmYzgzNjMyMzY0YTNlYmMyY2Q5MzQ5YjQxYWI2MTYyNmQ5ZTgyJ1xuICAgKlxuICAgKiBjb25zdCBjdXN0b21IYXNoTWV0aG9kID0gKGEsIGIpID0+IGBjdXN0b21fJHthfV8ke2J9YDtcbiAgICogY29uc3QgcmVzdWx0MiA9IE1lcmtsZVRyZWUuaGFzaCgnMHhhYmMnLCAnMHhkZWYnLCBjdXN0b21IYXNoTWV0aG9kKTtcbiAgICogLy8gcmVzdWx0MiA9ICdjdXN0b21fMjc0OF8zNTY3J1xuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBoYXNoKGEsIGIsIGhhc2hNZXRob2QgPSBjb21wdXRlUGVkZXJzZW5IYXNoKSB7XG4gICAgY29uc3QgW2FTb3J0ZWQsIGJTb3J0ZWRdID0gW0JpZ0ludChhKSwgQmlnSW50KGIpXS5zb3J0KCh4LCB5KSA9PiB4ID49IHkgPyAxIDogLTEpO1xuICAgIHJldHVybiBoYXNoTWV0aG9kKGFTb3J0ZWQsIGJTb3J0ZWQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBtZXJrbGUgbWVtYmVyc2hpcCBwcm9vZiBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSBsZWFmIGhleC1zdHJpbmdcbiAgICogQHBhcmFtIGJyYW5jaCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEBwYXJhbSBoYXNoUGF0aCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEByZXR1cm5zIGNvbGxlY3Rpb24gb2YgbWVya2xlIHByb29mIGhleC1zdHJpbmcgaGFzaGVzXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbGVhdmVzID0gWycweDEnLCAnMHgyJywgJzB4MycsICcweDQnLCAnMHg1JywgJzB4NicsICcweDcnXTtcbiAgICogY29uc3QgdHJlZSA9IG5ldyBNZXJrbGVUcmVlKGxlYXZlcyk7XG4gICAqIGNvbnN0IHJlc3VsdCA9IHRyZWUuZ2V0UHJvb2YoJzB4MycpO1xuICAgKiAvLyByZXN1bHQgPSBbXG4gICAqIC8vICAgJzB4NCcsXG4gICAqIC8vICAgJzB4NWJiOTQ0MGUyNzg4OWEzNjRiY2I2NzhiMWY2NzllY2QxMzQ3YWNkZWRjYmYzNmU4MzQ5NGY4NTdjYzU4MDI2JyxcbiAgICogLy8gICAnMHg4YzBlNDZkZDJkZjlhYWYzYThlYmZiYzI1NDA4YTU4MmFkN2ZhNzE3MWYwNjk4ZGRiYmM1MTMwYjRiNGU2MCcsXG4gICAqIC8vIF1cbiAgICogYGBgXG4gICAqL1xuICBnZXRQcm9vZihsZWFmLCBicmFuY2ggPSB0aGlzLmxlYXZlcywgaGFzaFBhdGggPSBbXSkge1xuICAgIGNvbnN0IGluZGV4ID0gYnJhbmNoLmluZGV4T2YobGVhZik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGVhZiBub3QgZm91bmRcIik7XG4gICAgfVxuICAgIGlmIChicmFuY2gubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gaGFzaFBhdGg7XG4gICAgfVxuICAgIGNvbnN0IGlzTGVmdCA9IGluZGV4ICUgMiA9PT0gMDtcbiAgICBjb25zdCBuZWVkZWRCcmFuY2ggPSAoaXNMZWZ0ID8gYnJhbmNoW2luZGV4ICsgMV0gOiBicmFuY2hbaW5kZXggLSAxXSkgPz8gXCIweDBcIjtcbiAgICBjb25zdCBuZXdIYXNoUGF0aCA9IFsuLi5oYXNoUGF0aCwgbmVlZGVkQnJhbmNoXTtcbiAgICBjb25zdCBjdXJyZW50QnJhbmNoTGV2ZWxJbmRleCA9IHRoaXMubGVhdmVzLmxlbmd0aCA9PT0gYnJhbmNoLmxlbmd0aCA/IC0xIDogdGhpcy5icmFuY2hlcy5maW5kSW5kZXgoKGIpID0+IGIubGVuZ3RoID09PSBicmFuY2gubGVuZ3RoKTtcbiAgICBjb25zdCBuZXh0QnJhbmNoID0gdGhpcy5icmFuY2hlc1tjdXJyZW50QnJhbmNoTGV2ZWxJbmRleCArIDFdID8/IFt0aGlzLnJvb3RdO1xuICAgIHJldHVybiB0aGlzLmdldFByb29mKFxuICAgICAgX01lcmtsZVRyZWUuaGFzaChpc0xlZnQgPyBsZWFmIDogbmVlZGVkQnJhbmNoLCBpc0xlZnQgPyBuZWVkZWRCcmFuY2ggOiBsZWFmLCB0aGlzLmhhc2hNZXRob2QpLFxuICAgICAgbmV4dEJyYW5jaCxcbiAgICAgIG5ld0hhc2hQYXRoXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHByb29mTWVya2xlUGF0aChyb290LCBsZWFmLCBwYXRoLCBoYXNoTWV0aG9kID0gY29tcHV0ZVBlZGVyc2VuSGFzaCkge1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcm9vdCA9PT0gbGVhZjtcbiAgfVxuICBjb25zdCBbbmV4dCwgLi4ucmVzdF0gPSBwYXRoO1xuICByZXR1cm4gcHJvb2ZNZXJrbGVQYXRoKHJvb3QsIE1lcmtsZVRyZWUuaGFzaChsZWFmLCBuZXh0LCBoYXNoTWV0aG9kKSwgcmVzdCwgaGFzaE1ldGhvZCk7XG59XG5cbi8vIHNyYy91dGlscy90eXBlZERhdGEudHNcbnZhciBwcmVzZXRUeXBlcyA9IHtcbiAgdTI1NjogSlNPTi5wYXJzZSgnW3sgXCJuYW1lXCI6IFwibG93XCIsIFwidHlwZVwiOiBcInUxMjhcIiB9LCB7IFwibmFtZVwiOiBcImhpZ2hcIiwgXCJ0eXBlXCI6IFwidTEyOFwiIH1dJyksXG4gIFRva2VuQW1vdW50OiBKU09OLnBhcnNlKFxuICAgICdbeyBcIm5hbWVcIjogXCJ0b2tlbl9hZGRyZXNzXCIsIFwidHlwZVwiOiBcIkNvbnRyYWN0QWRkcmVzc1wiIH0sIHsgXCJuYW1lXCI6IFwiYW1vdW50XCIsIFwidHlwZVwiOiBcInUyNTZcIiB9XSdcbiAgKSxcbiAgTmZ0SWQ6IEpTT04ucGFyc2UoXG4gICAgJ1t7IFwibmFtZVwiOiBcImNvbGxlY3Rpb25fYWRkcmVzc1wiLCBcInR5cGVcIjogXCJDb250cmFjdEFkZHJlc3NcIiB9LCB7IFwibmFtZVwiOiBcInRva2VuX2lkXCIsIFwidHlwZVwiOiBcInUyNTZcIiB9XSdcbiAgKVxufTtcbnZhciByZXZpc2lvbkNvbmZpZ3VyYXRpb24gPSB7XG4gIFtUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkVdOiB7XG4gICAgZG9tYWluOiBcIlN0YXJrbmV0RG9tYWluXCIsXG4gICAgaGFzaE1ldGhvZDogY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHMsXG4gICAgaGFzaE1lcmtsZU1ldGhvZDogY29tcHV0ZVBvc2VpZG9uSGFzaCxcbiAgICBlc2NhcGVUeXBlU3RyaW5nOiAocykgPT4gYFwiJHtzfVwiYCxcbiAgICBwcmVzZXRUeXBlc1xuICB9LFxuICBbVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZXToge1xuICAgIGRvbWFpbjogXCJTdGFya05ldERvbWFpblwiLFxuICAgIGhhc2hNZXRob2Q6IGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzLFxuICAgIGhhc2hNZXJrbGVNZXRob2Q6IGNvbXB1dGVQZWRlcnNlbkhhc2gsXG4gICAgZXNjYXBlVHlwZVN0cmluZzogKHMpID0+IHMsXG4gICAgcHJlc2V0VHlwZXM6IHt9XG4gIH1cbn07XG5mdW5jdGlvbiBhc3NlcnRSYW5nZShkYXRhLCB0eXBlLCB7IG1pbiwgbWF4IH0pIHtcbiAgY29uc3QgdmFsdWUgPSBCaWdJbnQoZGF0YSk7XG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPD0gbWF4LCBgJHt2YWx1ZX0gKCR7dHlwZX0pIGlzIG91dCBvZiBib3VuZHMgWyR7bWlufSwgJHttYXh9XWApO1xufVxuZnVuY3Rpb24gaWRlbnRpZnlSZXZpc2lvbih7IHR5cGVzLCBkb21haW4gfSkge1xuICBpZiAocmV2aXNpb25Db25maWd1cmF0aW9uW1R5cGVkRGF0YVJldmlzaW9uLkFDVElWRV0uZG9tYWluIGluIHR5cGVzICYmIGRvbWFpbi5yZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKVxuICAgIHJldHVybiBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkU7XG4gIGlmIChyZXZpc2lvbkNvbmZpZ3VyYXRpb25bVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZXS5kb21haW4gaW4gdHlwZXMgJiYgKGRvbWFpbi5yZXZpc2lvbiA/PyBUeXBlZERhdGFSZXZpc2lvbi5MRUdBQ1kpID09PSBUeXBlZERhdGFSZXZpc2lvbi5MRUdBQ1kpXG4gICAgcmV0dXJuIFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWTtcbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldEhleCh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0b0hleCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdG9IZXgoZW5jb2RlU2hvcnRTdHJpbmcodmFsdWUpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEJpZ051bWJlcmlzaDogJHt2YWx1ZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlZERhdGEoZGF0YSkge1xuICBjb25zdCB0eXBlZERhdGEgPSBkYXRhO1xuICByZXR1cm4gQm9vbGVhbihcbiAgICB0eXBlZERhdGEubWVzc2FnZSAmJiB0eXBlZERhdGEucHJpbWFyeVR5cGUgJiYgdHlwZWREYXRhLnR5cGVzICYmIGlkZW50aWZ5UmV2aXNpb24odHlwZWREYXRhKVxuICApO1xufVxuZnVuY3Rpb24gcHJlcGFyZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHJldHVybiBpc0hleChzZWxlY3RvcikgPyBzZWxlY3RvciA6IGdldFNlbGVjdG9yRnJvbU5hbWUoc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gaXNNZXJrbGVUcmVlVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnR5cGUgPT09IFwibWVya2xldHJlZVwiO1xufVxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0eXBlLCBkZXBlbmRlbmNpZXMgPSBbXSwgY29udGFpbnMgPSBcIlwiLCByZXZpc2lvbiA9IFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWSkge1xuICBsZXQgZGVwZW5kZW5jeVR5cGVzID0gW3R5cGVdO1xuICBpZiAodHlwZVt0eXBlLmxlbmd0aCAtIDFdID09PSBcIipcIikge1xuICAgIGRlcGVuZGVuY3lUeXBlcyA9IFt0eXBlLnNsaWNlKDAsIC0xKV07XG4gIH0gZWxzZSBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRSkge1xuICAgIGlmICh0eXBlID09PSBcImVudW1cIikge1xuICAgICAgZGVwZW5kZW5jeVR5cGVzID0gW2NvbnRhaW5zXTtcbiAgICB9IGVsc2UgaWYgKHR5cGUubWF0Y2goL15cXCguKlxcKSQvKSkge1xuICAgICAgZGVwZW5kZW5jeVR5cGVzID0gdHlwZS5zbGljZSgxLCAtMSkuc3BsaXQoXCIsXCIpLm1hcCgoZGVwVHlwZSkgPT4gZGVwVHlwZVtkZXBUeXBlLmxlbmd0aCAtIDFdID09PSBcIipcIiA/IGRlcFR5cGUuc2xpY2UoMCwgLTEpIDogZGVwVHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXBlbmRlbmN5VHlwZXMuZmlsdGVyKCh0KSA9PiAhZGVwZW5kZW5jaWVzLmluY2x1ZGVzKHQpICYmIHR5cGVzW3RdKS5yZWR1Y2UoXG4gICAgLy8gVGhpcyBjb21tZW50IHByZXZlbnRzIHByZXR0aWVyIGZyb20gcm9sbGluZyBldmVyeXRoaW5nIGhlcmUgaW50byBhIHNpbmdsZSBsaW5lLlxuICAgIChwLCBkZXBUeXBlKSA9PiBbXG4gICAgICAuLi5wLFxuICAgICAgLi4uW1xuICAgICAgICBkZXBUeXBlLFxuICAgICAgICAuLi50eXBlc1tkZXBUeXBlXS5yZWR1Y2UoXG4gICAgICAgICAgKHByZXZpb3VzLCB0KSA9PiBbXG4gICAgICAgICAgICAuLi5wcmV2aW91cyxcbiAgICAgICAgICAgIC4uLmdldERlcGVuZGVuY2llcyh0eXBlcywgdC50eXBlLCBwcmV2aW91cywgdC5jb250YWlucywgcmV2aXNpb24pLmZpbHRlcihcbiAgICAgICAgICAgICAgKGRlcGVuZGVuY3kpID0+ICFwcmV2aW91cy5pbmNsdWRlcyhkZXBlbmRlbmN5KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIF0sXG4gICAgICAgICAgW11cbiAgICAgICAgKVxuICAgICAgXS5maWx0ZXIoKGRlcGVuZGVuY3kpID0+ICFwLmluY2x1ZGVzKGRlcGVuZGVuY3kpKVxuICAgIF0sXG4gICAgW11cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE1lcmtsZVRyZWVUeXBlKHR5cGVzLCBjdHgpIHtcbiAgaWYgKGN0eC5wYXJlbnQgJiYgY3R4LmtleSkge1xuICAgIGNvbnN0IHBhcmVudFR5cGUgPSB0eXBlc1tjdHgucGFyZW50XTtcbiAgICBjb25zdCBtZXJrbGVUeXBlID0gcGFyZW50VHlwZS5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IGN0eC5rZXkpO1xuICAgIGNvbnN0IGlzTWVya2xlVHJlZSA9IGlzTWVya2xlVHJlZVR5cGUobWVya2xlVHlwZSk7XG4gICAgaWYgKCFpc01lcmtsZVRyZWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjdHgua2V5fSBpcyBub3QgYSBtZXJrbGUgdHJlZWApO1xuICAgIH1cbiAgICBpZiAobWVya2xlVHlwZS5jb250YWlucy5lbmRzV2l0aChcIipcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWVya2xlIHRyZWUgY29udGFpbiBwcm9wZXJ0eSBtdXN0IG5vdCBiZSBhbiBhcnJheSBidXQgd2FzIGdpdmVuICR7Y3R4LmtleX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmtsZVR5cGUuY29udGFpbnM7XG4gIH1cbiAgcmV0dXJuIFwicmF3XCI7XG59XG5mdW5jdGlvbiBlbmNvZGVUeXBlKHR5cGVzLCB0eXBlLCByZXZpc2lvbiA9IFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWSkge1xuICBjb25zdCBhbGxUeXBlcyA9IHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUgPyB7IC4uLnR5cGVzLCAuLi5yZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLnByZXNldFR5cGVzIH0gOiB0eXBlcztcbiAgY29uc3QgW3ByaW1hcnksIC4uLmRlcGVuZGVuY2llc10gPSBnZXREZXBlbmRlbmNpZXMoXG4gICAgYWxsVHlwZXMsXG4gICAgdHlwZSxcbiAgICB2b2lkIDAsXG4gICAgdm9pZCAwLFxuICAgIHJldmlzaW9uXG4gICk7XG4gIGNvbnN0IG5ld1R5cGVzID0gIXByaW1hcnkgPyBbXSA6IFtwcmltYXJ5LCAuLi5kZXBlbmRlbmNpZXMuc29ydCgpXTtcbiAgY29uc3QgZXNjID0gcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5lc2NhcGVUeXBlU3RyaW5nO1xuICByZXR1cm4gbmV3VHlwZXMubWFwKChkZXBlbmRlbmN5KSA9PiB7XG4gICAgY29uc3QgZGVwZW5kZW5jeUVsZW1lbnRzID0gYWxsVHlwZXNbZGVwZW5kZW5jeV0ubWFwKCh0KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRUeXBlID0gdC50eXBlID09PSBcImVudW1cIiAmJiByZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFID8gdC5jb250YWlucyA6IHQudHlwZTtcbiAgICAgIGNvbnN0IHR5cGVTdHJpbmcgPSB0YXJnZXRUeXBlLm1hdGNoKC9eXFwoLipcXCkkLykgPyBgKCR7dGFyZ2V0VHlwZS5zbGljZSgxLCAtMSkuc3BsaXQoXCIsXCIpLm1hcCgoZSkgPT4gZSA/IGVzYyhlKSA6IGUpLmpvaW4oXCIsXCIpfSlgIDogZXNjKHRhcmdldFR5cGUpO1xuICAgICAgcmV0dXJuIGAke2VzYyh0Lm5hbWUpfToke3R5cGVTdHJpbmd9YDtcbiAgICB9KTtcbiAgICByZXR1cm4gYCR7ZXNjKGRlcGVuZGVuY3kpfSgke2RlcGVuZGVuY3lFbGVtZW50c30pYDtcbiAgfSkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldFR5cGVIYXNoKHR5cGVzLCB0eXBlLCByZXZpc2lvbiA9IFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWSkge1xuICByZXR1cm4gZ2V0U2VsZWN0b3JGcm9tTmFtZShlbmNvZGVUeXBlKHR5cGVzLCB0eXBlLCByZXZpc2lvbikpO1xufVxuZnVuY3Rpb24gZW5jb2RlVmFsdWUodHlwZXMsIHR5cGUsIGRhdGEsIGN0eCA9IHt9LCByZXZpc2lvbiA9IFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWSkge1xuICBpZiAodHlwZXNbdHlwZV0pIHtcbiAgICByZXR1cm4gW3R5cGUsIGdldFN0cnVjdEhhc2godHlwZXMsIHR5cGUsIGRhdGEsIHJldmlzaW9uKV07XG4gIH1cbiAgaWYgKHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0ucHJlc2V0VHlwZXNbdHlwZV0pIHtcbiAgICByZXR1cm4gW1xuICAgICAgdHlwZSxcbiAgICAgIGdldFN0cnVjdEhhc2goXG4gICAgICAgIHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0ucHJlc2V0VHlwZXMsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHJldmlzaW9uXG4gICAgICApXG4gICAgXTtcbiAgfVxuICBpZiAodHlwZS5lbmRzV2l0aChcIipcIikpIHtcbiAgICBjb25zdCBoYXNoZXMgPSBkYXRhLm1hcChcbiAgICAgIChlbnRyeSkgPT4gZW5jb2RlVmFsdWUodHlwZXMsIHR5cGUuc2xpY2UoMCwgLTEpLCBlbnRyeSwgdm9pZCAwLCByZXZpc2lvbilbMV1cbiAgICApO1xuICAgIHJldHVybiBbdHlwZSwgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWV0aG9kKGhhc2hlcyldO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJlbnVtXCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIGNvbnN0IFt2YXJpYW50S2V5LCB2YXJpYW50RGF0YV0gPSBPYmplY3QuZW50cmllcyhkYXRhKVswXTtcbiAgICAgICAgY29uc3QgcGFyZW50VHlwZSA9IHR5cGVzW2N0eC5wYXJlbnRdLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gY3R4LmtleSk7XG4gICAgICAgIGNvbnN0IGVudW1UeXBlID0gdHlwZXNbcGFyZW50VHlwZS5jb250YWluc107XG4gICAgICAgIGNvbnN0IHZhcmlhbnRUeXBlID0gZW51bVR5cGUuZmluZCgodCkgPT4gdC5uYW1lID09PSB2YXJpYW50S2V5KTtcbiAgICAgICAgY29uc3QgdmFyaWFudEluZGV4ID0gZW51bVR5cGUuaW5kZXhPZih2YXJpYW50VHlwZSk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRTdWJ0eXBlcyA9IHZhcmlhbnRUeXBlLnR5cGUuc2xpY2UoMSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoKHN1YnR5cGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKCFzdWJ0eXBlKSByZXR1cm4gc3VidHlwZTtcbiAgICAgICAgICBjb25zdCBzdWJ0eXBlRGF0YSA9IHZhcmlhbnREYXRhW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gZW5jb2RlVmFsdWUodHlwZXMsIHN1YnR5cGUsIHN1YnR5cGVEYXRhLCB2b2lkIDAsIHJldmlzaW9uKVsxXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXRob2QoW3ZhcmlhbnRJbmRleCwgLi4uZW5jb2RlZFN1YnR5cGVzXSlcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gICAgY2FzZSBcIm1lcmtsZXRyZWVcIjoge1xuICAgICAgY29uc3QgbWVya2xlVHJlZVR5cGUgPSBnZXRNZXJrbGVUcmVlVHlwZSh0eXBlcywgY3R4KTtcbiAgICAgIGNvbnN0IHN0cnVjdEhhc2hlcyA9IGRhdGEubWFwKChzdHJ1Y3QpID0+IHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVZhbHVlKHR5cGVzLCBtZXJrbGVUcmVlVHlwZSwgc3RydWN0LCB2b2lkIDAsIHJldmlzaW9uKVsxXTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyByb290IH0gPSBuZXcgTWVya2xlVHJlZShcbiAgICAgICAgc3RydWN0SGFzaGVzLFxuICAgICAgICByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXJrbGVNZXRob2RcbiAgICAgICk7XG4gICAgICByZXR1cm4gW1wiZmVsdFwiLCByb290XTtcbiAgICB9XG4gICAgY2FzZSBcInNlbGVjdG9yXCI6IHtcbiAgICAgIHJldHVybiBbXCJmZWx0XCIsIHByZXBhcmVTZWxlY3RvcihkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUpIHtcbiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gYnl0ZUFycmF5RnJvbVN0cmluZyhkYXRhKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXG4gICAgICAgICAgYnl0ZUFycmF5LmRhdGEubGVuZ3RoLFxuICAgICAgICAgIC4uLmJ5dGVBcnJheS5kYXRhLFxuICAgICAgICAgIGJ5dGVBcnJheS5wZW5kaW5nX3dvcmQsXG4gICAgICAgICAgYnl0ZUFycmF5LnBlbmRpbmdfd29yZF9sZW5cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFt0eXBlLCByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXRob2QoZWxlbWVudHMpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gICAgY2FzZSBcImkxMjhcIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBCaWdJbnQoZGF0YSk7XG4gICAgICAgIGFzc2VydFJhbmdlKHZhbHVlLCB0eXBlLCBSQU5HRV9JMTI4KTtcbiAgICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgodmFsdWUgPCAwbiA/IFBSSU1FICsgdmFsdWUgOiB2YWx1ZSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwidGltZXN0YW1wXCI6XG4gICAgY2FzZSBcInUxMjhcIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUpIHtcbiAgICAgICAgYXNzZXJ0UmFuZ2UoZGF0YSwgdHlwZSwgUkFOR0VfVTEyOCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJmZWx0XCI6XG4gICAgY2FzZSBcInNob3J0c3RyaW5nXCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIGFzc2VydFJhbmdlKGdldEhleChkYXRhKSwgdHlwZSwgUkFOR0VfRkVMVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJDbGFzc0hhc2hcIjpcbiAgICBjYXNlIFwiQ29udHJhY3RBZGRyZXNzXCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIGFzc2VydFJhbmdlKGRhdGEsIHR5cGUsIFJBTkdFX0ZFTFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwiYm9vbFwiOiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRSkge1xuICAgICAgICBhc3NlcnQoaXNCb29sZWFuKGRhdGEpLCBgVHlwZSBtaXNtYXRjaCBmb3IgJHt0eXBlfSAke2RhdGF9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZTogJHt0eXBlfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW5jb2RlRGF0YSh0eXBlcywgdHlwZSwgZGF0YSwgcmV2aXNpb24gPSBUeXBlZERhdGFSZXZpc2lvbi5MRUdBQ1kpIHtcbiAgY29uc3QgdGFyZ2V0VHlwZSA9IHR5cGVzW3R5cGVdID8/IHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0ucHJlc2V0VHlwZXNbdHlwZV07XG4gIGNvbnN0IFtyZXR1cm5UeXBlcywgdmFsdWVzXSA9IHRhcmdldFR5cGUucmVkdWNlKFxuICAgIChbdHMsIHZzXSwgZmllbGQpID0+IHtcbiAgICAgIGlmIChkYXRhW2ZpZWxkLm5hbWVdID09PSB2b2lkIDAgfHwgZGF0YVtmaWVsZC5uYW1lXSA9PT0gbnVsbCAmJiBmaWVsZC50eXBlICE9PSBcImVudW1cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBlbmNvZGUgZGF0YTogbWlzc2luZyBkYXRhIGZvciAnJHtmaWVsZC5uYW1lfSdgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtmaWVsZC5uYW1lXTtcbiAgICAgIGNvbnN0IGN0eCA9IHsgcGFyZW50OiB0eXBlLCBrZXk6IGZpZWxkLm5hbWUgfTtcbiAgICAgIGNvbnN0IFt0LCBlbmNvZGVkVmFsdWVdID0gZW5jb2RlVmFsdWUodHlwZXMsIGZpZWxkLnR5cGUsIHZhbHVlLCBjdHgsIHJldmlzaW9uKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFsuLi50cywgdF0sXG4gICAgICAgIFsuLi52cywgZW5jb2RlZFZhbHVlXVxuICAgICAgXTtcbiAgICB9LFxuICAgIFtbXCJmZWx0XCJdLCBbZ2V0VHlwZUhhc2godHlwZXMsIHR5cGUsIHJldmlzaW9uKV1dXG4gICk7XG4gIHJldHVybiBbcmV0dXJuVHlwZXMsIHZhbHVlc107XG59XG5mdW5jdGlvbiBnZXRTdHJ1Y3RIYXNoKHR5cGVzLCB0eXBlLCBkYXRhLCByZXZpc2lvbiA9IFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWSkge1xuICByZXR1cm4gcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWV0aG9kKGVuY29kZURhdGEodHlwZXMsIHR5cGUsIGRhdGEsIHJldmlzaW9uKVsxXSk7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlSGFzaCh0eXBlZERhdGEsIGFjY291bnQpIHtcbiAgaWYgKCF2YWxpZGF0ZVR5cGVkRGF0YSh0eXBlZERhdGEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZWQgZGF0YSBkb2VzIG5vdCBtYXRjaCBKU09OIHNjaGVtYVwiKTtcbiAgfVxuICBjb25zdCByZXZpc2lvbiA9IGlkZW50aWZ5UmV2aXNpb24odHlwZWREYXRhKTtcbiAgY29uc3QgeyBkb21haW4sIGhhc2hNZXRob2QgfSA9IHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl07XG4gIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgZW5jb2RlU2hvcnRTdHJpbmcoXCJTdGFya05ldCBNZXNzYWdlXCIpLFxuICAgIGdldFN0cnVjdEhhc2godHlwZWREYXRhLnR5cGVzLCBkb21haW4sIHR5cGVkRGF0YS5kb21haW4sIHJldmlzaW9uKSxcbiAgICBhY2NvdW50LFxuICAgIGdldFN0cnVjdEhhc2godHlwZWREYXRhLnR5cGVzLCB0eXBlZERhdGEucHJpbWFyeVR5cGUsIHR5cGVkRGF0YS5tZXNzYWdlLCByZXZpc2lvbilcbiAgXTtcbiAgcmV0dXJuIGhhc2hNZXRob2QobWVzc2FnZSk7XG59XG5mdW5jdGlvbiB2ZXJpZnlNZXNzYWdlKG1lc3NhZ2UsIHNpZ25hdHVyZSwgZnVsbFB1YmxpY0tleSwgYWNjb3VudEFkZHJlc3MpIHtcbiAgY29uc3QgaXNUeXBlZERhdGEgPSB2YWxpZGF0ZVR5cGVkRGF0YShtZXNzYWdlKTtcbiAgaWYgKCFpc0JpZ051bWJlcmlzaChtZXNzYWdlKSAmJiAhaXNUeXBlZERhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXNzYWdlIGhhcyBhIHdyb25nIGZvcm1hdC5cIik7XG4gIH1cbiAgaWYgKGlzVHlwZWREYXRhICYmIGFjY291bnRBZGRyZXNzID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIldoZW4gcHJvdmlkaW5nIGEgVHlwZWREYXRhIGluIG1lc3NhZ2UgcGFyYW1ldGVyLCB0aGUgYWNjb3VudEFkZHJlc3MgcGFyYW1ldGVyIGhhcyB0byBiZSBwcm92aWRlZC5cIlxuICAgICk7XG4gIH1cbiAgaWYgKGlzVHlwZWREYXRhICYmICFpc0JpZ051bWJlcmlzaChhY2NvdW50QWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhY2NvdW50QWRkcmVzcyBzaGFsbCBiZSBhIEJpZ051bWJlcmlzaFwiKTtcbiAgfVxuICBjb25zdCBtZXNzYWdlSGFzaCA9IGlzVHlwZWREYXRhID8gZ2V0TWVzc2FnZUhhc2gobWVzc2FnZSwgYWNjb3VudEFkZHJlc3MpIDogdG9IZXgobWVzc2FnZSk7XG4gIGNvbnN0IHNpZ24gPSBBcnJheS5pc0FycmF5KHNpZ25hdHVyZSkgPyBuZXcgc3RhcmtDdXJ2ZS5TaWduYXR1cmUoQmlnSW50KHNpZ25hdHVyZVswXSksIEJpZ0ludChzaWduYXR1cmVbMV0pKSA6IHNpZ25hdHVyZTtcbiAgY29uc3QgZnVsbFB1YktleSA9IHRvSGV4KGZ1bGxQdWJsaWNLZXkpO1xuICBjb25zdCBpc1ZhbGlkID0gc3RhcmtDdXJ2ZS52ZXJpZnkoc2lnbiwgbWVzc2FnZUhhc2gsIGZ1bGxQdWJLZXkpO1xuICByZXR1cm4gaXNWYWxpZDtcbn1cblxuLy8gc3JjL3Byb3ZpZGVyL3JwYy50c1xudmFyIFJwY1Byb3ZpZGVyID0gY2xhc3Mge1xuICByZXNwb25zZVBhcnNlcjtcbiAgY2hhbm5lbDtcbiAgY29uc3RydWN0b3Iob3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICBpZiAob3B0aW9uc09yUHJvdmlkZXIgJiYgXCJjaGFubmVsXCIgaW4gb3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IG9wdGlvbnNPclByb3ZpZGVyLmNoYW5uZWw7XG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyID0gXCJyZXNwb25zZVBhcnNlclwiIGluIG9wdGlvbnNPclByb3ZpZGVyID8gb3B0aW9uc09yUHJvdmlkZXIucmVzcG9uc2VQYXJzZXIgOiBuZXcgUlBDUmVzcG9uc2VQYXJzZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFubmVsID0gbmV3IFJwY0NoYW5uZWwyKHsgLi4ub3B0aW9uc09yUHJvdmlkZXIsIHdhaXRNb2RlOiBmYWxzZSB9KTtcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIgPSBuZXcgUlBDUmVzcG9uc2VQYXJzZXIob3B0aW9uc09yUHJvdmlkZXI/LmZlZU1hcmdpblBlcmNlbnRhZ2UpO1xuICAgIH1cbiAgfVxuICBmZXRjaChtZXRob2QsIHBhcmFtcywgaWQgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5mZXRjaChtZXRob2QsIHBhcmFtcywgaWQpO1xuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRDaGFpbklkKCk7XG4gIH1cbiAgYXN5bmMgZ2V0U3BlY1ZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRTcGVjVmVyc2lvbigpO1xuICB9XG4gIGFzeW5jIGdldE5vbmNlRm9yQWRkcmVzcyhjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRCbG9jayhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllcikudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0QmxvY2tSZXNwb25zZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgaGFzaCBhbmQgbnVtYmVyXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IGFjY2VwdGVkIGJsb2NrIG51bWJlclxuICAgKiByZWR1bmRhbnQgdXNlIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKTtcbiAgICogQHJldHVybnMgTnVtYmVyIG9mIHRoZSBsYXRlc3QgYmxvY2tcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1dpdGhUeEhhc2hlcyhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBleGVjdXRpb24gb2YgdGhlIHNjcmlwdCB1bnRpbCBhIHNwZWNpZmllZCBibG9jayBpcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge0Jsb2NrSWRlbnRpZmllcn0gYmxvY2tJZGVudGlmaWVyIGJsb2MgbnVtYmVyIChCaWdOdW1iZXJpc2gpIG9yICdwZW5kaW5nJyBvciAnbGF0ZXN0Jy5cbiAgICogVXNlIG9mICdsYXRlc3RcIiBvciBvZiBhIGJsb2NrIGFscmVhZHkgY3JlYXRlZCB3aWxsIGdlbmVyYXRlIG5vIHBhdXNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JldHJ5SW50ZXJ2YWxdIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYmV0d2VlbiAyIHJlcXVlc3RzIHRvIHRoZSBub2RlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogYXdhaXQgbXlQcm92aWRlci53YWl0Rm9yQmxvY2soKTtcbiAgICogLy8gd2FpdCB0aGUgY3JlYXRpb24gb2YgdGhlIHBlbmRpbmcgYmxvY2tcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyB3YWl0Rm9yQmxvY2soYmxvY2tJZGVudGlmaWVyID0gXCJwZW5kaW5nXCIsIHJldHJ5SW50ZXJ2YWwgPSA1ZTMpIHtcbiAgICBpZiAoYmxvY2tJZGVudGlmaWVyID09PSBCbG9ja1RhZy5MQVRFU1QpIHJldHVybjtcbiAgICBjb25zdCBjdXJyZW50QmxvY2sgPSBhd2FpdCB0aGlzLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgY29uc3QgdGFyZ2V0QmxvY2sgPSBibG9ja0lkZW50aWZpZXIgPT09IEJsb2NrVGFnLlBFTkRJTkcgPyBjdXJyZW50QmxvY2sgKyAxIDogTnVtYmVyKHRvSGV4KGJsb2NrSWRlbnRpZmllcikpO1xuICAgIGlmICh0YXJnZXRCbG9jayA8PSBjdXJyZW50QmxvY2spIHJldHVybjtcbiAgICBjb25zdCB7IHJldHJpZXMgfSA9IHRoaXMuY2hhbm5lbDtcbiAgICBsZXQgcmV0cmllc0NvdW50ID0gcmV0cmllcztcbiAgICBsZXQgaXNUYXJnZXRCbG9jayA9IGZhbHNlO1xuICAgIHdoaWxlICghaXNUYXJnZXRCbG9jaykge1xuICAgICAgY29uc3QgY3VyckJsb2NrID0gYXdhaXQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xuICAgICAgaWYgKGN1cnJCbG9jayA9PT0gdGFyZ2V0QmxvY2spIHtcbiAgICAgICAgaXNUYXJnZXRCbG9jayA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB3YWl0KHJldHJ5SW50ZXJ2YWwpO1xuICAgICAgfVxuICAgICAgcmV0cmllc0NvdW50IC09IDE7XG4gICAgICBpZiAocmV0cmllc0NvdW50IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3YWl0Rm9yQmxvY2soKSB0aW1lZC1vdXQgYWZ0ZXIgJHtyZXRyaWVzfSB0cmllcy5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0TDFHYXNQcmljZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllcikudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlTDFHYXNQcmljZVJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRMMU1lc3NhZ2VIYXNoKGwyVHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLmNoYW5uZWwuZ2V0VHJhbnNhY3Rpb25CeUhhc2gobDJUeEhhc2gpO1xuICAgIGFzc2VydCh0cmFuc2FjdGlvbi50eXBlID09PSBcIkwxX0hBTkRMRVJcIiwgXCJUaGlzIEwyIHRyYW5zYWN0aW9uIGlzIG5vdCBhIEwxIG1lc3NhZ2UuXCIpO1xuICAgIGNvbnN0IHsgY2FsbGRhdGEsIGNvbnRyYWN0X2FkZHJlc3MsIGVudHJ5X3BvaW50X3NlbGVjdG9yLCBub25jZSB9ID0gdHJhbnNhY3Rpb247XG4gICAgY29uc3QgcGFyYW1zID0gW1xuICAgICAgY2FsbGRhdGFbMF0sXG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgbm9uY2UsXG4gICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcixcbiAgICAgIGNhbGxkYXRhLmxlbmd0aCAtIDEsXG4gICAgICAuLi5jYWxsZGF0YS5zbGljZSgxKVxuICAgIF07XG4gICAgcmV0dXJuIHNvbGlkaXR5VWludDI1NlBhY2tlZEtlY2NhazI1NihwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrV2l0aFJlY2VpcHRzKGJsb2NrSWRlbnRpZmllcikge1xuICAgIGlmICh0aGlzLmNoYW5uZWwgaW5zdGFuY2VvZiBycGNfMF82X2V4cG9ydHMuUnBjQ2hhbm5lbClcbiAgICAgIHRocm93IG5ldyBMaWJyYXJ5RXJyb3IoXCJVbnN1cHBvcnRlZCBtZXRob2QgZm9yIFJQQyB2ZXJzaW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tXaXRoUmVjZWlwdHMoYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBnZXRTdGF0ZVVwZGF0ZSA9IHRoaXMuZ2V0QmxvY2tTdGF0ZVVwZGF0ZTtcbiAgYXN5bmMgZ2V0QmxvY2tTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrU3RhdGVVcGRhdGUoYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1RyYW5zYWN0aW9uc1RyYWNlcyhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0cmFuc2FjdGlvbnMgZnJvbSBwZW5kaW5nIGJsb2NrXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQgdXNlIGdldEJsb2NrKEJsb2NrVGFnLlBFTkRJTkcpOyAod2lsbCBiZSByZW1vdmVkIGluIG5leHQgbWlub3IgdmVyc2lvbilcbiAgICogVXRpbGl0eSBtZXRob2QsIHNhbWUgcmVzdWx0IGNhbiBiZSBhY2hpZXZlZCB1c2luZyBnZXRCbG9ja1dpdGhUeEhhc2hlcyhCbG9ja1RhZy5wZW5kaW5nKTtcbiAgICovXG4gIGFzeW5jIGdldFBlbmRpbmdUcmFuc2FjdGlvbnMoKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IGF3YWl0IHRoaXMuZ2V0QmxvY2tXaXRoVHhIYXNoZXMoQmxvY2tUYWcuUEVORElORykudGhlbihcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VHZXRCbG9ja1Jlc3BvbnNlXG4gICAgKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zLm1hcCgoaXQpID0+IHRoaXMuZ2V0VHJhbnNhY3Rpb25CeUhhc2goaXQpKSk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHhIYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uQnlIYXNoKHR4SGFzaCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0VHJhbnNhY3Rpb25CeUhhc2godHhIYXNoKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4KGJsb2NrSWRlbnRpZmllciwgaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXgoYmxvY2tJZGVudGlmaWVyLCBpbmRleCk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCkge1xuICAgIGNvbnN0IHR4UmVjZWlwdFdvSGVscGVyID0gYXdhaXQgdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICAgIGNvbnN0IHR4UmVjZWlwdFdvSGVscGVyTW9kaWZpZWQgPSB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlVHJhbnNhY3Rpb25SZWNlaXB0KHR4UmVjZWlwdFdvSGVscGVyKTtcbiAgICByZXR1cm4gbmV3IFJlY2VpcHRUeCh0eFJlY2VpcHRXb0hlbHBlck1vZGlmaWVkKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvblRyYWNlKHR4SGFzaCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YXR1cyBvZiBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBpbnZvY2F0aW9ucyBBY2NvdW50SW52b2NhdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMgYmxvY2tJZGVudGlmaWVyIGFuZCBmbGFncyB0byBza2lwIHZhbGlkYXRpb24gYW5kIGZlZSBjaGFyZ2U8YnIvPlxuICAgKiAtIGJsb2NrSWRlbnRpZmllcjxici8+XG4gICAqIC0gc2tpcFZhbGlkYXRlIChkZWZhdWx0IGZhbHNlKTxici8+XG4gICAqIC0gc2tpcEZlZUNoYXJnZSAoZGVmYXVsdCB0cnVlKTxici8+XG4gICAqL1xuICBhc3luYyBnZXRTaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5zaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCBvcHRpb25zKS50aGVuKChyKSA9PiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKHIpKTtcbiAgfVxuICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24odHhIYXNoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVjZWlwdFdvSGVscGVyID0gYXdhaXQgdGhpcy5jaGFubmVsLndhaXRGb3JUcmFuc2FjdGlvbihcbiAgICAgIHR4SGFzaCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiBuZXcgUmVjZWlwdFR4KHJlY2VpcHRXb0hlbHBlcik7XG4gIH1cbiAgYXN5bmMgZ2V0U3RvcmFnZUF0KGNvbnRyYWN0QWRkcmVzcywga2V5LCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0Q2xhc3NIYXNoQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQnlIYXNoKGNsYXNzSGFzaCkge1xuICAgIHJldHVybiB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q29udHJhY3RWZXJzaW9uKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCB7XG4gICAgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5jaGFubmVsLmJsb2NrSWRlbnRpZmllcixcbiAgICBjb21waWxlciA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgbGV0IGNvbnRyYWN0Q2xhc3M7XG4gICAgaWYgKGNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgY29udHJhY3RDbGFzcyA9IGF3YWl0IHRoaXMuZ2V0Q2xhc3NBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gICAgfSBlbHNlIGlmIChjbGFzc0hhc2gpIHtcbiAgICAgIGNvbnRyYWN0Q2xhc3MgPSBhd2FpdCB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJnZXRDb250cmFjdFZlcnNpb24gcmVxdWlyZSBjb250cmFjdEFkZHJlc3Mgb3IgY2xhc3NIYXNoXCIpO1xuICAgIH1cbiAgICBpZiAoaXNTaWVycmEoY29udHJhY3RDbGFzcykpIHtcbiAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICBjb25zdCBhYmlUZXN0ID0gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGNvbnRyYWN0Q2xhc3MuYWJpKTtcbiAgICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogYWJpVGVzdC5jb21waWxlciB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogdm9pZCAwIH07XG4gICAgfVxuICAgIHJldHVybiB7IGNhaXJvOiBcIjBcIiwgY29tcGlsZXI6IFwiMFwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBnZXQqdHlwZSpFc3RpbWF0ZUZlZSAod2lsbCBiZSByZWZhY3RvcmVkIGJhc2VkIG9uIHR5cGUgYWZ0ZXIgc2VxdWVuY2VyIGRlcHJlY2F0aW9uKVxuICAgKi9cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKTtcbiAgfVxuICBhc3luYyBnZXRJbnZva2VFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEVzdGltYXRlRmVlKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogVHJhbnNhY3Rpb25UeXBlLklOVk9LRSxcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAgIC4uLmludm9jYXRpb25EZXRhaWxzXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH1cbiAgICApLnRoZW4oKHIpID0+IHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKHIpKTtcbiAgfVxuICBhc3luYyBnZXREZWNsYXJlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEVzdGltYXRlRmVlKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgICAuLi5kZXRhaWxzXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH1cbiAgICApLnRoZW4oKHIpID0+IHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKHIpKTtcbiAgfVxuICBhc3luYyBnZXREZXBsb3lBY2NvdW50RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEVzdGltYXRlRmVlKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogVHJhbnNhY3Rpb25UeXBlLkRFUExPWV9BQ0NPVU5ULFxuICAgICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgeyBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9XG4gICAgKS50aGVuKChyKSA9PiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZShyKSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRFc3RpbWF0ZUZlZShpbnZvY2F0aW9ucywgb3B0aW9ucykudGhlbigocikgPT4gdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKHIpKTtcbiAgfVxuICBhc3luYyBpbnZva2VGdW5jdGlvbihmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmludm9rZShmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpO1xuICB9XG4gIGFzeW5jIGRlY2xhcmVDb250cmFjdCh0cmFuc2FjdGlvbiwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZGVjbGFyZSh0cmFuc2FjdGlvbiwgZGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZGVwbG95QWNjb3VudENvbnRyYWN0KHRyYW5zYWN0aW9uLCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5kZXBsb3lBY2NvdW50KFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBkZXRhaWxzXG4gICAgKTtcbiAgfVxuICBhc3luYyBjYWxsQ29udHJhY3QoY2FsbCwgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5jYWxsQ29udHJhY3QoY2FsbCwgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICAvKipcbiAgICogTkVXOiBFc3RpbWF0ZSB0aGUgZmVlIGZvciBhIG1lc3NhZ2UgZnJvbSBMMVxuICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIEZyb20gTDFcbiAgICovXG4gIGFzeW5jIGVzdGltYXRlTWVzc2FnZUZlZShtZXNzYWdlLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmVzdGltYXRlTWVzc2FnZUZlZShtZXNzYWdlLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBhYm91dCB0aGUgc3luYyBzdGF0dXMsIG9yIGZhbHNlIGlmIHRoZSBub2RlIGlzIG5vdCBzeW5jaGluZ1xuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCB0aGUgc3RhdHMgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0U3luY2luZ1N0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0U3luY2luZ1N0YXRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGV2ZW50cyBtYXRjaGluZyB0aGUgZ2l2ZW4gZmlsdGVyXG4gICAqIEByZXR1cm5zIGV2ZW50cyBhbmQgdGhlIHBhZ2luYXRpb24gb2YgdGhlIGV2ZW50c1xuICAgKi9cbiAgYXN5bmMgZ2V0RXZlbnRzKGV2ZW50RmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRFdmVudHMoZXZlbnRGaWx0ZXIpO1xuICB9XG4gIC8qKlxuICAgKiBWZXJpZnkgaW4gU3RhcmtuZXQgYSBzaWduYXR1cmUgb2YgYSBUeXBlZERhdGEgb2JqZWN0IG9yIG9mIGEgZ2l2ZW4gaGFzaC5cbiAgICogQHBhcmFtIHtCaWdOdW1iZXJpc2ggfCBUeXBlZERhdGF9IG1lc3NhZ2UgVHlwZWREYXRhIG9iamVjdCB0byBiZSB2ZXJpZmllZCwgb3IgbWVzc2FnZSBoYXNoIHRvIGJlIHZlcmlmaWVkLlxuICAgKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlIHNpZ25hdHVyZSBvZiB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtCaWdOdW1iZXJpc2h9IGFjY291bnRBZGRyZXNzIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBoYXMgc2lnbmVkIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NpZ25hdHVyZVZlcmlmaWNhdGlvbkZ1bmN0aW9uTmFtZV0gaWYgYWNjb3VudCBjb250cmFjdCB3aXRoIG5vbiBzdGFuZGFyZCBhY2NvdW50IHZlcmlmaWNhdGlvbiBmdW5jdGlvbiBuYW1lLlxuICAgKiBAcGFyYW0geyBva1Jlc3BvbnNlOiBzdHJpbmdbXTsgbm9rUmVzcG9uc2U6IHN0cmluZ1tdOyBlcnJvcjogc3RyaW5nW10gfSBbc2lnbmF0dXJlVmVyaWZpY2F0aW9uUmVzcG9uc2VdIGlmIGFjY291bnQgY29udHJhY3Qgd2l0aCBub24gc3RhbmRhcmQgcmVzcG9uc2Ugb2YgdmVyaWZpY2F0aW9uIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuc1xuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IG15VHlwZWRNZXNzYWdlOiBUeXBlZE1lc3NhZ2UgPSAuLi4uIDtcbiAgICogY29uc3QgbWVzc2FnZUhhc2ggPSB0eXBlZERhdGEuZ2V0TWVzc2FnZUhhc2gobXlUeXBlZE1lc3NhZ2UsYWNjb3VudEFkZHJlc3MpO1xuICAgKiBjb25zdCBzaWduOiBXZWllcnN0cmFzc1NpZ25hdHVyZVR5cGUgPSBlYy5zdGFya0N1cnZlLnNpZ24obWVzc2FnZUhhc2gsIHByaXZhdGVLZXkpO1xuICAgKiBjb25zdCBhY2NvdW50QWRkcmVzcyA9IFwiMHg0M2I3MjQwZDIyN2FhMmZiODQzNDM1MGIzMzIxYzQwYWMxYjg4YzcwNjc5ODI1NDllNzYwOTg3MDYyMWI1MzVcIjtcbiAgICogY29uc3QgcmVzdWx0MSA9IG15UnBjUHJvdmlkZXIudmVyaWZ5TWVzc2FnZUluU3RhcmtuZXQobXlUeXBlZE1lc3NhZ2UsIHNpZ24sIGFjY291bnRBZGRyZXNzKTtcbiAgICogY29uc3QgcmVzdWx0MiA9IG15UnBjUHJvdmlkZXIudmVyaWZ5TWVzc2FnZUluU3RhcmtuZXQobWVzc2FnZUhhc2gsIHNpZ24sIGFjY291bnRBZGRyZXNzKTtcbiAgICogLy8gcmVzdWx0MSA9IHJlc3VsdDIgPSB0cnVlXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5TWVzc2FnZUluU3RhcmtuZXQobWVzc2FnZSwgc2lnbmF0dXJlLCBhY2NvdW50QWRkcmVzcywgc2lnbmF0dXJlVmVyaWZpY2F0aW9uRnVuY3Rpb25OYW1lLCBzaWduYXR1cmVWZXJpZmljYXRpb25SZXNwb25zZSkge1xuICAgIGNvbnN0IGlzVHlwZWREYXRhID0gdmFsaWRhdGVUeXBlZERhdGEobWVzc2FnZSk7XG4gICAgaWYgKCFpc0JpZ051bWJlcmlzaChtZXNzYWdlKSAmJiAhaXNUeXBlZERhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1lc3NhZ2UgaGFzIGEgd3JvbmcgZm9ybWF0LlwiKTtcbiAgICB9XG4gICAgaWYgKCFpc0JpZ051bWJlcmlzaChhY2NvdW50QWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFjY291bnRBZGRyZXNzIHNoYWxsIGJlIGEgQmlnTnVtYmVyaXNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGlzVHlwZWREYXRhID8gZ2V0TWVzc2FnZUhhc2gobWVzc2FnZSwgYWNjb3VudEFkZHJlc3MpIDogdG9IZXgobWVzc2FnZSk7XG4gICAgY29uc3Qga25vd25TaWdWZXJpZmljYXRpb25GTmFtZSA9IHNpZ25hdHVyZVZlcmlmaWNhdGlvbkZ1bmN0aW9uTmFtZSA/IFtzaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbk5hbWVdIDogW1wiaXNWYWxpZFNpZ25hdHVyZVwiLCBcImlzX3ZhbGlkX3NpZ25hdHVyZVwiXTtcbiAgICBjb25zdCBrbm93blNpZ25hdHVyZVJlc3BvbnNlID0gc2lnbmF0dXJlVmVyaWZpY2F0aW9uUmVzcG9uc2UgfHwge1xuICAgICAgb2tSZXNwb25zZTogW1xuICAgICAgICAvLyBhbnkgbm9uLW5vayByZXNwb25zZSBpcyB0cnVlXG4gICAgICBdLFxuICAgICAgbm9rUmVzcG9uc2U6IFtcbiAgICAgICAgXCIweDBcIixcbiAgICAgICAgLy8gRGV2bmV0XG4gICAgICAgIFwiMHgwMFwiXG4gICAgICAgIC8vIE9wZW5aZXBwZWxpbiAwLjcuMCB0byAwLjkuMCBpbnZhbGlkIHNpZ25hdHVyZVxuICAgICAgXSxcbiAgICAgIGVycm9yOiBbXG4gICAgICAgIFwiYXJnZW50L2ludmFsaWQtc2lnbmF0dXJlXCIsXG4gICAgICAgIC8vIEFyZ2VudFggMC4zLjAgdG8gMC4zLjFcbiAgICAgICAgXCJpcyBpbnZhbGlkLCB3aXRoIHJlc3BlY3QgdG8gdGhlIHB1YmxpYyBrZXlcIixcbiAgICAgICAgLy8gT3BlblplcHBlbGluIHVudGlsIDAuNi4xLCBCcmFhdm9zIDAuMC4xMVxuICAgICAgICBcIklOVkFMSURfU0lHXCJcbiAgICAgICAgLy8gQnJhYXZvcyAxLjAuMFxuICAgICAgXVxuICAgIH07XG4gICAgbGV0IGVycm9yO1xuICAgIGZvciAoY29uc3QgU2lnVmVyaWZpY2F0aW9uRk5hbWUgb2Yga25vd25TaWdWZXJpZmljYXRpb25GTmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuY2FsbENvbnRyYWN0KHtcbiAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHRvSGV4KGFjY291bnRBZGRyZXNzKSxcbiAgICAgICAgICBlbnRyeXBvaW50OiBTaWdWZXJpZmljYXRpb25GTmFtZSxcbiAgICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZSh7XG4gICAgICAgICAgICBoYXNoOiB0b0JpZ0ludChtZXNzYWdlSGFzaCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZm9ybWF0U2lnbmF0dXJlKHNpZ25hdHVyZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGtub3duU2lnbmF0dXJlUmVzcG9uc2Uubm9rUmVzcG9uc2UuaW5jbHVkZXMocmVzcFswXS50b1N0cmluZygpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa25vd25TaWduYXR1cmVSZXNwb25zZS5va1Jlc3BvbnNlLmxlbmd0aCA9PT0gMCB8fCBrbm93blNpZ25hdHVyZVJlc3BvbnNlLm9rUmVzcG9uc2UuaW5jbHVkZXMocmVzcFswXS50b1N0cmluZygpKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IEVycm9yKFwic2lnbmF0dXJlVmVyaWZpY2F0aW9uUmVzcG9uc2UgRXJyb3I6IHJlc3BvbnNlIGlzIG5vdCBwYXJ0IG9mIGtub3duIHJlc3BvbnNlc1wiKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoa25vd25TaWduYXR1cmVSZXNwb25zZS5lcnJvci5zb21lKFxuICAgICAgICAgIChlcnJNZXNzYWdlKSA9PiBlcnIubWVzc2FnZS5pbmNsdWRlcyhlcnJNZXNzYWdlKVxuICAgICAgICApKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBFcnJvcihgU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBFcnJvcjogJHtlcnJvcn1gKTtcbiAgfVxuICAvKipcbiAgICogVGVzdCBpZiBjbGFzcyBpcyBhbHJlYWR5IGRlY2xhcmVkIGZyb20gQ29udHJhY3RDbGFzc0lkZW50aWZpZXJcbiAgICogSGVscGVyIG1ldGhvZCB1c2luZyBnZXRDbGFzc1xuICAgKiBAcGFyYW0gQ29udHJhY3RDbGFzc0lkZW50aWZpZXJcbiAgICogQHBhcmFtIGJsb2NrSWRlbnRpZmllclxuICAgKi9cbiAgYXN5bmMgaXNDbGFzc0RlY2xhcmVkKGNvbnRyYWN0Q2xhc3NJZGVudGlmaWVyLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICBsZXQgY2xhc3NIYXNoO1xuICAgIGlmICghY29udHJhY3RDbGFzc0lkZW50aWZpZXIuY2xhc3NIYXNoICYmIFwiY29udHJhY3RcIiBpbiBjb250cmFjdENsYXNzSWRlbnRpZmllcikge1xuICAgICAgY29uc3QgaGFzaGVzID0gZXh0cmFjdENvbnRyYWN0SGFzaGVzKGNvbnRyYWN0Q2xhc3NJZGVudGlmaWVyKTtcbiAgICAgIGNsYXNzSGFzaCA9IGhhc2hlcy5jbGFzc0hhc2g7XG4gICAgfSBlbHNlIGlmIChjb250cmFjdENsYXNzSWRlbnRpZmllci5jbGFzc0hhc2gpIHtcbiAgICAgIGNsYXNzSGFzaCA9IGNvbnRyYWN0Q2xhc3NJZGVudGlmaWVyLmNsYXNzSGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJjb250cmFjdENsYXNzSWRlbnRpZmllciB0eXBlIG5vdCBzYXRpc2ZpZWRcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyKTtcbiAgICAgIHJldHVybiByZXN1bHQgaW5zdGFuY2VvZiBPYmplY3Q7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIExpYnJhcnlFcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEJ1aWxkIGJ1bGsgaW52b2NhdGlvbnMgd2l0aCBhdXRvLWRldGVjdCBkZWNsYXJlZCBjbGFzc1xuICAgKiAxLiBUZXN0IGlmIGNsYXNzIGlzIGRlY2xhcmVkIGlmIG5vdCBkZWNsYXJlIGl0IHByZXZlbnRpbmcgYWxyZWFkeSBkZWNsYXJlZCBjbGFzcyBlcnJvciBhbmQgbm90IGRlY2xhcmVkIGNsYXNzIGVycm9yc1xuICAgKiAyLiBPcmRlciBkZWNsYXJhdGlvbnMgZmlyc3RcbiAgICogQHBhcmFtIGludm9jYXRpb25zXG4gICAqL1xuICBhc3luYyBwcmVwYXJlSW52b2NhdGlvbnMoaW52b2NhdGlvbnMpIHtcbiAgICBjb25zdCBidWxrID0gW107XG4gICAgZm9yIChjb25zdCBpbnZvY2F0aW9uIG9mIGludm9jYXRpb25zKSB7XG4gICAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuREVDTEFSRSkge1xuICAgICAgICBjb25zdCBpc0RlY2xhcmVkID0gYXdhaXQgdGhpcy5pc0NsYXNzRGVjbGFyZWQoXG4gICAgICAgICAgXCJwYXlsb2FkXCIgaW4gaW52b2NhdGlvbiA/IGludm9jYXRpb24ucGF5bG9hZCA6IGludm9jYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFpc0RlY2xhcmVkKSB7XG4gICAgICAgICAgYnVsay51bnNoaWZ0KGludm9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWxrLnB1c2goaW52b2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWxrO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvZXh0ZW5zaW9ucy9kZWZhdWx0LnRzXG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gXCJ0cy1taXhlclwiO1xuXG4vLyBzcmMvdXRpbHMvc3RhcmtuZXRJZC50c1xudmFyIHN0YXJrbmV0SWRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3RhcmtuZXRJZF9leHBvcnRzLCB7XG4gIFN0YXJrbmV0SWRDb250cmFjdDogKCkgPT4gU3RhcmtuZXRJZENvbnRyYWN0LFxuICBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDogKCkgPT4gU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QsXG4gIFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDogKCkgPT4gU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0LFxuICBTdGFya25ldElkUGZwQ29udHJhY3Q6ICgpID0+IFN0YXJrbmV0SWRQZnBDb250cmFjdCxcbiAgU3RhcmtuZXRJZFBvcENvbnRyYWN0OiAoKSA9PiBTdGFya25ldElkUG9wQ29udHJhY3QsXG4gIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0OiAoKSA9PiBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdCxcbiAgZHluYW1pY0NhbGxEYXRhOiAoKSA9PiBkeW5hbWljQ2FsbERhdGEsXG4gIGR5bmFtaWNGZWx0OiAoKSA9PiBkeW5hbWljRmVsdCxcbiAgZXhlY3V0aW9uOiAoKSA9PiBleGVjdXRpb24sXG4gIGdldFN0YXJrbmV0SWRDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZENvbnRyYWN0LFxuICBnZXRTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QsXG4gIGdldFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0LFxuICBnZXRTdGFya25ldElkUGZwQ29udHJhY3Q6ICgpID0+IGdldFN0YXJrbmV0SWRQZnBDb250cmFjdCxcbiAgZ2V0U3RhcmtuZXRJZFBvcENvbnRyYWN0OiAoKSA9PiBnZXRTdGFya25ldElkUG9wQ29udHJhY3QsXG4gIGdldFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0OiAoKSA9PiBnZXRTdGFya25ldElkVmVyaWZpZXJDb250cmFjdCxcbiAgaXNTdGFya0RvbWFpbjogKCkgPT4gaXNTdGFya0RvbWFpbixcbiAgdXNlRGVjb2RlZDogKCkgPT4gdXNlRGVjb2RlZCxcbiAgdXNlRW5jb2RlZDogKCkgPT4gdXNlRW5jb2RlZFxufSk7XG52YXIgYmFzaWNBbHBoYWJldCA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LVwiO1xudmFyIGJhc2ljU2l6ZVBsdXNPbmUgPSBCaWdJbnQoYmFzaWNBbHBoYWJldC5sZW5ndGggKyAxKTtcbnZhciBiaWdBbHBoYWJldCA9IFwiXFx1OEZEOVxcdTY3NjVcIjtcbnZhciBiYXNpY0FscGhhYmV0U2l6ZSA9IEJpZ0ludChiYXNpY0FscGhhYmV0Lmxlbmd0aCk7XG52YXIgYmlnQWxwaGFiZXRTaXplID0gQmlnSW50KGJpZ0FscGhhYmV0Lmxlbmd0aCk7XG52YXIgYmlnQWxwaGFiZXRTaXplUGx1c09uZSA9IEJpZ0ludChiaWdBbHBoYWJldC5sZW5ndGggKyAxKTtcbmZ1bmN0aW9uIGV4dHJhY3RTdGFycyhzdHIpIHtcbiAgbGV0IGsgPSAwO1xuICB3aGlsZSAoc3RyLmVuZHNXaXRoKGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdKSkge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICAgIGsgKz0gMTtcbiAgfVxuICByZXR1cm4gW3N0ciwga107XG59XG5mdW5jdGlvbiB1c2VEZWNvZGVkKGVuY29kZWQpIHtcbiAgbGV0IGRlY29kZWQgPSBcIlwiO1xuICBlbmNvZGVkLmZvckVhY2goKHN1YmRvbWFpbikgPT4ge1xuICAgIHdoaWxlIChzdWJkb21haW4gIT09IFpFUk8pIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdWJkb21haW4gJSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgc3ViZG9tYWluIC89IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICBpZiAoY29kZSA9PT0gQmlnSW50KGJhc2ljQWxwaGFiZXQubGVuZ3RoKSkge1xuICAgICAgICBjb25zdCBuZXh0U3ViZG9tYWluID0gc3ViZG9tYWluIC8gYmlnQWxwaGFiZXRTaXplUGx1c09uZTtcbiAgICAgICAgaWYgKG5leHRTdWJkb21haW4gPT09IFpFUk8pIHtcbiAgICAgICAgICBjb25zdCBjb2RlMiA9IHN1YmRvbWFpbiAlIGJpZ0FscGhhYmV0U2l6ZVBsdXNPbmU7XG4gICAgICAgICAgc3ViZG9tYWluID0gbmV4dFN1YmRvbWFpbjtcbiAgICAgICAgICBpZiAoY29kZTIgPT09IFpFUk8pIGRlY29kZWQgKz0gYmFzaWNBbHBoYWJldFswXTtcbiAgICAgICAgICBlbHNlIGRlY29kZWQgKz0gYmlnQWxwaGFiZXRbTnVtYmVyKGNvZGUyKSAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGNvZGUyID0gc3ViZG9tYWluICUgYmlnQWxwaGFiZXRTaXplO1xuICAgICAgICAgIGRlY29kZWQgKz0gYmlnQWxwaGFiZXRbTnVtYmVyKGNvZGUyKV07XG4gICAgICAgICAgc3ViZG9tYWluIC89IGJpZ0FscGhhYmV0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGRlY29kZWQgKz0gYmFzaWNBbHBoYWJldFtOdW1iZXIoY29kZSldO1xuICAgIH1cbiAgICBjb25zdCBbc3RyLCBrXSA9IGV4dHJhY3RTdGFycyhkZWNvZGVkKTtcbiAgICBpZiAoaylcbiAgICAgIGRlY29kZWQgPSBzdHIgKyAoayAlIDIgPT09IDAgPyBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoayAvIDIgLSAxKSArIGJpZ0FscGhhYmV0WzBdICsgYmFzaWNBbHBoYWJldFsxXSA6IGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdLnJlcGVhdCgoayAtIDEpIC8gMiArIDEpKTtcbiAgICBkZWNvZGVkICs9IFwiLlwiO1xuICB9KTtcbiAgaWYgKCFkZWNvZGVkKSB7XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH1cbiAgcmV0dXJuIGRlY29kZWQuY29uY2F0KFwic3RhcmtcIik7XG59XG5mdW5jdGlvbiB1c2VFbmNvZGVkKGRlY29kZWQpIHtcbiAgbGV0IGVuY29kZWQgPSBCaWdJbnQoMCk7XG4gIGxldCBtdWx0aXBsaWVyID0gQmlnSW50KDEpO1xuICBpZiAoZGVjb2RlZC5lbmRzV2l0aChiaWdBbHBoYWJldFswXSArIGJhc2ljQWxwaGFiZXRbMV0pKSB7XG4gICAgY29uc3QgW3N0ciwga10gPSBleHRyYWN0U3RhcnMoZGVjb2RlZC5zdWJzdHJpbmcoMCwgZGVjb2RlZC5sZW5ndGggLSAyKSk7XG4gICAgZGVjb2RlZCA9IHN0ciArIGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdLnJlcGVhdCgyICogKGsgKyAxKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW3N0ciwga10gPSBleHRyYWN0U3RhcnMoZGVjb2RlZCk7XG4gICAgaWYgKGspIGRlY29kZWQgPSBzdHIgKyBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoMSArIDIgKiAoayAtIDEpKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBjaGFyID0gZGVjb2RlZFtpXTtcbiAgICBjb25zdCBpbmRleCA9IGJhc2ljQWxwaGFiZXQuaW5kZXhPZihjaGFyKTtcbiAgICBjb25zdCBibkluZGV4ID0gQmlnSW50KGJhc2ljQWxwaGFiZXQuaW5kZXhPZihjaGFyKSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGkgPT09IGRlY29kZWQubGVuZ3RoIC0gMSAmJiBkZWNvZGVkW2ldID09PSBiYXNpY0FscGhhYmV0WzBdKSB7XG4gICAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIGJhc2ljQWxwaGFiZXRTaXplO1xuICAgICAgICBtdWx0aXBsaWVyICo9IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIGJuSW5kZXg7XG4gICAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJpZ0FscGhhYmV0LmluZGV4T2YoY2hhcikgIT09IC0xKSB7XG4gICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBiYXNpY0FscGhhYmV0U2l6ZTtcbiAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIGNvbnN0IG5ld2lkID0gKGkgPT09IGRlY29kZWQubGVuZ3RoIC0gMSA/IDEgOiAwKSArIGJpZ0FscGhhYmV0LmluZGV4T2YoY2hhcik7XG4gICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBCaWdJbnQobmV3aWQpO1xuICAgICAgbXVsdGlwbGllciAqPSBiaWdBbHBoYWJldFNpemU7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmNvZGVkO1xufVxudmFyIFN0YXJrbmV0SWRDb250cmFjdCA9IHtcbiAgTUFJTk5FVDogXCIweDZhYzU5N2Y4MTE2Zjg4NmZhMWM5N2EyM2ZhNGUwODI5OTk3NWVjYWY2YjU5ODg3M2NhNjc5MmI5YmJmYjY3OFwiLFxuICBURVNUTkVUX1NFUE9MSUE6IFwiMHgxNTRiYzJlMWFmOTI2MGI5ZTY2YWYwZTljNDZmYzc1N2ZmODkzYjNmZjZhODU3MThhODEwYmFmMTQ3NFwiXG59O1xuZnVuY3Rpb24gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFN0YXJrbmV0SWRDb250cmFjdC5NQUlOTkVUO1xuICAgIGNhc2UgXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIgLyogU05fU0VQT0xJQSAqLzpcbiAgICAgIHJldHVybiBTdGFya25ldElkQ29udHJhY3QuVEVTVE5FVF9TRVBPTElBO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFya25ldC5pZCBpcyBub3QgeWV0IGRlcGxveWVkIG9uIHRoaXMgbmV0d29ya1wiKTtcbiAgfVxufVxudmFyIFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0ID0ge1xuICBNQUlOTkVUOiBcIjB4MDVkYmRlZGMyMDNlOTI3NDllMmU3NDZlMmQ0MGE3NjhkOTY2YmQyNDNkZjA0YTZiNzEyZTIyMmJjMDQwYTlhZlwiLFxuICBURVNUTkVUX1NFUE9MSUE6IFwiMHgzNjk3NjYwYTA5ODFkNzM0NzgwNzMxOTQ5ZWNiMmI0YTM4ZDZhNThmYzQxNjI5ZWQ2MTFlOGRlZmRhXCJcbn07XG5mdW5jdGlvbiBnZXRTdGFya25ldElkSWRlbnRpdHlDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdC5NQUlOTkVUO1xuICAgIGNhc2UgXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIgLyogU05fU0VQT0xJQSAqLzpcbiAgICAgIHJldHVybiBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdC5URVNUTkVUX1NFUE9MSUE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXJrbmV0LmlkIHZlcmlmaWVyIGNvbnRyYWN0IGlzIG5vdCB5ZXQgZGVwbG95ZWQgb24gdGhpcyBuZXR3b3JrXCIpO1xuICB9XG59XG52YXIgU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0ID0gXCIweDAzNGZmYjhmNDQ1MmRmN2E2MTNhMDIxMDgyNGQ2NDE0ZGJhZGNkZGNlNmM2ZTE5YmY0ZGRjOWUyMmNlNWY5NzBcIjtcbmZ1bmN0aW9uIGdldFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3Q7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNTM0NTUwNGY0YzQ5NDFcIiAvKiBTTl9TRVBPTElBICovOlxuICAgICAgcmV0dXJuIFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhcmtuZXQuaWQgbXVsdGljYWxsIGNvbnRyYWN0IGlzIG5vdCB5ZXQgZGVwbG95ZWQgb24gdGhpcyBuZXR3b3JrXCIpO1xuICB9XG59XG52YXIgU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QgPSB7XG4gIE1BSU5ORVQ6IFwiMHgwN2QxNGRmZDhlZTk1YjQxZmNlMTc5MTcwZDg4YmExZjBkNWE1MTJlMTNhZWIyMzJmMTljZmVlYzBhODhmOGJmXCIsXG4gIFRFU1RORVRfU0VQT0xJQTogXCIweDYwQjk0ZkVEZTUyNWY4MTVBRTVFODM3N0E0NjNlMTIxQzc4N2NDQ2YzYTM2MzU4QWE5QjE4YzEyYzRENTY2XCJcbn07XG5mdW5jdGlvbiBnZXRTdGFya25ldElkVmVyaWZpZXJDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdC5NQUlOTkVUO1xuICAgIGNhc2UgXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIgLyogU05fU0VQT0xJQSAqLzpcbiAgICAgIHJldHVybiBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdC5URVNUTkVUX1NFUE9MSUE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXJrbmV0LmlkIHZlcmlmaWVyIGNvbnRyYWN0IGlzIG5vdCB5ZXQgZGVwbG95ZWQgb24gdGhpcyBuZXR3b3JrXCIpO1xuICB9XG59XG52YXIgU3RhcmtuZXRJZFBmcENvbnRyYWN0ID0ge1xuICBNQUlOTkVUOiBcIjB4MDcwYWFhMjBlYzRhNDZkYTU3YzkzMmQ5ZmQ4OWNhNWU2YmI5Y2EzMTg4ZDNkZjM2MWEzMjMwNmFmZjdkNTljN1wiLFxuICBURVNUTkVUX1NFUE9MSUE6IFwiMHg5ZTdiZGI4ZGFiZDAyZWE4Y2ZjMjNiMWQxYzUyNzhlNDY0OTBmMTkzZjg3NTE2ZWQ1ZmYyZGZlYzAyXCJcbn07XG5mdW5jdGlvbiBnZXRTdGFya25ldElkUGZwQ29udHJhY3QoY2hhaW5JZCkge1xuICBzd2l0Y2ggKGNoYWluSWQpIHtcbiAgICBjYXNlIFwiMHg1MzRlNWY0ZDQxNDk0ZVwiIC8qIFNOX01BSU4gKi86XG4gICAgICByZXR1cm4gU3RhcmtuZXRJZFBmcENvbnRyYWN0Lk1BSU5ORVQ7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNTM0NTUwNGY0YzQ5NDFcIiAvKiBTTl9TRVBPTElBICovOlxuICAgICAgcmV0dXJuIFN0YXJrbmV0SWRQZnBDb250cmFjdC5URVNUTkVUX1NFUE9MSUE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJTdGFya25ldC5pZCBwcm9maWxlIHBpY3R1cmUgdmVyaWZpZXIgY29udHJhY3QgaXMgbm90IHlldCBkZXBsb3llZCBvbiB0aGlzIG5ldHdvcmtcIlxuICAgICAgKTtcbiAgfVxufVxudmFyIFN0YXJrbmV0SWRQb3BDb250cmFjdCA9IHtcbiAgTUFJTk5FVDogXCIweDAyOTNlYjJiYTk4NjJmNzYyYmQzMDM2NTg2ZDU3NTVhNzgyYmQyMmU2ZjUwMjgzMjBmMWQwNDA1ZmQ0N2JmZjRcIixcbiAgVEVTVE5FVF9TRVBPTElBOiBcIjB4MTVhZTg4YWUwNTRjYWE3NDA5MGI4OTAyNWMxNTk1NjgzZjEyZWRmN2E0ZWQyYWQwMjc0ZGUzZTFkNGFcIlxufTtcbmZ1bmN0aW9uIGdldFN0YXJrbmV0SWRQb3BDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBTdGFya25ldElkUG9wQ29udHJhY3QuTUFJTk5FVDtcbiAgICBjYXNlIFwiMHg1MzRlNWY1MzQ1NTA0ZjRjNDk0MVwiIC8qIFNOX1NFUE9MSUEgKi86XG4gICAgICByZXR1cm4gU3RhcmtuZXRJZFBvcENvbnRyYWN0LlRFU1RORVRfU0VQT0xJQTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlN0YXJrbmV0LmlkIHByb29mIG9mIHBlcnNvbmhvb2QgdmVyaWZpZXIgY29udHJhY3QgaXMgbm90IHlldCBkZXBsb3llZCBvbiB0aGlzIG5ldHdvcmtcIlxuICAgICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gZXhlY3V0aW9uKHN0YXRpY0V4LCBpZkVxdWFsID0gdm9pZCAwLCBpZk5vdEVxdWFsID0gdm9pZCAwKSB7XG4gIHJldHVybiBuZXcgQ2Fpcm9DdXN0b21FbnVtKHtcbiAgICBTdGF0aWM6IHN0YXRpY0V4LFxuICAgIElmRXF1YWw6IGlmRXF1YWwgPyB0dXBsZShpZkVxdWFsWzBdLCBpZkVxdWFsWzFdLCBpZkVxdWFsWzJdKSA6IHZvaWQgMCxcbiAgICBJZk5vdEVxdWFsOiBpZk5vdEVxdWFsID8gdHVwbGUoaWZOb3RFcXVhbFswXSwgaWZOb3RFcXVhbFsxXSwgaWZOb3RFcXVhbFsyXSkgOiB2b2lkIDBcbiAgfSk7XG59XG5mdW5jdGlvbiBkeW5hbWljRmVsdChoYXJkY29kZWQsIHJlZmVyZW5jZSA9IHZvaWQgMCkge1xuICByZXR1cm4gbmV3IENhaXJvQ3VzdG9tRW51bSh7XG4gICAgSGFyZGNvZGVkOiBoYXJkY29kZWQsXG4gICAgUmVmZXJlbmNlOiByZWZlcmVuY2UgPyB0dXBsZShyZWZlcmVuY2VbMF0sIHJlZmVyZW5jZVsxXSkgOiB2b2lkIDBcbiAgfSk7XG59XG5mdW5jdGlvbiBkeW5hbWljQ2FsbERhdGEoaGFyZGNvZGVkLCByZWZlcmVuY2UgPSB2b2lkIDAsIGFycmF5UmVmZXJlbmNlID0gdm9pZCAwKSB7XG4gIHJldHVybiBuZXcgQ2Fpcm9DdXN0b21FbnVtKHtcbiAgICBIYXJkY29kZWQ6IGhhcmRjb2RlZCxcbiAgICBSZWZlcmVuY2U6IHJlZmVyZW5jZSA/IHR1cGxlKHJlZmVyZW5jZVswXSwgcmVmZXJlbmNlWzFdKSA6IHZvaWQgMCxcbiAgICBBcnJheVJlZmVyZW5jZTogYXJyYXlSZWZlcmVuY2UgPyB0dXBsZShhcnJheVJlZmVyZW5jZVswXSwgYXJyYXlSZWZlcmVuY2VbMV0pIDogdm9pZCAwXG4gIH0pO1xufVxuZnVuY3Rpb24gaXNTdGFya0RvbWFpbihkb21haW4pIHtcbiAgcmV0dXJuIC9eKD86W2EtejAtOS1dezEsNDh9KD86W2EtejAtOS1dezEsNDh9W2EtejAtOS1dKT9cXC4pKlthLXowLTktXXsxLDQ4fVxcLnN0YXJrJC8udGVzdChkb21haW4pO1xufVxuXG4vLyBzcmMvcHJvdmlkZXIvZXh0ZW5zaW9ucy9zdGFya25ldElkLnRzXG52YXIgU3RhcmtuZXRJZCA9IGNsYXNzIF9TdGFya25ldElkIHtcbiAgYXN5bmMgZ2V0U3RhcmtOYW1lKGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gX1N0YXJrbmV0SWQuZ2V0U3RhcmtOYW1lKFxuICAgICAgLy8gQWZ0ZXIgTWl4aW4sIHRoaXMgaXMgUHJvdmlkZXJJbnRlcmZhY2VcbiAgICAgIHRoaXMsXG4gICAgICBhZGRyZXNzLFxuICAgICAgU3RhcmtuZXRJZENvbnRyYWN0MlxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUobmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBfU3RhcmtuZXRJZC5nZXRBZGRyZXNzRnJvbVN0YXJrTmFtZShcbiAgICAgIC8vIEFmdGVyIE1peGluLCB0aGlzIGlzIFByb3ZpZGVySW50ZXJmYWNlXG4gICAgICB0aGlzLFxuICAgICAgbmFtZSxcbiAgICAgIFN0YXJrbmV0SWRDb250cmFjdDJcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldFN0YXJrUHJvZmlsZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyLCBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDIsIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0MiwgU3RhcmtuZXRJZFBmcENvbnRyYWN0MiwgU3RhcmtuZXRJZFBvcENvbnRyYWN0MiwgU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0Mikge1xuICAgIHJldHVybiBfU3RhcmtuZXRJZC5nZXRTdGFya1Byb2ZpbGUoXG4gICAgICAvLyBBZnRlciBNaXhpbiwgdGhpcyBpcyBQcm92aWRlckludGVyZmFjZVxuICAgICAgdGhpcyxcbiAgICAgIGFkZHJlc3MsXG4gICAgICBTdGFya25ldElkQ29udHJhY3QyLFxuICAgICAgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyLFxuICAgICAgU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QyLFxuICAgICAgU3RhcmtuZXRJZFBmcENvbnRyYWN0MixcbiAgICAgIFN0YXJrbmV0SWRQb3BDb250cmFjdDIsXG4gICAgICBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QyXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZ2V0U3RhcmtOYW1lKHByb3ZpZGVyLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBjb250cmFjdCA9IFN0YXJrbmV0SWRDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZXhEb21haW4gPSBhd2FpdCBwcm92aWRlci5jYWxsQ29udHJhY3Qoe1xuICAgICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnRyYWN0LFxuICAgICAgICBlbnRyeXBvaW50OiBcImFkZHJlc3NfdG9fZG9tYWluXCIsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIGhpbnQ6IFtdXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlY2ltYWxEb21haW4gPSBoZXhEb21haW4ubWFwKChlbGVtZW50KSA9PiBCaWdJbnQoZWxlbWVudCkpLnNsaWNlKDEpO1xuICAgICAgY29uc3Qgc3RyaW5nRG9tYWluID0gdXNlRGVjb2RlZChkZWNpbWFsRG9tYWluKTtcbiAgICAgIGlmICghc3RyaW5nRG9tYWluKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiU3RhcmtuYW1lIG5vdCBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmdEb21haW47XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UgPT09IFwiU3RhcmtuYW1lIG5vdCBmb3VuZFwiKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgc3RhcmsgbmFtZVwiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKHByb3ZpZGVyLCBuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgY29uc3Qgc3RhcmtOYW1lID0gbmFtZS5lbmRzV2l0aChcIi5zdGFya1wiKSA/IG5hbWUgOiBgJHtuYW1lfS5zdGFya2A7XG4gICAgaWYgKCFpc1N0YXJrRG9tYWluKHN0YXJrTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZG9tYWluLCBtdXN0IGJlIGEgdmFsaWQgLnN0YXJrIGRvbWFpblwiKTtcbiAgICB9XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBjb250cmFjdCA9IFN0YXJrbmV0SWRDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbmNvZGVkRG9tYWluID0gc3RhcmtOYW1lLnJlcGxhY2UoXCIuc3RhcmtcIiwgXCJcIikuc3BsaXQoXCIuXCIpLm1hcCgocGFydCkgPT4gdXNlRW5jb2RlZChwYXJ0KS50b1N0cmluZygxMCkpO1xuICAgICAgY29uc3QgYWRkcmVzc0RhdGEgPSBhd2FpdCBwcm92aWRlci5jYWxsQ29udHJhY3Qoe1xuICAgICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnRyYWN0LFxuICAgICAgICBlbnRyeXBvaW50OiBcImRvbWFpbl90b19hZGRyZXNzXCIsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHsgZG9tYWluOiBlbmNvZGVkRG9tYWluLCBoaW50OiBbXSB9KVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWRkcmVzc0RhdGFbMF07XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgYWRkcmVzcyBmcm9tIHN0YXJrIG5hbWVcIik7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhc3luYyBnZXRTdGFya1Byb2ZpbGUocHJvdmlkZXIsIGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIsIFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0MiwgU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QyLCBTdGFya25ldElkUGZwQ29udHJhY3QyLCBTdGFya25ldElkUG9wQ29udHJhY3QyLCBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QyKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBjb250cmFjdCA9IFN0YXJrbmV0SWRDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpO1xuICAgIGNvbnN0IGlkZW50aXR5Q29udHJhY3QgPSBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QoY2hhaW5JZCk7XG4gICAgY29uc3QgdmVyaWZpZXJDb250cmFjdCA9IFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkVmVyaWZpZXJDb250cmFjdChjaGFpbklkKTtcbiAgICBjb25zdCBwZnBDb250cmFjdCA9IFN0YXJrbmV0SWRQZnBDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZFBmcENvbnRyYWN0KGNoYWluSWQpO1xuICAgIGNvbnN0IHBvcENvbnRyYWN0ID0gU3RhcmtuZXRJZFBvcENvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkUG9wQ29udHJhY3QoY2hhaW5JZCk7XG4gICAgY29uc3QgbXVsdGljYWxsQWRkcmVzcyA9IFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0KGNoYWluSWQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjYWxscyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHt9KSxcbiAgICAgICAgICB0bzogZHluYW1pY0NhbGxEYXRhKGNvbnRyYWN0KSxcbiAgICAgICAgICBzZWxlY3RvcjogZHluYW1pY0NhbGxEYXRhKGdldFNlbGVjdG9yRnJvbU5hbWUoXCJhZGRyZXNzX3RvX2RvbWFpblwiKSksXG4gICAgICAgICAgY2FsbGRhdGE6IFtkeW5hbWljQ2FsbERhdGEoYWRkcmVzcyksIGR5bmFtaWNDYWxsRGF0YShcIjBcIildXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih7fSksXG4gICAgICAgICAgdG86IGR5bmFtaWNGZWx0KGNvbnRyYWN0KSxcbiAgICAgICAgICBzZWxlY3RvcjogZHluYW1pY0ZlbHQoZ2V0U2VsZWN0b3JGcm9tTmFtZShcImRvbWFpbl90b19pZFwiKSksXG4gICAgICAgICAgY2FsbGRhdGE6IFtkeW5hbWljQ2FsbERhdGEodm9pZCAwLCB2b2lkIDAsIFswLCAwXSldXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih7fSksXG4gICAgICAgICAgdG86IGR5bmFtaWNGZWx0KGlkZW50aXR5Q29udHJhY3QpLFxuICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEodm9pZCAwLCBbMSwgMF0pLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKGVuY29kZVNob3J0U3RyaW5nKFwidHdpdHRlclwiKSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEodmVyaWZpZXJDb250cmFjdCksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoXCIwXCIpXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgIHRvOiBkeW5hbWljRmVsdChpZGVudGl0eUNvbnRyYWN0KSxcbiAgICAgICAgICBzZWxlY3RvcjogZHluYW1pY0ZlbHQoZ2V0U2VsZWN0b3JGcm9tTmFtZShcImdldF92ZXJpZmllcl9kYXRhXCIpKSxcbiAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzEsIDBdKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShlbmNvZGVTaG9ydFN0cmluZyhcImdpdGh1YlwiKSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEodmVyaWZpZXJDb250cmFjdCksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoXCIwXCIpXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgIHRvOiBkeW5hbWljRmVsdChpZGVudGl0eUNvbnRyYWN0KSxcbiAgICAgICAgICBzZWxlY3RvcjogZHluYW1pY0ZlbHQoZ2V0U2VsZWN0b3JGcm9tTmFtZShcImdldF92ZXJpZmllcl9kYXRhXCIpKSxcbiAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzEsIDBdKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShlbmNvZGVTaG9ydFN0cmluZyhcImRpc2NvcmRcIikpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZlcmlmaWVyQ29udHJhY3QpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKFwiMFwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHt9KSxcbiAgICAgICAgICB0bzogZHluYW1pY0ZlbHQoaWRlbnRpdHlDb250cmFjdCksXG4gICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNGZWx0KGdldFNlbGVjdG9yRnJvbU5hbWUoXCJnZXRfdmVyaWZpZXJfZGF0YVwiKSksXG4gICAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFsxLCAwXSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoZW5jb2RlU2hvcnRTdHJpbmcoXCJwcm9vZl9vZl9wZXJzb25ob29kXCIpKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShwb3BDb250cmFjdCksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoXCIwXCIpXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvLyBQRlBcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHt9KSxcbiAgICAgICAgICB0bzogZHluYW1pY0ZlbHQoaWRlbnRpdHlDb250cmFjdCksXG4gICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNGZWx0KGdldFNlbGVjdG9yRnJvbU5hbWUoXCJnZXRfdmVyaWZpZXJfZGF0YVwiKSksXG4gICAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFsxLCAwXSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoZW5jb2RlU2hvcnRTdHJpbmcoXCJuZnRfcHBfY29udHJhY3RcIikpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHBmcENvbnRyYWN0KSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShcIjBcIilcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih7fSksXG4gICAgICAgICAgdG86IGR5bmFtaWNGZWx0KGlkZW50aXR5Q29udHJhY3QpLFxuICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X2V4dGVuZGVkX3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEodm9pZCAwLCBbMSwgMF0pLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKGVuY29kZVNob3J0U3RyaW5nKFwibmZ0X3BwX2lkXCIpKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShcIjJcIiksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEocGZwQ29udHJhY3QpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKFwiMFwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHZvaWQgMCwgdm9pZCAwLCBbNiwgMCwgMF0pLFxuICAgICAgICAgIHRvOiBkeW5hbWljRmVsdCh2b2lkIDAsIFs2LCAwXSksXG4gICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNGZWx0KGdldFNlbGVjdG9yRnJvbU5hbWUoXCJ0b2tlblVSSVwiKSksXG4gICAgICAgICAgY2FsbGRhdGE6IFtkeW5hbWljQ2FsbERhdGEodm9pZCAwLCBbNywgMV0pLCBkeW5hbWljQ2FsbERhdGEodm9pZCAwLCBbNywgMl0pXVxuICAgICAgICB9XG4gICAgICBdO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHByb3ZpZGVyLmNhbGxDb250cmFjdCh7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogbXVsdGljYWxsQWRkcmVzcyxcbiAgICAgICAgZW50cnlwb2ludDogXCJhZ2dyZWdhdGVcIixcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoe1xuICAgICAgICAgIGNhbGxzXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludChkYXRhWzBdLCAxNik7XG4gICAgICAgIGNvbnN0IGZpbmFsQXJyYXkgPSBbXTtcbiAgICAgICAgbGV0IGluZGV4ID0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViQXJyYXlTaXplID0gcGFyc2VJbnQoZGF0YVtpbmRleF0sIDE2KTtcbiAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICBjb25zdCBzdWJBcnJheSA9IGRhdGEuc2xpY2UoaW5kZXgsIGluZGV4ICsgc3ViQXJyYXlTaXplKTtcbiAgICAgICAgICAgIGZpbmFsQXJyYXkucHVzaChzdWJBcnJheSk7XG4gICAgICAgICAgICBpbmRleCArPSBzdWJBcnJheVNpemU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdXNlRGVjb2RlZChmaW5hbEFycmF5WzBdLnNsaWNlKDEpLm1hcCgoaGV4U3RyaW5nKSA9PiBCaWdJbnQoaGV4U3RyaW5nKSkpO1xuICAgICAgICBjb25zdCB0d2l0dGVyID0gZmluYWxBcnJheVsyXVswXSAhPT0gXCIweDBcIiA/IEJpZ0ludChmaW5hbEFycmF5WzJdWzBdKS50b1N0cmluZygpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBnaXRodWIgPSBmaW5hbEFycmF5WzNdWzBdICE9PSBcIjB4MFwiID8gQmlnSW50KGZpbmFsQXJyYXlbM11bMF0pLnRvU3RyaW5nKCkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGRpc2NvcmQgPSBmaW5hbEFycmF5WzRdWzBdICE9PSBcIjB4MFwiID8gQmlnSW50KGZpbmFsQXJyYXlbNF1bMF0pLnRvU3RyaW5nKCkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHByb29mT2ZQZXJzb25ob29kID0gZmluYWxBcnJheVs1XVswXSA9PT0gXCIweDFcIjtcbiAgICAgICAgY29uc3QgcHJvZmlsZVBpY3R1cmVNZXRhZGF0YSA9IGRhdGFbMF0gPT09IFwiMHg5XCIgPyBmaW5hbEFycmF5WzhdLnNsaWNlKDEpLm1hcCgodmFsKSA9PiBkZWNvZGVTaG9ydFN0cmluZyh2YWwpKS5qb2luKFwiXCIpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBwcm9maWxlUGljdHVyZSA9IHByb2ZpbGVQaWN0dXJlTWV0YWRhdGEgfHwgYGh0dHBzOi8vc3RhcmtuZXQuaWQvYXBpL2lkZW50aWNvbnMvJHtCaWdJbnQoZmluYWxBcnJheVsxXVswXSkudG9TdHJpbmcoKX1gO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdHdpdHRlcixcbiAgICAgICAgICBnaXRodWIsXG4gICAgICAgICAgZGlzY29yZCxcbiAgICAgICAgICBwcm9vZk9mUGVyc29uaG9vZCxcbiAgICAgICAgICBwcm9maWxlUGljdHVyZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXCJFcnJvciB3aGlsZSBjYWxsaW5nIGFnZ3JlZ2F0ZSBmdW5jdGlvblwiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgdXNlciBzdGFyayBwcm9maWxlIGRhdGEgZnJvbSBhZGRyZXNzXCIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL2V4dGVuc2lvbnMvZGVmYXVsdC50c1xudmFyIFJwY1Byb3ZpZGVyMiA9IGNsYXNzIGV4dGVuZHMgTWl4aW4oUnBjUHJvdmlkZXIsIFN0YXJrbmV0SWQpIHtcbn07XG5cbi8vIHNyYy9wcm92aWRlci9pbnRlcmZhY2UudHNcbnZhciBQcm92aWRlckludGVyZmFjZSA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy9wcm92aWRlci9pbmRleC50c1xudmFyIGRlZmF1bHRQcm92aWRlciA9IG5ldyBScGNQcm92aWRlcih7IGRlZmF1bHQ6IHRydWUgfSk7XG5cbi8vIHNyYy9zaWduZXIvaW50ZXJmYWNlLnRzXG52YXIgU2lnbmVySW50ZXJmYWNlID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL3NpZ25lci9kZWZhdWx0LnRzXG52YXIgU2lnbmVyID0gY2xhc3Mge1xuICBwaztcbiAgY29uc3RydWN0b3IocGsgPSBzdGFya0N1cnZlLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSkge1xuICAgIHRoaXMucGsgPSBwayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBidWYyaGV4KHBrKSA6IHRvSGV4KHBrKTtcbiAgfVxuICBhc3luYyBnZXRQdWJLZXkoKSB7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuZ2V0U3RhcmtLZXkodGhpcy5wayk7XG4gIH1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UodHlwZWREYXRhLCBhY2NvdW50QWRkcmVzcykge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSBnZXRNZXNzYWdlSGFzaCh0eXBlZERhdGEsIGFjY291bnRBZGRyZXNzKTtcbiAgICByZXR1cm4gdGhpcy5zaWduUmF3KG1zZ0hhc2gpO1xuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbnMsIGRldGFpbHMpIHtcbiAgICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKHRyYW5zYWN0aW9ucywgZGV0YWlscy5jYWlyb1ZlcnNpb24pO1xuICAgIGxldCBtc2dIYXNoO1xuICAgIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IGRldC53YWxsZXRBZGRyZXNzLFxuICAgICAgICBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IGRldC53YWxsZXRBZGRyZXNzLFxuICAgICAgICBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduVHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnblJhdyhtc2dIYXNoKTtcbiAgfVxuICBhc3luYyBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKGRldGFpbHMpIHtcbiAgICBjb25zdCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGRldGFpbHMuY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNhbHQ6IGRldC5hZGRyZXNzU2FsdCxcbiAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzYWx0OiBkZXQuYWRkcmVzc1NhbHQsXG4gICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb24sXG4gICAgICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSksXG4gICAgICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0LmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduUmF3KG1zZ0hhc2gpO1xuICB9XG4gIGFzeW5jIHNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oZGV0YWlscykge1xuICAgIGxldCBtc2dIYXNoO1xuICAgIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduRGVjbGFyZVRyYW5zYWN0aW9uIHZlcnNpb25cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25SYXcobXNnSGFzaCk7XG4gIH1cbiAgYXN5bmMgc2lnblJhdyhtc2dIYXNoKSB7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuc2lnbihtc2dIYXNoLCB0aGlzLnBrKTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lci9ldGhTaWduZXIudHNcbmltcG9ydCB7IHNlY3AyNTZrMSBhcyBzZWNwMjU2azEyIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5cbi8vIHNyYy91dGlscy91aW50MjU2LnRzXG52YXIgdWludDI1Nl9leHBvcnRzID0ge307XG5fX2V4cG9ydCh1aW50MjU2X2V4cG9ydHMsIHtcbiAgVUlOVF8xMjhfTUFYOiAoKSA9PiBVSU5UXzEyOF9NQVgsXG4gIFVJTlRfMjU2X01BWDogKCkgPT4gVUlOVF8yNTZfTUFYLFxuICBiblRvVWludDI1NjogKCkgPT4gYm5Ub1VpbnQyNTYsXG4gIGlzVWludDI1NjogKCkgPT4gaXNVaW50MjU2LFxuICB1aW50MjU2VG9CTjogKCkgPT4gdWludDI1NlRvQk5cbn0pO1xuZnVuY3Rpb24gdWludDI1NlRvQk4odWludDI1NjIpIHtcbiAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYodWludDI1NjIpLnRvQmlnSW50KCk7XG59XG5mdW5jdGlvbiBpc1VpbnQyNTYoYm4pIHtcbiAgcmV0dXJuIENhaXJvVWludDI1Ni5pcyhibik7XG59XG5mdW5jdGlvbiBiblRvVWludDI1Nihibikge1xuICByZXR1cm4gbmV3IENhaXJvVWludDI1NihibikudG9VaW50MjU2SGV4U3RyaW5nKCk7XG59XG5cbi8vIHNyYy9zaWduZXIvZXRoU2lnbmVyLnRzXG52YXIgRXRoU2lnbmVyID0gY2xhc3Mge1xuICBwaztcbiAgLy8gaGV4IHN0cmluZyB3aXRob3V0IDB4IGFuZCB3aXRoIGFuIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICBjb25zdHJ1Y3RvcihwayA9IGV0aFJhbmRvbVByaXZhdGVLZXkoKSkge1xuICAgIHRoaXMucGsgPSBwayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBidWYyaGV4KHBrKS5wYWRTdGFydCg2NCwgXCIwXCIpIDogcmVtb3ZlSGV4UHJlZml4KHRvSGV4KHBrKSkucGFkU3RhcnQoNjQsIFwiMFwiKTtcbiAgfVxuICAvKipcbiAgICogcHJvdmlkZXMgdGhlIEV0aGVyZXVtIGZ1bGwgcHVibGljIGtleSAod2l0aG91dCBwYXJpdHkgcHJlZml4KVxuICAgKiBAcmV0dXJucyBhbiBoZXggc3RyaW5nIDogNjQgZmlyc3QgY2hhcmFjdGVycyBhcmUgUG9pbnQgWCBjb29yZGluYXRlLiA2NCBsYXN0IGNoYXJhY3RlcnMgYXJlIFBvaW50IFkgY29vcmRpbmF0ZS5cbiAgICovXG4gIGFzeW5jIGdldFB1YktleSgpIHtcbiAgICByZXR1cm4gYWRkSGV4UHJlZml4KFxuICAgICAgYnVmMmhleChzZWNwMjU2azEyLmdldFB1YmxpY0tleSh0aGlzLnBrLCBmYWxzZSkpLnBhZFN0YXJ0KDEzMCwgXCIwXCIpLnNsaWNlKDIpXG4gICAgKTtcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZSh0eXBlZERhdGEsIGFjY291bnRBZGRyZXNzKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IGdldE1lc3NhZ2VIYXNoKHR5cGVkRGF0YSwgYWNjb3VudEFkZHJlc3MpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMTIuc2lnbihcbiAgICAgIHJlbW92ZUhleFByZWZpeChzYW5pdGl6ZUhleChtc2dIYXNoKSksXG4gICAgICB0aGlzLnBrXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRFdGhTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25zLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IGdldEV4ZWN1dGVDYWxsZGF0YSh0cmFuc2FjdGlvbnMsIGRldGFpbHMuY2Fpcm9WZXJzaW9uKTtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2gyKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzZW5kZXJBZGRyZXNzOiBkZXQud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMykuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2gyKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzZW5kZXJBZGRyZXNzOiBkZXQud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb24sXG4gICAgICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSksXG4gICAgICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0LmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnblRyYW5zYWN0aW9uIHZlcnNpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMTIuc2lnbihcbiAgICAgIHJlbW92ZUhleFByZWZpeChzYW5pdGl6ZUhleChtc2dIYXNoKSksXG4gICAgICB0aGlzLnBrXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRFdGhTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgfVxuICBhc3luYyBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKGRldGFpbHMpIHtcbiAgICBjb25zdCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGRldGFpbHMuY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNhbHQ6IGRldC5hZGRyZXNzU2FsdCxcbiAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzYWx0OiBkZXQuYWRkcmVzc1NhbHQsXG4gICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb24sXG4gICAgICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSksXG4gICAgICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0LmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSBzZWNwMjU2azEyLnNpZ24oXG4gICAgICByZW1vdmVIZXhQcmVmaXgoc2FuaXRpemVIZXgobXNnSGFzaCkpLFxuICAgICAgdGhpcy5wa1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0RXRoU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gIH1cbiAgYXN5bmMgc2lnbkRlY2xhcmVUcmFuc2FjdGlvbihkZXRhaWxzKSB7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uLFxuICAgICAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0Lm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUpLFxuICAgICAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIHNpZ25EZWNsYXJlVHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2VjcDI1NmsxMi5zaWduKFxuICAgICAgcmVtb3ZlSGV4UHJlZml4KHNhbml0aXplSGV4KG1zZ0hhc2gpKSxcbiAgICAgIHRoaXMucGtcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdEV0aFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIHNpZ25hdHVyZSBpbiBjb25mb3JtaXR5IHdpdGggc3RhcmtuZXQ6OmV0aF9zaWduYXR1cmU6OlNpZ25hdHVyZVxuICAgKiBAcGFyYW0gZXRoU2lnbmF0dXJlIHNlY3AyNTZrMSBzaWduYXR1cmUgZnJvbSBOb2JsZSBjdXJ2ZXMgbGlicmFyeVxuICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGZlbHRzLCByZXByZXNlbnRpbmcgYSBDYWlybyBFdGggU2lnbmF0dXJlLlxuICAgKi9cbiAgZm9ybWF0RXRoU2lnbmF0dXJlKGV0aFNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHIgPSBiblRvVWludDI1NihldGhTaWduYXR1cmUucik7XG4gICAgY29uc3QgcyA9IGJuVG9VaW50MjU2KGV0aFNpZ25hdHVyZS5zKTtcbiAgICByZXR1cm4gW1xuICAgICAgdG9IZXgoci5sb3cpLFxuICAgICAgdG9IZXgoci5oaWdoKSxcbiAgICAgIHRvSGV4KHMubG93KSxcbiAgICAgIHRvSGV4KHMuaGlnaCksXG4gICAgICB0b0hleChldGhTaWduYXR1cmUucmVjb3ZlcnkpXG4gICAgXTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lci9sZWRnZXJTaWduZXIxMTEudHNcbnZhciBMZWRnZXJTaWduZXIxMTEgPSBjbGFzcyB7XG4gIHRyYW5zcG9ydGVyO1xuICAvLyB0aGlzIGlzIGEgaGFjayB0byBhbGxvdyB0aGUgJ0BsZWRnZXJocS9ody10cmFuc3BvcnQnIHR5cGUgdG8gYmUgdXNlZCBhcyBhIGRldiBkZXBlbmRlbmN5IGJ1dCBub3QgZXhwb3NlZCBpbiB0aGUgcHJvZHVjdGlvbiBidWlsZFxuICBfdHJhbnNwb3J0ZXI7XG4gIGFjY291bnRJRDtcbiAgZWlwMjY0NWFwcGxpY2F0aW9uTmFtZTtcbiAgcGF0aEJ1ZmZlcjtcbiAgYXBwVmVyc2lvbjtcbiAgcHViS2V5O1xuICBmdWxsUHViS2V5O1xuICAvKipcbiAgICogY29uc3RydWN0b3Igb2YgdGhlIExlZGdlclNpZ25lciBjbGFzcy5cbiAgICogQHBhcmFtIHtUcmFuc3BvcnR9IHRyYW5zcG9ydCA1IHRyYW5zcG9ydHMgYXJlIGF2YWlsYWJsZSB0byBoYW5kbGUgVVNCLCBibHVldG9vdGgsIE5vZGUsIFdlYiwgTW9iaWxlLlxuICAgKiBTZWUgR3VpZGVzIGZvciBtb3JlIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhY2NvdW50SUQgSUQgb2YgTGVkZ2VyIE5hbm8gKGNhbiBoYW5kbGUgMioqMzEgYWNjb3VudHMpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2VpcDI2NDVhcHBsaWNhdGlvbj0nTGVkZ2VyVyddIEEgd2FsbGV0IGlzIGRlZmluZWQgYnkgYW4gRVJDMjY0NSBkZXJpdmF0aW9uIHBhdGggKDYgaXRlbXMpLFxuICAgKiBhbmQgb25lIGl0ZW0gaXMgdGhlIGBhcHBsaWNhdGlvbmAgYW5kIGNhbiBiZSBjdXN0b21pemVkLlxuICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBMZWRnZXJXYC5cbiAgICogQHBhcmFtIHtMZWRnZXJQYXRoQ2FsY3VsYXRpb259IFtwYXRoRnVuY3Rpb249Z2V0TGVkZ2VyUGF0aEJ1ZmZlcjExMV1cbiAgICogZGVmaW5lcyB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGN1bGF0ZSB0aGUgcGF0aC4gQnkgZGVmYXVsdCBgZ2V0TGVkZ2VyUGF0aEJ1ZmZlcjExMWAgaXMgc2VsZWN0ZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0IFRyYW5zcG9ydE5vZGVIaWQgZnJvbSBcIkBsZWRnZXJocS9ody10cmFuc3BvcnQtbm9kZS1oaWRcIjtcbiAgICogY29uc3QgbXlOb2RlVHJhbnNwb3J0ID0gYXdhaXQgVHJhbnNwb3J0Tm9kZUhpZC5jcmVhdGUoKTtcbiAgICogY29uc3QgbXlMZWRnZXJTaWduZXIgPSBuZXcgTGVkZ2VyU2lnbmVyMTExKG15Tm9kZVRyYW5zcG9ydCwgMCk7XG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBhY2NvdW50SUQsIGVpcDI2NDVhcHBsaWNhdGlvbiA9IFwiTGVkZ2VyV1wiLCBwYXRoRnVuY3Rpb24gPSBnZXRMZWRnZXJQYXRoQnVmZmVyMTExKSB7XG4gICAgYXNzZXJ0KGFjY291bnRJRCA+PSAwLCBcIkxlZGdlciBhY2NvdW50IElEIHNoYWxsIG5vdCBiZSBhIG5lZ2F0aXZlIG51bWJlci5cIik7XG4gICAgYXNzZXJ0KGFjY291bnRJRCA8PSBNQVNLXzMxLCBcIkxlZGdlciBhY2NvdW50IElEIHNoYWxsIGJlIDwgMioqMzEuXCIpO1xuICAgIGFzc2VydCghIWVpcDI2NDVhcHBsaWNhdGlvbiwgXCJMZWRnZXIgYXBwbGljYXRpb24gbmFtZSBzaGFsbCBub3QgYmUgZW1wdHkuXCIpO1xuICAgIHRoaXMudHJhbnNwb3J0ZXIgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5fdHJhbnNwb3J0ZXIgPSB0aGlzLnRyYW5zcG9ydGVyO1xuICAgIHRoaXMuYWNjb3VudElEID0gYWNjb3VudElEO1xuICAgIHRoaXMucHViS2V5ID0gXCJcIjtcbiAgICB0aGlzLmZ1bGxQdWJLZXkgPSBcIlwiO1xuICAgIHRoaXMuZWlwMjY0NWFwcGxpY2F0aW9uTmFtZSA9IGVpcDI2NDVhcHBsaWNhdGlvbjtcbiAgICB0aGlzLmFwcFZlcnNpb24gPSBcIlwiO1xuICAgIHRoaXMucGF0aEJ1ZmZlciA9IHBhdGhGdW5jdGlvbih0aGlzLmFjY291bnRJRCwgdGhpcy5laXAyNjQ1YXBwbGljYXRpb25OYW1lKTtcbiAgfVxuICAvKipcbiAgICogcHJvdmlkZXMgdGhlIFN0YXJrbmV0IHB1YmxpYyBrZXlcbiAgICogQHJldHVybnMgYW4gaGV4IHN0cmluZyA6IDY0IGNoYXJhY3RlcnMgYXJlIFBvaW50IFggY29vcmRpbmF0ZS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBteUxlZGdlclNpZ25lci5nZXRQdWJLZXkoKTtcbiAgICogLy8gcmVzdWx0PSBcIjB4MDM2ODE0MTdiYTNlMWYwNTBkZDNjY2RjZWI4ZDIyYjVlNDRmYTcwZWU3ODQ0ZDQ3MmM2YTc2OGJkZWQ1MTc0ZVwiXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZ2V0UHViS2V5KCkge1xuICAgIGlmICghdGhpcy5wdWJLZXkpIGF3YWl0IHRoaXMuZ2V0UHVibGljS2V5cygpO1xuICAgIHJldHVybiB0aGlzLnB1YktleTtcbiAgfVxuICAvKipcbiAgICogcHJvdmlkZXMgdGhlIGZ1bGwgcHVibGljIGtleSAod2l0aCBwYXJpdHkgcHJlZml4KVxuICAgKiBAcmV0dXJucyBhbiBoZXggc3RyaW5nIDogMiBmaXJzdCBjaGFyYWN0ZXJzIGFyZSB0aGUgcGFyaXR5LCB0aGUgNjQgZm9sbG93aW5nIGNoYXJhY3RlcnMgYXJlIFBvaW50IFggY29vcmRpbmF0ZS4gNjQgbGFzdCBjaGFyYWN0ZXJzIGFyZSBQb2ludCBZIGNvb3JkaW5hdGUuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbXlMZWRnZXJTaWduZXIuZ2V0RnVsbFB1YktleSgpO1xuICAgKiAvLyByZXN1bHQ9IFwiMHgwNDAzNjgxNDE3YmEzZTFmMDUwZGQzY2NkY2ViOGQyMmI1ZTQ0ZmE3MGVlNzg0NGQ0NzJjNmE3NjhiZGVkNTE3NGUwM2NiYzg2ZjgwNWRjZmNiMGMxOTIyZGQ0ZGFmMTgxYWZhMjg5ZDg2MjIzYTE4YmM4NTYyNzY2MTViY2M3Nzg3XCJcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBnZXRGdWxsUHViS2V5KCkge1xuICAgIGlmICghdGhpcy5mdWxsUHViS2V5KSBhd2FpdCB0aGlzLmdldFB1YmxpY0tleXMoKTtcbiAgICByZXR1cm4gdGhpcy5mdWxsUHViS2V5O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIG9mIHRoZSBTdGFya25ldCBBUFAgaW1wbGVtZW50ZWQgaW4gdGhlIExlZGdlci5cbiAgICogQHJldHVybnMge3N0cmluZ30gdmVyc2lvbi5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBteUxlZGdlclNpZ25lci5nZXRBcHBWZXJzaW9uKCk7XG4gICAqIC8vIHJlc3VsdD0gXCIxLjEuMVwiXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZ2V0QXBwVmVyc2lvbigpIHtcbiAgICBpZiAoIXRoaXMuYXBwVmVyc2lvbikge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuX3RyYW5zcG9ydGVyLnNlbmQoTnVtYmVyKFwiMHg1YVwiKSwgMCwgMCwgMCk7XG4gICAgICB0aGlzLmFwcFZlcnNpb24gPSBgJHtyZXNwWzBdfS4ke3Jlc3BbMV19LiR7cmVzcFsyXX1gO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hcHBWZXJzaW9uO1xuICB9XG4gIC8qKlxuICAgKiBTaWduIGEgVHlwZWREYXRhIG1lc3NhZ2UgKFNOSVAtMTIpIGluIGEgTGVkZ2VyLlxuICAgKiBAcGFyYW0ge3R5cGVkRGF0YVRvSGFzaH0gdHlwZWREYXRhVG9IYXNoIEEgVHlwZWREYXRhIG1lc3NhZ2UgY29tcGF0aWJsZSB3aXRoIFNOSVAtMTIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50QWRkcmVzcyBTaWduZXIgYWNjb3VudCBhZGRyZXNzIChIZXggb3IgbnVtIHN0cmluZylcbiAgICogQHJldHVybnMge1NpZ25hdHVyZX0gVGhlIHNpZ25lZCBtZXNzYWdlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3VsdCA9IG15TGVkZ2VyU2lnbmVyLnNpZ25NZXNzYWdlKHNuaXAxMk1lc3NhZ2UsIGFjY291bnQwLmFkZHJlc3MpO1xuICAgKiAvLyByZXN1bHQgPSBTaWduYXR1cmUgeyByOiA2MTE0NzUyNDMzOTMzOTYxNDg3MjkzMjY5MTc0MTA1NDYxNDY0MDUyMzQxNTU5MjgyOTgzNTM4OTkxOTE1MjkwOTA5MjMyOTg2ODhuLFxuICAgKiAvLyBzOiA3OTg4Mzk4MTkyMTM1NDA5ODU4NTY5NTI0ODE2NTEzOTI2NTIxNDk3OTc4MTc1NTE2ODY2MjYxMTQ2OTc0OTMxMDE0MzM3NjE5ODJuLFxuICAgKiAvLyByZWNvdmVyeTogMH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBzaWduTWVzc2FnZSh0eXBlZERhdGFUb0hhc2gsIGFjY291bnRBZGRyZXNzKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IGdldE1lc3NhZ2VIYXNoKHR5cGVkRGF0YVRvSGFzaCwgYWNjb3VudEFkZHJlc3MpO1xuICAgIHJldHVybiB0aGlzLnNpZ25SYXcobXNnSGFzaCk7XG4gIH1cbiAgLyoqXG4gICAqIFNpZ24gaW4gYSBMZWRnZXIgYSBWMSBvciBhIFYzIHRyYW5zYWN0aW9uLiBUaGlzIGlzIGEgYmxpbmQgc2lnbiBvbiB0aGUgTGVkZ2VyIHNjcmVlbi5cbiAgICogQHBhcmFtIHtDYWxsMVtdfSB0cmFuc2FjdGlvbnMgQW4gYXJyYXkgb2YgYENhbGxgIHRyYW5zYWN0aW9ucyAoZ2VuZXJhdGVkIGZvciBleGFtcGxlIGJ5IGBteUNvbnRyYWN0LnBvcHVsYXRlKClgKS5cbiAgICogQHBhcmFtIHtJbnZvY2F0aW9uc1NpZ25lckRldGFpbHN9IHRyYW5zYWN0aW9uc0RldGFpbCBBbiBvYmplY3QgdGhhdCBpbmNsdWRlcyBhbGwgdGhlIG5lY2Vzc2FyeSBpbnB1dHMgdG8gaGFzaCB0aGUgdHJhbnNhY3Rpb24uIENhbiBiZSBgVjJJbnZvY2F0aW9uc1NpZ25lckRldGFpbHNgIG9yIGBWM0ludm9jYXRpb25zU2lnbmVyRGV0YWlsc2AgdHlwZS5cbiAgICogQHJldHVybnMge1NpZ25hdHVyZX0gVGhlIHNpZ25lZCB0cmFuc2FjdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCB0eERldGFpbHNWMzogVjNJbnZvY2F0aW9uc1NpZ25lckRldGFpbHMgPSB7XG4gICAqIGNoYWluSWQ6IGNvbnN0YW50cy5TdGFya25ldENoYWluSWQuU05fTUFJTixcbiAgICogbm9uY2U6IFwiMjhcIixcbiAgICogYWNjb3VudERlcGxveW1lbnREYXRhOiBbXSxcbiAgICogcGF5bWFzdGVyRGF0YTogW10sXG4gICAqIGNhaXJvVmVyc2lvbjogXCIxXCIsXG4gICAqIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBcIkwxXCIsXG4gICAqIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IFwiTDFcIixcbiAgICogcmVzb3VyY2VCb3VuZHM6IHtcbiAgICogICBsMV9nYXM6IHtcbiAgICogICAgIG1heF9hbW91bnQ6IFwiMHgyYTAwXCIsXG4gICAqICAgICBtYXhfcHJpY2VfcGVyX3VuaXQ6IFwiMHg1YzAwMDAwXCJcbiAgICogICB9LFxuICAgKiAgIGwyX2dhczoge1xuICAgKiAgICAgbWF4X2Ftb3VudDogXCIweDAwXCIsXG4gICAqICAgICBtYXhfcHJpY2VfcGVyX3VuaXQ6IFwiMHgwMFwiXG4gICAqICAgfSxcbiAgICogfSxcbiAgICogdGlwOiAwLFxuICAgKiB2ZXJzaW9uOiBcIjB4M1wiLFxuICAgKiB3YWxsZXRBZGRyZXNzOiBhY2NvdW50MC5hZGRyZXNzXG4gICAqIH1cbiAgICogY29uc3QgcmVzdWx0ID0gbXlMZWRnZXJTaWduZXIuc2lnblRyYW5zYWN0aW9uKFtjYWxsMCwgY2FsbDFdLCB0eERldGFpbHNWMyk7XG4gICAqIC8vIHJlc3VsdCA9IFNpZ25hdHVyZSB7IHI6IDYxMTQ3NTI0MzM5MzM5NjE0ODcyOTMyNjkxNzQxMDU0NjE0NjQwNTIzNDE1NTkyODI5ODM1Mzg5OTE5MTUyOTA5MDkyMzI5ODY4OG4sXG4gICAqIC8vIHM6IDc5ODgzOTgxOTIxMzU0MDk4NTg1Njk1MjQ4MTY1MTM5MjY1MjE0OTc5NzgxNzU1MTY4NjYyNjExNDY5NzQ5MzEwMTQzMzc2MTk4Mm4sXG4gICAqIC8vIHJlY292ZXJ5OiAwfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbnMsIHRyYW5zYWN0aW9uc0RldGFpbCkge1xuICAgIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBnZXRFeGVjdXRlQ2FsbGRhdGEodHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbnNEZXRhaWwuY2Fpcm9WZXJzaW9uKTtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhFVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXModHJhbnNhY3Rpb25zRGV0YWlsLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSB0cmFuc2FjdGlvbnNEZXRhaWw7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMih7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2VuZGVyQWRkcmVzczogZGV0LndhbGxldEFkZHJlc3MsXG4gICAgICAgIGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKHRyYW5zYWN0aW9uc0RldGFpbC52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gdHJhbnNhY3Rpb25zRGV0YWlsO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IGRldC53YWxsZXRBZGRyZXNzLFxuICAgICAgICBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduVHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnblJhdyhtc2dIYXNoKTtcbiAgfVxuICAvKipcbiAgICogU2lnbiBpbiBhIExlZGdlciB0aGUgZGVwbG95bWVudCBvZiBhIG5ldyBhY2NvdW50LiBUaGlzIGlzIGEgYmxpbmQgc2lnbiBvbiB0aGUgTGVkZ2VyIHNjcmVlbi5cbiAgICogQHBhcmFtIHtEZXBsb3lBY2NvdW50U2lnbmVyRGV0YWlsc30gZGV0YWlscyBBbiBvYmplY3QgdGhhdCBpbmNsdWRlcyBhbGwgbmVjZXNzYXJ5IGRhdGEgdG8gY2FsY3VsYXRlIHRoZSBIYXNoLiBJdCBjYW4gYmUgYFYyRGVwbG95QWNjb3VudFNpZ25lckRldGFpbHNgIG9yIGBWM0RlcGxveUFjY291bnRTaWduZXJEZXRhaWxzYCB0eXBlcy5cbiAgICogQHJldHVybnMge1NpZ25hdHVyZX0gVGhlIGRlcGxveSBhY2NvdW50IHNpZ25hdHVyZS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQgPSBteUxlZGdlclNpZ25lci5zaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKGRldGFpbHMpO1xuICAgKiAvLyByZXN1bHQgPSBTaWduYXR1cmUgeyByOiA2MTE0NzUyNDMzOTMzOTYxNDg3MjkzMjY5MTc0MTA1NDYxNDY0MDUyMzQxNTU5MjgyOTgzNTM4OTkxOTE1MjkwOTA5MjMyOTg2ODhuLFxuICAgKiAvLyBzOiA3OTg4Mzk4MTkyMTM1NDA5ODU4NTY5NTI0ODE2NTEzOTI2NTIxNDk3OTc4MTc1NTE2ODY2MjYxMTQ2OTc0OTMxMDE0MzM3NjE5ODJuLFxuICAgKiAvLyByZWNvdmVyeTogMH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKGRldGFpbHMpIHtcbiAgICBjb25zdCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGRldGFpbHMuY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNhbHQ6IGRldC5hZGRyZXNzU2FsdCxcbiAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzYWx0OiBkZXQuYWRkcmVzc1NhbHQsXG4gICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb24sXG4gICAgICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSksXG4gICAgICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0LmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduUmF3KG1zZ0hhc2gpO1xuICB9XG4gIC8qKlxuICAgKiBTaWduIGluIGEgTGVkZ2VyIHRoZSBkZWNsYXJhdGlvbiBvZiBhIG5ldyBjbGFzcy4gVGhpcyBpcyBhIGJsaW5kIHNpZ24gb24gdGhlIExlZGdlciBzY3JlZW4uXG4gICAqIEBwYXJhbSB7RGVjbGFyZVNpZ25lckRldGFpbHN9IGRldGFpbHMgQW4gb2JqZWN0IHRoYXQgaW5jbHVkZXMgYWxsIG5lY2Vzc2FyeSBkYXRhIHRvIGNhbGN1bGF0ZSB0aGUgSGFzaC4gSXQgY2FuIGJlIGBWM0RlY2xhcmVTaWduZXJEZXRhaWxzYCBvciBgVjJEZWNsYXJlU2lnbmVyRGV0YWlsc2AgdHlwZXMuXG4gICAqIEByZXR1cm5zIHtTaWduYXR1cmV9IFRoZSBkZWNsYXJlIFNpZ25hdHVyZS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQgPSBteUxlZGdlclNpZ25lci5zaWduRGVjbGFyZVRyYW5zYWN0aW9uKGRldGFpbHMpO1xuICAgKiAvLyByZXN1bHQgPSBTaWduYXR1cmUgeyByOiA2MTE0NzUyNDMzOTMzOTYxNDg3MjkzMjY5MTc0MTA1NDYxNDY0MDUyMzQxNTU5MjgyOTgzNTM4OTkxOTE1MjkwOTA5MjMyOTg2ODhuLFxuICAgKiAvLyBzOiA3OTg4Mzk4MTkyMTM1NDA5ODU4NTY5NTI0ODE2NTEzOTI2NTIxNDk3OTc4MTc1NTE2ODY2MjYxMTQ2OTc0OTMxMDE0MzM3NjE5ODJuLFxuICAgKiAvLyByZWNvdmVyeTogMH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBzaWduRGVjbGFyZVRyYW5zYWN0aW9uKGRldGFpbHMpIHtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhFVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMykuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb24sXG4gICAgICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSksXG4gICAgICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0LmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnbkRlY2xhcmVUcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduUmF3KG1zZ0hhc2gpO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBzaWduIGEgaGFzaCBpbiBhIExlZGdlciBOYW5vLlxuICAgKiBUaGlzIGlzIGEgYmxpbmQgc2lnbiBpbiB0aGUgTGVkZ2VyIDsgbm8gZGlzcGxheSBvZiB3aGF0IHlvdSBhcmUgc2lnbmluZy5cbiAgICovXG4gIGFzeW5jIHNpZ25SYXcobXNnSGFzaCkge1xuICAgIGFkZEhleFByZWZpeChcbiAgICAgIGJ1ZjJoZXgoYXdhaXQgdGhpcy5fdHJhbnNwb3J0ZXIuc2VuZChOdW1iZXIoXCIweDVhXCIpLCAyLCAwLCAwLCBCdWZmZXIuZnJvbSh0aGlzLnBhdGhCdWZmZXIpKSlcbiAgICApO1xuICAgIGNvbnN0IHNoaWZ0ZWRIYXNoID0gdG9IZXgoQmlnSW50KG1zZ0hhc2gpIDw8IDRuKTtcbiAgICBjb25zdCBidWZmMiA9IGhleFRvQnl0ZXMoc2hpZnRlZEhhc2gpO1xuICAgIGNvbnN0IHJlc3BTaWduMiA9IFVpbnQ4QXJyYXkuZnJvbShcbiAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydGVyLnNlbmQoTnVtYmVyKFwiMHg1YVwiKSwgMiwgMSwgMCwgQnVmZmVyLmZyb20oYnVmZjIpKVxuICAgICk7XG4gICAgY29uc3QgciA9IEJpZ0ludChhZGRIZXhQcmVmaXgoYnVmMmhleChyZXNwU2lnbjIuc3ViYXJyYXkoMSwgMzMpKSkpO1xuICAgIGNvbnN0IHMgPSBCaWdJbnQoYWRkSGV4UHJlZml4KGJ1ZjJoZXgocmVzcFNpZ24yLnN1YmFycmF5KDMzLCA2NSkpKSk7XG4gICAgY29uc3QgdiA9IHJlc3BTaWduMls2NV07XG4gICAgY29uc3Qgc2lnbjAgPSBuZXcgc3RhcmtDdXJ2ZS5TaWduYXR1cmUociwgcyk7XG4gICAgY29uc3Qgc2lnbjEgPSBzaWduMC5hZGRSZWNvdmVyeUJpdCh2KTtcbiAgICByZXR1cm4gc2lnbjE7XG4gIH1cbiAgLyoqIGludGVybmFsIGZ1bmN0aW9uIHRvIGdldCBib3RoIHRoZSBTdGFya25ldCBwdWJsaWMga2V5IGFuZCB0aGUgZnVsbCBwdWJsaWMga2V5ICovXG4gIGFzeW5jIGdldFB1YmxpY0tleXMoKSB7XG4gICAgY29uc3QgcGF0aEJ1ZmYgPSB0aGlzLnBhdGhCdWZmZXI7XG4gICAgY29uc3QgcmVzcEdldFB1YmxpYyA9IFVpbnQ4QXJyYXkuZnJvbShcbiAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydGVyLnNlbmQoTnVtYmVyKFwiMHg1YVwiKSwgMSwgMCwgMCwgQnVmZmVyLmZyb20ocGF0aEJ1ZmYpKVxuICAgICk7XG4gICAgdGhpcy5wdWJLZXkgPSBhZGRIZXhQcmVmaXgoYnVmMmhleChyZXNwR2V0UHVibGljLnN1YmFycmF5KDEsIDMzKSkpO1xuICAgIHRoaXMuZnVsbFB1YktleSA9IGFkZEhleFByZWZpeChidWYyaGV4KHJlc3BHZXRQdWJsaWMuc3ViYXJyYXkoMCwgNjUpKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRMZWRnZXJQYXRoQnVmZmVyMTExKGFjY291bnRJZCwgYXBwbGljYXRpb25OYW1lID0gXCJMZWRnZXJXXCIpIHtcbiAgY29uc3QgcGF0aDBidWZmID0gbmV3IFVpbnQ4QXJyYXkoWzEyOCwgMCwgMTAsIDg1XSk7XG4gIGNvbnN0IHBhdGgxYnVmZiA9IG5ldyBVaW50OEFycmF5KFs3MSwgNjUsIDIzMywgMjAxXSk7XG4gIGNvbnN0IHBhdGgyYnVmZiA9IGFwcGxpY2F0aW9uTmFtZSA9PT0gXCJMZWRnZXJXXCIgPyBuZXcgVWludDhBcnJheShbNDMsIDIwNiwgMjMxLCAyMTldKSA6IHN0cmluZ1RvU2hhMjU2VG9BcnJheUJ1ZmY0KGFwcGxpY2F0aW9uTmFtZSk7XG4gIGNvbnN0IHBhdGgzYnVmZiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAwXSk7XG4gIGNvbnN0IGhleCA9IHRvSGV4KGFjY291bnRJZCk7XG4gIGNvbnN0IHBhZGRlZCA9IGFkZEhleFByZWZpeChyZW1vdmVIZXhQcmVmaXgoaGV4KS5wYWRTdGFydCg4LCBcIjBcIikpO1xuICBjb25zdCBwYXRoNGJ1ZmYgPSBoZXhUb0J5dGVzKHBhZGRlZCk7XG4gIGNvbnN0IHBhdGg1YnVmZiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAwXSk7XG4gIGNvbnN0IHBhdGhCdWZmID0gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcihbXG4gICAgcGF0aDBidWZmLFxuICAgIHBhdGgxYnVmZixcbiAgICBwYXRoMmJ1ZmYsXG4gICAgcGF0aDNidWZmLFxuICAgIHBhdGg0YnVmZixcbiAgICBwYXRoNWJ1ZmZcbiAgXSk7XG4gIHJldHVybiBwYXRoQnVmZjtcbn1cblxuLy8gc3JjL3V0aWxzL2FkZHJlc3MudHNcbmltcG9ydCB7IGhleFRvQnl0ZXMgYXMgaGV4VG9CeXRlczIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiO1xuZnVuY3Rpb24gYWRkQWRkcmVzc1BhZGRpbmcoYWRkcmVzcykge1xuICBjb25zdCBoZXggPSB0b0hleChhZGRIZXhQcmVmaXgoYWRkcmVzcy50b1N0cmluZygpKSk7XG4gIGNvbnN0IHBhZGRlZCA9IHJlbW92ZUhleFByZWZpeChoZXgpLnBhZFN0YXJ0KDY0LCBcIjBcIik7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgocGFkZGVkKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzKGFkZHJlc3MpIHtcbiAgY29uc3QgcmVzdWx0ID0gYWRkQWRkcmVzc1BhZGRpbmcoYWRkcmVzcyk7XG4gIGlmICghcmVzdWx0Lm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs2NH0kLykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEFkZHJlc3MgRm9ybWF0XCIpO1xuICB9XG4gIGFzc2VydEluUmFuZ2UocmVzdWx0LCBaRVJPLCBBRERSX0JPVU5EIC0gMW4sIFwiU3RhcmtuZXQgQWRkcmVzc1wiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gIGNvbnN0IGNoYXJzID0gcmVtb3ZlSGV4UHJlZml4KHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzKGFkZHJlc3MpKS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiXCIpO1xuICBjb25zdCBoZXggPSByZW1vdmVIZXhQcmVmaXgoa2VjY2FrQm4oYWRkcmVzcykpO1xuICBjb25zdCBoYXNoZWQgPSBoZXhUb0J5dGVzMihoZXgucGFkU3RhcnQoNjQsIFwiMFwiKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBpZiAoaGFzaGVkW2kgPj4gMV0gPj4gNCA+PSA4KSB7XG4gICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gJiAxNSkgPj0gOCkge1xuICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoY2hhcnMuam9pbihcIlwiKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykgPT09IGFkZHJlc3M7XG59XG5cbi8vIHNyYy9zaWduZXIvbGVkZ2VyU2lnbmVyMjIxLnRzXG52YXIgTGVkZ2VyU2lnbmVyMjIxID0gY2xhc3MgZXh0ZW5kcyBMZWRnZXJTaWduZXIxMTEge1xuICAvKipcbiAgICogY29uc3RydWN0b3Igb2YgdGhlIExlZGdlclNpZ25lciBjbGFzcy5cbiAgICogQHBhcmFtIHtUcmFuc3BvcnR9IHRyYW5zcG9ydCA1IHRyYW5zcG9ydHMgYXJlIGF2YWlsYWJsZSB0byBoYW5kbGUgVVNCLCBibHVldG9vdGgsIE5vZGUsIFdlYiwgTW9iaWxlLlxuICAgKiBTZWUgR3VpZGVzIGZvciBtb3JlIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhY2NvdW50SUQgSUQgb2YgTGVkZ2VyIE5hbm8gKGNhbiBoYW5kbGUgMioqMzEgYWNjb3VudHMpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2VpcDI2NDVhcHBsaWNhdGlvbj0nTGVkZ2VyVyddIEEgd2FsbGV0IGlzIGRlZmluZWQgYnkgYW4gRVJDMjY0NSBkZXJpdmF0aW9uIHBhdGggKDYgaXRlbXMpLlxuICAgKiBPbmUgaXRlbSBpcyBjYWxsZWQgYGFwcGxpY2F0aW9uYCBhbmQgY2FuIGJlIGN1c3RvbWl6ZWQuXG4gICAqIERlZmF1bHQgdmFsdWUgaXMgYExlZGdlcldgLlxuICAgKiBAcGFyYW0ge0xlZGdlclBhdGhDYWxjdWxhdGlvbn0gW3BhdGhGdW5jdGlvbj1nZXRMZWRnZXJQYXRoQnVmZmVyMjIxXVxuICAgKiBkZWZpbmVzIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsY3VsYXRlIHRoZSBwYXRoLiBCeSBkZWZhdWx0IGBnZXRMZWRnZXJQYXRoQnVmZmVyMjIxYCBpcyBzZWxlY3RlZC5cbiAgICpcbiAgICogSWYgeW91IGFyZSB1c2luZyBBUFAgdjIuMi4xIHdpdGggYW4gYWNjb3VudCBjcmVhdGVkIHdpdGggdGhlIHYxLjEuMSwgeW91IG5lZWQgdG8gdXNlIDpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBteUxlZGdlclNpZ25lciA9IG5ldyBMZWRnZXJTaWduZXIyMTEobXlOb2RlVHJhbnNwb3J0LCAwLCB1bmRlZmluZWQsIGdldExlZGdlclBhdGhCdWZmZXIxMTEpO1xuICAgKiBgYGBcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgVHJhbnNwb3J0Tm9kZUhpZCBmcm9tIFwiQGxlZGdlcmhxL2h3LXRyYW5zcG9ydC1ub2RlLWhpZFwiO1xuICAgKiBjb25zdCBteU5vZGVUcmFuc3BvcnQgPSBhd2FpdCBUcmFuc3BvcnROb2RlSGlkLmNyZWF0ZSgpO1xuICAgKiBjb25zdCBteUxlZGdlclNpZ25lciA9IG5ldyBMZWRnZXJTaWduZXIyMTEobXlOb2RlVHJhbnNwb3J0LCAwKTtcbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGFjY291bnRJRCwgZWlwMjY0NWFwcGxpY2F0aW9uID0gXCJMZWRnZXJXXCIsIHBhdGhGdW5jdGlvbiA9IGdldExlZGdlclBhdGhCdWZmZXIyMjEpIHtcbiAgICBzdXBlcih0cmFuc3BvcnQsIGFjY291bnRJRCwgZWlwMjY0NWFwcGxpY2F0aW9uLCBwYXRoRnVuY3Rpb24pO1xuICB9XG4gIC8qKlxuICAgKiBTaWduIGluIGEgTGVkZ2VyIGEgVjEgb3IgYSBWMyB0cmFuc2FjdGlvbi4gVGhlIGRldGFpbHMgYXJlIGRpc3BsYXllZCBvbiB0aGUgTGVkZ2VyIHNjcmVlbi5cbiAgICogQHBhcmFtIHtDYWxsW119IHRyYW5zYWN0aW9ucyBBbiBhcnJheSBvZiBgQ2FsbGAgdHJhbnNhY3Rpb25zIChnZW5lcmF0ZWQgZm9yIGV4YW1wbGUgYnkgYG15Q29udHJhY3QucG9wdWxhdGUoKWApLlxuICAgKiBAcGFyYW0ge0ludm9jYXRpb25zU2lnbmVyRGV0YWlsc30gdHJhbnNhY3Rpb25zRGV0YWlsIEFuIG9iamVjdCB0aGF0IGluY2x1ZGVzIGFsbCB0aGUgbmVjZXNzYXJ5IGlucHV0cyB0byBoYXNoIHRoZSB0cmFuc2FjdGlvbi4gQ2FuIGJlIGBWMkludm9jYXRpb25zU2lnbmVyRGV0YWlsc2Agb3IgYFYzSW52b2NhdGlvbnNTaWduZXJEZXRhaWxzYCB0eXBlLlxuICAgKiBAcmV0dXJucyB7U2lnbmF0dXJlfSBUaGUgc2lnbmVkIHRyYW5zYWN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHR4RGV0YWlsc1YzOiBWM0ludm9jYXRpb25zU2lnbmVyRGV0YWlscyA9IHtcbiAgICogY2hhaW5JZDogY29uc3RhbnRzLlN0YXJrbmV0Q2hhaW5JZC5TTl9NQUlOLFxuICAgKiBub25jZTogXCIyOFwiLFxuICAgKiBhY2NvdW50RGVwbG95bWVudERhdGE6IFtdLFxuICAgKiBwYXltYXN0ZXJEYXRhOiBbXSxcbiAgICogY2Fpcm9WZXJzaW9uOiBcIjFcIixcbiAgICogZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IFwiTDFcIixcbiAgICogbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogXCJMMVwiLFxuICAgKiByZXNvdXJjZUJvdW5kczoge1xuICAgKiAgIGwxX2dhczoge1xuICAgKiAgICAgbWF4X2Ftb3VudDogXCIweDJhMDBcIixcbiAgICogICAgIG1heF9wcmljZV9wZXJfdW5pdDogXCIweDVjMDAwMDBcIlxuICAgKiAgIH0sXG4gICAqICAgbDJfZ2FzOiB7XG4gICAqICAgICBtYXhfYW1vdW50OiBcIjB4MDBcIixcbiAgICogICAgIG1heF9wcmljZV9wZXJfdW5pdDogXCIweDAwXCJcbiAgICogICB9LFxuICAgKiB9LFxuICAgKiB0aXA6IDAsXG4gICAqIHZlcnNpb246IFwiMHgzXCIsXG4gICAqIHdhbGxldEFkZHJlc3M6IGFjY291bnQwLmFkZHJlc3NcbiAgICogfVxuICAgKiBjb25zdCByZXN1bHQgPSBteUxlZGdlclNpZ25lci5zaWduVHJhbnNhY3Rpb24oW2NhbGwwLCBjYWxsMV0sIHR4RGV0YWlsc1YzKTtcbiAgICogLy8gcmVzdWx0ID0gU2lnbmF0dXJlIHsgcjogNjExNDc1MjQzMzkzMzk2MTQ4NzI5MzI2OTE3NDEwNTQ2MTQ2NDA1MjM0MTU1OTI4Mjk4MzUzODk5MTkxNTI5MDkwOTIzMjk4Njg4bixcbiAgICogLy8gczogNzk4ODM5ODE5MjEzNTQwOTg1ODU2OTUyNDgxNjUxMzkyNjUyMTQ5Nzk3ODE3NTUxNjg2NjI2MTE0Njk3NDkzMTAxNDMzNzYxOTgybixcbiAgICogLy8gcmVjb3Zlcnk6IDB9XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb25zRGV0YWlsKSB7XG4gICAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IGdldEV4ZWN1dGVDYWxsZGF0YSh0cmFuc2FjdGlvbnMsIHRyYW5zYWN0aW9uc0RldGFpbC5jYWlyb1ZlcnNpb24pO1xuICAgIGlmIChPYmplY3QudmFsdWVzKEVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyh0cmFuc2FjdGlvbnNEZXRhaWwudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IHRyYW5zYWN0aW9uc0RldGFpbDtcbiAgICAgIGNvbnN0IG1zZ0hhc2ggPSBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2gyKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzZW5kZXJBZGRyZXNzOiBkZXQud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb25cbiAgICAgIH0pO1xuICAgICAgY29uc3QgbGVkZ2VyUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNpZ25UeFYxKGRldCwgdHJhbnNhY3Rpb25zKTtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdG9CaWdJbnQobXNnSGFzaCkgPT09IGxlZGdlclJlc3BvbnNlLmhhc2gsXG4gICAgICAgIFwiVGhlIHRyYW5zYWN0aW9uIGhhc2ggY2FsY3VsYXRlZCBieSBTdGFya25ldC5qcyBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgb25lIGNhbGN1bGF0ZWQgYnkgdGhlIExlZGdlci5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBsZWRnZXJSZXNwb25zZS5zaWduYXR1cmU7XG4gICAgfVxuICAgIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyh0cmFuc2FjdGlvbnNEZXRhaWwudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IHRyYW5zYWN0aW9uc0RldGFpbDtcbiAgICAgIGNvbnN0IG1zZ0hhc2ggPSBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2gyKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzZW5kZXJBZGRyZXNzOiBkZXQud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb24sXG4gICAgICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSksXG4gICAgICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0LmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKVxuICAgICAgfSk7XG4gICAgICBjb25zdCBsZWRnZXJSZXNwb25zZSA9IGF3YWl0IHRoaXMuc2lnblR4VjMoZGV0LCB0cmFuc2FjdGlvbnMpO1xuICAgICAgYXNzZXJ0KFxuICAgICAgICB0b0JpZ0ludChtc2dIYXNoKSA9PT0gbGVkZ2VyUmVzcG9uc2UuaGFzaCxcbiAgICAgICAgXCJUaGUgdHJhbnNhY3Rpb24gaGFzaCBjYWxjdWxhdGVkIGJ5IFN0YXJrbmV0LmpzIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBvbmUgY2FsY3VsYXRlZCBieSB0aGUgTGVkZ2VyLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGxlZGdlclJlc3BvbnNlLnNpZ25hdHVyZTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduVHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgfVxuICAvKipcbiAgICogU2lnbiBpbiBhIExlZGdlciB0aGUgZGVwbG95bWVudCBvZiBhIG5ldyBhY2NvdW50LiBUaGUgZGV0YWlscyBhcmUgZGlzcGxheWVkIG9uIHRoZSBMZWRnZXIgc2NyZWVuLlxuICAgKiBAcGFyYW0ge0RlcGxveUFjY291bnRTaWduZXJEZXRhaWxzfSBkZXRhaWxzIEFuIG9iamVjdCB0aGF0IGluY2x1ZGVzIGFsbCBuZWNlc3NhcnkgZGF0YSB0byBjYWxjdWxhdGUgdGhlIEhhc2guIEl0IGNhbiBiZSBgVjJEZXBsb3lBY2NvdW50U2lnbmVyRGV0YWlsc2Agb3IgYFYzRGVwbG95QWNjb3VudFNpZ25lckRldGFpbHNgIHR5cGVzLlxuICAgKiBAcmV0dXJucyB7U2lnbmF0dXJlfSBUaGUgZGVwbG95IGFjY291bnQgc2lnbmF0dXJlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3VsdCA9IG15TGVkZ2VyU2lnbmVyLnNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oZGV0YWlscyk7XG4gICAqIC8vIHJlc3VsdCA9IFNpZ25hdHVyZSB7IHI6IDYxMTQ3NTI0MzM5MzM5NjE0ODcyOTMyNjkxNzQxMDU0NjE0NjQwNTIzNDE1NTkyODI5ODM1Mzg5OTE5MTUyOTA5MDkyMzI5ODY4OG4sXG4gICAqIC8vIHM6IDc5ODgzOTgxOTIxMzU0MDk4NTg1Njk1MjQ4MTY1MTM5MjY1MjE0OTc5NzgxNzU1MTY4NjYyNjExNDY5NzQ5MzEwMTQzMzc2MTk4Mm4sXG4gICAqIC8vIHJlY292ZXJ5OiAwfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoZGV0YWlscy5jb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhFVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2FsdDogZGV0LmFkZHJlc3NTYWx0LFxuICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGxlZGdlclJlc3BvbnNlID0gYXdhaXQgdGhpcy5zaWduRGVwbG95QWNjb3VudFYxKGRldCk7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHRvQmlnSW50KG1zZ0hhc2gpID09PSBsZWRnZXJSZXNwb25zZS5oYXNoLFxuICAgICAgICBcIlRoZSB0cmFuc2FjdGlvbiBoYXNoIGNhbGN1bGF0ZWQgYnkgU3RhcmtuZXQuanMgaXMgZGlmZmVyZW50IGZyb20gdGhlIG9uZSBjYWxjdWxhdGVkIGJ5IHRoZSBMZWRnZXIuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbGVkZ2VyUmVzcG9uc2Uuc2lnbmF0dXJlO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMykuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2FsdDogZGV0LmFkZHJlc3NTYWx0LFxuICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uLFxuICAgICAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0Lm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUpLFxuICAgICAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbGVkZ2VyUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNpZ25EZXBsb3lBY2NvdW50VjMoZGV0KTtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdG9CaWdJbnQobXNnSGFzaCkgPT09IGxlZGdlclJlc3BvbnNlLmhhc2gsXG4gICAgICAgIFwiVGhlIHRyYW5zYWN0aW9uIGhhc2ggY2FsY3VsYXRlZCBieSBTdGFya25ldC5qcyBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgb25lIGNhbGN1bGF0ZWQgYnkgdGhlIExlZGdlci5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBsZWRnZXJSZXNwb25zZS5zaWduYXR1cmU7XG4gICAgfVxuICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBjb252ZXJ0IGEgYmlnTnVtYmVyaXNoIHRvIGFuIFVpbnQ4YXJyYXkgb2YgMjU2IGJpdHNcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJpc2h9IGlucHV0IGlucHV0IHZhbHVlXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyAzMiBieXRlcy5cbiAgICovXG4gIGNvbnZlcnRCblRvTGVkZ2VyKGlucHV0KSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMoYWRkQWRkcmVzc1BhZGRpbmcodG9IZXgoaW5wdXQpKSk7XG4gIH1cbiAgLyoqXG4gICAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGRlY29kZSB0aGUgcmVzcG9uc2Ugb2YgdGhlIExlZGdlciBzaWduYXR1cmVcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSByZXNwU2lnbiB0aGUgQnVmZmVyIHJlc3BvbnNlIG9mIHRoZSBMZWRnZXJcbiAgICogQHJldHVybnMgeyBoYXNoOiBiaWdpbnQ7IHNpZ25hdHVyZTogU2lnbmF0dXJlIH0gdHJhbnNhY3Rpb24gaGFzaCAmIHNpZ25hdHVyZVxuICAgKi9cbiAgZGVjb2RlU2lnbmF0dXJlTGVkZ2VyKHJlc3BTaWduKSB7XG4gICAgY29uc3QgaCA9IEJpZ0ludChhZGRIZXhQcmVmaXgoYnVmMmhleChyZXNwU2lnbi5zdWJhcnJheSgwLCAzMikpKSk7XG4gICAgY29uc3QgciA9IEJpZ0ludChhZGRIZXhQcmVmaXgoYnVmMmhleChyZXNwU2lnbi5zdWJhcnJheSgzMywgNjUpKSkpO1xuICAgIGNvbnN0IHMgPSBCaWdJbnQoYWRkSGV4UHJlZml4KGJ1ZjJoZXgocmVzcFNpZ24uc3ViYXJyYXkoNjUsIDk3KSkpKTtcbiAgICBjb25zdCB2ID0gcmVzcFNpZ25bOTddO1xuICAgIGNvbnN0IHNpZ24wID0gbmV3IHN0YXJrQ3VydmUuU2lnbmF0dXJlKHIsIHMpO1xuICAgIGNvbnN0IHNpZ24xID0gc2lnbjAuYWRkUmVjb3ZlcnlCaXQodik7XG4gICAgcmV0dXJuIHsgaGFzaDogaCwgc2lnbmF0dXJlOiBzaWduMSB9O1xuICB9XG4gIC8qKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBjb252ZXJ0IGEgQ2FsbCB0byBhbiBhcnJheSBvZiBVaW50OEFycmF5LlxuICAgKiBAcGFyYW0ge0NhbGx9IGNhbGwgQSBDYWxsIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXlbXX0gQ2FsbCBlbmNvZGVkIGluIGFuIGFycmF5IG9mIFVpbnQ4QXJyYXkgKGVhY2ggY29udGFpbmluZyA3IHUyNTYpLlxuICAgKi9cbiAgZW5jb2RlQ2FsbChjYWxsKSB7XG4gICAgY29uc3QgdG9CdWYgPSB0aGlzLmNvbnZlcnRCblRvTGVkZ2VyKGNhbGwuY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBzZWxlY3RvckJ1ZiA9IGhleFRvQnl0ZXMoYWRkQWRkcmVzc1BhZGRpbmcoZ2V0U2VsZWN0b3IoY2FsbC5lbnRyeXBvaW50KSkpO1xuICAgIGxldCBjYWxsZGF0YUJ1ZiA9IG5ldyBVaW50OEFycmF5KFtdKTtcbiAgICBpZiAoY2FsbC5jYWxsZGF0YSkge1xuICAgICAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY2FsbC5jYWxsZGF0YSk7XG4gICAgICBjYWxsZGF0YUJ1ZiA9IGNvbmNhdGVuYXRlQXJyYXlCdWZmZXIoXG4gICAgICAgIGNvbXBpbGVkQ2FsbGRhdGEubWFwKChwYXJhbWV0ZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBhID0gdGhpcy5jb252ZXJ0Qm5Ub0xlZGdlcihwYXJhbWV0ZXIpO1xuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgY2FsbEJ1ZiA9IGNvbmNhdGVuYXRlQXJyYXlCdWZmZXIoW3RvQnVmLCBzZWxlY3RvckJ1ZiwgY2FsbGRhdGFCdWZdKTtcbiAgICBjb25zdCBjYWxsZGF0YXMgPSBbXTtcbiAgICBjb25zdCBjaHVua1NpemUgPSA3ICogMzI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsQnVmLmxlbmd0aDsgaSArPSBjaHVua1NpemUpXG4gICAgICBjYWxsZGF0YXMucHVzaChjYWxsQnVmLnN1YmFycmF5KGksIGkgKyBjaHVua1NpemUpKTtcbiAgICByZXR1cm4gY2FsbGRhdGFzO1xuICB9XG4gIC8qKlxuICAgKiBBc2sgdGhlIExlZGdlciBOYW5vIHRvIGRpc3BsYXkgYW5kIHNpZ24gYSBTdGFya25ldCBWMSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtWMkludm9jYXRpb25zU2lnbmVyRGV0YWlsc30gdHhEZXRhaWxzIEFsbCB0aGUgZGV0YWlscyBuZWVkZWQgZm9yIGEgdHhWMS5cbiAgICogQHBhcmFtIHtDYWxsW119IGNhbGxzIGFycmF5IG9mIFN0YXJrbmV0IGludm9jYXRpb25zXG4gICAqIEByZXR1cm5zIGFuIG9iamVjdCBpbmNsdWRpbmcgdGhlIHRyYW5zYWN0aW9uIEhhc2ggYW5kIHRoZSBzaWduYXR1cmVcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBjYWxsczogQ2FsbFtdID0gW3tjb250cmFjdEFkZHJlc3M6IFwiMHgwNDlkMzY1NzBkNGU0NmY0OGU5OTY3NGJkM2ZjYzg0NjQ0ZGRkNmI5NmY3Yzc0MWIxNTYyYjgyZjllMDA0ZGM3XCIsXG4gICAqICAgICAgZW50cnlwb2ludDogXCJ0cmFuc2ZlclwiLFxuICAgKiAgICAgIGNhbGxkYXRhOltcIjB4MTFmNWZjMmE5MmFjMDM0MzRhNzkzN2ZlOTgyZjVlNTI5M2I2NWFkNDM4YTk4OWM1Yjc4ZmI4ZjA0YTEyMDE2XCIsXG4gICAqICAgICAgICBcIjB4OTE4NGU3MmEwMDBcIiwgXCIweDBcIl19XTtcbiAgICogY29uc3QgdHhEZXQ6IFYySW52b2NhdGlvbnNTaWduZXJEZXRhaWxzID0ge1xuICAgKiAgICB3YWxsZXRBZGRyZXNzOiB0eERldGFpbHMuYWNjb3VudEFkZHJlc3MsXG4gICAqICAgIGNoYWluSWQ6IGNvbnN0YW50cy5TdGFya25ldENoYWluSWQuU05fTUFJTixcbiAgICogICAgY2Fpcm9WZXJzaW9uOiBcIjFcIiwgbWF4RmVlOiB0eERldGFpbHMubWF4X2ZlZSxcbiAgICogICAgbm9uY2U6IHR4RGV0YWlscy5ub25jZSwgdmVyc2lvbjogXCIweDFcIlxuICAgKiAgfTtcbiAgICogY29uc3QgcmVzID0gYXdhaXQgbXlMZWRnZXJTaWduZXIuc2lnblR4VjEodHhEZXQsIGNhbGxzKTtcbiAgICogLy8gcmVzID0ge2hhc2g6XG4gICAqIC8vICAgc2lnbmF0dXJlOlxuICAgKiAvLyB9XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgc2lnblR4VjEodHhEZXRhaWxzLCBjYWxscykge1xuICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydGVyLnNlbmQoTnVtYmVyKFwiMHg1YVwiKSwgNCwgMCwgMCwgQnVmZmVyLmZyb20odGhpcy5wYXRoQnVmZmVyKSk7XG4gICAgY29uc3QgYWNjb3VudEFkZHJlc3NCdWYgPSB0aGlzLmNvbnZlcnRCblRvTGVkZ2VyKHR4RGV0YWlscy53YWxsZXRBZGRyZXNzKTtcbiAgICBjb25zdCBtYXhGZWVCdWYgPSB0aGlzLmNvbnZlcnRCblRvTGVkZ2VyKHR4RGV0YWlscy5tYXhGZWUpO1xuICAgIGNvbnN0IGNoYWluSWRCdWYgPSB0aGlzLmNvbnZlcnRCblRvTGVkZ2VyKHR4RGV0YWlscy5jaGFpbklkKTtcbiAgICBjb25zdCBub25jZUJ1ZiA9IHRoaXMuY29udmVydEJuVG9MZWRnZXIodHhEZXRhaWxzLm5vbmNlKTtcbiAgICBjb25zdCBkYXRhQnVmID0gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcihbXG4gICAgICBhY2NvdW50QWRkcmVzc0J1ZixcbiAgICAgIG1heEZlZUJ1ZixcbiAgICAgIGNoYWluSWRCdWYsXG4gICAgICBub25jZUJ1ZlxuICAgIF0pO1xuICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydGVyLnNlbmQoTnVtYmVyKFwiMHg1YVwiKSwgNCwgMSwgMCwgQnVmZmVyLmZyb20oZGF0YUJ1ZikpO1xuICAgIGNvbnN0IG5iQ2FsbHNCdWYgPSB0aGlzLmNvbnZlcnRCblRvTGVkZ2VyKGNhbGxzLmxlbmd0aCk7XG4gICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0ZXIuc2VuZChOdW1iZXIoXCIweDVhXCIpLCA0LCAyLCAwLCBCdWZmZXIuZnJvbShuYkNhbGxzQnVmKSk7XG4gICAgbGV0IHJlc3BTaWduID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgZm9yIChjb25zdCBjYWxsIG9mIGNhbGxzKSB7XG4gICAgICBjb25zdCBjYWxsZGF0YXMgPSB0aGlzLmVuY29kZUNhbGwoY2FsbCk7XG4gICAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnRlci5zZW5kKE51bWJlcihcIjB4NWFcIiksIDQsIDMsIDAsIEJ1ZmZlci5mcm9tKGNhbGxkYXRhc1swXSkpO1xuICAgICAgaWYgKGNhbGxkYXRhcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNhbGxkYXRhcy5zbGljZSgxKS5mb3JFYWNoKGFzeW5jIChwYXJ0KSA9PiB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0ZXIuc2VuZChOdW1iZXIoXCIweDVhXCIpLCA0LCAzLCAxLCBCdWZmZXIuZnJvbShwYXJ0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmVzcFNpZ24gPSBhd2FpdCB0aGlzLl90cmFuc3BvcnRlci5zZW5kKE51bWJlcihcIjB4NWFcIiksIDQsIDMsIDIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZWNvZGVTaWduYXR1cmVMZWRnZXIocmVzcFNpZ24pO1xuICB9XG4gIC8qKlxuICAgKiBBc2sgdG8gdGhlIExlZGdlciBOYW5vIHRvIGRpc3BsYXkgYW5kIHNpZ24gYSBTdGFya25ldCBWMyB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtWM0ludm9jYXRpb25zU2lnbmVyRGV0YWlsc30gdHhEZXRhaWxzIEFsbCB0aGUgZGV0YWlscyBuZWVkZWQgZm9yIGEgdHhWMy5cbiAgICogQHBhcmFtIHtDYWxsW119IGNhbGxzIGFycmF5IG9mIFN0YXJrbmV0IGludm9jYXRpb25zXG4gICAqIEByZXR1cm5zIGFuIG9iamVjdCBpbmNsdWRpbmcgdGhlIHRyYW5zYWN0aW9uIEhhc2ggYW5kIHRoZSBzaWduYXR1cmVcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBjYWxsczogQ2FsbFtdID0gW3tjb250cmFjdEFkZHJlc3M6IFwiMHgwNDlkMzY1NzBkNGU0NmY0OGU5OTY3NGJkM2ZjYzg0NjQ0ZGRkNmI5NmY3Yzc0MWIxNTYyYjgyZjllMDA0ZGM3XCIsXG4gICAqICAgICAgZW50cnlwb2ludDogXCJ0cmFuc2ZlclwiLFxuICAgKiAgICAgIGNhbGxkYXRhOltcIjB4MTFmNWZjMmE5MmFjMDM0MzRhNzkzN2ZlOTgyZjVlNTI5M2I2NWFkNDM4YTk4OWM1Yjc4ZmI4ZjA0YTEyMDE2XCIsXG4gICAqICAgICAgICBcIjB4OTE4NGU3MmEwMDBcIiwgXCIweDBcIl19XTtcbiAgICogY29uc3QgdHhEZXRhaWxzVjM6IFYzSW52b2NhdGlvbnNTaWduZXJEZXRhaWxzID0ge1xuICAgKiAgIGNoYWluSWQ6IGNvbnN0YW50cy5TdGFya25ldENoYWluSWQuU05fTUFJTixcbiAgICogICBub25jZTogXCIyOFwiLCBhY2NvdW50RGVwbG95bWVudERhdGE6IFtdLFxuICAgKiAgIHBheW1hc3RlckRhdGE6IFtdLCBjYWlyb1ZlcnNpb246IFwiMVwiLFxuICAgKiAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBcIkwxXCIsIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IFwiTDFcIixcbiAgICogICByZXNvdXJjZUJvdW5kczoge1xuICAgKiAgICAgbDFfZ2FzOiB7IG1heF9hbW91bnQ6IFwiMHgyYTAwXCIsIG1heF9wcmljZV9wZXJfdW5pdDogXCIweDVjMDAwMDBcIlxuICAgKiAgICAgfSxcbiAgICogICAgIGwyX2dhczogeyBtYXhfYW1vdW50OiBcIjB4MDBcIiwgbWF4X3ByaWNlX3Blcl91bml0OiBcIjB4MDBcIn0sXG4gICAqICAgfSwgdGlwOiAwLCB2ZXJzaW9uOiBcIjB4M1wiLCB3YWxsZXRBZGRyZXNzOiBhY2NvdW50MC5hZGRyZXNzXG4gICAqICB9O1xuICAgKiBjb25zdCByZXMgPSBhd2FpdCBteUxlZGdlclNpZ25lci5zaWduVHhWMyh0eERldGFpbHNWMywgY2FsbHMpO1xuICAgKiAvLyByZXMgPSB7aGFzaDpcbiAgICogLy8gICBzaWduYXR1cmU6XG4gICAqIC8vIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBzaWduVHhWMyh0eERldGFpbHMsIGNhbGxzKSB7XG4gICAgYXNzZXJ0KHR4RGV0YWlscy5wYXltYXN0ZXJEYXRhLmxlbmd0aCA8PSA3LCBcIlBheW1hc3RlciBkYXRhIGluY2x1ZGVzIG1vcmUgdGhhbiA3IGl0ZW1zLlwiKTtcbiAgICBhc3NlcnQoXG4gICAgICB0eERldGFpbHMuYWNjb3VudERlcGxveW1lbnREYXRhLmxlbmd0aCA8PSA3LFxuICAgICAgXCJhY2NvdW50RGVwbG95bWVudERhdGEgaW5jbHVkZXMgbW9yZSB0aGFuIDcgaXRlbXNcIlxuICAgICk7XG4gICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0ZXIuc2VuZChOdW1iZXIoXCIweDVhXCIpLCAzLCAwLCAwLCBCdWZmZXIuZnJvbSh0aGlzLnBhdGhCdWZmZXIpKTtcbiAgICBjb25zdCBhY2NvdW50QWRkcmVzc0J1ZiA9IHRoaXMuY29udmVydEJuVG9MZWRnZXIodHhEZXRhaWxzLndhbGxldEFkZHJlc3MpO1xuICAgIGNvbnN0IHRpcEJ1ZiA9IHRoaXMuY29udmVydEJuVG9MZWRnZXIodHhEZXRhaWxzLnRpcCk7XG4gICAgY29uc3QgY2hhaW5JZEJ1ZiA9IHRoaXMuY29udmVydEJuVG9MZWRnZXIodHhEZXRhaWxzLmNoYWluSWQpO1xuICAgIGNvbnN0IG5vbmNlQnVmID0gdGhpcy5jb252ZXJ0Qm5Ub0xlZGdlcih0eERldGFpbHMubm9uY2UpO1xuICAgIGNvbnN0IGRBTW9kZUhhc2hCdWYgPSB0aGlzLmNvbnZlcnRCblRvTGVkZ2VyKFxuICAgICAgaGFzaERBTW9kZShcbiAgICAgICAgdHhEZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUgPT09IGFwaV9leHBvcnRzLkVEYXRhQXZhaWxhYmlsaXR5TW9kZS5MMSA/IGFwaV9leHBvcnRzLkVEQU1vZGUuTDEgOiBhcGlfZXhwb3J0cy5FREFNb2RlLkwyLFxuICAgICAgICB0eERldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUgPT09IGFwaV9leHBvcnRzLkVEYXRhQXZhaWxhYmlsaXR5TW9kZS5MMSA/IGFwaV9leHBvcnRzLkVEQU1vZGUuTDEgOiBhcGlfZXhwb3J0cy5FREFNb2RlLkwyXG4gICAgICApXG4gICAgKTtcbiAgICBjb25zdCBsMV9nYXNCdWYgPSB0aGlzLmNvbnZlcnRCblRvTGVkZ2VyKGVuY29kZVJlc291cmNlQm91bmRzTDEodHhEZXRhaWxzLnJlc291cmNlQm91bmRzKSk7XG4gICAgY29uc3QgbDJfZ2FzQnVmID0gdGhpcy5jb252ZXJ0Qm5Ub0xlZGdlcihlbmNvZGVSZXNvdXJjZUJvdW5kc0wyKHR4RGV0YWlscy5yZXNvdXJjZUJvdW5kcykpO1xuICAgIGNvbnN0IGRhdGFCdWYgPSBjb25jYXRlbmF0ZUFycmF5QnVmZmVyKFtcbiAgICAgIGFjY291bnRBZGRyZXNzQnVmLFxuICAgICAgdGlwQnVmLFxuICAgICAgbDFfZ2FzQnVmLFxuICAgICAgbDJfZ2FzQnVmLFxuICAgICAgY2hhaW5JZEJ1ZixcbiAgICAgIG5vbmNlQnVmLFxuICAgICAgZEFNb2RlSGFzaEJ1ZlxuICAgIF0pO1xuICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydGVyLnNlbmQoTnVtYmVyKFwiMHg1YVwiKSwgMywgMSwgMCwgQnVmZmVyLmZyb20oZGF0YUJ1ZikpO1xuICAgIGNvbnN0IHBheW1hc3RlckJ1ZiA9IGNvbmNhdGVuYXRlQXJyYXlCdWZmZXIoXG4gICAgICB0eERldGFpbHMucGF5bWFzdGVyRGF0YS5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmNvbnZlcnRCblRvTGVkZ2VyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9KVxuICAgICk7XG4gICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0ZXIuc2VuZChOdW1iZXIoXCIweDVhXCIpLCAzLCAyLCAwLCBCdWZmZXIuZnJvbShwYXltYXN0ZXJCdWYpKTtcbiAgICBjb25zdCBhY2NvdW50RGVwbG95RGF0YUJ1ZiA9IGNvbmNhdGVuYXRlQXJyYXlCdWZmZXIoXG4gICAgICB0eERldGFpbHMucGF5bWFzdGVyRGF0YS5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmNvbnZlcnRCblRvTGVkZ2VyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9KVxuICAgICk7XG4gICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0ZXIuc2VuZChOdW1iZXIoXCIweDVhXCIpLCAzLCAzLCAwLCBCdWZmZXIuZnJvbShhY2NvdW50RGVwbG95RGF0YUJ1ZikpO1xuICAgIGNvbnN0IG5iQ2FsbHNCdWYgPSB0aGlzLmNvbnZlcnRCblRvTGVkZ2VyKGNhbGxzLmxlbmd0aCk7XG4gICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0ZXIuc2VuZChOdW1iZXIoXCIweDVhXCIpLCAzLCA0LCAwLCBCdWZmZXIuZnJvbShuYkNhbGxzQnVmKSk7XG4gICAgbGV0IHJlc3BTaWduID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgZm9yIChjb25zdCBjYWxsIG9mIGNhbGxzKSB7XG4gICAgICBjb25zdCBjYWxsZGF0YXMgPSB0aGlzLmVuY29kZUNhbGwoY2FsbCk7XG4gICAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnRlci5zZW5kKE51bWJlcihcIjB4NWFcIiksIDMsIDUsIDAsIEJ1ZmZlci5mcm9tKGNhbGxkYXRhc1swXSkpO1xuICAgICAgaWYgKGNhbGxkYXRhcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNhbGxkYXRhcy5zbGljZSgxKS5mb3JFYWNoKGFzeW5jIChwYXJ0KSA9PiB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0ZXIuc2VuZChOdW1iZXIoXCIweDVhXCIpLCAzLCA1LCAxLCBCdWZmZXIuZnJvbShwYXJ0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmVzcFNpZ24gPSBhd2FpdCB0aGlzLl90cmFuc3BvcnRlci5zZW5kKE51bWJlcihcIjB4NWFcIiksIDMsIDUsIDIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZWNvZGVTaWduYXR1cmVMZWRnZXIocmVzcFNpZ24pO1xuICB9XG4gIC8qKlxuICAgKiBBc2sgdGhlIExlZGdlciBOYW5vIHRvIGRpc3BsYXkgYW5kIHNpZ24gYSBTdGFya25ldCBWMSBhY2NvdW50IGRlcGxveW1lbnQuXG4gICAqIEBwYXJhbSB7VjJEZXBsb3lBY2NvdW50U2lnbmVyRGV0YWlsc30gZGVwbG95QWNjb3VudERldGFpbCBBbGwgdGhlIGRldGFpbHMgbmVlZGVkIGZvciBhIFYxIGRlcGxveSBhY2NvdW50LlxuICAgKiBAcmV0dXJucyBhbiBvYmplY3QgaW5jbHVkaW5nIHRoZSB0cmFuc2FjdGlvbiBIYXNoIGFuZCB0aGUgc2lnbmF0dXJlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgZGVwbG95RGF0YTogVjJEZXBsb3lBY2NvdW50U2lnbmVyRGV0YWlscyA9XG4gICAqIHtcbiAgICogIHRpcDogMCwgcGF5bWFzdGVyRGF0YTogW10sIGFjY291bnREZXBsb3ltZW50RGF0YTogW10sXG4gICAqICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiAnTDEnLCBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogJ0wxJyxcbiAgICogIHJlc291cmNlQm91bmRzOiB7XG4gICAqICAgIGwyX2dhczogeyBtYXhfYW1vdW50OiAnMHgwJywgbWF4X3ByaWNlX3Blcl91bml0OiAnMHgwJyB9LFxuICAgKiAgICBsMV9nYXM6IHsgbWF4X2Ftb3VudDogJzB4MCcsIG1heF9wcmljZV9wZXJfdW5pdDogJzB4MCcgfVxuICAgKiAgIH0sXG4gICAqICBjbGFzc0hhc2g6ICcweDU0MGQ3ZjVlYzdlY2YzMTdlNjhkNDg1NjQ5MzRjYjk5MjU5NzgxYjFlZTNjZWRiYmMzN2VjNTMzN2Y4ZTY4OCcsXG4gICAqICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBbXG4gICAqICAgICc4OTgzMjY5NjAwMDg4OTY2Mjk5OTc2NzAyMjc1MDg1MTg4NjY3NDA3NzgyMTI5Mzg5MzE4NzkwMDY2NDU3MzM3MjE0NTQxMDc1NSdcbiAgICogIF0sXG4gICAqICBjb250cmFjdEFkZHJlc3M6ICcweDMyYzYwZmJhNjRlYjk2ODMxZDA2NGJiYjIzMTkzNzViN2I3MzgxNTQzYWJlNjZkYTg3MmU0MzQ0YmNkNzJhMCcsXG4gICAqICBhZGRyZXNzU2FsdDogJzB4MDAzMmQ3ZWZlMmE5MjMyZjliNDYzZTcyMDZjNjhmZGVhNGFlYjEzZmVjMGNiMzA4YzZiYTFkMTk3ZDU5MjJjMycsXG4gICAqICBjaGFpbklkOiAnMHg1MzRlNWY1MzQ1NTA0ZjRjNDk0MScsIG1heEZlZTogNTUwNTAwMDAwMDAwMDBuLFxuICAgKiAgdmVyc2lvbjogJzB4MScsIG5vbmNlOiAwblxuICAgKn1cbiAgICogY29uc3QgcmVzID0gYXdhaXQgbXlMZWRnZXJTaWduZXIuc2lnbkRlcGxveUFjY291bnRWMShkZXBsb3lEYXRhKTtcbiAgICogLy8gcmVzID0ge2hhc2g6XG4gICAqIC8vICAgc2lnbmF0dXJlOlxuICAgKiAvLyB9XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgc2lnbkRlcGxveUFjY291bnRWMShkZXBsb3lBY2NvdW50RGV0YWlsKSB7XG4gICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0ZXIuc2VuZChOdW1iZXIoXCIweDVhXCIpLCA2LCAwLCAwLCBCdWZmZXIuZnJvbSh0aGlzLnBhdGhCdWZmZXIpKTtcbiAgICBjb25zdCBhY2NvdW50QWRkcmVzc0J1ZiA9IHRoaXMuY29udmVydEJuVG9MZWRnZXIoXG4gICAgICBkZXBsb3lBY2NvdW50RGV0YWlsLmNvbnRyYWN0QWRkcmVzc1xuICAgICk7XG4gICAgY29uc3QgY2xhc3NIYXNoQnVmID0gdGhpcy5jb252ZXJ0Qm5Ub0xlZGdlcihkZXBsb3lBY2NvdW50RGV0YWlsLmNsYXNzSGFzaCk7XG4gICAgY29uc3Qgc2FsdEJ1ZiA9IHRoaXMuY29udmVydEJuVG9MZWRnZXIoZGVwbG95QWNjb3VudERldGFpbC5hZGRyZXNzU2FsdCk7XG4gICAgY29uc3QgY2hhaW5JZEJ1ZiA9IHRoaXMuY29udmVydEJuVG9MZWRnZXIoZGVwbG95QWNjb3VudERldGFpbC5jaGFpbklkKTtcbiAgICBjb25zdCBub25jZUJ1ZiA9IHRoaXMuY29udmVydEJuVG9MZWRnZXIoZGVwbG95QWNjb3VudERldGFpbC5ub25jZSk7XG4gICAgY29uc3QgZGF0YUJ1ZiA9IGNvbmNhdGVuYXRlQXJyYXlCdWZmZXIoW1xuICAgICAgYWNjb3VudEFkZHJlc3NCdWYsXG4gICAgICBjbGFzc0hhc2hCdWYsXG4gICAgICBzYWx0QnVmLFxuICAgICAgY2hhaW5JZEJ1ZixcbiAgICAgIG5vbmNlQnVmXG4gICAgXSk7XG4gICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0ZXIuc2VuZChOdW1iZXIoXCIweDVhXCIpLCA2LCAxLCAwLCBCdWZmZXIuZnJvbShkYXRhQnVmKSk7XG4gICAgY29uc3QgbWF4RnJlZUJ1ZiA9IHRoaXMuY29udmVydEJuVG9MZWRnZXIoZGVwbG95QWNjb3VudERldGFpbC5tYXhGZWUpO1xuICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydGVyLnNlbmQoTnVtYmVyKFwiMHg1YVwiKSwgNiwgMiwgMCwgQnVmZmVyLmZyb20obWF4RnJlZUJ1ZikpO1xuICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3IgPSBDYWxsRGF0YS5jb21waWxlKGRlcGxveUFjY291bnREZXRhaWwuY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgY29uc3QgY29uc3RydWN0b3JMZW5ndGhCdWYgPSB0aGlzLmNvbnZlcnRCblRvTGVkZ2VyKGNvbXBpbGVkQ29uc3RydWN0b3IubGVuZ3RoKTtcbiAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnRlci5zZW5kKE51bWJlcihcIjB4NWFcIiksIDYsIDMsIDAsIEJ1ZmZlci5mcm9tKGNvbnN0cnVjdG9yTGVuZ3RoQnVmKSk7XG4gICAgY29uc3QgY29uc3RydWN0b3JCdWYgPSBjb25jYXRlbmF0ZUFycmF5QnVmZmVyKFxuICAgICAgY29tcGlsZWRDb25zdHJ1Y3Rvci5tYXAoKHBhcmFtZXRlcikgPT4ge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5jb252ZXJ0Qm5Ub0xlZGdlcihwYXJhbWV0ZXIpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBjb25zdCBjb25zdHJ1Y3RvckNodW5rcyA9IFtdO1xuICAgIGNvbnN0IGNodW5rU2l6ZSA9IDcgKiAzMjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnN0cnVjdG9yQnVmLmxlbmd0aDsgaSArPSBjaHVua1NpemUpXG4gICAgICBjb25zdHJ1Y3RvckNodW5rcy5wdXNoKGNvbnN0cnVjdG9yQnVmLnN1YmFycmF5KGksIGkgKyBjaHVua1NpemUpKTtcbiAgICBsZXQgcmVzcFNpZ24gPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNvbnN0cnVjdG9yQ2h1bmtzKSB7XG4gICAgICByZXNwU2lnbiA9IGF3YWl0IHRoaXMuX3RyYW5zcG9ydGVyLnNlbmQoTnVtYmVyKFwiMHg1YVwiKSwgNiwgNCwgMCwgQnVmZmVyLmZyb20oY2h1bmspKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlU2lnbmF0dXJlTGVkZ2VyKHJlc3BTaWduKTtcbiAgfVxuICAvKipcbiAgICpBc2sgdGhlIExlZGdlciBOYW5vIHRvIGRpc3BsYXkgYW5kIHNpZ24gYSBTdGFya25ldCBWMyBhY2NvdW50IGRlcGxveW1lbnQuXG4gICAqIEBwYXJhbSB7VjNEZXBsb3lBY2NvdW50U2lnbmVyRGV0YWlsc30gZGVwbG95QWNjb3VudERldGFpbCBBbGwgdGhlIGRldGFpbHMgbmVlZGVkIGZvciBhIFYzIGRlcGxveSBhY2NvdW50LlxuICAgKiBAcmV0dXJucyBhbiBvYmplY3QgaW5jbHVkaW5nIHRoZSB0cmFuc2FjdGlvbiBIYXNoIGFuZCB0aGUgc2lnbmF0dXJlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgZGVwbG95RGF0YTogVjNEZXBsb3lBY2NvdW50U2lnbmVyRGV0YWlscyA9XG4gICAqIHtcbiAgICogIHRpcDogMCwgcGF5bWFzdGVyRGF0YTogW10sIGFjY291bnREZXBsb3ltZW50RGF0YTogW10sXG4gICAqICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiAnTDEnLCBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogJ0wxJyxcbiAgICogIHJlc291cmNlQm91bmRzOiB7XG4gICAqICAgIGwyX2dhczogeyBtYXhfYW1vdW50OiAnMHgwJywgbWF4X3ByaWNlX3Blcl91bml0OiAnMHgwJyB9LFxuICAgKiAgICBsMV9nYXM6IHsgbWF4X2Ftb3VudDogJzB4MjI2JywgbWF4X3ByaWNlX3Blcl91bml0OiAnMHgyMmVjYjI1YzAwJyB9XG4gICAqICAgfSxcbiAgICogIGNsYXNzSGFzaDogJzB4NTQwZDdmNWVjN2VjZjMxN2U2OGQ0ODU2NDkzNGNiOTkyNTk3ODFiMWVlM2NlZGJiYzM3ZWM1MzM3ZjhlNjg4JyxcbiAgICogIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IFtcbiAgICogICAgJzM1NzExMjUxMjc3NDQ4MzA0NDU1NzIyODU1NzQ0Njk4NDI1Nzk0MDEyNTU0MzE4MjE2NDQ4MjI3MjY4NTc0NzE0NjM2NzIxOTk2MjEnXG4gICAqICBdLFxuICAgKiAgY29udHJhY3RBZGRyZXNzOiAnMHg0Y2EwNjJhZGQxY2YxMmExMDdiZTExMDdhZjE3OTgxY2Y2ZTU0NGEyNGQ5ODc2OTMyMzBlYTQ4MWQzZDVlMzQnLFxuICAgKiAgYWRkcmVzc1NhbHQ6ICcweDA3ZTUyZjY4ZTMxNjBlMWVmNjk4MjExY2RmNmQzNzkyMzY4ZmUzNDdlN2UyZDRhOGFjZTE0ZDliMjQ4ZjM5YzUnLFxuICAgKiAgY2hhaW5JZDogJzB4NTM0ZTVmNTM0NTUwNGY0YzQ5NDEnLCBtYXhGZWU6IDAsXG4gICAqICB2ZXJzaW9uOiAnMHgzJywgbm9uY2U6IDBuXG4gICAqfVxuICAgKiBjb25zdCByZXMgPSBhd2FpdCBteUxlZGdlclNpZ25lci5zaWduRGVwbG95QWNjb3VudFYzKGRlcGxveURhdGEpO1xuICAgKiAvLyByZXMgPSB7aGFzaDpcbiAgICogLy8gICBzaWduYXR1cmU6XG4gICAqIC8vIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBzaWduRGVwbG95QWNjb3VudFYzKGRlcGxveUFjY291bnREZXRhaWwpIHtcbiAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnRlci5zZW5kKE51bWJlcihcIjB4NWFcIiksIDUsIDAsIDAsIEJ1ZmZlci5mcm9tKHRoaXMucGF0aEJ1ZmZlcikpO1xuICAgIGNvbnN0IGFjY291bnRBZGRyZXNzQnVmID0gdGhpcy5jb252ZXJ0Qm5Ub0xlZGdlcihcbiAgICAgIGRlcGxveUFjY291bnREZXRhaWwuY29udHJhY3RBZGRyZXNzXG4gICAgKTtcbiAgICBjb25zdCBjaGFpbklkQnVmID0gdGhpcy5jb252ZXJ0Qm5Ub0xlZGdlcihkZXBsb3lBY2NvdW50RGV0YWlsLmNoYWluSWQpO1xuICAgIGNvbnN0IG5vbmNlQnVmID0gdGhpcy5jb252ZXJ0Qm5Ub0xlZGdlcihkZXBsb3lBY2NvdW50RGV0YWlsLm5vbmNlKTtcbiAgICBjb25zdCBkQU1vZGVIYXNoQnVmID0gdGhpcy5jb252ZXJ0Qm5Ub0xlZGdlcihcbiAgICAgIGhhc2hEQU1vZGUoXG4gICAgICAgIGRlcGxveUFjY291bnREZXRhaWwubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSA9PT0gYXBpX2V4cG9ydHMuRURhdGFBdmFpbGFiaWxpdHlNb2RlLkwxID8gYXBpX2V4cG9ydHMuRURBTW9kZS5MMSA6IGFwaV9leHBvcnRzLkVEQU1vZGUuTDIsXG4gICAgICAgIGRlcGxveUFjY291bnREZXRhaWwuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUgPT09IGFwaV9leHBvcnRzLkVEYXRhQXZhaWxhYmlsaXR5TW9kZS5MMSA/IGFwaV9leHBvcnRzLkVEQU1vZGUuTDEgOiBhcGlfZXhwb3J0cy5FREFNb2RlLkwyXG4gICAgICApXG4gICAgKTtcbiAgICBjb25zdCBjbGFzc0hhc2hCdWYgPSB0aGlzLmNvbnZlcnRCblRvTGVkZ2VyKGRlcGxveUFjY291bnREZXRhaWwuY2xhc3NIYXNoKTtcbiAgICBjb25zdCBzYWx0QnVmID0gdGhpcy5jb252ZXJ0Qm5Ub0xlZGdlcihkZXBsb3lBY2NvdW50RGV0YWlsLmFkZHJlc3NTYWx0KTtcbiAgICBjb25zdCBkYXRhQnVmID0gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcihbXG4gICAgICBhY2NvdW50QWRkcmVzc0J1ZixcbiAgICAgIGNoYWluSWRCdWYsXG4gICAgICBub25jZUJ1ZixcbiAgICAgIGRBTW9kZUhhc2hCdWYsXG4gICAgICBjbGFzc0hhc2hCdWYsXG4gICAgICBzYWx0QnVmXG4gICAgXSk7XG4gICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0ZXIuc2VuZChOdW1iZXIoXCIweDVhXCIpLCA1LCAxLCAwLCBCdWZmZXIuZnJvbShkYXRhQnVmKSk7XG4gICAgY29uc3QgdGlwQnVmID0gdGhpcy5jb252ZXJ0Qm5Ub0xlZGdlcihkZXBsb3lBY2NvdW50RGV0YWlsLnRpcCk7XG4gICAgY29uc3QgbDFfZ2FzQnVmID0gdGhpcy5jb252ZXJ0Qm5Ub0xlZGdlcihcbiAgICAgIGVuY29kZVJlc291cmNlQm91bmRzTDEoZGVwbG95QWNjb3VudERldGFpbC5yZXNvdXJjZUJvdW5kcylcbiAgICApO1xuICAgIGNvbnN0IGwyX2dhc0J1ZiA9IHRoaXMuY29udmVydEJuVG9MZWRnZXIoXG4gICAgICBlbmNvZGVSZXNvdXJjZUJvdW5kc0wyKGRlcGxveUFjY291bnREZXRhaWwucmVzb3VyY2VCb3VuZHMpXG4gICAgKTtcbiAgICBjb25zdCBmZWVCdWYgPSBjb25jYXRlbmF0ZUFycmF5QnVmZmVyKFt0aXBCdWYsIGwxX2dhc0J1ZiwgbDJfZ2FzQnVmXSk7XG4gICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0ZXIuc2VuZChOdW1iZXIoXCIweDVhXCIpLCA1LCAyLCAwLCBCdWZmZXIuZnJvbShmZWVCdWYpKTtcbiAgICBjb25zdCBwYXltYXN0ZXJCdWYgPSBjb25jYXRlbmF0ZUFycmF5QnVmZmVyKFxuICAgICAgZGVwbG95QWNjb3VudERldGFpbC5wYXltYXN0ZXJEYXRhLm1hcCgodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuY29udmVydEJuVG9MZWRnZXIodmFsdWUpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnRlci5zZW5kKE51bWJlcihcIjB4NWFcIiksIDUsIDMsIDAsIEJ1ZmZlci5mcm9tKHBheW1hc3RlckJ1ZikpO1xuICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3IgPSBDYWxsRGF0YS5jb21waWxlKGRlcGxveUFjY291bnREZXRhaWwuY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgY29uc3QgY29uc3RydWN0b3JMZW5ndGhCdWYgPSB0aGlzLmNvbnZlcnRCblRvTGVkZ2VyKGNvbXBpbGVkQ29uc3RydWN0b3IubGVuZ3RoKTtcbiAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnRlci5zZW5kKE51bWJlcihcIjB4NWFcIiksIDUsIDQsIDAsIEJ1ZmZlci5mcm9tKGNvbnN0cnVjdG9yTGVuZ3RoQnVmKSk7XG4gICAgY29uc3QgY29uc3RydWN0b3JCdWYgPSBjb25jYXRlbmF0ZUFycmF5QnVmZmVyKFxuICAgICAgY29tcGlsZWRDb25zdHJ1Y3Rvci5tYXAoKHBhcmFtZXRlcikgPT4ge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5jb252ZXJ0Qm5Ub0xlZGdlcihwYXJhbWV0ZXIpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBjb25zdCBjb25zdHJ1Y3RvckNodW5rcyA9IFtdO1xuICAgIGNvbnN0IGNodW5rU2l6ZSA9IDcgKiAzMjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnN0cnVjdG9yQnVmLmxlbmd0aDsgaSArPSBjaHVua1NpemUpXG4gICAgICBjb25zdHJ1Y3RvckNodW5rcy5wdXNoKGNvbnN0cnVjdG9yQnVmLnN1YmFycmF5KGksIGkgKyBjaHVua1NpemUpKTtcbiAgICBsZXQgcmVzcFNpZ24gPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNvbnN0cnVjdG9yQ2h1bmtzKSB7XG4gICAgICByZXNwU2lnbiA9IGF3YWl0IHRoaXMuX3RyYW5zcG9ydGVyLnNlbmQoTnVtYmVyKFwiMHg1YVwiKSwgNSwgNSwgMCwgQnVmZmVyLmZyb20oY2h1bmspKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlU2lnbmF0dXJlTGVkZ2VyKHJlc3BTaWduKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldExlZGdlclBhdGhCdWZmZXIyMjEoYWNjb3VudElkLCBhcHBsaWNhdGlvbk5hbWUgPSBcIkxlZGdlcldcIikge1xuICBjb25zdCBwYXRoMGJ1ZmYgPSBuZXcgVWludDhBcnJheShbSEFSREVOSU5HX0JZVEUsIDAsIDEwLCA4NV0pO1xuICBjb25zdCBwYXRoMWJ1ZmYgPSBuZXcgVWludDhBcnJheShbNzEgfCBIQVJERU5JTkdfQllURSwgNjUsIDIzMywgMjAxXSk7XG4gIGNvbnN0IHBhdGgyQmFzZSA9IGFwcGxpY2F0aW9uTmFtZSA9PT0gXCJMZWRnZXJXXCIgPyBuZXcgVWludDhBcnJheShbNDMsIDIwNiwgMjMxLCAyMTldKSA6IHN0cmluZ1RvU2hhMjU2VG9BcnJheUJ1ZmY0KGFwcGxpY2F0aW9uTmFtZSk7XG4gIGNvbnN0IHBhdGgyYnVmZiA9IGNvbmNhdGVuYXRlQXJyYXlCdWZmZXIoW1xuICAgIG5ldyBVaW50OEFycmF5KFtwYXRoMkJhc2VbMF0gfCBIQVJERU5JTkdfQllURV0pLFxuICAgIHBhdGgyQmFzZS5zdWJhcnJheSgxKVxuICBdKTtcbiAgY29uc3QgcGF0aDNidWZmID0gbmV3IFVpbnQ4QXJyYXkoW0hBUkRFTklOR19CWVRFLCAwLCAwLCAwXSk7XG4gIGNvbnN0IGhleCA9IHRvSGV4KEJpZ0ludChhY2NvdW50SWQpIHwgSEFSREVOSU5HXzRCWVRFUyk7XG4gIGNvbnN0IHBhZGRlZCA9IGFkZEhleFByZWZpeChyZW1vdmVIZXhQcmVmaXgoaGV4KS5wYWRTdGFydCg4LCBcIjBcIikpO1xuICBjb25zdCBwYXRoNGJ1ZmYgPSBoZXhUb0J5dGVzKHBhZGRlZCk7XG4gIGNvbnN0IHBhdGg1YnVmZiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAwXSk7XG4gIGNvbnN0IHBhdGhCdWZmID0gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcihbXG4gICAgcGF0aDBidWZmLFxuICAgIHBhdGgxYnVmZixcbiAgICBwYXRoMmJ1ZmYsXG4gICAgcGF0aDNidWZmLFxuICAgIHBhdGg0YnVmZixcbiAgICBwYXRoNWJ1ZmZcbiAgXSk7XG4gIHJldHVybiBwYXRoQnVmZjtcbn1cblxuLy8gc3JjL3V0aWxzL2V2ZW50cy9pbmRleC50c1xudmFyIGV2ZW50c19leHBvcnRzID0ge307XG5fX2V4cG9ydChldmVudHNfZXhwb3J0cywge1xuICBnZXRBYmlFdmVudHM6ICgpID0+IGdldEFiaUV2ZW50cyxcbiAgaXNBYmlFdmVudDogKCkgPT4gaXNBYmlFdmVudCxcbiAgcGFyc2VFdmVudHM6ICgpID0+IHBhcnNlRXZlbnRzLFxuICBwYXJzZVVEQ0V2ZW50OiAoKSA9PiBwYXJzZVVEQ0V2ZW50XG59KTtcbmZ1bmN0aW9uIGlzQWJpRXZlbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QudHlwZSA9PT0gXCJldmVudFwiO1xufVxuZnVuY3Rpb24gZ2V0Q2Fpcm8wQWJpRXZlbnRzKGFiaSkge1xuICByZXR1cm4gYWJpLmZpbHRlcigoYWJpRW50cnkpID0+IGFiaUVudHJ5LnR5cGUgPT09IFwiZXZlbnRcIikucmVkdWNlKChhY2MsIGFiaUVudHJ5KSA9PiB7XG4gICAgY29uc3QgZW50cnlOYW1lID0gYWJpRW50cnkubmFtZTtcbiAgICBjb25zdCBhYmlFbnRyeU1vZCA9IHsgLi4uYWJpRW50cnkgfTtcbiAgICBhYmlFbnRyeU1vZC5uYW1lID0gZW50cnlOYW1lO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2MsXG4gICAgICBbYWRkSGV4UHJlZml4KHN0YXJrQ3VydmUua2VjY2FrKHV0ZjhUb0FycmF5KGVudHJ5TmFtZSkpLnRvU3RyaW5nKDE2KSldOiBhYmlFbnRyeU1vZFxuICAgIH07XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldENhaXJvMUFiaUV2ZW50cyhhYmkpIHtcbiAgY29uc3QgYWJpRXZlbnRzU3RydWN0cyA9IGFiaS5maWx0ZXIoKG9iaikgPT4gaXNBYmlFdmVudChvYmopICYmIG9iai5raW5kID09PSBcInN0cnVjdFwiKTtcbiAgY29uc3QgYWJpRXZlbnRzRW51bXMgPSBhYmkuZmlsdGVyKChvYmopID0+IGlzQWJpRXZlbnQob2JqKSAmJiBvYmoua2luZCA9PT0gXCJlbnVtXCIpO1xuICBjb25zdCBhYmlFdmVudHNEYXRhID0gYWJpRXZlbnRzU3RydWN0cy5yZWR1Y2UoKGFjYywgZXZlbnQpID0+IHtcbiAgICBsZXQgbmFtZUxpc3QgPSBbXTtcbiAgICBsZXQgeyBuYW1lIH0gPSBldmVudDtcbiAgICBsZXQgZmxhdCA9IGZhbHNlO1xuICAgIGNvbnN0IGZpbmROYW1lID0gKHZhcmlhbnQpID0+IHZhcmlhbnQudHlwZSA9PT0gbmFtZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgZXZlbnRFbnVtID0gYWJpRXZlbnRzRW51bXMuZmluZCgoZXZlbnRFKSA9PiBldmVudEUudmFyaWFudHMuc29tZShmaW5kTmFtZSkpO1xuICAgICAgaWYgKGlzVW5kZWZpbmVkKGV2ZW50RW51bSkpIGJyZWFrO1xuICAgICAgY29uc3QgdmFyaWFudCA9IGV2ZW50RW51bS52YXJpYW50cy5maW5kKGZpbmROYW1lKTtcbiAgICAgIG5hbWVMaXN0LnVuc2hpZnQodmFyaWFudC5uYW1lKTtcbiAgICAgIGlmICh2YXJpYW50LmtpbmQgPT09IFwiZmxhdFwiKSBmbGF0ID0gdHJ1ZTtcbiAgICAgIG5hbWUgPSBldmVudEVudW0ubmFtZTtcbiAgICB9XG4gICAgaWYgKG5hbWVMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5jb25zaXN0ZW5jeSBpbiBBQkkgZXZlbnRzIGRlZmluaXRpb24uXCIpO1xuICAgIH1cbiAgICBpZiAoZmxhdCkgbmFtZUxpc3QgPSBbbmFtZUxpc3RbbmFtZUxpc3QubGVuZ3RoIC0gMV1dO1xuICAgIGNvbnN0IGZpbmFsID0gbmFtZUxpc3QucG9wKCk7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgIFthZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoZmluYWwpKS50b1N0cmluZygxNikpXTogZXZlbnRcbiAgICB9O1xuICAgIHdoaWxlIChuYW1lTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIFthZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkobmFtZUxpc3QucG9wKCkpKS50b1N0cmluZygxNikpXTogcmVzdWx0XG4gICAgICB9O1xuICAgIH1cbiAgICByZXN1bHQgPSB7IC4uLnJlc3VsdCB9O1xuICAgIHJldHVybiBtZXJnZUFiaUV2ZW50cyhhY2MsIHJlc3VsdCk7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGFiaUV2ZW50c0RhdGE7XG59XG5mdW5jdGlvbiBnZXRBYmlFdmVudHMoYWJpKSB7XG4gIHJldHVybiBpc0NhaXJvMUFiaShhYmkpID8gZ2V0Q2Fpcm8xQWJpRXZlbnRzKGFiaSkgOiBnZXRDYWlybzBBYmlFdmVudHMoYWJpKTtcbn1cbmZ1bmN0aW9uIG1lcmdlQWJpRXZlbnRzKHRhcmdldCwgc291cmNlKSB7XG4gIGNvbnN0IG91dHB1dCA9IHsgLi4udGFyZ2V0IH07XG4gIGlmIChpc09iamVjdCh0YXJnZXQpICYmIGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSkgT2JqZWN0LmFzc2lnbihvdXRwdXQsIHsgW2tleV06IHNvdXJjZVtrZXldIH0pO1xuICAgICAgICBlbHNlIG91dHB1dFtrZXldID0gbWVyZ2VBYmlFdmVudHModGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCB7IFtrZXldOiBzb3VyY2Vba2V5XSB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gcGFyc2VFdmVudHMocHJvdmlkZXJSZWNlaXZlZEV2ZW50cywgYWJpRXZlbnRzLCBhYmlTdHJ1Y3RzLCBhYmlFbnVtcykge1xuICBjb25zdCByZXQgPSBwcm92aWRlclJlY2VpdmVkRXZlbnRzLmZsYXQoKS5yZWR1Y2UoKGFjYywgcmVjRXZlbnQpID0+IHtcbiAgICBsZXQgYWJpRXZlbnQgPSBhYmlFdmVudHNbcmVjRXZlbnQua2V5cy5zaGlmdCgpID8/IDBdO1xuICAgIGlmICghYWJpRXZlbnQpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIHdoaWxlICghYWJpRXZlbnQubmFtZSkge1xuICAgICAgY29uc3QgaGFzaE5hbWUgPSByZWNFdmVudC5rZXlzLnNoaWZ0KCk7XG4gICAgICBhc3NlcnQoISFoYXNoTmFtZSwgJ05vdCBlbm91Z2ggZGF0YSBpbiBcImtleXNcIiBwcm9wZXJ0eSBvZiB0aGlzIGV2ZW50LicpO1xuICAgICAgYWJpRXZlbnQgPSBhYmlFdmVudFtoYXNoTmFtZV07XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZEV2ZW50ID0ge307XG4gICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV0gPSB7fTtcbiAgICBjb25zdCBrZXlzSXRlciA9IHJlY0V2ZW50LmtleXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGRhdGFJdGVyID0gcmVjRXZlbnQuZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgYWJpRXZlbnRLZXlzID0gYWJpRXZlbnQubWVtYmVycz8uZmlsdGVyKChpdCkgPT4gaXQua2luZCA9PT0gXCJrZXlcIikgfHwgYWJpRXZlbnQua2V5cztcbiAgICBjb25zdCBhYmlFdmVudERhdGEgPSBhYmlFdmVudC5tZW1iZXJzPy5maWx0ZXIoKGl0KSA9PiBpdC5raW5kID09PSBcImRhdGFcIikgfHwgYWJpRXZlbnQuZGF0YTtcbiAgICBhYmlFdmVudEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVtrZXkubmFtZV0gPSByZXNwb25zZVBhcnNlcihcbiAgICAgICAga2V5c0l0ZXIsXG4gICAgICAgIGtleSxcbiAgICAgICAgYWJpU3RydWN0cyxcbiAgICAgICAgYWJpRW51bXMsXG4gICAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdXG4gICAgICApO1xuICAgIH0pO1xuICAgIGFiaUV2ZW50RGF0YS5mb3JFYWNoKChkYXRhKSA9PiB7XG4gICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVtkYXRhLm5hbWVdID0gcmVzcG9uc2VQYXJzZXIoXG4gICAgICAgIGRhdGFJdGVyLFxuICAgICAgICBkYXRhLFxuICAgICAgICBhYmlTdHJ1Y3RzLFxuICAgICAgICBhYmlFbnVtcyxcbiAgICAgICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgaWYgKFwiYmxvY2tfaGFzaFwiIGluIHJlY0V2ZW50KSBwYXJzZWRFdmVudC5ibG9ja19oYXNoID0gcmVjRXZlbnQuYmxvY2tfaGFzaDtcbiAgICBpZiAoXCJibG9ja19udW1iZXJcIiBpbiByZWNFdmVudCkgcGFyc2VkRXZlbnQuYmxvY2tfbnVtYmVyID0gcmVjRXZlbnQuYmxvY2tfbnVtYmVyO1xuICAgIGlmIChcInRyYW5zYWN0aW9uX2hhc2hcIiBpbiByZWNFdmVudCkgcGFyc2VkRXZlbnQudHJhbnNhY3Rpb25faGFzaCA9IHJlY0V2ZW50LnRyYW5zYWN0aW9uX2hhc2g7XG4gICAgYWNjLnB1c2gocGFyc2VkRXZlbnQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHBhcnNlVURDRXZlbnQodHhSZWNlaXB0KSB7XG4gIGlmICghdHhSZWNlaXB0LmV2ZW50cz8ubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVURDIGVtaXR0ZWQgZXZlbnQgaXMgZW1wdHlcIik7XG4gIH1cbiAgY29uc3QgZXZlbnQgPSB0eFJlY2VpcHQuZXZlbnRzLmZpbmQoXG4gICAgKGl0KSA9PiBjbGVhbkhleChpdC5mcm9tX2FkZHJlc3MpID09PSBjbGVhbkhleChVREMuQUREUkVTUylcbiAgKSB8fCB7XG4gICAgZGF0YTogW11cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2FjdGlvbl9oYXNoOiB0eFJlY2VpcHQudHJhbnNhY3Rpb25faGFzaCxcbiAgICBjb250cmFjdF9hZGRyZXNzOiBldmVudC5kYXRhWzBdLFxuICAgIGFkZHJlc3M6IGV2ZW50LmRhdGFbMF0sXG4gICAgZGVwbG95ZXI6IGV2ZW50LmRhdGFbMV0sXG4gICAgdW5pcXVlOiBldmVudC5kYXRhWzJdLFxuICAgIGNsYXNzSGFzaDogZXZlbnQuZGF0YVszXSxcbiAgICBjYWxsZGF0YV9sZW46IGV2ZW50LmRhdGFbNF0sXG4gICAgY2FsbGRhdGE6IGV2ZW50LmRhdGEuc2xpY2UoNSwgNSArIHBhcnNlSW50KGV2ZW50LmRhdGFbNF0sIDE2KSksXG4gICAgc2FsdDogZXZlbnQuZGF0YVtldmVudC5kYXRhLmxlbmd0aCAtIDFdXG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9vdXRzaWRlRXhlY3V0aW9uLnRzXG52YXIgb3V0c2lkZUV4ZWN1dGlvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChvdXRzaWRlRXhlY3V0aW9uX2V4cG9ydHMsIHtcbiAgYnVpbGRFeGVjdXRlRnJvbU91dHNpZGVDYWxsOiAoKSA9PiBidWlsZEV4ZWN1dGVGcm9tT3V0c2lkZUNhbGwsXG4gIGJ1aWxkRXhlY3V0ZUZyb21PdXRzaWRlQ2FsbERhdGE6ICgpID0+IGJ1aWxkRXhlY3V0ZUZyb21PdXRzaWRlQ2FsbERhdGEsXG4gIGdldE91dHNpZGVDYWxsOiAoKSA9PiBnZXRPdXRzaWRlQ2FsbCxcbiAgZ2V0VHlwZWREYXRhOiAoKSA9PiBnZXRUeXBlZERhdGFcbn0pO1xuZnVuY3Rpb24gZ2V0T3V0c2lkZUNhbGwoY2FsbCkge1xuICBjb25zdCBjYWxsRGF0YSA9IGNhbGwuY2FsbGRhdGEgPz8gW107XG4gIGNvbnN0IGNhbGxEYXRhQ29tcGlsZWQgPSBBcnJheS5pc0FycmF5KGNhbGxEYXRhKSA/IGNhbGxEYXRhIDogQ2FsbERhdGEuY29tcGlsZShjYWxsRGF0YSk7XG4gIHJldHVybiB7XG4gICAgdG86IGNhbGwuY29udHJhY3RBZGRyZXNzLFxuICAgIHNlbGVjdG9yOiBnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCksXG4gICAgY2FsbGRhdGE6IGNhbGxEYXRhQ29tcGlsZWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGxUb1R5cGVkRGF0YShjYWxsLCB2ZXJzaW9uKSB7XG4gIGNvbnN0IG91dHNpZGVDYWxsID0gZ2V0T3V0c2lkZUNhbGwoY2FsbCk7XG4gIGlmICh2ZXJzaW9uID09PSBcIjFcIikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5vdXRzaWRlQ2FsbCxcbiAgICAgIGNhbGxkYXRhX2xlbjogb3V0c2lkZUNhbGwuY2FsbGRhdGEubGVuZ3RoLFxuICAgICAgY2FsbGRhdGE6IG91dHNpZGVDYWxsLmNhbGxkYXRhXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIFRvOiBvdXRzaWRlQ2FsbC50byxcbiAgICBTZWxlY3Rvcjogb3V0c2lkZUNhbGwuc2VsZWN0b3IsXG4gICAgQ2FsbGRhdGE6IG91dHNpZGVDYWxsLmNhbGxkYXRhXG4gIH07XG59XG5mdW5jdGlvbiBnZXREb21haW4oY2hhaW5JZCwgdmVyc2lvbikge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IFwiQWNjb3VudC5leGVjdXRlX2Zyb21fb3V0c2lkZVwiLFxuICAgIHZlcnNpb24sXG4gICAgY2hhaW5JZCxcbiAgICAuLi52ZXJzaW9uID09PSBcIjJcIiA/IHsgcmV2aXNpb246IFwiMVwiIH0gOiB7fVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VHlwZWREYXRhKGNoYWluSWQsIG9wdGlvbnMsIG5vbmNlLCBteUNhbGxzLCB2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uID09PSBcIjFcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlczogT3V0c2lkZUV4ZWN1dGlvblR5cGVzVjEsXG4gICAgICBwcmltYXJ5VHlwZTogXCJPdXRzaWRlRXhlY3V0aW9uXCIsXG4gICAgICBkb21haW46IGdldERvbWFpbihjaGFpbklkLCB2ZXJzaW9uKSxcbiAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIGNhbGxzX2xlbjogbXlDYWxscy5sZW5ndGgsXG4gICAgICAgIGNhbGxzOiBteUNhbGxzLm1hcCgoY2FsbCkgPT4gY2FsbFRvVHlwZWREYXRhKGNhbGwsIHZlcnNpb24pKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlczogT3V0c2lkZUV4ZWN1dGlvblR5cGVzVjIsXG4gICAgcHJpbWFyeVR5cGU6IFwiT3V0c2lkZUV4ZWN1dGlvblwiLFxuICAgIGRvbWFpbjogZ2V0RG9tYWluKGNoYWluSWQsIHZlcnNpb24pLFxuICAgIG1lc3NhZ2U6IHtcbiAgICAgIENhbGxlcjogb3B0aW9ucy5jYWxsZXIsXG4gICAgICBOb25jZTogbm9uY2UsXG4gICAgICBcIkV4ZWN1dGUgQWZ0ZXJcIjogb3B0aW9ucy5leGVjdXRlX2FmdGVyLFxuICAgICAgXCJFeGVjdXRlIEJlZm9yZVwiOiBvcHRpb25zLmV4ZWN1dGVfYmVmb3JlLFxuICAgICAgQ2FsbHM6IG15Q2FsbHMubWFwKChjYWxsKSA9PiBjYWxsVG9UeXBlZERhdGEoY2FsbCwgdmVyc2lvbikpXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFeGVjdXRlRnJvbU91dHNpZGVDYWxsRGF0YShvdXRzaWRlVHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgZXhlY3V0aW9uMiA9IG91dHNpZGVUcmFuc2FjdGlvbi5vdXRzaWRlRXhlY3V0aW9uO1xuICBjb25zdCBmb3JtYXR0ZWRTaWduYXR1cmUgPSBmb3JtYXRTaWduYXR1cmUob3V0c2lkZVRyYW5zYWN0aW9uLnNpZ25hdHVyZSk7XG4gIHJldHVybiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICBvdXRzaWRlX2V4ZWN1dGlvbjogZXhlY3V0aW9uMixcbiAgICBzaWduYXR1cmU6IGZvcm1hdHRlZFNpZ25hdHVyZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXhlY3V0ZUZyb21PdXRzaWRlQ2FsbChvdXRzaWRlVHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgbXlPdXRzaWRlVHJhbnNhY3Rpb25zID0gQXJyYXkuaXNBcnJheShvdXRzaWRlVHJhbnNhY3Rpb24pID8gb3V0c2lkZVRyYW5zYWN0aW9uIDogW291dHNpZGVUcmFuc2FjdGlvbl07XG4gIGNvbnN0IG11bHRpQ2FsbCA9IG15T3V0c2lkZVRyYW5zYWN0aW9ucy5tYXAoKG91dHNpZGVUeCkgPT4ge1xuICAgIGxldCBlbnRyeXBvaW50O1xuICAgIGlmIChvdXRzaWRlVHgudmVyc2lvbiA9PT0gXCIxXCIgLyogVjEgKi8pIHtcbiAgICAgIGVudHJ5cG9pbnQgPSBcImV4ZWN1dGVfZnJvbV9vdXRzaWRlXCI7XG4gICAgfSBlbHNlIGlmIChvdXRzaWRlVHgudmVyc2lvbiA9PT0gXCIyXCIgLyogVjIgKi8pIHtcbiAgICAgIGVudHJ5cG9pbnQgPSBcImV4ZWN1dGVfZnJvbV9vdXRzaWRlX3YyXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIE91dHNpZGVFeGVjdXRpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdG9IZXgob3V0c2lkZVR4LnNpZ25lckFkZHJlc3MpLFxuICAgICAgZW50cnlwb2ludCxcbiAgICAgIGNhbGxkYXRhOiBidWlsZEV4ZWN1dGVGcm9tT3V0c2lkZUNhbGxEYXRhKG91dHNpZGVUeClcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIG11bHRpQ2FsbDtcbn1cblxuLy8gc3JjL3V0aWxzL3NyYzUudHNcbnZhciBzcmM1X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyYzVfZXhwb3J0cywge1xuICBzdXBwb3J0c0ludGVyZmFjZTogKCkgPT4gc3VwcG9ydHNJbnRlcmZhY2Vcbn0pO1xuYXN5bmMgZnVuY3Rpb24gc3VwcG9ydHNJbnRlcmZhY2UocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgaW50ZXJmYWNlSWQpIHtcbiAgY29uc3QgY2FsbCA9IHtcbiAgICBjb250cmFjdEFkZHJlc3M6IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyksXG4gICAgZW50cnlwb2ludDogXCJzdXBwb3J0c19pbnRlcmZhY2VcIixcbiAgICBjYWxsZGF0YTogW3RvSGV4KGludGVyZmFjZUlkKV1cbiAgfTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgcHJvdmlkZXIuY2FsbENvbnRyYWN0KGNhbGwpO1xuICAgIHJldHVybiBCaWdJbnQocmVzcFswXSkgIT09IDBuO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gc3JjL2FjY291bnQvZGVmYXVsdC50c1xudmFyIEFjY291bnQgPSBjbGFzcyBleHRlbmRzIFJwY1Byb3ZpZGVyMiB7XG4gIHNpZ25lcjtcbiAgYWRkcmVzcztcbiAgY2Fpcm9WZXJzaW9uO1xuICB0cmFuc2FjdGlvblZlcnNpb247XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyT3JPcHRpb25zLCBhZGRyZXNzLCBwa09yU2lnbmVyLCBjYWlyb1ZlcnNpb24sIHRyYW5zYWN0aW9uVmVyc2lvbiA9IGNvbmZpZy5nZXQoXG4gICAgXCJhY2NvdW50VHhWZXJzaW9uXCJcbiAgKSkge1xuICAgIHN1cGVyKHByb3ZpZGVyT3JPcHRpb25zKTtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5zaWduZXIgPSBpc1N0cmluZyhwa09yU2lnbmVyKSB8fCBwa09yU2lnbmVyIGluc3RhbmNlb2YgVWludDhBcnJheSA/IG5ldyBTaWduZXIocGtPclNpZ25lcikgOiBwa09yU2lnbmVyO1xuICAgIGlmIChjYWlyb1ZlcnNpb24pIHtcbiAgICAgIHRoaXMuY2Fpcm9WZXJzaW9uID0gY2Fpcm9WZXJzaW9uLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMudHJhbnNhY3Rpb25WZXJzaW9uID0gdHJhbnNhY3Rpb25WZXJzaW9uO1xuICB9XG4gIC8vIHByb3ZpZGVkIHZlcnNpb24gb3IgY29udHJhY3QgYmFzZWQgcHJlZmVycmVkIHRyYW5zYWN0aW9uVmVyc2lvblxuICBnZXRQcmVmZXJyZWRWZXJzaW9uKHR5cGUxMiwgdHlwZTMpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvblZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpIHJldHVybiB0eXBlMztcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvblZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIpIHJldHVybiB0eXBlMTI7XG4gICAgcmV0dXJuIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjM7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2UoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldE5vbmNlRm9yQWRkcmVzcyh0aGlzLmFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2VTYWZlKG5vbmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0b0JpZ0ludChub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gMG47XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIENhaXJvIHZlcnNpb24gZnJvbSB0aGUgbmV0d29yayBhbmQgc2V0cyBgY2Fpcm9WZXJzaW9uYCBpZiBub3QgYWxyZWFkeSBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gY2xhc3NIYXNoIGlmIHByb3ZpZGVkIGRldGVjdHMgQ2Fpcm8gdmVyc2lvbiBmcm9tIGNsYXNzSGFzaCwgb3RoZXJ3aXNlIGZyb20gdGhlIGFjY291bnQgYWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q2Fpcm9WZXJzaW9uKGNsYXNzSGFzaCkge1xuICAgIGlmICghdGhpcy5jYWlyb1ZlcnNpb24pIHtcbiAgICAgIGNvbnN0IHsgY2Fpcm8gfSA9IGNsYXNzSGFzaCA/IGF3YWl0IHN1cGVyLmdldENvbnRyYWN0VmVyc2lvbih2b2lkIDAsIGNsYXNzSGFzaCkgOiBhd2FpdCBzdXBlci5nZXRDb250cmFjdFZlcnNpb24odGhpcy5hZGRyZXNzKTtcbiAgICAgIHRoaXMuY2Fpcm9WZXJzaW9uID0gY2Fpcm87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhaXJvVmVyc2lvbjtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUZlZShjYWxscywgZXN0aW1hdGVGZWVEZXRhaWxzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZUludm9rZUZlZShjYWxscywgZXN0aW1hdGVGZWVEZXRhaWxzKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUludm9rZUZlZShjYWxscywgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbm9uY2U6IHByb3ZpZGVkTm9uY2UsXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICB2ZXJzaW9uOiBwcm92aWRlZFZlcnNpb24sXG4gICAgICBza2lwVmFsaWRhdGUgPSB0cnVlXG4gICAgfSA9IGRldGFpbHM7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25zID0gQXJyYXkuaXNBcnJheShjYWxscykgPyBjYWxscyA6IFtjYWxsc107XG4gICAgY29uc3Qgbm9uY2UgPSB0b0JpZ0ludChwcm92aWRlZE5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjEsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjMpLFxuICAgICAgdG9GZWVWZXJzaW9uKHByb3ZpZGVkVmVyc2lvbilcbiAgICApO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBzaWduZXJEZXRhaWxzID0ge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgbm9uY2UsXG4gICAgICBtYXhGZWU6IFpFUk8sXG4gICAgICB2ZXJzaW9uLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGNhaXJvVmVyc2lvbjogYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKSxcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgIH07XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IGF3YWl0IHRoaXMuYnVpbGRJbnZvY2F0aW9uKHRyYW5zYWN0aW9ucywgc2lnbmVyRGV0YWlscyk7XG4gICAgcmV0dXJuIHN1cGVyLmdldEludm9rZUVzdGltYXRlRmVlKFxuICAgICAgeyAuLi5pbnZvY2F0aW9uIH0sXG4gICAgICB7IC4uLnYzRGV0YWlscyhkZXRhaWxzKSwgdmVyc2lvbiwgbm9uY2UgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIGRldGFpbHMuc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZURlY2xhcmVGZWUocGF5bG9hZCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgbm9uY2U6IHByb3ZpZGVkTm9uY2UsXG4gICAgICB2ZXJzaW9uOiBwcm92aWRlZFZlcnNpb24sXG4gICAgICBza2lwVmFsaWRhdGUgPSB0cnVlXG4gICAgfSA9IGRldGFpbHM7XG4gICAgY29uc3Qgbm9uY2UgPSB0b0JpZ0ludChwcm92aWRlZE5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgIWlzU2llcnJhKHBheWxvYWQuY29udHJhY3QpID8gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMSA6IHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYyLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzKSxcbiAgICAgIHRvRmVlVmVyc2lvbihwcm92aWRlZFZlcnNpb24pXG4gICAgKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLmJ1aWxkRGVjbGFyZVBheWxvYWQocGF5bG9hZCwge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgbm9uY2UsXG4gICAgICBjaGFpbklkLFxuICAgICAgdmVyc2lvbixcbiAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgIGNhaXJvVmVyc2lvbjogdm9pZCAwLFxuICAgICAgLy8gdW51c2VkIHBhcmFtZXRlclxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgfSk7XG4gICAgcmV0dXJuIHN1cGVyLmdldERlY2xhcmVFc3RpbWF0ZUZlZShcbiAgICAgIGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uLFxuICAgICAgeyAuLi52M0RldGFpbHMoZGV0YWlscyksIHZlcnNpb24sIG5vbmNlIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBkZXRhaWxzLnNraXBWYWxpZGF0ZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVBY2NvdW50RGVwbG95RmVlKHtcbiAgICBjbGFzc0hhc2gsXG4gICAgYWRkcmVzc1NhbHQgPSAwLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXSxcbiAgICBjb250cmFjdEFkZHJlc3NcbiAgfSwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgeyBibG9ja0lkZW50aWZpZXIsIHZlcnNpb246IHByb3ZpZGVkVmVyc2lvbiwgc2tpcFZhbGlkYXRlID0gdHJ1ZSB9ID0gZGV0YWlscztcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMSwgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMyksXG4gICAgICB0b0ZlZVZlcnNpb24ocHJvdmlkZWRWZXJzaW9uKVxuICAgICk7XG4gICAgY29uc3Qgbm9uY2UgPSBaRVJPO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEFjY291bnREZXBsb3lQYXlsb2FkKFxuICAgICAgeyBjbGFzc0hhc2gsIGFkZHJlc3NTYWx0LCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBjb250cmFjdEFkZHJlc3MgfSxcbiAgICAgIHtcbiAgICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgICBub25jZSxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAvLyB1bnVzZWQgcGFyYW1ldGVyXG4gICAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDAsXG4gICAgICAgIC8vIHVudXNlZCBwYXJhbWV0ZXIsXG4gICAgICAgIHNraXBWYWxpZGF0ZVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHN1cGVyLmdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZShcbiAgICAgIHsgLi4ucGF5bG9hZCB9LFxuICAgICAgeyAuLi52M0RldGFpbHMoZGV0YWlscyksIHZlcnNpb24sIG5vbmNlIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBkZXRhaWxzLnNraXBWYWxpZGF0ZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVEZXBsb3lGZWUocGF5bG9hZCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgY2FsbHMgPSB0aGlzLmJ1aWxkVURDQ29udHJhY3RQYXlsb2FkKHBheWxvYWQpO1xuICAgIHJldHVybiB0aGlzLmVzdGltYXRlSW52b2tlRmVlKGNhbGxzLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUZlZUJ1bGsoaW52b2NhdGlvbnMsIGRldGFpbHMgPSB7fSkge1xuICAgIGlmICghaW52b2NhdGlvbnMubGVuZ3RoKSB0aHJvdyBUeXBlRXJyb3IoXCJJbnZvY2F0aW9ucyBzaG91bGQgYmUgbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgIGNvbnN0IHsgbm9uY2UsIGJsb2NrSWRlbnRpZmllciwgdmVyc2lvbiwgc2tpcFZhbGlkYXRlIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IGFjY291bnRJbnZvY2F0aW9ucyA9IGF3YWl0IHRoaXMuYWNjb3VudEludm9jYXRpb25zRmFjdG9yeShpbnZvY2F0aW9ucywge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgdmVyc2lvbnM6IFtcbiAgICAgICAgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMSxcbiAgICAgICAgLy8gbm9uLXNpZXJyYVxuICAgICAgICB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgICAgICB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMiwgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMyksXG4gICAgICAgICAgdmVyc2lvblxuICAgICAgICApXG4gICAgICAgIC8vIHNpZXJyYVxuICAgICAgXSxcbiAgICAgIG5vbmNlLFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgfSk7XG4gICAgcmV0dXJuIHN1cGVyLmdldEVzdGltYXRlRmVlQnVsayhhY2NvdW50SW52b2NhdGlvbnMsIHtcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIGRldGFpbHMgPSB7fSkge1xuICAgIGlmICghaW52b2NhdGlvbnMubGVuZ3RoKSB0aHJvdyBUeXBlRXJyb3IoXCJJbnZvY2F0aW9ucyBzaG91bGQgYmUgbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgIGNvbnN0IHsgbm9uY2UsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gdHJ1ZSwgc2tpcEV4ZWN1dGUsIHZlcnNpb24gfSA9IGRldGFpbHM7XG4gICAgY29uc3QgYWNjb3VudEludm9jYXRpb25zID0gYXdhaXQgdGhpcy5hY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICB2ZXJzaW9uczogW1xuICAgICAgICBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAvLyBub24tc2llcnJhXG4gICAgICAgIHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgICAgIHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYyLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzKSxcbiAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgIClcbiAgICAgIF0sXG4gICAgICBub25jZSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgIH0pO1xuICAgIHJldHVybiBzdXBlci5nZXRTaW11bGF0ZVRyYW5zYWN0aW9uKGFjY291bnRJbnZvY2F0aW9ucywge1xuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlLFxuICAgICAgc2tpcEV4ZWN1dGVcbiAgICB9KTtcbiAgfVxuICBhc3luYyBleGVjdXRlKHRyYW5zYWN0aW9ucywgYXJnMiwgdHJhbnNhY3Rpb25zRGV0YWlsID0ge30pIHtcbiAgICBjb25zdCBkZXRhaWxzID0gYXJnMiA9PT0gdm9pZCAwIHx8IEFycmF5LmlzQXJyYXkoYXJnMikgPyB0cmFuc2FjdGlvbnNEZXRhaWwgOiBhcmcyO1xuICAgIGNvbnN0IGNhbGxzID0gQXJyYXkuaXNBcnJheSh0cmFuc2FjdGlvbnMpID8gdHJhbnNhY3Rpb25zIDogW3RyYW5zYWN0aW9uc107XG4gICAgY29uc3Qgbm9uY2UgPSB0b0JpZ0ludChkZXRhaWxzLm5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpLFxuICAgICAgLy8gVE9ETzogZG9lcyB0aGlzIGRlcGVuZCBvbiBjYWlybyB2ZXJzaW9uID9cbiAgICAgIGRldGFpbHMudmVyc2lvblxuICAgICk7XG4gICAgY29uc3QgZXN0aW1hdGUgPSBhd2FpdCB0aGlzLmdldFVuaXZlcnNhbFN1Z2dlc3RlZEZlZShcbiAgICAgIHZlcnNpb24sXG4gICAgICB7IHR5cGU6IFRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsIHBheWxvYWQ6IHRyYW5zYWN0aW9ucyB9LFxuICAgICAge1xuICAgICAgICAuLi5kZXRhaWxzLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIHJlc291cmNlQm91bmRzOiBlc3RpbWF0ZS5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIG5vbmNlLFxuICAgICAgbWF4RmVlOiBlc3RpbWF0ZS5tYXhGZWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGNhaXJvVmVyc2lvbjogYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKVxuICAgIH07XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduZXIuc2lnblRyYW5zYWN0aW9uKGNhbGxzLCBzaWduZXJEZXRhaWxzKTtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldEV4ZWN1dGVDYWxsZGF0YShjYWxscywgYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKSk7XG4gICAgcmV0dXJuIHRoaXMuaW52b2tlRnVuY3Rpb24oXG4gICAgICB7IGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLCBjYWxsZGF0YSwgc2lnbmF0dXJlIH0sXG4gICAgICB7XG4gICAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgICAgcmVzb3VyY2VCb3VuZHM6IGVzdGltYXRlLnJlc291cmNlQm91bmRzLFxuICAgICAgICBub25jZSxcbiAgICAgICAgbWF4RmVlOiBlc3RpbWF0ZS5tYXhGZWUsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBGaXJzdCBjaGVjayBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkLCBpZiBub3QgZGVjbGFyZSBpdFxuICAgKiBJZiBjb250cmFjdCBhbHJlYWR5IGRlY2xhcmVkIHJldHVybmVkIHRyYW5zYWN0aW9uX2hhc2ggaXMgJycuXG4gICAqIE1ldGhvZCB3aWxsIHBhc3MgZXZlbiBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbnNEZXRhaWwgKG9wdGlvbmFsKVxuICAgKi9cbiAgYXN5bmMgZGVjbGFyZUlmTm90KHBheWxvYWQsIHRyYW5zYWN0aW9uc0RldGFpbCA9IHt9KSB7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5nZXRDbGFzc0J5SGFzaChkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmUocGF5bG9hZCwgdHJhbnNhY3Rpb25zRGV0YWlsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IFwiXCIsXG4gICAgICBjbGFzc19oYXNoOiBkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaFxuICAgIH07XG4gIH1cbiAgYXN5bmMgZGVjbGFyZShwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RQYXlsb2FkID0gZXh0cmFjdENvbnRyYWN0SGFzaGVzKHBheWxvYWQpO1xuICAgIGNvbnN0IHsgbm9uY2UsIHZlcnNpb246IHByb3ZpZGVkVmVyc2lvbiB9ID0gZGV0YWlscztcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICAhaXNTaWVycmEocGF5bG9hZC5jb250cmFjdCkgPyBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxIDogdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpLFxuICAgICAgcHJvdmlkZWRWZXJzaW9uXG4gICAgKTtcbiAgICBjb25zdCBlc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZ2V0VW5pdmVyc2FsU3VnZ2VzdGVkRmVlKFxuICAgICAgdmVyc2lvbixcbiAgICAgIHtcbiAgICAgICAgdHlwZTogVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgIHBheWxvYWQ6IGRlY2xhcmVDb250cmFjdFBheWxvYWRcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC4uLmRldGFpbHMsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IGRlY2xhcmVEZXRhaWxzID0ge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgcmVzb3VyY2VCb3VuZHM6IGVzdGltYXRlLnJlc291cmNlQm91bmRzLFxuICAgICAgbWF4RmVlOiBlc3RpbWF0ZS5tYXhGZWUsXG4gICAgICBub25jZTogdG9CaWdJbnQobm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBjaGFpbklkOiBhd2FpdCB0aGlzLmdldENoYWluSWQoKSxcbiAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIGNhaXJvVmVyc2lvbjogdm9pZCAwXG4gICAgfTtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuYnVpbGREZWNsYXJlUGF5bG9hZChcbiAgICAgIGRlY2xhcmVDb250cmFjdFBheWxvYWQsXG4gICAgICBkZWNsYXJlRGV0YWlsc1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZGVjbGFyZUNvbnRyYWN0KGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uLCBkZWNsYXJlRGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZGVwbG95KHBheWxvYWQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2FsbHMsIGFkZHJlc3NlcyB9ID0gYnVpbGRVRENDYWxsKHBheWxvYWQsIHRoaXMuYWRkcmVzcyk7XG4gICAgY29uc3QgaW52b2tlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGUoY2FsbHMsIHZvaWQgMCwgZGV0YWlscyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmludm9rZVJlc3BvbnNlLFxuICAgICAgY29udHJhY3RfYWRkcmVzczogYWRkcmVzc2VzXG4gICAgfTtcbiAgfVxuICBhc3luYyBkZXBsb3lDb250cmFjdChwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCBkZXBsb3lUeCA9IGF3YWl0IHRoaXMuZGVwbG95KHBheWxvYWQsIGRldGFpbHMpO1xuICAgIGNvbnN0IHR4UmVjZWlwdCA9IGF3YWl0IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKGRlcGxveVR4LnRyYW5zYWN0aW9uX2hhc2gpO1xuICAgIHJldHVybiBwYXJzZVVEQ0V2ZW50KHR4UmVjZWlwdCk7XG4gIH1cbiAgYXN5bmMgZGVjbGFyZUFuZERlcGxveShwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7IGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHNhbHQsIHVuaXF1ZSB9ID0gcGF5bG9hZDtcbiAgICBsZXQgZGVjbGFyZSA9IGF3YWl0IHRoaXMuZGVjbGFyZUlmTm90KHBheWxvYWQsIGRldGFpbHMpO1xuICAgIGlmIChkZWNsYXJlLnRyYW5zYWN0aW9uX2hhc2ggIT09IFwiXCIpIHtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oZGVjbGFyZS50cmFuc2FjdGlvbl9oYXNoKTtcbiAgICAgIGRlY2xhcmUgPSB7IC4uLmRlY2xhcmUsIC4uLnR4IH07XG4gICAgfVxuICAgIGNvbnN0IGRlcGxveSA9IGF3YWl0IHRoaXMuZGVwbG95Q29udHJhY3QoXG4gICAgICB7IGNsYXNzSGFzaDogZGVjbGFyZS5jbGFzc19oYXNoLCBzYWx0LCB1bmlxdWUsIGNvbnN0cnVjdG9yQ2FsbGRhdGEgfSxcbiAgICAgIGRldGFpbHNcbiAgICApO1xuICAgIHJldHVybiB7IGRlY2xhcmU6IHsgLi4uZGVjbGFyZSB9LCBkZXBsb3kgfTtcbiAgfVxuICBkZXBsb3lTZWxmID0gdGhpcy5kZXBsb3lBY2NvdW50O1xuICBhc3luYyBkZXBsb3lBY2NvdW50KHtcbiAgICBjbGFzc0hhc2gsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdLFxuICAgIGFkZHJlc3NTYWx0ID0gMCxcbiAgICBjb250cmFjdEFkZHJlc3M6IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzXG4gIH0sIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgIHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzKSxcbiAgICAgIGRldGFpbHMudmVyc2lvblxuICAgICk7XG4gICAgY29uc3Qgbm9uY2UgPSBaRVJPO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBwcm92aWRlZENvbnRyYWN0QWRkcmVzcyA/PyBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaChhZGRyZXNzU2FsdCwgY2xhc3NIYXNoLCBjb21waWxlZENhbGxkYXRhLCAwKTtcbiAgICBjb25zdCBlc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZ2V0VW5pdmVyc2FsU3VnZ2VzdGVkRmVlKFxuICAgICAgdmVyc2lvbixcbiAgICAgIHtcbiAgICAgICAgdHlwZTogVHJhbnNhY3Rpb25UeXBlLkRFUExPWV9BQ0NPVU5ULFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICAgICAgY29udHJhY3RBZGRyZXNzXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXRhaWxzXG4gICAgKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBhZGRyZXNzU2FsdCxcbiAgICAgIGNoYWluSWQsXG4gICAgICByZXNvdXJjZUJvdW5kczogZXN0aW1hdGUucmVzb3VyY2VCb3VuZHMsXG4gICAgICBtYXhGZWU6IGVzdGltYXRlLm1heEZlZSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBub25jZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmRlcGxveUFjY291bnRDb250cmFjdChcbiAgICAgIHsgY2xhc3NIYXNoLCBhZGRyZXNzU2FsdCwgY29uc3RydWN0b3JDYWxsZGF0YSwgc2lnbmF0dXJlIH0sXG4gICAgICB7XG4gICAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIHJlc291cmNlQm91bmRzOiBlc3RpbWF0ZS5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgbWF4RmVlOiBlc3RpbWF0ZS5tYXhGZWUsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKHR5cGVkRGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25lci5zaWduTWVzc2FnZSh0eXBlZERhdGEsIHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgYXN5bmMgaGFzaE1lc3NhZ2UodHlwZWREYXRhKSB7XG4gICAgcmV0dXJuIGdldE1lc3NhZ2VIYXNoKHR5cGVkRGF0YSwgdGhpcy5hZGRyZXNzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVG8gcmVwbGFjZSBieSBgbXlScGNQcm92aWRlci52ZXJpZnlNZXNzYWdlSW5TdGFya25ldCgpYFxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5TWVzc2FnZUhhc2goaGFzaCwgc2lnbmF0dXJlLCBzaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbk5hbWUsIHNpZ25hdHVyZVZlcmlmaWNhdGlvblJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyaWZ5TWVzc2FnZUluU3RhcmtuZXQoXG4gICAgICBoYXNoLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgdGhpcy5hZGRyZXNzLFxuICAgICAgc2lnbmF0dXJlVmVyaWZpY2F0aW9uRnVuY3Rpb25OYW1lLFxuICAgICAgc2lnbmF0dXJlVmVyaWZpY2F0aW9uUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBUbyByZXBsYWNlIGJ5IGBteVJwY1Byb3ZpZGVyLnZlcmlmeU1lc3NhZ2VJblN0YXJrbmV0KClgXG4gICAqL1xuICBhc3luYyB2ZXJpZnlNZXNzYWdlKHR5cGVkRGF0YSwgc2lnbmF0dXJlLCBzaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbk5hbWUsIHNpZ25hdHVyZVZlcmlmaWNhdGlvblJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyaWZ5TWVzc2FnZUluU3RhcmtuZXQoXG4gICAgICB0eXBlZERhdGEsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICB0aGlzLmFkZHJlc3MsXG4gICAgICBzaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbk5hbWUsXG4gICAgICBzaWduYXR1cmVWZXJpZmljYXRpb25SZXNwb25zZVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFZlcmlmeSBpZiBhbiBhY2NvdW50IGlzIGNvbXBhdGlibGUgd2l0aCBTTklQLTkgb3V0c2lkZSBleGVjdXRpb24sIGFuZCB3aXRoIHdoaWNoIHZlcnNpb24gb2YgdGhpcyBzdGFuZGFyZC5cbiAgICogQHJldHVybnMge091dHNpZGVFeGVjdXRpb25WZXJzaW9ufSBOb3QgY29tcGF0aWJsZSwgVjEsIFYyLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3VsdCA9IG15QWNjb3VudC5nZXRTbmlwOVZlcnNpb24oKTtcbiAgICogLy8gcmVzdWx0ID0gXCJWMVwiXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZ2V0U25pcDlWZXJzaW9uKCkge1xuICAgIGlmIChhd2FpdCBzdXBwb3J0c0ludGVyZmFjZSh0aGlzLCB0aGlzLmFkZHJlc3MsIFNOSVA5X1YyX0lOVEVSRkFDRV9JRCkpIHtcbiAgICAgIHJldHVybiBcIjJcIiAvKiBWMiAqLztcbiAgICB9XG4gICAgaWYgKGF3YWl0IHN1cHBvcnRzSW50ZXJmYWNlKHRoaXMsIHRoaXMuYWRkcmVzcywgU05JUDlfVjFfSU5URVJGQUNFX0lEKSkge1xuICAgICAgcmV0dXJuIFwiMVwiIC8qIFYxICovO1xuICAgIH1cbiAgICByZXR1cm4gXCIwXCIgLyogVU5TVVBQT1JURUQgKi87XG4gIH1cbiAgLyoqXG4gICAqIFZlcmlmeSBpZiBhIFNOSVAtOSBub25jZSBoYXMgbm90IHlldCBiZWVuIHVzZWQgYnkgdGhlIGFjY291bnQuXG4gICAqIEBwYXJhbSB7QmlnTnVtYmVyaXNofSBub25jZSBTTklQLTkgbm9uY2UgdG8gdGVzdC5cbiAgICogQHJldHVybnMgIHtib29sZWFufSB0cnVlIGlmIFNOSVAtOSBub25jZSBub3QgeWV0IHVzZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgcmVzdWx0ID0gbXlBY2NvdW50LmlzVmFsaWRTbmlwOU5vbmNlKDEyMzQpO1xuICAgKiAvLyByZXN1bHQgPSB0cnVlXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgaXNWYWxpZFNuaXA5Tm9uY2Uobm9uY2UpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FsbCA9IHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFwiaXNfdmFsaWRfb3V0c2lkZV9leGVjdXRpb25fbm9uY2VcIixcbiAgICAgICAgY2FsbGRhdGE6IFt0b0hleChub25jZSldXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuY2FsbENvbnRyYWN0KGNhbGwpO1xuICAgICAgcmV0dXJuIEJpZ0ludChyZXNwWzBdKSAhPT0gMG47XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNoZWNrIGlmIG5vbmNlIGlzIHZhbGlkOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogT3V0c2lkZSB0cmFuc2FjdGlvbiBuZWVkcyBhIHNwZWNpZmljIFNOSVAtOSBub25jZSwgdGhhdCB3ZSBnZXQgaW4gdGhpcyBmdW5jdGlvbi5cbiAgICogQSBTTklQLTkgbm9uY2UgY2FuIGJlIGFueSBudW1iZXIgbm90IHlldCB1c2VkIDsgbm8gb3JkZXJpbmcgaXMgbmVlZGVkLlxuICAgKiBAcmV0dXJucyAge3N0cmluZ30gYW4gSGV4IHN0cmluZyBvZiBhIFNOSVAtOSBub25jZS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQgPSBteUFjY291bnQuZ2V0U25pcDlOb25jZSgpO1xuICAgKiAvLyByZXN1bHQgPSBcIjB4MjhhNjEyNTkwZGJjMzY5Mjc5MzNjOGVlMGYzNTdlZWU2MzljOGIyMmIzZDNhYTg2OTQ5ZWVkM2FkYTRhYzU1XCJcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBnZXRTbmlwOU5vbmNlKCkge1xuICAgIGNvbnN0IG5vbmNlID0gcmFuZG9tQWRkcmVzcygpO1xuICAgIGNvbnN0IGlzVmFsaWROb25jZSA9IGF3YWl0IHRoaXMuaXNWYWxpZFNuaXA5Tm9uY2Uobm9uY2UpO1xuICAgIGlmICghaXNWYWxpZE5vbmNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTbmlwOU5vbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBub25jZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29udGFpbmluZyB0cmFuc2FjdGlvbihzKSB0aGF0IGNhbiBiZSBleGVjdXRlZCBieSBhbiBvdGhlciBhY2NvdW50IHdpdGhgIEFjY291bnQuZXhlY3V0ZUZyb21PdXRzaWRlKClgLCBjYWxsZWQgT3V0c2lkZSBUcmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtPdXRzaWRlRXhlY3V0aW9uT3B0aW9uc30gb3B0aW9ucyBQYXJhbWV0ZXJzIG9mIHRoZSB0cmFuc2FjdGlvbihzKS5cbiAgICogQHBhcmFtIHtBbGxvd0FycmF5PENhbGw+fSBjYWxscyBUcmFuc2FjdGlvbihzKSB0byBleGVjdXRlLlxuICAgKiBAcGFyYW0ge091dHNpZGVFeGVjdXRpb25WZXJzaW9ufSBbdmVyc2lvbl0gU05JUC05IHZlcnNpb24gb2YgdGhlIEFjY291bnQgdGhhdCBjcmVhdGVzIHRoZSBvdXRzaWRlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge0JpZ051bWJlcmlzaH0gW25vbmNlXSBPdXRzaWRlIE5vbmNlLlxuICAgKiBAcmV0dXJucyB7T3V0c2lkZVRyYW5zYWN0aW9ufSBhbmQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgaW4gYEFjY291bnQuZXhlY3V0ZUZyb21PdXRzaWRlKClgXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3Qgbm93X3NlY29uZHMgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICogY29uc3QgY2FsbE9wdGlvbnM6IE91dHNpZGVFeGVjdXRpb25PcHRpb25zID0ge1xuICAgICAgY2FsbGVyOiBleGVjdXRvckFjY291bnQuYWRkcmVzcywgZXhlY3V0ZV9hZnRlcjogbm93X3NlY29uZHMgLSAzNjAwLCBleGVjdXRlX2JlZm9yZTogbm93X3NlY29uZHMgKyAzNjAwIH07XG4gICAqIGNvbnN0IGNhbGwxOiBDYWxsID0geyBjb250cmFjdEFkZHJlc3M6IGV0aEFkZHJlc3MsIGVudHJ5cG9pbnQ6ICd0cmFuc2ZlcicsIGNhbGxkYXRhOiB7XG4gICAqICAgICByZWNpcGllbnQ6IHJlY2lwaWVudEFjY291bnQuYWRkcmVzcywgYW1vdW50OiBjYWlyby51aW50MjU2KDEwMCkgfSB9O1xuICAgKiBjb25zdCBvdXRzaWRlVHJhbnNhY3Rpb24xOiBPdXRzaWRlVHJhbnNhY3Rpb24gPSBhd2FpdCBzaWduZXJBY2NvdW50LmdldE91dHNpZGVUcmFuc2FjdGlvbihjYWxsT3B0aW9ucywgY2FsbDMpO1xuICAgKiAvLyByZXN1bHQgPSB7XG4gICAqIC8vIG91dHNpZGVFeGVjdXRpb246IHtcbiAgICogLy8gY2FsbGVyOiAnMHg2NGI0ODgwNjkwMmEzNjdjODU5OGY0Zjk1YzMwNWU4YzFhMWFjYmE1ZjA4MmQyOTRhNDM3OTMxMTMxMTU2OTEnLFxuICAgKiAvLyBub25jZTogJzB4MjhhNjEyNTkwZGJjMzY5Mjc5MzNjOGVlMGYzNTdlZWU2MzljOGIyMmIzZDNhYTg2OTQ5ZWVkM2FkYTRhYzU1JyxcbiAgICogLy8gZXhlY3V0ZV9hZnRlcjogMTcyMzY1MDIyOSwgZXhlY3V0ZV9iZWZvcmU6IDE3MjM3MDQyMjksIGNhbGxzOiBbW09iamVjdF1dIH0sXG4gICAqIC8vIHNpZ25hdHVyZTogU2lnbmF0dXJlIHtcbiAgICogLy8gcjogNjc1MTg2MjcwMzc5MTU1MTQ5ODUzMjEyNzg4NTc4MjUzODQxMDY0ODI5OTk2MDk2MzQ4NzMyODc0MDY2MTI3NTY4NDM5MTY4MTRuLFxuICAgKiAvLyBzOiA3MzcxOTg3Mzg1Njk4NDA2MzkxOTI4NDQxMDE2OTAwMDk0OTg5ODM2MTE2NTQ0NTg2MzY2MjQyOTM1Nzk1MzQ1NjA4NjIwNjc3MDluLCByZWNvdmVyeTogMCB9LFxuICAgKiAvLyBzaWduZXJBZGRyZXNzOiAnMHg2NTVmOGZkN2M0MDEzYzA3Y2YxMmE5MjE4NGFhNmMzMTRkMTgxNDQzOTEzZTIxZjdlMjA5YTE4ZjBjNzg0OTInLFxuICAgKiAvLyB2ZXJzaW9uOiAnMidcbiAgICogLy8gfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGdldE91dHNpZGVUcmFuc2FjdGlvbihvcHRpb25zLCBjYWxscywgdmVyc2lvbiwgbm9uY2UpIHtcbiAgICBpZiAoIWlzSGV4KG9wdGlvbnMuY2FsbGVyKSAmJiBvcHRpb25zLmNhbGxlciAhPT0gXCJBTllfQ0FMTEVSXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGNhbGxlciAke29wdGlvbnMuY2FsbGVyfSBpcyBub3QgdmFsaWQuYCk7XG4gICAgfVxuICAgIGNvbnN0IGNvZGVkQ2FsbGVyID0gaXNIZXgob3B0aW9ucy5jYWxsZXIpID8gb3B0aW9ucy5jYWxsZXIgOiBPdXRzaWRlRXhlY3V0aW9uQ2FsbGVyQW55O1xuICAgIGNvbnN0IG15Q2FsbHMgPSBBcnJheS5pc0FycmF5KGNhbGxzKSA/IGNhbGxzIDogW2NhbGxzXTtcbiAgICBjb25zdCBzdXBwb3J0ZWRWZXJzaW9uID0gdmVyc2lvbiA/PyBhd2FpdCB0aGlzLmdldFNuaXA5VmVyc2lvbigpO1xuICAgIGlmICghc3VwcG9ydGVkVmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBhY2NvdW50IGlzIG5vdCBoYW5kbGluZyBvdXRzaWRlIHRyYW5zYWN0aW9ucy5cIik7XG4gICAgfVxuICAgIGNvbnN0IG15Tm9uY2UgPSBub25jZSA/IHRvSGV4KG5vbmNlKSA6IGF3YWl0IHRoaXMuZ2V0U25pcDlOb25jZSgpO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRUeXBlZERhdGEoXG4gICAgICBhd2FpdCB0aGlzLmdldENoYWluSWQoKSxcbiAgICAgIHtcbiAgICAgICAgY2FsbGVyOiBjb2RlZENhbGxlcixcbiAgICAgICAgZXhlY3V0ZV9hZnRlcjogb3B0aW9ucy5leGVjdXRlX2FmdGVyLFxuICAgICAgICBleGVjdXRlX2JlZm9yZTogb3B0aW9ucy5leGVjdXRlX2JlZm9yZVxuICAgICAgfSxcbiAgICAgIG15Tm9uY2UsXG4gICAgICBteUNhbGxzLFxuICAgICAgc3VwcG9ydGVkVmVyc2lvblxuICAgICk7XG4gICAgY29uc3Qgc2lnbiA9IGF3YWl0IHRoaXMuc2lnbk1lc3NhZ2UobWVzc2FnZSk7XG4gICAgY29uc3QgdG9FeGVjdXRlID0ge1xuICAgICAgY2FsbGVyOiBjb2RlZENhbGxlcixcbiAgICAgIG5vbmNlOiBteU5vbmNlLFxuICAgICAgZXhlY3V0ZV9hZnRlcjogb3B0aW9ucy5leGVjdXRlX2FmdGVyLFxuICAgICAgZXhlY3V0ZV9iZWZvcmU6IG9wdGlvbnMuZXhlY3V0ZV9iZWZvcmUsXG4gICAgICBjYWxsczogbXlDYWxscy5tYXAoZ2V0T3V0c2lkZUNhbGwpXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgb3V0c2lkZUV4ZWN1dGlvbjogdG9FeGVjdXRlLFxuICAgICAgc2lnbmF0dXJlOiBzaWduLFxuICAgICAgc2lnbmVyQWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgdmVyc2lvbjogc3VwcG9ydGVkVmVyc2lvblxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEFuIGFjY291bnQgQiBleGVjdXRlcyBhIHRyYW5zYWN0aW9uIHRoYXQgaGFzIGJlZW4gc2lnbmVkIGJ5IGFuIGFjY291bnQgQS5cbiAgICogRmVlcyBhcmUgcGFpZCBieSBCLlxuICAgKiBAcGFyYW0ge0FsbG93QXJyYXk8T3V0c2lkZVRyYW5zYWN0aW9uPn0gb3V0c2lkZVRyYW5zYWN0aW9uIHRoZSBzaWduZWQgdHJhbnNhY3Rpb24gZ2VuZXJhdGVkIGJ5IGBBY2NvdW50LmdldE91dHNpZGVUcmFuc2FjdGlvbigpYC5cbiAgICogQHBhcmFtIHtVbml2ZXJzYWxEZXRhaWxzfSBbb3B0c10gc2FtZSBvcHRpb25zIHRoYW4gYEFjY291bnQuZXhlY3V0ZSgpYC5cbiAgICogQHJldHVybnMge0ludm9rZUZ1bmN0aW9uUmVzcG9uc2V9IHNhbWUgcmVzcG9uc2UgdGhhbiBgQWNjb3VudC5leGVjdXRlKClgLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IG91dHNpZGVUcmFuc2FjdGlvbjE6IE91dHNpZGVUcmFuc2FjdGlvbiA9IGF3YWl0IHNpZ25lckFjY291bnQuZ2V0T3V0c2lkZVRyYW5zYWN0aW9uKGNhbGxPcHRpb25zLCBjYWxsMSk7XG4gICAqIGNvbnN0IG91dHNpZGVUcmFuc2FjdGlvbjI6IE91dHNpZGVUcmFuc2FjdGlvbiA9IGF3YWl0IHNpZ25lckFjY291bnQuZ2V0T3V0c2lkZVRyYW5zYWN0aW9uKGNhbGxPcHRpb25zNCwgY2FsbDQpO1xuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBteUFjY291bnQuZXhlY3V0ZUZyb21PdXRzaWRlKFtcbiAgICAgIG91dHNpZGVUcmFuc2FjdGlvbjEsXG4gICAgICBvdXRzaWRlVHJhbnNhY3Rpb24yLFxuICAgIF0pO1xuICAgKiAvLyByZXN1bHQgPSB7IHRyYW5zYWN0aW9uX2hhc2g6ICcweDExMjMzLi4uYH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBleGVjdXRlRnJvbU91dHNpZGUob3V0c2lkZVRyYW5zYWN0aW9uLCBvcHRzKSB7XG4gICAgY29uc3QgbXVsdGlDYWxsID0gYnVpbGRFeGVjdXRlRnJvbU91dHNpZGVDYWxsKG91dHNpZGVUcmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShtdWx0aUNhbGwsIG9wdHMpO1xuICB9XG4gIC8qXG4gICAqIFN1cHBvcnQgbWV0aG9kc1xuICAgKi9cbiAgYXN5bmMgZ2V0VW5pdmVyc2FsU3VnZ2VzdGVkRmVlKHZlcnNpb24sIHsgdHlwZSwgcGF5bG9hZCB9LCBkZXRhaWxzKSB7XG4gICAgbGV0IG1heEZlZSA9IDA7XG4gICAgbGV0IHJlc291cmNlQm91bmRzID0gZXN0aW1hdGVGZWVUb0JvdW5kcyhaRVJPKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMykge1xuICAgICAgcmVzb3VyY2VCb3VuZHMgPSBkZXRhaWxzLnJlc291cmNlQm91bmRzID8/IChhd2FpdCB0aGlzLmdldFN1Z2dlc3RlZEZlZSh7IHR5cGUsIHBheWxvYWQgfSwgZGV0YWlscykpLnJlc291cmNlQm91bmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhGZWUgPSBkZXRhaWxzLm1heEZlZSA/PyAoYXdhaXQgdGhpcy5nZXRTdWdnZXN0ZWRGZWUoeyB0eXBlLCBwYXlsb2FkIH0sIGRldGFpbHMpKS5zdWdnZXN0ZWRNYXhGZWU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtYXhGZWUsXG4gICAgICByZXNvdXJjZUJvdW5kc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZ2V0U3VnZ2VzdGVkRmVlKHsgdHlwZSwgcGF5bG9hZCB9LCBkZXRhaWxzKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5JTlZPS0U6XG4gICAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlSW52b2tlRmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuREVDTEFSRTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVEZWNsYXJlRmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQ6XG4gICAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlQWNjb3VudERlcGxveUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkRFUExPWTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVEZXBsb3lGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGdhc19jb25zdW1lZDogMG4sXG4gICAgICAgICAgZ2FzX3ByaWNlOiAwbixcbiAgICAgICAgICBvdmVyYWxsX2ZlZTogWkVSTyxcbiAgICAgICAgICB1bml0OiBcIkZSSVwiLFxuICAgICAgICAgIHN1Z2dlc3RlZE1heEZlZTogWkVSTyxcbiAgICAgICAgICByZXNvdXJjZUJvdW5kczogZXN0aW1hdGVGZWVUb0JvdW5kcyhaRVJPKSxcbiAgICAgICAgICBkYXRhX2dhc19jb25zdW1lZDogMG4sXG4gICAgICAgICAgZGF0YV9nYXNfcHJpY2U6IDBuXG4gICAgICAgIH07XG4gICAgfVxuICB9XG4gIGFzeW5jIGJ1aWxkSW52b2NhdGlvbihjYWxsLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRFeGVjdXRlQ2FsbGRhdGEoY2FsbCwgYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gIWRldGFpbHMuc2tpcFZhbGlkYXRlID8gYXdhaXQgdGhpcy5zaWduZXIuc2lnblRyYW5zYWN0aW9uKGNhbGwsIGRldGFpbHMpIDogW107XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgY2FsbGRhdGEsXG4gICAgICBzaWduYXR1cmVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGJ1aWxkRGVjbGFyZVBheWxvYWQocGF5bG9hZCwgZGV0YWlscykge1xuICAgIGNvbnN0IHsgY2xhc3NIYXNoLCBjb250cmFjdCwgY29tcGlsZWRDbGFzc0hhc2ggfSA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICBjb25zdCBjb21wcmVzc2VkQ29tcGlsZWRDb250cmFjdCA9IHBhcnNlQ29udHJhY3QoY29udHJhY3QpO1xuICAgIGlmIChpc1VuZGVmaW5lZChjb21waWxlZENsYXNzSGFzaCkgJiYgKGRldGFpbHMudmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMuRjMgfHwgZGV0YWlscy52ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMy5WMykpIHtcbiAgICAgIHRocm93IEVycm9yKFwiVjMgVHJhbnNhY3Rpb24gd29yayB3aXRoIENhaXJvMSBDb250cmFjdHMgYW5kIHJlcXVpcmUgY29tcGlsZWRDbGFzc0hhc2hcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICFkZXRhaWxzLnNraXBWYWxpZGF0ZSA/IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oe1xuICAgICAgLi4uZGV0YWlscyxcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgLy8gVE9ETzogVFMsIGNhc3QgYmVjYXVzZSBvcHRpb25hbCBmb3IgdjIgYW5kIHJlcXVpcmVkIGZvciB2MywgdGhyb3duIGlmIG5vdCBwcmVzZW50XG4gICAgICBzZW5kZXJBZGRyZXNzOiBkZXRhaWxzLndhbGxldEFkZHJlc3NcbiAgICB9KSA6IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBzZW5kZXJBZGRyZXNzOiBkZXRhaWxzLndhbGxldEFkZHJlc3MsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBjb250cmFjdDogY29tcHJlc3NlZENvbXBpbGVkQ29udHJhY3QsXG4gICAgICBjb21waWxlZENsYXNzSGFzaFxuICAgIH07XG4gIH1cbiAgYXN5bmMgYnVpbGRBY2NvdW50RGVwbG95UGF5bG9hZCh7XG4gICAgY2xhc3NIYXNoLFxuICAgIGFkZHJlc3NTYWx0ID0gMCxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW10sXG4gICAgY29udHJhY3RBZGRyZXNzOiBwcm92aWRlZENvbnRyYWN0QWRkcmVzc1xuICB9LCBkZXRhaWxzKSB7XG4gICAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gcHJvdmlkZWRDb250cmFjdEFkZHJlc3MgPz8gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goYWRkcmVzc1NhbHQsIGNsYXNzSGFzaCwgY29tcGlsZWRDYWxsZGF0YSwgMCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gIWRldGFpbHMuc2tpcFZhbGlkYXRlID8gYXdhaXQgdGhpcy5zaWduZXIuc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbih7XG4gICAgICAuLi5kZXRhaWxzLFxuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhXG4gICAgfSkgOiBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbiAgfVxuICBidWlsZFVEQ0NvbnRyYWN0UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgY29uc3QgY2FsbHMgPSBbXS5jb25jYXQocGF5bG9hZCkubWFwKChpdCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgIHNhbHQgPSBcIjBcIixcbiAgICAgICAgdW5pcXVlID0gdHJ1ZSxcbiAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdXG4gICAgICB9ID0gaXQ7XG4gICAgICBjb25zdCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBVREMuQUREUkVTUyxcbiAgICAgICAgZW50cnlwb2ludDogVURDLkVOVFJZUE9JTlQsXG4gICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIHNhbHQsXG4gICAgICAgICAgdG9DYWlyb0Jvb2wodW5pcXVlKSxcbiAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEubGVuZ3RoLFxuICAgICAgICAgIC4uLmNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBjYWxscztcbiAgfVxuICBhc3luYyBhY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgeyBub25jZSwgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSB0cnVlIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IHNhZmVOb25jZSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2VTYWZlKG5vbmNlKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgdmVyc2lvbnMgPSBkZXRhaWxzLnZlcnNpb25zLm1hcCgoaXQpID0+IHRvVHJhbnNhY3Rpb25WZXJzaW9uKGl0KSk7XG4gICAgY29uc3QgdHgwUGF5bG9hZCA9IFwicGF5bG9hZFwiIGluIGludm9jYXRpb25zWzBdID8gaW52b2NhdGlvbnNbMF0ucGF5bG9hZCA6IGludm9jYXRpb25zWzBdO1xuICAgIGNvbnN0IGNhaXJvVmVyc2lvbiA9IGludm9jYXRpb25zWzBdLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5ERVBMT1lfQUNDT1VOVCA/IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKHR4MFBheWxvYWQuY2xhc3NIYXNoKSA6IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgW10uY29uY2F0KGludm9jYXRpb25zKS5tYXAoYXN5bmMgKHRyYW5zYWN0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB0eFBheWxvYWQgPSBcInBheWxvYWRcIiBpbiB0cmFuc2FjdGlvbiA/IHRyYW5zYWN0aW9uLnBheWxvYWQgOiB0cmFuc2FjdGlvbjtcbiAgICAgICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgIG5vbmNlOiB0b0JpZ0ludChOdW1iZXIoc2FmZU5vbmNlKSArIGluZGV4KSxcbiAgICAgICAgICBtYXhGZWU6IFpFUk8sXG4gICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICBjYWlyb1ZlcnNpb24sXG4gICAgICAgICAgdmVyc2lvbjogXCJcIixcbiAgICAgICAgICBza2lwVmFsaWRhdGVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tbW9uID0ge1xuICAgICAgICAgIHR5cGU6IHRyYW5zYWN0aW9uLnR5cGUsXG4gICAgICAgICAgbm9uY2U6IHRvQmlnSW50KE51bWJlcihzYWZlTm9uY2UpICsgaW5kZXgpLFxuICAgICAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgICAgICB2ZXJzaW9uOiBcIlwiXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuSU5WT0tFKSB7XG4gICAgICAgICAgY29uc3QgdmVyc2lvblggPSByZWR1Y2VWMih2ZXJzaW9uc1sxXSk7XG4gICAgICAgICAgc2lnbmVyRGV0YWlscy52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29tbW9uLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24oXG4gICAgICAgICAgICBbXS5jb25jYXQodHhQYXlsb2FkKSxcbiAgICAgICAgICAgIHNpZ25lckRldGFpbHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAgICAgLi4uc2lnbmVyRGV0YWlsc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5ERVBMT1kpIHtcbiAgICAgICAgICBjb25zdCB2ZXJzaW9uWCA9IHJlZHVjZVYyKHZlcnNpb25zWzFdKTtcbiAgICAgICAgICBzaWduZXJEZXRhaWxzLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb21tb24udmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbnN0IGNhbGxzID0gdGhpcy5idWlsZFVEQ0NvbnRyYWN0UGF5bG9hZCh0eFBheWxvYWQpO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkSW52b2NhdGlvbihjYWxscywgc2lnbmVyRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICAuLi5zaWduZXJEZXRhaWxzLFxuICAgICAgICAgICAgdHlwZTogVHJhbnNhY3Rpb25UeXBlLklOVk9LRVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFKSB7XG4gICAgICAgICAgY29uc3QgdmVyc2lvblggPSAhaXNTaWVycmEodHhQYXlsb2FkLmNvbnRyYWN0KSA/IHZlcnNpb25zWzBdIDogdmVyc2lvbnNbMV07XG4gICAgICAgICAgc2lnbmVyRGV0YWlscy52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29tbW9uLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZERlY2xhcmVQYXlsb2FkKHR4UGF5bG9hZCwgc2lnbmVyRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICAuLi5zaWduZXJEZXRhaWxzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkRFUExPWV9BQ0NPVU5UKSB7XG4gICAgICAgICAgY29uc3QgdmVyc2lvblggPSByZWR1Y2VWMih2ZXJzaW9uc1sxXSk7XG4gICAgICAgICAgc2lnbmVyRGV0YWlscy52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29tbW9uLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEFjY291bnREZXBsb3lQYXlsb2FkKHR4UGF5bG9hZCwgc2lnbmVyRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICAuLi5zaWduZXJEZXRhaWxzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBFcnJvcihgYWNjb3VudEludm9jYXRpb25zRmFjdG9yeTogdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHt0cmFuc2FjdGlvbn1gKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRTdGFya05hbWUoYWRkcmVzcyA9IHRoaXMuYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBzdXBlci5nZXRTdGFya05hbWUoYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbn07XG5cbi8vIHNyYy9hY2NvdW50L2ludGVyZmFjZS50c1xudmFyIEFjY291bnRJbnRlcmZhY2UgPSBjbGFzcyBleHRlbmRzIFByb3ZpZGVySW50ZXJmYWNlIHtcbn07XG5cbi8vIHNyYy93YWxsZXQvY29ubmVjdC50c1xudmFyIGNvbm5lY3RfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY29ubmVjdF9leHBvcnRzLCB7XG4gIGFkZERlY2xhcmVUcmFuc2FjdGlvbjogKCkgPT4gYWRkRGVjbGFyZVRyYW5zYWN0aW9uLFxuICBhZGRJbnZva2VUcmFuc2FjdGlvbjogKCkgPT4gYWRkSW52b2tlVHJhbnNhY3Rpb24sXG4gIGFkZFN0YXJrbmV0Q2hhaW46ICgpID0+IGFkZFN0YXJrbmV0Q2hhaW4sXG4gIGRlcGxveW1lbnREYXRhOiAoKSA9PiBkZXBsb3ltZW50RGF0YSxcbiAgZ2V0UGVybWlzc2lvbnM6ICgpID0+IGdldFBlcm1pc3Npb25zLFxuICBvbkFjY291bnRDaGFuZ2U6ICgpID0+IG9uQWNjb3VudENoYW5nZSxcbiAgb25OZXR3b3JrQ2hhbmdlZDogKCkgPT4gb25OZXR3b3JrQ2hhbmdlZCxcbiAgcmVxdWVzdEFjY291bnRzOiAoKSA9PiByZXF1ZXN0QWNjb3VudHMsXG4gIHJlcXVlc3RDaGFpbklkOiAoKSA9PiByZXF1ZXN0Q2hhaW5JZCxcbiAgc2lnbk1lc3NhZ2U6ICgpID0+IHNpZ25NZXNzYWdlLFxuICBzdXBwb3J0ZWRTcGVjczogKCkgPT4gc3VwcG9ydGVkU3BlY3MsXG4gIHN3aXRjaFN0YXJrbmV0Q2hhaW46ICgpID0+IHN3aXRjaFN0YXJrbmV0Q2hhaW4sXG4gIHdhdGNoQXNzZXQ6ICgpID0+IHdhdGNoQXNzZXRcbn0pO1xuZnVuY3Rpb24gcmVxdWVzdEFjY291bnRzKHN3bywgc2lsZW50X21vZGUgPSBmYWxzZSkge1xuICByZXR1cm4gc3dvLnJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X3JlcXVlc3RBY2NvdW50c1wiLFxuICAgIHBhcmFtczogeyBzaWxlbnRfbW9kZSB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UGVybWlzc2lvbnMoc3dvKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7IHR5cGU6IFwid2FsbGV0X2dldFBlcm1pc3Npb25zXCIgfSk7XG59XG5mdW5jdGlvbiB3YXRjaEFzc2V0KHN3bywgYXNzZXQpIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHsgdHlwZTogXCJ3YWxsZXRfd2F0Y2hBc3NldFwiLCBwYXJhbXM6IGFzc2V0IH0pO1xufVxuZnVuY3Rpb24gYWRkU3RhcmtuZXRDaGFpbihzd28sIGNoYWluKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7IHR5cGU6IFwid2FsbGV0X2FkZFN0YXJrbmV0Q2hhaW5cIiwgcGFyYW1zOiBjaGFpbiB9KTtcbn1cbmZ1bmN0aW9uIHN3aXRjaFN0YXJrbmV0Q2hhaW4oc3dvLCBjaGFpbklkKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfc3dpdGNoU3RhcmtuZXRDaGFpblwiLFxuICAgIHBhcmFtczogeyBjaGFpbklkIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXF1ZXN0Q2hhaW5JZChzd28pIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHsgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdENoYWluSWRcIiB9KTtcbn1cbmZ1bmN0aW9uIGRlcGxveW1lbnREYXRhKHN3bykge1xuICByZXR1cm4gc3dvLnJlcXVlc3QoeyB0eXBlOiBcIndhbGxldF9kZXBsb3ltZW50RGF0YVwiIH0pO1xufVxuZnVuY3Rpb24gYWRkSW52b2tlVHJhbnNhY3Rpb24oc3dvLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHsgdHlwZTogXCJ3YWxsZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIiwgcGFyYW1zIH0pO1xufVxuZnVuY3Rpb24gYWRkRGVjbGFyZVRyYW5zYWN0aW9uKHN3bywgcGFyYW1zKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7IHR5cGU6IFwid2FsbGV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCBwYXJhbXMgfSk7XG59XG5mdW5jdGlvbiBzaWduTWVzc2FnZShzd28sIHR5cGVkRGF0YSkge1xuICByZXR1cm4gc3dvLnJlcXVlc3QoeyB0eXBlOiBcIndhbGxldF9zaWduVHlwZWREYXRhXCIsIHBhcmFtczogdHlwZWREYXRhIH0pO1xufVxuZnVuY3Rpb24gc3VwcG9ydGVkU3BlY3Moc3dvKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7IHR5cGU6IFwid2FsbGV0X3N1cHBvcnRlZFNwZWNzXCIgfSk7XG59XG5mdW5jdGlvbiBvbkFjY291bnRDaGFuZ2Uoc3dvLCBjYWxsYmFjaykge1xuICBzd28ub24oXCJhY2NvdW50c0NoYW5nZWRcIiwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gb25OZXR3b3JrQ2hhbmdlZChzd28sIGNhbGxiYWNrKSB7XG4gIHN3by5vbihcIm5ldHdvcmtDaGFuZ2VkXCIsIGNhbGxiYWNrKTtcbn1cblxuLy8gc3JjL3dhbGxldC9hY2NvdW50LnRzXG52YXIgV2FsbGV0QWNjb3VudCA9IGNsYXNzIF9XYWxsZXRBY2NvdW50IGV4dGVuZHMgQWNjb3VudCB7XG4gIHdhbGxldFByb3ZpZGVyO1xuICBjb25zdHJ1Y3Rvcihwcm92aWRlck9yT3B0aW9ucywgd2FsbGV0UHJvdmlkZXIsIGNhaXJvVmVyc2lvbiwgYWRkcmVzcyA9IFwiXCIpIHtcbiAgICBzdXBlcihwcm92aWRlck9yT3B0aW9ucywgYWRkcmVzcywgXCJcIiwgY2Fpcm9WZXJzaW9uKTtcbiAgICB0aGlzLndhbGxldFByb3ZpZGVyID0gd2FsbGV0UHJvdmlkZXI7XG4gICAgdGhpcy53YWxsZXRQcm92aWRlci5vbihcImFjY291bnRzQ2hhbmdlZFwiLCAocmVzKSA9PiB7XG4gICAgICBpZiAoIXJlcykgcmV0dXJuO1xuICAgICAgdGhpcy5hZGRyZXNzID0gcmVzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgdGhpcy53YWxsZXRQcm92aWRlci5vbihcIm5ldHdvcmtDaGFuZ2VkXCIsIChyZXMpID0+IHtcbiAgICAgIGlmICghcmVzKSByZXR1cm47XG4gICAgICB0aGlzLmNoYW5uZWwuc2V0Q2hhaW5JZChyZXMpO1xuICAgIH0pO1xuICAgIGlmICghYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICBcIkBkZXByZWNhdGVkIFVzZSBzdGF0aWMgbWV0aG9kIFdhbGxldEFjY291bnQuY29ubmVjdCBvciBXYWxsZXRBY2NvdW50LmNvbm5lY3RTaWxlbnQgaW5zdGVhZC4gQ29uc3RydWN0b3Ige0BsaW5rIFdhbGxldEFjY291bnQuKGZvcm1hdDoyKX0uXCJcbiAgICAgICk7XG4gICAgICByZXF1ZXN0QWNjb3VudHModGhpcy53YWxsZXRQcm92aWRlcikudGhlbigoW2FjY291bnRBZGRyZXNzXSkgPT4ge1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhY2NvdW50QWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBXQUxMRVQgRVZFTlRTXG4gICAqL1xuICBvbkFjY291bnRDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICBvbkFjY291bnRDaGFuZ2UodGhpcy53YWxsZXRQcm92aWRlciwgY2FsbGJhY2spO1xuICB9XG4gIG9uTmV0d29ya0NoYW5nZWQoY2FsbGJhY2spIHtcbiAgICBvbk5ldHdvcmtDaGFuZ2VkKHRoaXMud2FsbGV0UHJvdmlkZXIsIGNhbGxiYWNrKTtcbiAgfVxuICAvKipcbiAgICogV0FMTEVUIFNQRUNJRklDIE1FVEhPRFNcbiAgICovXG4gIHJlcXVlc3RBY2NvdW50cyhzaWxlbnRNb2RlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gcmVxdWVzdEFjY291bnRzKHRoaXMud2FsbGV0UHJvdmlkZXIsIHNpbGVudE1vZGUpO1xuICB9XG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiBnZXRQZXJtaXNzaW9ucyh0aGlzLndhbGxldFByb3ZpZGVyKTtcbiAgfVxuICBzd2l0Y2hTdGFya25ldENoYWluKGNoYWluSWQpIHtcbiAgICByZXR1cm4gc3dpdGNoU3RhcmtuZXRDaGFpbih0aGlzLndhbGxldFByb3ZpZGVyLCBjaGFpbklkKTtcbiAgfVxuICB3YXRjaEFzc2V0KGFzc2V0KSB7XG4gICAgcmV0dXJuIHdhdGNoQXNzZXQodGhpcy53YWxsZXRQcm92aWRlciwgYXNzZXQpO1xuICB9XG4gIGFkZFN0YXJrbmV0Q2hhaW4oY2hhaW4pIHtcbiAgICByZXR1cm4gYWRkU3RhcmtuZXRDaGFpbih0aGlzLndhbGxldFByb3ZpZGVyLCBjaGFpbik7XG4gIH1cbiAgLyoqXG4gICAqIEFDQ09VTlQgTUVUSE9EU1xuICAgKi9cbiAgZXhlY3V0ZShjYWxscykge1xuICAgIGNvbnN0IHR4Q2FsbHMgPSBbXS5jb25jYXQoY2FsbHMpLm1hcCgoaXQpID0+IHtcbiAgICAgIGNvbnN0IHsgY29udHJhY3RBZGRyZXNzLCBlbnRyeXBvaW50LCBjYWxsZGF0YSB9ID0gaXQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250cmFjdF9hZGRyZXNzOiBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGVudHJ5X3BvaW50OiBlbnRyeXBvaW50LFxuICAgICAgICBjYWxsZGF0YVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBjYWxsczogdHhDYWxsc1xuICAgIH07XG4gICAgcmV0dXJuIGFkZEludm9rZVRyYW5zYWN0aW9uKHRoaXMud2FsbGV0UHJvdmlkZXIsIHBhcmFtcyk7XG4gIH1cbiAgZGVjbGFyZShwYXlsb2FkKSB7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICBjb25zdCBwQ29udHJhY3QgPSBwYXlsb2FkLmNvbnRyYWN0O1xuICAgIGNvbnN0IGNhaXJvMUNvbnRyYWN0ID0ge1xuICAgICAgLi4ucENvbnRyYWN0LFxuICAgICAgYWJpOiBzdHJpbmdpZnkyKHBDb250cmFjdC5hYmkpXG4gICAgfTtcbiAgICBpZiAoIWRlY2xhcmVDb250cmFjdFBheWxvYWQuY29tcGlsZWRDbGFzc0hhc2gpIHtcbiAgICAgIHRocm93IEVycm9yKFwiY29tcGlsZWRDbGFzc0hhc2ggaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGRlY2xhcmVDb250cmFjdFBheWxvYWQuY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICBjb250cmFjdF9jbGFzczogY2Fpcm8xQ29udHJhY3RcbiAgICB9O1xuICAgIHJldHVybiBhZGREZWNsYXJlVHJhbnNhY3Rpb24odGhpcy53YWxsZXRQcm92aWRlciwgcGFyYW1zKTtcbiAgfVxuICBhc3luYyBkZXBsb3kocGF5bG9hZCkge1xuICAgIGNvbnN0IHsgY2FsbHMsIGFkZHJlc3NlcyB9ID0gYnVpbGRVRENDYWxsKHBheWxvYWQsIHRoaXMuYWRkcmVzcyk7XG4gICAgY29uc3QgaW52b2tlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGUoY2FsbHMpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pbnZva2VSZXNwb25zZSxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGFkZHJlc3Nlc1xuICAgIH07XG4gIH1cbiAgc2lnbk1lc3NhZ2UodHlwZWREYXRhKSB7XG4gICAgcmV0dXJuIHNpZ25NZXNzYWdlKHRoaXMud2FsbGV0UHJvdmlkZXIsIHR5cGVkRGF0YSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3QocHJvdmlkZXIsIHdhbGxldFByb3ZpZGVyLCBjYWlyb1ZlcnNpb24sIHNpbGVudE1vZGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IFthY2NvdW50QWRkcmVzc10gPSBhd2FpdCByZXF1ZXN0QWNjb3VudHMod2FsbGV0UHJvdmlkZXIsIHNpbGVudE1vZGUpO1xuICAgIHJldHVybiBuZXcgX1dhbGxldEFjY291bnQocHJvdmlkZXIsIHdhbGxldFByb3ZpZGVyLCBjYWlyb1ZlcnNpb24sIGFjY291bnRBZGRyZXNzKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY29ubmVjdFNpbGVudChwcm92aWRlciwgd2FsbGV0UHJvdmlkZXIsIGNhaXJvVmVyc2lvbikge1xuICAgIHJldHVybiBfV2FsbGV0QWNjb3VudC5jb25uZWN0KHByb3ZpZGVyLCB3YWxsZXRQcm92aWRlciwgY2Fpcm9WZXJzaW9uLCB0cnVlKTtcbiAgfVxuICAvLyBUT0RPOiBNSVNTSU5HIEVTVElNQVRFU1xufTtcblxuLy8gc3JjL2NvbnRyYWN0L2RlZmF1bHQudHNcbnZhciBzcGxpdEFyZ3NBbmRPcHRpb25zID0gKGFyZ3MpID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IFtcbiAgICBcImJsb2NrSWRlbnRpZmllclwiLFxuICAgIFwicGFyc2VSZXF1ZXN0XCIsXG4gICAgXCJwYXJzZVJlc3BvbnNlXCIsXG4gICAgXCJmb3JtYXRSZXNwb25zZVwiLFxuICAgIFwibWF4RmVlXCIsXG4gICAgXCJub25jZVwiLFxuICAgIFwic2lnbmF0dXJlXCIsXG4gICAgXCJhZGRyZXNzU2FsdFwiXG4gIF07XG4gIGNvbnN0IGxhc3RBcmcgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gIGlmICh0eXBlb2YgbGFzdEFyZyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLnNvbWUoKHgpID0+IHggaW4gbGFzdEFyZykpIHtcbiAgICByZXR1cm4geyBhcmdzLCBvcHRpb25zOiBhcmdzLnBvcCgpIH07XG4gIH1cbiAgcmV0dXJuIHsgYXJncyB9O1xufTtcbmZ1bmN0aW9uIGJ1aWxkQ2FsbChjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzcGxpdEFyZ3NBbmRPcHRpb25zKGFyZ3MpO1xuICAgIHJldHVybiBjb250cmFjdC5jYWxsKGZ1bmN0aW9uQWJpLm5hbWUsIHBhcmFtcy5hcmdzLCB7XG4gICAgICBwYXJzZVJlcXVlc3Q6IHRydWUsXG4gICAgICBwYXJzZVJlc3BvbnNlOiB0cnVlLFxuICAgICAgLi4ucGFyYW1zLm9wdGlvbnNcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkSW52b2tlKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0QXJnc0FuZE9wdGlvbnMoYXJncyk7XG4gICAgcmV0dXJuIGNvbnRyYWN0Lmludm9rZShmdW5jdGlvbkFiaS5uYW1lLCBwYXJhbXMuYXJncywge1xuICAgICAgcGFyc2VSZXF1ZXN0OiB0cnVlLFxuICAgICAgLi4ucGFyYW1zLm9wdGlvbnNcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGVmYXVsdChjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgaWYgKGZ1bmN0aW9uQWJpLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgZnVuY3Rpb25BYmkuc3RhdGVfbXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIpIHtcbiAgICByZXR1cm4gYnVpbGRDYWxsKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSk7XG4gIH1cbiAgcmV0dXJuIGJ1aWxkSW52b2tlKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSk7XG59XG5mdW5jdGlvbiBidWlsZFBvcHVsYXRlKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBjb250cmFjdC5wb3B1bGF0ZShmdW5jdGlvbkFiaS5uYW1lLCBhcmdzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXN0aW1hdGUoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGNvbnRyYWN0LmVzdGltYXRlKGZ1bmN0aW9uQWJpLm5hbWUsIGFyZ3MpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2FsbGRhdGEoYXJncywgY2FsbGJhY2spIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgXCJfX2NvbXBpbGVkX19cIiBpbiBhcmdzKSByZXR1cm4gYXJncztcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgQXJyYXkuaXNBcnJheShhcmdzWzBdKSAmJiBcIl9fY29tcGlsZWRfX1wiIGluIGFyZ3NbMF0pXG4gICAgcmV0dXJuIGFyZ3NbMF07XG4gIHJldHVybiBjYWxsYmFjaygpO1xufVxudmFyIENvbnRyYWN0ID0gY2xhc3Mge1xuICBhYmk7XG4gIGFkZHJlc3M7XG4gIHByb3ZpZGVyT3JBY2NvdW50O1xuICBkZXBsb3lUcmFuc2FjdGlvbkhhc2g7XG4gIHN0cnVjdHM7XG4gIGV2ZW50cztcbiAgZnVuY3Rpb25zO1xuICBjYWxsU3RhdGljO1xuICBwb3B1bGF0ZVRyYW5zYWN0aW9uO1xuICBlc3RpbWF0ZUZlZTtcbiAgY2FsbERhdGE7XG4gIC8qKlxuICAgKiBDb250cmFjdCBjbGFzcyB0byBoYW5kbGUgY29udHJhY3QgbWV0aG9kc1xuICAgKlxuICAgKiBAcGFyYW0gYWJpIC0gQWJpIG9mIHRoZSBjb250cmFjdCBvYmplY3RcbiAgICogQHBhcmFtIGFkZHJlc3MgKG9wdGlvbmFsKSAtIGFkZHJlc3MgdG8gY29ubmVjdCB0b1xuICAgKiBAcGFyYW0gcHJvdmlkZXJPckFjY291bnQgKG9wdGlvbmFsKSAtIFByb3ZpZGVyIG9yIEFjY291bnQgdG8gYXR0YWNoIHRvXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhYmksIGFkZHJlc3MsIHByb3ZpZGVyT3JBY2NvdW50ID0gZGVmYXVsdFByb3ZpZGVyKSB7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcyAmJiBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm92aWRlck9yQWNjb3VudCA9IHByb3ZpZGVyT3JBY2NvdW50O1xuICAgIHRoaXMuY2FsbERhdGEgPSBuZXcgQ2FsbERhdGEoYWJpKTtcbiAgICB0aGlzLnN0cnVjdHMgPSBDYWxsRGF0YS5nZXRBYmlTdHJ1Y3QoYWJpKTtcbiAgICB0aGlzLmV2ZW50cyA9IGdldEFiaUV2ZW50cyhhYmkpO1xuICAgIGNvbnN0IHBhcnNlciA9IGNyZWF0ZUFiaVBhcnNlcihhYmkpO1xuICAgIHRoaXMuYWJpID0gcGFyc2VyLmdldExlZ2FjeUZvcm1hdCgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgZnVuY3Rpb25zOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBjYWxsU3RhdGljOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBlc3RpbWF0ZUZlZTogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9XG4gICAgfSk7XG4gICAgdGhpcy5hYmkuZm9yRWFjaCgoYWJpRWxlbWVudCkgPT4ge1xuICAgICAgaWYgKGFiaUVsZW1lbnQudHlwZSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm47XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhYmlFbGVtZW50Lm5hbWU7XG4gICAgICBpZiAoIXRoaXNbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGREZWZhdWx0KHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmZ1bmN0aW9uc1tzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmZ1bmN0aW9ucywgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGREZWZhdWx0KHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5jYWxsU3RhdGljLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZENhbGwodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkUG9wdWxhdGUodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZXN0aW1hdGVGZWVbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lc3RpbWF0ZUZlZSwgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGRFc3RpbWF0ZSh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhdHRhY2goYWRkcmVzcykge1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gIH1cbiAgY29ubmVjdChwcm92aWRlck9yQWNjb3VudCkge1xuICAgIHRoaXMucHJvdmlkZXJPckFjY291bnQgPSBwcm92aWRlck9yQWNjb3VudDtcbiAgfVxuICBhc3luYyBkZXBsb3llZCgpIHtcbiAgICBpZiAodGhpcy5kZXBsb3lUcmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXJPckFjY291bnQud2FpdEZvclRyYW5zYWN0aW9uKHRoaXMuZGVwbG95VHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgIHRoaXMuZGVwbG95VHJhbnNhY3Rpb25IYXNoID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhc3luYyBjYWxsKG1ldGhvZCwgYXJncyA9IFtdLCB7XG4gICAgcGFyc2VSZXF1ZXN0ID0gdHJ1ZSxcbiAgICBwYXJzZVJlc3BvbnNlID0gdHJ1ZSxcbiAgICBmb3JtYXRSZXNwb25zZSA9IHZvaWQgMCxcbiAgICBibG9ja0lkZW50aWZpZXIgPSB2b2lkIDBcbiAgfSA9IHt9KSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB7XG4gICAgICBpZiAocGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoVmFsaWRhdGVUeXBlLkNBTEwsIG1ldGhvZCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci53YXJuKFwiQ2FsbCBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5jYWxsQ29udHJhY3QoXG4gICAgICB7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICBjYWxsZGF0YSxcbiAgICAgICAgZW50cnlwb2ludDogbWV0aG9kXG4gICAgICB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyXG4gICAgKS50aGVuKChpdCkgPT4ge1xuICAgICAgaWYgKCFwYXJzZVJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBpdDtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXRSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsRGF0YS5mb3JtYXQobWV0aG9kLCBpdCwgZm9ybWF0UmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEucGFyc2UobWV0aG9kLCBpdCk7XG4gICAgfSk7XG4gIH1cbiAgaW52b2tlKG1ldGhvZCwgYXJncyA9IFtdLCB7IHBhcnNlUmVxdWVzdCA9IHRydWUsIG1heEZlZSwgbm9uY2UsIHNpZ25hdHVyZSB9ID0ge30pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldENhbGxkYXRhKGFyZ3MsICgpID0+IHtcbiAgICAgIGlmIChwYXJzZVJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShWYWxpZGF0ZVR5cGUuSU5WT0tFLCBtZXRob2QsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsRGF0YS5jb21waWxlKG1ldGhvZCwgYXJncyk7XG4gICAgICB9XG4gICAgICBsb2dnZXIud2FybihcIkludm9rZSBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9KTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIGVudHJ5cG9pbnQ6IG1ldGhvZFxuICAgIH07XG4gICAgaWYgKFwiZXhlY3V0ZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmV4ZWN1dGUoaW52b2NhdGlvbiwgdm9pZCAwLCB7XG4gICAgICAgIG1heEZlZSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW5vbmNlKSB0aHJvdyBuZXcgRXJyb3IoYE5vbmNlIGlzIHJlcXVpcmVkIHdoZW4gaW52b2tpbmcgYSBmdW5jdGlvbiB3aXRob3V0IGFuIGFjY291bnRgKTtcbiAgICBsb2dnZXIud2FybihgSW52b2tpbmcgJHttZXRob2R9IHdpdGhvdXQgYW4gYWNjb3VudC4gVGhpcyB3aWxsIG5vdCB3b3JrIG9uIGEgcHVibGljIG5vZGUuYCk7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuaW52b2tlRnVuY3Rpb24oXG4gICAgICB7XG4gICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgIHNpZ25hdHVyZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbm9uY2VcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlKG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgaWYgKCFnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiBmYWxzZSkpIHtcbiAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoVmFsaWRhdGVUeXBlLklOVk9LRSwgbWV0aG9kLCBhcmdzKTtcbiAgICB9XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IHRoaXMucG9wdWxhdGUobWV0aG9kLCBhcmdzKTtcbiAgICBpZiAoXCJlc3RpbWF0ZUludm9rZUZlZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmVzdGltYXRlSW52b2tlRmVlKGludm9jYXRpb24pO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIkNvbnRyYWN0IG11c3QgYmUgY29ubmVjdGVkIHRvIHRoZSBhY2NvdW50IGNvbnRyYWN0IHRvIGVzdGltYXRlXCIpO1xuICB9XG4gIHBvcHVsYXRlKG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgZW50cnlwb2ludDogbWV0aG9kLFxuICAgICAgY2FsbGRhdGFcbiAgICB9O1xuICB9XG4gIHBhcnNlRXZlbnRzKHJlY2VpcHQpIHtcbiAgICBsZXQgcGFyc2VkO1xuICAgIHJlY2VpcHQubWF0Y2goe1xuICAgICAgc3VjY2VzczogKHR4UikgPT4ge1xuICAgICAgICBjb25zdCBlbWl0dGVkRXZlbnRzID0gdHhSLmV2ZW50cz8ubWFwKChldmVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9ja19oYXNoOiB0eFIuYmxvY2tfaGFzaCxcbiAgICAgICAgICAgIGJsb2NrX251bWJlcjogdHhSLmJsb2NrX251bWJlcixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IHR4Ui50cmFuc2FjdGlvbl9oYXNoLFxuICAgICAgICAgICAgLi4uZXZlbnRcbiAgICAgICAgICB9O1xuICAgICAgICB9KS5maWx0ZXIoKGV2ZW50KSA9PiBjbGVhbkhleChldmVudC5mcm9tX2FkZHJlc3MpID09PSBjbGVhbkhleCh0aGlzLmFkZHJlc3MpLCBbXSkgfHwgW107XG4gICAgICAgIHBhcnNlZCA9IHBhcnNlRXZlbnRzKFxuICAgICAgICAgIGVtaXR0ZWRFdmVudHMsXG4gICAgICAgICAgdGhpcy5ldmVudHMsXG4gICAgICAgICAgdGhpcy5zdHJ1Y3RzLFxuICAgICAgICAgIENhbGxEYXRhLmdldEFiaUVudW0odGhpcy5hYmkpXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgXzogKCkgPT4ge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlRoaXMgdHJhbnNhY3Rpb24gd2FzIG5vdCBzdWNjZXNzZnVsLlwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIGlzQ2Fpcm8xKCkge1xuICAgIHJldHVybiBjYWlyb19leHBvcnRzLmlzQ2Fpcm8xQWJpKHRoaXMuYWJpKTtcbiAgfVxuICBhc3luYyBnZXRWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmdldENvbnRyYWN0VmVyc2lvbih0aGlzLmFkZHJlc3MpO1xuICB9XG4gIHR5cGVkdjIodEFiaSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG4vLyBzcmMvY29udHJhY3QvaW50ZXJmYWNlLnRzXG52YXIgQ29udHJhY3RJbnRlcmZhY2UgPSBjbGFzcyB7XG4gIGZ1bmN0aW9ucztcbiAgY2FsbFN0YXRpYztcbiAgcG9wdWxhdGVUcmFuc2FjdGlvbjtcbiAgZXN0aW1hdGVGZWU7XG59O1xuXG4vLyBzcmMvY29udHJhY3QvY29udHJhY3RGYWN0b3J5LnRzXG52YXIgQ29udHJhY3RGYWN0b3J5ID0gY2xhc3Mge1xuICBjb21waWxlZENvbnRyYWN0O1xuICBhY2NvdW50O1xuICBhYmk7XG4gIGNsYXNzSGFzaDtcbiAgY2FzbTtcbiAgY29tcGlsZWRDbGFzc0hhc2g7XG4gIENhbGxEYXRhO1xuICAvKipcbiAgICogQHBhcmFtIHBhcmFtcyBDRlBhcmFtc1xuICAgKiAgLSBjb21waWxlZENvbnRyYWN0OiBDb21waWxlZENvbnRyYWN0O1xuICAgKiAgLSBhY2NvdW50OiBBY2NvdW50SW50ZXJmYWNlO1xuICAgKiAgLSBjYXNtPzogQ2Fpcm9Bc3NlbWJseTtcbiAgICogIC0gY2xhc3NIYXNoPzogc3RyaW5nO1xuICAgKiAgLSBjb21waWxlZENsYXNzSGFzaD86IHN0cmluZztcbiAgICogIC0gYWJpPzogQWJpO1xuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgdGhpcy5jb21waWxlZENvbnRyYWN0ID0gcGFyYW1zLmNvbXBpbGVkQ29udHJhY3Q7XG4gICAgdGhpcy5hY2NvdW50ID0gcGFyYW1zLmFjY291bnQ7XG4gICAgdGhpcy5jYXNtID0gcGFyYW1zLmNhc207XG4gICAgdGhpcy5hYmkgPSBwYXJhbXMuYWJpID8/IHBhcmFtcy5jb21waWxlZENvbnRyYWN0LmFiaTtcbiAgICB0aGlzLmNsYXNzSGFzaCA9IHBhcmFtcy5jbGFzc0hhc2g7XG4gICAgdGhpcy5jb21waWxlZENsYXNzSGFzaCA9IHBhcmFtcy5jb21waWxlZENsYXNzSGFzaDtcbiAgICB0aGlzLkNhbGxEYXRhID0gbmV3IENhbGxEYXRhKHRoaXMuYWJpKTtcbiAgfVxuICAvKipcbiAgICogRGVwbG95cyBjb250cmFjdCBhbmQgcmV0dXJucyBuZXcgaW5zdGFuY2Ugb2YgdGhlIENvbnRyYWN0XG4gICAqXG4gICAqIElmIGNvbnRyYWN0IGlzIG5vdCBkZWNsYXJlZCBpdCB3aWxsIGZpcnN0IGRlY2xhcmUgaXQsIGFuZCB0aGVuIGRlcGxveVxuICAgKi9cbiAgYXN5bmMgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICBjb25zdCB7IGFyZ3M6IHBhcmFtLCBvcHRpb25zID0geyBwYXJzZVJlcXVlc3Q6IHRydWUgfSB9ID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICBjb25zdCBjb25zdHJ1Y3RvckNhbGxkYXRhID0gZ2V0Q2FsbGRhdGEocGFyYW0sICgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlUmVxdWVzdCkge1xuICAgICAgICB0aGlzLkNhbGxEYXRhLnZhbGlkYXRlKFZhbGlkYXRlVHlwZS5ERVBMT1ksIFwiY29uc3RydWN0b3JcIiwgcGFyYW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5DYWxsRGF0YS5jb21waWxlKFwiY29uc3RydWN0b3JcIiwgcGFyYW0pO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLndhcm4oXCJDYWxsIHNraXBwZWQgcGFyc2luZyBidXQgcHJvdmlkZWQgcmF3QXJncywgcG9zc2libGUgbWFsZnVuY3Rpb24gcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBkZXBsb3k6IHsgY29udHJhY3RfYWRkcmVzcywgdHJhbnNhY3Rpb25faGFzaCB9XG4gICAgfSA9IGF3YWl0IHRoaXMuYWNjb3VudC5kZWNsYXJlQW5kRGVwbG95KHtcbiAgICAgIGNvbnRyYWN0OiB0aGlzLmNvbXBpbGVkQ29udHJhY3QsXG4gICAgICBjYXNtOiB0aGlzLmNhc20sXG4gICAgICBjbGFzc0hhc2g6IHRoaXMuY2xhc3NIYXNoLFxuICAgICAgY29tcGlsZWRDbGFzc0hhc2g6IHRoaXMuY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgc2FsdDogb3B0aW9ucy5hZGRyZXNzU2FsdFxuICAgIH0pO1xuICAgIGFzc2VydChCb29sZWFuKGNvbnRyYWN0X2FkZHJlc3MpLCBcIkRlcGxveW1lbnQgb2YgdGhlIGNvbnRyYWN0IGZhaWxlZFwiKTtcbiAgICBjb25zdCBjb250cmFjdEluc3RhbmNlID0gbmV3IENvbnRyYWN0KFxuICAgICAgdGhpcy5jb21waWxlZENvbnRyYWN0LmFiaSxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICB0aGlzLmFjY291bnRcbiAgICApO1xuICAgIGNvbnRyYWN0SW5zdGFuY2UuZGVwbG95VHJhbnNhY3Rpb25IYXNoID0gdHJhbnNhY3Rpb25faGFzaDtcbiAgICByZXR1cm4gY29udHJhY3RJbnN0YW5jZTtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoZXMgdG8gbmV3IEFjY291bnRcbiAgICpcbiAgICogQHBhcmFtIGFjY291bnQgLSBuZXcgQWNjb3VudCB0byBhdHRhY2ggdG9cbiAgICovXG4gIGNvbm5lY3QoYWNjb3VudCkge1xuICAgIHRoaXMuYWNjb3VudCA9IGFjY291bnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaGVzIGN1cnJlbnQgYWJpIGFuZCBhY2NvdW50IHRvIHRoZSBuZXcgYWRkcmVzc1xuICAgKi9cbiAgYXR0YWNoKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gbmV3IENvbnRyYWN0KHRoaXMuYWJpLCBhZGRyZXNzLCB0aGlzLmFjY291bnQpO1xuICB9XG4gIC8vIGV0aGVycy5qcycgZ2V0RGVwbG95VHJhbnNhY3Rpb24gY2FuJ3QgYmUgc3VwcG9ydGVkIGFzIGl0IHJlcXVpcmVzIHRoZSBhY2NvdW50IG9yIHNpZ25lciB0byByZXR1cm4gYSBzaWduZWQgdHJhbnNhY3Rpb24gd2hpY2ggaXMgbm90IHBvc3NpYmxlIHdpdGggdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb25cbn07XG5cbi8vIHNyYy91dGlscy9yZXNwb25zZVBhcnNlci9pbnRlcmZhY2UudHNcbnZhciBSZXNwb25zZVBhcnNlciA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy91dGlscy91bml0cy50c1xuZnVuY3Rpb24gdW5pdHMoYW1vdW50LCBzaW1ib2wgPSBcImZyaVwiKSB7XG4gIGlmIChzaW1ib2wgPT09IFwic3Rya1wiKSB7XG4gICAgbGV0IG51bVN0ciA9IFwiXCI7XG4gICAgaWYgKHR5cGVvZiBhbW91bnQgPT09IFwiYmlnaW50XCIpIG51bVN0ciA9IGFtb3VudC50b1N0cmluZygpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBhbW91bnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChpc0hleChhbW91bnQpKSB7XG4gICAgICAgIG51bVN0ciA9IEJpZ0ludChhbW91bnQpLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW1TdHIgPSBhbW91bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFtpbnRlZ2VyLCBkZWNpbWFsID0gXCIwXCJdID0gbnVtU3RyLnNwbGl0KFwiLlwiKTtcbiAgICBjb25zdCBwZGVjID0gZGVjaW1hbC5wYWRFbmQoMTgsIFwiMFwiKTtcbiAgICByZXR1cm4gYCR7aW50ZWdlcn0ke3BkZWN9YC5yZXBsYWNlKC9cXGIwKy9nLCBcIlwiKTtcbiAgfVxuICBjb25zdCBiaXMgPSBCaWdJbnQoYW1vdW50KS50b1N0cmluZygpO1xuICBsZXQgc3RyaztcbiAgaWYgKGJpcy5sZW5ndGggPD0gMTgpIHtcbiAgICBzdHJrID0gYDAuJHtiaXMucGFkU3RhcnQoMTgsIFwiMFwiKX1gO1xuICB9IGVsc2Uge1xuICAgIHN0cmsgPSBgJHtiaXMuc2xpY2UoMCwgYmlzLmxlbmd0aCAtIDE4KX0uJHtiaXMuc2xpY2UoYmlzLmxlbmd0aCAtIDE4KX1gO1xuICB9XG4gIHJldHVybiBzdHJrLnJlcGxhY2UoLyhcXC5bMC05XSpbMS05XSkwKyR8XFwuMCokLywgXCIkMVwiKTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG52YXIgbnVtYmVyID0gbnVtX2V4cG9ydHM7XG5leHBvcnQge1xuICBBY2NvdW50LFxuICBBY2NvdW50SW50ZXJmYWNlLFxuICBCYXRjaENsaWVudCxcbiAgQmxvY2tTdGF0dXMsXG4gIEJsb2NrVGFnLFxuICBDYWlyb0N1c3RvbUVudW0sXG4gIENhaXJvRml4ZWRBcnJheSxcbiAgQ2Fpcm9PcHRpb24sXG4gIENhaXJvT3B0aW9uVmFyaWFudCxcbiAgQ2Fpcm9SZXN1bHQsXG4gIENhaXJvUmVzdWx0VmFyaWFudCxcbiAgQ2Fpcm9VaW50MjU2LFxuICBDYWlyb1VpbnQ1MTIsXG4gIENhbGxEYXRhLFxuICBDb250cmFjdCxcbiAgQ29udHJhY3RGYWN0b3J5LFxuICBDb250cmFjdEludGVyZmFjZSxcbiAgQ3VzdG9tRXJyb3IsXG4gIEVUSF9BRERSRVNTLFxuICBFbnRyeVBvaW50VHlwZSxcbiAgRXRoU2lnbmVyLFxuICBMZWRnZXJTaWduZXIxMTEgYXMgTGVkZ2VyU2lnbmVyLFxuICBMZWRnZXJTaWduZXIxMTEsXG4gIExlZGdlclNpZ25lcjIyMSxcbiAgTGlicmFyeUVycm9yLFxuICBMaXRlcmFsLFxuICBMb2dMZXZlbEluZGV4LFxuICBOT05fWkVST19QUkVGSVgsXG4gIE91dHNpZGVFeGVjdXRpb25UeXBlc1YxLFxuICBPdXRzaWRlRXhlY3V0aW9uVHlwZXNWMixcbiAgT3V0c2lkZUV4ZWN1dGlvblZlcnNpb24sXG4gIFJwY1Byb3ZpZGVyMiBhcyBQcm92aWRlcixcbiAgUHJvdmlkZXJJbnRlcmZhY2UsXG4gIGFwaV9leHBvcnRzIGFzIFJQQyxcbiAgcnBjXzBfNl9leHBvcnRzIGFzIFJQQzA2LFxuICBycGNfMF83X2V4cG9ydHMgYXMgUlBDMDcsXG4gIFJQQ1Jlc3BvbnNlUGFyc2VyLFxuICBSZWNlaXB0VHgsXG4gIFJlc3BvbnNlUGFyc2VyLFxuICBScGNDaGFubmVsMiBhcyBScGNDaGFubmVsLFxuICBScGNFcnJvcixcbiAgUnBjUHJvdmlkZXIyIGFzIFJwY1Byb3ZpZGVyLFxuICBTaWduZXIsXG4gIFNpZ25lckludGVyZmFjZSxcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMsXG4gIFRyYW5zYWN0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvblR5cGUsXG4gIFR5cGVkRGF0YVJldmlzaW9uLFxuICBVSU5UXzEyOF9NQVgsXG4gIFVJTlRfMTI4X01JTixcbiAgVUlOVF8yNTZfSElHSF9NQVgsXG4gIFVJTlRfMjU2X0hJR0hfTUlOLFxuICBVSU5UXzI1Nl9MT1dfTUFYLFxuICBVSU5UXzI1Nl9MT1dfTUlOLFxuICBVSU5UXzI1Nl9NQVgsXG4gIFVJTlRfMjU2X01JTixcbiAgVUlOVF81MTJfTUFYLFxuICBVSU5UXzUxMl9NSU4sXG4gIFVpbnQsXG4gIFZhbGlkYXRlVHlwZSxcbiAgV2FsbGV0QWNjb3VudCxcbiAgYWRkQWRkcmVzc1BhZGRpbmcsXG4gIGJ5dGVBcnJheV9leHBvcnRzIGFzIGJ5dGVBcnJheSxcbiAgY2Fpcm9fZXhwb3J0cyBhcyBjYWlybyxcbiAgY29uZmlnLFxuICBjb25zdGFudHNfZXhwb3J0cyBhcyBjb25zdGFudHMsXG4gIGNvbnRyYWN0Q2xhc3NSZXNwb25zZVRvTGVnYWN5Q29tcGlsZWRDb250cmFjdCxcbiAgZGVmYXVsdFByb3ZpZGVyLFxuICBlY19leHBvcnRzIGFzIGVjLFxuICBlbmNvZGVfZXhwb3J0cyBhcyBlbmNvZGUsXG4gIGV0aF9leHBvcnRzIGFzIGV0aCxcbiAgZXZlbnRzX2V4cG9ydHMgYXMgZXZlbnRzLFxuICBleHRyYWN0Q29udHJhY3RIYXNoZXMsXG4gIGZpeFByb3RvLFxuICBmaXhTdGFjayxcbiAgZ2V0Q2FsbGRhdGEsXG4gIGdldENoZWNrc3VtQWRkcmVzcyxcbiAgZ2V0TGVkZ2VyUGF0aEJ1ZmZlcjExMSBhcyBnZXRMZWRnZXJQYXRoQnVmZmVyLFxuICBnZXRMZWRnZXJQYXRoQnVmZmVyMTExLFxuICBnZXRMZWRnZXJQYXRoQnVmZmVyMjIxLFxuICBoYXNoX2V4cG9ydHMgYXMgaGFzaCxcbiAgaXNTaWVycmEsXG4gIGpzb25fZXhwb3J0cyBhcyBqc29uLFxuICBsb2dnZXIsXG4gIG1lcmtsZV9leHBvcnRzIGFzIG1lcmtsZSxcbiAgbnVtX2V4cG9ydHMgYXMgbnVtLFxuICBudW1iZXIsXG4gIG91dHNpZGVFeGVjdXRpb25fZXhwb3J0cyBhcyBvdXRzaWRlRXhlY3V0aW9uLFxuICBwYXJzZUNhbGxkYXRhRmllbGQsXG4gIHByb3ZpZGVyX2V4cG9ydHMgYXMgcHJvdmlkZXIsXG4gIHNlbGVjdG9yX2V4cG9ydHMgYXMgc2VsZWN0b3IsXG4gIHNob3J0U3RyaW5nX2V4cG9ydHMgYXMgc2hvcnRTdHJpbmcsXG4gIHNwbGl0QXJnc0FuZE9wdGlvbnMsXG4gIHNyYzVfZXhwb3J0cyBhcyBzcmM1LFxuICBzdGFya19leHBvcnRzIGFzIHN0YXJrLFxuICBzdGFya25ldElkX2V4cG9ydHMgYXMgc3RhcmtuZXRJZCxcbiAgdHJhbnNhY3Rpb25fZXhwb3J0cyBhcyB0cmFuc2FjdGlvbixcbiAgdHlwZWREYXRhX2V4cG9ydHMgYXMgdHlwZWREYXRhLFxuICB0eXBlc19leHBvcnRzIGFzIHR5cGVzLFxuICB1aW50MjU2X2V4cG9ydHMgYXMgdWludDI1NixcbiAgdW5pdHMsXG4gIHYyX2V4cG9ydHMgYXMgdjJoYXNoLFxuICB2M19leHBvcnRzIGFzIHYzaGFzaCxcbiAgdmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MsXG4gIHZhbGlkYXRlQ2hlY2tzdW1BZGRyZXNzLFxuICBjb25uZWN0X2V4cG9ydHMgYXMgd2FsbGV0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs\n");

/***/ })

};
;