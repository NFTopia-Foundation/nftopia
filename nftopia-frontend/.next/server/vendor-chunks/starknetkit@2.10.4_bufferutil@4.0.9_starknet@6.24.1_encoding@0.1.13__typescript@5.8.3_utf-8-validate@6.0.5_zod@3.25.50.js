"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50";
exports.ids = ["vendor-chunks/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/argentMobile.js":
/*!*************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/argentMobile.js ***!
  \*************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArgentMobileBaseConnector: () => (/* reexport safe */ _index_d4f30f2e_js__WEBPACK_IMPORTED_MODULE_4__.A),\n/* harmony export */   ArgentMobileConnector: () => (/* reexport safe */ _index_d4f30f2e_js__WEBPACK_IMPORTED_MODULE_4__.a),\n/* harmony export */   isInArgentMobileAppBrowser: () => (/* reexport safe */ _index_d4f30f2e_js__WEBPACK_IMPORTED_MODULE_4__.i)\n/* harmony export */ });\n/* harmony import */ var _core_d21d2e96_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core-d21d2e96.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/core-d21d2e96.js\");\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! starknet */ \"(ssr)/./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lastConnected-e9351912.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/lastConnected-e9351912.js\");\n/* harmony import */ var _getStarknetChainId_7c4b3163_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getStarknetChainId-7c4b3163.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/getStarknetChainId-7c4b3163.js\");\n/* harmony import */ var _index_d4f30f2e_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index-d4f30f2e.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-d4f30f2e.js\");\n/* harmony import */ var _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index-9bb48f8a.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-9bb48f8a.js\");\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9hcmdlbnRNb2JpbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTRCO0FBQ1Y7QUFDbUI7QUFDSztBQUNtQjtBQUNoQztBQUszQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0YXJrbmV0a2l0QDIuMTAuNF9idWZmZXJ1dGlsQDQuMC45X3N0YXJrbmV0QDYuMjQuMV9lbmNvZGluZ0AwLjEuMTNfX3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANi4wLjVfem9kQDMuMjUuNTAvbm9kZV9tb2R1bGVzL3N0YXJrbmV0a2l0L2Rpc3QvYXJnZW50TW9iaWxlLmpzPzAzY2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwiLi9jb3JlLWQyMWQyZTk2LmpzXCI7XG5pbXBvcnQgXCJzdGFya25ldFwiO1xuaW1wb3J0IFwiLi9sYXN0Q29ubmVjdGVkLWU5MzUxOTEyLmpzXCI7XG5pbXBvcnQgXCIuL2dldFN0YXJrbmV0Q2hhaW5JZC03YzRiMzE2My5qc1wiO1xuaW1wb3J0IHsgQSBhcyBtLCBhIGFzIHMsIGkgYXMgYSB9IGZyb20gXCIuL2luZGV4LWQ0ZjMwZjJlLmpzXCI7XG5pbXBvcnQgXCIuL2luZGV4LTliYjQ4ZjhhLmpzXCI7XG5leHBvcnQge1xuICBtIGFzIEFyZ2VudE1vYmlsZUJhc2VDb25uZWN0b3IsXG4gIHMgYXMgQXJnZW50TW9iaWxlQ29ubmVjdG9yLFxuICBhIGFzIGlzSW5BcmdlbnRNb2JpbGVBcHBCcm93c2VyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/argentMobile.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/braavosMobile.js":
/*!**************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/braavosMobile.js ***!
  \**************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BraavosMobileBaseConnector: () => (/* binding */ c),\n/* harmony export */   BraavosMobileConnector: () => (/* binding */ g),\n/* harmony export */   isInBraavosMobileAppBrowser: () => (/* binding */ p)\n/* harmony export */ });\n/* harmony import */ var _core_d21d2e96_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core-d21d2e96.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/core-d21d2e96.js\");\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! starknet */ \"(ssr)/./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lastConnected-e9351912.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/lastConnected-e9351912.js\");\n/* harmony import */ var _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index-9bb48f8a.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-9bb48f8a.js\");\nvar i = Object.defineProperty;\nvar l = (r, e, t) => e in r ? i(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;\nvar n = (r, e, t) => (l(r, typeof e != \"symbol\" ? e + \"\" : e, t), t);\n\n\n\n\nconst o = `<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"32px\" height=\"32px\" viewBox=\"0 0 32 32\" version=\"1.1\">\n    <defs>\n    <clipPath id=\"clip1\">\n      <path d=\"M 5.332031 0 L 26.667969 0 C 29.613281 0 32 2.386719 32 5.332031 L 32 26.667969 C 32 29.613281 29.613281 32 26.667969 32 L 5.332031 32 C 2.386719 32 0 29.613281 0 26.667969 L 0 5.332031 C 0 2.386719 2.386719 0 5.332031 0 Z M 5.332031 0 \"/>\n    </clipPath>\n    <linearGradient id=\"linear0\" gradientUnits=\"userSpaceOnUse\" x1=\"-9.552\" y1=\"-6.444\" x2=\"50.240002\" y2=\"41.303001\" gradientTransform=\"matrix(0.666667,0,0,0.666667,0,0)\">\n      <stop offset=\"0\" style=\"stop-color:rgb(3.529412%,45.09804%,75.294119%);stop-opacity:1;\"/>\n      <stop offset=\"1\" style=\"stop-color:rgb(10.980392%,28.627452%,87.058824%);stop-opacity:1;\"/>\n    </linearGradient>\n    <clipPath id=\"clip2\">\n      <path d=\"M 7 4 L 25 4 L 25 15 L 7 15 Z M 7 4 \"/>\n    </clipPath>\n    <clipPath id=\"clip3\">\n      <path d=\"M 5.332031 0 L 26.667969 0 C 29.613281 0 32 2.386719 32 5.332031 L 32 26.667969 C 32 29.613281 29.613281 32 26.667969 32 L 5.332031 32 C 2.386719 32 0 29.613281 0 26.667969 L 0 5.332031 C 0 2.386719 2.386719 0 5.332031 0 Z M 5.332031 0 \"/>\n    </clipPath>\n    <clipPath id=\"clip4\">\n    \t<path d=\"M 6 13 L 26 13 L 26 28 L 6 28 Z M 6 13 \"/>\n    </clipPath>\n    <clipPath id=\"clip5\">\n      <path d=\"M 5.332031 0 L 26.667969 0 C 29.613281 0 32 2.386719 32 5.332031 L 32 26.667969 C 32 29.613281 29.613281 32 26.667969 32 L 5.332031 32 C 2.386719 32 0 29.613281 0 26.667969 L 0 5.332031 C 0 2.386719 2.386719 0 5.332031 0 Z M 5.332031 0 \"/>\n    </clipPath>\n    </defs>\n    <g id=\"surface1\">\n      <g clip-path=\"url(#clip1)\" clip-rule=\"nonzero\">\n        <rect x=\"0\" y=\"0\" width=\"32\" height=\"32\" style=\"fill:url(#linear0);stroke:none;\"/>\n      </g>\n    \t<g clip-path=\"url(#clip2)\" clip-rule=\"nonzero\">\n        <g clip-path=\"url(#clip3)\" clip-rule=\"nonzero\">\n\t        <path style=\" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;\" d=\"M 19.507812 6.320312 C 19.542969 6.378906 19.496094 6.453125 19.425781 6.453125 C 18.027344 6.453125 16.886719 7.5625 16.859375 8.941406 C 16.375 8.851562 15.878906 8.847656 15.390625 8.929688 C 15.359375 7.554688 14.222656 6.453125 12.824219 6.453125 C 12.757812 6.453125 12.710938 6.378906 12.746094 6.320312 C 13.453125 5.128906 14.738281 4.398438 16.125 4.398438 C 17.515625 4.394531 18.800781 5.125 19.507812 6.320312 M 23.65625 14.847656 C 24.132812 14.992188 24.585938 14.574219 24.402344 14.109375 C 23.066406 10.65625 19.109375 9.242188 16.105469 9.242188 C 13.097656 9.242188 9.054688 10.703125 7.804688 14.128906 C 7.632812 14.589844 8.082031 14.996094 8.550781 14.851562 L 15.75 12.648438 C 15.957031 12.582031 16.179688 12.582031 16.386719 12.644531 Z M 23.65625 14.847656 \"/>\n        </g>\n    \t</g>\n    \t<g clip-path=\"url(#clip4)\" clip-rule=\"nonzero\">\n        <g clip-path=\"url(#clip5)\" clip-rule=\"nonzero\">\n          <path style=\" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;\" d=\"M 7.734375 15.511719 L 15.757812 13.078125 C 15.964844 13.015625 16.183594 13.015625 16.390625 13.078125 L 24.464844 15.511719 C 25.136719 15.714844 25.597656 16.335938 25.597656 17.042969 L 25.597656 24.378906 C 25.566406 26.167969 23.960938 27.605469 22.167969 27.605469 L 19.195312 27.605469 C 19.054688 27.605469 18.917969 27.550781 18.820312 27.449219 C 18.71875 27.347656 18.664062 27.214844 18.664062 27.074219 L 18.664062 24.5 C 18.664062 23.488281 19.261719 22.570312 20.191406 22.164062 C 21.433594 21.621094 22.90625 20.886719 23.183594 19.410156 C 23.269531 18.933594 22.960938 18.472656 22.484375 18.378906 C 21.285156 18.140625 19.953125 18.230469 18.824219 18.734375 C 17.546875 19.308594 17.210938 20.257812 17.085938 21.539062 L 16.9375 22.914062 C 16.890625 23.335938 16.496094 23.65625 16.074219 23.65625 C 15.636719 23.65625 15.308594 23.324219 15.261719 22.886719 L 15.113281 21.539062 C 15.007812 20.441406 14.8125 19.378906 13.683594 18.875 C 12.390625 18.296875 11.09375 18.105469 9.714844 18.378906 C 9.238281 18.472656 8.929688 18.933594 9.015625 19.410156 C 9.296875 20.898438 10.757812 21.617188 12.007812 22.164062 C 12.9375 22.570312 13.535156 23.488281 13.535156 24.5 L 13.535156 27.074219 C 13.535156 27.367188 13.296875 27.605469 13.003906 27.605469 L 10.03125 27.605469 C 8.238281 27.605469 6.628906 26.167969 6.597656 24.378906 L 6.597656 17.039062 C 6.597656 16.335938 7.058594 15.714844 7.734375 15.511719 \"/>\n        </g>\n    \t</g>\n    </g>\n</svg>\n`, p = () => {\n  if (typeof window > \"u\")\n    return !1;\n  const e = navigator.userAgent.toLowerCase().includes(\"braavos\");\n  return e || !1;\n};\nclass c extends _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.C {\n  constructor() {\n    super();\n    n(this, \"_wallet\", null);\n  }\n  available() {\n    return !0;\n  }\n  async ready() {\n    return !0;\n  }\n  get id() {\n    return \"braavosMobile\";\n  }\n  get name() {\n    return \"Braavos (mobile)\";\n  }\n  get icon() {\n    return {\n      dark: o,\n      light: o\n    };\n  }\n  get wallet() {\n    throw new Error(\"not implemented\");\n  }\n  async connect(t = {}) {\n    return await this.ensureWallet(), {\n      account: \"\",\n      chainId: BigInt(0)\n    };\n  }\n  async disconnect() {\n    throw new Error(\"not implemented\");\n  }\n  async account(t) {\n    throw new Error(\"not implemented\");\n  }\n  async chainId() {\n    throw new Error(\"not implemented\");\n  }\n  async request(t) {\n    throw new Error(\"not implemented\");\n  }\n  // needed, methods required by starknet-react. Otherwise an exception is throwd\n  async initEventListener(t) {\n    throw new Error(\"not implemented\");\n  }\n  // needed, methods required by starknet-react. Otherwise an exception is throwd\n  async removeEventListener(t) {\n    throw new Error(\"not implemented\");\n  }\n  async ensureWallet() {\n    window.open(`https://link.braavos.app/dapp/${window.origin}`, \"_blank\");\n  }\n}\nclass g {\n  static init(e) {\n    const { inAppBrowserOptions: t } = e || {};\n    return p() ? new _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_3__.I({\n      options: { id: \"braavos\", ...t }\n    }) : new c();\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9icmFhdm9zTW9iaWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBLHdDQUF3QywwREFBMEQ7QUFDbEc7QUFDNEI7QUFDVjtBQUNtQztBQUNSO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxlQUFlO0FBQzVGLCtFQUErRSxlQUFlO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLFlBQVk7QUFDdkY7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQix5QkFBeUIsZUFBZTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0IseUJBQXlCLGVBQWU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQUM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMscUJBQXFCLGlEQUFDO0FBQ3RCLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9icmFhdm9zTW9iaWxlLmpzP2IwYzYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgbCA9IChyLCBlLCB0KSA9PiBlIGluIHIgPyBpKHIsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiByW2VdID0gdDtcbnZhciBuID0gKHIsIGUsIHQpID0+IChsKHIsIHR5cGVvZiBlICE9IFwic3ltYm9sXCIgPyBlICsgXCJcIiA6IGUsIHQpLCB0KTtcbmltcG9ydCBcIi4vY29yZS1kMjFkMmU5Ni5qc1wiO1xuaW1wb3J0IFwic3RhcmtuZXRcIjtcbmltcG9ydCB7IEMgYXMgYSB9IGZyb20gXCIuL2xhc3RDb25uZWN0ZWQtZTkzNTE5MTIuanNcIjtcbmltcG9ydCB7IEkgYXMgcyB9IGZyb20gXCIuL2luZGV4LTliYjQ4ZjhhLmpzXCI7XG5jb25zdCBvID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHdpZHRoPVwiMzJweFwiIGhlaWdodD1cIjMycHhcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCIgdmVyc2lvbj1cIjEuMVwiPlxuICAgIDxkZWZzPlxuICAgIDxjbGlwUGF0aCBpZD1cImNsaXAxXCI+XG4gICAgICA8cGF0aCBkPVwiTSA1LjMzMjAzMSAwIEwgMjYuNjY3OTY5IDAgQyAyOS42MTMyODEgMCAzMiAyLjM4NjcxOSAzMiA1LjMzMjAzMSBMIDMyIDI2LjY2Nzk2OSBDIDMyIDI5LjYxMzI4MSAyOS42MTMyODEgMzIgMjYuNjY3OTY5IDMyIEwgNS4zMzIwMzEgMzIgQyAyLjM4NjcxOSAzMiAwIDI5LjYxMzI4MSAwIDI2LjY2Nzk2OSBMIDAgNS4zMzIwMzEgQyAwIDIuMzg2NzE5IDIuMzg2NzE5IDAgNS4zMzIwMzEgMCBaIE0gNS4zMzIwMzEgMCBcIi8+XG4gICAgPC9jbGlwUGF0aD5cbiAgICA8bGluZWFyR3JhZGllbnQgaWQ9XCJsaW5lYXIwXCIgZ3JhZGllbnRVbml0cz1cInVzZXJTcGFjZU9uVXNlXCIgeDE9XCItOS41NTJcIiB5MT1cIi02LjQ0NFwiIHgyPVwiNTAuMjQwMDAyXCIgeTI9XCI0MS4zMDMwMDFcIiBncmFkaWVudFRyYW5zZm9ybT1cIm1hdHJpeCgwLjY2NjY2NywwLDAsMC42NjY2NjcsMCwwKVwiPlxuICAgICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0eWxlPVwic3RvcC1jb2xvcjpyZ2IoMy41Mjk0MTIlLDQ1LjA5ODA0JSw3NS4yOTQxMTklKTtzdG9wLW9wYWNpdHk6MTtcIi8+XG4gICAgICA8c3RvcCBvZmZzZXQ9XCIxXCIgc3R5bGU9XCJzdG9wLWNvbG9yOnJnYigxMC45ODAzOTIlLDI4LjYyNzQ1MiUsODcuMDU4ODI0JSk7c3RvcC1vcGFjaXR5OjE7XCIvPlxuICAgIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgPGNsaXBQYXRoIGlkPVwiY2xpcDJcIj5cbiAgICAgIDxwYXRoIGQ9XCJNIDcgNCBMIDI1IDQgTCAyNSAxNSBMIDcgMTUgWiBNIDcgNCBcIi8+XG4gICAgPC9jbGlwUGF0aD5cbiAgICA8Y2xpcFBhdGggaWQ9XCJjbGlwM1wiPlxuICAgICAgPHBhdGggZD1cIk0gNS4zMzIwMzEgMCBMIDI2LjY2Nzk2OSAwIEMgMjkuNjEzMjgxIDAgMzIgMi4zODY3MTkgMzIgNS4zMzIwMzEgTCAzMiAyNi42Njc5NjkgQyAzMiAyOS42MTMyODEgMjkuNjEzMjgxIDMyIDI2LjY2Nzk2OSAzMiBMIDUuMzMyMDMxIDMyIEMgMi4zODY3MTkgMzIgMCAyOS42MTMyODEgMCAyNi42Njc5NjkgTCAwIDUuMzMyMDMxIEMgMCAyLjM4NjcxOSAyLjM4NjcxOSAwIDUuMzMyMDMxIDAgWiBNIDUuMzMyMDMxIDAgXCIvPlxuICAgIDwvY2xpcFBhdGg+XG4gICAgPGNsaXBQYXRoIGlkPVwiY2xpcDRcIj5cbiAgICBcdDxwYXRoIGQ9XCJNIDYgMTMgTCAyNiAxMyBMIDI2IDI4IEwgNiAyOCBaIE0gNiAxMyBcIi8+XG4gICAgPC9jbGlwUGF0aD5cbiAgICA8Y2xpcFBhdGggaWQ9XCJjbGlwNVwiPlxuICAgICAgPHBhdGggZD1cIk0gNS4zMzIwMzEgMCBMIDI2LjY2Nzk2OSAwIEMgMjkuNjEzMjgxIDAgMzIgMi4zODY3MTkgMzIgNS4zMzIwMzEgTCAzMiAyNi42Njc5NjkgQyAzMiAyOS42MTMyODEgMjkuNjEzMjgxIDMyIDI2LjY2Nzk2OSAzMiBMIDUuMzMyMDMxIDMyIEMgMi4zODY3MTkgMzIgMCAyOS42MTMyODEgMCAyNi42Njc5NjkgTCAwIDUuMzMyMDMxIEMgMCAyLjM4NjcxOSAyLjM4NjcxOSAwIDUuMzMyMDMxIDAgWiBNIDUuMzMyMDMxIDAgXCIvPlxuICAgIDwvY2xpcFBhdGg+XG4gICAgPC9kZWZzPlxuICAgIDxnIGlkPVwic3VyZmFjZTFcIj5cbiAgICAgIDxnIGNsaXAtcGF0aD1cInVybCgjY2xpcDEpXCIgY2xpcC1ydWxlPVwibm9uemVyb1wiPlxuICAgICAgICA8cmVjdCB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgc3R5bGU9XCJmaWxsOnVybCgjbGluZWFyMCk7c3Ryb2tlOm5vbmU7XCIvPlxuICAgICAgPC9nPlxuICAgIFx0PGcgY2xpcC1wYXRoPVwidXJsKCNjbGlwMilcIiBjbGlwLXJ1bGU9XCJub256ZXJvXCI+XG4gICAgICAgIDxnIGNsaXAtcGF0aD1cInVybCgjY2xpcDMpXCIgY2xpcC1ydWxlPVwibm9uemVyb1wiPlxuXHQgICAgICAgIDxwYXRoIHN0eWxlPVwiIHN0cm9rZTpub25lO2ZpbGwtcnVsZTpub256ZXJvO2ZpbGw6cmdiKDEwMCUsMTAwJSwxMDAlKTtmaWxsLW9wYWNpdHk6MTtcIiBkPVwiTSAxOS41MDc4MTIgNi4zMjAzMTIgQyAxOS41NDI5NjkgNi4zNzg5MDYgMTkuNDk2MDk0IDYuNDUzMTI1IDE5LjQyNTc4MSA2LjQ1MzEyNSBDIDE4LjAyNzM0NCA2LjQ1MzEyNSAxNi44ODY3MTkgNy41NjI1IDE2Ljg1OTM3NSA4Ljk0MTQwNiBDIDE2LjM3NSA4Ljg1MTU2MiAxNS44Nzg5MDYgOC44NDc2NTYgMTUuMzkwNjI1IDguOTI5Njg4IEMgMTUuMzU5Mzc1IDcuNTU0Njg4IDE0LjIyMjY1NiA2LjQ1MzEyNSAxMi44MjQyMTkgNi40NTMxMjUgQyAxMi43NTc4MTIgNi40NTMxMjUgMTIuNzEwOTM4IDYuMzc4OTA2IDEyLjc0NjA5NCA2LjMyMDMxMiBDIDEzLjQ1MzEyNSA1LjEyODkwNiAxNC43MzgyODEgNC4zOTg0MzggMTYuMTI1IDQuMzk4NDM4IEMgMTcuNTE1NjI1IDQuMzk0NTMxIDE4LjgwMDc4MSA1LjEyNSAxOS41MDc4MTIgNi4zMjAzMTIgTSAyMy42NTYyNSAxNC44NDc2NTYgQyAyNC4xMzI4MTIgMTQuOTkyMTg4IDI0LjU4NTkzOCAxNC41NzQyMTkgMjQuNDAyMzQ0IDE0LjEwOTM3NSBDIDIzLjA2NjQwNiAxMC42NTYyNSAxOS4xMDkzNzUgOS4yNDIxODggMTYuMTA1NDY5IDkuMjQyMTg4IEMgMTMuMDk3NjU2IDkuMjQyMTg4IDkuMDU0Njg4IDEwLjcwMzEyNSA3LjgwNDY4OCAxNC4xMjg5MDYgQyA3LjYzMjgxMiAxNC41ODk4NDQgOC4wODIwMzEgMTQuOTk2MDk0IDguNTUwNzgxIDE0Ljg1MTU2MiBMIDE1Ljc1IDEyLjY0ODQzOCBDIDE1Ljk1NzAzMSAxMi41ODIwMzEgMTYuMTc5Njg4IDEyLjU4MjAzMSAxNi4zODY3MTkgMTIuNjQ0NTMxIFogTSAyMy42NTYyNSAxNC44NDc2NTYgXCIvPlxuICAgICAgICA8L2c+XG4gICAgXHQ8L2c+XG4gICAgXHQ8ZyBjbGlwLXBhdGg9XCJ1cmwoI2NsaXA0KVwiIGNsaXAtcnVsZT1cIm5vbnplcm9cIj5cbiAgICAgICAgPGcgY2xpcC1wYXRoPVwidXJsKCNjbGlwNSlcIiBjbGlwLXJ1bGU9XCJub256ZXJvXCI+XG4gICAgICAgICAgPHBhdGggc3R5bGU9XCIgc3Ryb2tlOm5vbmU7ZmlsbC1ydWxlOm5vbnplcm87ZmlsbDpyZ2IoMTAwJSwxMDAlLDEwMCUpO2ZpbGwtb3BhY2l0eToxO1wiIGQ9XCJNIDcuNzM0Mzc1IDE1LjUxMTcxOSBMIDE1Ljc1NzgxMiAxMy4wNzgxMjUgQyAxNS45NjQ4NDQgMTMuMDE1NjI1IDE2LjE4MzU5NCAxMy4wMTU2MjUgMTYuMzkwNjI1IDEzLjA3ODEyNSBMIDI0LjQ2NDg0NCAxNS41MTE3MTkgQyAyNS4xMzY3MTkgMTUuNzE0ODQ0IDI1LjU5NzY1NiAxNi4zMzU5MzggMjUuNTk3NjU2IDE3LjA0Mjk2OSBMIDI1LjU5NzY1NiAyNC4zNzg5MDYgQyAyNS41NjY0MDYgMjYuMTY3OTY5IDIzLjk2MDkzOCAyNy42MDU0NjkgMjIuMTY3OTY5IDI3LjYwNTQ2OSBMIDE5LjE5NTMxMiAyNy42MDU0NjkgQyAxOS4wNTQ2ODggMjcuNjA1NDY5IDE4LjkxNzk2OSAyNy41NTA3ODEgMTguODIwMzEyIDI3LjQ0OTIxOSBDIDE4LjcxODc1IDI3LjM0NzY1NiAxOC42NjQwNjIgMjcuMjE0ODQ0IDE4LjY2NDA2MiAyNy4wNzQyMTkgTCAxOC42NjQwNjIgMjQuNSBDIDE4LjY2NDA2MiAyMy40ODgyODEgMTkuMjYxNzE5IDIyLjU3MDMxMiAyMC4xOTE0MDYgMjIuMTY0MDYyIEMgMjEuNDMzNTk0IDIxLjYyMTA5NCAyMi45MDYyNSAyMC44ODY3MTkgMjMuMTgzNTk0IDE5LjQxMDE1NiBDIDIzLjI2OTUzMSAxOC45MzM1OTQgMjIuOTYwOTM4IDE4LjQ3MjY1NiAyMi40ODQzNzUgMTguMzc4OTA2IEMgMjEuMjg1MTU2IDE4LjE0MDYyNSAxOS45NTMxMjUgMTguMjMwNDY5IDE4LjgyNDIxOSAxOC43MzQzNzUgQyAxNy41NDY4NzUgMTkuMzA4NTk0IDE3LjIxMDkzOCAyMC4yNTc4MTIgMTcuMDg1OTM4IDIxLjUzOTA2MiBMIDE2LjkzNzUgMjIuOTE0MDYyIEMgMTYuODkwNjI1IDIzLjMzNTkzOCAxNi40OTYwOTQgMjMuNjU2MjUgMTYuMDc0MjE5IDIzLjY1NjI1IEMgMTUuNjM2NzE5IDIzLjY1NjI1IDE1LjMwODU5NCAyMy4zMjQyMTkgMTUuMjYxNzE5IDIyLjg4NjcxOSBMIDE1LjExMzI4MSAyMS41MzkwNjIgQyAxNS4wMDc4MTIgMjAuNDQxNDA2IDE0LjgxMjUgMTkuMzc4OTA2IDEzLjY4MzU5NCAxOC44NzUgQyAxMi4zOTA2MjUgMTguMjk2ODc1IDExLjA5Mzc1IDE4LjEwNTQ2OSA5LjcxNDg0NCAxOC4zNzg5MDYgQyA5LjIzODI4MSAxOC40NzI2NTYgOC45Mjk2ODggMTguOTMzNTk0IDkuMDE1NjI1IDE5LjQxMDE1NiBDIDkuMjk2ODc1IDIwLjg5ODQzOCAxMC43NTc4MTIgMjEuNjE3MTg4IDEyLjAwNzgxMiAyMi4xNjQwNjIgQyAxMi45Mzc1IDIyLjU3MDMxMiAxMy41MzUxNTYgMjMuNDg4MjgxIDEzLjUzNTE1NiAyNC41IEwgMTMuNTM1MTU2IDI3LjA3NDIxOSBDIDEzLjUzNTE1NiAyNy4zNjcxODggMTMuMjk2ODc1IDI3LjYwNTQ2OSAxMy4wMDM5MDYgMjcuNjA1NDY5IEwgMTAuMDMxMjUgMjcuNjA1NDY5IEMgOC4yMzgyODEgMjcuNjA1NDY5IDYuNjI4OTA2IDI2LjE2Nzk2OSA2LjU5NzY1NiAyNC4zNzg5MDYgTCA2LjU5NzY1NiAxNy4wMzkwNjIgQyA2LjU5NzY1NiAxNi4zMzU5MzggNy4wNTg1OTQgMTUuNzE0ODQ0IDcuNzM0Mzc1IDE1LjUxMTcxOSBcIi8+XG4gICAgICAgIDwvZz5cbiAgICBcdDwvZz5cbiAgICA8L2c+XG48L3N2Zz5cbmAsIHAgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID4gXCJ1XCIpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBlID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiYnJhYXZvc1wiKTtcbiAgcmV0dXJuIGUgfHwgITE7XG59O1xuY2xhc3MgYyBleHRlbmRzIGEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIG4odGhpcywgXCJfd2FsbGV0XCIsIG51bGwpO1xuICB9XG4gIGF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgYXN5bmMgcmVhZHkoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gXCJicmFhdm9zTW9iaWxlXCI7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIFwiQnJhYXZvcyAobW9iaWxlKVwiO1xuICB9XG4gIGdldCBpY29uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXJrOiBvLFxuICAgICAgbGlnaHQ6IG9cbiAgICB9O1xuICB9XG4gIGdldCB3YWxsZXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QodCA9IHt9KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5zdXJlV2FsbGV0KCksIHtcbiAgICAgIGFjY291bnQ6IFwiXCIsXG4gICAgICBjaGFpbklkOiBCaWdJbnQoMClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIGFzeW5jIGFjY291bnQodCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBhc3luYyBjaGFpbklkKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBhc3luYyByZXF1ZXN0KHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgLy8gbmVlZGVkLCBtZXRob2RzIHJlcXVpcmVkIGJ5IHN0YXJrbmV0LXJlYWN0LiBPdGhlcndpc2UgYW4gZXhjZXB0aW9uIGlzIHRocm93ZFxuICBhc3luYyBpbml0RXZlbnRMaXN0ZW5lcih0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIC8vIG5lZWRlZCwgbWV0aG9kcyByZXF1aXJlZCBieSBzdGFya25ldC1yZWFjdC4gT3RoZXJ3aXNlIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd2RcbiAgYXN5bmMgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIGFzeW5jIGVuc3VyZVdhbGxldCgpIHtcbiAgICB3aW5kb3cub3BlbihgaHR0cHM6Ly9saW5rLmJyYWF2b3MuYXBwL2RhcHAvJHt3aW5kb3cub3JpZ2lufWAsIFwiX2JsYW5rXCIpO1xuICB9XG59XG5jbGFzcyBnIHtcbiAgc3RhdGljIGluaXQoZSkge1xuICAgIGNvbnN0IHsgaW5BcHBCcm93c2VyT3B0aW9uczogdCB9ID0gZSB8fCB7fTtcbiAgICByZXR1cm4gcCgpID8gbmV3IHMoe1xuICAgICAgb3B0aW9uczogeyBpZDogXCJicmFhdm9zXCIsIC4uLnQgfVxuICAgIH0pIDogbmV3IGMoKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgYyBhcyBCcmFhdm9zTW9iaWxlQmFzZUNvbm5lY3RvcixcbiAgZyBhcyBCcmFhdm9zTW9iaWxlQ29ubmVjdG9yLFxuICBwIGFzIGlzSW5CcmFhdm9zTW9iaWxlQXBwQnJvd3NlclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/braavosMobile.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/core-d21d2e96.js":
/*!**************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/core-d21d2e96.js ***!
  \**************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   m: () => (/* binding */ main)\n/* harmony export */ });\nvar te = Object.defineProperty, ne = (t, e, o) => e in t ? te(t, e, { enumerable: !0, configurable: !0, writable: !0, value: o }) : t[e] = o, _ = (t, e, o) => (ne(t, typeof e != \"symbol\" ? e + \"\" : e, o), o), K = (t, e, o) => {\n  if (!e.has(t))\n    throw TypeError(\"Cannot \" + o);\n}, N = (t, e, o) => (K(t, e, \"read from private field\"), o ? o.call(t) : e.get(t)), T = (t, e, o) => {\n  if (e.has(t))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  e instanceof WeakSet ? e.add(t) : e.set(t, o);\n}, B = (t, e, o, n) => (K(t, e, \"write to private field\"), n ? n.call(t, o) : e.set(t, o), o), E = (t, e, o) => (K(t, e, \"access private method\"), o);\nconst generateUID = () => `${Date.now()}-${Math.floor(Math.random() * 8999999999999) + 1e12}`, shuffle = (t) => {\n  for (let e = t.length - 1; e > 0; e--) {\n    const o = Math.floor(Math.random() * (e + 1));\n    [t[e], t[o]] = [t[o], t[e]];\n  }\n  return t;\n}, pipe$1 = (...t) => (e) => t.reduce((o, n) => o.then(n), Promise.resolve(e));\nfunction ensureKeysArray(t) {\n  return Object.keys(t);\n}\nconst ssrSafeWindow = typeof window < \"u\" ? window : null;\nfunction getBuilderId() {\n  return typeof FEDERATION_BUILD_IDENTIFIER < \"u\" ? FEDERATION_BUILD_IDENTIFIER : \"\";\n}\nfunction isDebugMode$1() {\n  return !!\"\";\n}\nfunction isBrowserEnv$1() {\n  return typeof window < \"u\";\n}\nconst LOG_CATEGORY$1 = \"[ Federation Runtime ]\";\nfunction assert(t, e) {\n  t || error(e);\n}\nfunction error(t) {\n  throw t instanceof Error ? (t.message = `${LOG_CATEGORY$1}: ${t.message}`, t) : new Error(`${LOG_CATEGORY$1}: ${t}`);\n}\nfunction warn$1(t) {\n  t instanceof Error ? (t.message = `${LOG_CATEGORY$1}: ${t.message}`, console.warn(t)) : console.warn(`${LOG_CATEGORY$1}: ${t}`);\n}\nfunction addUniqueItem(t, e) {\n  return t.findIndex((o) => o === e) === -1 && t.push(e), t;\n}\nfunction getFMId(t) {\n  return \"version\" in t && t.version ? `${t.name}:${t.version}` : \"entry\" in t && t.entry ? `${t.name}:${t.entry}` : `${t.name}`;\n}\nfunction isRemoteInfoWithEntry(t) {\n  return typeof t.entry < \"u\";\n}\nfunction isPureRemoteEntry(t) {\n  return !t.entry.includes(\".json\") && t.entry.includes(\".js\");\n}\nfunction safeToString$1(t) {\n  try {\n    return JSON.stringify(t, null, 2);\n  } catch {\n    return \"\";\n  }\n}\nfunction isObject(t) {\n  return t && typeof t == \"object\";\n}\nconst objectToString = Object.prototype.toString;\nfunction isPlainObject(t) {\n  return objectToString.call(t) === \"[object Object]\";\n}\nfunction _extends$1$1() {\n  return _extends$1$1 = Object.assign || function(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var o = arguments[e];\n      for (var n in o)\n        Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]);\n    }\n    return t;\n  }, _extends$1$1.apply(this, arguments);\n}\nfunction _object_without_properties_loose$1(t, e) {\n  if (t == null)\n    return {};\n  var o = {}, n = Object.keys(t), r, i;\n  for (i = 0; i < n.length; i++)\n    r = n[i], !(e.indexOf(r) >= 0) && (o[r] = t[r]);\n  return o;\n}\nconst nativeGlobal = (() => {\n  try {\n    return new Function(\"return this\")();\n  } catch {\n    return globalThis;\n  }\n})(), Global = nativeGlobal;\nfunction definePropertyGlobalVal(t, e, o) {\n  Object.defineProperty(t, e, {\n    value: o,\n    configurable: !1,\n    writable: !0\n  });\n}\nfunction includeOwnProperty(t, e) {\n  return Object.hasOwnProperty.call(t, e);\n}\nincludeOwnProperty(globalThis, \"__GLOBAL_LOADING_REMOTE_ENTRY__\") || definePropertyGlobalVal(globalThis, \"__GLOBAL_LOADING_REMOTE_ENTRY__\", {});\nconst globalLoading = globalThis.__GLOBAL_LOADING_REMOTE_ENTRY__;\nfunction setGlobalDefaultVal(t) {\n  var e, o, n, r, i, a;\n  includeOwnProperty(t, \"__VMOK__\") && !includeOwnProperty(t, \"__FEDERATION__\") && definePropertyGlobalVal(t, \"__FEDERATION__\", t.__VMOK__), includeOwnProperty(t, \"__FEDERATION__\") || (definePropertyGlobalVal(t, \"__FEDERATION__\", {\n    __GLOBAL_PLUGIN__: [],\n    __INSTANCES__: [],\n    moduleInfo: {},\n    __SHARE__: {},\n    __MANIFEST_LOADING__: {},\n    __PRELOADED_MAP__: /* @__PURE__ */ new Map()\n  }), definePropertyGlobalVal(t, \"__VMOK__\", t.__FEDERATION__)), (e = t.__FEDERATION__).__GLOBAL_PLUGIN__ != null || (e.__GLOBAL_PLUGIN__ = []), (o = t.__FEDERATION__).__INSTANCES__ != null || (o.__INSTANCES__ = []), (n = t.__FEDERATION__).moduleInfo != null || (n.moduleInfo = {}), (r = t.__FEDERATION__).__SHARE__ != null || (r.__SHARE__ = {}), (i = t.__FEDERATION__).__MANIFEST_LOADING__ != null || (i.__MANIFEST_LOADING__ = {}), (a = t.__FEDERATION__).__PRELOADED_MAP__ != null || (a.__PRELOADED_MAP__ = /* @__PURE__ */ new Map());\n}\nsetGlobalDefaultVal(globalThis);\nsetGlobalDefaultVal(nativeGlobal);\nfunction getGlobalFederationInstance(t, e) {\n  const o = getBuilderId();\n  return globalThis.__FEDERATION__.__INSTANCES__.find((n) => !!(o && n.options.id === getBuilderId() || n.options.name === t && !n.options.version && !e || n.options.name === t && e && n.options.version === e));\n}\nfunction setGlobalFederationInstance(t) {\n  globalThis.__FEDERATION__.__INSTANCES__.push(t);\n}\nfunction getGlobalFederationConstructor() {\n  return globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__;\n}\nfunction setGlobalFederationConstructor(t, e = isDebugMode$1()) {\n  e && (globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__ = t, globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR_VERSION__ = \"0.1.2\");\n}\nfunction getInfoWithoutType(t, e) {\n  if (typeof e == \"string\") {\n    if (t[e])\n      return {\n        value: t[e],\n        key: e\n      };\n    {\n      const o = Object.keys(t);\n      for (const n of o) {\n        const [r, i] = n.split(\":\"), a = `${r}:${e}`, s = t[a];\n        if (s)\n          return {\n            value: s,\n            key: a\n          };\n      }\n      return {\n        value: void 0,\n        key: e\n      };\n    }\n  } else\n    throw new Error(\"key must be string\");\n}\nconst getGlobalSnapshot = () => nativeGlobal.__FEDERATION__.moduleInfo, getTargetSnapshotInfoByModuleInfo = (t, e) => {\n  const o = getFMId(t), n = getInfoWithoutType(e, o).value;\n  if (n && !n.version && \"version\" in t && t.version && (n.version = t.version), n)\n    return n;\n  if (\"version\" in t && t.version) {\n    const { version: r } = t, i = _object_without_properties_loose$1(t, [\n      \"version\"\n    ]), a = getFMId(i), s = getInfoWithoutType(nativeGlobal.__FEDERATION__.moduleInfo, a).value;\n    if (s?.version === r)\n      return s;\n  }\n}, getGlobalSnapshotInfoByModuleInfo = (t) => getTargetSnapshotInfoByModuleInfo(t, nativeGlobal.__FEDERATION__.moduleInfo), setGlobalSnapshotInfoByModuleInfo = (t, e) => {\n  const o = getFMId(t);\n  return nativeGlobal.__FEDERATION__.moduleInfo[o] = e, nativeGlobal.__FEDERATION__.moduleInfo;\n}, addGlobalSnapshot = (t) => (nativeGlobal.__FEDERATION__.moduleInfo = _extends$1$1({}, nativeGlobal.__FEDERATION__.moduleInfo, t), () => {\n  const e = Object.keys(t);\n  for (const o of e)\n    delete nativeGlobal.__FEDERATION__.moduleInfo[o];\n}), getRemoteEntryExports = (t, e) => {\n  const o = e || `__FEDERATION_${t}:custom__`, n = globalThis[o];\n  return {\n    remoteEntryKey: o,\n    entryExports: n\n  };\n}, getGlobalHostPlugins = () => nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__, getPreloaded = (t) => globalThis.__FEDERATION__.__PRELOADED_MAP__.get(t), setPreloaded = (t) => globalThis.__FEDERATION__.__PRELOADED_MAP__.set(t, !0), DEFAULT_SCOPE = \"default\", DEFAULT_REMOTE_TYPE = \"global\", buildIdentifier = \"[0-9A-Za-z-]+\", build = `(?:\\\\+(${buildIdentifier}(?:\\\\.${buildIdentifier})*))`, numericIdentifier = \"0|[1-9]\\\\d*\", numericIdentifierLoose = \"[0-9]+\", nonNumericIdentifier = \"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\", preReleaseIdentifierLoose = `(?:${numericIdentifierLoose}|${nonNumericIdentifier})`, preReleaseLoose = `(?:-?(${preReleaseIdentifierLoose}(?:\\\\.${preReleaseIdentifierLoose})*))`, preReleaseIdentifier = `(?:${numericIdentifier}|${nonNumericIdentifier})`, preRelease = `(?:-(${preReleaseIdentifier}(?:\\\\.${preReleaseIdentifier})*))`, xRangeIdentifier = `${numericIdentifier}|x|X|\\\\*`, xRangePlain = `[v=\\\\s]*(${xRangeIdentifier})(?:\\\\.(${xRangeIdentifier})(?:\\\\.(${xRangeIdentifier})(?:${preRelease})?${build}?)?)?`, hyphenRange = `^\\\\s*(${xRangePlain})\\\\s+-\\\\s+(${xRangePlain})\\\\s*$`, mainVersionLoose = `(${numericIdentifierLoose})\\\\.(${numericIdentifierLoose})\\\\.(${numericIdentifierLoose})`, loosePlain = `[v=\\\\s]*${mainVersionLoose}${preReleaseLoose}?${build}?`, gtlt = \"((?:<|>)?=?)\", comparatorTrim = `(\\\\s*)${gtlt}\\\\s*(${loosePlain}|${xRangePlain})`, loneTilde = \"(?:~>?)\", tildeTrim = `(\\\\s*)${loneTilde}\\\\s+`, loneCaret = \"(?:\\\\^)\", caretTrim = `(\\\\s*)${loneCaret}\\\\s+`, star = \"(<|>)?=?\\\\s*\\\\*\", caret = `^${loneCaret}${xRangePlain}$`, mainVersion = `(${numericIdentifier})\\\\.(${numericIdentifier})\\\\.(${numericIdentifier})`, fullPlain = `v?${mainVersion}${preRelease}?${build}?`, tilde = `^${loneTilde}${xRangePlain}$`, xRange = `^${gtlt}\\\\s*${xRangePlain}$`, comparator = `^${gtlt}\\\\s*(${fullPlain})$|^$`, gte0 = \"^\\\\s*>=\\\\s*0.0.0\\\\s*$\";\nfunction parseRegex(t) {\n  return new RegExp(t);\n}\nfunction isXVersion(t) {\n  return !t || t.toLowerCase() === \"x\" || t === \"*\";\n}\nfunction pipe(...t) {\n  return (e) => t.reduce((o, n) => n(o), e);\n}\nfunction extractComparator(t) {\n  return t.match(parseRegex(comparator));\n}\nfunction combineVersion(t, e, o, n) {\n  const r = `${t}.${e}.${o}`;\n  return n ? `${r}-${n}` : r;\n}\nfunction parseHyphen(t) {\n  return t.replace(parseRegex(hyphenRange), (e, o, n, r, i, a, s, c, l, u, h, g) => (isXVersion(n) ? o = \"\" : isXVersion(r) ? o = `>=${n}.0.0` : isXVersion(i) ? o = `>=${n}.${r}.0` : o = `>=${o}`, isXVersion(l) ? c = \"\" : isXVersion(u) ? c = `<${Number(l) + 1}.0.0-0` : isXVersion(h) ? c = `<${l}.${Number(u) + 1}.0-0` : g ? c = `<=${l}.${u}.${h}-${g}` : c = `<=${c}`, `${o} ${c}`.trim()));\n}\nfunction parseComparatorTrim(t) {\n  return t.replace(parseRegex(comparatorTrim), \"$1$2$3\");\n}\nfunction parseTildeTrim(t) {\n  return t.replace(parseRegex(tildeTrim), \"$1~\");\n}\nfunction parseCaretTrim(t) {\n  return t.replace(parseRegex(caretTrim), \"$1^\");\n}\nfunction parseCarets(t) {\n  return t.trim().split(/\\s+/).map((e) => e.replace(parseRegex(caret), (o, n, r, i, a) => isXVersion(n) ? \"\" : isXVersion(r) ? `>=${n}.0.0 <${Number(n) + 1}.0.0-0` : isXVersion(i) ? n === \"0\" ? `>=${n}.${r}.0 <${n}.${Number(r) + 1}.0-0` : `>=${n}.${r}.0 <${Number(n) + 1}.0.0-0` : a ? n === \"0\" ? r === \"0\" ? `>=${n}.${r}.${i}-${a} <${n}.${r}.${Number(i) + 1}-0` : `>=${n}.${r}.${i}-${a} <${n}.${Number(r) + 1}.0-0` : `>=${n}.${r}.${i}-${a} <${Number(n) + 1}.0.0-0` : n === \"0\" ? r === \"0\" ? `>=${n}.${r}.${i} <${n}.${r}.${Number(i) + 1}-0` : `>=${n}.${r}.${i} <${n}.${Number(r) + 1}.0-0` : `>=${n}.${r}.${i} <${Number(n) + 1}.0.0-0`)).join(\" \");\n}\nfunction parseTildes(t) {\n  return t.trim().split(/\\s+/).map((e) => e.replace(parseRegex(tilde), (o, n, r, i, a) => isXVersion(n) ? \"\" : isXVersion(r) ? `>=${n}.0.0 <${Number(n) + 1}.0.0-0` : isXVersion(i) ? `>=${n}.${r}.0 <${n}.${Number(r) + 1}.0-0` : a ? `>=${n}.${r}.${i}-${a} <${n}.${Number(r) + 1}.0-0` : `>=${n}.${r}.${i} <${n}.${Number(r) + 1}.0-0`)).join(\" \");\n}\nfunction parseXRanges(t) {\n  return t.split(/\\s+/).map((e) => e.trim().replace(parseRegex(xRange), (o, n, r, i, a, s) => {\n    const c = isXVersion(r), l = c || isXVersion(i), u = l || isXVersion(a);\n    return n === \"=\" && u && (n = \"\"), s = \"\", c ? n === \">\" || n === \"<\" ? \"<0.0.0-0\" : \"*\" : n && u ? (l && (i = 0), a = 0, n === \">\" ? (n = \">=\", l ? (r = Number(r) + 1, i = 0, a = 0) : (i = Number(i) + 1, a = 0)) : n === \"<=\" && (n = \"<\", l ? r = Number(r) + 1 : i = Number(i) + 1), n === \"<\" && (s = \"-0\"), `${n + r}.${i}.${a}${s}`) : l ? `>=${r}.0.0${s} <${Number(r) + 1}.0.0-0` : u ? `>=${r}.${i}.0${s} <${r}.${Number(i) + 1}.0-0` : o;\n  })).join(\" \");\n}\nfunction parseStar(t) {\n  return t.trim().replace(parseRegex(star), \"\");\n}\nfunction parseGTE0(t) {\n  return t.trim().replace(parseRegex(gte0), \"\");\n}\nfunction compareAtom(t, e) {\n  return t = Number(t) || t, e = Number(e) || e, t > e ? 1 : t === e ? 0 : -1;\n}\nfunction comparePreRelease(t, e) {\n  const { preRelease: o } = t, { preRelease: n } = e;\n  if (o === void 0 && n)\n    return 1;\n  if (o && n === void 0)\n    return -1;\n  if (o === void 0 && n === void 0)\n    return 0;\n  for (let r = 0, i = o.length; r <= i; r++) {\n    const a = o[r], s = n[r];\n    if (a !== s)\n      return a === void 0 && s === void 0 ? 0 : a ? s ? compareAtom(a, s) : -1 : 1;\n  }\n  return 0;\n}\nfunction compareVersion(t, e) {\n  return compareAtom(t.major, e.major) || compareAtom(t.minor, e.minor) || compareAtom(t.patch, e.patch) || comparePreRelease(t, e);\n}\nfunction eq(t, e) {\n  return t.version === e.version;\n}\nfunction compare(t, e) {\n  switch (t.operator) {\n    case \"\":\n    case \"=\":\n      return eq(t, e);\n    case \">\":\n      return compareVersion(t, e) < 0;\n    case \">=\":\n      return eq(t, e) || compareVersion(t, e) < 0;\n    case \"<\":\n      return compareVersion(t, e) > 0;\n    case \"<=\":\n      return eq(t, e) || compareVersion(t, e) > 0;\n    case void 0:\n      return !0;\n    default:\n      return !1;\n  }\n}\nfunction parseComparatorString(t) {\n  return pipe(\n    parseCarets,\n    parseTildes,\n    parseXRanges,\n    parseStar\n  )(t);\n}\nfunction parseRange(t) {\n  return pipe(\n    parseHyphen,\n    parseComparatorTrim,\n    parseTildeTrim,\n    parseCaretTrim\n  )(t.trim()).split(/\\s+/).join(\" \");\n}\nfunction satisfy(t, e) {\n  if (!t)\n    return !1;\n  const o = parseRange(e).split(\" \").map((u) => parseComparatorString(u)).join(\" \").split(/\\s+/).map((u) => parseGTE0(u)), n = extractComparator(t);\n  if (!n)\n    return !1;\n  const [, r, , i, a, s, c] = n, l = {\n    operator: r,\n    version: combineVersion(i, a, s, c),\n    major: i,\n    minor: a,\n    patch: s,\n    preRelease: c?.split(\".\")\n  };\n  for (const u of o) {\n    const h = extractComparator(u);\n    if (!h)\n      return !1;\n    const [, g, , p, d, m, M] = h, I = {\n      operator: g,\n      version: combineVersion(p, d, m, M),\n      major: p,\n      minor: d,\n      patch: m,\n      preRelease: M?.split(\".\")\n    };\n    if (!compare(I, l))\n      return !1;\n  }\n  return !0;\n}\nfunction _extends$6() {\n  return _extends$6 = Object.assign || function(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var o = arguments[e];\n      for (var n in o)\n        Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]);\n    }\n    return t;\n  }, _extends$6.apply(this, arguments);\n}\nfunction formatShare(t, e) {\n  let o;\n  return \"get\" in t ? o = t.get : o = () => Promise.resolve(t.lib), _extends$6({\n    deps: [],\n    useIn: [],\n    from: e,\n    loading: null\n  }, t, {\n    shareConfig: _extends$6({\n      requiredVersion: `^${t.version}`,\n      singleton: !1,\n      eager: !1,\n      strictVersion: !1\n    }, t.shareConfig),\n    get: o,\n    loaded: \"lib\" in t ? !0 : void 0,\n    scope: Array.isArray(t.scope) ? t.scope : [\n      \"default\"\n    ],\n    strategy: t.strategy || \"version-first\"\n  });\n}\nfunction formatShareConfigs(t, e) {\n  return t ? Object.keys(t).reduce((o, n) => (o[n] = formatShare(t[n], e), o), {}) : {};\n}\nfunction versionLt(t, e) {\n  const o = (n) => {\n    if (!Number.isNaN(Number(n))) {\n      const r = n.split(\".\");\n      let i = n;\n      for (let a = 0; a < 3 - r.length; a++)\n        i += \".0\";\n      return i;\n    }\n    return n;\n  };\n  return !!satisfy(o(t), `<=${o(e)}`);\n}\nconst findVersion = (t, e, o, n) => {\n  const r = t[e][o], i = n || function(a, s) {\n    return versionLt(a, s);\n  };\n  return Object.keys(r).reduce((a, s) => !a || i(a, s) || a === \"0\" ? s : a, 0);\n}, isLoaded = (t) => !!t.loaded || typeof t.lib == \"function\";\nfunction findSingletonVersionOrderByVersion(t, e, o) {\n  const n = t[e][o];\n  return findVersion(t, e, o, function(r, i) {\n    return !isLoaded(n[r]) && versionLt(r, i);\n  });\n}\nfunction findSingletonVersionOrderByLoaded(t, e, o) {\n  const n = t[e][o];\n  return findVersion(t, e, o, function(r, i) {\n    return isLoaded(n[i]) ? isLoaded(n[r]) ? !!versionLt(r, i) : !0 : isLoaded(n[r]) ? !1 : versionLt(r, i);\n  });\n}\nfunction getFindShareFunction(t) {\n  return t === \"loaded-first\" ? findSingletonVersionOrderByLoaded : findSingletonVersionOrderByVersion;\n}\nfunction getRegisteredShare(t, e, o, n) {\n  if (!t)\n    return;\n  const { shareConfig: r, scope: i = DEFAULT_SCOPE, strategy: a } = o, s = Array.isArray(i) ? i : [\n    i\n  ];\n  for (const c of s)\n    if (r && t[c] && t[c][e]) {\n      const { requiredVersion: l } = r, u = getFindShareFunction(a)(t, c, e), h = () => {\n        if (r.singleton) {\n          if (typeof l == \"string\" && !satisfy(u, l)) {\n            const p = `Version ${u} from ${u && t[c][e][u].from} of shared singleton module ${e} does not satisfy the requirement of ${o.from} which needs ${l})`;\n            r.strictVersion ? error(p) : warn$1(p);\n          }\n          return t[c][e][u];\n        } else {\n          if (l === !1 || l === \"*\" || satisfy(u, l))\n            return t[c][e][u];\n          for (const [p, d] of Object.entries(t[c][e]))\n            if (satisfy(p, l))\n              return d;\n        }\n      }, g = {\n        shareScopeMap: t,\n        scope: c,\n        pkgName: e,\n        version: u,\n        GlobalFederation: Global.__FEDERATION__,\n        resolver: h\n      };\n      return (n.emit(g) || g).resolver();\n    }\n}\nfunction getGlobalShareScope() {\n  return Global.__FEDERATION__.__SHARE__;\n}\nfunction _define_property$3(t, e, o) {\n  return e in t ? Object.defineProperty(t, e, {\n    value: o,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : t[e] = o, t;\n}\nvar MANIFEST_EXT = \".json\", BROWSER_LOG_KEY = \"FEDERATION_DEBUG\", BROWSER_LOG_VALUE = \"1\", NameTransformSymbol = {\n  AT: \"@\",\n  HYPHEN: \"-\",\n  SLASH: \"/\"\n}, _obj, NameTransformMap = (_obj = {}, _define_property$3(_obj, NameTransformSymbol.AT, \"scope_\"), _define_property$3(_obj, NameTransformSymbol.HYPHEN, \"_\"), _define_property$3(_obj, NameTransformSymbol.SLASH, \"__\"), _obj), _obj1;\n_obj1 = {}, _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.AT], NameTransformSymbol.AT), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.HYPHEN], NameTransformSymbol.HYPHEN), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.SLASH], NameTransformSymbol.SLASH);\nvar SEPARATOR = \":\";\nfunction isBrowserEnv() {\n  return typeof window < \"u\";\n}\nfunction isDebugMode() {\n  return typeof process < \"u\" && process.env && process.env.FEDERATION_DEBUG ? !!process.env.FEDERATION_DEBUG : typeof FEDERATION_DEBUG < \"u\" && !!FEDERATION_DEBUG;\n}\nfunction _array_like_to_array$2(t, e) {\n  (e == null || e > t.length) && (e = t.length);\n  for (var o = 0, n = new Array(e); o < e; o++)\n    n[o] = t[o];\n  return n;\n}\nfunction _array_without_holes(t) {\n  if (Array.isArray(t))\n    return _array_like_to_array$2(t);\n}\nfunction _class_call_check(t, e) {\n  if (!(t instanceof e))\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(t, e) {\n  for (var o = 0; o < e.length; o++) {\n    var n = e[o];\n    n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n  }\n}\nfunction _create_class(t, e, o) {\n  return e && _defineProperties(t.prototype, e), o && _defineProperties(t, o), t;\n}\nfunction _define_property$2(t, e, o) {\n  return e in t ? Object.defineProperty(t, e, {\n    value: o,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : t[e] = o, t;\n}\nfunction _iterable_to_array$1(t) {\n  if (typeof Symbol < \"u\" && t[Symbol.iterator] != null || t[\"@@iterator\"] != null)\n    return Array.from(t);\n}\nfunction _non_iterable_spread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _to_consumable_array(t) {\n  return _array_without_holes(t) || _iterable_to_array$1(t) || _unsupported_iterable_to_array$2(t) || _non_iterable_spread();\n}\nfunction _unsupported_iterable_to_array$2(t, e) {\n  if (t) {\n    if (typeof t == \"string\")\n      return _array_like_to_array$2(t, e);\n    var o = Object.prototype.toString.call(t).slice(8, -1);\n    if (o === \"Object\" && t.constructor && (o = t.constructor.name), o === \"Map\" || o === \"Set\")\n      return Array.from(o);\n    if (o === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))\n      return _array_like_to_array$2(t, e);\n  }\n}\nfunction safeToString(t) {\n  try {\n    return JSON.stringify(t, null, 2);\n  } catch {\n    return \"\";\n  }\n}\nvar DEBUG_LOG = \"[ FEDERATION DEBUG ]\";\nfunction safeGetLocalStorageItem() {\n  try {\n    if (typeof window < \"u\" && window.localStorage)\n      return localStorage.getItem(BROWSER_LOG_KEY) === BROWSER_LOG_VALUE;\n  } catch {\n    return typeof document < \"u\";\n  }\n  return !1;\n}\nvar Logger = /* @__PURE__ */ function() {\n  function t(e) {\n    _class_call_check(this, t), _define_property$2(this, \"enable\", !1), _define_property$2(this, \"identifier\", void 0), this.identifier = e || DEBUG_LOG, isBrowserEnv() && safeGetLocalStorageItem() ? this.enable = !0 : isDebugMode() && (this.enable = !0);\n  }\n  return _create_class(t, [\n    {\n      key: \"info\",\n      value: function(e, o) {\n        if (this.enable) {\n          var n = safeToString(o) || \"\";\n          isBrowserEnv() ? console.info(\"%c \".concat(this.identifier, \": \").concat(e, \" \").concat(n), \"color:#3300CC\") : console.info(\"\\x1B[34m%s\", \"\".concat(this.identifier, \": \").concat(e, \" \").concat(n ? `\n`.concat(n) : \"\"));\n        }\n      }\n    },\n    {\n      key: \"logOriginalInfo\",\n      value: function() {\n        for (var e = arguments.length, o = new Array(e), n = 0; n < e; n++)\n          o[n] = arguments[n];\n        if (this.enable)\n          if (isBrowserEnv()) {\n            var r;\n            console.info(\"%c \".concat(this.identifier, \": OriginalInfo\"), \"color:#3300CC\"), (r = console).log.apply(r, _to_consumable_array(o));\n          } else {\n            var i;\n            console.info(\"%c \".concat(this.identifier, \": OriginalInfo\"), \"color:#3300CC\"), (i = console).log.apply(i, _to_consumable_array(o));\n          }\n      }\n    }\n  ]), t;\n}(), LOG_CATEGORY = \"[ Federation Runtime ]\";\nnew Logger();\nvar composeKeyWithSeparator = function() {\n  for (var t = arguments.length, e = new Array(t), o = 0; o < t; o++)\n    e[o] = arguments[o];\n  return e.length ? e.reduce(function(n, r) {\n    return r ? n ? \"\".concat(n).concat(SEPARATOR).concat(r) : r : n;\n  }, \"\") : \"\";\n}, getResourceUrl = function(t, e) {\n  if (\"getPublicPath\" in t) {\n    var o = new Function(t.getPublicPath)();\n    return \"\".concat(o).concat(e);\n  } else\n    return \"publicPath\" in t ? \"\".concat(t.publicPath).concat(e) : (console.warn(\"Can not get resource url, if in debug mode, please ignore\", t, e), \"\");\n}, warn = function(t) {\n  console.warn(\"\".concat(LOG_CATEGORY, \": \").concat(t));\n};\nfunction _define_property$1(t, e, o) {\n  return e in t ? Object.defineProperty(t, e, {\n    value: o,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : t[e] = o, t;\n}\nfunction _object_spread$1(t) {\n  for (var e = 1; e < arguments.length; e++) {\n    var o = arguments[e] != null ? arguments[e] : {}, n = Object.keys(o);\n    typeof Object.getOwnPropertySymbols == \"function\" && (n = n.concat(Object.getOwnPropertySymbols(o).filter(function(r) {\n      return Object.getOwnPropertyDescriptor(o, r).enumerable;\n    }))), n.forEach(function(r) {\n      _define_property$1(t, r, o[r]);\n    });\n  }\n  return t;\n}\nfunction ownKeys(t, e) {\n  var o = Object.keys(t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(t);\n    e && (n = n.filter(function(r) {\n      return Object.getOwnPropertyDescriptor(t, r).enumerable;\n    })), o.push.apply(o, n);\n  }\n  return o;\n}\nfunction _object_spread_props(t, e) {\n  return e = e ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)) : ownKeys(Object(e)).forEach(function(o) {\n    Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(e, o));\n  }), t;\n}\nvar simpleJoinRemoteEntry = function(t, e) {\n  if (!t)\n    return e;\n  var o = function(r) {\n    if (r === \".\")\n      return \"\";\n    if (r.startsWith(\"./\"))\n      return r.replace(\"./\", \"\");\n    if (r.startsWith(\"/\")) {\n      var i = r.slice(1);\n      return i.endsWith(\"/\") ? i.slice(0, -1) : i;\n    }\n    return r;\n  }, n = o(t);\n  return n ? n.endsWith(\"/\") ? \"\".concat(n).concat(e) : \"\".concat(n, \"/\").concat(e) : e;\n};\nfunction generateSnapshotFromManifest(t) {\n  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o, n, r = e.remotes, i = r === void 0 ? {} : r, a = e.overrides, s = a === void 0 ? {} : a, c = e.version, l, u = function() {\n    return \"publicPath\" in t.metaData ? t.metaData.publicPath : t.metaData.getPublicPath;\n  }, h = Object.keys(s), g = {};\n  if (!Object.keys(i).length) {\n    var p;\n    g = ((p = t.remotes) === null || p === void 0 ? void 0 : p.reduce(function(w, R) {\n      var U, W = R.federationContainerName;\n      return h.includes(W) ? U = s[W] : \"version\" in R ? U = R.version : U = R.entry, w[W] = {\n        matchedVersion: U\n      }, w;\n    }, {})) || {};\n  }\n  Object.keys(i).forEach(function(w) {\n    return g[w] = {\n      matchedVersion: h.includes(w) ? s[w] : i[w]\n    };\n  });\n  var d = t.metaData, m = d.remoteEntry, M = m.path, I = m.name, D = m.type, S = d.types, O = d.buildInfo.buildVersion, L = d.globalName, v = t.exposes, y = {\n    version: c || \"\",\n    buildVersion: O,\n    globalName: L,\n    remoteEntry: simpleJoinRemoteEntry(M, I),\n    remoteEntryType: D,\n    remoteTypes: simpleJoinRemoteEntry(S.path, S.name),\n    remoteTypesZip: S.zip || \"\",\n    remoteTypesAPI: S.api || \"\",\n    remotesInfo: g,\n    shared: t?.shared.map(function(w) {\n      return {\n        assets: w.assets,\n        sharedName: w.name\n      };\n    }),\n    modules: v?.map(function(w) {\n      return {\n        moduleName: w.name,\n        modulePath: w.path,\n        assets: w.assets\n      };\n    })\n  };\n  if (!((o = t.metaData) === null || o === void 0) && o.prefetchInterface) {\n    var A = t.metaData.prefetchInterface;\n    y = _object_spread_props(_object_spread$1({}, y), {\n      prefetchInterface: A\n    });\n  }\n  if (!((n = t.metaData) === null || n === void 0) && n.prefetchEntry) {\n    var b = t.metaData.prefetchEntry, x = b.path, H = b.name, $ = b.type;\n    y = _object_spread_props(_object_spread$1({}, y), {\n      prefetchEntry: simpleJoinRemoteEntry(x, H),\n      prefetchEntryType: $\n    });\n  }\n  return \"publicPath\" in t.metaData ? l = _object_spread_props(_object_spread$1({}, y), {\n    publicPath: u()\n  }) : l = _object_spread_props(_object_spread$1({}, y), {\n    getPublicPath: u()\n  }), l;\n}\nfunction isManifestProvider(t) {\n  return !!(\"remoteEntry\" in t && t.remoteEntry.includes(MANIFEST_EXT));\n}\nfunction asyncGeneratorStep$1(t, e, o, n, r, i, a) {\n  try {\n    var s = t[i](a), c = s.value;\n  } catch (l) {\n    o(l);\n    return;\n  }\n  s.done ? e(c) : Promise.resolve(c).then(n, r);\n}\nfunction _async_to_generator$1(t) {\n  return function() {\n    var e = this, o = arguments;\n    return new Promise(function(n, r) {\n      var i = t.apply(e, o);\n      function a(c) {\n        asyncGeneratorStep$1(i, n, r, a, s, \"next\", c);\n      }\n      function s(c) {\n        asyncGeneratorStep$1(i, n, r, a, s, \"throw\", c);\n      }\n      a(void 0);\n    });\n  };\n}\nfunction _instanceof(t, e) {\n  return e != null && typeof Symbol < \"u\" && e[Symbol.hasInstance] ? !!e[Symbol.hasInstance](t) : t instanceof e;\n}\nfunction _ts_generator$1(t, e) {\n  var o, n, r, i, a = {\n    label: 0,\n    sent: function() {\n      if (r[0] & 1)\n        throw r[1];\n      return r[1];\n    },\n    trys: [],\n    ops: []\n  };\n  return i = {\n    next: s(0),\n    throw: s(1),\n    return: s(2)\n  }, typeof Symbol == \"function\" && (i[Symbol.iterator] = function() {\n    return this;\n  }), i;\n  function s(l) {\n    return function(u) {\n      return c([\n        l,\n        u\n      ]);\n    };\n  }\n  function c(l) {\n    if (o)\n      throw new TypeError(\"Generator is already executing.\");\n    for (; a; )\n      try {\n        if (o = 1, n && (r = l[0] & 2 ? n.return : l[0] ? n.throw || ((r = n.return) && r.call(n), 0) : n.next) && !(r = r.call(n, l[1])).done)\n          return r;\n        switch (n = 0, r && (l = [\n          l[0] & 2,\n          r.value\n        ]), l[0]) {\n          case 0:\n          case 1:\n            r = l;\n            break;\n          case 4:\n            return a.label++, {\n              value: l[1],\n              done: !1\n            };\n          case 5:\n            a.label++, n = l[1], l = [\n              0\n            ];\n            continue;\n          case 7:\n            l = a.ops.pop(), a.trys.pop();\n            continue;\n          default:\n            if (r = a.trys, !(r = r.length > 0 && r[r.length - 1]) && (l[0] === 6 || l[0] === 2)) {\n              a = 0;\n              continue;\n            }\n            if (l[0] === 3 && (!r || l[1] > r[0] && l[1] < r[3])) {\n              a.label = l[1];\n              break;\n            }\n            if (l[0] === 6 && a.label < r[1]) {\n              a.label = r[1], r = l;\n              break;\n            }\n            if (r && a.label < r[2]) {\n              a.label = r[2], a.ops.push(l);\n              break;\n            }\n            r[2] && a.ops.pop(), a.trys.pop();\n            continue;\n        }\n        l = e.call(t, a);\n      } catch (u) {\n        l = [\n          6,\n          u\n        ], n = 0;\n      } finally {\n        o = r = 0;\n      }\n    if (l[0] & 5)\n      throw l[1];\n    return {\n      value: l[0] ? l[1] : void 0,\n      done: !0\n    };\n  }\n}\nfunction safeWrapper(t, e) {\n  return _safeWrapper.apply(this, arguments);\n}\nfunction _safeWrapper() {\n  return _safeWrapper = _async_to_generator$1(function(t, e) {\n    var o, n;\n    return _ts_generator$1(this, function(r) {\n      switch (r.label) {\n        case 0:\n          return r.trys.push([\n            0,\n            2,\n            ,\n            3\n          ]), [\n            4,\n            t()\n          ];\n        case 1:\n          return o = r.sent(), [\n            2,\n            o\n          ];\n        case 2:\n          return n = r.sent(), !e && warn(n), [\n            2\n          ];\n        case 3:\n          return [\n            2\n          ];\n      }\n    });\n  }), _safeWrapper.apply(this, arguments);\n}\nfunction isStaticResourcesEqual(t, e) {\n  var o = /^(https?:)?\\/\\//i, n = t.replace(o, \"\").replace(/\\/$/, \"\"), r = e.replace(o, \"\").replace(/\\/$/, \"\");\n  return n === r;\n}\nfunction createScript(t, e, o, n) {\n  for (var r = null, i = !0, a = document.getElementsByTagName(\"script\"), s = 0; s < a.length; s++) {\n    var c = a[s], l = c.getAttribute(\"src\");\n    if (l && isStaticResourcesEqual(l, t)) {\n      r = c, i = !1;\n      break;\n    }\n  }\n  if (!r && (r = document.createElement(\"script\"), r.type = \"text/javascript\", r.src = t, n)) {\n    var u = n(t);\n    _instanceof(u, HTMLScriptElement) && (r = u);\n  }\n  o && Object.keys(o).forEach(function(g) {\n    r && (g === \"async\" || g === \"defer\" ? r[g] = o[g] : r.setAttribute(g, o[g]));\n  });\n  var h = function(g, p) {\n    if (r && (r.onerror = null, r.onload = null, safeWrapper(function() {\n      r != null && r.parentNode && r.parentNode.removeChild(r);\n    }), g)) {\n      var d = g(p);\n      return e(), d;\n    }\n    e();\n  };\n  return r.onerror = h.bind(null, r.onerror), r.onload = h.bind(null, r.onload), {\n    script: r,\n    needAttach: i\n  };\n}\nfunction createLink(t, e) {\n  for (var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = arguments.length > 3 ? arguments[3] : void 0, r = null, i = !0, a = document.getElementsByTagName(\"link\"), s = 0; s < a.length; s++) {\n    var c = a[s], l = c.getAttribute(\"href\"), u = c.getAttribute(\"ref\");\n    if (l && isStaticResourcesEqual(l, t) && u === o.ref) {\n      r = c, i = !1;\n      break;\n    }\n  }\n  if (!r && (r = document.createElement(\"link\"), r.setAttribute(\"href\", t), n)) {\n    var h = n(t);\n    _instanceof(h, HTMLLinkElement) && (r = h);\n  }\n  o && Object.keys(o).forEach(function(p) {\n    r && r.setAttribute(p, o[p]);\n  });\n  var g = function(p, d) {\n    if (r && (r.onerror = null, r.onload = null, safeWrapper(function() {\n      r != null && r.parentNode && r.parentNode.removeChild(r);\n    }), p)) {\n      var m = p(d);\n      return e(), m;\n    }\n    e();\n  };\n  return r.onerror = g.bind(null, r.onerror), r.onload = g.bind(null, r.onload), {\n    link: r,\n    needAttach: i\n  };\n}\nfunction loadScript(t, e) {\n  var o = e.attrs, n = e.createScriptHook;\n  return new Promise(function(r, i) {\n    var a = createScript(t, r, o, n), s = a.script, c = a.needAttach;\n    c && document.getElementsByTagName(\"head\")[0].appendChild(s);\n  });\n}\nfunction _array_like_to_array(t, e) {\n  (e == null || e > t.length) && (e = t.length);\n  for (var o = 0, n = new Array(e); o < e; o++)\n    n[o] = t[o];\n  return n;\n}\nfunction _array_with_holes(t) {\n  if (Array.isArray(t))\n    return t;\n}\nfunction asyncGeneratorStep(t, e, o, n, r, i, a) {\n  try {\n    var s = t[i](a), c = s.value;\n  } catch (l) {\n    o(l);\n    return;\n  }\n  s.done ? e(c) : Promise.resolve(c).then(n, r);\n}\nfunction _async_to_generator(t) {\n  return function() {\n    var e = this, o = arguments;\n    return new Promise(function(n, r) {\n      var i = t.apply(e, o);\n      function a(c) {\n        asyncGeneratorStep(i, n, r, a, s, \"next\", c);\n      }\n      function s(c) {\n        asyncGeneratorStep(i, n, r, a, s, \"throw\", c);\n      }\n      a(void 0);\n    });\n  };\n}\nfunction _iterable_to_array_limit(t, e) {\n  var o = t == null ? null : typeof Symbol < \"u\" && t[Symbol.iterator] || t[\"@@iterator\"];\n  if (o != null) {\n    var n = [], r = !0, i = !1, a, s;\n    try {\n      for (o = o.call(t); !(r = (a = o.next()).done) && (n.push(a.value), !(e && n.length === e)); r = !0)\n        ;\n    } catch (c) {\n      i = !0, s = c;\n    } finally {\n      try {\n        !r && o.return != null && o.return();\n      } finally {\n        if (i)\n          throw s;\n      }\n    }\n    return n;\n  }\n}\nfunction _non_iterable_rest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array(t, e) {\n  return _array_with_holes(t) || _iterable_to_array_limit(t, e) || _unsupported_iterable_to_array(t, e) || _non_iterable_rest();\n}\nfunction _unsupported_iterable_to_array(t, e) {\n  if (t) {\n    if (typeof t == \"string\")\n      return _array_like_to_array(t, e);\n    var o = Object.prototype.toString.call(t).slice(8, -1);\n    if (o === \"Object\" && t.constructor && (o = t.constructor.name), o === \"Map\" || o === \"Set\")\n      return Array.from(o);\n    if (o === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))\n      return _array_like_to_array(t, e);\n  }\n}\nfunction _ts_generator(t, e) {\n  var o, n, r, i, a = {\n    label: 0,\n    sent: function() {\n      if (r[0] & 1)\n        throw r[1];\n      return r[1];\n    },\n    trys: [],\n    ops: []\n  };\n  return i = {\n    next: s(0),\n    throw: s(1),\n    return: s(2)\n  }, typeof Symbol == \"function\" && (i[Symbol.iterator] = function() {\n    return this;\n  }), i;\n  function s(l) {\n    return function(u) {\n      return c([\n        l,\n        u\n      ]);\n    };\n  }\n  function c(l) {\n    if (o)\n      throw new TypeError(\"Generator is already executing.\");\n    for (; a; )\n      try {\n        if (o = 1, n && (r = l[0] & 2 ? n.return : l[0] ? n.throw || ((r = n.return) && r.call(n), 0) : n.next) && !(r = r.call(n, l[1])).done)\n          return r;\n        switch (n = 0, r && (l = [\n          l[0] & 2,\n          r.value\n        ]), l[0]) {\n          case 0:\n          case 1:\n            r = l;\n            break;\n          case 4:\n            return a.label++, {\n              value: l[1],\n              done: !1\n            };\n          case 5:\n            a.label++, n = l[1], l = [\n              0\n            ];\n            continue;\n          case 7:\n            l = a.ops.pop(), a.trys.pop();\n            continue;\n          default:\n            if (r = a.trys, !(r = r.length > 0 && r[r.length - 1]) && (l[0] === 6 || l[0] === 2)) {\n              a = 0;\n              continue;\n            }\n            if (l[0] === 3 && (!r || l[1] > r[0] && l[1] < r[3])) {\n              a.label = l[1];\n              break;\n            }\n            if (l[0] === 6 && a.label < r[1]) {\n              a.label = r[1], r = l;\n              break;\n            }\n            if (r && a.label < r[2]) {\n              a.label = r[2], a.ops.push(l);\n              break;\n            }\n            r[2] && a.ops.pop(), a.trys.pop();\n            continue;\n        }\n        l = e.call(t, a);\n      } catch (u) {\n        l = [\n          6,\n          u\n        ], n = 0;\n      } finally {\n        o = r = 0;\n      }\n    if (l[0] & 5)\n      throw l[1];\n    return {\n      value: l[0] ? l[1] : void 0,\n      done: !0\n    };\n  }\n}\nfunction importNodeModule(t) {\n  if (!t)\n    throw new Error(\"import specifier is required\");\n  var e = new Function(\"name\", \"return import(name)\");\n  return e(t).then(function(o) {\n    return o.default;\n  }).catch(function(o) {\n    throw console.error(\"Error importing module \".concat(t, \":\"), o), o;\n  });\n}\nfunction createScriptNode(url, cb, attrs, createScriptHook) {\n  if (createScriptHook) {\n    var hookResult = createScriptHook(url);\n    hookResult && typeof hookResult == \"object\" && \"url\" in hookResult && (url = hookResult.url);\n  }\n  var urlObj;\n  try {\n    urlObj = new URL(url);\n  } catch (t) {\n    console.error(\"Error constructing URL:\", t), cb(new Error(\"Invalid URL: \".concat(t)));\n    return;\n  }\n  var getFetch = function() {\n    var t = _async_to_generator(function() {\n      var e;\n      return _ts_generator(this, function(o) {\n        switch (o.label) {\n          case 0:\n            return typeof fetch > \"u\" ? [\n              4,\n              importNodeModule(\"node-fetch\")\n            ] : [\n              3,\n              2\n            ];\n          case 1:\n            return e = o.sent(), [\n              2,\n              e?.default || e\n            ];\n          case 2:\n            return [\n              2,\n              fetch\n            ];\n          case 3:\n            return [\n              2\n            ];\n        }\n      });\n    });\n    return function() {\n      return t.apply(this, arguments);\n    };\n  }();\n  console.log(\"fetching\", urlObj.href), getFetch().then(function(f) {\n    f(urlObj.href).then(function(t) {\n      return t.text();\n    }).then(function() {\n      var _ref = _async_to_generator(function(data) {\n        var _ref, path, vm, scriptContext, urlDirname, filename, script, exportedInterface, container;\n        return _ts_generator(this, function(_state) {\n          switch (_state.label) {\n            case 0:\n              return [\n                4,\n                Promise.all([\n                  importNodeModule(\"path\"),\n                  importNodeModule(\"vm\")\n                ])\n              ];\n            case 1:\n              _ref = _sliced_to_array.apply(void 0, [\n                _state.sent(),\n                2\n              ]), path = _ref[0], vm = _ref[1], scriptContext = {\n                exports: {},\n                module: {\n                  exports: {}\n                }\n              }, urlDirname = urlObj.pathname.split(\"/\").slice(0, -1).join(\"/\"), filename = path.basename(urlObj.pathname);\n              try {\n                if (script = new vm.Script(\"(function(exports, module, require, __dirname, __filename) {\".concat(data, `\n})`), filename), script.runInThisContext()(scriptContext.exports, scriptContext.module, eval(\"require\"), urlDirname, filename), exportedInterface = scriptContext.module.exports || scriptContext.exports, attrs && exportedInterface && attrs.globalName)\n                  return container = exportedInterface[attrs.globalName] || exportedInterface, cb(void 0, container), [\n                    2\n                  ];\n                cb(void 0, exportedInterface);\n              } catch (t) {\n                cb(new Error(\"Script execution error: \".concat(t)));\n              }\n              return [\n                2\n              ];\n          }\n        });\n      });\n      return function(t) {\n        return _ref.apply(this, arguments);\n      };\n    }()).catch(function(t) {\n      cb(t);\n    });\n  });\n}\nfunction loadScriptNode(t, e) {\n  return new Promise(function(o, n) {\n    createScriptNode(t, function(r, i) {\n      if (r)\n        n(r);\n      else {\n        var a, s, c = (e == null || (a = e.attrs) === null || a === void 0 ? void 0 : a.globalName) || \"__FEDERATION_\".concat(e == null || (s = e.attrs) === null || s === void 0 ? void 0 : s.name, \":custom__\"), l = globalThis[c] = i;\n        o(l);\n      }\n    }, e.attrs, e.createScriptHook);\n  });\n}\nfunction matchRemoteWithNameAndExpose(t, e) {\n  for (const o of t) {\n    const n = e.startsWith(o.name);\n    let r = e.replace(o.name, \"\");\n    if (n) {\n      if (r.startsWith(\"/\")) {\n        const s = o.name;\n        return r = `.${r}`, {\n          pkgNameOrAlias: s,\n          expose: r,\n          remote: o\n        };\n      } else if (r === \"\")\n        return {\n          pkgNameOrAlias: o.name,\n          expose: \".\",\n          remote: o\n        };\n    }\n    const i = o.alias && e.startsWith(o.alias);\n    let a = o.alias && e.replace(o.alias, \"\");\n    if (o.alias && i) {\n      if (a && a.startsWith(\"/\")) {\n        const s = o.alias;\n        return a = `.${a}`, {\n          pkgNameOrAlias: s,\n          expose: a,\n          remote: o\n        };\n      } else if (a === \"\")\n        return {\n          pkgNameOrAlias: o.alias,\n          expose: \".\",\n          remote: o\n        };\n    }\n  }\n}\nfunction matchRemote(t, e) {\n  for (const o of t)\n    if (e === o.name || o.alias && e === o.alias)\n      return o;\n}\nfunction registerPlugins(t, e) {\n  const o = getGlobalHostPlugins();\n  o.length > 0 && o.forEach((n) => {\n    t != null && t.find((r) => r.name !== n.name) && t.push(n);\n  }), t && t.length > 0 && t.forEach((n) => {\n    e.forEach((r) => {\n      r.applyPlugin(n);\n    });\n  });\n}\nfunction _extends$5() {\n  return _extends$5 = Object.assign || function(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var o = arguments[e];\n      for (var n in o)\n        Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]);\n    }\n    return t;\n  }, _extends$5.apply(this, arguments);\n}\nasync function loadEsmEntry({ entry: t, remoteEntryExports: e }) {\n  return new Promise((o, n) => {\n    try {\n      e ? o(e) : new Function(\"callbacks\", `import(\"${t}\").then(callbacks[0]).catch(callbacks[1])`)([\n        o,\n        n\n      ]);\n    } catch (r) {\n      n(r);\n    }\n  });\n}\nasync function loadEntryScript({ name: t, globalName: e, entry: o, createScriptHook: n }) {\n  const { entryExports: r } = getRemoteEntryExports(t, e);\n  return r || (typeof document > \"u\" ? loadScriptNode(o, {\n    attrs: {\n      name: t,\n      globalName: e\n    },\n    createScriptHook: n\n  }).then(() => {\n    const { remoteEntryKey: i, entryExports: a } = getRemoteEntryExports(t, e);\n    return assert(a, `\n        Unable to use the ${t}'s '${o}' URL with ${i}'s globalName to get remoteEntry exports.\n        Possible reasons could be:\n\n        1. '${o}' is not the correct URL, or the remoteEntry resource or name is incorrect.\n\n        2. ${i} cannot be used to get remoteEntry exports in the window object.\n      `), a;\n  }).catch((i) => i) : loadScript(o, {\n    attrs: {},\n    createScriptHook: n\n  }).then(() => {\n    const { remoteEntryKey: i, entryExports: a } = getRemoteEntryExports(t, e);\n    return assert(a, `\n      Unable to use the ${t}'s '${o}' URL with ${i}'s globalName to get remoteEntry exports.\n      Possible reasons could be:\n\n      1. '${o}' is not the correct URL, or the remoteEntry resource or name is incorrect.\n\n      2. ${i} cannot be used to get remoteEntry exports in the window object.\n    `), a;\n  }).catch((i) => i));\n}\nfunction getRemoteEntryUniqueKey(t) {\n  const { entry: e, name: o } = t;\n  return composeKeyWithSeparator(o, e);\n}\nasync function getRemoteEntry({ remoteEntryExports: t, remoteInfo: e, createScriptHook: o }) {\n  const { entry: n, name: r, type: i, entryGlobalName: a } = e, s = getRemoteEntryUniqueKey(e);\n  return t || (globalLoading[s] || (i === \"esm\" ? globalLoading[s] = loadEsmEntry({\n    entry: n,\n    remoteEntryExports: t\n  }) : globalLoading[s] = loadEntryScript({\n    name: r,\n    globalName: a,\n    entry: n,\n    createScriptHook: o\n  })), globalLoading[s]);\n}\nfunction getRemoteInfo(t) {\n  return _extends$5({}, t, {\n    entry: \"entry\" in t ? t.entry : \"\",\n    type: t.type || DEFAULT_REMOTE_TYPE,\n    entryGlobalName: t.entryGlobalName || t.name,\n    shareScope: t.shareScope || DEFAULT_SCOPE\n  });\n}\nfunction _extends$4() {\n  return _extends$4 = Object.assign || function(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var o = arguments[e];\n      for (var n in o)\n        Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]);\n    }\n    return t;\n  }, _extends$4.apply(this, arguments);\n}\nlet Module = class {\n  async getEntry() {\n    if (this.remoteEntryExports)\n      return this.remoteEntryExports;\n    const t = await getRemoteEntry({\n      remoteInfo: this.remoteInfo,\n      remoteEntryExports: this.remoteEntryExports,\n      createScriptHook: (e) => {\n        const o = this.host.loaderHook.lifecycle.createScript.emit({\n          url: e\n        });\n        if (typeof document > \"u\" || o instanceof HTMLScriptElement)\n          return o;\n      }\n    });\n    return assert(t, `remoteEntryExports is undefined \n ${safeToString$1(this.remoteInfo)}`), this.remoteEntryExports = t, this.remoteEntryExports;\n  }\n  async get(t, e) {\n    const { loadFactory: o = !0 } = e || {\n      loadFactory: !0\n    }, n = await this.getEntry();\n    if (!this.inited) {\n      const i = this.host.shareScopeMap, a = this.remoteInfo.shareScope || \"default\";\n      i[a] || (i[a] = {});\n      const s = i[a], c = [], l = {\n        version: this.remoteInfo.version || \"\"\n      };\n      Object.defineProperty(l, \"hostId\", {\n        value: this.host.options.id || this.host.name,\n        enumerable: !1\n      });\n      const u = await this.host.hooks.lifecycle.beforeInitContainer.emit({\n        shareScope: s,\n        remoteEntryInitOptions: l,\n        initScope: c,\n        remoteInfo: this.remoteInfo,\n        origin: this.host\n      });\n      await n.init(u.shareScope, u.initScope, u.remoteEntryInitOptions), await this.host.hooks.lifecycle.initContainer.emit(_extends$4({}, u, {\n        remoteEntryExports: n\n      }));\n    }\n    this.lib = n, this.inited = !0;\n    const r = await n.get(t);\n    return assert(r, `${getFMId(this.remoteInfo)} remote don't export ${t}.`), o ? await r() : r;\n  }\n  constructor({ remoteInfo: t, host: e }) {\n    this.inited = !1, this.lib = void 0, this.remoteInfo = t, this.host = e;\n  }\n};\nclass SyncHook {\n  on(e) {\n    typeof e == \"function\" && this.listeners.add(e);\n  }\n  once(e) {\n    const o = this;\n    this.on(function n(...r) {\n      return o.remove(n), e.apply(null, r);\n    });\n  }\n  emit(...e) {\n    let o;\n    return this.listeners.size > 0 && this.listeners.forEach((n) => {\n      o = n(...e);\n    }), o;\n  }\n  remove(e) {\n    this.listeners.delete(e);\n  }\n  removeAll() {\n    this.listeners.clear();\n  }\n  constructor(e) {\n    this.type = \"\", this.listeners = /* @__PURE__ */ new Set(), e && (this.type = e);\n  }\n}\nclass AsyncHook extends SyncHook {\n  emit(...e) {\n    let o;\n    const n = Array.from(this.listeners);\n    if (n.length > 0) {\n      let r = 0;\n      const i = (a) => a === !1 ? !1 : r < n.length ? Promise.resolve(n[r++].apply(null, e)).then(i) : a;\n      o = i();\n    }\n    return Promise.resolve(o);\n  }\n}\nfunction checkReturnData(t, e) {\n  if (!isObject(e))\n    return !1;\n  if (t !== e) {\n    for (const o in t)\n      if (!(o in e))\n        return !1;\n  }\n  return !0;\n}\nclass SyncWaterfallHook extends SyncHook {\n  emit(e) {\n    isObject(e) || error(`The data for the \"${this.type}\" hook should be an object.`);\n    for (const o of this.listeners)\n      try {\n        const n = o(e);\n        if (checkReturnData(e, n))\n          e = n;\n        else {\n          this.onerror(`A plugin returned an unacceptable value for the \"${this.type}\" type.`);\n          break;\n        }\n      } catch (n) {\n        warn$1(n), this.onerror(n);\n      }\n    return e;\n  }\n  constructor(e) {\n    super(), this.onerror = error, this.type = e;\n  }\n}\nclass AsyncWaterfallHook extends SyncHook {\n  emit(e) {\n    isObject(e) || error(`The response data for the \"${this.type}\" hook must be an object.`);\n    const o = Array.from(this.listeners);\n    if (o.length > 0) {\n      let n = 0;\n      const r = (a) => (warn$1(a), this.onerror(a), e), i = (a) => {\n        if (checkReturnData(e, a)) {\n          if (e = a, n < o.length)\n            try {\n              return Promise.resolve(o[n++](e)).then(i, r);\n            } catch (s) {\n              return r(s);\n            }\n        } else\n          this.onerror(`A plugin returned an incorrect value for the \"${this.type}\" type.`);\n        return e;\n      };\n      return Promise.resolve(i(e));\n    }\n    return Promise.resolve(e);\n  }\n  constructor(e) {\n    super(), this.onerror = error, this.type = e;\n  }\n}\nclass PluginSystem {\n  applyPlugin(e) {\n    assert(isPlainObject(e), \"Plugin configuration is invalid.\");\n    const o = e.name;\n    assert(o, \"A name must be provided by the plugin.\"), this.registerPlugins[o] || (this.registerPlugins[o] = e, Object.keys(this.lifecycle).forEach((n) => {\n      const r = e[n];\n      r && this.lifecycle[n].on(r);\n    }));\n  }\n  removePlugin(e) {\n    assert(e, \"A name is required.\");\n    const o = this.registerPlugins[e];\n    assert(o, `The plugin \"${e}\" is not registered.`), Object.keys(o).forEach((n) => {\n      n !== \"name\" && this.lifecycle[n].remove(o[n]);\n    });\n  }\n  inherit({ lifecycle: e, registerPlugins: o }) {\n    Object.keys(e).forEach((n) => {\n      assert(!this.lifecycle[n], `The hook \"${n}\" has a conflict and cannot be inherited.`), this.lifecycle[n] = e[n];\n    }), Object.keys(o).forEach((n) => {\n      assert(!this.registerPlugins[n], `The plugin \"${n}\" has a conflict and cannot be inherited.`), this.applyPlugin(o[n]);\n    });\n  }\n  constructor(e) {\n    this.registerPlugins = {}, this.lifecycle = e, this.lifecycleKeys = Object.keys(e);\n  }\n}\nfunction _extends$3() {\n  return _extends$3 = Object.assign || function(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var o = arguments[e];\n      for (var n in o)\n        Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]);\n    }\n    return t;\n  }, _extends$3.apply(this, arguments);\n}\nfunction defaultPreloadArgs(t) {\n  return _extends$3({\n    resourceCategory: \"sync\",\n    share: !0,\n    depsRemote: !0,\n    prefetchInterface: !1\n  }, t);\n}\nfunction formatPreloadArgs(t, e) {\n  return e.map((o) => {\n    const n = matchRemote(t, o.nameOrAlias);\n    return assert(n, `Unable to preload ${o.nameOrAlias} as it is not included in ${!n && safeToString$1({\n      remoteInfo: n,\n      remotes: t\n    })}`), {\n      remote: n,\n      preloadConfig: defaultPreloadArgs(o)\n    };\n  });\n}\nfunction normalizePreloadExposes(t) {\n  return t ? t.map((e) => e === \".\" ? e : e.startsWith(\"./\") ? e.replace(\"./\", \"\") : e) : [];\n}\nfunction preloadAssets(t, e, o) {\n  const { cssAssets: n, jsAssetsWithoutEntry: r, entryAssets: i } = o;\n  if (e.options.inBrowser) {\n    i.forEach((s) => {\n      const { moduleInfo: c } = s, l = e.moduleCache.get(t.name);\n      getRemoteEntry(l ? {\n        remoteInfo: c,\n        remoteEntryExports: l.remoteEntryExports,\n        createScriptHook: (u) => {\n          const h = e.loaderHook.lifecycle.createScript.emit({\n            url: u\n          });\n          if (h instanceof HTMLScriptElement)\n            return h;\n        }\n      } : {\n        remoteInfo: c,\n        remoteEntryExports: void 0,\n        createScriptHook: (u) => {\n          const h = e.loaderHook.lifecycle.createScript.emit({\n            url: u\n          });\n          if (h instanceof HTMLScriptElement)\n            return h;\n        }\n      });\n    });\n    const a = document.createDocumentFragment();\n    n.forEach((s) => {\n      const { link: c, needAttach: l } = createLink(s, () => {\n      }, {\n        rel: \"preload\",\n        as: \"style\"\n      }, (u) => {\n        const h = e.loaderHook.lifecycle.createLink.emit({\n          url: u\n        });\n        if (h instanceof HTMLLinkElement)\n          return h;\n      });\n      l && a.appendChild(c);\n    }), r.forEach((s) => {\n      const { link: c, needAttach: l } = createLink(s, () => {\n      }, {\n        rel: \"preload\",\n        as: \"script\"\n      }, (u) => {\n        const h = e.loaderHook.lifecycle.createLink.emit({\n          url: u\n        });\n        if (h instanceof HTMLLinkElement)\n          return h;\n      });\n      l && document.head.appendChild(c);\n    }), document.head.appendChild(a);\n  }\n}\nfunction _extends$2() {\n  return _extends$2 = Object.assign || function(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var o = arguments[e];\n      for (var n in o)\n        Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]);\n    }\n    return t;\n  }, _extends$2.apply(this, arguments);\n}\nfunction assignRemoteInfo(t, e) {\n  (!(\"remoteEntry\" in e) || !e.remoteEntry) && error(`The attribute remoteEntry of ${name} must not be undefined.`);\n  const { remoteEntry: o } = e, n = getResourceUrl(e, o);\n  t.type = e.remoteEntryType, t.entryGlobalName = e.globalName, t.entry = n, t.version = e.version, t.buildVersion = e.buildVersion;\n}\nfunction snapshotPlugin() {\n  return {\n    name: \"snapshot-plugin\",\n    async afterResolve(t) {\n      const { remote: e, pkgNameOrAlias: o, expose: n, origin: r, remoteInfo: i } = t;\n      if (!isRemoteInfoWithEntry(e) || !isPureRemoteEntry(e)) {\n        const { remoteSnapshot: a, globalSnapshot: s } = await r.snapshotHandler.loadRemoteSnapshotInfo(e);\n        assignRemoteInfo(i, a);\n        const c = {\n          remote: e,\n          preloadConfig: {\n            nameOrAlias: o,\n            exposes: [\n              n\n            ],\n            resourceCategory: \"sync\",\n            share: !1,\n            depsRemote: !1\n          }\n        }, l = await r.hooks.lifecycle.generatePreloadAssets.emit({\n          origin: r,\n          preloadOptions: c,\n          remoteInfo: i,\n          remote: e,\n          remoteSnapshot: a,\n          globalSnapshot: s\n        });\n        return l && preloadAssets(i, r, l), _extends$2({}, t, {\n          remoteSnapshot: a\n        });\n      }\n      return t;\n    }\n  };\n}\nfunction splitId(t) {\n  const e = t.split(\":\");\n  return e.length === 1 ? {\n    name: e[0],\n    version: void 0\n  } : e.length === 2 ? {\n    name: e[0],\n    version: e[1]\n  } : {\n    name: e[1],\n    version: e[2]\n  };\n}\nfunction traverseModuleInfo(t, e, o, n, r = {}, i) {\n  const a = getFMId(e), { value: s } = getInfoWithoutType(t, a), c = i || s;\n  if (c && !isManifestProvider(c) && (o(c, e, n), c.remotesInfo)) {\n    const l = Object.keys(c.remotesInfo);\n    for (const u of l) {\n      if (r[u])\n        continue;\n      r[u] = !0;\n      const h = splitId(u), g = c.remotesInfo[u];\n      traverseModuleInfo(t, {\n        name: h.name,\n        version: g.matchedVersion\n      }, o, !1, r, void 0);\n    }\n  }\n}\nfunction generatePreloadAssets(t, e, o, n, r) {\n  const i = [], a = [], s = [], c = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set(), { options: u } = t, { preloadConfig: h } = e, { depsRemote: g } = h;\n  traverseModuleInfo(n, o, (d, m, M) => {\n    let I;\n    if (M)\n      I = h;\n    else if (Array.isArray(g)) {\n      const y = g.find((A) => A.nameOrAlias === m.name || A.nameOrAlias === m.alias);\n      if (!y)\n        return;\n      I = defaultPreloadArgs(y);\n    } else if (g === !0)\n      I = h;\n    else\n      return;\n    const D = getResourceUrl(d, \"remoteEntry\" in d ? d.remoteEntry : \"\");\n    D && s.push({\n      name: m.name,\n      moduleInfo: {\n        name: m.name,\n        entry: D,\n        type: \"remoteEntryType\" in d ? d.remoteEntryType : \"global\",\n        entryGlobalName: \"globalName\" in d ? d.globalName : m.name,\n        shareScope: \"\",\n        version: \"version\" in d ? d.version : void 0\n      },\n      url: D\n    });\n    let S = \"modules\" in d ? d.modules : [];\n    const O = normalizePreloadExposes(I.exposes);\n    if (O.length && \"modules\" in d) {\n      var L;\n      S = d == null || (L = d.modules) == null ? void 0 : L.reduce((y, A) => (O?.indexOf(A.moduleName) !== -1 && y.push(A), y), []);\n    }\n    function v(y) {\n      const A = y.map((b) => getResourceUrl(d, b));\n      return I.filter ? A.filter(I.filter) : A;\n    }\n    if (S) {\n      const y = S.length;\n      for (let A = 0; A < y; A++) {\n        const b = S[A], x = `${m.name}/${b.moduleName}`;\n        t.hooks.lifecycle.handlePreloadModule.emit({\n          id: b.moduleName === \".\" ? m.name : x,\n          name: m.name,\n          remoteSnapshot: d,\n          preloadConfig: I,\n          remote: m,\n          origin: t\n        }), !getPreloaded(x) && (I.resourceCategory === \"all\" ? (i.push(...v(b.assets.css.async)), i.push(...v(b.assets.css.sync)), a.push(...v(b.assets.js.async)), a.push(...v(b.assets.js.sync))) : (I.resourceCategory = \"sync\") && (i.push(...v(b.assets.css.sync)), a.push(...v(b.assets.js.sync))), setPreloaded(x));\n      }\n    }\n  }, !0, {}, r), r.shared && r.shared.forEach((d) => {\n    var m;\n    const M = (m = u.shared) == null ? void 0 : m[d.sharedName];\n    if (!M)\n      return;\n    const I = getRegisteredShare(t.shareScopeMap, d.sharedName, M, t.hooks.lifecycle.resolveShare);\n    I && typeof I.lib == \"function\" && (d.assets.js.sync.forEach((D) => {\n      c.add(D);\n    }), d.assets.css.sync.forEach((D) => {\n      l.add(D);\n    }));\n  });\n  const p = a.filter((d) => !c.has(d));\n  return {\n    cssAssets: i.filter((d) => !l.has(d)),\n    jsAssetsWithoutEntry: p,\n    entryAssets: s\n  };\n}\nconst generatePreloadAssetsPlugin = function() {\n  return {\n    name: \"generate-preload-assets-plugin\",\n    async generatePreloadAssets(t) {\n      const { origin: e, preloadOptions: o, remoteInfo: n, remote: r, globalSnapshot: i, remoteSnapshot: a } = t;\n      return isRemoteInfoWithEntry(r) && isPureRemoteEntry(r) ? {\n        cssAssets: [],\n        jsAssetsWithoutEntry: [],\n        entryAssets: [\n          {\n            name: r.name,\n            url: r.entry,\n            moduleInfo: {\n              name: n.name,\n              entry: r.entry,\n              type: \"global\",\n              entryGlobalName: \"\",\n              shareScope: \"\"\n            }\n          }\n        ]\n      } : (assignRemoteInfo(n, a), generatePreloadAssets(e, o, n, i, a));\n    }\n  };\n};\nfunction _extends$1() {\n  return _extends$1 = Object.assign || function(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var o = arguments[e];\n      for (var n in o)\n        Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]);\n    }\n    return t;\n  }, _extends$1.apply(this, arguments);\n}\nclass SnapshotHandler {\n  async loadSnapshot(e) {\n    const { options: o } = this.HostInstance, { hostGlobalSnapshot: n, remoteSnapshot: r, globalSnapshot: i } = this.getGlobalRemoteInfo(e), { remoteSnapshot: a, globalSnapshot: s } = await this.hooks.lifecycle.loadSnapshot.emit({\n      options: o,\n      moduleInfo: e,\n      hostGlobalSnapshot: n,\n      remoteSnapshot: r,\n      globalSnapshot: i\n    });\n    return {\n      remoteSnapshot: a,\n      globalSnapshot: s\n    };\n  }\n  async loadRemoteSnapshotInfo(e) {\n    const { options: o } = this.HostInstance;\n    await this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({\n      options: o,\n      moduleInfo: e\n    });\n    let n = getGlobalSnapshotInfoByModuleInfo({\n      name: this.HostInstance.options.name,\n      version: this.HostInstance.options.version\n    });\n    n || (n = {\n      version: this.HostInstance.options.version || \"\",\n      remoteEntry: \"\",\n      remotesInfo: {}\n    }, addGlobalSnapshot({\n      [this.HostInstance.options.name]: n\n    })), n && \"remotesInfo\" in n && !getInfoWithoutType(n.remotesInfo, e.name).value && (\"version\" in e || \"entry\" in e) && (n.remotesInfo = _extends$1({}, n?.remotesInfo, {\n      [e.name]: {\n        matchedVersion: \"version\" in e ? e.version : e.entry\n      }\n    }));\n    const { hostGlobalSnapshot: r, remoteSnapshot: i, globalSnapshot: a } = this.getGlobalRemoteInfo(e), { remoteSnapshot: s, globalSnapshot: c } = await this.hooks.lifecycle.loadSnapshot.emit({\n      options: o,\n      moduleInfo: e,\n      hostGlobalSnapshot: r,\n      remoteSnapshot: i,\n      globalSnapshot: a\n    });\n    if (s)\n      if (isManifestProvider(s)) {\n        const l = await this.getManifestJson(s.remoteEntry, e, {}), u = setGlobalSnapshotInfoByModuleInfo(_extends$1({}, e, {\n          entry: s.remoteEntry\n        }), l);\n        return {\n          remoteSnapshot: l,\n          globalSnapshot: u\n        };\n      } else {\n        const { remoteSnapshot: l } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n          options: this.HostInstance.options,\n          moduleInfo: e,\n          remoteSnapshot: s,\n          from: \"global\"\n        });\n        return {\n          remoteSnapshot: l,\n          globalSnapshot: c\n        };\n      }\n    else if (isRemoteInfoWithEntry(e)) {\n      const l = await this.getManifestJson(e.entry, e, {}), u = setGlobalSnapshotInfoByModuleInfo(e, l), { remoteSnapshot: h } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n        options: this.HostInstance.options,\n        moduleInfo: e,\n        remoteSnapshot: l,\n        from: \"global\"\n      });\n      return {\n        remoteSnapshot: h,\n        globalSnapshot: u\n      };\n    } else\n      error(`\n          Cannot get remoteSnapshot with the name: '${e.name}', version: '${e.version}' from __FEDERATION__.moduleInfo. The following reasons may be causing the problem:\n\n          1. The Deploy platform did not deliver the correct data. You can use __FEDERATION__.moduleInfo to check the remoteInfo.\n\n          2. The remote '${e.name}' version '${e.version}' is not released.\n\n          The transformed module info: ${JSON.stringify(c)}\n        `);\n  }\n  getGlobalRemoteInfo(e) {\n    const o = getGlobalSnapshotInfoByModuleInfo({\n      name: this.HostInstance.options.name,\n      version: this.HostInstance.options.version\n    }), n = o && \"remotesInfo\" in o && o.remotesInfo && getInfoWithoutType(o.remotesInfo, e.name).value;\n    return n && n.matchedVersion ? {\n      hostGlobalSnapshot: o,\n      globalSnapshot: getGlobalSnapshot(),\n      remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({\n        name: e.name,\n        version: n.matchedVersion\n      })\n    } : {\n      hostGlobalSnapshot: void 0,\n      globalSnapshot: getGlobalSnapshot(),\n      remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({\n        name: e.name,\n        version: \"version\" in e ? e.version : void 0\n      })\n    };\n  }\n  async getManifestJson(e, o, n) {\n    const r = async () => {\n      let a = this.manifestCache.get(e);\n      if (a)\n        return a;\n      try {\n        let s = await this.loaderHook.lifecycle.fetch.emit(e, {});\n        return (!s || !(s instanceof Response)) && (s = await fetch(e, {})), a = await s.json(), assert(a.metaData && a.exposes && a.shared, `${e} is not a federation manifest`), this.manifestCache.set(e, a), a;\n      } catch (s) {\n        error(`Failed to get manifestJson for ${o.name}. The manifest URL is ${e}. Please ensure that the manifestUrl is accessible.\n          \n Error message:\n          \n ${s}`);\n      }\n    }, i = async () => {\n      const a = await r(), s = generateSnapshotFromManifest(a, {\n        version: e\n      }), { remoteSnapshot: c } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n        options: this.HostInstance.options,\n        moduleInfo: o,\n        manifestJson: a,\n        remoteSnapshot: s,\n        manifestUrl: e,\n        from: \"manifest\"\n      });\n      return c;\n    };\n    return this.manifestLoading[e] || (this.manifestLoading[e] = i().then((a) => a)), this.manifestLoading[e];\n  }\n  constructor(e) {\n    this.loadingHostSnapshot = null, this.manifestCache = /* @__PURE__ */ new Map(), this.hooks = new PluginSystem({\n      beforeLoadRemoteSnapshot: new AsyncHook(\"beforeLoadRemoteSnapshot\"),\n      loadSnapshot: new AsyncWaterfallHook(\"loadGlobalSnapshot\"),\n      loadRemoteSnapshot: new AsyncWaterfallHook(\"loadRemoteSnapshot\")\n    }), this.manifestLoading = Global.__FEDERATION__.__MANIFEST_LOADING__, this.HostInstance = e, this.loaderHook = e.loaderHook;\n  }\n}\nfunction _extends() {\n  return _extends = Object.assign || function(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var o = arguments[e];\n      for (var n in o)\n        Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]);\n    }\n    return t;\n  }, _extends.apply(this, arguments);\n}\nfunction _object_without_properties_loose(t, e) {\n  if (t == null)\n    return {};\n  var o = {}, n = Object.keys(t), r, i;\n  for (i = 0; i < n.length; i++)\n    r = n[i], !(e.indexOf(r) >= 0) && (o[r] = t[r]);\n  return o;\n}\nclass FederationHost {\n  _setGlobalShareScopeMap() {\n    const e = getGlobalShareScope(), o = this.options.id || this.options.name;\n    o && !e[o] && (e[o] = this.shareScopeMap);\n  }\n  initOptions(e) {\n    this.registerPlugins(e.plugins);\n    const o = this.formatOptions(this.options, e);\n    return this.options = o, o;\n  }\n  async loadShare(e, o) {\n    var n;\n    const r = Object.assign({}, (n = this.options.shared) == null ? void 0 : n[e], o);\n    r != null && r.scope && await Promise.all(r.scope.map(async (l) => {\n      await Promise.all(this.initializeSharing(l, r.strategy));\n    }));\n    const i = await this.hooks.lifecycle.beforeLoadShare.emit({\n      pkgName: e,\n      shareInfo: r,\n      shared: this.options.shared,\n      origin: this\n    }), { shareInfo: a } = i;\n    assert(a, `Cannot find ${e} Share in the ${this.options.name}. Please ensure that the ${e} Share parameters have been injected`);\n    const s = getRegisteredShare(this.shareScopeMap, e, a, this.hooks.lifecycle.resolveShare), c = (l) => {\n      l.useIn || (l.useIn = []), addUniqueItem(l.useIn, this.options.name);\n    };\n    if (s && s.lib)\n      return c(s), s.lib;\n    if (s && s.loading && !s.loaded) {\n      const l = await s.loading;\n      return s.loaded = !0, s.lib || (s.lib = l), c(s), l;\n    } else if (s) {\n      const l = (async () => {\n        const u = await s.get();\n        a.lib = u, a.loaded = !0, c(a);\n        const h = getRegisteredShare(this.shareScopeMap, e, a, this.hooks.lifecycle.resolveShare);\n        return h && (h.lib = u, h.loaded = !0), u;\n      })();\n      return this.setShared({\n        pkgName: e,\n        loaded: !1,\n        shared: s,\n        from: this.options.name,\n        lib: null,\n        loading: l\n      }), l;\n    } else {\n      if (o)\n        return !1;\n      const l = (async () => {\n        const u = await a.get();\n        a.lib = u, a.loaded = !0, c(a);\n        const h = getRegisteredShare(this.shareScopeMap, e, a, this.hooks.lifecycle.resolveShare);\n        return h && (h.lib = u, h.loaded = !0), u;\n      })();\n      return this.setShared({\n        pkgName: e,\n        loaded: !1,\n        shared: a,\n        from: this.options.name,\n        lib: null,\n        loading: l\n      }), l;\n    }\n  }\n  loadShareSync(e, o) {\n    var n;\n    const r = Object.assign({}, (n = this.options.shared) == null ? void 0 : n[e], o);\n    r != null && r.scope && r.scope.forEach((s) => {\n      this.initializeSharing(s, r.strategy);\n    });\n    const i = getRegisteredShare(this.shareScopeMap, e, r, this.hooks.lifecycle.resolveShare), a = (s) => {\n      s.useIn || (s.useIn = []), addUniqueItem(s.useIn, this.options.name);\n    };\n    if (i) {\n      if (typeof i.lib == \"function\")\n        return a(i), i.loaded || (i.loaded = !0, i.from === this.options.name && (r.loaded = !0)), i.lib;\n      if (typeof i.get == \"function\") {\n        const s = i.get();\n        if (!(s instanceof Promise))\n          return a(i), this.setShared({\n            pkgName: e,\n            loaded: !0,\n            from: this.options.name,\n            lib: s,\n            shared: i\n          }), s;\n      }\n    }\n    if (r.lib)\n      return r.loaded || (r.loaded = !0), r.lib;\n    if (r.get) {\n      const s = r.get();\n      if (s instanceof Promise)\n        throw new Error(`\n        The loadShareSync function was unable to load ${e}. The ${e} could not be found in ${this.options.name}.\n        Possible reasons for failure: \n\n        1. The ${e} share was registered with the 'get' attribute, but loadShare was not used beforehand.\n\n        2. The ${e} share was not registered with the 'lib' attribute.\n\n      `);\n      return r.lib = s, this.setShared({\n        pkgName: e,\n        loaded: !0,\n        from: this.options.name,\n        lib: r.lib,\n        shared: r\n      }), r.lib;\n    }\n    throw new Error(`\n        The loadShareSync function was unable to load ${e}. The ${e} could not be found in ${this.options.name}.\n        Possible reasons for failure: \n\n        1. The ${e} share was registered with the 'get' attribute, but loadShare was not used beforehand.\n\n        2. The ${e} share was not registered with the 'lib' attribute.\n\n      `);\n  }\n  initRawContainer(e, o, n) {\n    const r = getRemoteInfo({\n      name: e,\n      entry: o\n    }), i = new Module({\n      host: this,\n      remoteInfo: r\n    });\n    return i.remoteEntryExports = n, this.moduleCache.set(e, i), i;\n  }\n  async _getRemoteModuleAndOptions(e) {\n    const o = await this.hooks.lifecycle.beforeRequest.emit({\n      id: e,\n      options: this.options,\n      origin: this\n    }), { id: n } = o, r = matchRemoteWithNameAndExpose(this.options.remotes, n);\n    assert(r, `\n        Unable to locate ${n} in ${this.options.name}. Potential reasons for failure include:\n\n        1. ${n} was not included in the 'remotes' parameter of ${this.options.name || \"the host\"}.\n\n        2. ${n} could not be found in the 'remotes' of ${this.options.name} with either 'name' or 'alias' attributes.\n        3. ${n} is not online, injected, or loaded.\n        4. ${n}  cannot be accessed on the expected.\n        5. The 'beforeRequest' hook was provided but did not return the correct 'remoteInfo' when attempting to load ${n}.\n      `);\n    const { remote: i } = r, a = getRemoteInfo(i), s = await this.hooks.lifecycle.afterResolve.emit(_extends({\n      id: n\n    }, r, {\n      options: this.options,\n      origin: this,\n      remoteInfo: a\n    })), { remote: c, expose: l } = s;\n    assert(c && l, `The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading ${n}.`);\n    let u = this.moduleCache.get(c.name);\n    const h = {\n      host: this,\n      remoteInfo: a\n    };\n    return u || (u = new Module(h), this.moduleCache.set(c.name, u)), {\n      module: u,\n      moduleOptions: h,\n      remoteMatchInfo: s\n    };\n  }\n  async loadRemote(e, o) {\n    try {\n      const { loadFactory: n = !0 } = o || {\n        loadFactory: !0\n      }, { module: r, moduleOptions: i, remoteMatchInfo: a } = await this._getRemoteModuleAndOptions(e), { pkgNameOrAlias: s, remote: c, expose: l, id: u } = a, h = await r.get(l, o), g = await this.hooks.lifecycle.onLoad.emit({\n        id: u,\n        pkgNameOrAlias: s,\n        expose: l,\n        exposeModule: n ? h : void 0,\n        exposeModuleFactory: n ? void 0 : h,\n        remote: c,\n        options: i,\n        moduleInstance: r,\n        origin: this\n      });\n      return typeof g == \"function\" ? g : h;\n    } catch (n) {\n      const { from: r = \"runtime\" } = o || {\n        from: \"runtime\"\n      }, i = await this.hooks.lifecycle.errorLoadRemote.emit({\n        id: e,\n        error: n,\n        from: r,\n        origin: this\n      });\n      if (!i)\n        throw n;\n      return i;\n    }\n  }\n  async preloadRemote(e) {\n    await this.hooks.lifecycle.beforePreloadRemote.emit({\n      preloadOptions: e,\n      options: this.options,\n      origin: this\n    });\n    const o = formatPreloadArgs(this.options.remotes, e);\n    await Promise.all(o.map(async (n) => {\n      const { remote: r } = n, i = getRemoteInfo(r), { globalSnapshot: a, remoteSnapshot: s } = await this.snapshotHandler.loadRemoteSnapshotInfo(r), c = await this.hooks.lifecycle.generatePreloadAssets.emit({\n        origin: this,\n        preloadOptions: n,\n        remote: r,\n        remoteInfo: i,\n        globalSnapshot: a,\n        remoteSnapshot: s\n      });\n      !c || preloadAssets(i, this, c);\n    }));\n  }\n  initializeSharing(e = DEFAULT_SCOPE, o) {\n    const n = this.shareScopeMap, r = this.options.name;\n    n[e] || (n[e] = {});\n    const i = n[e], a = (u, h) => {\n      var g;\n      const { version: p, eager: d } = h;\n      i[u] = i[u] || {};\n      const m = i[u], M = m[p], I = !!(M && (M.eager || (g = M.shareConfig) != null && g.eager));\n      (!M || M.strategy !== \"loaded-first\" && !M.loaded && (!d != !I ? d : r > M.from)) && (m[p] = h);\n    }, s = [], c = (u) => u && u.init && u.init(n[e]), l = async (u) => {\n      const { module: h } = await this._getRemoteModuleAndOptions(u);\n      if (h.getEntry) {\n        const g = await h.getEntry();\n        h.inited || (c(g), h.inited = !0);\n      }\n    };\n    return Object.keys(this.options.shared).forEach((u) => {\n      const h = this.options.shared[u];\n      h.scope.includes(e) && a(u, h);\n    }), o === \"version-first\" && this.options.remotes.forEach((u) => {\n      u.shareScope === e && s.push(l(u.name));\n    }), s;\n  }\n  initShareScopeMap(e, o) {\n    this.shareScopeMap[e] = o, this.hooks.lifecycle.initContainerShareScopeMap.emit({\n      shareScope: o,\n      options: this.options,\n      origin: this\n    });\n  }\n  formatOptions(e, o) {\n    const n = formatShareConfigs(o.shared || {}, o.name), r = _extends({}, e.shared, n), { userOptions: i, options: a } = this.hooks.lifecycle.beforeInit.emit({\n      origin: this,\n      userOptions: o,\n      options: e,\n      shareInfo: r\n    }), s = (i.remotes || []).reduce((u, h) => (this.registerRemote(h, u, {\n      force: !1\n    }), u), a.remotes);\n    Object.keys(n).forEach((u) => {\n      const h = n[u];\n      !getRegisteredShare(this.shareScopeMap, u, h, this.hooks.lifecycle.resolveShare) && h && h.lib && this.setShared({\n        pkgName: u,\n        lib: h.lib,\n        get: h.get,\n        loaded: !0,\n        shared: h,\n        from: o.name\n      });\n    });\n    const c = [\n      ...a.plugins\n    ];\n    i.plugins && i.plugins.forEach((u) => {\n      c.includes(u) || c.push(u);\n    });\n    const l = _extends({}, e, o, {\n      plugins: c,\n      remotes: s,\n      shared: r\n    });\n    return this.hooks.lifecycle.init.emit({\n      origin: this,\n      options: l\n    }), l;\n  }\n  registerPlugins(e) {\n    registerPlugins(e, [\n      this.hooks,\n      this.snapshotHandler.hooks,\n      this.loaderHook\n    ]);\n  }\n  setShared({ pkgName: e, shared: o, from: n, lib: r, loading: i, loaded: a, get: s }) {\n    const { version: c, scope: l = \"default\" } = o, u = _object_without_properties_loose(o, [\n      \"version\",\n      \"scope\"\n    ]);\n    (Array.isArray(l) ? l : [\n      l\n    ]).forEach((h) => {\n      this.shareScopeMap[h] || (this.shareScopeMap[h] = {}), this.shareScopeMap[h][e] || (this.shareScopeMap[h][e] = {}), !this.shareScopeMap[h][e][c] && (this.shareScopeMap[h][e][c] = _extends({\n        version: c,\n        scope: [\n          \"default\"\n        ]\n      }, u, {\n        lib: r,\n        loaded: a,\n        loading: i\n      }), s && (this.shareScopeMap[h][e][c].get = s));\n    });\n  }\n  removeRemote(e) {\n    const { name: o } = e, n = this.options.remotes.findIndex((i) => i.name === o);\n    n !== -1 && this.options.remotes.splice(n, 1);\n    const r = this.moduleCache.get(e.name);\n    if (r) {\n      const i = r.remoteInfo.entryGlobalName;\n      globalThis[i] && delete globalThis[i];\n      const a = getRemoteEntryUniqueKey(r.remoteInfo);\n      globalLoading[a] && delete globalLoading[a], this.moduleCache.delete(e.name);\n    }\n  }\n  registerRemote(e, o, n) {\n    const r = () => {\n      if (e.alias) {\n        const a = o.find((s) => {\n          var c;\n          return e.alias && (s.name.startsWith(e.alias) || ((c = s.alias) == null ? void 0 : c.startsWith(e.alias)));\n        });\n        assert(!a, `The alias ${e.alias} of remote ${e.name} is not allowed to be the prefix of ${a && a.name} name or alias`);\n      }\n      \"entry\" in e && isBrowserEnv$1() && !e.entry.startsWith(\"http\") && (e.entry = new URL(e.entry, window.location.origin).href), e.shareScope || (e.shareScope = DEFAULT_SCOPE), e.type || (e.type = DEFAULT_REMOTE_TYPE);\n    }, i = o.find((a) => a.name === e.name);\n    if (!i)\n      r(), o.push(e);\n    else {\n      const a = [\n        `The remote \"${e.name}\" is already registered.`,\n        n != null && n.force ? \"Hope you have known that OVERRIDE it may have some unexpected errors\" : 'If you want to merge the remote, you can set \"force: true\".'\n      ];\n      n != null && n.force && (this.removeRemote(i), r(), o.push(e)), warn$1(a.join(\" \"));\n    }\n  }\n  registerRemotes(e, o) {\n    e.forEach((n) => {\n      this.registerRemote(n, this.options.remotes, {\n        force: o?.force\n      });\n    });\n  }\n  constructor(e) {\n    this.hooks = new PluginSystem({\n      beforeInit: new SyncWaterfallHook(\"beforeInit\"),\n      init: new SyncHook(),\n      beforeRequest: new AsyncWaterfallHook(\"beforeRequest\"),\n      afterResolve: new AsyncWaterfallHook(\"afterResolve\"),\n      beforeInitContainer: new AsyncWaterfallHook(\"beforeInitContainer\"),\n      initContainerShareScopeMap: new AsyncWaterfallHook(\"initContainer\"),\n      initContainer: new AsyncWaterfallHook(\"initContainer\"),\n      onLoad: new AsyncHook(\"onLoad\"),\n      handlePreloadModule: new SyncHook(\"handlePreloadModule\"),\n      errorLoadRemote: new AsyncHook(\"errorLoadRemote\"),\n      beforeLoadShare: new AsyncWaterfallHook(\"beforeLoadShare\"),\n      loadShare: new AsyncHook(),\n      resolveShare: new SyncWaterfallHook(\"resolveShare\"),\n      beforePreloadRemote: new AsyncHook(),\n      generatePreloadAssets: new AsyncHook(\"generatePreloadAssets\"),\n      afterPreloadRemote: new AsyncHook()\n    }), this.version = \"0.1.2\", this.moduleCache = /* @__PURE__ */ new Map(), this.loaderHook = new PluginSystem({\n      getModuleInfo: new SyncHook(),\n      createScript: new SyncHook(),\n      createLink: new SyncHook(),\n      fetch: new AsyncHook(\"fetch\")\n    });\n    const o = {\n      id: getBuilderId(),\n      name: e.name,\n      plugins: [\n        snapshotPlugin(),\n        generatePreloadAssetsPlugin()\n      ],\n      remotes: [],\n      shared: {},\n      inBrowser: isBrowserEnv$1()\n    };\n    this.name = e.name, this.options = o, this.shareScopeMap = {}, this._setGlobalShareScopeMap(), this.snapshotHandler = new SnapshotHandler(this), this.registerPlugins([\n      ...o.plugins,\n      ...e.plugins || []\n    ]), this.options = this.formatOptions(o, e);\n  }\n}\nlet FederationInstance = null;\nfunction init(t) {\n  const e = getGlobalFederationInstance(t.name, t.version);\n  if (e)\n    return e.initOptions(t), FederationInstance || (FederationInstance = e), e;\n  {\n    const o = getGlobalFederationConstructor() || FederationHost;\n    return FederationInstance = new o(t), setGlobalFederationInstance(FederationInstance), FederationInstance;\n  }\n}\nfunction loadRemote(...t) {\n  return assert(FederationInstance, \"Please call init first\"), FederationInstance.loadRemote.apply(FederationInstance, t);\n}\nsetGlobalFederationConstructor(FederationHost);\nfunction __awaiter(t, e, o, n) {\n  function r(i) {\n    return i instanceof o ? i : new o(function(a) {\n      a(i);\n    });\n  }\n  return new (o || (o = Promise))(function(i, a) {\n    function s(u) {\n      try {\n        l(n.next(u));\n      } catch (h) {\n        a(h);\n      }\n    }\n    function c(u) {\n      try {\n        l(n.throw(u));\n      } catch (h) {\n        a(h);\n      }\n    }\n    function l(u) {\n      u.done ? i(u.value) : r(u.value).then(s, c);\n    }\n    l((n = n.apply(t, e || [])).next());\n  });\n}\nfunction __generator(t, e) {\n  var o = { label: 0, sent: function() {\n    if (i[0] & 1)\n      throw i[1];\n    return i[1];\n  }, trys: [], ops: [] }, n, r, i, a;\n  return a = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == \"function\" && (a[Symbol.iterator] = function() {\n    return this;\n  }), a;\n  function s(l) {\n    return function(u) {\n      return c([l, u]);\n    };\n  }\n  function c(l) {\n    if (n)\n      throw new TypeError(\"Generator is already executing.\");\n    for (; o; )\n      try {\n        if (n = 1, r && (i = l[0] & 2 ? r.return : l[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, l[1])).done)\n          return i;\n        switch (r = 0, i && (l = [l[0] & 2, i.value]), l[0]) {\n          case 0:\n          case 1:\n            i = l;\n            break;\n          case 4:\n            return o.label++, { value: l[1], done: !1 };\n          case 5:\n            o.label++, r = l[1], l = [0];\n            continue;\n          case 7:\n            l = o.ops.pop(), o.trys.pop();\n            continue;\n          default:\n            if (i = o.trys, !(i = i.length > 0 && i[i.length - 1]) && (l[0] === 6 || l[0] === 2)) {\n              o = 0;\n              continue;\n            }\n            if (l[0] === 3 && (!i || l[1] > i[0] && l[1] < i[3])) {\n              o.label = l[1];\n              break;\n            }\n            if (l[0] === 6 && o.label < i[1]) {\n              o.label = i[1], i = l;\n              break;\n            }\n            if (i && o.label < i[2]) {\n              o.label = i[2], o.ops.push(l);\n              break;\n            }\n            i[2] && o.ops.pop(), o.trys.pop();\n            continue;\n        }\n        l = e.call(t, o);\n      } catch (u) {\n        l = [6, u], r = 0;\n      } finally {\n        n = i = 0;\n      }\n    if (l[0] & 5)\n      throw l[1];\n    return { value: l[0] ? l[1] : void 0, done: !0 };\n  }\n}\nvar E_CANCELED = new Error(\"request for lock canceled\"), Semaphore = function() {\n  function t(e, o) {\n    o === void 0 && (o = E_CANCELED), this._value = e, this._cancelError = o, this._queue = [], this._weightedWaiters = [];\n  }\n  return t.prototype.acquire = function(e, o) {\n    var n = this;\n    if (e === void 0 && (e = 1), o === void 0 && (o = 0), e <= 0)\n      throw new Error(\"invalid weight \".concat(e, \": must be positive\"));\n    return new Promise(function(r, i) {\n      var a = { resolve: r, reject: i, weight: e, priority: o }, s = findIndexFromEnd(n._queue, function(c) {\n        return o <= c.priority;\n      });\n      s === -1 && e <= n._value ? n._dispatchItem(a) : n._queue.splice(s + 1, 0, a);\n    });\n  }, t.prototype.runExclusive = function(e) {\n    return __awaiter(this, arguments, void 0, function(o, n, r) {\n      var i, a, s;\n      return n === void 0 && (n = 1), r === void 0 && (r = 0), __generator(this, function(c) {\n        switch (c.label) {\n          case 0:\n            return [4, this.acquire(n, r)];\n          case 1:\n            i = c.sent(), a = i[0], s = i[1], c.label = 2;\n          case 2:\n            return c.trys.push([2, , 4, 5]), [4, o(a)];\n          case 3:\n            return [2, c.sent()];\n          case 4:\n            return s(), [7];\n          case 5:\n            return [2];\n        }\n      });\n    });\n  }, t.prototype.waitForUnlock = function(e, o) {\n    var n = this;\n    if (e === void 0 && (e = 1), o === void 0 && (o = 0), e <= 0)\n      throw new Error(\"invalid weight \".concat(e, \": must be positive\"));\n    return this._couldLockImmediately(e, o) ? Promise.resolve() : new Promise(function(r) {\n      n._weightedWaiters[e - 1] || (n._weightedWaiters[e - 1] = []), insertSorted(n._weightedWaiters[e - 1], { resolve: r, priority: o });\n    });\n  }, t.prototype.isLocked = function() {\n    return this._value <= 0;\n  }, t.prototype.getValue = function() {\n    return this._value;\n  }, t.prototype.setValue = function(e) {\n    this._value = e, this._dispatchQueue();\n  }, t.prototype.release = function(e) {\n    if (e === void 0 && (e = 1), e <= 0)\n      throw new Error(\"invalid weight \".concat(e, \": must be positive\"));\n    this._value += e, this._dispatchQueue();\n  }, t.prototype.cancel = function() {\n    var e = this;\n    this._queue.forEach(function(o) {\n      return o.reject(e._cancelError);\n    }), this._queue = [];\n  }, t.prototype._dispatchQueue = function() {\n    for (this._drainUnlockWaiters(); this._queue.length > 0 && this._queue[0].weight <= this._value; )\n      this._dispatchItem(this._queue.shift()), this._drainUnlockWaiters();\n  }, t.prototype._dispatchItem = function(e) {\n    var o = this._value;\n    this._value -= e.weight, e.resolve([o, this._newReleaser(e.weight)]);\n  }, t.prototype._newReleaser = function(e) {\n    var o = this, n = !1;\n    return function() {\n      n || (n = !0, o.release(e));\n    };\n  }, t.prototype._drainUnlockWaiters = function() {\n    if (this._queue.length === 0)\n      for (var e = this._value; e > 0; e--) {\n        var o = this._weightedWaiters[e - 1];\n        !o || (o.forEach(function(i) {\n          return i.resolve();\n        }), this._weightedWaiters[e - 1] = []);\n      }\n    else\n      for (var n = this._queue[0].priority, e = this._value; e > 0; e--) {\n        var o = this._weightedWaiters[e - 1];\n        if (o) {\n          var r = o.findIndex(function(s) {\n            return s.priority <= n;\n          });\n          (r === -1 ? o : o.splice(0, r)).forEach(function(s) {\n            return s.resolve();\n          });\n        }\n      }\n  }, t.prototype._couldLockImmediately = function(e, o) {\n    return (this._queue.length === 0 || this._queue[0].priority < o) && e <= this._value;\n  }, t;\n}();\nfunction insertSorted(t, e) {\n  var o = findIndexFromEnd(t, function(n) {\n    return e.priority <= n.priority;\n  });\n  t.splice(o + 1, 0, e);\n}\nfunction findIndexFromEnd(t, e) {\n  for (var o = t.length - 1; o >= 0; o--)\n    if (e(t[o]))\n      return o;\n  return -1;\n}\nvar Mutex = function() {\n  function t(e) {\n    this._semaphore = new Semaphore(1, e);\n  }\n  return t.prototype.acquire = function() {\n    return __awaiter(this, arguments, void 0, function(e) {\n      var o, n;\n      return e === void 0 && (e = 0), __generator(this, function(r) {\n        switch (r.label) {\n          case 0:\n            return [4, this._semaphore.acquire(1, e)];\n          case 1:\n            return o = r.sent(), n = o[1], [2, n];\n        }\n      });\n    });\n  }, t.prototype.runExclusive = function(e, o) {\n    return o === void 0 && (o = 0), this._semaphore.runExclusive(function() {\n      return e();\n    }, 1, o);\n  }, t.prototype.isLocked = function() {\n    return this._semaphore.isLocked();\n  }, t.prototype.waitForUnlock = function(e) {\n    return e === void 0 && (e = 0), this._semaphore.waitForUnlock(1, e);\n  }, t.prototype.release = function() {\n    this._semaphore.isLocked() && this._semaphore.release();\n  }, t.prototype.cancel = function() {\n    return this._semaphore.cancel();\n  }, t;\n}();\nfunction isMetaMaskProvider(t) {\n  return t !== null && typeof t == \"object\" && t.hasOwnProperty(\"isMetaMask\") && t.hasOwnProperty(\"request\");\n}\nfunction detectMetaMaskProvider(t, { timeout: e = 3e3 } = {}) {\n  let o = !1;\n  return new Promise((n) => {\n    const r = (i) => {\n      const { info: a, provider: s } = i.detail;\n      (a.rdns === \"io.metamask\" || a.rdns === \"io.metamask.flask\") && isMetaMaskProvider(s) && (n(s), o = !0);\n    };\n    typeof t.addEventListener == \"function\" && t.addEventListener(\n      \"eip6963:announceProvider\",\n      r\n    ), setTimeout(() => {\n      o || n(null);\n    }, e), typeof t.dispatchEvent == \"function\" && t.dispatchEvent(new Event(\"eip6963:requestProvider\"));\n  });\n}\nasync function waitForMetaMaskProvider(t, e = {}) {\n  const { timeout: o = 3e3, retries: n = 0 } = e;\n  let r = null;\n  try {\n    r = await detectMetaMaskProvider(t, { timeout: o });\n  } catch {\n  }\n  return r || (n === 0 ? null : (r = await waitForMetaMaskProvider({ timeout: o, retries: n - 1 }), r));\n}\nasync function detectMetamaskSupport(t) {\n  return await waitForMetaMaskProvider(t, { retries: 3 });\n}\nvar Q, q, C, G, Y, J;\nclass MetaMaskVirtualWallet {\n  constructor() {\n    T(this, Q), T(this, C), T(this, Y), _(this, \"id\", \"metamask\"), _(this, \"name\", \"MetaMask\"), _(this, \"icon\", \"data:image/svg+xml;utf8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMTIiIGhlaWdodD0iMTg5IiB2aWV3Qm94PSIwIDAgMjEyIDE4OSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cG9seWdvbiBmaWxsPSIjQ0RCREIyIiBwb2ludHM9IjYwLjc1IDE3My4yNSA4OC4zMTMgMTgwLjU2MyA4OC4zMTMgMTcxIDkwLjU2MyAxNjguNzUgMTA2LjMxMyAxNjguNzUgMTA2LjMxMyAxODAgMTA2LjMxMyAxODcuODc1IDg5LjQzOCAxODcuODc1IDY4LjYyNSAxNzguODc1Ii8+PHBvbHlnb24gZmlsbD0iI0NEQkRCMiIgcG9pbnRzPSIxMDUuNzUgMTczLjI1IDEzMi43NSAxODAuNTYzIDEzMi43NSAxNzEgMTM1IDE2OC43NSAxNTAuNzUgMTY4Ljc1IDE1MC43NSAxODAgMTUwLjc1IDE4Ny44NzUgMTMzLjg3NSAxODcuODc1IDExMy4wNjMgMTc4Ljg3NSIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjU2LjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzEgOTEuMTI1IDE2OC43NSAxMjAuMzc1IDE2OC43NSAxMjMuNzUgMTcxIDEyMS41IDE1Mi40MzggMTE3IDE0OS42MjUgOTQuNSAxNTAuMTg4Ii8+PHBvbHlnb24gZmlsbD0iI0Y4OUMzNSIgcG9pbnRzPSI3NS4zNzUgMjcgODguODc1IDU4LjUgOTUuMDYzIDE1MC4xODggMTE3IDE1MC4xODggMTIzLjc1IDU4LjUgMTM2LjEyNSAyNyIvPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MC41NjMgMTUyLjQzOCIvPjxwb2x5Z29uIGZpbGw9IiNFQThFM0EiIHBvaW50cz0iOTIuMjUgMTAyLjM3NSA5NS4wNjMgMTUwLjE4OCA4Ni42MjUgMTI1LjcxOSIvPjxwb2x5Z29uIGZpbGw9IiNEODdDMzAiIHBvaW50cz0iMzkuMzc1IDEzOC45MzggNjUuMjUgMTM4LjM3NSA2MC43NSAxNzMuMjUiLz48cG9seWdvbiBmaWxsPSIjRUI4RjM1IiBwb2ludHM9IjEyLjkzOCAxODguNDM4IDYwLjc1IDE3My4yNSAzOS4zNzUgMTM4LjkzOCAuNTYzIDE0MS43NSIvPjxwb2x5Z29uIGZpbGw9IiNFODgyMUUiIHBvaW50cz0iODguODc1IDU4LjUgNjQuNjg4IDc4Ljc1IDQ2LjEyNSAxMDEuMjUgOTIuMjUgMTAyLjkzOCIvPjxwb2x5Z29uIGZpbGw9IiNERkNFQzMiIHBvaW50cz0iNjAuNzUgMTczLjI1IDkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzAuNDM4IDg4LjMxMyAxODAuNTYzIDY4LjA2MyAxNzYuNjI1Ii8+PHBvbHlnb24gZmlsbD0iI0RGQ0VDMyIgcG9pbnRzPSIxMjEuNSAxNzMuMjUgMTUwLjc1IDE1Mi40MzggMTQ4LjUgMTcwLjQzOCAxNDguNSAxODAuNTYzIDEyOC4yNSAxNzYuNjI1IiB0cmFuc2Zvcm09Im1hdHJpeCgtMSAwIDAgMSAyNzIuMjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PGcgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjExLjUgMCkiPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MCAxNTMiLz48cG9seWdvbiBmaWxsPSIjRUE4RTNBIiBwb2ludHM9IjkyLjI1IDEwMi4zNzUgOTUuMDYzIDE1MC4xODggODYuNjI1IDEyNS43MTkiLz48cG9seWdvbiBmaWxsPSIjRDg3QzMwIiBwb2ludHM9IjM5LjM3NSAxMzguOTM4IDY1LjI1IDEzOC4zNzUgNjAuNzUgMTczLjI1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSIxMi45MzggMTg4LjQzOCA2MC43NSAxNzMuMjUgMzkuMzc1IDEzOC45MzggLjU2MyAxNDEuNzUiLz48cG9seWdvbiBmaWxsPSIjRTg4MjFFIiBwb2ludHM9Ijg4Ljg3NSA1OC41IDY0LjY4OCA3OC43NSA0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi45MzgiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PC9nPjwvZz48L3N2Zz4=\"), _(this, \"windowKey\", \"starknet_metamask\"), _(this, \"provider\", null), _(this, \"swo\", null), _(this, \"lock\"), _(this, \"version\", \"v2.0.0\"), this.lock = new Mutex();\n  }\n  async loadWallet(e) {\n    return await E(this, C, G).call(this, e), this;\n  }\n  async hasSupport(e) {\n    return this.provider = await detectMetamaskSupport(e), this.provider !== null;\n  }\n  async request(e) {\n    return E(this, C, G).call(this).then((o) => o.request(\n      e\n    ));\n  }\n  on(e, o) {\n    E(this, C, G).call(this).then(\n      (n) => n.on(e, o)\n    );\n  }\n  off(e, o) {\n    E(this, C, G).call(this).then(\n      (n) => n.off(e, o)\n    );\n  }\n}\nQ = /* @__PURE__ */ new WeakSet(), q = async function(t) {\n  this.provider || (this.provider = await detectMetamaskSupport(t)), await init({\n    name: \"MetaMaskStarknetSnapWallet\",\n    remotes: [\n      {\n        name: \"MetaMaskStarknetSnapWallet\",\n        alias: \"MetaMaskStarknetSnapWallet\",\n        entry: `https://snaps.consensys.io/starknet/get-starknet/v1/remoteEntry.js?ts=${Date.now()}`\n      }\n    ]\n  });\n  const e = await loadRemote(\"MetaMaskStarknetSnapWallet/index\");\n  if (!e)\n    throw new Error(\"Failed to load MetaMask Wallet\");\n  return new e.MetaMaskSnapWallet(\n    this.provider,\n    \"*\"\n  );\n}, C = /* @__PURE__ */ new WeakSet(), G = async function(t = window) {\n  return this.lock.runExclusive(async () => (this.swo || (this.swo = await E(this, Q, q).call(this, t), E(this, Y, J).call(this)), this.swo));\n}, Y = /* @__PURE__ */ new WeakSet(), J = function() {\n  this.swo && (this.version = this.swo.version, this.name = this.swo.name, this.id = this.swo.id, this.icon = this.swo.icon);\n};\nconst metaMaskVirtualWallet = new MetaMaskVirtualWallet();\nvar X, Z;\nconst wallets = [\n  {\n    id: \"argentX\",\n    name: \"Argent X\",\n    icon: \"data:image/svg+xml;base64,Cjxzdmcgd2lkdGg9IjQwIiBoZWlnaHQ9IjM2IiB2aWV3Qm94PSIwIDAgNDAgMzYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0yNC43NTgyIC0zLjk3MzY0ZS0wN0gxNC42MjM4QzE0LjI4NTEgLTMuOTczNjRlLTA3IDE0LjAxMzggMC4yODExNzggMTQuMDA2NCAwLjYzMDY4M0MxMy44MDE3IDEwLjQ1NDkgOC44MjIzNCAxOS43NzkyIDAuMjUxODkzIDI2LjM4MzdDLTAuMDIwMjA0NiAyNi41OTMzIC0wLjA4MjE5NDYgMjYuOTg3MiAwLjExNjczNCAyNy4yNzA5TDYuMDQ2MjMgMzUuNzM0QzYuMjQ3OTYgMzYuMDIyIDYuNjQwOTkgMzYuMDg3IDYuOTE3NjYgMzUuODc1NEMxMi4yNzY1IDMxLjc3MjggMTYuNTg2OSAyNi44MjM2IDE5LjY5MSAyMS4zMzhDMjIuNzk1MSAyNi44MjM2IDI3LjEwNTcgMzEuNzcyOCAzMi40NjQ2IDM1Ljg3NTRDMzIuNzQxIDM2LjA4NyAzMy4xMzQxIDM2LjAyMiAzMy4zMzYxIDM1LjczNEwzOS4yNjU2IDI3LjI3MDlDMzkuNDY0MiAyNi45ODcyIDM5LjQwMjIgMjYuNTkzMyAzOS4xMzA0IDI2LjM4MzdDMzAuNTU5NyAxOS43NzkyIDI1LjU4MDQgMTAuNDU0OSAyNS4zNzU5IDAuNjMwNjgzQzI1LjM2ODUgMC4yODExNzggMjUuMDk2OSAtMy45NzM2NGUtMDcgMjQuNzU4MiAtMy45NzM2NGUtMDdaIiBmaWxsPSIjRkY4NzVCIi8+Cjwvc3ZnPgo=\",\n    downloads: {\n      chrome: \"https://chrome.google.com/webstore/detail/argent-x-starknet-wallet/dlcobpjiigpikoobohmabehhmhfoodbb\",\n      firefox: \"https://addons.mozilla.org/en-US/firefox/addon/argent-x\",\n      edge: \"https://microsoftedge.microsoft.com/addons/detail/argent-x/ajcicjlkibolbeaaagejfhnofogocgcj\"\n    }\n  },\n  {\n    id: \"braavos\",\n    name: \"Braavos\",\n    icon: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8cGF0aAogICAgICAgIGQ9Ik02Mi43MDUgMTMuOTExNkM2Mi44MzU5IDE0LjEzMzMgNjIuNjYyMSAxNC40MDcgNjIuNDAzOSAxNC40MDdDNTcuMTgwNyAxNC40MDcgNTIuOTM0OCAxOC41NDI3IDUyLjgzNTEgMjMuNjgxN0M1MS4wNDY1IDIzLjM0NzcgNDkuMTkzMyAyMy4zMjI2IDQ3LjM2MjYgMjMuNjMxMUM0Ny4yMzYxIDE4LjUxNTYgNDMuMDAwOSAxNC40MDcgMzcuNzk0OCAxNC40MDdDMzcuNTM2NSAxNC40MDcgMzcuMzYyNSAxNC4xMzMxIDM3LjQ5MzUgMTMuOTExMkM0MC4wMjE3IDkuNjI4MDkgNDQuNzIwNCA2Ljc1IDUwLjA5OTEgNi43NUM1NS40NzgxIDYuNzUgNjAuMTc2OSA5LjYyODI2IDYyLjcwNSAxMy45MTE2WiIKICAgICAgICBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMzcyXzQwMjU5KSIgLz4KICAgIDxwYXRoCiAgICAgICAgZD0iTTc4Ljc2MDYgNDUuODcxOEM4MC4yNzI1IDQ2LjMyOTcgODEuNzAyNSA0NS4wMDU1IDgxLjE3MTQgNDMuNTIyMkM3Ni40MTM3IDMwLjIzMzQgNjEuMzkxMSAyNC44MDM5IDUwLjAyNzcgMjQuODAzOUMzOC42NDQyIDI0LjgwMzkgMjMuMjg2OCAzMC40MDcgMTguODc1NCA0My41OTEyQzE4LjM4MjQgNDUuMDY0NSAxOS44MDgzIDQ2LjM0NDYgMjEuMjk3OCA0NS44ODgxTDQ4Ljg3MiAzNy40MzgxQzQ5LjUzMzEgMzcuMjM1NSA1MC4yMzk5IDM3LjIzNDQgNTAuOTAxNyAzNy40MzQ4TDc4Ljc2MDYgNDUuODcxOFoiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8cGF0aAogICAgICAgIGQ9Ik0xOC44MTMyIDQ4LjE3MDdMNDguODkzNSAzOS4wNDcyQzQ5LjU1MDYgMzguODQ3OCA1MC4yNTI0IDM4Ljg0NzMgNTAuOTA5OCAzOS4wNDU2TDgxLjE3ODEgNDguMTc1MkM4My42OTEyIDQ4LjkzMzIgODUuNDExIDUxLjI0ODMgODUuNDExIDUzLjg3MzVWODEuMjIzM0M4NS4yOTQ0IDg3Ljg5OTEgNzkuMjk3NyA5My4yNSA3Mi42MjQ1IDkzLjI1SDYxLjU0MDZDNjAuNDQ0OSA5My4yNSA1OS41NTc3IDkyLjM2MzcgNTkuNTU3NyA5MS4yNjhWODEuNjc4OUM1OS41NTc3IDc3LjkwMzEgNjEuNzkyMSA3NC40ODU1IDY1LjI0OTggNzIuOTcyOUM2OS44ODQ5IDcwLjk0NTQgNzUuMzY4MSA2OC4yMDI4IDc2LjM5OTQgNjIuNjk5MkM3Ni43MzIzIDYwLjkyMjkgNzUuNTc0MSA1OS4yMDk0IDczLjgwMjQgNTguODU3M0M2OS4zMjI2IDU3Ljk2NjcgNjQuMzU2MiA1OC4zMTA3IDYwLjE1NjQgNjAuMTg5M0M1NS4zODg3IDYyLjMyMTkgNTQuMTQxNSA2NS44Njk0IDUzLjY3OTcgNzAuNjMzN0w1My4xMjAxIDc1Ljc2NjJDNTIuOTQ5MSA3Ny4zMzQ5IDUxLjQ3ODUgNzguNTM2NiA0OS45MDE0IDc4LjUzNjZDNDguMjY5OSA3OC41MzY2IDQ3LjA0NjUgNzcuMjk0IDQ2Ljg2OTYgNzUuNjcxMkw0Ni4zMjA0IDcwLjYzMzdDNDUuOTI0OSA2Ni41NTI5IDQ1LjIwNzkgNjIuNTg4NyA0MC45ODk1IDYwLjcwMThDMzYuMTc3NiA1OC41NDk0IDMxLjM0MTkgNTcuODM0NyAyNi4xOTc2IDU4Ljg1NzNDMjQuNDI2IDU5LjIwOTQgMjMuMjY3OCA2MC45MjI5IDIzLjYwMDcgNjIuNjk5MkMyNC42NDEgNjguMjUwNyAzMC4wODEyIDcwLjkzMDUgMzQuNzUwMyA3Mi45NzI5QzM4LjIwOCA3NC40ODU1IDQwLjQ0MjQgNzcuOTAzMSA0MC40NDI0IDgxLjY3ODlWOTEuMjY2M0M0MC40NDI0IDkyLjM2MiAzOS41NTU1IDkzLjI1IDM4LjQ1OTkgOTMuMjVIMjcuMzc1NkMyMC43MDI0IDkzLjI1IDE0LjcwNTcgODcuODk5MSAxNC41ODkxIDgxLjIyMzNWNTMuODY2M0MxNC41ODkxIDUxLjI0NDYgMTYuMzA0NSA0OC45MzE2IDE4LjgxMzIgNDguMTcwN1oiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDJfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8ZGVmcz4KICAgICAgICA8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMzcyXzQwMjU5IiB4MT0iNDkuMzA1NyIgeTE9IjIuMDc5IiB4Mj0iODAuMzYyNyIgeTI9IjkzLjY1OTciCiAgICAgICAgICAgIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIgLz4KICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5NjAwIiAvPgogICAgICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAgICAgPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzM3Ml80MDI1OSIgeDE9IjQ5LjMwNTciIHkxPSIyLjA3OSIgeDI9IjgwLjM2MjciIHkyPSI5My42NTk3IgogICAgICAgICAgICBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiNGNUQ0NUUiIC8+CiAgICAgICAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTYwMCIgLz4KICAgICAgICA8L2xpbmVhckdyYWRpZW50PgogICAgICAgIDxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl8zNzJfNDAyNTkiIHgxPSI0OS4zMDU3IiB5MT0iMi4wNzkiIHgyPSI4MC4zNjI3IiB5Mj0iOTMuNjU5NyIKICAgICAgICAgICAgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgogICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjRjVENDVFIiAvPgogICAgICAgICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiIC8+CiAgICAgICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDwvZGVmcz4KPC9zdmc+\",\n    downloads: {\n      chrome: \"https://chrome.google.com/webstore/detail/braavos-wallet/jnlgamecbpmbajjfhmmmlhejkemejdma\",\n      firefox: \"https://addons.mozilla.org/en-US/firefox/addon/braavos-wallet\",\n      edge: \"https://microsoftedge.microsoft.com/addons/detail/braavos-wallet/hkkpjehhcnhgefhbdcgfkeegglpjchdc\",\n      ios: `https://link.braavos.app/dapp/${(X = ssrSafeWindow?.location) == null ? void 0 : X.host}`,\n      android: `https://link.braavos.app/dapp/${(Z = ssrSafeWindow?.location) == null ? void 0 : Z.host}`\n    }\n  },\n  {\n    id: metaMaskVirtualWallet.id,\n    name: metaMaskVirtualWallet.name,\n    icon: metaMaskVirtualWallet.icon,\n    downloads: {\n      chrome: \"https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n      firefox: \"https://addons.mozilla.org/en-US/firefox/addon/ether-metamask/\",\n      edge: \"https://microsoftedge.microsoft.com/addons/detail/metamask/ejbalbakoplchlghecdalmeeeajnimhm?hl=en-US\"\n    }\n  },\n  {\n    id: \"okxwallet\",\n    name: \"OKX Wallet\",\n    icon: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zq9jtpAEMfHlhEgQLiioXEkoAGECwoKxMcTRHmC5E3IoyRPkPAEkI7unJYmTgEFTYwA8a3NTKScLnCHN6c9r1e3P2llWQy7M/s1Gv1twCP0ej37dDq9x+Zut1t3t9vZjDEHIiSRSPg4ZpDL5fxkMvn1cDh8m0wmfugfO53OoFQq/crn8wxfY9EymQyrVCqMfHvScZx1p9ls3pFxXBy/bKlUipGPrVbLuQqAfsCliq3zl0H84zwtjQrOw4Mt1W63P5LvBm2d+Xz+YzqdgkqUy+WgWCy+Mc/nc282m4FqLBYL+3g8fjDxenq72WxANZbLJeA13zDX67UDioL5ybXwafMYu64Ltn3bdDweQ5R97fd7GyhBQMipx4POeEDHIu2LfDdBIGGz+hJ9CQ1ABjoA2egAZPM6AgiCAEQhsi/C4jHyPA/6/f5NG3Ks2+3CYDC4aTccDrn6ojG54MnEvG00GoVmWLIRNZ7wTCwDHYBsdACy0QHIhiuRETxlICWpMMhGZHmqS8qH6JLyGegAZKMDkI0uKf8X4SWlaZo+Pp1bRrwlJU8ZKLIvUjKh0WiQ3sRUbNVq9c5Ebew7KEo2m/1p4jJ4qAmDaqDQBzj5XyiAT4VCQezJigAU+IDU+z8vJFnGWeC+bKQV/5VZ71FV6L7PA3gg3tXrdQ+DgLhC+75Wq3no69P3MC0NFQpx2lL04Ql9gHK1bRDjsSBIvScBnDTk1WrlGIZBorIDEYJj+rhdgnQ67VmWRe0zlplXl81vcyEt0rSoYDUAAAAASUVORK5CYII=\",\n    downloads: {\n      chrome: \"https://chrome.google.com/webstore/detail/mcohilncbfahbmgdjkbpemcciiolgcge\",\n      firefox: \"https://addons.mozilla.org/en-US/firefox/addon/okexwallet\",\n      edge: \"https://microsoftedge.microsoft.com/addons/detail/%E6%AC%A7%E6%98%93-web3-%E9%92%B1%E5%8C%85/pbpjkcldjiffchgbbndmhojiacbgflha\",\n      safari: \"https://apps.apple.com/us/app/okx-wallet/id6463797825\"\n    }\n  },\n  {\n    id: \"keplr\",\n    name: \"Keplr\",\n    icon: \"data:image/png;base64,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\",\n    downloads: {\n      chrome: \"https://chrome.google.com/webstore/detail/keplr/dmkamcknogkgcdfhhbddcghachkejeap\",\n      firefox: \"https://addons.mozilla.org/en-US/firefox/addon/keplr\",\n      edge: \"https://microsoftedge.microsoft.com/addons/detail/keplr/ocodgmmffbkkeecmadcijjhkmeohinei\"\n    }\n  },\n  {\n    id: \"fordefi\",\n    name: \"Fordefi\",\n    icon: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzNDk0XzY2MjU0KSI+CjxwYXRoIGQ9Ik0xMC44NzY5IDE1LjYzNzhIMS41VjE4LjM5OUMxLjUgMTkuODAxMyAyLjYzNDQ3IDIwLjkzOCA0LjAzMzkyIDIwLjkzOEg4LjI0OTkyTDEwLjg3NjkgMTUuNjM3OFoiIGZpbGw9IiM3OTk0RkYiLz4KPHBhdGggZD0iTTEuNSA5Ljc3NTUxSDE5LjA1MTZMMTcuMDEzOSAxMy44NzExSDEuNVY5Ljc3NTUxWiIgZmlsbD0iIzQ4NkRGRiIvPgo8cGF0aCBkPSJNNy42NTk5NiAzSDEuNTI0NDFWOC4wMDcwNEgyMi40NjEyVjNIMTYuMzI1NlY2LjczOTQ0SDE1LjA2MDZWM0g4LjkyNTAyVjYuNzM5NDRINy42NTk5NlYzWiIgZmlsbD0iIzVDRDFGQSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzNDk0XzY2MjU0Ij4KPHJlY3Qgd2lkdGg9IjIxIiBoZWlnaHQ9IjE4IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS41IDMpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==\",\n    downloads: {\n      chrome: \"https://chrome.google.com/webstore/detail/fordefi/hcmehenccjdmfbojapcbcofkgdpbnlle\"\n    }\n  }\n];\nvar z, j, P, V, ee, k, F;\nclass LocalStorageWrapper {\n  constructor(e) {\n    T(this, V), T(this, k), T(this, z, !1), T(this, j, void 0), T(this, P, void 0), _(this, \"value\"), B(this, P, e), E(this, k, F).call(this);\n  }\n  set(e) {\n    return !N(this, z) && !E(this, k, F).call(this) ? !1 : (this.delete(), this.value = e, e && (B(this, j, `${N(this, P)}-${generateUID()}`), localStorage.setItem(N(this, j), e)), !0);\n  }\n  get() {\n    return E(this, V, ee).call(this), this.value;\n  }\n  delete() {\n    return !N(this, z) && !E(this, k, F).call(this) ? !1 : (this.value = null, N(this, j) && localStorage.removeItem(N(this, j)), !0);\n  }\n}\nz = /* @__PURE__ */ new WeakMap(), j = /* @__PURE__ */ new WeakMap(), P = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakSet(), ee = function() {\n  this.value && this.set(this.value);\n}, k = /* @__PURE__ */ new WeakSet(), F = function() {\n  try {\n    !N(this, z) && typeof window < \"u\" && (B(this, j, Object.keys(localStorage).find(\n      (t) => t.startsWith(N(this, P))\n    )), B(this, z, !0), N(this, j) && this.set(localStorage.getItem(N(this, j))));\n  } catch (t) {\n    console.warn(t);\n  }\n  return N(this, z);\n};\nconst Permission = {\n  ACCOUNTS: \"accounts\"\n};\nfunction filterBy(t, e) {\n  var o, n;\n  if ((o = e?.include) != null && o.length) {\n    const r = new Set(e.include);\n    return t.filter((i) => r.has(i.id));\n  }\n  if ((n = e?.exclude) != null && n.length) {\n    const r = new Set(e.exclude);\n    return t.filter((i) => !r.has(i.id));\n  }\n  return t;\n}\nconst filterByAuthorized = async (t) => {\n  const e = await Promise.all(\n    t.map(async (o) => {\n      try {\n        return (await o.request({\n          type: \"wallet_getPermissions\"\n        })).includes(Permission.ACCOUNTS);\n      } catch {\n        return !1;\n      }\n    })\n  );\n  return t.filter((o, n) => e[n]);\n}, virtualWalletKeys = ensureKeysArray({\n  id: !0,\n  name: !0,\n  icon: !0,\n  windowKey: !0,\n  loadWallet: !0,\n  hasSupport: !0\n}), fullWalletKeys = ensureKeysArray({\n  id: !0,\n  name: !0,\n  version: !0,\n  icon: !0,\n  request: !0,\n  on: !0,\n  off: !0\n});\nfunction createWalletGuard(t) {\n  return function(e) {\n    return e !== null && typeof e == \"object\" && t.every((o) => o in e);\n  };\n}\nconst isFullWallet = createWalletGuard(fullWalletKeys), isVirtualWallet = createWalletGuard(virtualWalletKeys);\nfunction isWalletObject(t) {\n  try {\n    return isFullWallet(t) || isVirtualWallet(t);\n  } catch {\n  }\n  return !1;\n}\nfunction scanObjectForWallets(t, e) {\n  return Object.values(\n    Object.getOwnPropertyNames(t).reduce((o, n) => {\n      if (n.startsWith(\"starknet\")) {\n        const r = t[n];\n        e(r) && !o[r.id] && (o[r.id] = r);\n      }\n      return o;\n    }, {})\n  );\n}\nconst sortBy = (t, e) => {\n  if (e && Array.isArray(e)) {\n    t.sort((n, r) => e.indexOf(n.id) - e.indexOf(r.id));\n    const o = t.length - e.length;\n    return [\n      ...t.slice(o),\n      ...shuffle(t.slice(0, o))\n    ];\n  } else\n    return shuffle(t);\n}, virtualWallets = [metaMaskVirtualWallet];\nfunction initiateVirtualWallets(t) {\n  virtualWallets.forEach(async (e) => {\n    e.windowKey in t || await e.hasSupport(t) && (t[e.windowKey] = e);\n  });\n}\nconst virtualWalletsMap = {};\nasync function resolveVirtualWallet(t, e) {\n  let o = virtualWalletsMap[e.id];\n  return o || (o = await e.loadWallet(t), virtualWalletsMap[e.id] = o), o;\n}\nconst defaultOptions = {\n  windowObject: ssrSafeWindow ?? {},\n  isWalletObject,\n  storageFactoryImplementation: (t) => new LocalStorageWrapper(t)\n};\nfunction getStarknet(t = {}) {\n  const { storageFactoryImplementation: e, windowObject: o, isWalletObject: n } = {\n    ...defaultOptions,\n    ...t\n  }, r = e(\"gsw-last\");\n  return initiateVirtualWallets(o), {\n    getAvailableWallets: async (i = {}) => {\n      const a = scanObjectForWallets(\n        o,\n        n\n      );\n      return pipe$1(\n        (s) => filterBy(s, i),\n        (s) => sortBy(s, i.sort)\n      )(a);\n    },\n    getAuthorizedWallets: async (i = {}) => {\n      const a = scanObjectForWallets(\n        o,\n        n\n      );\n      return pipe$1(\n        (s) => filterByAuthorized(s),\n        (s) => filterBy(s, i),\n        (s) => sortBy(s, i.sort)\n      )(a);\n    },\n    getDiscoveryWallets: async (i = {}) => pipe$1(\n      (a) => filterBy(a, i),\n      (a) => sortBy(a, i.sort)\n    )(wallets),\n    getLastConnectedWallet: async () => {\n      const i = r.get(), a = scanObjectForWallets(o, n).find(\n        (c) => c.id === i\n      ), [s] = await filterByAuthorized(\n        a ? [a] : []\n      );\n      return s || (r.delete(), null);\n    },\n    discoverVirtualWallets: async (i = []) => {\n      const a = new Set(i), s = a.size > 0 ? virtualWallets.filter(\n        (c) => a.has(c.name) || a.has(c.id)\n      ) : virtualWallets;\n      await Promise.all(\n        s.map(async (c) => {\n          await c.hasSupport(o) && (o[c.windowKey] = c);\n        })\n      );\n    },\n    enable: async (i, a) => {\n      let s;\n      if (isVirtualWallet(i))\n        s = await resolveVirtualWallet(o, i);\n      else if (isFullWallet(i))\n        s = i;\n      else\n        throw new Error(\"Invalid wallet object\");\n      await s.request({\n        type: \"wallet_requestAccounts\",\n        params: {\n          silent_mode: a?.silent_mode\n        }\n      });\n      const c = await s.request({\n        type: \"wallet_getPermissions\"\n      });\n      if (!(c != null && c.includes(Permission.ACCOUNTS)))\n        throw new Error(\"Failed to connect to wallet\");\n      return r.set(s.id), s;\n    },\n    disconnect: async ({ clearLastWallet: i } = {}) => {\n      i && r.delete();\n    }\n  };\n}\nconst main = getStarknet();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9jb3JlLWQyMWQyZTk2LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxzRUFBc0UsMERBQTBEO0FBQ2hJO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDZCQUE2QixXQUFXLEdBQUcsaURBQWlEO0FBQzVGLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxlQUFlLElBQUksVUFBVSxxQkFBcUIsZUFBZSxJQUFJLEVBQUU7QUFDcEg7QUFDQTtBQUNBLHVDQUF1QyxlQUFlLElBQUksVUFBVSxzQ0FBc0MsZUFBZSxJQUFJLEVBQUU7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPLEdBQUcsVUFBVSxpQ0FBaUMsT0FBTyxHQUFHLFFBQVEsT0FBTyxPQUFPO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGNBQWM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLHdIQUF3SCxjQUFjO0FBQ3hOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUVBQXlFO0FBQ25HO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSx3R0FBd0c7QUFDeEcsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixFQUFFO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhCQUE4QixpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBLHNEQUFzRCxFQUFFO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUNBQWlDLHVEQUF1RDtBQUN4RixVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxZQUFZLHFDQUFxQztBQUNqRDtBQUNBLDRCQUE0QixFQUFFLE1BQU0sRUFBRSxhQUFhLEVBQUU7QUFDckQ7O0FBRUEsY0FBYyxFQUFFOztBQUVoQixhQUFhLEdBQUc7QUFDaEI7QUFDQSxHQUFHO0FBQ0gsYUFBYTtBQUNiO0FBQ0EsR0FBRztBQUNILFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0EsMEJBQTBCLEVBQUUsTUFBTSxFQUFFLGFBQWEsRUFBRTtBQUNuRDs7QUFFQSxZQUFZLEVBQUU7O0FBRWQsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQTJEO0FBQzNGLFVBQVUsaURBQWlEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUcsZ0NBQWdDO0FBQ25DO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseUlBQXlJO0FBQ3pJO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEIsc0JBQXNCLEVBQUU7QUFDMUU7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLFVBQVU7QUFDckY7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxVQUFVO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVix3RUFBd0UsVUFBVTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUU7QUFDL0I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLGtDQUFrQztBQUM5QztBQUNBLDhDQUE4QyxFQUFFO0FBQ2hELEtBQUs7QUFDTCxzREFBc0QsRUFBRTtBQUN4RCxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlLDJCQUEyQjtBQUNwRjtBQUNBO0FBQ0EsS0FBSyxFQUFFO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUF3RDtBQUNsRTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxjQUFjLHlCQUF5QjtBQUN2QyxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFGQUFxRixNQUFNO0FBQzNGLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0VBQW9FO0FBQ2xGO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlEQUF5RDtBQUN6RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLGFBQWEsT0FBTyxtQkFBbUIsT0FBTyxnQkFBZ0I7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCLCtCQUErQixPQUFPLEdBQUcsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRyxRQUFRO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtGQUErRjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYSx1QkFBdUIsOERBQThELGlDQUFpQyx1Q0FBdUM7QUFDdEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUsscUpBQXFKO0FBQzFKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLDhEQUE4RCxpQ0FBaUMsdUNBQXVDO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlFQUFpRSxzREFBc0Q7QUFDdkg7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsa0RBQWtELG9CQUFvQjtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNEQUFzRCxPQUFPLGVBQWUsVUFBVTs7QUFFdEY7O0FBRUEsMkJBQTJCLE9BQU8sYUFBYSxVQUFVOztBQUV6RCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLHlFQUF5RSx1RUFBdUUsR0FBRztBQUNuSixRQUFRO0FBQ1IsZ0RBQWdELE9BQU8sd0JBQXdCLEVBQUU7QUFDakY7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU8sS0FBSyxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssS0FBSyxlQUFlO0FBQ3pCLDZCQUE2QixHQUFHLGVBQWUsa0JBQWtCLDJCQUEyQixHQUFHO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxFQUFFLFFBQVEsR0FBRyx3QkFBd0Isa0JBQWtCO0FBQy9HOztBQUVBLGlCQUFpQixHQUFHOztBQUVwQixpQkFBaUIsR0FBRzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHdEQUF3RCxFQUFFLFFBQVEsR0FBRyx3QkFBd0Isa0JBQWtCO0FBQy9HOztBQUVBLGlCQUFpQixHQUFHOztBQUVwQixpQkFBaUIsR0FBRzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUssUUFBUTtBQUNsQjtBQUNBLDJCQUEyQixHQUFHLEtBQUssa0JBQWtCOztBQUVyRCxhQUFhLEdBQUcsaURBQWlELGdDQUFnQzs7QUFFakcsYUFBYSxHQUFHLHlDQUF5QyxtQkFBbUI7QUFDNUUsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsSUFBSTtBQUNqQix1SEFBdUgsRUFBRTtBQUN6SDtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLLE1BQU0sdUJBQXVCO0FBQ2xDLDRJQUE0SSxFQUFFO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQSxPQUFPLElBQUksa0RBQWtELDhDQUE4QyxpREFBaUQ7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLFlBQVksNkJBQTZCLHVDQUF1QztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0MsMEJBQTBCLGtCQUFrQiw2QkFBNkI7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVFQUF1RTtBQUNyRixZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsNkRBQTZEO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDLFNBQVMsWUFBWSxRQUFRLHFDQUFxQyxhQUFhO0FBQy9HO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRyxxQkFBcUI7QUFDeEIsZUFBZSx1Q0FBdUM7QUFDdEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBK0M7QUFDL0Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRyx5QkFBeUI7QUFDeEksS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxxQ0FBcUMsZ0VBQWdFO0FBQ3JHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDZEQUE2RCxPQUFPO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CLElBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsZ0RBQWdEO0FBQ2hELFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RCxJQUFJO0FBQ0o7QUFDQSxxRUFBcUUsNEJBQTRCO0FBQ2pHO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSSxLQUFLO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixXQUFXO0FBQ25HO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3REFBd0Q7QUFDcEcsZ0RBQWdELHdEQUF3RDtBQUN4RztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRyxXQUFXLEdBQUcsY0FBYztBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsVUFBVSxzRUFBc0U7QUFDaEY7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5QixxQkFBcUIsSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdGFya25ldGtpdEAyLjEwLjRfYnVmZmVydXRpbEA0LjAuOV9zdGFya25ldEA2LjI0LjFfZW5jb2RpbmdAMC4xLjEzX190eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDYuMC41X3pvZEAzLjI1LjUwL25vZGVfbW9kdWxlcy9zdGFya25ldGtpdC9kaXN0L2NvcmUtZDIxZDJlOTYuanM/MjcyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdGUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIG5lID0gKHQsIGUsIG8pID0+IGUgaW4gdCA/IHRlKHQsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IG8gfSkgOiB0W2VdID0gbywgXyA9ICh0LCBlLCBvKSA9PiAobmUodCwgdHlwZW9mIGUgIT0gXCJzeW1ib2xcIiA/IGUgKyBcIlwiIDogZSwgbyksIG8pLCBLID0gKHQsIGUsIG8pID0+IHtcbiAgaWYgKCFlLmhhcyh0KSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBvKTtcbn0sIE4gPSAodCwgZSwgbykgPT4gKEsodCwgZSwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSwgbyA/IG8uY2FsbCh0KSA6IGUuZ2V0KHQpKSwgVCA9ICh0LCBlLCBvKSA9PiB7XG4gIGlmIChlLmhhcyh0KSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO1xuICBlIGluc3RhbmNlb2YgV2Vha1NldCA/IGUuYWRkKHQpIDogZS5zZXQodCwgbyk7XG59LCBCID0gKHQsIGUsIG8sIG4pID0+IChLKHQsIGUsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSwgbiA/IG4uY2FsbCh0LCBvKSA6IGUuc2V0KHQsIG8pLCBvKSwgRSA9ICh0LCBlLCBvKSA9PiAoSyh0LCBlLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKSwgbyk7XG5jb25zdCBnZW5lcmF0ZVVJRCA9ICgpID0+IGAke0RhdGUubm93KCl9LSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogODk5OTk5OTk5OTk5OSkgKyAxZTEyfWAsIHNodWZmbGUgPSAodCkgPT4ge1xuICBmb3IgKGxldCBlID0gdC5sZW5ndGggLSAxOyBlID4gMDsgZS0tKSB7XG4gICAgY29uc3QgbyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChlICsgMSkpO1xuICAgIFt0W2VdLCB0W29dXSA9IFt0W29dLCB0W2VdXTtcbiAgfVxuICByZXR1cm4gdDtcbn0sIHBpcGUkMSA9ICguLi50KSA9PiAoZSkgPT4gdC5yZWR1Y2UoKG8sIG4pID0+IG8udGhlbihuKSwgUHJvbWlzZS5yZXNvbHZlKGUpKTtcbmZ1bmN0aW9uIGVuc3VyZUtleXNBcnJheSh0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0KTtcbn1cbmNvbnN0IHNzclNhZmVXaW5kb3cgPSB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyB3aW5kb3cgOiBudWxsO1xuZnVuY3Rpb24gZ2V0QnVpbGRlcklkKCkge1xuICByZXR1cm4gdHlwZW9mIEZFREVSQVRJT05fQlVJTERfSURFTlRJRklFUiA8IFwidVwiID8gRkVERVJBVElPTl9CVUlMRF9JREVOVElGSUVSIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGlzRGVidWdNb2RlJDEoKSB7XG4gIHJldHVybiAhIVwiXCI7XG59XG5mdW5jdGlvbiBpc0Jyb3dzZXJFbnYkMSgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPCBcInVcIjtcbn1cbmNvbnN0IExPR19DQVRFR09SWSQxID0gXCJbIEZlZGVyYXRpb24gUnVudGltZSBdXCI7XG5mdW5jdGlvbiBhc3NlcnQodCwgZSkge1xuICB0IHx8IGVycm9yKGUpO1xufVxuZnVuY3Rpb24gZXJyb3IodCkge1xuICB0aHJvdyB0IGluc3RhbmNlb2YgRXJyb3IgPyAodC5tZXNzYWdlID0gYCR7TE9HX0NBVEVHT1JZJDF9OiAke3QubWVzc2FnZX1gLCB0KSA6IG5ldyBFcnJvcihgJHtMT0dfQ0FURUdPUlkkMX06ICR7dH1gKTtcbn1cbmZ1bmN0aW9uIHdhcm4kMSh0KSB7XG4gIHQgaW5zdGFuY2VvZiBFcnJvciA/ICh0Lm1lc3NhZ2UgPSBgJHtMT0dfQ0FURUdPUlkkMX06ICR7dC5tZXNzYWdlfWAsIGNvbnNvbGUud2Fybih0KSkgOiBjb25zb2xlLndhcm4oYCR7TE9HX0NBVEVHT1JZJDF9OiAke3R9YCk7XG59XG5mdW5jdGlvbiBhZGRVbmlxdWVJdGVtKHQsIGUpIHtcbiAgcmV0dXJuIHQuZmluZEluZGV4KChvKSA9PiBvID09PSBlKSA9PT0gLTEgJiYgdC5wdXNoKGUpLCB0O1xufVxuZnVuY3Rpb24gZ2V0Rk1JZCh0KSB7XG4gIHJldHVybiBcInZlcnNpb25cIiBpbiB0ICYmIHQudmVyc2lvbiA/IGAke3QubmFtZX06JHt0LnZlcnNpb259YCA6IFwiZW50cnlcIiBpbiB0ICYmIHQuZW50cnkgPyBgJHt0Lm5hbWV9OiR7dC5lbnRyeX1gIDogYCR7dC5uYW1lfWA7XG59XG5mdW5jdGlvbiBpc1JlbW90ZUluZm9XaXRoRW50cnkodCkge1xuICByZXR1cm4gdHlwZW9mIHQuZW50cnkgPCBcInVcIjtcbn1cbmZ1bmN0aW9uIGlzUHVyZVJlbW90ZUVudHJ5KHQpIHtcbiAgcmV0dXJuICF0LmVudHJ5LmluY2x1ZGVzKFwiLmpzb25cIikgJiYgdC5lbnRyeS5pbmNsdWRlcyhcIi5qc1wiKTtcbn1cbmZ1bmN0aW9uIHNhZmVUb1N0cmluZyQxKHQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodCwgbnVsbCwgMik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5mdW5jdGlvbiBpc09iamVjdCh0KSB7XG4gIHJldHVybiB0ICYmIHR5cGVvZiB0ID09IFwib2JqZWN0XCI7XG59XG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwodCkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBfZXh0ZW5kcyQxJDEoKSB7XG4gIHJldHVybiBfZXh0ZW5kcyQxJDEgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlID0gMTsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIG8gPSBhcmd1bWVudHNbZV07XG4gICAgICBmb3IgKHZhciBuIGluIG8pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBuKSAmJiAodFtuXSA9IG9bbl0pO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfSwgX2V4dGVuZHMkMSQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSQxKHQsIGUpIHtcbiAgaWYgKHQgPT0gbnVsbClcbiAgICByZXR1cm4ge307XG4gIHZhciBvID0ge30sIG4gPSBPYmplY3Qua2V5cyh0KSwgciwgaTtcbiAgZm9yIChpID0gMDsgaSA8IG4ubGVuZ3RoOyBpKyspXG4gICAgciA9IG5baV0sICEoZS5pbmRleE9mKHIpID49IDApICYmIChvW3JdID0gdFtyXSk7XG4gIHJldHVybiBvO1xufVxuY29uc3QgbmF0aXZlR2xvYmFsID0gKCgpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIH1cbn0pKCksIEdsb2JhbCA9IG5hdGl2ZUdsb2JhbDtcbmZ1bmN0aW9uIGRlZmluZVByb3BlcnR5R2xvYmFsVmFsKHQsIGUsIG8pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIGUsIHtcbiAgICB2YWx1ZTogbyxcbiAgICBjb25maWd1cmFibGU6ICExLFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVPd25Qcm9wZXJ0eSh0LCBlKSB7XG4gIHJldHVybiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0LCBlKTtcbn1cbmluY2x1ZGVPd25Qcm9wZXJ0eShnbG9iYWxUaGlzLCBcIl9fR0xPQkFMX0xPQURJTkdfUkVNT1RFX0VOVFJZX19cIikgfHwgZGVmaW5lUHJvcGVydHlHbG9iYWxWYWwoZ2xvYmFsVGhpcywgXCJfX0dMT0JBTF9MT0FESU5HX1JFTU9URV9FTlRSWV9fXCIsIHt9KTtcbmNvbnN0IGdsb2JhbExvYWRpbmcgPSBnbG9iYWxUaGlzLl9fR0xPQkFMX0xPQURJTkdfUkVNT1RFX0VOVFJZX187XG5mdW5jdGlvbiBzZXRHbG9iYWxEZWZhdWx0VmFsKHQpIHtcbiAgdmFyIGUsIG8sIG4sIHIsIGksIGE7XG4gIGluY2x1ZGVPd25Qcm9wZXJ0eSh0LCBcIl9fVk1PS19fXCIpICYmICFpbmNsdWRlT3duUHJvcGVydHkodCwgXCJfX0ZFREVSQVRJT05fX1wiKSAmJiBkZWZpbmVQcm9wZXJ0eUdsb2JhbFZhbCh0LCBcIl9fRkVERVJBVElPTl9fXCIsIHQuX19WTU9LX18pLCBpbmNsdWRlT3duUHJvcGVydHkodCwgXCJfX0ZFREVSQVRJT05fX1wiKSB8fCAoZGVmaW5lUHJvcGVydHlHbG9iYWxWYWwodCwgXCJfX0ZFREVSQVRJT05fX1wiLCB7XG4gICAgX19HTE9CQUxfUExVR0lOX186IFtdLFxuICAgIF9fSU5TVEFOQ0VTX186IFtdLFxuICAgIG1vZHVsZUluZm86IHt9LFxuICAgIF9fU0hBUkVfXzoge30sXG4gICAgX19NQU5JRkVTVF9MT0FESU5HX186IHt9LFxuICAgIF9fUFJFTE9BREVEX01BUF9fOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gIH0pLCBkZWZpbmVQcm9wZXJ0eUdsb2JhbFZhbCh0LCBcIl9fVk1PS19fXCIsIHQuX19GRURFUkFUSU9OX18pKSwgKGUgPSB0Ll9fRkVERVJBVElPTl9fKS5fX0dMT0JBTF9QTFVHSU5fXyAhPSBudWxsIHx8IChlLl9fR0xPQkFMX1BMVUdJTl9fID0gW10pLCAobyA9IHQuX19GRURFUkFUSU9OX18pLl9fSU5TVEFOQ0VTX18gIT0gbnVsbCB8fCAoby5fX0lOU1RBTkNFU19fID0gW10pLCAobiA9IHQuX19GRURFUkFUSU9OX18pLm1vZHVsZUluZm8gIT0gbnVsbCB8fCAobi5tb2R1bGVJbmZvID0ge30pLCAociA9IHQuX19GRURFUkFUSU9OX18pLl9fU0hBUkVfXyAhPSBudWxsIHx8IChyLl9fU0hBUkVfXyA9IHt9KSwgKGkgPSB0Ll9fRkVERVJBVElPTl9fKS5fX01BTklGRVNUX0xPQURJTkdfXyAhPSBudWxsIHx8IChpLl9fTUFOSUZFU1RfTE9BRElOR19fID0ge30pLCAoYSA9IHQuX19GRURFUkFUSU9OX18pLl9fUFJFTE9BREVEX01BUF9fICE9IG51bGwgfHwgKGEuX19QUkVMT0FERURfTUFQX18gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbn1cbnNldEdsb2JhbERlZmF1bHRWYWwoZ2xvYmFsVGhpcyk7XG5zZXRHbG9iYWxEZWZhdWx0VmFsKG5hdGl2ZUdsb2JhbCk7XG5mdW5jdGlvbiBnZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UodCwgZSkge1xuICBjb25zdCBvID0gZ2V0QnVpbGRlcklkKCk7XG4gIHJldHVybiBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fSU5TVEFOQ0VTX18uZmluZCgobikgPT4gISEobyAmJiBuLm9wdGlvbnMuaWQgPT09IGdldEJ1aWxkZXJJZCgpIHx8IG4ub3B0aW9ucy5uYW1lID09PSB0ICYmICFuLm9wdGlvbnMudmVyc2lvbiAmJiAhZSB8fCBuLm9wdGlvbnMubmFtZSA9PT0gdCAmJiBlICYmIG4ub3B0aW9ucy52ZXJzaW9uID09PSBlKSk7XG59XG5mdW5jdGlvbiBzZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UodCkge1xuICBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fSU5TVEFOQ0VTX18ucHVzaCh0KTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvcigpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19ERUJVR19DT05TVFJVQ1RPUl9fO1xufVxuZnVuY3Rpb24gc2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yKHQsIGUgPSBpc0RlYnVnTW9kZSQxKCkpIHtcbiAgZSAmJiAoZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX0RFQlVHX0NPTlNUUlVDVE9SX18gPSB0LCBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fREVCVUdfQ09OU1RSVUNUT1JfVkVSU0lPTl9fID0gXCIwLjEuMlwiKTtcbn1cbmZ1bmN0aW9uIGdldEluZm9XaXRob3V0VHlwZSh0LCBlKSB7XG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHRbZV0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdFtlXSxcbiAgICAgICAga2V5OiBlXG4gICAgICB9O1xuICAgIHtcbiAgICAgIGNvbnN0IG8gPSBPYmplY3Qua2V5cyh0KTtcbiAgICAgIGZvciAoY29uc3QgbiBvZiBvKSB7XG4gICAgICAgIGNvbnN0IFtyLCBpXSA9IG4uc3BsaXQoXCI6XCIpLCBhID0gYCR7cn06JHtlfWAsIHMgPSB0W2FdO1xuICAgICAgICBpZiAocylcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHMsXG4gICAgICAgICAgICBrZXk6IGFcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAga2V5OiBlXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKFwia2V5IG11c3QgYmUgc3RyaW5nXCIpO1xufVxuY29uc3QgZ2V0R2xvYmFsU25hcHNob3QgPSAoKSA9PiBuYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX18ubW9kdWxlSW5mbywgZ2V0VGFyZ2V0U25hcHNob3RJbmZvQnlNb2R1bGVJbmZvID0gKHQsIGUpID0+IHtcbiAgY29uc3QgbyA9IGdldEZNSWQodCksIG4gPSBnZXRJbmZvV2l0aG91dFR5cGUoZSwgbykudmFsdWU7XG4gIGlmIChuICYmICFuLnZlcnNpb24gJiYgXCJ2ZXJzaW9uXCIgaW4gdCAmJiB0LnZlcnNpb24gJiYgKG4udmVyc2lvbiA9IHQudmVyc2lvbiksIG4pXG4gICAgcmV0dXJuIG47XG4gIGlmIChcInZlcnNpb25cIiBpbiB0ICYmIHQudmVyc2lvbikge1xuICAgIGNvbnN0IHsgdmVyc2lvbjogciB9ID0gdCwgaSA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlJDEodCwgW1xuICAgICAgXCJ2ZXJzaW9uXCJcbiAgICBdKSwgYSA9IGdldEZNSWQoaSksIHMgPSBnZXRJbmZvV2l0aG91dFR5cGUobmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm8sIGEpLnZhbHVlO1xuICAgIGlmIChzPy52ZXJzaW9uID09PSByKVxuICAgICAgcmV0dXJuIHM7XG4gIH1cbn0sIGdldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyA9ICh0KSA9PiBnZXRUYXJnZXRTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8odCwgbmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm8pLCBzZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8gPSAodCwgZSkgPT4ge1xuICBjb25zdCBvID0gZ2V0Rk1JZCh0KTtcbiAgcmV0dXJuIG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvW29dID0gZSwgbmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm87XG59LCBhZGRHbG9iYWxTbmFwc2hvdCA9ICh0KSA9PiAobmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm8gPSBfZXh0ZW5kcyQxJDEoe30sIG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvLCB0KSwgKCkgPT4ge1xuICBjb25zdCBlID0gT2JqZWN0LmtleXModCk7XG4gIGZvciAoY29uc3QgbyBvZiBlKVxuICAgIGRlbGV0ZSBuYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX18ubW9kdWxlSW5mb1tvXTtcbn0pLCBnZXRSZW1vdGVFbnRyeUV4cG9ydHMgPSAodCwgZSkgPT4ge1xuICBjb25zdCBvID0gZSB8fCBgX19GRURFUkFUSU9OXyR7dH06Y3VzdG9tX19gLCBuID0gZ2xvYmFsVGhpc1tvXTtcbiAgcmV0dXJuIHtcbiAgICByZW1vdGVFbnRyeUtleTogbyxcbiAgICBlbnRyeUV4cG9ydHM6IG5cbiAgfTtcbn0sIGdldEdsb2JhbEhvc3RQbHVnaW5zID0gKCkgPT4gbmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLl9fR0xPQkFMX1BMVUdJTl9fLCBnZXRQcmVsb2FkZWQgPSAodCkgPT4gZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX1BSRUxPQURFRF9NQVBfXy5nZXQodCksIHNldFByZWxvYWRlZCA9ICh0KSA9PiBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fUFJFTE9BREVEX01BUF9fLnNldCh0LCAhMCksIERFRkFVTFRfU0NPUEUgPSBcImRlZmF1bHRcIiwgREVGQVVMVF9SRU1PVEVfVFlQRSA9IFwiZ2xvYmFsXCIsIGJ1aWxkSWRlbnRpZmllciA9IFwiWzAtOUEtWmEtei1dK1wiLCBidWlsZCA9IGAoPzpcXFxcKygke2J1aWxkSWRlbnRpZmllcn0oPzpcXFxcLiR7YnVpbGRJZGVudGlmaWVyfSkqKSlgLCBudW1lcmljSWRlbnRpZmllciA9IFwiMHxbMS05XVxcXFxkKlwiLCBudW1lcmljSWRlbnRpZmllckxvb3NlID0gXCJbMC05XStcIiwgbm9uTnVtZXJpY0lkZW50aWZpZXIgPSBcIlxcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSpcIiwgcHJlUmVsZWFzZUlkZW50aWZpZXJMb29zZSA9IGAoPzoke251bWVyaWNJZGVudGlmaWVyTG9vc2V9fCR7bm9uTnVtZXJpY0lkZW50aWZpZXJ9KWAsIHByZVJlbGVhc2VMb29zZSA9IGAoPzotPygke3ByZVJlbGVhc2VJZGVudGlmaWVyTG9vc2V9KD86XFxcXC4ke3ByZVJlbGVhc2VJZGVudGlmaWVyTG9vc2V9KSopKWAsIHByZVJlbGVhc2VJZGVudGlmaWVyID0gYCg/OiR7bnVtZXJpY0lkZW50aWZpZXJ9fCR7bm9uTnVtZXJpY0lkZW50aWZpZXJ9KWAsIHByZVJlbGVhc2UgPSBgKD86LSgke3ByZVJlbGVhc2VJZGVudGlmaWVyfSg/OlxcXFwuJHtwcmVSZWxlYXNlSWRlbnRpZmllcn0pKikpYCwgeFJhbmdlSWRlbnRpZmllciA9IGAke251bWVyaWNJZGVudGlmaWVyfXx4fFh8XFxcXCpgLCB4UmFuZ2VQbGFpbiA9IGBbdj1cXFxcc10qKCR7eFJhbmdlSWRlbnRpZmllcn0pKD86XFxcXC4oJHt4UmFuZ2VJZGVudGlmaWVyfSkoPzpcXFxcLigke3hSYW5nZUlkZW50aWZpZXJ9KSg/OiR7cHJlUmVsZWFzZX0pPyR7YnVpbGR9Pyk/KT9gLCBoeXBoZW5SYW5nZSA9IGBeXFxcXHMqKCR7eFJhbmdlUGxhaW59KVxcXFxzKy1cXFxccysoJHt4UmFuZ2VQbGFpbn0pXFxcXHMqJGAsIG1haW5WZXJzaW9uTG9vc2UgPSBgKCR7bnVtZXJpY0lkZW50aWZpZXJMb29zZX0pXFxcXC4oJHtudW1lcmljSWRlbnRpZmllckxvb3NlfSlcXFxcLigke251bWVyaWNJZGVudGlmaWVyTG9vc2V9KWAsIGxvb3NlUGxhaW4gPSBgW3Y9XFxcXHNdKiR7bWFpblZlcnNpb25Mb29zZX0ke3ByZVJlbGVhc2VMb29zZX0/JHtidWlsZH0/YCwgZ3RsdCA9IFwiKCg/Ojx8Pik/PT8pXCIsIGNvbXBhcmF0b3JUcmltID0gYChcXFxccyopJHtndGx0fVxcXFxzKigke2xvb3NlUGxhaW59fCR7eFJhbmdlUGxhaW59KWAsIGxvbmVUaWxkZSA9IFwiKD86fj4/KVwiLCB0aWxkZVRyaW0gPSBgKFxcXFxzKikke2xvbmVUaWxkZX1cXFxccytgLCBsb25lQ2FyZXQgPSBcIig/OlxcXFxeKVwiLCBjYXJldFRyaW0gPSBgKFxcXFxzKikke2xvbmVDYXJldH1cXFxccytgLCBzdGFyID0gXCIoPHw+KT89P1xcXFxzKlxcXFwqXCIsIGNhcmV0ID0gYF4ke2xvbmVDYXJldH0ke3hSYW5nZVBsYWlufSRgLCBtYWluVmVyc2lvbiA9IGAoJHtudW1lcmljSWRlbnRpZmllcn0pXFxcXC4oJHtudW1lcmljSWRlbnRpZmllcn0pXFxcXC4oJHtudW1lcmljSWRlbnRpZmllcn0pYCwgZnVsbFBsYWluID0gYHY/JHttYWluVmVyc2lvbn0ke3ByZVJlbGVhc2V9PyR7YnVpbGR9P2AsIHRpbGRlID0gYF4ke2xvbmVUaWxkZX0ke3hSYW5nZVBsYWlufSRgLCB4UmFuZ2UgPSBgXiR7Z3RsdH1cXFxccyoke3hSYW5nZVBsYWlufSRgLCBjb21wYXJhdG9yID0gYF4ke2d0bHR9XFxcXHMqKCR7ZnVsbFBsYWlufSkkfF4kYCwgZ3RlMCA9IFwiXlxcXFxzKj49XFxcXHMqMC4wLjBcXFxccyokXCI7XG5mdW5jdGlvbiBwYXJzZVJlZ2V4KHQpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAodCk7XG59XG5mdW5jdGlvbiBpc1hWZXJzaW9uKHQpIHtcbiAgcmV0dXJuICF0IHx8IHQudG9Mb3dlckNhc2UoKSA9PT0gXCJ4XCIgfHwgdCA9PT0gXCIqXCI7XG59XG5mdW5jdGlvbiBwaXBlKC4uLnQpIHtcbiAgcmV0dXJuIChlKSA9PiB0LnJlZHVjZSgobywgbikgPT4gbihvKSwgZSk7XG59XG5mdW5jdGlvbiBleHRyYWN0Q29tcGFyYXRvcih0KSB7XG4gIHJldHVybiB0Lm1hdGNoKHBhcnNlUmVnZXgoY29tcGFyYXRvcikpO1xufVxuZnVuY3Rpb24gY29tYmluZVZlcnNpb24odCwgZSwgbywgbikge1xuICBjb25zdCByID0gYCR7dH0uJHtlfS4ke299YDtcbiAgcmV0dXJuIG4gPyBgJHtyfS0ke259YCA6IHI7XG59XG5mdW5jdGlvbiBwYXJzZUh5cGhlbih0KSB7XG4gIHJldHVybiB0LnJlcGxhY2UocGFyc2VSZWdleChoeXBoZW5SYW5nZSksIChlLCBvLCBuLCByLCBpLCBhLCBzLCBjLCBsLCB1LCBoLCBnKSA9PiAoaXNYVmVyc2lvbihuKSA/IG8gPSBcIlwiIDogaXNYVmVyc2lvbihyKSA/IG8gPSBgPj0ke259LjAuMGAgOiBpc1hWZXJzaW9uKGkpID8gbyA9IGA+PSR7bn0uJHtyfS4wYCA6IG8gPSBgPj0ke299YCwgaXNYVmVyc2lvbihsKSA/IGMgPSBcIlwiIDogaXNYVmVyc2lvbih1KSA/IGMgPSBgPCR7TnVtYmVyKGwpICsgMX0uMC4wLTBgIDogaXNYVmVyc2lvbihoKSA/IGMgPSBgPCR7bH0uJHtOdW1iZXIodSkgKyAxfS4wLTBgIDogZyA/IGMgPSBgPD0ke2x9LiR7dX0uJHtofS0ke2d9YCA6IGMgPSBgPD0ke2N9YCwgYCR7b30gJHtjfWAudHJpbSgpKSk7XG59XG5mdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3JUcmltKHQpIHtcbiAgcmV0dXJuIHQucmVwbGFjZShwYXJzZVJlZ2V4KGNvbXBhcmF0b3JUcmltKSwgXCIkMSQyJDNcIik7XG59XG5mdW5jdGlvbiBwYXJzZVRpbGRlVHJpbSh0KSB7XG4gIHJldHVybiB0LnJlcGxhY2UocGFyc2VSZWdleCh0aWxkZVRyaW0pLCBcIiQxflwiKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FyZXRUcmltKHQpIHtcbiAgcmV0dXJuIHQucmVwbGFjZShwYXJzZVJlZ2V4KGNhcmV0VHJpbSksIFwiJDFeXCIpO1xufVxuZnVuY3Rpb24gcGFyc2VDYXJldHModCkge1xuICByZXR1cm4gdC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoKGUpID0+IGUucmVwbGFjZShwYXJzZVJlZ2V4KGNhcmV0KSwgKG8sIG4sIHIsIGksIGEpID0+IGlzWFZlcnNpb24obikgPyBcIlwiIDogaXNYVmVyc2lvbihyKSA/IGA+PSR7bn0uMC4wIDwke051bWJlcihuKSArIDF9LjAuMC0wYCA6IGlzWFZlcnNpb24oaSkgPyBuID09PSBcIjBcIiA/IGA+PSR7bn0uJHtyfS4wIDwke259LiR7TnVtYmVyKHIpICsgMX0uMC0wYCA6IGA+PSR7bn0uJHtyfS4wIDwke051bWJlcihuKSArIDF9LjAuMC0wYCA6IGEgPyBuID09PSBcIjBcIiA/IHIgPT09IFwiMFwiID8gYD49JHtufS4ke3J9LiR7aX0tJHthfSA8JHtufS4ke3J9LiR7TnVtYmVyKGkpICsgMX0tMGAgOiBgPj0ke259LiR7cn0uJHtpfS0ke2F9IDwke259LiR7TnVtYmVyKHIpICsgMX0uMC0wYCA6IGA+PSR7bn0uJHtyfS4ke2l9LSR7YX0gPCR7TnVtYmVyKG4pICsgMX0uMC4wLTBgIDogbiA9PT0gXCIwXCIgPyByID09PSBcIjBcIiA/IGA+PSR7bn0uJHtyfS4ke2l9IDwke259LiR7cn0uJHtOdW1iZXIoaSkgKyAxfS0wYCA6IGA+PSR7bn0uJHtyfS4ke2l9IDwke259LiR7TnVtYmVyKHIpICsgMX0uMC0wYCA6IGA+PSR7bn0uJHtyfS4ke2l9IDwke051bWJlcihuKSArIDF9LjAuMC0wYCkpLmpvaW4oXCIgXCIpO1xufVxuZnVuY3Rpb24gcGFyc2VUaWxkZXModCkge1xuICByZXR1cm4gdC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoKGUpID0+IGUucmVwbGFjZShwYXJzZVJlZ2V4KHRpbGRlKSwgKG8sIG4sIHIsIGksIGEpID0+IGlzWFZlcnNpb24obikgPyBcIlwiIDogaXNYVmVyc2lvbihyKSA/IGA+PSR7bn0uMC4wIDwke051bWJlcihuKSArIDF9LjAuMC0wYCA6IGlzWFZlcnNpb24oaSkgPyBgPj0ke259LiR7cn0uMCA8JHtufS4ke051bWJlcihyKSArIDF9LjAtMGAgOiBhID8gYD49JHtufS4ke3J9LiR7aX0tJHthfSA8JHtufS4ke051bWJlcihyKSArIDF9LjAtMGAgOiBgPj0ke259LiR7cn0uJHtpfSA8JHtufS4ke051bWJlcihyKSArIDF9LjAtMGApKS5qb2luKFwiIFwiKTtcbn1cbmZ1bmN0aW9uIHBhcnNlWFJhbmdlcyh0KSB7XG4gIHJldHVybiB0LnNwbGl0KC9cXHMrLykubWFwKChlKSA9PiBlLnRyaW0oKS5yZXBsYWNlKHBhcnNlUmVnZXgoeFJhbmdlKSwgKG8sIG4sIHIsIGksIGEsIHMpID0+IHtcbiAgICBjb25zdCBjID0gaXNYVmVyc2lvbihyKSwgbCA9IGMgfHwgaXNYVmVyc2lvbihpKSwgdSA9IGwgfHwgaXNYVmVyc2lvbihhKTtcbiAgICByZXR1cm4gbiA9PT0gXCI9XCIgJiYgdSAmJiAobiA9IFwiXCIpLCBzID0gXCJcIiwgYyA/IG4gPT09IFwiPlwiIHx8IG4gPT09IFwiPFwiID8gXCI8MC4wLjAtMFwiIDogXCIqXCIgOiBuICYmIHUgPyAobCAmJiAoaSA9IDApLCBhID0gMCwgbiA9PT0gXCI+XCIgPyAobiA9IFwiPj1cIiwgbCA/IChyID0gTnVtYmVyKHIpICsgMSwgaSA9IDAsIGEgPSAwKSA6IChpID0gTnVtYmVyKGkpICsgMSwgYSA9IDApKSA6IG4gPT09IFwiPD1cIiAmJiAobiA9IFwiPFwiLCBsID8gciA9IE51bWJlcihyKSArIDEgOiBpID0gTnVtYmVyKGkpICsgMSksIG4gPT09IFwiPFwiICYmIChzID0gXCItMFwiKSwgYCR7biArIHJ9LiR7aX0uJHthfSR7c31gKSA6IGwgPyBgPj0ke3J9LjAuMCR7c30gPCR7TnVtYmVyKHIpICsgMX0uMC4wLTBgIDogdSA/IGA+PSR7cn0uJHtpfS4wJHtzfSA8JHtyfS4ke051bWJlcihpKSArIDF9LjAtMGAgOiBvO1xuICB9KSkuam9pbihcIiBcIik7XG59XG5mdW5jdGlvbiBwYXJzZVN0YXIodCkge1xuICByZXR1cm4gdC50cmltKCkucmVwbGFjZShwYXJzZVJlZ2V4KHN0YXIpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHBhcnNlR1RFMCh0KSB7XG4gIHJldHVybiB0LnRyaW0oKS5yZXBsYWNlKHBhcnNlUmVnZXgoZ3RlMCksIFwiXCIpO1xufVxuZnVuY3Rpb24gY29tcGFyZUF0b20odCwgZSkge1xuICByZXR1cm4gdCA9IE51bWJlcih0KSB8fCB0LCBlID0gTnVtYmVyKGUpIHx8IGUsIHQgPiBlID8gMSA6IHQgPT09IGUgPyAwIDogLTE7XG59XG5mdW5jdGlvbiBjb21wYXJlUHJlUmVsZWFzZSh0LCBlKSB7XG4gIGNvbnN0IHsgcHJlUmVsZWFzZTogbyB9ID0gdCwgeyBwcmVSZWxlYXNlOiBuIH0gPSBlO1xuICBpZiAobyA9PT0gdm9pZCAwICYmIG4pXG4gICAgcmV0dXJuIDE7XG4gIGlmIChvICYmIG4gPT09IHZvaWQgMClcbiAgICByZXR1cm4gLTE7XG4gIGlmIChvID09PSB2b2lkIDAgJiYgbiA9PT0gdm9pZCAwKVxuICAgIHJldHVybiAwO1xuICBmb3IgKGxldCByID0gMCwgaSA9IG8ubGVuZ3RoOyByIDw9IGk7IHIrKykge1xuICAgIGNvbnN0IGEgPSBvW3JdLCBzID0gbltyXTtcbiAgICBpZiAoYSAhPT0gcylcbiAgICAgIHJldHVybiBhID09PSB2b2lkIDAgJiYgcyA9PT0gdm9pZCAwID8gMCA6IGEgPyBzID8gY29tcGFyZUF0b20oYSwgcykgOiAtMSA6IDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjb21wYXJlVmVyc2lvbih0LCBlKSB7XG4gIHJldHVybiBjb21wYXJlQXRvbSh0Lm1ham9yLCBlLm1ham9yKSB8fCBjb21wYXJlQXRvbSh0Lm1pbm9yLCBlLm1pbm9yKSB8fCBjb21wYXJlQXRvbSh0LnBhdGNoLCBlLnBhdGNoKSB8fCBjb21wYXJlUHJlUmVsZWFzZSh0LCBlKTtcbn1cbmZ1bmN0aW9uIGVxKHQsIGUpIHtcbiAgcmV0dXJuIHQudmVyc2lvbiA9PT0gZS52ZXJzaW9uO1xufVxuZnVuY3Rpb24gY29tcGFyZSh0LCBlKSB7XG4gIHN3aXRjaCAodC5vcGVyYXRvcikge1xuICAgIGNhc2UgXCJcIjpcbiAgICBjYXNlIFwiPVwiOlxuICAgICAgcmV0dXJuIGVxKHQsIGUpO1xuICAgIGNhc2UgXCI+XCI6XG4gICAgICByZXR1cm4gY29tcGFyZVZlcnNpb24odCwgZSkgPCAwO1xuICAgIGNhc2UgXCI+PVwiOlxuICAgICAgcmV0dXJuIGVxKHQsIGUpIHx8IGNvbXBhcmVWZXJzaW9uKHQsIGUpIDwgMDtcbiAgICBjYXNlIFwiPFwiOlxuICAgICAgcmV0dXJuIGNvbXBhcmVWZXJzaW9uKHQsIGUpID4gMDtcbiAgICBjYXNlIFwiPD1cIjpcbiAgICAgIHJldHVybiBlcSh0LCBlKSB8fCBjb21wYXJlVmVyc2lvbih0LCBlKSA+IDA7XG4gICAgY2FzZSB2b2lkIDA6XG4gICAgICByZXR1cm4gITA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VDb21wYXJhdG9yU3RyaW5nKHQpIHtcbiAgcmV0dXJuIHBpcGUoXG4gICAgcGFyc2VDYXJldHMsXG4gICAgcGFyc2VUaWxkZXMsXG4gICAgcGFyc2VYUmFuZ2VzLFxuICAgIHBhcnNlU3RhclxuICApKHQpO1xufVxuZnVuY3Rpb24gcGFyc2VSYW5nZSh0KSB7XG4gIHJldHVybiBwaXBlKFxuICAgIHBhcnNlSHlwaGVuLFxuICAgIHBhcnNlQ29tcGFyYXRvclRyaW0sXG4gICAgcGFyc2VUaWxkZVRyaW0sXG4gICAgcGFyc2VDYXJldFRyaW1cbiAgKSh0LnRyaW0oKSkuc3BsaXQoL1xccysvKS5qb2luKFwiIFwiKTtcbn1cbmZ1bmN0aW9uIHNhdGlzZnkodCwgZSkge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBvID0gcGFyc2VSYW5nZShlKS5zcGxpdChcIiBcIikubWFwKCh1KSA9PiBwYXJzZUNvbXBhcmF0b3JTdHJpbmcodSkpLmpvaW4oXCIgXCIpLnNwbGl0KC9cXHMrLykubWFwKCh1KSA9PiBwYXJzZUdURTAodSkpLCBuID0gZXh0cmFjdENvbXBhcmF0b3IodCk7XG4gIGlmICghbilcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IFssIHIsICwgaSwgYSwgcywgY10gPSBuLCBsID0ge1xuICAgIG9wZXJhdG9yOiByLFxuICAgIHZlcnNpb246IGNvbWJpbmVWZXJzaW9uKGksIGEsIHMsIGMpLFxuICAgIG1ham9yOiBpLFxuICAgIG1pbm9yOiBhLFxuICAgIHBhdGNoOiBzLFxuICAgIHByZVJlbGVhc2U6IGM/LnNwbGl0KFwiLlwiKVxuICB9O1xuICBmb3IgKGNvbnN0IHUgb2Ygbykge1xuICAgIGNvbnN0IGggPSBleHRyYWN0Q29tcGFyYXRvcih1KTtcbiAgICBpZiAoIWgpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgWywgZywgLCBwLCBkLCBtLCBNXSA9IGgsIEkgPSB7XG4gICAgICBvcGVyYXRvcjogZyxcbiAgICAgIHZlcnNpb246IGNvbWJpbmVWZXJzaW9uKHAsIGQsIG0sIE0pLFxuICAgICAgbWFqb3I6IHAsXG4gICAgICBtaW5vcjogZCxcbiAgICAgIHBhdGNoOiBtLFxuICAgICAgcHJlUmVsZWFzZTogTT8uc3BsaXQoXCIuXCIpXG4gICAgfTtcbiAgICBpZiAoIWNvbXBhcmUoSSwgbCkpXG4gICAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gX2V4dGVuZHMkNigpIHtcbiAgcmV0dXJuIF9leHRlbmRzJDYgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlID0gMTsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIG8gPSBhcmd1bWVudHNbZV07XG4gICAgICBmb3IgKHZhciBuIGluIG8pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBuKSAmJiAodFtuXSA9IG9bbl0pO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfSwgX2V4dGVuZHMkNi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gZm9ybWF0U2hhcmUodCwgZSkge1xuICBsZXQgbztcbiAgcmV0dXJuIFwiZ2V0XCIgaW4gdCA/IG8gPSB0LmdldCA6IG8gPSAoKSA9PiBQcm9taXNlLnJlc29sdmUodC5saWIpLCBfZXh0ZW5kcyQ2KHtcbiAgICBkZXBzOiBbXSxcbiAgICB1c2VJbjogW10sXG4gICAgZnJvbTogZSxcbiAgICBsb2FkaW5nOiBudWxsXG4gIH0sIHQsIHtcbiAgICBzaGFyZUNvbmZpZzogX2V4dGVuZHMkNih7XG4gICAgICByZXF1aXJlZFZlcnNpb246IGBeJHt0LnZlcnNpb259YCxcbiAgICAgIHNpbmdsZXRvbjogITEsXG4gICAgICBlYWdlcjogITEsXG4gICAgICBzdHJpY3RWZXJzaW9uOiAhMVxuICAgIH0sIHQuc2hhcmVDb25maWcpLFxuICAgIGdldDogbyxcbiAgICBsb2FkZWQ6IFwibGliXCIgaW4gdCA/ICEwIDogdm9pZCAwLFxuICAgIHNjb3BlOiBBcnJheS5pc0FycmF5KHQuc2NvcGUpID8gdC5zY29wZSA6IFtcbiAgICAgIFwiZGVmYXVsdFwiXG4gICAgXSxcbiAgICBzdHJhdGVneTogdC5zdHJhdGVneSB8fCBcInZlcnNpb24tZmlyc3RcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNoYXJlQ29uZmlncyh0LCBlKSB7XG4gIHJldHVybiB0ID8gT2JqZWN0LmtleXModCkucmVkdWNlKChvLCBuKSA9PiAob1tuXSA9IGZvcm1hdFNoYXJlKHRbbl0sIGUpLCBvKSwge30pIDoge307XG59XG5mdW5jdGlvbiB2ZXJzaW9uTHQodCwgZSkge1xuICBjb25zdCBvID0gKG4pID0+IHtcbiAgICBpZiAoIU51bWJlci5pc05hTihOdW1iZXIobikpKSB7XG4gICAgICBjb25zdCByID0gbi5zcGxpdChcIi5cIik7XG4gICAgICBsZXQgaSA9IG47XG4gICAgICBmb3IgKGxldCBhID0gMDsgYSA8IDMgLSByLmxlbmd0aDsgYSsrKVxuICAgICAgICBpICs9IFwiLjBcIjtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfTtcbiAgcmV0dXJuICEhc2F0aXNmeShvKHQpLCBgPD0ke28oZSl9YCk7XG59XG5jb25zdCBmaW5kVmVyc2lvbiA9ICh0LCBlLCBvLCBuKSA9PiB7XG4gIGNvbnN0IHIgPSB0W2VdW29dLCBpID0gbiB8fCBmdW5jdGlvbihhLCBzKSB7XG4gICAgcmV0dXJuIHZlcnNpb25MdChhLCBzKTtcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHIpLnJlZHVjZSgoYSwgcykgPT4gIWEgfHwgaShhLCBzKSB8fCBhID09PSBcIjBcIiA/IHMgOiBhLCAwKTtcbn0sIGlzTG9hZGVkID0gKHQpID0+ICEhdC5sb2FkZWQgfHwgdHlwZW9mIHQubGliID09IFwiZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIGZpbmRTaW5nbGV0b25WZXJzaW9uT3JkZXJCeVZlcnNpb24odCwgZSwgbykge1xuICBjb25zdCBuID0gdFtlXVtvXTtcbiAgcmV0dXJuIGZpbmRWZXJzaW9uKHQsIGUsIG8sIGZ1bmN0aW9uKHIsIGkpIHtcbiAgICByZXR1cm4gIWlzTG9hZGVkKG5bcl0pICYmIHZlcnNpb25MdChyLCBpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmaW5kU2luZ2xldG9uVmVyc2lvbk9yZGVyQnlMb2FkZWQodCwgZSwgbykge1xuICBjb25zdCBuID0gdFtlXVtvXTtcbiAgcmV0dXJuIGZpbmRWZXJzaW9uKHQsIGUsIG8sIGZ1bmN0aW9uKHIsIGkpIHtcbiAgICByZXR1cm4gaXNMb2FkZWQobltpXSkgPyBpc0xvYWRlZChuW3JdKSA/ICEhdmVyc2lvbkx0KHIsIGkpIDogITAgOiBpc0xvYWRlZChuW3JdKSA/ICExIDogdmVyc2lvbkx0KHIsIGkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZpbmRTaGFyZUZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQgPT09IFwibG9hZGVkLWZpcnN0XCIgPyBmaW5kU2luZ2xldG9uVmVyc2lvbk9yZGVyQnlMb2FkZWQgOiBmaW5kU2luZ2xldG9uVmVyc2lvbk9yZGVyQnlWZXJzaW9uO1xufVxuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZFNoYXJlKHQsIGUsIG8sIG4pIHtcbiAgaWYgKCF0KVxuICAgIHJldHVybjtcbiAgY29uc3QgeyBzaGFyZUNvbmZpZzogciwgc2NvcGU6IGkgPSBERUZBVUxUX1NDT1BFLCBzdHJhdGVneTogYSB9ID0gbywgcyA9IEFycmF5LmlzQXJyYXkoaSkgPyBpIDogW1xuICAgIGlcbiAgXTtcbiAgZm9yIChjb25zdCBjIG9mIHMpXG4gICAgaWYgKHIgJiYgdFtjXSAmJiB0W2NdW2VdKSB7XG4gICAgICBjb25zdCB7IHJlcXVpcmVkVmVyc2lvbjogbCB9ID0gciwgdSA9IGdldEZpbmRTaGFyZUZ1bmN0aW9uKGEpKHQsIGMsIGUpLCBoID0gKCkgPT4ge1xuICAgICAgICBpZiAoci5zaW5nbGV0b24pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGwgPT0gXCJzdHJpbmdcIiAmJiAhc2F0aXNmeSh1LCBsKSkge1xuICAgICAgICAgICAgY29uc3QgcCA9IGBWZXJzaW9uICR7dX0gZnJvbSAke3UgJiYgdFtjXVtlXVt1XS5mcm9tfSBvZiBzaGFyZWQgc2luZ2xldG9uIG1vZHVsZSAke2V9IGRvZXMgbm90IHNhdGlzZnkgdGhlIHJlcXVpcmVtZW50IG9mICR7by5mcm9tfSB3aGljaCBuZWVkcyAke2x9KWA7XG4gICAgICAgICAgICByLnN0cmljdFZlcnNpb24gPyBlcnJvcihwKSA6IHdhcm4kMShwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRbY11bZV1bdV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGwgPT09ICExIHx8IGwgPT09IFwiKlwiIHx8IHNhdGlzZnkodSwgbCkpXG4gICAgICAgICAgICByZXR1cm4gdFtjXVtlXVt1XTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtwLCBkXSBvZiBPYmplY3QuZW50cmllcyh0W2NdW2VdKSlcbiAgICAgICAgICAgIGlmIChzYXRpc2Z5KHAsIGwpKVxuICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgICAgfSwgZyA9IHtcbiAgICAgICAgc2hhcmVTY29wZU1hcDogdCxcbiAgICAgICAgc2NvcGU6IGMsXG4gICAgICAgIHBrZ05hbWU6IGUsXG4gICAgICAgIHZlcnNpb246IHUsXG4gICAgICAgIEdsb2JhbEZlZGVyYXRpb246IEdsb2JhbC5fX0ZFREVSQVRJT05fXyxcbiAgICAgICAgcmVzb2x2ZXI6IGhcbiAgICAgIH07XG4gICAgICByZXR1cm4gKG4uZW1pdChnKSB8fCBnKS5yZXNvbHZlcigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEdsb2JhbFNoYXJlU2NvcGUoKSB7XG4gIHJldHVybiBHbG9iYWwuX19GRURFUkFUSU9OX18uX19TSEFSRV9fO1xufVxuZnVuY3Rpb24gX2RlZmluZV9wcm9wZXJ0eSQzKHQsIGUsIG8pIHtcbiAgcmV0dXJuIGUgaW4gdCA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBlLCB7XG4gICAgdmFsdWU6IG8sXG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICB3cml0YWJsZTogITBcbiAgfSkgOiB0W2VdID0gbywgdDtcbn1cbnZhciBNQU5JRkVTVF9FWFQgPSBcIi5qc29uXCIsIEJST1dTRVJfTE9HX0tFWSA9IFwiRkVERVJBVElPTl9ERUJVR1wiLCBCUk9XU0VSX0xPR19WQUxVRSA9IFwiMVwiLCBOYW1lVHJhbnNmb3JtU3ltYm9sID0ge1xuICBBVDogXCJAXCIsXG4gIEhZUEhFTjogXCItXCIsXG4gIFNMQVNIOiBcIi9cIlxufSwgX29iaiwgTmFtZVRyYW5zZm9ybU1hcCA9IChfb2JqID0ge30sIF9kZWZpbmVfcHJvcGVydHkkMyhfb2JqLCBOYW1lVHJhbnNmb3JtU3ltYm9sLkFULCBcInNjb3BlX1wiKSwgX2RlZmluZV9wcm9wZXJ0eSQzKF9vYmosIE5hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOLCBcIl9cIiksIF9kZWZpbmVfcHJvcGVydHkkMyhfb2JqLCBOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNILCBcIl9fXCIpLCBfb2JqKSwgX29iajE7XG5fb2JqMSA9IHt9LCBfZGVmaW5lX3Byb3BlcnR5JDMoX29iajEsIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF0sIE5hbWVUcmFuc2Zvcm1TeW1ib2wuQVQpLCBfZGVmaW5lX3Byb3BlcnR5JDMoX29iajEsIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU5dLCBOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTiksIF9kZWZpbmVfcHJvcGVydHkkMyhfb2JqMSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXSwgTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSCk7XG52YXIgU0VQQVJBVE9SID0gXCI6XCI7XG5mdW5jdGlvbiBpc0Jyb3dzZXJFbnYoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93IDwgXCJ1XCI7XG59XG5mdW5jdGlvbiBpc0RlYnVnTW9kZSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzIDwgXCJ1XCIgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuRkVERVJBVElPTl9ERUJVRyA/ICEhcHJvY2Vzcy5lbnYuRkVERVJBVElPTl9ERUJVRyA6IHR5cGVvZiBGRURFUkFUSU9OX0RFQlVHIDwgXCJ1XCIgJiYgISFGRURFUkFUSU9OX0RFQlVHO1xufVxuZnVuY3Rpb24gX2FycmF5X2xpa2VfdG9fYXJyYXkkMih0LCBlKSB7XG4gIChlID09IG51bGwgfHwgZSA+IHQubGVuZ3RoKSAmJiAoZSA9IHQubGVuZ3RoKTtcbiAgZm9yICh2YXIgbyA9IDAsIG4gPSBuZXcgQXJyYXkoZSk7IG8gPCBlOyBvKyspXG4gICAgbltvXSA9IHRbb107XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gX2FycmF5X3dpdGhvdXRfaG9sZXModCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0KSlcbiAgICByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkkMih0KTtcbn1cbmZ1bmN0aW9uIF9jbGFzc19jYWxsX2NoZWNrKHQsIGUpIHtcbiAgaWYgKCEodCBpbnN0YW5jZW9mIGUpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0LCBlKSB7XG4gIGZvciAodmFyIG8gPSAwOyBvIDwgZS5sZW5ndGg7IG8rKykge1xuICAgIHZhciBuID0gZVtvXTtcbiAgICBuLmVudW1lcmFibGUgPSBuLmVudW1lcmFibGUgfHwgITEsIG4uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBuICYmIChuLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgbi5rZXksIG4pO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlX2NsYXNzKHQsIGUsIG8pIHtcbiAgcmV0dXJuIGUgJiYgX2RlZmluZVByb3BlcnRpZXModC5wcm90b3R5cGUsIGUpLCBvICYmIF9kZWZpbmVQcm9wZXJ0aWVzKHQsIG8pLCB0O1xufVxuZnVuY3Rpb24gX2RlZmluZV9wcm9wZXJ0eSQyKHQsIGUsIG8pIHtcbiAgcmV0dXJuIGUgaW4gdCA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBlLCB7XG4gICAgdmFsdWU6IG8sXG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICB3cml0YWJsZTogITBcbiAgfSkgOiB0W2VdID0gbywgdDtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZV90b19hcnJheSQxKHQpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiB0W1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCB0W1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKVxuICAgIHJldHVybiBBcnJheS5mcm9tKHQpO1xufVxuZnVuY3Rpb24gX25vbl9pdGVyYWJsZV9zcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfdG9fY29uc3VtYWJsZV9hcnJheSh0KSB7XG4gIHJldHVybiBfYXJyYXlfd2l0aG91dF9ob2xlcyh0KSB8fCBfaXRlcmFibGVfdG9fYXJyYXkkMSh0KSB8fCBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkkMih0KSB8fCBfbm9uX2l0ZXJhYmxlX3NwcmVhZCgpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5JDIodCwgZSkge1xuICBpZiAodCkge1xuICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5JDIodCwgZSk7XG4gICAgdmFyIG8gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChvID09PSBcIk9iamVjdFwiICYmIHQuY29uc3RydWN0b3IgJiYgKG8gPSB0LmNvbnN0cnVjdG9yLm5hbWUpLCBvID09PSBcIk1hcFwiIHx8IG8gPT09IFwiU2V0XCIpXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgICBpZiAobyA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChvKSlcbiAgICAgIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheSQyKHQsIGUpO1xuICB9XG59XG5mdW5jdGlvbiBzYWZlVG9TdHJpbmcodCkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0LCBudWxsLCAyKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbn1cbnZhciBERUJVR19MT0cgPSBcIlsgRkVERVJBVElPTiBERUJVRyBdXCI7XG5mdW5jdGlvbiBzYWZlR2V0TG9jYWxTdG9yYWdlSXRlbSgpIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpXG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQlJPV1NFUl9MT0dfS0VZKSA9PT0gQlJPV1NFUl9MT0dfVkFMVUU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIjtcbiAgfVxuICByZXR1cm4gITE7XG59XG52YXIgTG9nZ2VyID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiB0KGUpIHtcbiAgICBfY2xhc3NfY2FsbF9jaGVjayh0aGlzLCB0KSwgX2RlZmluZV9wcm9wZXJ0eSQyKHRoaXMsIFwiZW5hYmxlXCIsICExKSwgX2RlZmluZV9wcm9wZXJ0eSQyKHRoaXMsIFwiaWRlbnRpZmllclwiLCB2b2lkIDApLCB0aGlzLmlkZW50aWZpZXIgPSBlIHx8IERFQlVHX0xPRywgaXNCcm93c2VyRW52KCkgJiYgc2FmZUdldExvY2FsU3RvcmFnZUl0ZW0oKSA/IHRoaXMuZW5hYmxlID0gITAgOiBpc0RlYnVnTW9kZSgpICYmICh0aGlzLmVuYWJsZSA9ICEwKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZV9jbGFzcyh0LCBbXG4gICAge1xuICAgICAga2V5OiBcImluZm9cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihlLCBvKSB7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZSkge1xuICAgICAgICAgIHZhciBuID0gc2FmZVRvU3RyaW5nKG8pIHx8IFwiXCI7XG4gICAgICAgICAgaXNCcm93c2VyRW52KCkgPyBjb25zb2xlLmluZm8oXCIlYyBcIi5jb25jYXQodGhpcy5pZGVudGlmaWVyLCBcIjogXCIpLmNvbmNhdChlLCBcIiBcIikuY29uY2F0KG4pLCBcImNvbG9yOiMzMzAwQ0NcIikgOiBjb25zb2xlLmluZm8oXCJcXHgxQlszNG0lc1wiLCBcIlwiLmNvbmNhdCh0aGlzLmlkZW50aWZpZXIsIFwiOiBcIikuY29uY2F0KGUsIFwiIFwiKS5jb25jYXQobiA/IGBcbmAuY29uY2F0KG4pIDogXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBrZXk6IFwibG9nT3JpZ2luYWxJbmZvXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoLCBvID0gbmV3IEFycmF5KGUpLCBuID0gMDsgbiA8IGU7IG4rKylcbiAgICAgICAgICBvW25dID0gYXJndW1lbnRzW25dO1xuICAgICAgICBpZiAodGhpcy5lbmFibGUpXG4gICAgICAgICAgaWYgKGlzQnJvd3NlckVudigpKSB7XG4gICAgICAgICAgICB2YXIgcjtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIiVjIFwiLmNvbmNhdCh0aGlzLmlkZW50aWZpZXIsIFwiOiBPcmlnaW5hbEluZm9cIiksIFwiY29sb3I6IzMzMDBDQ1wiKSwgKHIgPSBjb25zb2xlKS5sb2cuYXBwbHkociwgX3RvX2NvbnN1bWFibGVfYXJyYXkobykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIiVjIFwiLmNvbmNhdCh0aGlzLmlkZW50aWZpZXIsIFwiOiBPcmlnaW5hbEluZm9cIiksIFwiY29sb3I6IzMzMDBDQ1wiKSwgKGkgPSBjb25zb2xlKS5sb2cuYXBwbHkoaSwgX3RvX2NvbnN1bWFibGVfYXJyYXkobykpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIF0pLCB0O1xufSgpLCBMT0dfQ0FURUdPUlkgPSBcIlsgRmVkZXJhdGlvbiBSdW50aW1lIF1cIjtcbm5ldyBMb2dnZXIoKTtcbnZhciBjb21wb3NlS2V5V2l0aFNlcGFyYXRvciA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCwgZSA9IG5ldyBBcnJheSh0KSwgbyA9IDA7IG8gPCB0OyBvKyspXG4gICAgZVtvXSA9IGFyZ3VtZW50c1tvXTtcbiAgcmV0dXJuIGUubGVuZ3RoID8gZS5yZWR1Y2UoZnVuY3Rpb24obiwgcikge1xuICAgIHJldHVybiByID8gbiA/IFwiXCIuY29uY2F0KG4pLmNvbmNhdChTRVBBUkFUT1IpLmNvbmNhdChyKSA6IHIgOiBuO1xuICB9LCBcIlwiKSA6IFwiXCI7XG59LCBnZXRSZXNvdXJjZVVybCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgaWYgKFwiZ2V0UHVibGljUGF0aFwiIGluIHQpIHtcbiAgICB2YXIgbyA9IG5ldyBGdW5jdGlvbih0LmdldFB1YmxpY1BhdGgpKCk7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KG8pLmNvbmNhdChlKTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIFwicHVibGljUGF0aFwiIGluIHQgPyBcIlwiLmNvbmNhdCh0LnB1YmxpY1BhdGgpLmNvbmNhdChlKSA6IChjb25zb2xlLndhcm4oXCJDYW4gbm90IGdldCByZXNvdXJjZSB1cmwsIGlmIGluIGRlYnVnIG1vZGUsIHBsZWFzZSBpZ25vcmVcIiwgdCwgZSksIFwiXCIpO1xufSwgd2FybiA9IGZ1bmN0aW9uKHQpIHtcbiAgY29uc29sZS53YXJuKFwiXCIuY29uY2F0KExPR19DQVRFR09SWSwgXCI6IFwiKS5jb25jYXQodCkpO1xufTtcbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkkMSh0LCBlLCBvKSB7XG4gIHJldHVybiBlIGluIHQgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgZSwge1xuICAgIHZhbHVlOiBvLFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pIDogdFtlXSA9IG8sIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0X3NwcmVhZCQxKHQpIHtcbiAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgbyA9IGFyZ3VtZW50c1tlXSAhPSBudWxsID8gYXJndW1lbnRzW2VdIDoge30sIG4gPSBPYmplY3Qua2V5cyhvKTtcbiAgICB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PSBcImZ1bmN0aW9uXCIgJiYgKG4gPSBuLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG8pLmZpbHRlcihmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSksIG4uZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBfZGVmaW5lX3Byb3BlcnR5JDEodCwgciwgb1tyXSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBvd25LZXlzKHQsIGUpIHtcbiAgdmFyIG8gPSBPYmplY3Qua2V5cyh0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCk7XG4gICAgZSAmJiAobiA9IG4uZmlsdGVyKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCBvLnB1c2guYXBwbHkobywgbik7XG4gIH1cbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBfb2JqZWN0X3NwcmVhZF9wcm9wcyh0LCBlKSB7XG4gIHJldHVybiBlID0gZSA/PyB7fSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhlKSkgOiBvd25LZXlzKE9iamVjdChlKSkuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIG8sIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgbykpO1xuICB9KSwgdDtcbn1cbnZhciBzaW1wbGVKb2luUmVtb3RlRW50cnkgPSBmdW5jdGlvbih0LCBlKSB7XG4gIGlmICghdClcbiAgICByZXR1cm4gZTtcbiAgdmFyIG8gPSBmdW5jdGlvbihyKSB7XG4gICAgaWYgKHIgPT09IFwiLlwiKVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgaWYgKHIuc3RhcnRzV2l0aChcIi4vXCIpKVxuICAgICAgcmV0dXJuIHIucmVwbGFjZShcIi4vXCIsIFwiXCIpO1xuICAgIGlmIChyLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICB2YXIgaSA9IHIuc2xpY2UoMSk7XG4gICAgICByZXR1cm4gaS5lbmRzV2l0aChcIi9cIikgPyBpLnNsaWNlKDAsIC0xKSA6IGk7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9LCBuID0gbyh0KTtcbiAgcmV0dXJuIG4gPyBuLmVuZHNXaXRoKFwiL1wiKSA/IFwiXCIuY29uY2F0KG4pLmNvbmNhdChlKSA6IFwiXCIuY29uY2F0KG4sIFwiL1wiKS5jb25jYXQoZSkgOiBlO1xufTtcbmZ1bmN0aW9uIGdlbmVyYXRlU25hcHNob3RGcm9tTWFuaWZlc3QodCkge1xuICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge30sIG8sIG4sIHIgPSBlLnJlbW90ZXMsIGkgPSByID09PSB2b2lkIDAgPyB7fSA6IHIsIGEgPSBlLm92ZXJyaWRlcywgcyA9IGEgPT09IHZvaWQgMCA/IHt9IDogYSwgYyA9IGUudmVyc2lvbiwgbCwgdSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcInB1YmxpY1BhdGhcIiBpbiB0Lm1ldGFEYXRhID8gdC5tZXRhRGF0YS5wdWJsaWNQYXRoIDogdC5tZXRhRGF0YS5nZXRQdWJsaWNQYXRoO1xuICB9LCBoID0gT2JqZWN0LmtleXMocyksIGcgPSB7fTtcbiAgaWYgKCFPYmplY3Qua2V5cyhpKS5sZW5ndGgpIHtcbiAgICB2YXIgcDtcbiAgICBnID0gKChwID0gdC5yZW1vdGVzKSA9PT0gbnVsbCB8fCBwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwLnJlZHVjZShmdW5jdGlvbih3LCBSKSB7XG4gICAgICB2YXIgVSwgVyA9IFIuZmVkZXJhdGlvbkNvbnRhaW5lck5hbWU7XG4gICAgICByZXR1cm4gaC5pbmNsdWRlcyhXKSA/IFUgPSBzW1ddIDogXCJ2ZXJzaW9uXCIgaW4gUiA/IFUgPSBSLnZlcnNpb24gOiBVID0gUi5lbnRyeSwgd1tXXSA9IHtcbiAgICAgICAgbWF0Y2hlZFZlcnNpb246IFVcbiAgICAgIH0sIHc7XG4gICAgfSwge30pKSB8fCB7fTtcbiAgfVxuICBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcbiAgICByZXR1cm4gZ1t3XSA9IHtcbiAgICAgIG1hdGNoZWRWZXJzaW9uOiBoLmluY2x1ZGVzKHcpID8gc1t3XSA6IGlbd11cbiAgICB9O1xuICB9KTtcbiAgdmFyIGQgPSB0Lm1ldGFEYXRhLCBtID0gZC5yZW1vdGVFbnRyeSwgTSA9IG0ucGF0aCwgSSA9IG0ubmFtZSwgRCA9IG0udHlwZSwgUyA9IGQudHlwZXMsIE8gPSBkLmJ1aWxkSW5mby5idWlsZFZlcnNpb24sIEwgPSBkLmdsb2JhbE5hbWUsIHYgPSB0LmV4cG9zZXMsIHkgPSB7XG4gICAgdmVyc2lvbjogYyB8fCBcIlwiLFxuICAgIGJ1aWxkVmVyc2lvbjogTyxcbiAgICBnbG9iYWxOYW1lOiBMLFxuICAgIHJlbW90ZUVudHJ5OiBzaW1wbGVKb2luUmVtb3RlRW50cnkoTSwgSSksXG4gICAgcmVtb3RlRW50cnlUeXBlOiBELFxuICAgIHJlbW90ZVR5cGVzOiBzaW1wbGVKb2luUmVtb3RlRW50cnkoUy5wYXRoLCBTLm5hbWUpLFxuICAgIHJlbW90ZVR5cGVzWmlwOiBTLnppcCB8fCBcIlwiLFxuICAgIHJlbW90ZVR5cGVzQVBJOiBTLmFwaSB8fCBcIlwiLFxuICAgIHJlbW90ZXNJbmZvOiBnLFxuICAgIHNoYXJlZDogdD8uc2hhcmVkLm1hcChmdW5jdGlvbih3KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhc3NldHM6IHcuYXNzZXRzLFxuICAgICAgICBzaGFyZWROYW1lOiB3Lm5hbWVcbiAgICAgIH07XG4gICAgfSksXG4gICAgbW9kdWxlczogdj8ubWFwKGZ1bmN0aW9uKHcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZHVsZU5hbWU6IHcubmFtZSxcbiAgICAgICAgbW9kdWxlUGF0aDogdy5wYXRoLFxuICAgICAgICBhc3NldHM6IHcuYXNzZXRzXG4gICAgICB9O1xuICAgIH0pXG4gIH07XG4gIGlmICghKChvID0gdC5tZXRhRGF0YSkgPT09IG51bGwgfHwgbyA9PT0gdm9pZCAwKSAmJiBvLnByZWZldGNoSW50ZXJmYWNlKSB7XG4gICAgdmFyIEEgPSB0Lm1ldGFEYXRhLnByZWZldGNoSW50ZXJmYWNlO1xuICAgIHkgPSBfb2JqZWN0X3NwcmVhZF9wcm9wcyhfb2JqZWN0X3NwcmVhZCQxKHt9LCB5KSwge1xuICAgICAgcHJlZmV0Y2hJbnRlcmZhY2U6IEFcbiAgICB9KTtcbiAgfVxuICBpZiAoISgobiA9IHQubWV0YURhdGEpID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCkgJiYgbi5wcmVmZXRjaEVudHJ5KSB7XG4gICAgdmFyIGIgPSB0Lm1ldGFEYXRhLnByZWZldGNoRW50cnksIHggPSBiLnBhdGgsIEggPSBiLm5hbWUsICQgPSBiLnR5cGU7XG4gICAgeSA9IF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkJDEoe30sIHkpLCB7XG4gICAgICBwcmVmZXRjaEVudHJ5OiBzaW1wbGVKb2luUmVtb3RlRW50cnkoeCwgSCksXG4gICAgICBwcmVmZXRjaEVudHJ5VHlwZTogJFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBcInB1YmxpY1BhdGhcIiBpbiB0Lm1ldGFEYXRhID8gbCA9IF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkJDEoe30sIHkpLCB7XG4gICAgcHVibGljUGF0aDogdSgpXG4gIH0pIDogbCA9IF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkJDEoe30sIHkpLCB7XG4gICAgZ2V0UHVibGljUGF0aDogdSgpXG4gIH0pLCBsO1xufVxuZnVuY3Rpb24gaXNNYW5pZmVzdFByb3ZpZGVyKHQpIHtcbiAgcmV0dXJuICEhKFwicmVtb3RlRW50cnlcIiBpbiB0ICYmIHQucmVtb3RlRW50cnkuaW5jbHVkZXMoTUFOSUZFU1RfRVhUKSk7XG59XG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAkMSh0LCBlLCBvLCBuLCByLCBpLCBhKSB7XG4gIHRyeSB7XG4gICAgdmFyIHMgPSB0W2ldKGEpLCBjID0gcy52YWx1ZTtcbiAgfSBjYXRjaCAobCkge1xuICAgIG8obCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHMuZG9uZSA/IGUoYykgOiBQcm9taXNlLnJlc29sdmUoYykudGhlbihuLCByKTtcbn1cbmZ1bmN0aW9uIF9hc3luY190b19nZW5lcmF0b3IkMSh0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZSA9IHRoaXMsIG8gPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIHZhciBpID0gdC5hcHBseShlLCBvKTtcbiAgICAgIGZ1bmN0aW9uIGEoYykge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAkMShpLCBuLCByLCBhLCBzLCBcIm5leHRcIiwgYyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzKGMpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwJDEoaSwgbiwgciwgYSwgcywgXCJ0aHJvd1wiLCBjKTtcbiAgICAgIH1cbiAgICAgIGEodm9pZCAwKTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIF9pbnN0YW5jZW9mKHQsIGUpIHtcbiAgcmV0dXJuIGUgIT0gbnVsbCAmJiB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgZVtTeW1ib2wuaGFzSW5zdGFuY2VdID8gISFlW1N5bWJvbC5oYXNJbnN0YW5jZV0odCkgOiB0IGluc3RhbmNlb2YgZTtcbn1cbmZ1bmN0aW9uIF90c19nZW5lcmF0b3IkMSh0LCBlKSB7XG4gIHZhciBvLCBuLCByLCBpLCBhID0ge1xuICAgIGxhYmVsOiAwLFxuICAgIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHJbMF0gJiAxKVxuICAgICAgICB0aHJvdyByWzFdO1xuICAgICAgcmV0dXJuIHJbMV07XG4gICAgfSxcbiAgICB0cnlzOiBbXSxcbiAgICBvcHM6IFtdXG4gIH07XG4gIHJldHVybiBpID0ge1xuICAgIG5leHQ6IHMoMCksXG4gICAgdGhyb3c6IHMoMSksXG4gICAgcmV0dXJuOiBzKDIpXG4gIH0sIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIChpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGk7XG4gIGZ1bmN0aW9uIHMobCkge1xuICAgIHJldHVybiBmdW5jdGlvbih1KSB7XG4gICAgICByZXR1cm4gYyhbXG4gICAgICAgIGwsXG4gICAgICAgIHVcbiAgICAgIF0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYyhsKSB7XG4gICAgaWYgKG8pXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICBmb3IgKDsgYTsgKVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG8gPSAxLCBuICYmIChyID0gbFswXSAmIDIgPyBuLnJldHVybiA6IGxbMF0gPyBuLnRocm93IHx8ICgociA9IG4ucmV0dXJuKSAmJiByLmNhbGwobiksIDApIDogbi5uZXh0KSAmJiAhKHIgPSByLmNhbGwobiwgbFsxXSkpLmRvbmUpXG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIHN3aXRjaCAobiA9IDAsIHIgJiYgKGwgPSBbXG4gICAgICAgICAgbFswXSAmIDIsXG4gICAgICAgICAgci52YWx1ZVxuICAgICAgICBdKSwgbFswXSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByID0gbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBhLmxhYmVsKyssIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGxbMV0sXG4gICAgICAgICAgICAgIGRvbmU6ICExXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGEubGFiZWwrKywgbiA9IGxbMV0sIGwgPSBbXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBsID0gYS5vcHMucG9wKCksIGEudHJ5cy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAociA9IGEudHJ5cywgIShyID0gci5sZW5ndGggPiAwICYmIHJbci5sZW5ndGggLSAxXSkgJiYgKGxbMF0gPT09IDYgfHwgbFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgYSA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxbMF0gPT09IDMgJiYgKCFyIHx8IGxbMV0gPiByWzBdICYmIGxbMV0gPCByWzNdKSkge1xuICAgICAgICAgICAgICBhLmxhYmVsID0gbFsxXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobFswXSA9PT0gNiAmJiBhLmxhYmVsIDwgclsxXSkge1xuICAgICAgICAgICAgICBhLmxhYmVsID0gclsxXSwgciA9IGw7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIgJiYgYS5sYWJlbCA8IHJbMl0pIHtcbiAgICAgICAgICAgICAgYS5sYWJlbCA9IHJbMl0sIGEub3BzLnB1c2gobCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgclsyXSAmJiBhLm9wcy5wb3AoKSwgYS50cnlzLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbCA9IGUuY2FsbCh0LCBhKTtcbiAgICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgICAgbCA9IFtcbiAgICAgICAgICA2LFxuICAgICAgICAgIHVcbiAgICAgICAgXSwgbiA9IDA7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBvID0gciA9IDA7XG4gICAgICB9XG4gICAgaWYgKGxbMF0gJiA1KVxuICAgICAgdGhyb3cgbFsxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGxbMF0gPyBsWzFdIDogdm9pZCAwLFxuICAgICAgZG9uZTogITBcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBzYWZlV3JhcHBlcih0LCBlKSB7XG4gIHJldHVybiBfc2FmZVdyYXBwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9zYWZlV3JhcHBlcigpIHtcbiAgcmV0dXJuIF9zYWZlV3JhcHBlciA9IF9hc3luY190b19nZW5lcmF0b3IkMShmdW5jdGlvbih0LCBlKSB7XG4gICAgdmFyIG8sIG47XG4gICAgcmV0dXJuIF90c19nZW5lcmF0b3IkMSh0aGlzLCBmdW5jdGlvbihyKSB7XG4gICAgICBzd2l0Y2ggKHIubGFiZWwpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiByLnRyeXMucHVzaChbXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMixcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIDNcbiAgICAgICAgICBdKSwgW1xuICAgICAgICAgICAgNCxcbiAgICAgICAgICAgIHQoKVxuICAgICAgICAgIF07XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gbyA9IHIuc2VudCgpLCBbXG4gICAgICAgICAgICAyLFxuICAgICAgICAgICAgb1xuICAgICAgICAgIF07XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gbiA9IHIuc2VudCgpLCAhZSAmJiB3YXJuKG4pLCBbXG4gICAgICAgICAgICAyXG4gICAgICAgICAgXTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAyXG4gICAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksIF9zYWZlV3JhcHBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNSZXNvdXJjZXNFcXVhbCh0LCBlKSB7XG4gIHZhciBvID0gL14oaHR0cHM/Oik/XFwvXFwvL2ksIG4gPSB0LnJlcGxhY2UobywgXCJcIikucmVwbGFjZSgvXFwvJC8sIFwiXCIpLCByID0gZS5yZXBsYWNlKG8sIFwiXCIpLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgcmV0dXJuIG4gPT09IHI7XG59XG5mdW5jdGlvbiBjcmVhdGVTY3JpcHQodCwgZSwgbywgbikge1xuICBmb3IgKHZhciByID0gbnVsbCwgaSA9ICEwLCBhID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIiksIHMgPSAwOyBzIDwgYS5sZW5ndGg7IHMrKykge1xuICAgIHZhciBjID0gYVtzXSwgbCA9IGMuZ2V0QXR0cmlidXRlKFwic3JjXCIpO1xuICAgIGlmIChsICYmIGlzU3RhdGljUmVzb3VyY2VzRXF1YWwobCwgdCkpIHtcbiAgICAgIHIgPSBjLCBpID0gITE7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKCFyICYmIChyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSwgci50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIiwgci5zcmMgPSB0LCBuKSkge1xuICAgIHZhciB1ID0gbih0KTtcbiAgICBfaW5zdGFuY2VvZih1LCBIVE1MU2NyaXB0RWxlbWVudCkgJiYgKHIgPSB1KTtcbiAgfVxuICBvICYmIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24oZykge1xuICAgIHIgJiYgKGcgPT09IFwiYXN5bmNcIiB8fCBnID09PSBcImRlZmVyXCIgPyByW2ddID0gb1tnXSA6IHIuc2V0QXR0cmlidXRlKGcsIG9bZ10pKTtcbiAgfSk7XG4gIHZhciBoID0gZnVuY3Rpb24oZywgcCkge1xuICAgIGlmIChyICYmIChyLm9uZXJyb3IgPSBudWxsLCByLm9ubG9hZCA9IG51bGwsIHNhZmVXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgciAhPSBudWxsICYmIHIucGFyZW50Tm9kZSAmJiByLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocik7XG4gICAgfSksIGcpKSB7XG4gICAgICB2YXIgZCA9IGcocCk7XG4gICAgICByZXR1cm4gZSgpLCBkO1xuICAgIH1cbiAgICBlKCk7XG4gIH07XG4gIHJldHVybiByLm9uZXJyb3IgPSBoLmJpbmQobnVsbCwgci5vbmVycm9yKSwgci5vbmxvYWQgPSBoLmJpbmQobnVsbCwgci5vbmxvYWQpLCB7XG4gICAgc2NyaXB0OiByLFxuICAgIG5lZWRBdHRhY2g6IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpbmsodCwgZSkge1xuICBmb3IgKHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fSwgbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdm9pZCAwLCByID0gbnVsbCwgaSA9ICEwLCBhID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpLCBzID0gMDsgcyA8IGEubGVuZ3RoOyBzKyspIHtcbiAgICB2YXIgYyA9IGFbc10sIGwgPSBjLmdldEF0dHJpYnV0ZShcImhyZWZcIiksIHUgPSBjLmdldEF0dHJpYnV0ZShcInJlZlwiKTtcbiAgICBpZiAobCAmJiBpc1N0YXRpY1Jlc291cmNlc0VxdWFsKGwsIHQpICYmIHUgPT09IG8ucmVmKSB7XG4gICAgICByID0gYywgaSA9ICExO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghciAmJiAociA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpLCByLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgdCksIG4pKSB7XG4gICAgdmFyIGggPSBuKHQpO1xuICAgIF9pbnN0YW5jZW9mKGgsIEhUTUxMaW5rRWxlbWVudCkgJiYgKHIgPSBoKTtcbiAgfVxuICBvICYmIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgIHIgJiYgci5zZXRBdHRyaWJ1dGUocCwgb1twXSk7XG4gIH0pO1xuICB2YXIgZyA9IGZ1bmN0aW9uKHAsIGQpIHtcbiAgICBpZiAociAmJiAoci5vbmVycm9yID0gbnVsbCwgci5vbmxvYWQgPSBudWxsLCBzYWZlV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgIHIgIT0gbnVsbCAmJiByLnBhcmVudE5vZGUgJiYgci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHIpO1xuICAgIH0pLCBwKSkge1xuICAgICAgdmFyIG0gPSBwKGQpO1xuICAgICAgcmV0dXJuIGUoKSwgbTtcbiAgICB9XG4gICAgZSgpO1xuICB9O1xuICByZXR1cm4gci5vbmVycm9yID0gZy5iaW5kKG51bGwsIHIub25lcnJvciksIHIub25sb2FkID0gZy5iaW5kKG51bGwsIHIub25sb2FkKSwge1xuICAgIGxpbms6IHIsXG4gICAgbmVlZEF0dGFjaDogaVxuICB9O1xufVxuZnVuY3Rpb24gbG9hZFNjcmlwdCh0LCBlKSB7XG4gIHZhciBvID0gZS5hdHRycywgbiA9IGUuY3JlYXRlU2NyaXB0SG9vaztcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHIsIGkpIHtcbiAgICB2YXIgYSA9IGNyZWF0ZVNjcmlwdCh0LCByLCBvLCBuKSwgcyA9IGEuc2NyaXB0LCBjID0gYS5uZWVkQXR0YWNoO1xuICAgIGMgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKHMpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9hcnJheV9saWtlX3RvX2FycmF5KHQsIGUpIHtcbiAgKGUgPT0gbnVsbCB8fCBlID4gdC5sZW5ndGgpICYmIChlID0gdC5sZW5ndGgpO1xuICBmb3IgKHZhciBvID0gMCwgbiA9IG5ldyBBcnJheShlKTsgbyA8IGU7IG8rKylcbiAgICBuW29dID0gdFtvXTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBfYXJyYXlfd2l0aF9ob2xlcyh0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHQpKVxuICAgIHJldHVybiB0O1xufVxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKHQsIGUsIG8sIG4sIHIsIGksIGEpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcyA9IHRbaV0oYSksIGMgPSBzLnZhbHVlO1xuICB9IGNhdGNoIChsKSB7XG4gICAgbyhsKTtcbiAgICByZXR1cm47XG4gIH1cbiAgcy5kb25lID8gZShjKSA6IFByb21pc2UucmVzb2x2ZShjKS50aGVuKG4sIHIpO1xufVxuZnVuY3Rpb24gX2FzeW5jX3RvX2dlbmVyYXRvcih0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZSA9IHRoaXMsIG8gPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgIHZhciBpID0gdC5hcHBseShlLCBvKTtcbiAgICAgIGZ1bmN0aW9uIGEoYykge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoaSwgbiwgciwgYSwgcywgXCJuZXh0XCIsIGMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcyhjKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChpLCBuLCByLCBhLCBzLCBcInRocm93XCIsIGMpO1xuICAgICAgfVxuICAgICAgYSh2b2lkIDApO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlX3RvX2FycmF5X2xpbWl0KHQsIGUpIHtcbiAgdmFyIG8gPSB0ID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIHRbU3ltYm9sLml0ZXJhdG9yXSB8fCB0W1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG8gIT0gbnVsbCkge1xuICAgIHZhciBuID0gW10sIHIgPSAhMCwgaSA9ICExLCBhLCBzO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKG8gPSBvLmNhbGwodCk7ICEociA9IChhID0gby5uZXh0KCkpLmRvbmUpICYmIChuLnB1c2goYS52YWx1ZSksICEoZSAmJiBuLmxlbmd0aCA9PT0gZSkpOyByID0gITApXG4gICAgICAgIDtcbiAgICB9IGNhdGNoIChjKSB7XG4gICAgICBpID0gITAsIHMgPSBjO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAhciAmJiBvLnJldHVybiAhPSBudWxsICYmIG8ucmV0dXJuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoaSlcbiAgICAgICAgICB0aHJvdyBzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxufVxuZnVuY3Rpb24gX25vbl9pdGVyYWJsZV9yZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfc2xpY2VkX3RvX2FycmF5KHQsIGUpIHtcbiAgcmV0dXJuIF9hcnJheV93aXRoX2hvbGVzKHQpIHx8IF9pdGVyYWJsZV90b19hcnJheV9saW1pdCh0LCBlKSB8fCBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkodCwgZSkgfHwgX25vbl9pdGVyYWJsZV9yZXN0KCk7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkodCwgZSkge1xuICBpZiAodCkge1xuICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5KHQsIGUpO1xuICAgIHZhciBvID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobyA9PT0gXCJPYmplY3RcIiAmJiB0LmNvbnN0cnVjdG9yICYmIChvID0gdC5jb25zdHJ1Y3Rvci5uYW1lKSwgbyA9PT0gXCJNYXBcIiB8fCBvID09PSBcIlNldFwiKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgaWYgKG8gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobykpXG4gICAgICByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkodCwgZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIF90c19nZW5lcmF0b3IodCwgZSkge1xuICB2YXIgbywgbiwgciwgaSwgYSA9IHtcbiAgICBsYWJlbDogMCxcbiAgICBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChyWzBdICYgMSlcbiAgICAgICAgdGhyb3cgclsxXTtcbiAgICAgIHJldHVybiByWzFdO1xuICAgIH0sXG4gICAgdHJ5czogW10sXG4gICAgb3BzOiBbXVxuICB9O1xuICByZXR1cm4gaSA9IHtcbiAgICBuZXh0OiBzKDApLFxuICAgIHRocm93OiBzKDEpLFxuICAgIHJldHVybjogcygyKVxuICB9LCB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiAoaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBpO1xuICBmdW5jdGlvbiBzKGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odSkge1xuICAgICAgcmV0dXJuIGMoW1xuICAgICAgICBsLFxuICAgICAgICB1XG4gICAgICBdKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGMobCkge1xuICAgIGlmIChvKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgZm9yICg7IGE7IClcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChvID0gMSwgbiAmJiAociA9IGxbMF0gJiAyID8gbi5yZXR1cm4gOiBsWzBdID8gbi50aHJvdyB8fCAoKHIgPSBuLnJldHVybikgJiYgci5jYWxsKG4pLCAwKSA6IG4ubmV4dCkgJiYgIShyID0gci5jYWxsKG4sIGxbMV0pKS5kb25lKVxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICBzd2l0Y2ggKG4gPSAwLCByICYmIChsID0gW1xuICAgICAgICAgIGxbMF0gJiAyLFxuICAgICAgICAgIHIudmFsdWVcbiAgICAgICAgXSksIGxbMF0pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgciA9IGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gYS5sYWJlbCsrLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBsWzFdLFxuICAgICAgICAgICAgICBkb25lOiAhMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBhLmxhYmVsKyssIG4gPSBsWzFdLCBsID0gW1xuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgbCA9IGEub3BzLnBvcCgpLCBhLnRyeXMucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHIgPSBhLnRyeXMsICEociA9IHIubGVuZ3RoID4gMCAmJiByW3IubGVuZ3RoIC0gMV0pICYmIChsWzBdID09PSA2IHx8IGxbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgIGEgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsWzBdID09PSAzICYmICghciB8fCBsWzFdID4gclswXSAmJiBsWzFdIDwgclszXSkpIHtcbiAgICAgICAgICAgICAgYS5sYWJlbCA9IGxbMV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxbMF0gPT09IDYgJiYgYS5sYWJlbCA8IHJbMV0pIHtcbiAgICAgICAgICAgICAgYS5sYWJlbCA9IHJbMV0sIHIgPSBsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyICYmIGEubGFiZWwgPCByWzJdKSB7XG4gICAgICAgICAgICAgIGEubGFiZWwgPSByWzJdLCBhLm9wcy5wdXNoKGwpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJbMl0gJiYgYS5vcHMucG9wKCksIGEudHJ5cy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGwgPSBlLmNhbGwodCwgYSk7XG4gICAgICB9IGNhdGNoICh1KSB7XG4gICAgICAgIGwgPSBbXG4gICAgICAgICAgNixcbiAgICAgICAgICB1XG4gICAgICAgIF0sIG4gPSAwO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbyA9IHIgPSAwO1xuICAgICAgfVxuICAgIGlmIChsWzBdICYgNSlcbiAgICAgIHRocm93IGxbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBsWzBdID8gbFsxXSA6IHZvaWQgMCxcbiAgICAgIGRvbmU6ICEwXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaW1wb3J0Tm9kZU1vZHVsZSh0KSB7XG4gIGlmICghdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbXBvcnQgc3BlY2lmaWVyIGlzIHJlcXVpcmVkXCIpO1xuICB2YXIgZSA9IG5ldyBGdW5jdGlvbihcIm5hbWVcIiwgXCJyZXR1cm4gaW1wb3J0KG5hbWUpXCIpO1xuICByZXR1cm4gZSh0KS50aGVuKGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gby5kZWZhdWx0O1xuICB9KS5jYXRjaChmdW5jdGlvbihvKSB7XG4gICAgdGhyb3cgY29uc29sZS5lcnJvcihcIkVycm9yIGltcG9ydGluZyBtb2R1bGUgXCIuY29uY2F0KHQsIFwiOlwiKSwgbyksIG87XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU2NyaXB0Tm9kZSh1cmwsIGNiLCBhdHRycywgY3JlYXRlU2NyaXB0SG9vaykge1xuICBpZiAoY3JlYXRlU2NyaXB0SG9vaykge1xuICAgIHZhciBob29rUmVzdWx0ID0gY3JlYXRlU2NyaXB0SG9vayh1cmwpO1xuICAgIGhvb2tSZXN1bHQgJiYgdHlwZW9mIGhvb2tSZXN1bHQgPT0gXCJvYmplY3RcIiAmJiBcInVybFwiIGluIGhvb2tSZXN1bHQgJiYgKHVybCA9IGhvb2tSZXN1bHQudXJsKTtcbiAgfVxuICB2YXIgdXJsT2JqO1xuICB0cnkge1xuICAgIHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgfSBjYXRjaCAodCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjb25zdHJ1Y3RpbmcgVVJMOlwiLCB0KSwgY2IobmV3IEVycm9yKFwiSW52YWxpZCBVUkw6IFwiLmNvbmNhdCh0KSkpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZ2V0RmV0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgc3dpdGNoIChvLmxhYmVsKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmZXRjaCA+IFwidVwiID8gW1xuICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICBpbXBvcnROb2RlTW9kdWxlKFwibm9kZS1mZXRjaFwiKVxuICAgICAgICAgICAgXSA6IFtcbiAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgXTtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gZSA9IG8uc2VudCgpLCBbXG4gICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgIGU/LmRlZmF1bHQgfHwgZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICBmZXRjaFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAyXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0oKTtcbiAgY29uc29sZS5sb2coXCJmZXRjaGluZ1wiLCB1cmxPYmouaHJlZiksIGdldEZldGNoKCkudGhlbihmdW5jdGlvbihmKSB7XG4gICAgZih1cmxPYmouaHJlZikudGhlbihmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdC50ZXh0KCk7XG4gICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfcmVmID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBfcmVmLCBwYXRoLCB2bSwgc2NyaXB0Q29udGV4dCwgdXJsRGlybmFtZSwgZmlsZW5hbWUsIHNjcmlwdCwgZXhwb3J0ZWRJbnRlcmZhY2UsIGNvbnRhaW5lcjtcbiAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgc3dpdGNoIChfc3RhdGUubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgIGltcG9ydE5vZGVNb2R1bGUoXCJwYXRoXCIpLFxuICAgICAgICAgICAgICAgICAgaW1wb3J0Tm9kZU1vZHVsZShcInZtXCIpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgX3JlZiA9IF9zbGljZWRfdG9fYXJyYXkuYXBwbHkodm9pZCAwLCBbXG4gICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKSxcbiAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgIF0pLCBwYXRoID0gX3JlZlswXSwgdm0gPSBfcmVmWzFdLCBzY3JpcHRDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9LFxuICAgICAgICAgICAgICAgIG1vZHVsZToge1xuICAgICAgICAgICAgICAgICAgZXhwb3J0czoge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIHVybERpcm5hbWUgPSB1cmxPYmoucGF0aG5hbWUuc3BsaXQoXCIvXCIpLnNsaWNlKDAsIC0xKS5qb2luKFwiL1wiKSwgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKHVybE9iai5wYXRobmFtZSk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdCA9IG5ldyB2bS5TY3JpcHQoXCIoZnVuY3Rpb24oZXhwb3J0cywgbW9kdWxlLCByZXF1aXJlLCBfX2Rpcm5hbWUsIF9fZmlsZW5hbWUpIHtcIi5jb25jYXQoZGF0YSwgYFxufSlgKSwgZmlsZW5hbWUpLCBzY3JpcHQucnVuSW5UaGlzQ29udGV4dCgpKHNjcmlwdENvbnRleHQuZXhwb3J0cywgc2NyaXB0Q29udGV4dC5tb2R1bGUsIGV2YWwoXCJyZXF1aXJlXCIpLCB1cmxEaXJuYW1lLCBmaWxlbmFtZSksIGV4cG9ydGVkSW50ZXJmYWNlID0gc2NyaXB0Q29udGV4dC5tb2R1bGUuZXhwb3J0cyB8fCBzY3JpcHRDb250ZXh0LmV4cG9ydHMsIGF0dHJzICYmIGV4cG9ydGVkSW50ZXJmYWNlICYmIGF0dHJzLmdsb2JhbE5hbWUpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyID0gZXhwb3J0ZWRJbnRlcmZhY2VbYXR0cnMuZ2xvYmFsTmFtZV0gfHwgZXhwb3J0ZWRJbnRlcmZhY2UsIGNiKHZvaWQgMCwgY29udGFpbmVyKSwgW1xuICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNiKHZvaWQgMCwgZXhwb3J0ZWRJbnRlcmZhY2UpO1xuICAgICAgICAgICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgICAgICAgICAgY2IobmV3IEVycm9yKFwiU2NyaXB0IGV4ZWN1dGlvbiBlcnJvcjogXCIuY29uY2F0KHQpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSgpKS5jYXRjaChmdW5jdGlvbih0KSB7XG4gICAgICBjYih0KTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBsb2FkU2NyaXB0Tm9kZSh0LCBlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihvLCBuKSB7XG4gICAgY3JlYXRlU2NyaXB0Tm9kZSh0LCBmdW5jdGlvbihyLCBpKSB7XG4gICAgICBpZiAocilcbiAgICAgICAgbihyKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgYSwgcywgYyA9IChlID09IG51bGwgfHwgKGEgPSBlLmF0dHJzKSA9PT0gbnVsbCB8fCBhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhLmdsb2JhbE5hbWUpIHx8IFwiX19GRURFUkFUSU9OX1wiLmNvbmNhdChlID09IG51bGwgfHwgKHMgPSBlLmF0dHJzKSA9PT0gbnVsbCB8fCBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzLm5hbWUsIFwiOmN1c3RvbV9fXCIpLCBsID0gZ2xvYmFsVGhpc1tjXSA9IGk7XG4gICAgICAgIG8obCk7XG4gICAgICB9XG4gICAgfSwgZS5hdHRycywgZS5jcmVhdGVTY3JpcHRIb29rKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBtYXRjaFJlbW90ZVdpdGhOYW1lQW5kRXhwb3NlKHQsIGUpIHtcbiAgZm9yIChjb25zdCBvIG9mIHQpIHtcbiAgICBjb25zdCBuID0gZS5zdGFydHNXaXRoKG8ubmFtZSk7XG4gICAgbGV0IHIgPSBlLnJlcGxhY2Uoby5uYW1lLCBcIlwiKTtcbiAgICBpZiAobikge1xuICAgICAgaWYgKHIuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgY29uc3QgcyA9IG8ubmFtZTtcbiAgICAgICAgcmV0dXJuIHIgPSBgLiR7cn1gLCB7XG4gICAgICAgICAgcGtnTmFtZU9yQWxpYXM6IHMsXG4gICAgICAgICAgZXhwb3NlOiByLFxuICAgICAgICAgIHJlbW90ZTogb1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChyID09PSBcIlwiKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBrZ05hbWVPckFsaWFzOiBvLm5hbWUsXG4gICAgICAgICAgZXhwb3NlOiBcIi5cIixcbiAgICAgICAgICByZW1vdGU6IG9cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaSA9IG8uYWxpYXMgJiYgZS5zdGFydHNXaXRoKG8uYWxpYXMpO1xuICAgIGxldCBhID0gby5hbGlhcyAmJiBlLnJlcGxhY2Uoby5hbGlhcywgXCJcIik7XG4gICAgaWYgKG8uYWxpYXMgJiYgaSkge1xuICAgICAgaWYgKGEgJiYgYS5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICBjb25zdCBzID0gby5hbGlhcztcbiAgICAgICAgcmV0dXJuIGEgPSBgLiR7YX1gLCB7XG4gICAgICAgICAgcGtnTmFtZU9yQWxpYXM6IHMsXG4gICAgICAgICAgZXhwb3NlOiBhLFxuICAgICAgICAgIHJlbW90ZTogb1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChhID09PSBcIlwiKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBrZ05hbWVPckFsaWFzOiBvLmFsaWFzLFxuICAgICAgICAgIGV4cG9zZTogXCIuXCIsXG4gICAgICAgICAgcmVtb3RlOiBvXG4gICAgICAgIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXRjaFJlbW90ZSh0LCBlKSB7XG4gIGZvciAoY29uc3QgbyBvZiB0KVxuICAgIGlmIChlID09PSBvLm5hbWUgfHwgby5hbGlhcyAmJiBlID09PSBvLmFsaWFzKVxuICAgICAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiByZWdpc3RlclBsdWdpbnModCwgZSkge1xuICBjb25zdCBvID0gZ2V0R2xvYmFsSG9zdFBsdWdpbnMoKTtcbiAgby5sZW5ndGggPiAwICYmIG8uZm9yRWFjaCgobikgPT4ge1xuICAgIHQgIT0gbnVsbCAmJiB0LmZpbmQoKHIpID0+IHIubmFtZSAhPT0gbi5uYW1lKSAmJiB0LnB1c2gobik7XG4gIH0pLCB0ICYmIHQubGVuZ3RoID4gMCAmJiB0LmZvckVhY2goKG4pID0+IHtcbiAgICBlLmZvckVhY2goKHIpID0+IHtcbiAgICAgIHIuYXBwbHlQbHVnaW4obik7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gX2V4dGVuZHMkNSgpIHtcbiAgcmV0dXJuIF9leHRlbmRzJDUgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlID0gMTsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIG8gPSBhcmd1bWVudHNbZV07XG4gICAgICBmb3IgKHZhciBuIGluIG8pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBuKSAmJiAodFtuXSA9IG9bbl0pO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfSwgX2V4dGVuZHMkNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEVzbUVudHJ5KHsgZW50cnk6IHQsIHJlbW90ZUVudHJ5RXhwb3J0czogZSB9KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgobywgbikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBlID8gbyhlKSA6IG5ldyBGdW5jdGlvbihcImNhbGxiYWNrc1wiLCBgaW1wb3J0KFwiJHt0fVwiKS50aGVuKGNhbGxiYWNrc1swXSkuY2F0Y2goY2FsbGJhY2tzWzFdKWApKFtcbiAgICAgICAgbyxcbiAgICAgICAgblxuICAgICAgXSk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgbihyKTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEVudHJ5U2NyaXB0KHsgbmFtZTogdCwgZ2xvYmFsTmFtZTogZSwgZW50cnk6IG8sIGNyZWF0ZVNjcmlwdEhvb2s6IG4gfSkge1xuICBjb25zdCB7IGVudHJ5RXhwb3J0czogciB9ID0gZ2V0UmVtb3RlRW50cnlFeHBvcnRzKHQsIGUpO1xuICByZXR1cm4gciB8fCAodHlwZW9mIGRvY3VtZW50ID4gXCJ1XCIgPyBsb2FkU2NyaXB0Tm9kZShvLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIG5hbWU6IHQsXG4gICAgICBnbG9iYWxOYW1lOiBlXG4gICAgfSxcbiAgICBjcmVhdGVTY3JpcHRIb29rOiBuXG4gIH0pLnRoZW4oKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVtb3RlRW50cnlLZXk6IGksIGVudHJ5RXhwb3J0czogYSB9ID0gZ2V0UmVtb3RlRW50cnlFeHBvcnRzKHQsIGUpO1xuICAgIHJldHVybiBhc3NlcnQoYSwgYFxuICAgICAgICBVbmFibGUgdG8gdXNlIHRoZSAke3R9J3MgJyR7b30nIFVSTCB3aXRoICR7aX0ncyBnbG9iYWxOYW1lIHRvIGdldCByZW1vdGVFbnRyeSBleHBvcnRzLlxuICAgICAgICBQb3NzaWJsZSByZWFzb25zIGNvdWxkIGJlOlxuXG4gICAgICAgIDEuICcke299JyBpcyBub3QgdGhlIGNvcnJlY3QgVVJMLCBvciB0aGUgcmVtb3RlRW50cnkgcmVzb3VyY2Ugb3IgbmFtZSBpcyBpbmNvcnJlY3QuXG5cbiAgICAgICAgMi4gJHtpfSBjYW5ub3QgYmUgdXNlZCB0byBnZXQgcmVtb3RlRW50cnkgZXhwb3J0cyBpbiB0aGUgd2luZG93IG9iamVjdC5cbiAgICAgIGApLCBhO1xuICB9KS5jYXRjaCgoaSkgPT4gaSkgOiBsb2FkU2NyaXB0KG8sIHtcbiAgICBhdHRyczoge30sXG4gICAgY3JlYXRlU2NyaXB0SG9vazogblxuICB9KS50aGVuKCgpID0+IHtcbiAgICBjb25zdCB7IHJlbW90ZUVudHJ5S2V5OiBpLCBlbnRyeUV4cG9ydHM6IGEgfSA9IGdldFJlbW90ZUVudHJ5RXhwb3J0cyh0LCBlKTtcbiAgICByZXR1cm4gYXNzZXJ0KGEsIGBcbiAgICAgIFVuYWJsZSB0byB1c2UgdGhlICR7dH0ncyAnJHtvfScgVVJMIHdpdGggJHtpfSdzIGdsb2JhbE5hbWUgdG8gZ2V0IHJlbW90ZUVudHJ5IGV4cG9ydHMuXG4gICAgICBQb3NzaWJsZSByZWFzb25zIGNvdWxkIGJlOlxuXG4gICAgICAxLiAnJHtvfScgaXMgbm90IHRoZSBjb3JyZWN0IFVSTCwgb3IgdGhlIHJlbW90ZUVudHJ5IHJlc291cmNlIG9yIG5hbWUgaXMgaW5jb3JyZWN0LlxuXG4gICAgICAyLiAke2l9IGNhbm5vdCBiZSB1c2VkIHRvIGdldCByZW1vdGVFbnRyeSBleHBvcnRzIGluIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgIGApLCBhO1xuICB9KS5jYXRjaCgoaSkgPT4gaSkpO1xufVxuZnVuY3Rpb24gZ2V0UmVtb3RlRW50cnlVbmlxdWVLZXkodCkge1xuICBjb25zdCB7IGVudHJ5OiBlLCBuYW1lOiBvIH0gPSB0O1xuICByZXR1cm4gY29tcG9zZUtleVdpdGhTZXBhcmF0b3IobywgZSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZW1vdGVFbnRyeSh7IHJlbW90ZUVudHJ5RXhwb3J0czogdCwgcmVtb3RlSW5mbzogZSwgY3JlYXRlU2NyaXB0SG9vazogbyB9KSB7XG4gIGNvbnN0IHsgZW50cnk6IG4sIG5hbWU6IHIsIHR5cGU6IGksIGVudHJ5R2xvYmFsTmFtZTogYSB9ID0gZSwgcyA9IGdldFJlbW90ZUVudHJ5VW5pcXVlS2V5KGUpO1xuICByZXR1cm4gdCB8fCAoZ2xvYmFsTG9hZGluZ1tzXSB8fCAoaSA9PT0gXCJlc21cIiA/IGdsb2JhbExvYWRpbmdbc10gPSBsb2FkRXNtRW50cnkoe1xuICAgIGVudHJ5OiBuLFxuICAgIHJlbW90ZUVudHJ5RXhwb3J0czogdFxuICB9KSA6IGdsb2JhbExvYWRpbmdbc10gPSBsb2FkRW50cnlTY3JpcHQoe1xuICAgIG5hbWU6IHIsXG4gICAgZ2xvYmFsTmFtZTogYSxcbiAgICBlbnRyeTogbixcbiAgICBjcmVhdGVTY3JpcHRIb29rOiBvXG4gIH0pKSwgZ2xvYmFsTG9hZGluZ1tzXSk7XG59XG5mdW5jdGlvbiBnZXRSZW1vdGVJbmZvKHQpIHtcbiAgcmV0dXJuIF9leHRlbmRzJDUoe30sIHQsIHtcbiAgICBlbnRyeTogXCJlbnRyeVwiIGluIHQgPyB0LmVudHJ5IDogXCJcIixcbiAgICB0eXBlOiB0LnR5cGUgfHwgREVGQVVMVF9SRU1PVEVfVFlQRSxcbiAgICBlbnRyeUdsb2JhbE5hbWU6IHQuZW50cnlHbG9iYWxOYW1lIHx8IHQubmFtZSxcbiAgICBzaGFyZVNjb3BlOiB0LnNoYXJlU2NvcGUgfHwgREVGQVVMVF9TQ09QRVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9leHRlbmRzJDQoKSB7XG4gIHJldHVybiBfZXh0ZW5kcyQ0ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciBvID0gYXJndW1lbnRzW2VdO1xuICAgICAgZm9yICh2YXIgbiBpbiBvKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgbikgJiYgKHRbbl0gPSBvW25dKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH0sIF9leHRlbmRzJDQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmxldCBNb2R1bGUgPSBjbGFzcyB7XG4gIGFzeW5jIGdldEVudHJ5KCkge1xuICAgIGlmICh0aGlzLnJlbW90ZUVudHJ5RXhwb3J0cylcbiAgICAgIHJldHVybiB0aGlzLnJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICBjb25zdCB0ID0gYXdhaXQgZ2V0UmVtb3RlRW50cnkoe1xuICAgICAgcmVtb3RlSW5mbzogdGhpcy5yZW1vdGVJbmZvLFxuICAgICAgcmVtb3RlRW50cnlFeHBvcnRzOiB0aGlzLnJlbW90ZUVudHJ5RXhwb3J0cyxcbiAgICAgIGNyZWF0ZVNjcmlwdEhvb2s6IChlKSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLmhvc3QubG9hZGVySG9vay5saWZlY3ljbGUuY3JlYXRlU2NyaXB0LmVtaXQoe1xuICAgICAgICAgIHVybDogZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA+IFwidVwiIHx8IG8gaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudClcbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYXNzZXJ0KHQsIGByZW1vdGVFbnRyeUV4cG9ydHMgaXMgdW5kZWZpbmVkIFxuICR7c2FmZVRvU3RyaW5nJDEodGhpcy5yZW1vdGVJbmZvKX1gKSwgdGhpcy5yZW1vdGVFbnRyeUV4cG9ydHMgPSB0LCB0aGlzLnJlbW90ZUVudHJ5RXhwb3J0cztcbiAgfVxuICBhc3luYyBnZXQodCwgZSkge1xuICAgIGNvbnN0IHsgbG9hZEZhY3Rvcnk6IG8gPSAhMCB9ID0gZSB8fCB7XG4gICAgICBsb2FkRmFjdG9yeTogITBcbiAgICB9LCBuID0gYXdhaXQgdGhpcy5nZXRFbnRyeSgpO1xuICAgIGlmICghdGhpcy5pbml0ZWQpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLmhvc3Quc2hhcmVTY29wZU1hcCwgYSA9IHRoaXMucmVtb3RlSW5mby5zaGFyZVNjb3BlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgaVthXSB8fCAoaVthXSA9IHt9KTtcbiAgICAgIGNvbnN0IHMgPSBpW2FdLCBjID0gW10sIGwgPSB7XG4gICAgICAgIHZlcnNpb246IHRoaXMucmVtb3RlSW5mby52ZXJzaW9uIHx8IFwiXCJcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobCwgXCJob3N0SWRcIiwge1xuICAgICAgICB2YWx1ZTogdGhpcy5ob3N0Lm9wdGlvbnMuaWQgfHwgdGhpcy5ob3N0Lm5hbWUsXG4gICAgICAgIGVudW1lcmFibGU6ICExXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHUgPSBhd2FpdCB0aGlzLmhvc3QuaG9va3MubGlmZWN5Y2xlLmJlZm9yZUluaXRDb250YWluZXIuZW1pdCh7XG4gICAgICAgIHNoYXJlU2NvcGU6IHMsXG4gICAgICAgIHJlbW90ZUVudHJ5SW5pdE9wdGlvbnM6IGwsXG4gICAgICAgIGluaXRTY29wZTogYyxcbiAgICAgICAgcmVtb3RlSW5mbzogdGhpcy5yZW1vdGVJbmZvLFxuICAgICAgICBvcmlnaW46IHRoaXMuaG9zdFxuICAgICAgfSk7XG4gICAgICBhd2FpdCBuLmluaXQodS5zaGFyZVNjb3BlLCB1LmluaXRTY29wZSwgdS5yZW1vdGVFbnRyeUluaXRPcHRpb25zKSwgYXdhaXQgdGhpcy5ob3N0Lmhvb2tzLmxpZmVjeWNsZS5pbml0Q29udGFpbmVyLmVtaXQoX2V4dGVuZHMkNCh7fSwgdSwge1xuICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHM6IG5cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgdGhpcy5saWIgPSBuLCB0aGlzLmluaXRlZCA9ICEwO1xuICAgIGNvbnN0IHIgPSBhd2FpdCBuLmdldCh0KTtcbiAgICByZXR1cm4gYXNzZXJ0KHIsIGAke2dldEZNSWQodGhpcy5yZW1vdGVJbmZvKX0gcmVtb3RlIGRvbid0IGV4cG9ydCAke3R9LmApLCBvID8gYXdhaXQgcigpIDogcjtcbiAgfVxuICBjb25zdHJ1Y3Rvcih7IHJlbW90ZUluZm86IHQsIGhvc3Q6IGUgfSkge1xuICAgIHRoaXMuaW5pdGVkID0gITEsIHRoaXMubGliID0gdm9pZCAwLCB0aGlzLnJlbW90ZUluZm8gPSB0LCB0aGlzLmhvc3QgPSBlO1xuICB9XG59O1xuY2xhc3MgU3luY0hvb2sge1xuICBvbihlKSB7XG4gICAgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIHRoaXMubGlzdGVuZXJzLmFkZChlKTtcbiAgfVxuICBvbmNlKGUpIHtcbiAgICBjb25zdCBvID0gdGhpcztcbiAgICB0aGlzLm9uKGZ1bmN0aW9uIG4oLi4ucikge1xuICAgICAgcmV0dXJuIG8ucmVtb3ZlKG4pLCBlLmFwcGx5KG51bGwsIHIpO1xuICAgIH0pO1xuICB9XG4gIGVtaXQoLi4uZSkge1xuICAgIGxldCBvO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5zaXplID4gMCAmJiB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBvID0gbiguLi5lKTtcbiAgICB9KSwgbztcbiAgfVxuICByZW1vdmUoZSkge1xuICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShlKTtcbiAgfVxuICByZW1vdmVBbGwoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy50eXBlID0gXCJcIiwgdGhpcy5saXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBlICYmICh0aGlzLnR5cGUgPSBlKTtcbiAgfVxufVxuY2xhc3MgQXN5bmNIb29rIGV4dGVuZHMgU3luY0hvb2sge1xuICBlbWl0KC4uLmUpIHtcbiAgICBsZXQgbztcbiAgICBjb25zdCBuID0gQXJyYXkuZnJvbSh0aGlzLmxpc3RlbmVycyk7XG4gICAgaWYgKG4ubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IHIgPSAwO1xuICAgICAgY29uc3QgaSA9IChhKSA9PiBhID09PSAhMSA/ICExIDogciA8IG4ubGVuZ3RoID8gUHJvbWlzZS5yZXNvbHZlKG5bcisrXS5hcHBseShudWxsLCBlKSkudGhlbihpKSA6IGE7XG4gICAgICBvID0gaSgpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG8pO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja1JldHVybkRhdGEodCwgZSkge1xuICBpZiAoIWlzT2JqZWN0KGUpKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHQgIT09IGUpIHtcbiAgICBmb3IgKGNvbnN0IG8gaW4gdClcbiAgICAgIGlmICghKG8gaW4gZSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5jbGFzcyBTeW5jV2F0ZXJmYWxsSG9vayBleHRlbmRzIFN5bmNIb29rIHtcbiAgZW1pdChlKSB7XG4gICAgaXNPYmplY3QoZSkgfHwgZXJyb3IoYFRoZSBkYXRhIGZvciB0aGUgXCIke3RoaXMudHlwZX1cIiBob29rIHNob3VsZCBiZSBhbiBvYmplY3QuYCk7XG4gICAgZm9yIChjb25zdCBvIG9mIHRoaXMubGlzdGVuZXJzKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbiA9IG8oZSk7XG4gICAgICAgIGlmIChjaGVja1JldHVybkRhdGEoZSwgbikpXG4gICAgICAgICAgZSA9IG47XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMub25lcnJvcihgQSBwbHVnaW4gcmV0dXJuZWQgYW4gdW5hY2NlcHRhYmxlIHZhbHVlIGZvciB0aGUgXCIke3RoaXMudHlwZX1cIiB0eXBlLmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHdhcm4kMShuKSwgdGhpcy5vbmVycm9yKG4pO1xuICAgICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLm9uZXJyb3IgPSBlcnJvciwgdGhpcy50eXBlID0gZTtcbiAgfVxufVxuY2xhc3MgQXN5bmNXYXRlcmZhbGxIb29rIGV4dGVuZHMgU3luY0hvb2sge1xuICBlbWl0KGUpIHtcbiAgICBpc09iamVjdChlKSB8fCBlcnJvcihgVGhlIHJlc3BvbnNlIGRhdGEgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIGhvb2sgbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgY29uc3QgbyA9IEFycmF5LmZyb20odGhpcy5saXN0ZW5lcnMpO1xuICAgIGlmIChvLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBuID0gMDtcbiAgICAgIGNvbnN0IHIgPSAoYSkgPT4gKHdhcm4kMShhKSwgdGhpcy5vbmVycm9yKGEpLCBlKSwgaSA9IChhKSA9PiB7XG4gICAgICAgIGlmIChjaGVja1JldHVybkRhdGEoZSwgYSkpIHtcbiAgICAgICAgICBpZiAoZSA9IGEsIG4gPCBvLmxlbmd0aClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob1tuKytdKGUpKS50aGVuKGksIHIpO1xuICAgICAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgICByZXR1cm4gcihzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdGhpcy5vbmVycm9yKGBBIHBsdWdpbiByZXR1cm5lZCBhbiBpbmNvcnJlY3QgdmFsdWUgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIHR5cGUuYCk7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaShlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZSk7XG4gIH1cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIHRoaXMub25lcnJvciA9IGVycm9yLCB0aGlzLnR5cGUgPSBlO1xuICB9XG59XG5jbGFzcyBQbHVnaW5TeXN0ZW0ge1xuICBhcHBseVBsdWdpbihlKSB7XG4gICAgYXNzZXJ0KGlzUGxhaW5PYmplY3QoZSksIFwiUGx1Z2luIGNvbmZpZ3VyYXRpb24gaXMgaW52YWxpZC5cIik7XG4gICAgY29uc3QgbyA9IGUubmFtZTtcbiAgICBhc3NlcnQobywgXCJBIG5hbWUgbXVzdCBiZSBwcm92aWRlZCBieSB0aGUgcGx1Z2luLlwiKSwgdGhpcy5yZWdpc3RlclBsdWdpbnNbb10gfHwgKHRoaXMucmVnaXN0ZXJQbHVnaW5zW29dID0gZSwgT2JqZWN0LmtleXModGhpcy5saWZlY3ljbGUpLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBlW25dO1xuICAgICAgciAmJiB0aGlzLmxpZmVjeWNsZVtuXS5vbihyKTtcbiAgICB9KSk7XG4gIH1cbiAgcmVtb3ZlUGx1Z2luKGUpIHtcbiAgICBhc3NlcnQoZSwgXCJBIG5hbWUgaXMgcmVxdWlyZWQuXCIpO1xuICAgIGNvbnN0IG8gPSB0aGlzLnJlZ2lzdGVyUGx1Z2luc1tlXTtcbiAgICBhc3NlcnQobywgYFRoZSBwbHVnaW4gXCIke2V9XCIgaXMgbm90IHJlZ2lzdGVyZWQuYCksIE9iamVjdC5rZXlzKG8pLmZvckVhY2goKG4pID0+IHtcbiAgICAgIG4gIT09IFwibmFtZVwiICYmIHRoaXMubGlmZWN5Y2xlW25dLnJlbW92ZShvW25dKTtcbiAgICB9KTtcbiAgfVxuICBpbmhlcml0KHsgbGlmZWN5Y2xlOiBlLCByZWdpc3RlclBsdWdpbnM6IG8gfSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGFzc2VydCghdGhpcy5saWZlY3ljbGVbbl0sIGBUaGUgaG9vayBcIiR7bn1cIiBoYXMgYSBjb25mbGljdCBhbmQgY2Fubm90IGJlIGluaGVyaXRlZC5gKSwgdGhpcy5saWZlY3ljbGVbbl0gPSBlW25dO1xuICAgIH0pLCBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBhc3NlcnQoIXRoaXMucmVnaXN0ZXJQbHVnaW5zW25dLCBgVGhlIHBsdWdpbiBcIiR7bn1cIiBoYXMgYSBjb25mbGljdCBhbmQgY2Fubm90IGJlIGluaGVyaXRlZC5gKSwgdGhpcy5hcHBseVBsdWdpbihvW25dKTtcbiAgICB9KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5yZWdpc3RlclBsdWdpbnMgPSB7fSwgdGhpcy5saWZlY3ljbGUgPSBlLCB0aGlzLmxpZmVjeWNsZUtleXMgPSBPYmplY3Qua2V5cyhlKTtcbiAgfVxufVxuZnVuY3Rpb24gX2V4dGVuZHMkMygpIHtcbiAgcmV0dXJuIF9leHRlbmRzJDMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBlID0gMTsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIG8gPSBhcmd1bWVudHNbZV07XG4gICAgICBmb3IgKHZhciBuIGluIG8pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBuKSAmJiAodFtuXSA9IG9bbl0pO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfSwgX2V4dGVuZHMkMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFByZWxvYWRBcmdzKHQpIHtcbiAgcmV0dXJuIF9leHRlbmRzJDMoe1xuICAgIHJlc291cmNlQ2F0ZWdvcnk6IFwic3luY1wiLFxuICAgIHNoYXJlOiAhMCxcbiAgICBkZXBzUmVtb3RlOiAhMCxcbiAgICBwcmVmZXRjaEludGVyZmFjZTogITFcbiAgfSwgdCk7XG59XG5mdW5jdGlvbiBmb3JtYXRQcmVsb2FkQXJncyh0LCBlKSB7XG4gIHJldHVybiBlLm1hcCgobykgPT4ge1xuICAgIGNvbnN0IG4gPSBtYXRjaFJlbW90ZSh0LCBvLm5hbWVPckFsaWFzKTtcbiAgICByZXR1cm4gYXNzZXJ0KG4sIGBVbmFibGUgdG8gcHJlbG9hZCAke28ubmFtZU9yQWxpYXN9IGFzIGl0IGlzIG5vdCBpbmNsdWRlZCBpbiAkeyFuICYmIHNhZmVUb1N0cmluZyQxKHtcbiAgICAgIHJlbW90ZUluZm86IG4sXG4gICAgICByZW1vdGVzOiB0XG4gICAgfSl9YCksIHtcbiAgICAgIHJlbW90ZTogbixcbiAgICAgIHByZWxvYWRDb25maWc6IGRlZmF1bHRQcmVsb2FkQXJncyhvKVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJlbG9hZEV4cG9zZXModCkge1xuICByZXR1cm4gdCA/IHQubWFwKChlKSA9PiBlID09PSBcIi5cIiA/IGUgOiBlLnN0YXJ0c1dpdGgoXCIuL1wiKSA/IGUucmVwbGFjZShcIi4vXCIsIFwiXCIpIDogZSkgOiBbXTtcbn1cbmZ1bmN0aW9uIHByZWxvYWRBc3NldHModCwgZSwgbykge1xuICBjb25zdCB7IGNzc0Fzc2V0czogbiwganNBc3NldHNXaXRob3V0RW50cnk6IHIsIGVudHJ5QXNzZXRzOiBpIH0gPSBvO1xuICBpZiAoZS5vcHRpb25zLmluQnJvd3Nlcikge1xuICAgIGkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgY29uc3QgeyBtb2R1bGVJbmZvOiBjIH0gPSBzLCBsID0gZS5tb2R1bGVDYWNoZS5nZXQodC5uYW1lKTtcbiAgICAgIGdldFJlbW90ZUVudHJ5KGwgPyB7XG4gICAgICAgIHJlbW90ZUluZm86IGMsXG4gICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0czogbC5yZW1vdGVFbnRyeUV4cG9ydHMsXG4gICAgICAgIGNyZWF0ZVNjcmlwdEhvb2s6ICh1KSA9PiB7XG4gICAgICAgICAgY29uc3QgaCA9IGUubG9hZGVySG9vay5saWZlY3ljbGUuY3JlYXRlU2NyaXB0LmVtaXQoe1xuICAgICAgICAgICAgdXJsOiB1XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGggaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudClcbiAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICB9XG4gICAgICB9IDoge1xuICAgICAgICByZW1vdGVJbmZvOiBjLFxuICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHM6IHZvaWQgMCxcbiAgICAgICAgY3JlYXRlU2NyaXB0SG9vazogKHUpID0+IHtcbiAgICAgICAgICBjb25zdCBoID0gZS5sb2FkZXJIb29rLmxpZmVjeWNsZS5jcmVhdGVTY3JpcHQuZW1pdCh7XG4gICAgICAgICAgICB1cmw6IHVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaCBpbnN0YW5jZW9mIEhUTUxTY3JpcHRFbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgbi5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBjb25zdCB7IGxpbms6IGMsIG5lZWRBdHRhY2g6IGwgfSA9IGNyZWF0ZUxpbmsocywgKCkgPT4ge1xuICAgICAgfSwge1xuICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICBhczogXCJzdHlsZVwiXG4gICAgICB9LCAodSkgPT4ge1xuICAgICAgICBjb25zdCBoID0gZS5sb2FkZXJIb29rLmxpZmVjeWNsZS5jcmVhdGVMaW5rLmVtaXQoe1xuICAgICAgICAgIHVybDogdVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGggaW5zdGFuY2VvZiBIVE1MTGlua0VsZW1lbnQpXG4gICAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9KTtcbiAgICAgIGwgJiYgYS5hcHBlbmRDaGlsZChjKTtcbiAgICB9KSwgci5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBjb25zdCB7IGxpbms6IGMsIG5lZWRBdHRhY2g6IGwgfSA9IGNyZWF0ZUxpbmsocywgKCkgPT4ge1xuICAgICAgfSwge1xuICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICBhczogXCJzY3JpcHRcIlxuICAgICAgfSwgKHUpID0+IHtcbiAgICAgICAgY29uc3QgaCA9IGUubG9hZGVySG9vay5saWZlY3ljbGUuY3JlYXRlTGluay5lbWl0KHtcbiAgICAgICAgICB1cmw6IHVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoIGluc3RhbmNlb2YgSFRNTExpbmtFbGVtZW50KVxuICAgICAgICAgIHJldHVybiBoO1xuICAgICAgfSk7XG4gICAgICBsICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoYyk7XG4gICAgfSksIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoYSk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9leHRlbmRzJDIoKSB7XG4gIHJldHVybiBfZXh0ZW5kcyQyID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciBvID0gYXJndW1lbnRzW2VdO1xuICAgICAgZm9yICh2YXIgbiBpbiBvKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgbikgJiYgKHRbbl0gPSBvW25dKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH0sIF9leHRlbmRzJDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGFzc2lnblJlbW90ZUluZm8odCwgZSkge1xuICAoIShcInJlbW90ZUVudHJ5XCIgaW4gZSkgfHwgIWUucmVtb3RlRW50cnkpICYmIGVycm9yKGBUaGUgYXR0cmlidXRlIHJlbW90ZUVudHJ5IG9mICR7bmFtZX0gbXVzdCBub3QgYmUgdW5kZWZpbmVkLmApO1xuICBjb25zdCB7IHJlbW90ZUVudHJ5OiBvIH0gPSBlLCBuID0gZ2V0UmVzb3VyY2VVcmwoZSwgbyk7XG4gIHQudHlwZSA9IGUucmVtb3RlRW50cnlUeXBlLCB0LmVudHJ5R2xvYmFsTmFtZSA9IGUuZ2xvYmFsTmFtZSwgdC5lbnRyeSA9IG4sIHQudmVyc2lvbiA9IGUudmVyc2lvbiwgdC5idWlsZFZlcnNpb24gPSBlLmJ1aWxkVmVyc2lvbjtcbn1cbmZ1bmN0aW9uIHNuYXBzaG90UGx1Z2luKCkge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IFwic25hcHNob3QtcGx1Z2luXCIsXG4gICAgYXN5bmMgYWZ0ZXJSZXNvbHZlKHQpIHtcbiAgICAgIGNvbnN0IHsgcmVtb3RlOiBlLCBwa2dOYW1lT3JBbGlhczogbywgZXhwb3NlOiBuLCBvcmlnaW46IHIsIHJlbW90ZUluZm86IGkgfSA9IHQ7XG4gICAgICBpZiAoIWlzUmVtb3RlSW5mb1dpdGhFbnRyeShlKSB8fCAhaXNQdXJlUmVtb3RlRW50cnkoZSkpIHtcbiAgICAgICAgY29uc3QgeyByZW1vdGVTbmFwc2hvdDogYSwgZ2xvYmFsU25hcHNob3Q6IHMgfSA9IGF3YWl0IHIuc25hcHNob3RIYW5kbGVyLmxvYWRSZW1vdGVTbmFwc2hvdEluZm8oZSk7XG4gICAgICAgIGFzc2lnblJlbW90ZUluZm8oaSwgYSk7XG4gICAgICAgIGNvbnN0IGMgPSB7XG4gICAgICAgICAgcmVtb3RlOiBlLFxuICAgICAgICAgIHByZWxvYWRDb25maWc6IHtcbiAgICAgICAgICAgIG5hbWVPckFsaWFzOiBvLFxuICAgICAgICAgICAgZXhwb3NlczogW1xuICAgICAgICAgICAgICBuXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcmVzb3VyY2VDYXRlZ29yeTogXCJzeW5jXCIsXG4gICAgICAgICAgICBzaGFyZTogITEsXG4gICAgICAgICAgICBkZXBzUmVtb3RlOiAhMVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgbCA9IGF3YWl0IHIuaG9va3MubGlmZWN5Y2xlLmdlbmVyYXRlUHJlbG9hZEFzc2V0cy5lbWl0KHtcbiAgICAgICAgICBvcmlnaW46IHIsXG4gICAgICAgICAgcHJlbG9hZE9wdGlvbnM6IGMsXG4gICAgICAgICAgcmVtb3RlSW5mbzogaSxcbiAgICAgICAgICByZW1vdGU6IGUsXG4gICAgICAgICAgcmVtb3RlU25hcHNob3Q6IGEsXG4gICAgICAgICAgZ2xvYmFsU25hcHNob3Q6IHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsICYmIHByZWxvYWRBc3NldHMoaSwgciwgbCksIF9leHRlbmRzJDIoe30sIHQsIHtcbiAgICAgICAgICByZW1vdGVTbmFwc2hvdDogYVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0SWQodCkge1xuICBjb25zdCBlID0gdC5zcGxpdChcIjpcIik7XG4gIHJldHVybiBlLmxlbmd0aCA9PT0gMSA/IHtcbiAgICBuYW1lOiBlWzBdLFxuICAgIHZlcnNpb246IHZvaWQgMFxuICB9IDogZS5sZW5ndGggPT09IDIgPyB7XG4gICAgbmFtZTogZVswXSxcbiAgICB2ZXJzaW9uOiBlWzFdXG4gIH0gOiB7XG4gICAgbmFtZTogZVsxXSxcbiAgICB2ZXJzaW9uOiBlWzJdXG4gIH07XG59XG5mdW5jdGlvbiB0cmF2ZXJzZU1vZHVsZUluZm8odCwgZSwgbywgbiwgciA9IHt9LCBpKSB7XG4gIGNvbnN0IGEgPSBnZXRGTUlkKGUpLCB7IHZhbHVlOiBzIH0gPSBnZXRJbmZvV2l0aG91dFR5cGUodCwgYSksIGMgPSBpIHx8IHM7XG4gIGlmIChjICYmICFpc01hbmlmZXN0UHJvdmlkZXIoYykgJiYgKG8oYywgZSwgbiksIGMucmVtb3Rlc0luZm8pKSB7XG4gICAgY29uc3QgbCA9IE9iamVjdC5rZXlzKGMucmVtb3Rlc0luZm8pO1xuICAgIGZvciAoY29uc3QgdSBvZiBsKSB7XG4gICAgICBpZiAoclt1XSlcbiAgICAgICAgY29udGludWU7XG4gICAgICByW3VdID0gITA7XG4gICAgICBjb25zdCBoID0gc3BsaXRJZCh1KSwgZyA9IGMucmVtb3Rlc0luZm9bdV07XG4gICAgICB0cmF2ZXJzZU1vZHVsZUluZm8odCwge1xuICAgICAgICBuYW1lOiBoLm5hbWUsXG4gICAgICAgIHZlcnNpb246IGcubWF0Y2hlZFZlcnNpb25cbiAgICAgIH0sIG8sICExLCByLCB2b2lkIDApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2VuZXJhdGVQcmVsb2FkQXNzZXRzKHQsIGUsIG8sIG4sIHIpIHtcbiAgY29uc3QgaSA9IFtdLCBhID0gW10sIHMgPSBbXSwgYyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIGwgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCB7IG9wdGlvbnM6IHUgfSA9IHQsIHsgcHJlbG9hZENvbmZpZzogaCB9ID0gZSwgeyBkZXBzUmVtb3RlOiBnIH0gPSBoO1xuICB0cmF2ZXJzZU1vZHVsZUluZm8obiwgbywgKGQsIG0sIE0pID0+IHtcbiAgICBsZXQgSTtcbiAgICBpZiAoTSlcbiAgICAgIEkgPSBoO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZykpIHtcbiAgICAgIGNvbnN0IHkgPSBnLmZpbmQoKEEpID0+IEEubmFtZU9yQWxpYXMgPT09IG0ubmFtZSB8fCBBLm5hbWVPckFsaWFzID09PSBtLmFsaWFzKTtcbiAgICAgIGlmICgheSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgSSA9IGRlZmF1bHRQcmVsb2FkQXJncyh5KTtcbiAgICB9IGVsc2UgaWYgKGcgPT09ICEwKVxuICAgICAgSSA9IGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IEQgPSBnZXRSZXNvdXJjZVVybChkLCBcInJlbW90ZUVudHJ5XCIgaW4gZCA/IGQucmVtb3RlRW50cnkgOiBcIlwiKTtcbiAgICBEICYmIHMucHVzaCh7XG4gICAgICBuYW1lOiBtLm5hbWUsXG4gICAgICBtb2R1bGVJbmZvOiB7XG4gICAgICAgIG5hbWU6IG0ubmFtZSxcbiAgICAgICAgZW50cnk6IEQsXG4gICAgICAgIHR5cGU6IFwicmVtb3RlRW50cnlUeXBlXCIgaW4gZCA/IGQucmVtb3RlRW50cnlUeXBlIDogXCJnbG9iYWxcIixcbiAgICAgICAgZW50cnlHbG9iYWxOYW1lOiBcImdsb2JhbE5hbWVcIiBpbiBkID8gZC5nbG9iYWxOYW1lIDogbS5uYW1lLFxuICAgICAgICBzaGFyZVNjb3BlOiBcIlwiLFxuICAgICAgICB2ZXJzaW9uOiBcInZlcnNpb25cIiBpbiBkID8gZC52ZXJzaW9uIDogdm9pZCAwXG4gICAgICB9LFxuICAgICAgdXJsOiBEXG4gICAgfSk7XG4gICAgbGV0IFMgPSBcIm1vZHVsZXNcIiBpbiBkID8gZC5tb2R1bGVzIDogW107XG4gICAgY29uc3QgTyA9IG5vcm1hbGl6ZVByZWxvYWRFeHBvc2VzKEkuZXhwb3Nlcyk7XG4gICAgaWYgKE8ubGVuZ3RoICYmIFwibW9kdWxlc1wiIGluIGQpIHtcbiAgICAgIHZhciBMO1xuICAgICAgUyA9IGQgPT0gbnVsbCB8fCAoTCA9IGQubW9kdWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IEwucmVkdWNlKCh5LCBBKSA9PiAoTz8uaW5kZXhPZihBLm1vZHVsZU5hbWUpICE9PSAtMSAmJiB5LnB1c2goQSksIHkpLCBbXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHYoeSkge1xuICAgICAgY29uc3QgQSA9IHkubWFwKChiKSA9PiBnZXRSZXNvdXJjZVVybChkLCBiKSk7XG4gICAgICByZXR1cm4gSS5maWx0ZXIgPyBBLmZpbHRlcihJLmZpbHRlcikgOiBBO1xuICAgIH1cbiAgICBpZiAoUykge1xuICAgICAgY29uc3QgeSA9IFMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgQSA9IDA7IEEgPCB5OyBBKyspIHtcbiAgICAgICAgY29uc3QgYiA9IFNbQV0sIHggPSBgJHttLm5hbWV9LyR7Yi5tb2R1bGVOYW1lfWA7XG4gICAgICAgIHQuaG9va3MubGlmZWN5Y2xlLmhhbmRsZVByZWxvYWRNb2R1bGUuZW1pdCh7XG4gICAgICAgICAgaWQ6IGIubW9kdWxlTmFtZSA9PT0gXCIuXCIgPyBtLm5hbWUgOiB4LFxuICAgICAgICAgIG5hbWU6IG0ubmFtZSxcbiAgICAgICAgICByZW1vdGVTbmFwc2hvdDogZCxcbiAgICAgICAgICBwcmVsb2FkQ29uZmlnOiBJLFxuICAgICAgICAgIHJlbW90ZTogbSxcbiAgICAgICAgICBvcmlnaW46IHRcbiAgICAgICAgfSksICFnZXRQcmVsb2FkZWQoeCkgJiYgKEkucmVzb3VyY2VDYXRlZ29yeSA9PT0gXCJhbGxcIiA/IChpLnB1c2goLi4udihiLmFzc2V0cy5jc3MuYXN5bmMpKSwgaS5wdXNoKC4uLnYoYi5hc3NldHMuY3NzLnN5bmMpKSwgYS5wdXNoKC4uLnYoYi5hc3NldHMuanMuYXN5bmMpKSwgYS5wdXNoKC4uLnYoYi5hc3NldHMuanMuc3luYykpKSA6IChJLnJlc291cmNlQ2F0ZWdvcnkgPSBcInN5bmNcIikgJiYgKGkucHVzaCguLi52KGIuYXNzZXRzLmNzcy5zeW5jKSksIGEucHVzaCguLi52KGIuYXNzZXRzLmpzLnN5bmMpKSksIHNldFByZWxvYWRlZCh4KSk7XG4gICAgICB9XG4gICAgfVxuICB9LCAhMCwge30sIHIpLCByLnNoYXJlZCAmJiByLnNoYXJlZC5mb3JFYWNoKChkKSA9PiB7XG4gICAgdmFyIG07XG4gICAgY29uc3QgTSA9IChtID0gdS5zaGFyZWQpID09IG51bGwgPyB2b2lkIDAgOiBtW2Quc2hhcmVkTmFtZV07XG4gICAgaWYgKCFNKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IEkgPSBnZXRSZWdpc3RlcmVkU2hhcmUodC5zaGFyZVNjb3BlTWFwLCBkLnNoYXJlZE5hbWUsIE0sIHQuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgSSAmJiB0eXBlb2YgSS5saWIgPT0gXCJmdW5jdGlvblwiICYmIChkLmFzc2V0cy5qcy5zeW5jLmZvckVhY2goKEQpID0+IHtcbiAgICAgIGMuYWRkKEQpO1xuICAgIH0pLCBkLmFzc2V0cy5jc3Muc3luYy5mb3JFYWNoKChEKSA9PiB7XG4gICAgICBsLmFkZChEKTtcbiAgICB9KSk7XG4gIH0pO1xuICBjb25zdCBwID0gYS5maWx0ZXIoKGQpID0+ICFjLmhhcyhkKSk7XG4gIHJldHVybiB7XG4gICAgY3NzQXNzZXRzOiBpLmZpbHRlcigoZCkgPT4gIWwuaGFzKGQpKSxcbiAgICBqc0Fzc2V0c1dpdGhvdXRFbnRyeTogcCxcbiAgICBlbnRyeUFzc2V0czogc1xuICB9O1xufVxuY29uc3QgZ2VuZXJhdGVQcmVsb2FkQXNzZXRzUGx1Z2luID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJnZW5lcmF0ZS1wcmVsb2FkLWFzc2V0cy1wbHVnaW5cIixcbiAgICBhc3luYyBnZW5lcmF0ZVByZWxvYWRBc3NldHModCkge1xuICAgICAgY29uc3QgeyBvcmlnaW46IGUsIHByZWxvYWRPcHRpb25zOiBvLCByZW1vdGVJbmZvOiBuLCByZW1vdGU6IHIsIGdsb2JhbFNuYXBzaG90OiBpLCByZW1vdGVTbmFwc2hvdDogYSB9ID0gdDtcbiAgICAgIHJldHVybiBpc1JlbW90ZUluZm9XaXRoRW50cnkocikgJiYgaXNQdXJlUmVtb3RlRW50cnkocikgPyB7XG4gICAgICAgIGNzc0Fzc2V0czogW10sXG4gICAgICAgIGpzQXNzZXRzV2l0aG91dEVudHJ5OiBbXSxcbiAgICAgICAgZW50cnlBc3NldHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiByLm5hbWUsXG4gICAgICAgICAgICB1cmw6IHIuZW50cnksXG4gICAgICAgICAgICBtb2R1bGVJbmZvOiB7XG4gICAgICAgICAgICAgIG5hbWU6IG4ubmFtZSxcbiAgICAgICAgICAgICAgZW50cnk6IHIuZW50cnksXG4gICAgICAgICAgICAgIHR5cGU6IFwiZ2xvYmFsXCIsXG4gICAgICAgICAgICAgIGVudHJ5R2xvYmFsTmFtZTogXCJcIixcbiAgICAgICAgICAgICAgc2hhcmVTY29wZTogXCJcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSA6IChhc3NpZ25SZW1vdGVJbmZvKG4sIGEpLCBnZW5lcmF0ZVByZWxvYWRBc3NldHMoZSwgbywgbiwgaSwgYSkpO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBfZXh0ZW5kcyQxKCkge1xuICByZXR1cm4gX2V4dGVuZHMkMSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgbyA9IGFyZ3VtZW50c1tlXTtcbiAgICAgIGZvciAodmFyIG4gaW4gbylcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIG4pICYmICh0W25dID0gb1tuXSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9LCBfZXh0ZW5kcyQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5jbGFzcyBTbmFwc2hvdEhhbmRsZXIge1xuICBhc3luYyBsb2FkU25hcHNob3QoZSkge1xuICAgIGNvbnN0IHsgb3B0aW9uczogbyB9ID0gdGhpcy5Ib3N0SW5zdGFuY2UsIHsgaG9zdEdsb2JhbFNuYXBzaG90OiBuLCByZW1vdGVTbmFwc2hvdDogciwgZ2xvYmFsU25hcHNob3Q6IGkgfSA9IHRoaXMuZ2V0R2xvYmFsUmVtb3RlSW5mbyhlKSwgeyByZW1vdGVTbmFwc2hvdDogYSwgZ2xvYmFsU25hcHNob3Q6IHMgfSA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmxvYWRTbmFwc2hvdC5lbWl0KHtcbiAgICAgIG9wdGlvbnM6IG8sXG4gICAgICBtb2R1bGVJbmZvOiBlLFxuICAgICAgaG9zdEdsb2JhbFNuYXBzaG90OiBuLFxuICAgICAgcmVtb3RlU25hcHNob3Q6IHIsXG4gICAgICBnbG9iYWxTbmFwc2hvdDogaVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZW1vdGVTbmFwc2hvdDogYSxcbiAgICAgIGdsb2JhbFNuYXBzaG90OiBzXG4gICAgfTtcbiAgfVxuICBhc3luYyBsb2FkUmVtb3RlU25hcHNob3RJbmZvKGUpIHtcbiAgICBjb25zdCB7IG9wdGlvbnM6IG8gfSA9IHRoaXMuSG9zdEluc3RhbmNlO1xuICAgIGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZUxvYWRSZW1vdGVTbmFwc2hvdC5lbWl0KHtcbiAgICAgIG9wdGlvbnM6IG8sXG4gICAgICBtb2R1bGVJbmZvOiBlXG4gICAgfSk7XG4gICAgbGV0IG4gPSBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgbmFtZTogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy5uYW1lLFxuICAgICAgdmVyc2lvbjogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy52ZXJzaW9uXG4gICAgfSk7XG4gICAgbiB8fCAobiA9IHtcbiAgICAgIHZlcnNpb246IHRoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMudmVyc2lvbiB8fCBcIlwiLFxuICAgICAgcmVtb3RlRW50cnk6IFwiXCIsXG4gICAgICByZW1vdGVzSW5mbzoge31cbiAgICB9LCBhZGRHbG9iYWxTbmFwc2hvdCh7XG4gICAgICBbdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy5uYW1lXTogblxuICAgIH0pKSwgbiAmJiBcInJlbW90ZXNJbmZvXCIgaW4gbiAmJiAhZ2V0SW5mb1dpdGhvdXRUeXBlKG4ucmVtb3Rlc0luZm8sIGUubmFtZSkudmFsdWUgJiYgKFwidmVyc2lvblwiIGluIGUgfHwgXCJlbnRyeVwiIGluIGUpICYmIChuLnJlbW90ZXNJbmZvID0gX2V4dGVuZHMkMSh7fSwgbj8ucmVtb3Rlc0luZm8sIHtcbiAgICAgIFtlLm5hbWVdOiB7XG4gICAgICAgIG1hdGNoZWRWZXJzaW9uOiBcInZlcnNpb25cIiBpbiBlID8gZS52ZXJzaW9uIDogZS5lbnRyeVxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCB7IGhvc3RHbG9iYWxTbmFwc2hvdDogciwgcmVtb3RlU25hcHNob3Q6IGksIGdsb2JhbFNuYXBzaG90OiBhIH0gPSB0aGlzLmdldEdsb2JhbFJlbW90ZUluZm8oZSksIHsgcmVtb3RlU25hcHNob3Q6IHMsIGdsb2JhbFNuYXBzaG90OiBjIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkU25hcHNob3QuZW1pdCh7XG4gICAgICBvcHRpb25zOiBvLFxuICAgICAgbW9kdWxlSW5mbzogZSxcbiAgICAgIGhvc3RHbG9iYWxTbmFwc2hvdDogcixcbiAgICAgIHJlbW90ZVNuYXBzaG90OiBpLFxuICAgICAgZ2xvYmFsU25hcHNob3Q6IGFcbiAgICB9KTtcbiAgICBpZiAocylcbiAgICAgIGlmIChpc01hbmlmZXN0UHJvdmlkZXIocykpIHtcbiAgICAgICAgY29uc3QgbCA9IGF3YWl0IHRoaXMuZ2V0TWFuaWZlc3RKc29uKHMucmVtb3RlRW50cnksIGUsIHt9KSwgdSA9IHNldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyhfZXh0ZW5kcyQxKHt9LCBlLCB7XG4gICAgICAgICAgZW50cnk6IHMucmVtb3RlRW50cnlcbiAgICAgICAgfSksIGwpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiBsLFxuICAgICAgICAgIGdsb2JhbFNuYXBzaG90OiB1XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90OiBsIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkUmVtb3RlU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgb3B0aW9uczogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucyxcbiAgICAgICAgICBtb2R1bGVJbmZvOiBlLFxuICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiBzLFxuICAgICAgICAgIGZyb206IFwiZ2xvYmFsXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVtb3RlU25hcHNob3Q6IGwsXG4gICAgICAgICAgZ2xvYmFsU25hcHNob3Q6IGNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBlbHNlIGlmIChpc1JlbW90ZUluZm9XaXRoRW50cnkoZSkpIHtcbiAgICAgIGNvbnN0IGwgPSBhd2FpdCB0aGlzLmdldE1hbmlmZXN0SnNvbihlLmVudHJ5LCBlLCB7fSksIHUgPSBzZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oZSwgbCksIHsgcmVtb3RlU25hcHNob3Q6IGggfSA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmxvYWRSZW1vdGVTbmFwc2hvdC5lbWl0KHtcbiAgICAgICAgb3B0aW9uczogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucyxcbiAgICAgICAgbW9kdWxlSW5mbzogZSxcbiAgICAgICAgcmVtb3RlU25hcHNob3Q6IGwsXG4gICAgICAgIGZyb206IFwiZ2xvYmFsXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3RlU25hcHNob3Q6IGgsXG4gICAgICAgIGdsb2JhbFNuYXBzaG90OiB1XG4gICAgICB9O1xuICAgIH0gZWxzZVxuICAgICAgZXJyb3IoYFxuICAgICAgICAgIENhbm5vdCBnZXQgcmVtb3RlU25hcHNob3Qgd2l0aCB0aGUgbmFtZTogJyR7ZS5uYW1lfScsIHZlcnNpb246ICcke2UudmVyc2lvbn0nIGZyb20gX19GRURFUkFUSU9OX18ubW9kdWxlSW5mby4gVGhlIGZvbGxvd2luZyByZWFzb25zIG1heSBiZSBjYXVzaW5nIHRoZSBwcm9ibGVtOlxuXG4gICAgICAgICAgMS4gVGhlIERlcGxveSBwbGF0Zm9ybSBkaWQgbm90IGRlbGl2ZXIgdGhlIGNvcnJlY3QgZGF0YS4gWW91IGNhbiB1c2UgX19GRURFUkFUSU9OX18ubW9kdWxlSW5mbyB0byBjaGVjayB0aGUgcmVtb3RlSW5mby5cblxuICAgICAgICAgIDIuIFRoZSByZW1vdGUgJyR7ZS5uYW1lfScgdmVyc2lvbiAnJHtlLnZlcnNpb259JyBpcyBub3QgcmVsZWFzZWQuXG5cbiAgICAgICAgICBUaGUgdHJhbnNmb3JtZWQgbW9kdWxlIGluZm86ICR7SlNPTi5zdHJpbmdpZnkoYyl9XG4gICAgICAgIGApO1xuICB9XG4gIGdldEdsb2JhbFJlbW90ZUluZm8oZSkge1xuICAgIGNvbnN0IG8gPSBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgbmFtZTogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy5uYW1lLFxuICAgICAgdmVyc2lvbjogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy52ZXJzaW9uXG4gICAgfSksIG4gPSBvICYmIFwicmVtb3Rlc0luZm9cIiBpbiBvICYmIG8ucmVtb3Rlc0luZm8gJiYgZ2V0SW5mb1dpdGhvdXRUeXBlKG8ucmVtb3Rlc0luZm8sIGUubmFtZSkudmFsdWU7XG4gICAgcmV0dXJuIG4gJiYgbi5tYXRjaGVkVmVyc2lvbiA/IHtcbiAgICAgIGhvc3RHbG9iYWxTbmFwc2hvdDogbyxcbiAgICAgIGdsb2JhbFNuYXBzaG90OiBnZXRHbG9iYWxTbmFwc2hvdCgpLFxuICAgICAgcmVtb3RlU25hcHNob3Q6IGdldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyh7XG4gICAgICAgIG5hbWU6IGUubmFtZSxcbiAgICAgICAgdmVyc2lvbjogbi5tYXRjaGVkVmVyc2lvblxuICAgICAgfSlcbiAgICB9IDoge1xuICAgICAgaG9zdEdsb2JhbFNuYXBzaG90OiB2b2lkIDAsXG4gICAgICBnbG9iYWxTbmFwc2hvdDogZ2V0R2xvYmFsU25hcHNob3QoKSxcbiAgICAgIHJlbW90ZVNuYXBzaG90OiBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgICBuYW1lOiBlLm5hbWUsXG4gICAgICAgIHZlcnNpb246IFwidmVyc2lvblwiIGluIGUgPyBlLnZlcnNpb24gOiB2b2lkIDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBhc3luYyBnZXRNYW5pZmVzdEpzb24oZSwgbywgbikge1xuICAgIGNvbnN0IHIgPSBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYSA9IHRoaXMubWFuaWZlc3RDYWNoZS5nZXQoZSk7XG4gICAgICBpZiAoYSlcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgcyA9IGF3YWl0IHRoaXMubG9hZGVySG9vay5saWZlY3ljbGUuZmV0Y2guZW1pdChlLCB7fSk7XG4gICAgICAgIHJldHVybiAoIXMgfHwgIShzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSAmJiAocyA9IGF3YWl0IGZldGNoKGUsIHt9KSksIGEgPSBhd2FpdCBzLmpzb24oKSwgYXNzZXJ0KGEubWV0YURhdGEgJiYgYS5leHBvc2VzICYmIGEuc2hhcmVkLCBgJHtlfSBpcyBub3QgYSBmZWRlcmF0aW9uIG1hbmlmZXN0YCksIHRoaXMubWFuaWZlc3RDYWNoZS5zZXQoZSwgYSksIGE7XG4gICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgIGVycm9yKGBGYWlsZWQgdG8gZ2V0IG1hbmlmZXN0SnNvbiBmb3IgJHtvLm5hbWV9LiBUaGUgbWFuaWZlc3QgVVJMIGlzICR7ZX0uIFBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgbWFuaWZlc3RVcmwgaXMgYWNjZXNzaWJsZS5cbiAgICAgICAgICBcbiBFcnJvciBtZXNzYWdlOlxuICAgICAgICAgIFxuICR7c31gKTtcbiAgICAgIH1cbiAgICB9LCBpID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYSA9IGF3YWl0IHIoKSwgcyA9IGdlbmVyYXRlU25hcHNob3RGcm9tTWFuaWZlc3QoYSwge1xuICAgICAgICB2ZXJzaW9uOiBlXG4gICAgICB9KSwgeyByZW1vdGVTbmFwc2hvdDogYyB9ID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUubG9hZFJlbW90ZVNuYXBzaG90LmVtaXQoe1xuICAgICAgICBvcHRpb25zOiB0aGlzLkhvc3RJbnN0YW5jZS5vcHRpb25zLFxuICAgICAgICBtb2R1bGVJbmZvOiBvLFxuICAgICAgICBtYW5pZmVzdEpzb246IGEsXG4gICAgICAgIHJlbW90ZVNuYXBzaG90OiBzLFxuICAgICAgICBtYW5pZmVzdFVybDogZSxcbiAgICAgICAgZnJvbTogXCJtYW5pZmVzdFwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMubWFuaWZlc3RMb2FkaW5nW2VdIHx8ICh0aGlzLm1hbmlmZXN0TG9hZGluZ1tlXSA9IGkoKS50aGVuKChhKSA9PiBhKSksIHRoaXMubWFuaWZlc3RMb2FkaW5nW2VdO1xuICB9XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmxvYWRpbmdIb3N0U25hcHNob3QgPSBudWxsLCB0aGlzLm1hbmlmZXN0Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLmhvb2tzID0gbmV3IFBsdWdpblN5c3RlbSh7XG4gICAgICBiZWZvcmVMb2FkUmVtb3RlU25hcHNob3Q6IG5ldyBBc3luY0hvb2soXCJiZWZvcmVMb2FkUmVtb3RlU25hcHNob3RcIiksXG4gICAgICBsb2FkU25hcHNob3Q6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soXCJsb2FkR2xvYmFsU25hcHNob3RcIiksXG4gICAgICBsb2FkUmVtb3RlU25hcHNob3Q6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soXCJsb2FkUmVtb3RlU25hcHNob3RcIilcbiAgICB9KSwgdGhpcy5tYW5pZmVzdExvYWRpbmcgPSBHbG9iYWwuX19GRURFUkFUSU9OX18uX19NQU5JRkVTVF9MT0FESU5HX18sIHRoaXMuSG9zdEluc3RhbmNlID0gZSwgdGhpcy5sb2FkZXJIb29rID0gZS5sb2FkZXJIb29rO1xuICB9XG59XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgcmV0dXJuIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciBvID0gYXJndW1lbnRzW2VdO1xuICAgICAgZm9yICh2YXIgbiBpbiBvKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgbikgJiYgKHRbbl0gPSBvW25dKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH0sIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSh0LCBlKSB7XG4gIGlmICh0ID09IG51bGwpXG4gICAgcmV0dXJuIHt9O1xuICB2YXIgbyA9IHt9LCBuID0gT2JqZWN0LmtleXModCksIHIsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKVxuICAgIHIgPSBuW2ldLCAhKGUuaW5kZXhPZihyKSA+PSAwKSAmJiAob1tyXSA9IHRbcl0pO1xuICByZXR1cm4gbztcbn1cbmNsYXNzIEZlZGVyYXRpb25Ib3N0IHtcbiAgX3NldEdsb2JhbFNoYXJlU2NvcGVNYXAoKSB7XG4gICAgY29uc3QgZSA9IGdldEdsb2JhbFNoYXJlU2NvcGUoKSwgbyA9IHRoaXMub3B0aW9ucy5pZCB8fCB0aGlzLm9wdGlvbnMubmFtZTtcbiAgICBvICYmICFlW29dICYmIChlW29dID0gdGhpcy5zaGFyZVNjb3BlTWFwKTtcbiAgfVxuICBpbml0T3B0aW9ucyhlKSB7XG4gICAgdGhpcy5yZWdpc3RlclBsdWdpbnMoZS5wbHVnaW5zKTtcbiAgICBjb25zdCBvID0gdGhpcy5mb3JtYXRPcHRpb25zKHRoaXMub3B0aW9ucywgZSk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucyA9IG8sIG87XG4gIH1cbiAgYXN5bmMgbG9hZFNoYXJlKGUsIG8pIHtcbiAgICB2YXIgbjtcbiAgICBjb25zdCByID0gT2JqZWN0LmFzc2lnbih7fSwgKG4gPSB0aGlzLm9wdGlvbnMuc2hhcmVkKSA9PSBudWxsID8gdm9pZCAwIDogbltlXSwgbyk7XG4gICAgciAhPSBudWxsICYmIHIuc2NvcGUgJiYgYXdhaXQgUHJvbWlzZS5hbGwoci5zY29wZS5tYXAoYXN5bmMgKGwpID0+IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaW5pdGlhbGl6ZVNoYXJpbmcobCwgci5zdHJhdGVneSkpO1xuICAgIH0pKTtcbiAgICBjb25zdCBpID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuYmVmb3JlTG9hZFNoYXJlLmVtaXQoe1xuICAgICAgcGtnTmFtZTogZSxcbiAgICAgIHNoYXJlSW5mbzogcixcbiAgICAgIHNoYXJlZDogdGhpcy5vcHRpb25zLnNoYXJlZCxcbiAgICAgIG9yaWdpbjogdGhpc1xuICAgIH0pLCB7IHNoYXJlSW5mbzogYSB9ID0gaTtcbiAgICBhc3NlcnQoYSwgYENhbm5vdCBmaW5kICR7ZX0gU2hhcmUgaW4gdGhlICR7dGhpcy5vcHRpb25zLm5hbWV9LiBQbGVhc2UgZW5zdXJlIHRoYXQgdGhlICR7ZX0gU2hhcmUgcGFyYW1ldGVycyBoYXZlIGJlZW4gaW5qZWN0ZWRgKTtcbiAgICBjb25zdCBzID0gZ2V0UmVnaXN0ZXJlZFNoYXJlKHRoaXMuc2hhcmVTY29wZU1hcCwgZSwgYSwgdGhpcy5ob29rcy5saWZlY3ljbGUucmVzb2x2ZVNoYXJlKSwgYyA9IChsKSA9PiB7XG4gICAgICBsLnVzZUluIHx8IChsLnVzZUluID0gW10pLCBhZGRVbmlxdWVJdGVtKGwudXNlSW4sIHRoaXMub3B0aW9ucy5uYW1lKTtcbiAgICB9O1xuICAgIGlmIChzICYmIHMubGliKVxuICAgICAgcmV0dXJuIGMocyksIHMubGliO1xuICAgIGlmIChzICYmIHMubG9hZGluZyAmJiAhcy5sb2FkZWQpIHtcbiAgICAgIGNvbnN0IGwgPSBhd2FpdCBzLmxvYWRpbmc7XG4gICAgICByZXR1cm4gcy5sb2FkZWQgPSAhMCwgcy5saWIgfHwgKHMubGliID0gbCksIGMocyksIGw7XG4gICAgfSBlbHNlIGlmIChzKSB7XG4gICAgICBjb25zdCBsID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgdSA9IGF3YWl0IHMuZ2V0KCk7XG4gICAgICAgIGEubGliID0gdSwgYS5sb2FkZWQgPSAhMCwgYyhhKTtcbiAgICAgICAgY29uc3QgaCA9IGdldFJlZ2lzdGVyZWRTaGFyZSh0aGlzLnNoYXJlU2NvcGVNYXAsIGUsIGEsIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgICAgIHJldHVybiBoICYmIChoLmxpYiA9IHUsIGgubG9hZGVkID0gITApLCB1O1xuICAgICAgfSkoKTtcbiAgICAgIHJldHVybiB0aGlzLnNldFNoYXJlZCh7XG4gICAgICAgIHBrZ05hbWU6IGUsXG4gICAgICAgIGxvYWRlZDogITEsXG4gICAgICAgIHNoYXJlZDogcyxcbiAgICAgICAgZnJvbTogdGhpcy5vcHRpb25zLm5hbWUsXG4gICAgICAgIGxpYjogbnVsbCxcbiAgICAgICAgbG9hZGluZzogbFxuICAgICAgfSksIGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBsID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgdSA9IGF3YWl0IGEuZ2V0KCk7XG4gICAgICAgIGEubGliID0gdSwgYS5sb2FkZWQgPSAhMCwgYyhhKTtcbiAgICAgICAgY29uc3QgaCA9IGdldFJlZ2lzdGVyZWRTaGFyZSh0aGlzLnNoYXJlU2NvcGVNYXAsIGUsIGEsIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgICAgIHJldHVybiBoICYmIChoLmxpYiA9IHUsIGgubG9hZGVkID0gITApLCB1O1xuICAgICAgfSkoKTtcbiAgICAgIHJldHVybiB0aGlzLnNldFNoYXJlZCh7XG4gICAgICAgIHBrZ05hbWU6IGUsXG4gICAgICAgIGxvYWRlZDogITEsXG4gICAgICAgIHNoYXJlZDogYSxcbiAgICAgICAgZnJvbTogdGhpcy5vcHRpb25zLm5hbWUsXG4gICAgICAgIGxpYjogbnVsbCxcbiAgICAgICAgbG9hZGluZzogbFxuICAgICAgfSksIGw7XG4gICAgfVxuICB9XG4gIGxvYWRTaGFyZVN5bmMoZSwgbykge1xuICAgIHZhciBuO1xuICAgIGNvbnN0IHIgPSBPYmplY3QuYXNzaWduKHt9LCAobiA9IHRoaXMub3B0aW9ucy5zaGFyZWQpID09IG51bGwgPyB2b2lkIDAgOiBuW2VdLCBvKTtcbiAgICByICE9IG51bGwgJiYgci5zY29wZSAmJiByLnNjb3BlLmZvckVhY2goKHMpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVNoYXJpbmcocywgci5zdHJhdGVneSk7XG4gICAgfSk7XG4gICAgY29uc3QgaSA9IGdldFJlZ2lzdGVyZWRTaGFyZSh0aGlzLnNoYXJlU2NvcGVNYXAsIGUsIHIsIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSksIGEgPSAocykgPT4ge1xuICAgICAgcy51c2VJbiB8fCAocy51c2VJbiA9IFtdKSwgYWRkVW5pcXVlSXRlbShzLnVzZUluLCB0aGlzLm9wdGlvbnMubmFtZSk7XG4gICAgfTtcbiAgICBpZiAoaSkge1xuICAgICAgaWYgKHR5cGVvZiBpLmxpYiA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBhKGkpLCBpLmxvYWRlZCB8fCAoaS5sb2FkZWQgPSAhMCwgaS5mcm9tID09PSB0aGlzLm9wdGlvbnMubmFtZSAmJiAoci5sb2FkZWQgPSAhMCkpLCBpLmxpYjtcbiAgICAgIGlmICh0eXBlb2YgaS5nZXQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHMgPSBpLmdldCgpO1xuICAgICAgICBpZiAoIShzIGluc3RhbmNlb2YgUHJvbWlzZSkpXG4gICAgICAgICAgcmV0dXJuIGEoaSksIHRoaXMuc2V0U2hhcmVkKHtcbiAgICAgICAgICAgIHBrZ05hbWU6IGUsXG4gICAgICAgICAgICBsb2FkZWQ6ICEwLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICBsaWI6IHMsXG4gICAgICAgICAgICBzaGFyZWQ6IGlcbiAgICAgICAgICB9KSwgcztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHIubGliKVxuICAgICAgcmV0dXJuIHIubG9hZGVkIHx8IChyLmxvYWRlZCA9ICEwKSwgci5saWI7XG4gICAgaWYgKHIuZ2V0KSB7XG4gICAgICBjb25zdCBzID0gci5nZXQoKTtcbiAgICAgIGlmIChzIGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgICAgVGhlIGxvYWRTaGFyZVN5bmMgZnVuY3Rpb24gd2FzIHVuYWJsZSB0byBsb2FkICR7ZX0uIFRoZSAke2V9IGNvdWxkIG5vdCBiZSBmb3VuZCBpbiAke3RoaXMub3B0aW9ucy5uYW1lfS5cbiAgICAgICAgUG9zc2libGUgcmVhc29ucyBmb3IgZmFpbHVyZTogXG5cbiAgICAgICAgMS4gVGhlICR7ZX0gc2hhcmUgd2FzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgJ2dldCcgYXR0cmlidXRlLCBidXQgbG9hZFNoYXJlIHdhcyBub3QgdXNlZCBiZWZvcmVoYW5kLlxuXG4gICAgICAgIDIuIFRoZSAke2V9IHNoYXJlIHdhcyBub3QgcmVnaXN0ZXJlZCB3aXRoIHRoZSAnbGliJyBhdHRyaWJ1dGUuXG5cbiAgICAgIGApO1xuICAgICAgcmV0dXJuIHIubGliID0gcywgdGhpcy5zZXRTaGFyZWQoe1xuICAgICAgICBwa2dOYW1lOiBlLFxuICAgICAgICBsb2FkZWQ6ICEwLFxuICAgICAgICBmcm9tOiB0aGlzLm9wdGlvbnMubmFtZSxcbiAgICAgICAgbGliOiByLmxpYixcbiAgICAgICAgc2hhcmVkOiByXG4gICAgICB9KSwgci5saWI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgIFRoZSBsb2FkU2hhcmVTeW5jIGZ1bmN0aW9uIHdhcyB1bmFibGUgdG8gbG9hZCAke2V9LiBUaGUgJHtlfSBjb3VsZCBub3QgYmUgZm91bmQgaW4gJHt0aGlzLm9wdGlvbnMubmFtZX0uXG4gICAgICAgIFBvc3NpYmxlIHJlYXNvbnMgZm9yIGZhaWx1cmU6IFxuXG4gICAgICAgIDEuIFRoZSAke2V9IHNoYXJlIHdhcyByZWdpc3RlcmVkIHdpdGggdGhlICdnZXQnIGF0dHJpYnV0ZSwgYnV0IGxvYWRTaGFyZSB3YXMgbm90IHVzZWQgYmVmb3JlaGFuZC5cblxuICAgICAgICAyLiBUaGUgJHtlfSBzaGFyZSB3YXMgbm90IHJlZ2lzdGVyZWQgd2l0aCB0aGUgJ2xpYicgYXR0cmlidXRlLlxuXG4gICAgICBgKTtcbiAgfVxuICBpbml0UmF3Q29udGFpbmVyKGUsIG8sIG4pIHtcbiAgICBjb25zdCByID0gZ2V0UmVtb3RlSW5mbyh7XG4gICAgICBuYW1lOiBlLFxuICAgICAgZW50cnk6IG9cbiAgICB9KSwgaSA9IG5ldyBNb2R1bGUoe1xuICAgICAgaG9zdDogdGhpcyxcbiAgICAgIHJlbW90ZUluZm86IHJcbiAgICB9KTtcbiAgICByZXR1cm4gaS5yZW1vdGVFbnRyeUV4cG9ydHMgPSBuLCB0aGlzLm1vZHVsZUNhY2hlLnNldChlLCBpKSwgaTtcbiAgfVxuICBhc3luYyBfZ2V0UmVtb3RlTW9kdWxlQW5kT3B0aW9ucyhlKSB7XG4gICAgY29uc3QgbyA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZVJlcXVlc3QuZW1pdCh7XG4gICAgICBpZDogZSxcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIG9yaWdpbjogdGhpc1xuICAgIH0pLCB7IGlkOiBuIH0gPSBvLCByID0gbWF0Y2hSZW1vdGVXaXRoTmFtZUFuZEV4cG9zZSh0aGlzLm9wdGlvbnMucmVtb3Rlcywgbik7XG4gICAgYXNzZXJ0KHIsIGBcbiAgICAgICAgVW5hYmxlIHRvIGxvY2F0ZSAke259IGluICR7dGhpcy5vcHRpb25zLm5hbWV9LiBQb3RlbnRpYWwgcmVhc29ucyBmb3IgZmFpbHVyZSBpbmNsdWRlOlxuXG4gICAgICAgIDEuICR7bn0gd2FzIG5vdCBpbmNsdWRlZCBpbiB0aGUgJ3JlbW90ZXMnIHBhcmFtZXRlciBvZiAke3RoaXMub3B0aW9ucy5uYW1lIHx8IFwidGhlIGhvc3RcIn0uXG5cbiAgICAgICAgMi4gJHtufSBjb3VsZCBub3QgYmUgZm91bmQgaW4gdGhlICdyZW1vdGVzJyBvZiAke3RoaXMub3B0aW9ucy5uYW1lfSB3aXRoIGVpdGhlciAnbmFtZScgb3IgJ2FsaWFzJyBhdHRyaWJ1dGVzLlxuICAgICAgICAzLiAke259IGlzIG5vdCBvbmxpbmUsIGluamVjdGVkLCBvciBsb2FkZWQuXG4gICAgICAgIDQuICR7bn0gIGNhbm5vdCBiZSBhY2Nlc3NlZCBvbiB0aGUgZXhwZWN0ZWQuXG4gICAgICAgIDUuIFRoZSAnYmVmb3JlUmVxdWVzdCcgaG9vayB3YXMgcHJvdmlkZWQgYnV0IGRpZCBub3QgcmV0dXJuIHRoZSBjb3JyZWN0ICdyZW1vdGVJbmZvJyB3aGVuIGF0dGVtcHRpbmcgdG8gbG9hZCAke259LlxuICAgICAgYCk7XG4gICAgY29uc3QgeyByZW1vdGU6IGkgfSA9IHIsIGEgPSBnZXRSZW1vdGVJbmZvKGkpLCBzID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuYWZ0ZXJSZXNvbHZlLmVtaXQoX2V4dGVuZHMoe1xuICAgICAgaWQ6IG5cbiAgICB9LCByLCB7XG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICBvcmlnaW46IHRoaXMsXG4gICAgICByZW1vdGVJbmZvOiBhXG4gICAgfSkpLCB7IHJlbW90ZTogYywgZXhwb3NlOiBsIH0gPSBzO1xuICAgIGFzc2VydChjICYmIGwsIGBUaGUgJ2JlZm9yZVJlcXVlc3QnIGhvb2sgd2FzIGV4ZWN1dGVkLCBidXQgaXQgZmFpbGVkIHRvIHJldHVybiB0aGUgY29ycmVjdCAncmVtb3RlJyBhbmQgJ2V4cG9zZScgdmFsdWVzIHdoaWxlIGxvYWRpbmcgJHtufS5gKTtcbiAgICBsZXQgdSA9IHRoaXMubW9kdWxlQ2FjaGUuZ2V0KGMubmFtZSk7XG4gICAgY29uc3QgaCA9IHtcbiAgICAgIGhvc3Q6IHRoaXMsXG4gICAgICByZW1vdGVJbmZvOiBhXG4gICAgfTtcbiAgICByZXR1cm4gdSB8fCAodSA9IG5ldyBNb2R1bGUoaCksIHRoaXMubW9kdWxlQ2FjaGUuc2V0KGMubmFtZSwgdSkpLCB7XG4gICAgICBtb2R1bGU6IHUsXG4gICAgICBtb2R1bGVPcHRpb25zOiBoLFxuICAgICAgcmVtb3RlTWF0Y2hJbmZvOiBzXG4gICAgfTtcbiAgfVxuICBhc3luYyBsb2FkUmVtb3RlKGUsIG8pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBsb2FkRmFjdG9yeTogbiA9ICEwIH0gPSBvIHx8IHtcbiAgICAgICAgbG9hZEZhY3Rvcnk6ICEwXG4gICAgICB9LCB7IG1vZHVsZTogciwgbW9kdWxlT3B0aW9uczogaSwgcmVtb3RlTWF0Y2hJbmZvOiBhIH0gPSBhd2FpdCB0aGlzLl9nZXRSZW1vdGVNb2R1bGVBbmRPcHRpb25zKGUpLCB7IHBrZ05hbWVPckFsaWFzOiBzLCByZW1vdGU6IGMsIGV4cG9zZTogbCwgaWQ6IHUgfSA9IGEsIGggPSBhd2FpdCByLmdldChsLCBvKSwgZyA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLm9uTG9hZC5lbWl0KHtcbiAgICAgICAgaWQ6IHUsXG4gICAgICAgIHBrZ05hbWVPckFsaWFzOiBzLFxuICAgICAgICBleHBvc2U6IGwsXG4gICAgICAgIGV4cG9zZU1vZHVsZTogbiA/IGggOiB2b2lkIDAsXG4gICAgICAgIGV4cG9zZU1vZHVsZUZhY3Rvcnk6IG4gPyB2b2lkIDAgOiBoLFxuICAgICAgICByZW1vdGU6IGMsXG4gICAgICAgIG9wdGlvbnM6IGksXG4gICAgICAgIG1vZHVsZUluc3RhbmNlOiByLFxuICAgICAgICBvcmlnaW46IHRoaXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHR5cGVvZiBnID09IFwiZnVuY3Rpb25cIiA/IGcgOiBoO1xuICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgIGNvbnN0IHsgZnJvbTogciA9IFwicnVudGltZVwiIH0gPSBvIHx8IHtcbiAgICAgICAgZnJvbTogXCJydW50aW1lXCJcbiAgICAgIH0sIGkgPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5lcnJvckxvYWRSZW1vdGUuZW1pdCh7XG4gICAgICAgIGlkOiBlLFxuICAgICAgICBlcnJvcjogbixcbiAgICAgICAgZnJvbTogcixcbiAgICAgICAgb3JpZ2luOiB0aGlzXG4gICAgICB9KTtcbiAgICAgIGlmICghaSlcbiAgICAgICAgdGhyb3cgbjtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcmVsb2FkUmVtb3RlKGUpIHtcbiAgICBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5iZWZvcmVQcmVsb2FkUmVtb3RlLmVtaXQoe1xuICAgICAgcHJlbG9hZE9wdGlvbnM6IGUsXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICBvcmlnaW46IHRoaXNcbiAgICB9KTtcbiAgICBjb25zdCBvID0gZm9ybWF0UHJlbG9hZEFyZ3ModGhpcy5vcHRpb25zLnJlbW90ZXMsIGUpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKG8ubWFwKGFzeW5jIChuKSA9PiB7XG4gICAgICBjb25zdCB7IHJlbW90ZTogciB9ID0gbiwgaSA9IGdldFJlbW90ZUluZm8ociksIHsgZ2xvYmFsU25hcHNob3Q6IGEsIHJlbW90ZVNuYXBzaG90OiBzIH0gPSBhd2FpdCB0aGlzLnNuYXBzaG90SGFuZGxlci5sb2FkUmVtb3RlU25hcHNob3RJbmZvKHIpLCBjID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuZ2VuZXJhdGVQcmVsb2FkQXNzZXRzLmVtaXQoe1xuICAgICAgICBvcmlnaW46IHRoaXMsXG4gICAgICAgIHByZWxvYWRPcHRpb25zOiBuLFxuICAgICAgICByZW1vdGU6IHIsXG4gICAgICAgIHJlbW90ZUluZm86IGksXG4gICAgICAgIGdsb2JhbFNuYXBzaG90OiBhLFxuICAgICAgICByZW1vdGVTbmFwc2hvdDogc1xuICAgICAgfSk7XG4gICAgICAhYyB8fCBwcmVsb2FkQXNzZXRzKGksIHRoaXMsIGMpO1xuICAgIH0pKTtcbiAgfVxuICBpbml0aWFsaXplU2hhcmluZyhlID0gREVGQVVMVF9TQ09QRSwgbykge1xuICAgIGNvbnN0IG4gPSB0aGlzLnNoYXJlU2NvcGVNYXAsIHIgPSB0aGlzLm9wdGlvbnMubmFtZTtcbiAgICBuW2VdIHx8IChuW2VdID0ge30pO1xuICAgIGNvbnN0IGkgPSBuW2VdLCBhID0gKHUsIGgpID0+IHtcbiAgICAgIHZhciBnO1xuICAgICAgY29uc3QgeyB2ZXJzaW9uOiBwLCBlYWdlcjogZCB9ID0gaDtcbiAgICAgIGlbdV0gPSBpW3VdIHx8IHt9O1xuICAgICAgY29uc3QgbSA9IGlbdV0sIE0gPSBtW3BdLCBJID0gISEoTSAmJiAoTS5lYWdlciB8fCAoZyA9IE0uc2hhcmVDb25maWcpICE9IG51bGwgJiYgZy5lYWdlcikpO1xuICAgICAgKCFNIHx8IE0uc3RyYXRlZ3kgIT09IFwibG9hZGVkLWZpcnN0XCIgJiYgIU0ubG9hZGVkICYmICghZCAhPSAhSSA/IGQgOiByID4gTS5mcm9tKSkgJiYgKG1bcF0gPSBoKTtcbiAgICB9LCBzID0gW10sIGMgPSAodSkgPT4gdSAmJiB1LmluaXQgJiYgdS5pbml0KG5bZV0pLCBsID0gYXN5bmMgKHUpID0+IHtcbiAgICAgIGNvbnN0IHsgbW9kdWxlOiBoIH0gPSBhd2FpdCB0aGlzLl9nZXRSZW1vdGVNb2R1bGVBbmRPcHRpb25zKHUpO1xuICAgICAgaWYgKGguZ2V0RW50cnkpIHtcbiAgICAgICAgY29uc3QgZyA9IGF3YWl0IGguZ2V0RW50cnkoKTtcbiAgICAgICAgaC5pbml0ZWQgfHwgKGMoZyksIGguaW5pdGVkID0gITApO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5zaGFyZWQpLmZvckVhY2goKHUpID0+IHtcbiAgICAgIGNvbnN0IGggPSB0aGlzLm9wdGlvbnMuc2hhcmVkW3VdO1xuICAgICAgaC5zY29wZS5pbmNsdWRlcyhlKSAmJiBhKHUsIGgpO1xuICAgIH0pLCBvID09PSBcInZlcnNpb24tZmlyc3RcIiAmJiB0aGlzLm9wdGlvbnMucmVtb3Rlcy5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICB1LnNoYXJlU2NvcGUgPT09IGUgJiYgcy5wdXNoKGwodS5uYW1lKSk7XG4gICAgfSksIHM7XG4gIH1cbiAgaW5pdFNoYXJlU2NvcGVNYXAoZSwgbykge1xuICAgIHRoaXMuc2hhcmVTY29wZU1hcFtlXSA9IG8sIHRoaXMuaG9va3MubGlmZWN5Y2xlLmluaXRDb250YWluZXJTaGFyZVNjb3BlTWFwLmVtaXQoe1xuICAgICAgc2hhcmVTY29wZTogbyxcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIG9yaWdpbjogdGhpc1xuICAgIH0pO1xuICB9XG4gIGZvcm1hdE9wdGlvbnMoZSwgbykge1xuICAgIGNvbnN0IG4gPSBmb3JtYXRTaGFyZUNvbmZpZ3Moby5zaGFyZWQgfHwge30sIG8ubmFtZSksIHIgPSBfZXh0ZW5kcyh7fSwgZS5zaGFyZWQsIG4pLCB7IHVzZXJPcHRpb25zOiBpLCBvcHRpb25zOiBhIH0gPSB0aGlzLmhvb2tzLmxpZmVjeWNsZS5iZWZvcmVJbml0LmVtaXQoe1xuICAgICAgb3JpZ2luOiB0aGlzLFxuICAgICAgdXNlck9wdGlvbnM6IG8sXG4gICAgICBvcHRpb25zOiBlLFxuICAgICAgc2hhcmVJbmZvOiByXG4gICAgfSksIHMgPSAoaS5yZW1vdGVzIHx8IFtdKS5yZWR1Y2UoKHUsIGgpID0+ICh0aGlzLnJlZ2lzdGVyUmVtb3RlKGgsIHUsIHtcbiAgICAgIGZvcmNlOiAhMVxuICAgIH0pLCB1KSwgYS5yZW1vdGVzKTtcbiAgICBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICBjb25zdCBoID0gblt1XTtcbiAgICAgICFnZXRSZWdpc3RlcmVkU2hhcmUodGhpcy5zaGFyZVNjb3BlTWFwLCB1LCBoLCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5yZXNvbHZlU2hhcmUpICYmIGggJiYgaC5saWIgJiYgdGhpcy5zZXRTaGFyZWQoe1xuICAgICAgICBwa2dOYW1lOiB1LFxuICAgICAgICBsaWI6IGgubGliLFxuICAgICAgICBnZXQ6IGguZ2V0LFxuICAgICAgICBsb2FkZWQ6ICEwLFxuICAgICAgICBzaGFyZWQ6IGgsXG4gICAgICAgIGZyb206IG8ubmFtZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgYyA9IFtcbiAgICAgIC4uLmEucGx1Z2luc1xuICAgIF07XG4gICAgaS5wbHVnaW5zICYmIGkucGx1Z2lucy5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICBjLmluY2x1ZGVzKHUpIHx8IGMucHVzaCh1KTtcbiAgICB9KTtcbiAgICBjb25zdCBsID0gX2V4dGVuZHMoe30sIGUsIG8sIHtcbiAgICAgIHBsdWdpbnM6IGMsXG4gICAgICByZW1vdGVzOiBzLFxuICAgICAgc2hhcmVkOiByXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaG9va3MubGlmZWN5Y2xlLmluaXQuZW1pdCh7XG4gICAgICBvcmlnaW46IHRoaXMsXG4gICAgICBvcHRpb25zOiBsXG4gICAgfSksIGw7XG4gIH1cbiAgcmVnaXN0ZXJQbHVnaW5zKGUpIHtcbiAgICByZWdpc3RlclBsdWdpbnMoZSwgW1xuICAgICAgdGhpcy5ob29rcyxcbiAgICAgIHRoaXMuc25hcHNob3RIYW5kbGVyLmhvb2tzLFxuICAgICAgdGhpcy5sb2FkZXJIb29rXG4gICAgXSk7XG4gIH1cbiAgc2V0U2hhcmVkKHsgcGtnTmFtZTogZSwgc2hhcmVkOiBvLCBmcm9tOiBuLCBsaWI6IHIsIGxvYWRpbmc6IGksIGxvYWRlZDogYSwgZ2V0OiBzIH0pIHtcbiAgICBjb25zdCB7IHZlcnNpb246IGMsIHNjb3BlOiBsID0gXCJkZWZhdWx0XCIgfSA9IG8sIHUgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShvLCBbXG4gICAgICBcInZlcnNpb25cIixcbiAgICAgIFwic2NvcGVcIlxuICAgIF0pO1xuICAgIChBcnJheS5pc0FycmF5KGwpID8gbCA6IFtcbiAgICAgIGxcbiAgICBdKS5mb3JFYWNoKChoKSA9PiB7XG4gICAgICB0aGlzLnNoYXJlU2NvcGVNYXBbaF0gfHwgKHRoaXMuc2hhcmVTY29wZU1hcFtoXSA9IHt9KSwgdGhpcy5zaGFyZVNjb3BlTWFwW2hdW2VdIHx8ICh0aGlzLnNoYXJlU2NvcGVNYXBbaF1bZV0gPSB7fSksICF0aGlzLnNoYXJlU2NvcGVNYXBbaF1bZV1bY10gJiYgKHRoaXMuc2hhcmVTY29wZU1hcFtoXVtlXVtjXSA9IF9leHRlbmRzKHtcbiAgICAgICAgdmVyc2lvbjogYyxcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcImRlZmF1bHRcIlxuICAgICAgICBdXG4gICAgICB9LCB1LCB7XG4gICAgICAgIGxpYjogcixcbiAgICAgICAgbG9hZGVkOiBhLFxuICAgICAgICBsb2FkaW5nOiBpXG4gICAgICB9KSwgcyAmJiAodGhpcy5zaGFyZVNjb3BlTWFwW2hdW2VdW2NdLmdldCA9IHMpKTtcbiAgICB9KTtcbiAgfVxuICByZW1vdmVSZW1vdGUoZSkge1xuICAgIGNvbnN0IHsgbmFtZTogbyB9ID0gZSwgbiA9IHRoaXMub3B0aW9ucy5yZW1vdGVzLmZpbmRJbmRleCgoaSkgPT4gaS5uYW1lID09PSBvKTtcbiAgICBuICE9PSAtMSAmJiB0aGlzLm9wdGlvbnMucmVtb3Rlcy5zcGxpY2UobiwgMSk7XG4gICAgY29uc3QgciA9IHRoaXMubW9kdWxlQ2FjaGUuZ2V0KGUubmFtZSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIGNvbnN0IGkgPSByLnJlbW90ZUluZm8uZW50cnlHbG9iYWxOYW1lO1xuICAgICAgZ2xvYmFsVGhpc1tpXSAmJiBkZWxldGUgZ2xvYmFsVGhpc1tpXTtcbiAgICAgIGNvbnN0IGEgPSBnZXRSZW1vdGVFbnRyeVVuaXF1ZUtleShyLnJlbW90ZUluZm8pO1xuICAgICAgZ2xvYmFsTG9hZGluZ1thXSAmJiBkZWxldGUgZ2xvYmFsTG9hZGluZ1thXSwgdGhpcy5tb2R1bGVDYWNoZS5kZWxldGUoZS5uYW1lKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJSZW1vdGUoZSwgbywgbikge1xuICAgIGNvbnN0IHIgPSAoKSA9PiB7XG4gICAgICBpZiAoZS5hbGlhcykge1xuICAgICAgICBjb25zdCBhID0gby5maW5kKChzKSA9PiB7XG4gICAgICAgICAgdmFyIGM7XG4gICAgICAgICAgcmV0dXJuIGUuYWxpYXMgJiYgKHMubmFtZS5zdGFydHNXaXRoKGUuYWxpYXMpIHx8ICgoYyA9IHMuYWxpYXMpID09IG51bGwgPyB2b2lkIDAgOiBjLnN0YXJ0c1dpdGgoZS5hbGlhcykpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFzc2VydCghYSwgYFRoZSBhbGlhcyAke2UuYWxpYXN9IG9mIHJlbW90ZSAke2UubmFtZX0gaXMgbm90IGFsbG93ZWQgdG8gYmUgdGhlIHByZWZpeCBvZiAke2EgJiYgYS5uYW1lfSBuYW1lIG9yIGFsaWFzYCk7XG4gICAgICB9XG4gICAgICBcImVudHJ5XCIgaW4gZSAmJiBpc0Jyb3dzZXJFbnYkMSgpICYmICFlLmVudHJ5LnN0YXJ0c1dpdGgoXCJodHRwXCIpICYmIChlLmVudHJ5ID0gbmV3IFVSTChlLmVudHJ5LCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKS5ocmVmKSwgZS5zaGFyZVNjb3BlIHx8IChlLnNoYXJlU2NvcGUgPSBERUZBVUxUX1NDT1BFKSwgZS50eXBlIHx8IChlLnR5cGUgPSBERUZBVUxUX1JFTU9URV9UWVBFKTtcbiAgICB9LCBpID0gby5maW5kKChhKSA9PiBhLm5hbWUgPT09IGUubmFtZSk7XG4gICAgaWYgKCFpKVxuICAgICAgcigpLCBvLnB1c2goZSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBhID0gW1xuICAgICAgICBgVGhlIHJlbW90ZSBcIiR7ZS5uYW1lfVwiIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC5gLFxuICAgICAgICBuICE9IG51bGwgJiYgbi5mb3JjZSA/IFwiSG9wZSB5b3UgaGF2ZSBrbm93biB0aGF0IE9WRVJSSURFIGl0IG1heSBoYXZlIHNvbWUgdW5leHBlY3RlZCBlcnJvcnNcIiA6ICdJZiB5b3Ugd2FudCB0byBtZXJnZSB0aGUgcmVtb3RlLCB5b3UgY2FuIHNldCBcImZvcmNlOiB0cnVlXCIuJ1xuICAgICAgXTtcbiAgICAgIG4gIT0gbnVsbCAmJiBuLmZvcmNlICYmICh0aGlzLnJlbW92ZVJlbW90ZShpKSwgcigpLCBvLnB1c2goZSkpLCB3YXJuJDEoYS5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyUmVtb3RlcyhlLCBvKSB7XG4gICAgZS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICB0aGlzLnJlZ2lzdGVyUmVtb3RlKG4sIHRoaXMub3B0aW9ucy5yZW1vdGVzLCB7XG4gICAgICAgIGZvcmNlOiBvPy5mb3JjZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuaG9va3MgPSBuZXcgUGx1Z2luU3lzdGVtKHtcbiAgICAgIGJlZm9yZUluaXQ6IG5ldyBTeW5jV2F0ZXJmYWxsSG9vayhcImJlZm9yZUluaXRcIiksXG4gICAgICBpbml0OiBuZXcgU3luY0hvb2soKSxcbiAgICAgIGJlZm9yZVJlcXVlc3Q6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soXCJiZWZvcmVSZXF1ZXN0XCIpLFxuICAgICAgYWZ0ZXJSZXNvbHZlOiBuZXcgQXN5bmNXYXRlcmZhbGxIb29rKFwiYWZ0ZXJSZXNvbHZlXCIpLFxuICAgICAgYmVmb3JlSW5pdENvbnRhaW5lcjogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vayhcImJlZm9yZUluaXRDb250YWluZXJcIiksXG4gICAgICBpbml0Q29udGFpbmVyU2hhcmVTY29wZU1hcDogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vayhcImluaXRDb250YWluZXJcIiksXG4gICAgICBpbml0Q29udGFpbmVyOiBuZXcgQXN5bmNXYXRlcmZhbGxIb29rKFwiaW5pdENvbnRhaW5lclwiKSxcbiAgICAgIG9uTG9hZDogbmV3IEFzeW5jSG9vayhcIm9uTG9hZFwiKSxcbiAgICAgIGhhbmRsZVByZWxvYWRNb2R1bGU6IG5ldyBTeW5jSG9vayhcImhhbmRsZVByZWxvYWRNb2R1bGVcIiksXG4gICAgICBlcnJvckxvYWRSZW1vdGU6IG5ldyBBc3luY0hvb2soXCJlcnJvckxvYWRSZW1vdGVcIiksXG4gICAgICBiZWZvcmVMb2FkU2hhcmU6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soXCJiZWZvcmVMb2FkU2hhcmVcIiksXG4gICAgICBsb2FkU2hhcmU6IG5ldyBBc3luY0hvb2soKSxcbiAgICAgIHJlc29sdmVTaGFyZTogbmV3IFN5bmNXYXRlcmZhbGxIb29rKFwicmVzb2x2ZVNoYXJlXCIpLFxuICAgICAgYmVmb3JlUHJlbG9hZFJlbW90ZTogbmV3IEFzeW5jSG9vaygpLFxuICAgICAgZ2VuZXJhdGVQcmVsb2FkQXNzZXRzOiBuZXcgQXN5bmNIb29rKFwiZ2VuZXJhdGVQcmVsb2FkQXNzZXRzXCIpLFxuICAgICAgYWZ0ZXJQcmVsb2FkUmVtb3RlOiBuZXcgQXN5bmNIb29rKClcbiAgICB9KSwgdGhpcy52ZXJzaW9uID0gXCIwLjEuMlwiLCB0aGlzLm1vZHVsZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5sb2FkZXJIb29rID0gbmV3IFBsdWdpblN5c3RlbSh7XG4gICAgICBnZXRNb2R1bGVJbmZvOiBuZXcgU3luY0hvb2soKSxcbiAgICAgIGNyZWF0ZVNjcmlwdDogbmV3IFN5bmNIb29rKCksXG4gICAgICBjcmVhdGVMaW5rOiBuZXcgU3luY0hvb2soKSxcbiAgICAgIGZldGNoOiBuZXcgQXN5bmNIb29rKFwiZmV0Y2hcIilcbiAgICB9KTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgaWQ6IGdldEJ1aWxkZXJJZCgpLFxuICAgICAgbmFtZTogZS5uYW1lLFxuICAgICAgcGx1Z2luczogW1xuICAgICAgICBzbmFwc2hvdFBsdWdpbigpLFxuICAgICAgICBnZW5lcmF0ZVByZWxvYWRBc3NldHNQbHVnaW4oKVxuICAgICAgXSxcbiAgICAgIHJlbW90ZXM6IFtdLFxuICAgICAgc2hhcmVkOiB7fSxcbiAgICAgIGluQnJvd3NlcjogaXNCcm93c2VyRW52JDEoKVxuICAgIH07XG4gICAgdGhpcy5uYW1lID0gZS5uYW1lLCB0aGlzLm9wdGlvbnMgPSBvLCB0aGlzLnNoYXJlU2NvcGVNYXAgPSB7fSwgdGhpcy5fc2V0R2xvYmFsU2hhcmVTY29wZU1hcCgpLCB0aGlzLnNuYXBzaG90SGFuZGxlciA9IG5ldyBTbmFwc2hvdEhhbmRsZXIodGhpcyksIHRoaXMucmVnaXN0ZXJQbHVnaW5zKFtcbiAgICAgIC4uLm8ucGx1Z2lucyxcbiAgICAgIC4uLmUucGx1Z2lucyB8fCBbXVxuICAgIF0pLCB0aGlzLm9wdGlvbnMgPSB0aGlzLmZvcm1hdE9wdGlvbnMobywgZSk7XG4gIH1cbn1cbmxldCBGZWRlcmF0aW9uSW5zdGFuY2UgPSBudWxsO1xuZnVuY3Rpb24gaW5pdCh0KSB7XG4gIGNvbnN0IGUgPSBnZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UodC5uYW1lLCB0LnZlcnNpb24pO1xuICBpZiAoZSlcbiAgICByZXR1cm4gZS5pbml0T3B0aW9ucyh0KSwgRmVkZXJhdGlvbkluc3RhbmNlIHx8IChGZWRlcmF0aW9uSW5zdGFuY2UgPSBlKSwgZTtcbiAge1xuICAgIGNvbnN0IG8gPSBnZXRHbG9iYWxGZWRlcmF0aW9uQ29uc3RydWN0b3IoKSB8fCBGZWRlcmF0aW9uSG9zdDtcbiAgICByZXR1cm4gRmVkZXJhdGlvbkluc3RhbmNlID0gbmV3IG8odCksIHNldEdsb2JhbEZlZGVyYXRpb25JbnN0YW5jZShGZWRlcmF0aW9uSW5zdGFuY2UpLCBGZWRlcmF0aW9uSW5zdGFuY2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGxvYWRSZW1vdGUoLi4udCkge1xuICByZXR1cm4gYXNzZXJ0KEZlZGVyYXRpb25JbnN0YW5jZSwgXCJQbGVhc2UgY2FsbCBpbml0IGZpcnN0XCIpLCBGZWRlcmF0aW9uSW5zdGFuY2UubG9hZFJlbW90ZS5hcHBseShGZWRlcmF0aW9uSW5zdGFuY2UsIHQpO1xufVxuc2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yKEZlZGVyYXRpb25Ib3N0KTtcbmZ1bmN0aW9uIF9fYXdhaXRlcih0LCBlLCBvLCBuKSB7XG4gIGZ1bmN0aW9uIHIoaSkge1xuICAgIHJldHVybiBpIGluc3RhbmNlb2YgbyA/IGkgOiBuZXcgbyhmdW5jdGlvbihhKSB7XG4gICAgICBhKGkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgKG8gfHwgKG8gPSBQcm9taXNlKSkoZnVuY3Rpb24oaSwgYSkge1xuICAgIGZ1bmN0aW9uIHModSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbChuLm5leHQodSkpO1xuICAgICAgfSBjYXRjaCAoaCkge1xuICAgICAgICBhKGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjKHUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGwobi50aHJvdyh1KSk7XG4gICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgIGEoaCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGwodSkge1xuICAgICAgdS5kb25lID8gaSh1LnZhbHVlKSA6IHIodS52YWx1ZSkudGhlbihzLCBjKTtcbiAgICB9XG4gICAgbCgobiA9IG4uYXBwbHkodCwgZSB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gX19nZW5lcmF0b3IodCwgZSkge1xuICB2YXIgbyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmIChpWzBdICYgMSlcbiAgICAgIHRocm93IGlbMV07XG4gICAgcmV0dXJuIGlbMV07XG4gIH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIG4sIHIsIGksIGE7XG4gIHJldHVybiBhID0geyBuZXh0OiBzKDApLCB0aHJvdzogcygxKSwgcmV0dXJuOiBzKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIChhW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGE7XG4gIGZ1bmN0aW9uIHMobCkge1xuICAgIHJldHVybiBmdW5jdGlvbih1KSB7XG4gICAgICByZXR1cm4gYyhbbCwgdV0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYyhsKSB7XG4gICAgaWYgKG4pXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICBmb3IgKDsgbzsgKVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG4gPSAxLCByICYmIChpID0gbFswXSAmIDIgPyByLnJldHVybiA6IGxbMF0gPyByLnRocm93IHx8ICgoaSA9IHIucmV0dXJuKSAmJiBpLmNhbGwociksIDApIDogci5uZXh0KSAmJiAhKGkgPSBpLmNhbGwociwgbFsxXSkpLmRvbmUpXG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIHN3aXRjaCAociA9IDAsIGkgJiYgKGwgPSBbbFswXSAmIDIsIGkudmFsdWVdKSwgbFswXSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpID0gbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBvLmxhYmVsKyssIHsgdmFsdWU6IGxbMV0sIGRvbmU6ICExIH07XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgby5sYWJlbCsrLCByID0gbFsxXSwgbCA9IFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGwgPSBvLm9wcy5wb3AoKSwgby50cnlzLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChpID0gby50cnlzLCAhKGkgPSBpLmxlbmd0aCA+IDAgJiYgaVtpLmxlbmd0aCAtIDFdKSAmJiAobFswXSA9PT0gNiB8fCBsWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICBvID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobFswXSA9PT0gMyAmJiAoIWkgfHwgbFsxXSA+IGlbMF0gJiYgbFsxXSA8IGlbM10pKSB7XG4gICAgICAgICAgICAgIG8ubGFiZWwgPSBsWzFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsWzBdID09PSA2ICYmIG8ubGFiZWwgPCBpWzFdKSB7XG4gICAgICAgICAgICAgIG8ubGFiZWwgPSBpWzFdLCBpID0gbDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAmJiBvLmxhYmVsIDwgaVsyXSkge1xuICAgICAgICAgICAgICBvLmxhYmVsID0gaVsyXSwgby5vcHMucHVzaChsKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpWzJdICYmIG8ub3BzLnBvcCgpLCBvLnRyeXMucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsID0gZS5jYWxsKHQsIG8pO1xuICAgICAgfSBjYXRjaCAodSkge1xuICAgICAgICBsID0gWzYsIHVdLCByID0gMDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG4gPSBpID0gMDtcbiAgICAgIH1cbiAgICBpZiAobFswXSAmIDUpXG4gICAgICB0aHJvdyBsWzFdO1xuICAgIHJldHVybiB7IHZhbHVlOiBsWzBdID8gbFsxXSA6IHZvaWQgMCwgZG9uZTogITAgfTtcbiAgfVxufVxudmFyIEVfQ0FOQ0VMRUQgPSBuZXcgRXJyb3IoXCJyZXF1ZXN0IGZvciBsb2NrIGNhbmNlbGVkXCIpLCBTZW1hcGhvcmUgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gdChlLCBvKSB7XG4gICAgbyA9PT0gdm9pZCAwICYmIChvID0gRV9DQU5DRUxFRCksIHRoaXMuX3ZhbHVlID0gZSwgdGhpcy5fY2FuY2VsRXJyb3IgPSBvLCB0aGlzLl9xdWV1ZSA9IFtdLCB0aGlzLl93ZWlnaHRlZFdhaXRlcnMgPSBbXTtcbiAgfVxuICByZXR1cm4gdC5wcm90b3R5cGUuYWNxdWlyZSA9IGZ1bmN0aW9uKGUsIG8pIHtcbiAgICB2YXIgbiA9IHRoaXM7XG4gICAgaWYgKGUgPT09IHZvaWQgMCAmJiAoZSA9IDEpLCBvID09PSB2b2lkIDAgJiYgKG8gPSAwKSwgZSA8PSAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB3ZWlnaHQgXCIuY29uY2F0KGUsIFwiOiBtdXN0IGJlIHBvc2l0aXZlXCIpKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ociwgaSkge1xuICAgICAgdmFyIGEgPSB7IHJlc29sdmU6IHIsIHJlamVjdDogaSwgd2VpZ2h0OiBlLCBwcmlvcml0eTogbyB9LCBzID0gZmluZEluZGV4RnJvbUVuZChuLl9xdWV1ZSwgZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gbyA8PSBjLnByaW9yaXR5O1xuICAgICAgfSk7XG4gICAgICBzID09PSAtMSAmJiBlIDw9IG4uX3ZhbHVlID8gbi5fZGlzcGF0Y2hJdGVtKGEpIDogbi5fcXVldWUuc3BsaWNlKHMgKyAxLCAwLCBhKTtcbiAgICB9KTtcbiAgfSwgdC5wcm90b3R5cGUucnVuRXhjbHVzaXZlID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKG8sIG4sIHIpIHtcbiAgICAgIHZhciBpLCBhLCBzO1xuICAgICAgcmV0dXJuIG4gPT09IHZvaWQgMCAmJiAobiA9IDEpLCByID09PSB2b2lkIDAgJiYgKHIgPSAwKSwgX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oYykge1xuICAgICAgICBzd2l0Y2ggKGMubGFiZWwpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuYWNxdWlyZShuLCByKV07XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaSA9IGMuc2VudCgpLCBhID0gaVswXSwgcyA9IGlbMV0sIGMubGFiZWwgPSAyO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBjLnRyeXMucHVzaChbMiwgLCA0LCA1XSksIFs0LCBvKGEpXTtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gWzIsIGMuc2VudCgpXTtcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gcygpLCBbN107XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIHQucHJvdG90eXBlLndhaXRGb3JVbmxvY2sgPSBmdW5jdGlvbihlLCBvKSB7XG4gICAgdmFyIG4gPSB0aGlzO1xuICAgIGlmIChlID09PSB2b2lkIDAgJiYgKGUgPSAxKSwgbyA9PT0gdm9pZCAwICYmIChvID0gMCksIGUgPD0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgd2VpZ2h0IFwiLmNvbmNhdChlLCBcIjogbXVzdCBiZSBwb3NpdGl2ZVwiKSk7XG4gICAgcmV0dXJuIHRoaXMuX2NvdWxkTG9ja0ltbWVkaWF0ZWx5KGUsIG8pID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBuZXcgUHJvbWlzZShmdW5jdGlvbihyKSB7XG4gICAgICBuLl93ZWlnaHRlZFdhaXRlcnNbZSAtIDFdIHx8IChuLl93ZWlnaHRlZFdhaXRlcnNbZSAtIDFdID0gW10pLCBpbnNlcnRTb3J0ZWQobi5fd2VpZ2h0ZWRXYWl0ZXJzW2UgLSAxXSwgeyByZXNvbHZlOiByLCBwcmlvcml0eTogbyB9KTtcbiAgICB9KTtcbiAgfSwgdC5wcm90b3R5cGUuaXNMb2NrZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPD0gMDtcbiAgfSwgdC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH0sIHQucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuX3ZhbHVlID0gZSwgdGhpcy5fZGlzcGF0Y2hRdWV1ZSgpO1xuICB9LCB0LnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChlID09PSB2b2lkIDAgJiYgKGUgPSAxKSwgZSA8PSAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB3ZWlnaHQgXCIuY29uY2F0KGUsIFwiOiBtdXN0IGJlIHBvc2l0aXZlXCIpKTtcbiAgICB0aGlzLl92YWx1ZSArPSBlLCB0aGlzLl9kaXNwYXRjaFF1ZXVlKCk7XG4gIH0sIHQucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gdGhpcztcbiAgICB0aGlzLl9xdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiBvLnJlamVjdChlLl9jYW5jZWxFcnJvcik7XG4gICAgfSksIHRoaXMuX3F1ZXVlID0gW107XG4gIH0sIHQucHJvdG90eXBlLl9kaXNwYXRjaFF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh0aGlzLl9kcmFpblVubG9ja1dhaXRlcnMoKTsgdGhpcy5fcXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLl9xdWV1ZVswXS53ZWlnaHQgPD0gdGhpcy5fdmFsdWU7IClcbiAgICAgIHRoaXMuX2Rpc3BhdGNoSXRlbSh0aGlzLl9xdWV1ZS5zaGlmdCgpKSwgdGhpcy5fZHJhaW5VbmxvY2tXYWl0ZXJzKCk7XG4gIH0sIHQucHJvdG90eXBlLl9kaXNwYXRjaEl0ZW0gPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG8gPSB0aGlzLl92YWx1ZTtcbiAgICB0aGlzLl92YWx1ZSAtPSBlLndlaWdodCwgZS5yZXNvbHZlKFtvLCB0aGlzLl9uZXdSZWxlYXNlcihlLndlaWdodCldKTtcbiAgfSwgdC5wcm90b3R5cGUuX25ld1JlbGVhc2VyID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBvID0gdGhpcywgbiA9ICExO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIG4gfHwgKG4gPSAhMCwgby5yZWxlYXNlKGUpKTtcbiAgICB9O1xuICB9LCB0LnByb3RvdHlwZS5fZHJhaW5VbmxvY2tXYWl0ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMClcbiAgICAgIGZvciAodmFyIGUgPSB0aGlzLl92YWx1ZTsgZSA+IDA7IGUtLSkge1xuICAgICAgICB2YXIgbyA9IHRoaXMuX3dlaWdodGVkV2FpdGVyc1tlIC0gMV07XG4gICAgICAgICFvIHx8IChvLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiBpLnJlc29sdmUoKTtcbiAgICAgICAgfSksIHRoaXMuX3dlaWdodGVkV2FpdGVyc1tlIC0gMV0gPSBbXSk7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgbiA9IHRoaXMuX3F1ZXVlWzBdLnByaW9yaXR5LCBlID0gdGhpcy5fdmFsdWU7IGUgPiAwOyBlLS0pIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbZSAtIDFdO1xuICAgICAgICBpZiAobykge1xuICAgICAgICAgIHZhciByID0gby5maW5kSW5kZXgoZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgcmV0dXJuIHMucHJpb3JpdHkgPD0gbjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAociA9PT0gLTEgPyBvIDogby5zcGxpY2UoMCwgcikpLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgcmV0dXJuIHMucmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gIH0sIHQucHJvdG90eXBlLl9jb3VsZExvY2tJbW1lZGlhdGVseSA9IGZ1bmN0aW9uKGUsIG8pIHtcbiAgICByZXR1cm4gKHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9xdWV1ZVswXS5wcmlvcml0eSA8IG8pICYmIGUgPD0gdGhpcy5fdmFsdWU7XG4gIH0sIHQ7XG59KCk7XG5mdW5jdGlvbiBpbnNlcnRTb3J0ZWQodCwgZSkge1xuICB2YXIgbyA9IGZpbmRJbmRleEZyb21FbmQodCwgZnVuY3Rpb24obikge1xuICAgIHJldHVybiBlLnByaW9yaXR5IDw9IG4ucHJpb3JpdHk7XG4gIH0pO1xuICB0LnNwbGljZShvICsgMSwgMCwgZSk7XG59XG5mdW5jdGlvbiBmaW5kSW5kZXhGcm9tRW5kKHQsIGUpIHtcbiAgZm9yICh2YXIgbyA9IHQubGVuZ3RoIC0gMTsgbyA+PSAwOyBvLS0pXG4gICAgaWYgKGUodFtvXSkpXG4gICAgICByZXR1cm4gbztcbiAgcmV0dXJuIC0xO1xufVxudmFyIE11dGV4ID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHQoZSkge1xuICAgIHRoaXMuX3NlbWFwaG9yZSA9IG5ldyBTZW1hcGhvcmUoMSwgZSk7XG4gIH1cbiAgcmV0dXJuIHQucHJvdG90eXBlLmFjcXVpcmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgbywgbjtcbiAgICAgIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwgX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24ocikge1xuICAgICAgICBzd2l0Y2ggKHIubGFiZWwpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuX3NlbWFwaG9yZS5hY3F1aXJlKDEsIGUpXTtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gbyA9IHIuc2VudCgpLCBuID0gb1sxXSwgWzIsIG5dO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgdC5wcm90b3R5cGUucnVuRXhjbHVzaXZlID0gZnVuY3Rpb24oZSwgbykge1xuICAgIHJldHVybiBvID09PSB2b2lkIDAgJiYgKG8gPSAwKSwgdGhpcy5fc2VtYXBob3JlLnJ1bkV4Y2x1c2l2ZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlKCk7XG4gICAgfSwgMSwgbyk7XG4gIH0sIHQucHJvdG90eXBlLmlzTG9ja2VkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS5pc0xvY2tlZCgpO1xuICB9LCB0LnByb3RvdHlwZS53YWl0Rm9yVW5sb2NrID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwgdGhpcy5fc2VtYXBob3JlLndhaXRGb3JVbmxvY2soMSwgZSk7XG4gIH0sIHQucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zZW1hcGhvcmUuaXNMb2NrZWQoKSAmJiB0aGlzLl9zZW1hcGhvcmUucmVsZWFzZSgpO1xuICB9LCB0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLmNhbmNlbCgpO1xuICB9LCB0O1xufSgpO1xuZnVuY3Rpb24gaXNNZXRhTWFza1Byb3ZpZGVyKHQpIHtcbiAgcmV0dXJuIHQgIT09IG51bGwgJiYgdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0Lmhhc093blByb3BlcnR5KFwiaXNNZXRhTWFza1wiKSAmJiB0Lmhhc093blByb3BlcnR5KFwicmVxdWVzdFwiKTtcbn1cbmZ1bmN0aW9uIGRldGVjdE1ldGFNYXNrUHJvdmlkZXIodCwgeyB0aW1lb3V0OiBlID0gM2UzIH0gPSB7fSkge1xuICBsZXQgbyA9ICExO1xuICByZXR1cm4gbmV3IFByb21pc2UoKG4pID0+IHtcbiAgICBjb25zdCByID0gKGkpID0+IHtcbiAgICAgIGNvbnN0IHsgaW5mbzogYSwgcHJvdmlkZXI6IHMgfSA9IGkuZGV0YWlsO1xuICAgICAgKGEucmRucyA9PT0gXCJpby5tZXRhbWFza1wiIHx8IGEucmRucyA9PT0gXCJpby5tZXRhbWFzay5mbGFza1wiKSAmJiBpc01ldGFNYXNrUHJvdmlkZXIocykgJiYgKG4ocyksIG8gPSAhMCk7XG4gICAgfTtcbiAgICB0eXBlb2YgdC5hZGRFdmVudExpc3RlbmVyID09IFwiZnVuY3Rpb25cIiAmJiB0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcImVpcDY5NjM6YW5ub3VuY2VQcm92aWRlclwiLFxuICAgICAgclxuICAgICksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbyB8fCBuKG51bGwpO1xuICAgIH0sIGUpLCB0eXBlb2YgdC5kaXNwYXRjaEV2ZW50ID09IFwiZnVuY3Rpb25cIiAmJiB0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiZWlwNjk2MzpyZXF1ZXN0UHJvdmlkZXJcIikpO1xuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JNZXRhTWFza1Byb3ZpZGVyKHQsIGUgPSB7fSkge1xuICBjb25zdCB7IHRpbWVvdXQ6IG8gPSAzZTMsIHJldHJpZXM6IG4gPSAwIH0gPSBlO1xuICBsZXQgciA9IG51bGw7XG4gIHRyeSB7XG4gICAgciA9IGF3YWl0IGRldGVjdE1ldGFNYXNrUHJvdmlkZXIodCwgeyB0aW1lb3V0OiBvIH0pO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gciB8fCAobiA9PT0gMCA/IG51bGwgOiAociA9IGF3YWl0IHdhaXRGb3JNZXRhTWFza1Byb3ZpZGVyKHsgdGltZW91dDogbywgcmV0cmllczogbiAtIDEgfSksIHIpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRldGVjdE1ldGFtYXNrU3VwcG9ydCh0KSB7XG4gIHJldHVybiBhd2FpdCB3YWl0Rm9yTWV0YU1hc2tQcm92aWRlcih0LCB7IHJldHJpZXM6IDMgfSk7XG59XG52YXIgUSwgcSwgQywgRywgWSwgSjtcbmNsYXNzIE1ldGFNYXNrVmlydHVhbFdhbGxldCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIFQodGhpcywgUSksIFQodGhpcywgQyksIFQodGhpcywgWSksIF8odGhpcywgXCJpZFwiLCBcIm1ldGFtYXNrXCIpLCBfKHRoaXMsIFwibmFtZVwiLCBcIk1ldGFNYXNrXCIpLCBfKHRoaXMsIFwiaWNvblwiLCBcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4O2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TVRJaUlHaGxhV2RvZEQwaU1UZzVJaUIyYVdWM1FtOTRQU0l3SURBZ01qRXlJREU0T1NJK1BHY2dabWxzYkQwaWJtOXVaU0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWo0OGNHOXNlV2R2YmlCbWFXeHNQU0lqUTBSQ1JFSXlJaUJ3YjJsdWRITTlJall3TGpjMUlERTNNeTR5TlNBNE9DNHpNVE1nTVRnd0xqVTJNeUE0T0M0ek1UTWdNVGN4SURrd0xqVTJNeUF4TmpndU56VWdNVEEyTGpNeE15QXhOamd1TnpVZ01UQTJMak14TXlBeE9EQWdNVEEyTGpNeE15QXhPRGN1T0RjMUlEZzVMalF6T0NBeE9EY3VPRGMxSURZNExqWXlOU0F4TnpndU9EYzFJaTgrUEhCdmJIbG5iMjRnWm1sc2JEMGlJME5FUWtSQ01pSWdjRzlwYm5SelBTSXhNRFV1TnpVZ01UY3pMakkxSURFek1pNDNOU0F4T0RBdU5UWXpJREV6TWk0M05TQXhOekVnTVRNMUlERTJPQzQzTlNBeE5UQXVOelVnTVRZNExqYzFJREUxTUM0M05TQXhPREFnTVRVd0xqYzFJREU0Tnk0NE56VWdNVE16TGpnM05TQXhPRGN1T0RjMUlERXhNeTR3TmpNZ01UYzRMamczTlNJZ2RISmhibk5tYjNKdFBTSnRZWFJ5YVhnb0xURWdNQ0F3SURFZ01qVTJMalVnTUNraUx6NDhjRzlzZVdkdmJpQm1hV3hzUFNJak16a3pPVE01SWlCd2IybHVkSE05SWprd0xqVTJNeUF4TlRJdU5ETTRJRGc0TGpNeE15QXhOekVnT1RFdU1USTFJREUyT0M0M05TQXhNakF1TXpjMUlERTJPQzQzTlNBeE1qTXVOelVnTVRjeElERXlNUzQxSURFMU1pNDBNemdnTVRFM0lERTBPUzQyTWpVZ09UUXVOU0F4TlRBdU1UZzRJaTgrUEhCdmJIbG5iMjRnWm1sc2JEMGlJMFk0T1VNek5TSWdjRzlwYm5SelBTSTNOUzR6TnpVZ01qY2dPRGd1T0RjMUlEVTRMalVnT1RVdU1EWXpJREUxTUM0eE9EZ2dNVEUzSURFMU1DNHhPRGdnTVRJekxqYzFJRFU0TGpVZ01UTTJMakV5TlNBeU55SXZQanh3YjJ4NVoyOXVJR1pwYkd3OUlpTkdPRGxFTXpVaUlIQnZhVzUwY3owaU1UWXVNekV6SURrMkxqRTRPQ0F1TlRZeklERTBNUzQzTlNBek9TNDVNemdnTVRNNUxqVWdOalV1TWpVZ01UTTVMalVnTmpVdU1qVWdNVEU1TGpneE15QTJOQzR4TWpVZ056a3VNekV6SURVNExqVWdPRE11T0RFeklpOCtQSEJ2YkhsbmIyNGdabWxzYkQwaUkwUTROME16TUNJZ2NHOXBiblJ6UFNJME5pNHhNalVnTVRBeExqSTFJRGt5TGpJMUlERXdNaTR6TnpVZ09EY3VNVGc0SURFeU5pQTJOUzR5TlNBeE1qQXVNemMxSWk4K1BIQnZiSGxuYjI0Z1ptbHNiRDBpSTBWQk9FUXpRU0lnY0c5cGJuUnpQU0kwTmk0eE1qVWdNVEF4TGpneE15QTJOUzR5TlNBeE1Ua3VPREV6SURZMUxqSTFJREV6Tnk0NE1UTWlMejQ4Y0c5c2VXZHZiaUJtYVd4c1BTSWpSamc1UkRNMUlpQndiMmx1ZEhNOUlqWTFMakkxSURFeU1DNHpOelVnT0RjdU56VWdNVEkySURrMUxqQTJNeUF4TlRBdU1UZzRJRGt3SURFMU15QTJOUzR5TlNBeE16Z3VNemMxSWk4K1BIQnZiSGxuYjI0Z1ptbHNiRDBpSTBWQ09FWXpOU0lnY0c5cGJuUnpQU0kyTlM0eU5TQXhNemd1TXpjMUlEWXdMamMxSURFM015NHlOU0E1TUM0MU5qTWdNVFV5TGpRek9DSXZQanh3YjJ4NVoyOXVJR1pwYkd3OUlpTkZRVGhGTTBFaUlIQnZhVzUwY3owaU9USXVNalVnTVRBeUxqTTNOU0E1TlM0d05qTWdNVFV3TGpFNE9DQTROaTQyTWpVZ01USTFMamN4T1NJdlBqeHdiMng1WjI5dUlHWnBiR3c5SWlORU9EZERNekFpSUhCdmFXNTBjejBpTXprdU16YzFJREV6T0M0NU16Z2dOalV1TWpVZ01UTTRMak0zTlNBMk1DNDNOU0F4TnpNdU1qVWlMejQ4Y0c5c2VXZHZiaUJtYVd4c1BTSWpSVUk0UmpNMUlpQndiMmx1ZEhNOUlqRXlMamt6T0NBeE9EZ3VORE00SURZd0xqYzFJREUzTXk0eU5TQXpPUzR6TnpVZ01UTTRMamt6T0NBdU5UWXpJREUwTVM0M05TSXZQanh3YjJ4NVoyOXVJR1pwYkd3OUlpTkZPRGd5TVVVaUlIQnZhVzUwY3owaU9EZ3VPRGMxSURVNExqVWdOalF1TmpnNElEYzRMamMxSURRMkxqRXlOU0F4TURFdU1qVWdPVEl1TWpVZ01UQXlMamt6T0NJdlBqeHdiMng1WjI5dUlHWnBiR3c5SWlORVJrTkZRek1pSUhCdmFXNTBjejBpTmpBdU56VWdNVGN6TGpJMUlEa3dMalUyTXlBeE5USXVORE00SURnNExqTXhNeUF4TnpBdU5ETTRJRGc0TGpNeE15QXhPREF1TlRZeklEWTRMakEyTXlBeE56WXVOakkxSWk4K1BIQnZiSGxuYjI0Z1ptbHNiRDBpSTBSR1EwVkRNeUlnY0c5cGJuUnpQU0l4TWpFdU5TQXhOek11TWpVZ01UVXdMamMxSURFMU1pNDBNemdnTVRRNExqVWdNVGN3TGpRek9DQXhORGd1TlNBeE9EQXVOVFl6SURFeU9DNHlOU0F4TnpZdU5qSTFJaUIwY21GdWMyWnZjbTA5SW0xaGRISnBlQ2d0TVNBd0lEQWdNU0F5TnpJdU1qVWdNQ2tpTHo0OGNHOXNlV2R2YmlCbWFXeHNQU0lqTXprek9UTTVJaUJ3YjJsdWRITTlJamN3TGpNeE15QXhNVEl1TlNBMk5DNHhNalVnTVRJMUxqUXpPQ0E0Tmk0d05qTWdNVEU1TGpneE15SWdkSEpoYm5ObWIzSnRQU0p0WVhSeWFYZ29MVEVnTUNBd0lERWdNVFV3TGpFNE9DQXdLU0l2UGp4d2IyeDVaMjl1SUdacGJHdzlJaU5GT0RoR016VWlJSEJ2YVc1MGN6MGlNVEl1TXpjMUlDNDFOak1nT0RndU9EYzFJRFU0TGpVZ056VXVPVE00SURJM0lpOCtQSEJoZEdnZ1ptbHNiRDBpSXpoRk5VRXpNQ0lnWkQwaVRURXlMak0zTlRBd01ESXNNQzQxTmpJMU1EQXdNRGdnVERJdU1qVXdNREF3TURNc016RXVOVEF3TURBd05TQk1OeTQ0TnpVd01EQXhNaXcyTlM0eU5UQXdNREVnVERNdU9UTTNOVEF3TURZc05qY3VOVEF3TURBeElFdzVMalUyTWpVd01ERTBMRGN5TGpVMk1qVWdURFV1TURZeU5UQXdNRGdzTnpZdU5UQXdNREF4TVNCTU1URXVNalVzT0RJdU1USTFNREF4TWlCTU55NHpNVEkxTURBeE1TdzROUzQxTURBd01ERXpJRXd4Tmk0ek1USTFNREF5TERrMkxqYzFNREF3TVRRZ1REVTRMalV3TURBd01Ea3NPRE11T0RFeU5UQXhNaUJETnprdU1USTFNREF4TWl3Mk55NHpNVEkxTURBMElEZzVMakkxTURBd01UTXNOVGd1T0RjMU1EQXdNeUE0T0M0NE56VXdNREV6TERVNExqVXdNREF3TURrZ1F6ZzRMalV3TURBd01UTXNOVGd1TVRJMU1EQXdPU0EyTXk0d01EQXdNREE1TERNNExqZ3hNalV3TURZZ01USXVNemMxTURBd01pd3dMalUyTWpVd01EQXdPQ0JhSWk4K1BHY2dkSEpoYm5ObWIzSnRQU0p0WVhSeWFYZ29MVEVnTUNBd0lERWdNakV4TGpVZ01Da2lQanh3YjJ4NVoyOXVJR1pwYkd3OUlpTkdPRGxFTXpVaUlIQnZhVzUwY3owaU1UWXVNekV6SURrMkxqRTRPQ0F1TlRZeklERTBNUzQzTlNBek9TNDVNemdnTVRNNUxqVWdOalV1TWpVZ01UTTVMalVnTmpVdU1qVWdNVEU1TGpneE15QTJOQzR4TWpVZ056a3VNekV6SURVNExqVWdPRE11T0RFeklpOCtQSEJ2YkhsbmIyNGdabWxzYkQwaUkwUTROME16TUNJZ2NHOXBiblJ6UFNJME5pNHhNalVnTVRBeExqSTFJRGt5TGpJMUlERXdNaTR6TnpVZ09EY3VNVGc0SURFeU5pQTJOUzR5TlNBeE1qQXVNemMxSWk4K1BIQnZiSGxuYjI0Z1ptbHNiRDBpSTBWQk9FUXpRU0lnY0c5cGJuUnpQU0kwTmk0eE1qVWdNVEF4TGpneE15QTJOUzR5TlNBeE1Ua3VPREV6SURZMUxqSTFJREV6Tnk0NE1UTWlMejQ4Y0c5c2VXZHZiaUJtYVd4c1BTSWpSamc1UkRNMUlpQndiMmx1ZEhNOUlqWTFMakkxSURFeU1DNHpOelVnT0RjdU56VWdNVEkySURrMUxqQTJNeUF4TlRBdU1UZzRJRGt3SURFMU15QTJOUzR5TlNBeE16Z3VNemMxSWk4K1BIQnZiSGxuYjI0Z1ptbHNiRDBpSTBWQ09FWXpOU0lnY0c5cGJuUnpQU0kyTlM0eU5TQXhNemd1TXpjMUlEWXdMamMxSURFM015NHlOU0E1TUNBeE5UTWlMejQ4Y0c5c2VXZHZiaUJtYVd4c1BTSWpSVUU0UlROQklpQndiMmx1ZEhNOUlqa3lMakkxSURFd01pNHpOelVnT1RVdU1EWXpJREUxTUM0eE9EZ2dPRFl1TmpJMUlERXlOUzQzTVRraUx6NDhjRzlzZVdkdmJpQm1hV3hzUFNJalJEZzNRek13SWlCd2IybHVkSE05SWpNNUxqTTNOU0F4TXpndU9UTTRJRFkxTGpJMUlERXpPQzR6TnpVZ05qQXVOelVnTVRjekxqSTFJaTgrUEhCdmJIbG5iMjRnWm1sc2JEMGlJMFZDT0VZek5TSWdjRzlwYm5SelBTSXhNaTQ1TXpnZ01UZzRMalF6T0NBMk1DNDNOU0F4TnpNdU1qVWdNemt1TXpjMUlERXpPQzQ1TXpnZ0xqVTJNeUF4TkRFdU56VWlMejQ4Y0c5c2VXZHZiaUJtYVd4c1BTSWpSVGc0TWpGRklpQndiMmx1ZEhNOUlqZzRMamczTlNBMU9DNDFJRFkwTGpZNE9DQTNPQzQzTlNBME5pNHhNalVnTVRBeExqSTFJRGt5TGpJMUlERXdNaTQ1TXpnaUx6NDhjRzlzZVdkdmJpQm1hV3hzUFNJak16a3pPVE01SWlCd2IybHVkSE05SWpjd0xqTXhNeUF4TVRJdU5TQTJOQzR4TWpVZ01USTFMalF6T0NBNE5pNHdOak1nTVRFNUxqZ3hNeUlnZEhKaGJuTm1iM0p0UFNKdFlYUnlhWGdvTFRFZ01DQXdJREVnTVRVd0xqRTRPQ0F3S1NJdlBqeHdiMng1WjI5dUlHWnBiR3c5SWlORk9EaEdNelVpSUhCdmFXNTBjejBpTVRJdU16YzFJQzQxTmpNZ09EZ3VPRGMxSURVNExqVWdOelV1T1RNNElESTNJaTgrUEhCaGRHZ2dabWxzYkQwaUl6aEZOVUV6TUNJZ1pEMGlUVEV5TGpNM05UQXdNRElzTUM0MU5qSTFNREF3TURnZ1RESXVNalV3TURBd01ETXNNekV1TlRBd01EQXdOU0JNTnk0NE56VXdNREF4TWl3Mk5TNHlOVEF3TURFZ1RETXVPVE0zTlRBd01EWXNOamN1TlRBd01EQXhJRXc1TGpVMk1qVXdNREUwTERjeUxqVTJNalVnVERVdU1EWXlOVEF3TURnc056WXVOVEF3TURBeE1TQk1NVEV1TWpVc09ESXVNVEkxTURBeE1pQk1OeTR6TVRJMU1EQXhNU3c0TlM0MU1EQXdNREV6SUV3eE5pNHpNVEkxTURBeUxEazJMamMxTURBd01UUWdURFU0TGpVd01EQXdNRGtzT0RNdU9ERXlOVEF4TWlCRE56a3VNVEkxTURBeE1pdzJOeTR6TVRJMU1EQTBJRGc1TGpJMU1EQXdNVE1zTlRndU9EYzFNREF3TXlBNE9DNDROelV3TURFekxEVTRMalV3TURBd01Ea2dRemc0TGpVd01EQXdNVE1zTlRndU1USTFNREF3T1NBMk15NHdNREF3TURBNUxETTRMamd4TWpVd01EWWdNVEl1TXpjMU1EQXdNaXd3TGpVMk1qVXdNREF3T0NCYUlpOCtQQzluUGp3dlp6NDhMM04yWno0PVwiKSwgXyh0aGlzLCBcIndpbmRvd0tleVwiLCBcInN0YXJrbmV0X21ldGFtYXNrXCIpLCBfKHRoaXMsIFwicHJvdmlkZXJcIiwgbnVsbCksIF8odGhpcywgXCJzd29cIiwgbnVsbCksIF8odGhpcywgXCJsb2NrXCIpLCBfKHRoaXMsIFwidmVyc2lvblwiLCBcInYyLjAuMFwiKSwgdGhpcy5sb2NrID0gbmV3IE11dGV4KCk7XG4gIH1cbiAgYXN5bmMgbG9hZFdhbGxldChlKSB7XG4gICAgcmV0dXJuIGF3YWl0IEUodGhpcywgQywgRykuY2FsbCh0aGlzLCBlKSwgdGhpcztcbiAgfVxuICBhc3luYyBoYXNTdXBwb3J0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlciA9IGF3YWl0IGRldGVjdE1ldGFtYXNrU3VwcG9ydChlKSwgdGhpcy5wcm92aWRlciAhPT0gbnVsbDtcbiAgfVxuICBhc3luYyByZXF1ZXN0KGUpIHtcbiAgICByZXR1cm4gRSh0aGlzLCBDLCBHKS5jYWxsKHRoaXMpLnRoZW4oKG8pID0+IG8ucmVxdWVzdChcbiAgICAgIGVcbiAgICApKTtcbiAgfVxuICBvbihlLCBvKSB7XG4gICAgRSh0aGlzLCBDLCBHKS5jYWxsKHRoaXMpLnRoZW4oXG4gICAgICAobikgPT4gbi5vbihlLCBvKVxuICAgICk7XG4gIH1cbiAgb2ZmKGUsIG8pIHtcbiAgICBFKHRoaXMsIEMsIEcpLmNhbGwodGhpcykudGhlbihcbiAgICAgIChuKSA9PiBuLm9mZihlLCBvKVxuICAgICk7XG4gIH1cbn1cblEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSwgcSA9IGFzeW5jIGZ1bmN0aW9uKHQpIHtcbiAgdGhpcy5wcm92aWRlciB8fCAodGhpcy5wcm92aWRlciA9IGF3YWl0IGRldGVjdE1ldGFtYXNrU3VwcG9ydCh0KSksIGF3YWl0IGluaXQoe1xuICAgIG5hbWU6IFwiTWV0YU1hc2tTdGFya25ldFNuYXBXYWxsZXRcIixcbiAgICByZW1vdGVzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiTWV0YU1hc2tTdGFya25ldFNuYXBXYWxsZXRcIixcbiAgICAgICAgYWxpYXM6IFwiTWV0YU1hc2tTdGFya25ldFNuYXBXYWxsZXRcIixcbiAgICAgICAgZW50cnk6IGBodHRwczovL3NuYXBzLmNvbnNlbnN5cy5pby9zdGFya25ldC9nZXQtc3RhcmtuZXQvdjEvcmVtb3RlRW50cnkuanM/dHM9JHtEYXRlLm5vdygpfWBcbiAgICAgIH1cbiAgICBdXG4gIH0pO1xuICBjb25zdCBlID0gYXdhaXQgbG9hZFJlbW90ZShcIk1ldGFNYXNrU3RhcmtuZXRTbmFwV2FsbGV0L2luZGV4XCIpO1xuICBpZiAoIWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgTWV0YU1hc2sgV2FsbGV0XCIpO1xuICByZXR1cm4gbmV3IGUuTWV0YU1hc2tTbmFwV2FsbGV0KFxuICAgIHRoaXMucHJvdmlkZXIsXG4gICAgXCIqXCJcbiAgKTtcbn0sIEMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSwgRyA9IGFzeW5jIGZ1bmN0aW9uKHQgPSB3aW5kb3cpIHtcbiAgcmV0dXJuIHRoaXMubG9jay5ydW5FeGNsdXNpdmUoYXN5bmMgKCkgPT4gKHRoaXMuc3dvIHx8ICh0aGlzLnN3byA9IGF3YWl0IEUodGhpcywgUSwgcSkuY2FsbCh0aGlzLCB0KSwgRSh0aGlzLCBZLCBKKS5jYWxsKHRoaXMpKSwgdGhpcy5zd28pKTtcbn0sIFkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSwgSiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN3byAmJiAodGhpcy52ZXJzaW9uID0gdGhpcy5zd28udmVyc2lvbiwgdGhpcy5uYW1lID0gdGhpcy5zd28ubmFtZSwgdGhpcy5pZCA9IHRoaXMuc3dvLmlkLCB0aGlzLmljb24gPSB0aGlzLnN3by5pY29uKTtcbn07XG5jb25zdCBtZXRhTWFza1ZpcnR1YWxXYWxsZXQgPSBuZXcgTWV0YU1hc2tWaXJ0dWFsV2FsbGV0KCk7XG52YXIgWCwgWjtcbmNvbnN0IHdhbGxldHMgPSBbXG4gIHtcbiAgICBpZDogXCJhcmdlbnRYXCIsXG4gICAgbmFtZTogXCJBcmdlbnQgWFwiLFxuICAgIGljb246IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxDanh6ZG1jZ2QybGtkR2c5SWpRd0lpQm9aV2xuYUhROUlqTTJJaUIyYVdWM1FtOTRQU0l3SURBZ05EQWdNellpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK0NqeHdZWFJvSUdROUlrMHlOQzQzTlRneUlDMHpMamszTXpZMFpTMHdOMGd4TkM0Mk1qTTRRekUwTGpJNE5URWdMVE11T1Rjek5qUmxMVEEzSURFMExqQXhNemdnTUM0eU9ERXhOemdnTVRRdU1EQTJOQ0F3TGpZek1EWTRNME14TXk0NE1ERTNJREV3TGpRMU5Ea2dPQzQ0TWpJek5DQXhPUzQzTnpreUlEQXVNalV4T0RreklESTJMak00TXpkRExUQXVNREl3TWpBME5pQXlOaTQxT1RNeklDMHdMakE0TWpFNU5EWWdNall1T1RnM01pQXdMakV4Tmpjek5DQXlOeTR5TnpBNVREWXVNRFEyTWpNZ016VXVOek0wUXpZdU1qUTNPVFlnTXpZdU1ESXlJRFl1TmpRd09Ua2dNell1TURnM0lEWXVPVEUzTmpZZ016VXVPRGMxTkVNeE1pNHlOelkxSURNeExqYzNNamdnTVRZdU5UZzJPU0F5Tmk0NE1qTTJJREU1TGpZNU1TQXlNUzR6TXpoRE1qSXVOemsxTVNBeU5pNDRNak0ySURJM0xqRXdOVGNnTXpFdU56Y3lPQ0F6TWk0ME5qUTJJRE0xTGpnM05UUkRNekl1TnpReElETTJMakE0TnlBek15NHhNelF4SURNMkxqQXlNaUF6TXk0ek16WXhJRE0xTGpjek5Fd3pPUzR5TmpVMklESTNMakkzTURsRE16a3VORFkwTWlBeU5pNDVPRGN5SURNNUxqUXdNaklnTWpZdU5Ua3pNeUF6T1M0eE16QTBJREkyTGpNNE16ZERNekF1TlRVNU55QXhPUzQzTnpreUlESTFMalU0TURRZ01UQXVORFUwT1NBeU5TNHpOelU1SURBdU5qTXdOamd6UXpJMUxqTTJPRFVnTUM0eU9ERXhOemdnTWpVdU1EazJPU0F0TXk0NU56TTJOR1V0TURjZ01qUXVOelU0TWlBdE15NDVOek0yTkdVdE1EZGFJaUJtYVd4c1BTSWpSa1k0TnpWQ0lpOCtDand2YzNablBnbz1cIixcbiAgICBkb3dubG9hZHM6IHtcbiAgICAgIGNocm9tZTogXCJodHRwczovL2Nocm9tZS5nb29nbGUuY29tL3dlYnN0b3JlL2RldGFpbC9hcmdlbnQteC1zdGFya25ldC13YWxsZXQvZGxjb2JwamlpZ3Bpa29vYm9obWFiZWhobWhmb29kYmJcIixcbiAgICAgIGZpcmVmb3g6IFwiaHR0cHM6Ly9hZGRvbnMubW96aWxsYS5vcmcvZW4tVVMvZmlyZWZveC9hZGRvbi9hcmdlbnQteFwiLFxuICAgICAgZWRnZTogXCJodHRwczovL21pY3Jvc29mdGVkZ2UubWljcm9zb2Z0LmNvbS9hZGRvbnMvZGV0YWlsL2FyZ2VudC14L2FqY2ljamxraWJvbGJlYWFhZ2VqZmhub2ZvZ29jZ2NqXCJcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBpZDogXCJicmFhdm9zXCIsXG4gICAgbmFtZTogXCJCcmFhdm9zXCIsXG4gICAgaWNvbjogXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVEF3SWlCb1pXbG5hSFE5SWpFd01DSWdkbWxsZDBKdmVEMGlNQ0F3SURFd01DQXhNREFpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK0NpQWdJQ0E4Y0dGMGFBb2dJQ0FnSUNBZ0lHUTlJazAyTWk0M01EVWdNVE11T1RFeE5rTTJNaTQ0TXpVNUlERTBMakV6TXpNZ05qSXVOall5TVNBeE5DNDBNRGNnTmpJdU5EQXpPU0F4TkM0ME1EZEROVGN1TVRnd055QXhOQzQwTURjZ05USXVPVE0wT0NBeE9DNDFOREkzSURVeUxqZ3pOVEVnTWpNdU5qZ3hOME0xTVM0d05EWTFJREl6TGpNME56Y2dORGt1TVRrek15QXlNeTR6TWpJMklEUTNMak0yTWpZZ01qTXVOak14TVVNME55NHlNell4SURFNExqVXhOVFlnTkRNdU1EQXdPU0F4TkM0ME1EY2dNemN1TnprME9DQXhOQzQwTURkRE16Y3VOVE0yTlNBeE5DNDBNRGNnTXpjdU16WXlOU0F4TkM0eE16TXhJRE0zTGpRNU16VWdNVE11T1RFeE1rTTBNQzR3TWpFM0lEa3VOakk0TURrZ05EUXVOekl3TkNBMkxqYzFJRFV3TGpBNU9URWdOaTQzTlVNMU5TNDBOemd4SURZdU56VWdOakF1TVRjMk9TQTVMall5T0RJMklEWXlMamN3TlNBeE15NDVNVEUyV2lJS0lDQWdJQ0FnSUNCbWFXeHNQU0oxY213b0kzQmhhVzUwTUY5c2FXNWxZWEpmTXpjeVh6UXdNalU1S1NJZ0x6NEtJQ0FnSUR4d1lYUm9DaUFnSUNBZ0lDQWdaRDBpVFRjNExqYzJNRFlnTkRVdU9EY3hPRU00TUM0eU56STFJRFEyTGpNeU9UY2dPREV1TnpBeU5TQTBOUzR3TURVMUlEZ3hMakUzTVRRZ05ETXVOVEl5TWtNM05pNDBNVE0zSURNd0xqSXpNelFnTmpFdU16a3hNU0F5TkM0NE1ETTVJRFV3TGpBeU56Y2dNalF1T0RBek9VTXpPQzQyTkRReUlESTBMamd3TXprZ01qTXVNamcyT0NBek1DNDBNRGNnTVRndU9EYzFOQ0EwTXk0MU9URXlRekU0TGpNNE1qUWdORFV1TURZME5TQXhPUzQ0TURneklEUTJMak0wTkRZZ01qRXVNamszT0NBME5TNDRPRGd4VERRNExqZzNNaUF6Tnk0ME16Z3hRelE1TGpVek16RWdNemN1TWpNMU5TQTFNQzR5TXprNUlETTNMakl6TkRRZ05UQXVPVEF4TnlBek55NDBNelE0VERjNExqYzJNRFlnTkRVdU9EY3hPRm9pQ2lBZ0lDQWdJQ0FnWm1sc2JEMGlkWEpzS0NOd1lXbHVkREZmYkdsdVpXRnlYek0zTWw4ME1ESTFPU2tpSUM4K0NpQWdJQ0E4Y0dGMGFBb2dJQ0FnSUNBZ0lHUTlJazB4T0M0NE1UTXlJRFE0TGpFM01EZE1ORGd1T0Rrek5TQXpPUzR3TkRjeVF6UTVMalUxTURZZ016Z3VPRFEzT0NBMU1DNHlOVEkwSURNNExqZzBOek1nTlRBdU9UQTVPQ0F6T1M0d05EVTJURGd4TGpFM09ERWdORGd1TVRjMU1rTTRNeTQyT1RFeUlEUTRMamt6TXpJZ09EVXVOREV4SURVeExqSTBPRE1nT0RVdU5ERXhJRFV6TGpnM016VldPREV1TWpJek0wTTROUzR5T1RRMElEZzNMamc1T1RFZ056a3VNamszTnlBNU15NHlOU0EzTWk0Mk1qUTFJRGt6TGpJMVNEWXhMalUwTURaRE5qQXVORFEwT1NBNU15NHlOU0ExT1M0MU5UYzNJRGt5TGpNMk16Y2dOVGt1TlRVM055QTVNUzR5TmpoV09ERXVOamM0T1VNMU9TNDFOVGMzSURjM0xqa3dNekVnTmpFdU56a3lNU0EzTkM0ME9EVTFJRFkxTGpJME9UZ2dOekl1T1RjeU9VTTJPUzQ0T0RRNUlEY3dMamswTlRRZ056VXVNelk0TVNBMk9DNHlNREk0SURjMkxqTTVPVFFnTmpJdU5qazVNa00zTmk0M016SXpJRFl3TGpreU1qa2dOelV1TlRjME1TQTFPUzR5TURrMElEY3pMamd3TWpRZ05UZ3VPRFUzTTBNMk9TNHpNakkySURVM0xqazJOamNnTmpRdU16VTJNaUExT0M0ek1UQTNJRFl3TGpFMU5qUWdOakF1TVRnNU0wTTFOUzR6T0RnM0lEWXlMak15TVRrZ05UUXVNVFF4TlNBMk5TNDROamswSURVekxqWTNPVGNnTnpBdU5qTXpOMHcxTXk0eE1qQXhJRGMxTGpjMk5qSkROVEl1T1RRNU1TQTNOeTR6TXpRNUlEVXhMalEzT0RVZ056Z3VOVE0yTmlBME9TNDVNREUwSURjNExqVXpOalpETkRndU1qWTVPU0EzT0M0MU16WTJJRFEzTGpBME5qVWdOemN1TWprMElEUTJMamcyT1RZZ056VXVOamN4TWt3ME5pNHpNakEwSURjd0xqWXpNemRETkRVdU9USTBPU0EyTmk0MU5USTVJRFExTGpJd056a2dOakl1TlRnNE55QTBNQzQ1T0RrMUlEWXdMamN3TVRoRE16WXVNVGMzTmlBMU9DNDFORGswSURNeExqTTBNVGtnTlRjdU9ETTBOeUF5Tmk0eE9UYzJJRFU0TGpnMU56TkRNalF1TkRJMklEVTVMakl3T1RRZ01qTXVNalkzT0NBMk1DNDVNakk1SURJekxqWXdNRGNnTmpJdU5qazVNa015TkM0Mk5ERWdOamd1TWpVd055QXpNQzR3T0RFeUlEY3dMamt6TURVZ016UXVOelV3TXlBM01pNDVOekk1UXpNNExqSXdPQ0EzTkM0ME9EVTFJRFF3TGpRME1qUWdOemN1T1RBek1TQTBNQzQwTkRJMElEZ3hMalkzT0RsV09URXVNalkyTTBNME1DNDBOREkwSURreUxqTTJNaUF6T1M0MU5UVTFJRGt6TGpJMUlETTRMalExT1RrZ09UTXVNalZJTWpjdU16YzFOa015TUM0M01ESTBJRGt6TGpJMUlERTBMamN3TlRjZ09EY3VPRGs1TVNBeE5DNDFPRGt4SURneExqSXlNek5XTlRNdU9EWTJNME14TkM0MU9Ea3hJRFV4TGpJME5EWWdNVFl1TXpBME5TQTBPQzQ1TXpFMklERTRMamd4TXpJZ05EZ3VNVGN3TjFvaUNpQWdJQ0FnSUNBZ1ptbHNiRDBpZFhKc0tDTndZV2x1ZERKZmJHbHVaV0Z5WHpNM01sODBNREkxT1NraUlDOCtDaUFnSUNBOFpHVm1jejRLSUNBZ0lDQWdJQ0E4YkdsdVpXRnlSM0poWkdsbGJuUWdhV1E5SW5CaGFXNTBNRjlzYVc1bFlYSmZNemN5WHpRd01qVTVJaUI0TVQwaU5Ea3VNekExTnlJZ2VURTlJakl1TURjNUlpQjRNajBpT0RBdU16WXlOeUlnZVRJOUlqa3pMalkxT1RjaUNpQWdJQ0FnSUNBZ0lDQWdJR2R5WVdScFpXNTBWVzVwZEhNOUluVnpaWEpUY0dGalpVOXVWWE5sSWo0S0lDQWdJQ0FnSUNBZ0lDQWdQSE4wYjNBZ2MzUnZjQzFqYjJ4dmNqMGlJMFkxUkRRMVJTSWdMejRLSUNBZ0lDQWdJQ0FnSUNBZ1BITjBiM0FnYjJabWMyVjBQU0l4SWlCemRHOXdMV052Ykc5eVBTSWpSa1k1TmpBd0lpQXZQZ29nSUNBZ0lDQWdJRHd2YkdsdVpXRnlSM0poWkdsbGJuUStDaUFnSUNBZ0lDQWdQR3hwYm1WaGNrZHlZV1JwWlc1MElHbGtQU0p3WVdsdWRERmZiR2x1WldGeVh6TTNNbDgwTURJMU9TSWdlREU5SWpRNUxqTXdOVGNpSUhreFBTSXlMakEzT1NJZ2VESTlJamd3TGpNMk1qY2lJSGt5UFNJNU15NDJOVGszSWdvZ0lDQWdJQ0FnSUNBZ0lDQm5jbUZrYVdWdWRGVnVhWFJ6UFNKMWMyVnlVM0JoWTJWUGJsVnpaU0krQ2lBZ0lDQWdJQ0FnSUNBZ0lEeHpkRzl3SUhOMGIzQXRZMjlzYjNJOUlpTkdOVVEwTlVVaUlDOCtDaUFnSUNBZ0lDQWdJQ0FnSUR4emRHOXdJRzltWm5ObGREMGlNU0lnYzNSdmNDMWpiMnh2Y2owaUkwWkdPVFl3TUNJZ0x6NEtJQ0FnSUNBZ0lDQThMMnhwYm1WaGNrZHlZV1JwWlc1MFBnb2dJQ0FnSUNBZ0lEeHNhVzVsWVhKSGNtRmthV1Z1ZENCcFpEMGljR0ZwYm5ReVgyeHBibVZoY2w4ek56SmZOREF5TlRraUlIZ3hQU0kwT1M0ek1EVTNJaUI1TVQwaU1pNHdOemtpSUhneVBTSTRNQzR6TmpJM0lpQjVNajBpT1RNdU5qVTVOeUlLSUNBZ0lDQWdJQ0FnSUNBZ1ozSmhaR2xsYm5SVmJtbDBjejBpZFhObGNsTndZV05sVDI1VmMyVWlQZ29nSUNBZ0lDQWdJQ0FnSUNBOGMzUnZjQ0J6ZEc5d0xXTnZiRzl5UFNJalJqVkVORFZGSWlBdlBnb2dJQ0FnSUNBZ0lDQWdJQ0E4YzNSdmNDQnZabVp6WlhROUlqRWlJSE4wYjNBdFkyOXNiM0k5SWlOR1JqazJNREFpSUM4K0NpQWdJQ0FnSUNBZ1BDOXNhVzVsWVhKSGNtRmthV1Z1ZEQ0S0lDQWdJRHd2WkdWbWN6NEtQQzl6ZG1jK1wiLFxuICAgIGRvd25sb2Fkczoge1xuICAgICAgY2hyb21lOiBcImh0dHBzOi8vY2hyb21lLmdvb2dsZS5jb20vd2Vic3RvcmUvZGV0YWlsL2JyYWF2b3Mtd2FsbGV0L2pubGdhbWVjYnBtYmFqamZobW1tbGhlamtlbWVqZG1hXCIsXG4gICAgICBmaXJlZm94OiBcImh0dHBzOi8vYWRkb25zLm1vemlsbGEub3JnL2VuLVVTL2ZpcmVmb3gvYWRkb24vYnJhYXZvcy13YWxsZXRcIixcbiAgICAgIGVkZ2U6IFwiaHR0cHM6Ly9taWNyb3NvZnRlZGdlLm1pY3Jvc29mdC5jb20vYWRkb25zL2RldGFpbC9icmFhdm9zLXdhbGxldC9oa2twamVoaGNuaGdlZmhiZGNnZmtlZWdnbHBqY2hkY1wiLFxuICAgICAgaW9zOiBgaHR0cHM6Ly9saW5rLmJyYWF2b3MuYXBwL2RhcHAvJHsoWCA9IHNzclNhZmVXaW5kb3c/LmxvY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogWC5ob3N0fWAsXG4gICAgICBhbmRyb2lkOiBgaHR0cHM6Ly9saW5rLmJyYWF2b3MuYXBwL2RhcHAvJHsoWiA9IHNzclNhZmVXaW5kb3c/LmxvY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogWi5ob3N0fWBcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBpZDogbWV0YU1hc2tWaXJ0dWFsV2FsbGV0LmlkLFxuICAgIG5hbWU6IG1ldGFNYXNrVmlydHVhbFdhbGxldC5uYW1lLFxuICAgIGljb246IG1ldGFNYXNrVmlydHVhbFdhbGxldC5pY29uLFxuICAgIGRvd25sb2Fkczoge1xuICAgICAgY2hyb21lOiBcImh0dHBzOi8vY2hyb21lLmdvb2dsZS5jb20vd2Vic3RvcmUvZGV0YWlsL21ldGFtYXNrL25rYmloZmJlb2dhZWFvZWhsZWZua29kYmVmZ3Bna25uXCIsXG4gICAgICBmaXJlZm94OiBcImh0dHBzOi8vYWRkb25zLm1vemlsbGEub3JnL2VuLVVTL2ZpcmVmb3gvYWRkb24vZXRoZXItbWV0YW1hc2svXCIsXG4gICAgICBlZGdlOiBcImh0dHBzOi8vbWljcm9zb2Z0ZWRnZS5taWNyb3NvZnQuY29tL2FkZG9ucy9kZXRhaWwvbWV0YW1hc2svZWpiYWxiYWtvcGxjaGxnaGVjZGFsbWVlZWFqbmltaG0/aGw9ZW4tVVNcIlxuICAgIH1cbiAgfSxcbiAge1xuICAgIGlkOiBcIm9reHdhbGxldFwiLFxuICAgIG5hbWU6IFwiT0tYIFdhbGxldFwiLFxuICAgIGljb246IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFEQUFBQUF3Q0FZQUFBQlhBdm1IQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUpEU1VSQlZIZ0I3WnE5anRwQUVNZkhsaEVnUUxpaW9YRWtvQUdFQ3dvS3hNY1RSSG1DNUUzSW95UlBrUEFFa0k3dW5KWW1UZ0VGVFl3QThhM05US1NjTG5DSE42YzlyMWUzUDJsbFdReTdNL3MxR3YxdHdDUDBlajM3ZERxOXgrWnV0MXQzdDl2WmpERUhJaVNSU1BnNFpwREw1ZnhrTXZuMWNEaDhtMHdtZnVnZk81M09vRlFxL2Nybjh3eGZZOUV5bVF5clZDcU1mSHZTY1p4MXA5bHMzcEZ4WEJ5L2JLbFVpcEdQclZiTHVRcUFmc0NsaXEzemwwSDg0end0alFyT3c0TXQxVzYzUDVMdkJtMmQrWHorWXpxZGdrcVV5K1dnV0N5K01jL25jMjgybTRGcUxCWUwrM2c4ZmpEeGVucTcyV3hBTlpiTEplQTEzekRYNjdVRGlvTDV5Ylh3YWZNWXU2NEx0bjNiZER3ZVE1Ujk3ZmQ3R3loQlFNaXB4NFBPZUVESEl1MkxmRGRCSUdHeitoSjlDUTFBQmpvQTJlZ0FaUE02QWdpQ0FFUWhzaS9DNGpIeVBBLzYvZjVORzNLczIrM0NZREM0YVRjY0RybjZvakc1NE1uRXZHMDBHb1ZtV0xJUk5aN3dUQ3dESFlCc2RBQ3kwUUhJaGl1UkVUeGxJQ1dwTU1oR1pIbXFTOHFINkpMeUdlZ0FaS01Ea0kwdUtmOFg0U1dsYVpvK1BwMWJScndsSlU4WktMSXZVaktoMFdpUTNzUlViTlZxOWM1RWJldzdLRW8ybS8xcDRqSjRxQW1EYXFEUUJ6ajVYeWlBVDRWQ1FlekppZ0FVK0lEVSt6OHZKRm5HV2VDK2JLUVYvNVZaNzFGVjZMN1BBM2dnM3RYcmRRK0RnTGhDKzc1V3Ezbm82OVAzTUMwTkZRcHgybEwwNFFsOWdISzFiUkRqc1NCSXZTY0JuRFRrMVdybEdJWkJvcklERVlKaityaGRnblE2N1ZtV1JlMHpscGxYbDgxdmN5RXQwclNvWURVQUFBQUFTVVZPUks1Q1lJST1cIixcbiAgICBkb3dubG9hZHM6IHtcbiAgICAgIGNocm9tZTogXCJodHRwczovL2Nocm9tZS5nb29nbGUuY29tL3dlYnN0b3JlL2RldGFpbC9tY29oaWxuY2JmYWhibWdkamticGVtY2NpaW9sZ2NnZVwiLFxuICAgICAgZmlyZWZveDogXCJodHRwczovL2FkZG9ucy5tb3ppbGxhLm9yZy9lbi1VUy9maXJlZm94L2FkZG9uL29rZXh3YWxsZXRcIixcbiAgICAgIGVkZ2U6IFwiaHR0cHM6Ly9taWNyb3NvZnRlZGdlLm1pY3Jvc29mdC5jb20vYWRkb25zL2RldGFpbC8lRTYlQUMlQTclRTYlOTglOTMtd2ViMy0lRTklOTIlQjElRTUlOEMlODUvcGJwamtjbGRqaWZmY2hnYmJuZG1ob2ppYWNiZ2ZsaGFcIixcbiAgICAgIHNhZmFyaTogXCJodHRwczovL2FwcHMuYXBwbGUuY29tL3VzL2FwcC9va3gtd2FsbGV0L2lkNjQ2Mzc5NzgyNVwiXG4gICAgfVxuICB9LFxuICB7XG4gICAgaWQ6IFwia2VwbHJcIixcbiAgICBuYW1lOiBcIktlcGxyXCIsXG4gICAgaWNvbjogXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUlBQUFBQ0FDQVlBQUFERFBtSExBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFDUGZTVVJCVkhnQnpWMEwwQjlWZFQ5bnZ5L3ZCNm5WT2c0R0V4L1ZFUjNBMWlxbzlhTXpGZ1d0b09oZ3NZYUhZTlYybE5FcXhBZGZtS0hUYWt1RFRnZTFGSksydHFPdEdxb1dGV3RpOFRGU3hHRHJpRlNiSUsrcWdCOTVoK1RiMDkzOTcrNDlyM3QzLzk5L0xUMHptLy9lOTkxN2Z1ZDN6cjI3U1JCK0ViS2QxZ0FjT2hGZy9rU1ltam9CaUo0SmhNc0I2TEhGSmV0Uyt3Zm9Bb3dPUU9LbnVtR1ZVZlNYKzIzQmEwdVJmRmFHc2g2cE5LRHFQMlB6UU41VGJOeHFqQWVxaTJDdVdMdXZBdVU3NGVUMU8rQVhJQWhEU2FYMGcrZkJGTDZ5bUhTaGZGaFQ1UnZka25OTHpzVEliK2NDaG16YjJPSnFKWThhUUc5Z2FBVVhhWExiT0gwZ0w0bVhtWEhDL0hZVXYxdGhFV3lEazliUHdRQXlPUUMySDF3SEdiMjl1TnRRZExjbUZKQnYyQXNGQVBWUUpEUVBsRkJZRkFDcHNvNytrRm0xN2cvOXNVZ3IzUUZXTkkzVnRRV08wS2FDR1hiREJMSndBRlNLejJjTGp0dmdsaE5GR21yNk5vbWd4RVFkVDFrWUs4TjB1ekJ3SDNib3NISm8zRUtrRDFaRzBYNmN0QUZFVzZjQUFpd1lDQXNEd00ySEw0ZTh0SHBhNDVhN05OMlVVYXhCbUZBUG1wZHQrckdEcTB6ZHJwUDJJNnlSaWcwNkFOSE5IdUF3anhsekZwNjdmaE9NS2VNQm9MVDZLYnkrR0hNR21rbHlTVm9zSkFPK2FqSzlMWDZVeGw1MWV5cVpwL3RZdlZjUGJSa2x5blE3YXU5MTNhYWVCd0xSeis2Q0RVNGRodzJ5dmhWaCsrRXpJY1B2Qk9YWGMrU1hKejNMTVZZZUVibE9ZeEtaTXgva0Y0VjcwYVpQditxKzdjZVVtYWl2SFR1MGhEU1dxendSV2E0ckFzVHRjT3V1TTZHbjlBUEF6WWZlVnN6c004VUFhem9WQ2dEajFERUxuZXFyQmdycS9pbHlLVUZ3RkUyUjhjWDhVQUJEMU9tYU94ODdwa3cxMzdneG9QOXNzcTkxeGZVWitQZGRsME1QNlFiQVZ3dC9Qdytib1krTUNRenNxdU5ZNlZoQ0hVb0dOZVk0ZlVLalZMUjlKZElDOElreGtUcnFrZXJWUHNOc0h4Q2sxN1JVUHRGc3RKdzZ0RTJSZk5BUGwzNUNzN1hyU0hjR2hXUEhBREJXSUpqMjVYSjhpcGJKY1VtbFpSMDFGcytiaDB2ZytldWpCaHdIUU9uem9hRDlwRkFpMjVaaEQyWHpQS21ITkFBUXlDL3pIYkNlbEZOR2ljQlBweFA4alpGQTBFbDM3eHlhSEE4b3FtOHVCR2ZCODladjg0cDhBSlRSUHVEMjRtNGRwS1NMQWRoUFBHS3Y4d3g0KzFsOGRPL3Z0VldMMVB2UUtNSUl4T3RGbzNWS0t5OXk0Sk5ta2JvZmxlZjJONUs1Z2dsTzhuWUhmZ3hBaGZKSHdRUWtMOUVtWGdmSHFOY25Ma0JTd1dBUEVVRmZyRzNYczZrOGIrZGc2Nk42UnBTN0ROTXZBcCt2d1RYckIyTHQ3ZHF1Z1dtNEhoeXhBTmhlK1AyVTVmY0JReTBtWWgrbm50T21MMEJjb01SRUs4dk5yOHVpQ2duS2tBRWl4SU81Wm80MUlPS0tyZ1BOV0Z2dzFsaXVWRFdIdk5pK2YvTkhzNkJFcm1kSi9UbnVndDVDbGhsNW1WUGRVbkNrTG5NaGZWd0M4aFV6NWM2OXFpZm00dllCTHJXVDI4NUpxN2FVZEFPTTR1dDAyeWNBa0xFQ2lsZ0diMSsxbmFOY3VnTEpBUFBGMWlGbGlkN0Z4bWpINlZPM1I5OWQyemRPd2EyaytnTnBOVkdHY09iYzV2UFJFeFp2S0Z3eGphaExpbDFvbEdmN3FkMERnV0lYak0rNUhidXNnMnN5eE12VlU5UlNXdi9SL3Ridld5VWZsTVpvUTlZd0U2dmZoeEhLMWVuc3kzSEM2Rmx5cEc1Nml4Wm5CREoxYmYvMk93UGVVOFF5ZWg2bjVrRHJHeFpvR1NBN0NyTWlxUEV1YmpGZEY1dFRuemJHa3Jrb3krTDVIZ3NsR1NieVBHNFFSODVZVHA3UEFCaTEwc2JxVFRCSXltOFQyam5wdnNWOEVFd1E2RWhHOEhhK1p0WEhISGprOE0raHIxRDdSMVRRSzFmdHVtSUF0STFOdW8rVnB3K0dBSG9kOHJSNXFYU3FYNW1PV3ppeGNwYW5ySU04UmhMOXlQNlV6TTBmTGxqZzFQVnpJd1k0Y3VqTVRvdnVRQlZRRDJ0bmMrenkyeW5HNk5vR2RqSkJiTzVRV3hkb2E0YW9qOWZId2w0NmpJTUJYNlRxdDgrai9Ed0VpeGNzd05zVEpOWVN3eFZremFJbGNGNTVVd0VBYzl3d0ZnQThaVVFuWU90MkFjTjFiNG15YnZDaDdJTjZVSDh6THgyZ2dWY25uWTY2QnFwbnhkY0lMRENhWjNEbjMvUksvbk5KQUdON0VVeTlzbGtUd0JzUGVYWmhKRTNKdW9pY05uNDdqSmhsbHd2b1ZlNVJ1YUo1TXo3YXZnQ0hUWnV0bkJxenkwVTBlWGJsS0dJbFJ1YU9ITW5YVDhPTkIyZDZCbys5SmVhZVRKMkJ5OXB5WHNsYlE4UlJBVVU2b0k2OHNkT2xwa2lra1NRSVJ4b1BMNGRhZG1nVVNxSHpVUkg1dWthT2lxUVMxa3hQdzRuVFdma0ZML1dEVEVyNnhSNXhCWTZ2OU5HcW9GZUpFdTA4QmRjckhvRExGcjdLUTlucDJHbHYvRUtSU0FZb0NKUUVEMEdEWDJRNXdPWUthakF1b1c1NU41VVhBS0E4bTFtSStqdmJVTCs2Q3dHRUtGZEtRbEhEbVlSck5XQkFnWU16QWJaV0c1SUlaSUFTR3BHVForZUZkWEVQR3NmNnlaczF3RVVuVEJlSll6cmJtWnlPd1dnTUJSWnk3WWxMNEExcnAyRWg4bThQenNOcDM5eWZyT01xRTVpNzZGSzBsMWQwK3RIalY4SHJqMTBLUThoMzl4MkJrMi81V1Jpc1pDUTJIclhLVTdHQ21LRE02U3BDbUM5Y1FBN3J1czI1bjNURkVnTU5ZOFU4bUVyRVhJSzJVT1p2RWRLMHZ2RXBLd1pUL2wySDV1R2MyeDhTN0tESFF6RlBhRE9DMjFMbHZEQ3FGMXhUbXQwNnNYMUpBTWswaDhucURBYUlDT09ncDJCV2lCMjBHWnZmWlU5YkFSdWZ1aHlHa0ZMNXA5LzZJTng5S0hkZXpUYjdFd2ZoZFF4QUtWOUxYcWFRZGRPZGYzVXUwbmRLTUlFZXQ1OGVZSXNLQmV1SVdUN1A4c293MFVhenhHVy91bnc0NVI4c2xQL3RCK0hIeFc4N21Bb01VYk9CbVo0VC9ZNGgweWtBalNQaitQeHgyM2FPclFPdlVtS2dBTWRWZWF4WEJ3aWNKYzVkdXdRMlBtMFk1VDk4bE9EbGhlWGZVeWkvc1h4eXFGOXMvMktVTGdKaGdMUlBsREtOT1N4SUpxSi9WR1VUTUlEeGdhUXNHc2FacTdRMDN1N1p4MHpETlNlc2dpR2tWUDRadHhTV2Z5QUhIbnNZUDY4V0JoTmw0TlFFVlpNemMzTTNQWlN2NzFPM25ZQWVjeElYVUxkSE01WmZyeTFEVnBIUzh6NXUrUlI4L3VUT3pWSnZPZmZiUDRmdjdUa2EzN0syV1U1K205T2YrakZ4TnozcEtlQkNxWDlTMmhkOWVYU2ZHcXUxTnBUYktyUzN4eTJmaHMrZHNocU9XVFRNak4vNjNUM3c5UWNmc1N3SXZySTlSV09QT24zRkJvRWRnajBRTTU3U2FUSXdFTGpiejlZMUNEZmdMektLb3RGTjJlZmFGVlB3dVJlc0xrRFEvMi9RcFdUajkvYkNQOXg5VUc0eDdVd2dyc1QrOUU4OFZhMERnYmZKbXg0alhwQXQzV0VUWlRoZW03SEVZWUNrd2duYzdUTFBPMll4d3VkZU9KenkvL1RPL2ZEUlhRZXFJY0xjbW9ITkRFMFp1ZVd4OXM3YWxtOEJIWWFieUFYRUxEcGVGbWszcVJzYTB3V2txTGRSem1kZmRNeGd5di9BRC9iREJ3c0E4TEREem1ZaGpGRFhFZUJOMUZVZ0wyVjZuTVZmcUwrdnltSTBIV1BEdmxLNmdKeDNxRzRKQlBMZE9TajV5K2V1TEtMK0tSaENLdVhmc2IrZVErcGhWWmxRRmdvcVQwdnNZY25OTWpGQVdzbHhJdXBMOFVOYlArL0R1b0RFK0NZK0dNbTdqMThHcjN2U1loaENQdmFqZy9CbjM5Ky9ZSXZYUkk5T2J1dnIyZk9rbklMR3oxZ3VJQWtPaXRkRGIyVG9acFErZ3F4ckZKRVBxMk9zeVZKKytRRHZLcFQvcm1jdWd5SGtFM2NkZ3ZmZHZxK3cvQkJVc2dGSFd6eU1XN3dzOElIYk1vTW9HeStvRmd6UTIvcjFBa2RhbU1sQmhEVW1kUUV4OXhKSmUyVVhQMzFwQllBaDVCc1BISUczM2JxWCtmd0k5VmNnQUlndVFLVlFDNGFrdEgwbUs3VjNDd3NDbzBFWFEyc1BsNEEwaWViTnNHWU1jZTlGL3JXYzgrUWxjT1ZKd3h6eGZtOXVIczcvK3NNT0tCTmIwSmE3MWNLYUpyVnlxV01yMXJtczRlbDdCb0hVTDZwM3dKcXl4RFp2b0YyQVR1dkFTNE9nekg3MkwwL0JsYzhaeHZMdjNwL0RxM2ZNd2Q0anNmVUtHdkxqSXpVNWNwdUNIOVdTMnZ6M2srNGdNTktabXgxakJvdzlzR3kzWU1uQjNlTTIvaklHd3JVck05ajZvcFd3ZW9CVHZsTDVaMjkvR1BZZXB0YnZWMk01b0F1VEpWdHU2dFFaM2lrT0YxN2Y2MU1VQnVsMkFXUWpVbGNjSmNjVWpCRXFYcERVTVlBT3NxSWdxQmYzdUpVSW4zbkpxdUswYi9LOWZxbjgxM3psWWJoMy96eDduc2FlTy9id1ZSV0t6bHZXZzNqTVlJTE0yR2dvdWhydmJXREtyOGRpUkhUeXF1ZGxkREVCQTNEbDYwKy9ZaUE0cnJEOFQ3OWs1V0RLZisyL0t1WHJTTDJPenNFdHI2SENsSXVSZWlFdlpqWVV0ZjVZaTQ0WWdFd1NJL1ZpYzlLQkhqcGJ0RWxab0YxYmgvS2I4Wm82cTRzajN1dG5WbFQwUDZuc0tYejlhNy84TU55emIvUmFGMU5iM2ZZb2xzUmNSYjB1Nm1mWnNuTTFtaGM3UkNUeE1pZ1IrRVdzV2hVbjY2RXBtRUI0bjZSY0RGdXNNdnRETDF3T3ozck01S2Q4bGZKdktpeC9iMTcxRytpVmZWNnV3YzcraE9SeGpaL3kyazI2aE5ZRkpJSUMzNmV6UXhWajNZNUZNQ3NRbGp1QllQMWRCYmJqZ3V0VHIzaitNbmpwY1l0Z0NMbG8rMTc0L29QejduZDhNZDl2bE92UnZpY0MxRjNCSGlXVHVvdHBvOHkrbEJ6MTdiYU91Q1dISVlhSUFUekxaK2wzUEdjcFhIVDhFaGhDM3ZuMS9mQ3QrNCtNTEY4eGRnQWl0aWR6ZGNwbkJVMzdWUCtCRG5ORzFsTm05dEFlYTFNd1FJL1Y5NmlNMmo5a0ZUWXpURVQvVlhwQ3k5ZjltTU9lT3Y4ZHY3YTBBc0FRY3NVdEIrQlQvM1VZbXRNOWQwd0JDdC8zRzhPSldRN1BvUTdyOVBydWtNNkRJRDUzdDh3SlVQU3pTTFRLdjdTWjZyK1hsRzM1T1FESmVWMzA3TVVWQUlhUXE3OXpFTGI4NXlGQng5amhreEY0WFQ1cHYzNmI3OUk3aG5nbnNSR0lkMndYZW94M0FheU9nMmpaM3FlOU5Pb1hMc2lCeGVaNTJ2cEZzT21VWVU3NXJyN3RZQVdBQ3RBODRGVi9kNi9aaWlhZnRmbVhQN2hsZU91UlVtYVh0V3RkdTliYTR4ekF0L0lJZ2lNVEVxRFJ3ZG9BNHNVQXp5cU9lRGZQREtmOEQ5MTJjT1R6WGNybi81U0wzUkx6OHdrTkRMSEFyblZUWE5rT1FIb0RvcForTDROVW9PaTVxMEFLNFVtTkZYajV6UU5PSURvR1dMc3FnMnRmdGdKV0w1bWNZcTcvajhQdzRWc1B5cmtuQWs3c0Vmd2h2MGtDbys0UElLM3NDYmJXdlQ4S3hXWWtQUUVGRHI1SW9oNlN6VWZtUmhZcTVaQjVtRmVwL0UrZVdaenlyWnBjK1ovNndTTnc1VGNPbUlDUEs1VXJRZE84TGpmSDVSN3RxL1Z6clI1N1dqcDI0OEVGQUVaSEJwKzJzUXVOWkE1a21yb1k2N09udEJaWlhFODhwbEQrV1lYeVYwK3UvSEtQZitsWDl0Zi9oZzYwSUJCS00wcUg1RllVMmJ0NkdhK1E3RU5YYU9xeGNVVStSTVNOQTZURVhZQkFJRVZIQ2RiQUtLOHBZL215N3VobWNqWFYvUllnWHIwVTRkb3pWZ3ltL05kdjJ4dU9xVnZGMWt6QXgzWmpnamd6K0Z0VkJ4aWUyM0RjZ0pPTVp6cTY5b05BZEZwUnBMaFJwcUg4MEJ4VlE1ekFaeG1wcmYrcTMxNEd4ejl1OHZQOThtajM5ejY5Ri9ZVnIzVXpWM0hzWC81Q2N0MkJPWWwwUUNIU0FPNjJEMk1LaitRRHFERk5waFgvSElCc0QrZ2tSZ01wQ3hlS2w0NHNnSVRFUzVwSmR3T1h6eXlGMDU0eStSSHZ2WHRxNVIraTRKb1Npa1QyU2RjNGxzLzdBa2dEdyt0TDVJc09ySWkrSFZFeGdLVngyNU5VWkpYV2ZsRGVLUDlQSmc4bUFNREphNmVxYTFJcGxmK0dUKzJGKy9ia1lsR3h5N3FoaVE5QUtDcG0rZTVhNlRZQUZnaU5MYVdBd0NjVkVWMDgzZWU3UEk5U3hMK3BLdzI5MWE0Si9QakhKZWozKzJoSXBmeC9ySldQMnUrRHExaFVBUEhLWXVXZWN0SHo5NW9obW55QXhPdDNuUUZKU1c0RHZVRmE2elo1amRoUG9NVkpuV0VGR3V4QWFDR3lwL0QxR3o3SkxGOXQ5YmppVzR0bnJCVllRSXFYajJPVUo5TnMvRlQ5VUMrT2d2UkJrTFpzdFJ1d0wzc1VNSnlJMzdpRFIxdjVueWlVUDFlLzAvZG9uOEFjNzdiMUhJWXc3Vm01VHJmMTZ6dzNKcWc3Y2xsQVZKYUNySjVmT0pMNE9VQ2tONDlpV2xad0pzYi9RVVNKOWtTODhYOGs3N254QVB6Z0ovUEd2eU9BcEc2ZVgyWTBaY3lIeDJJRm5RYVF5a0h6S2hqNnV3TUFQNDVJQ2dwZzlOb0dKZzkvcVAzRCtSS0hWRDBJcjBiNXhCOEZGaWkvM3IzamY0NVdad2llZnhmV0Q1RDA5YTJ5bFFGWUprRC9sYmhqK2JGWDU5NkhJY2JhZTRPaC9NZWlTd0NvQytlaE9sNGRYYXE4M3JhTjhxbTZxa1drdW0xOVZTOUYybnFoSGEvZmxqOEtBRmhWdkNmWThycFZjT3pxckpwRFZzOG5xK2ZFNThmdm0zcTZMTXRaK3lwZC84UE1PYnRZbTB6VWxlTm5UVjdSSmlONU5YMWx1Zy9UTnVnQ0tYNkZEMEkwWExSL053bDFJb2FxVFBoNmFKbkM5N09QQWdJS09iWTRPdjd3cTFiQ0JYOC8ydnNMeXVhL25yVTdaZHpDT1hVYnQ4QWVWN0FGNE5pN2dTcmZOWFhHRUlubHphcU9hdXQxTGIyeDNQYXFtWUZrbmJZTll3M09BTWdZQWR1Nk1HSUVlUFRrNlkrZmd1dCtkMVgxNWpCbEtmd0tMSURxaXRmTlRGc1lXWFJqMllSaWZRd0xHVXUycklDQ0xTUkRHSlpvcnVpRGFyZFFLVDBvdnFIN0FKWVJNQ1RkdzBqQlJLRys2UC9SM1FJMlVvTGcybk5YVlorTWUvUnU2RDhIVitHWnFoZExZOTRvWGJxY3pPbXJBVXFqNkt5OXdLWCtCaXllc2wyQWVqR0FWVG9KcFFzcmRoVGZ4K3BGalBEL0JBUlhuYjB5NmRkRG1WUUF0OUE0Q0xpRjJqcVpVbHhidDdMdWlEVWJoVHV4UXRjbHFaN0VGVk42VUhSUVBIREZwNnplQXdVc1hPNjRmeDYrZi84OERDRy8vcVJwbUgzRmluZ1FTTUZ5ZFZuTWVsdjNrUHQxTXQxM3prRENyVGZYMXV3Rmg3N1ZaNmtMNjBnZUdtVzJTclJLaDFaeGRYMitFTXpxZ1MyQXNmcTJIaXViZ0FIMkZNSGJIMzU4UDl6Nzh4eUdrRmVjc0JobWYyZUZRLy9vQUVKWnNpckxjblFaUkxLRFZiaTIrTWE2VzR0MkFDS0F3aThPUWtJRG5HZ013SlhlQm5RMFVpSm5BUkVjRXNuOFBGZzlWemFxc2tuamdQc2Vtb2Z6cnQwN0dBaGVYb0RnOGxlc2dOamF1TDdVL01ZQnd4bkZBNFoyTjBnV1NKbkRLQzFRdUlMcmVJRmZncm1pTVlCNFFNa1F5SlFJdWRvVmlMWVVLSjlOUGpCRnpRaVRTTjN2ZlEvbGNQNkFJRGpqeE1Yd3h0OWM1aXN1QjBQUG9VenVDREtLVzczSUYrNUVLWThzblRjTWsrVUlPcjdJSEhDYXF3RUVLTC9mWHRvMWtLTjRrb29QOXlSY0JPaWdFU1FvSnBFcWZxakh2di9CSEM3NFdIRzJQeEFJM2ppekZONzQ0aG9FNEFSdHBDOFV5dFRLRGI0YmJLRFlLTFRELzR2dG4xS21yL0FJOWJjdUlNRUFNdUFEcS9oY0tyNWhBN3NiZ1BiOEFFdytUSHdReEszeS9vSUpMaHdRQkJjV0lMaHdacG1sYVFERGJENkZCK1dpVm00dWxlcUNoN1QvdDB3USttdDJEZkpzd21PRnBBdW9KajhQTXVCempvYTE0amtiaUxnaDRpSmFNTUVFNGl4NnlRU1gvTTArMk52dmY4UHJsQXNLRUpSWGJIZFFMUzRnV0tyblFaaFZidU15TEJNRVY0Q09xOGhVZkNBT2toUXI2Q05odXd0dzZCK2FxNlovc3dWa3dEQ2dZRlJ2M0VEYm5rTHcxL1E3Z1FqM1U0OTk1ejFINGVLUDdCME1CT2VmdXJTNmhQVlEzT0pIMXRWWTk3anVBTVVPUWxwdmVNZmdzZ0NyWitnK1YrOG1tbk1BN3hJK3VzM2pBSkZsd2JyRHdaQmVtUFpVa0VBeXdhUUFhSU5OdVJPNTg5Nmo4S1pyOWd3R2d2TUtBSnczc3hRczdhTlJCRHI1emZzRHoySzV4V2RrQVdiOFBtbUx0a2ZCYU9vNGw5N3p5MzIrV2xoQjdhQmlBZ3BSUFhHcnArQkNDTXdad0tUL1ZGejdRaWFYVE5NbzZNNTc1K0dxR3c3QVVMTGh0NWJDMlNjdkVSUWUvTHdDZ1lrRHdGVjhBSVYxSVhySElHTUllWENVUlJTT0ZHZUY2RGVCM2p2bThMNmF3THdiYnhPMUlwRGk3OVJydjg4L3JWcXdLT3RxeHVGZjRIeitsc05WM3Z2UFdRRkR5RnRPWHdiN0R4TGNkTnNqY2x3SXoxakZCTTM4MENzUGVjMWJSUGttRXNYM0VxRk1mUWRRajFHbDFiY0NxZGlxS1J0OUVOSVJoWWxQdDdneTYzUlllRklnWUFDcEc5aDhHTUFGS0NXd3F4bmpYd29RbEQ3NXZRT0I0STlldmJ3YTk4dTNIYkVnWUFyd2xPb3FHcVNTdVVxMDhrMVo4d2RaVlhhb3R2eDdBUlJWZ1B0UmFHUEZsWVJUUFBjTFdvS0FGTmJPV3NHRWJvRENMeUk0Q2hsZEpSTTg0WmN5dVBDMFlmN1c4RHZQWGw2QTZpQjgrZHVQK0IrUEFnY2hHb1lTeXRmTUlmSXRTTUk5Q21QVWRVRFV0eVZqL1ljUm96SXlkYzFYc3Z5dlNDdEFoSVZpakRDSi9nbUVTMEdTOHgzOS9mMlF2dTRMbzcvcGU4RkFJSGpUeTVmQ3J2dm1ZZGY5ODFieGFnNTh2YXEvVkFKNkRSMkd3S0JnelJ5aFRwMHYxaEU3cmI4c04rOEMrTmwrQ041VTlDKzJleEJlOURTQklJQTVPV3kyWitMN0FEN2Vnb1ZFMEtkM01QeVZkcE4zL1kwSDRmb3ZIb1FoWk1WU2hEKzVlQVU4NVFsVElaS3YxNGVmM2FNTzNrZ0hmRjRnaDg3QlVOZ3BpTE1CRStTcE1ja1BEalBnUjc3OERFQXAwTDRRSXJHZnQ5RS8yRjBFQTVtb040RlVGdVBzd1ZHTjFjeWRnMkRMRjRZRHdSOWZ0QUtlM0lJQVJPUXRsUVJXK1kxQ25RTWdwTEI3MERzRkFZaGNiVG5OaGU2VmdUcjRRWGJ4TXY1Q1NDeXVPQ0NTZFRXckNPWHp3eWVZUUp3eHROWEp2QURhTFFVSXR0NDRFQWlXSVZ4NWNRQ0JWblF6UG45TEdCU3JMZHdIaUdZQzhXMENlMmJ6SWFuYVJzcVRRSFZVS0E2RW5QeVdFYmhiaUIzd2NFcldib0lyYmxJaENsU2Z4NnhmNTQzcWx3RDQ0aTJQd0JCU2d1RFNEY3ZnVjRwQXM2RjFDUUtiMW04QkF6QmlwNFhPc1M4SFJmMWhpS2R3dlJhamd5Q2xjTzl3SjV6MU0wYmdsdCtBcGUySGpKc1E0TkJ0SndTQmZEQUM4Y2taZ1hOVUxLOFAvTjArK05KQUlDaVZmOFh2TDY5K28weEFNWXJXMW94dUhYdFNLTm1BdXhPUEVUZ3pSRjRIZy9rdXdHVUVRYW5FM0FVWXl2Zm9INWlybUVTUUhNWWhBUDFObzExZ2FPZjd3Yi9kQnpkOWF6Z1FiSHJ6Y25pOEFBRTZ2dHVDSSs0S0dEdTB2NUhYeDhTL0o5QWcwaTZnVWFhNitDTHFLRitrMlk3QSs5UUx5YmJuakRHWThzbTNMQjZmZUdYQkhRQjg1Si8ydzMvZk04ejNoWThybEgvNW0yTk00TGdDQnh3eUtQUjNBclpmWndlUWcvOTJNSGQyQWVhTm9GSW9HQVZEUy90aW05ZlN2MVlFbUx5SjR3Qkh1VDRvMUd0clZiYi9BTUc3cnQ0ekhBZ2VnL0QrTjZmZGdXVUNUOW1KZEM0QllkbUFNWUw3UVFoSlduUS9CcW51TFVCUXZEQUNOeDdnZnIvcHg3eTltMUFhQlJyUVVvd1ZLRkpHY0tBQXdhV2Jod1hCZTkvQ1FlQlRzc3NFMEFVR1NDaWV2eDIwNDRXM2dXTGh5Rkk4VzlTVXUvQi8vWDVNWDBOSTJTZlVEd2tzbHVGajFMOHRHMmhnMUhYS0Z6MVhmbXd2L09TaEhJYVFFZ1R2ZWVzeVdMbE1XWHZ6YnNBREkzUUVnRENxazBIY0RSaFhRRFlZemJRQzJyTnpUOGtxeVBLVUxIOTljQmhXbUVRb2J1a2NDTGJNQVVFZThuNzZRQTd2K1lzOThOTUhod0hCWXdzUVhGYUFvRHcwYXRZNDZnckF1Z1Y3VnVERkRkNUJrV1FZODMxZzZ4ZHpiYWxrWXdMUTBUNjVqQkM3dENzUlkwMGcyREdtUGdyV3ROK0NFemdRQUg1V2dPQzltNGNEd1hISFpuRHBIeXdkZ1VBb2F3U0trVlZiS3BkV2ExbkQyMUZrQWhUeTdJQWJvMzhPSUJUbXB6bGxCbjlQQ1RZZzhXMmdZSklKcEgzNTFHSHQwSUpQUGhOL0JnMktCZ1R2SzVqZ1p3T0M0TjB0Q094Y3BjOW1iQUdTOHZsMkwyN3B1bS9yQ3Z4UHd0aiszck5ZZXdJWWdqbVA4bU9BR1dRWFFCSGFCM0RCNW9PRURHQjQrb0VDQk8rL2F1OWdJRmhiZ09DY1Z5MXVsWlVCUklFcmxhcVZ6K1lMVU1jVUdKZ0VBbmd5VlNmVWpWSStXTXYzam9VVGx3U0JCZEVnN3dJZ05oYytqbElzT0NBd2VTU0E4RUNoL0E5Y3M2L2FKUXdocC96R0ZKeC83aEpCK1JpTkEvd2o1ZkJNWGY0ZkFXUHZCTFFGeFpTb0Y5WmpCemZxaHlZUEpPM3phMEp4VC9yRUFrbGxncU5ncnZTWW03anI3bm5ZVkREQlVDQTQrWGxUc09IY3hjNmNPWDJqZWphVVZrL3hqMGhqU2hkdXdRdjhZb0VhWndZYzgxZmNLMlZNSkZ4NVJCQm5KUkpqNnp3TmVydExHTjJYSUxqaXovZkNVRktDNERXdlhoUVVDUmJFYmt4QVV2a2NJUG90b2EzRHlvb0gzdTFaUFRwNW5pTGR4UWE1OENpWUlMS3JtRlRhY1NuUU9UZ1dMaFNzcUIrMDBsVWY5ZjJQQ3hCOGRNdHdYeHFmT2pNTnA1OCt6ZWljV3pGakJZaTRBYkl1aEZ0OWlBVlFYN3ZMZnladWJxVFJrYkRQL1VJZSt4WUplVDdWZWFvTWRWLzh2djU4ekMxYm9BaEtiQzhLSDAzVmN4dDlpa1dqNy9OSTFlVjU2UFRKODRvL2J2N0dJMVg2NHZPSCtWL0hHd0I4OGZQenphekR1b0plMjhBRUlWWGZJNjlYMzVHL3hzVlQ3eTZDdy9uYk1XTDFiY1BtWG04UkFhSk00WldqWWduay9TOVlTTEtPK3ZYZFFxUU5ZeEZ4RDR4QjJQM1hDaEI4L0pQRGZGQlN5c3NLRUx6MGpHbGg4ZGJhSStjQ0FHYUw2QVdHZ2lIeS9PR3NlS1c0MDZWd0FCc1E2YlJTWm5wUldUMXc2aTVRQW0wejViRGYwUmhlR2RrMGdPTWluR2RqYy83U1RZZGgyMmNQdzFEeTB0T25BZ2owQlpITDFMVUhRNTVyQU1JZDB6bmd6b3lVMXNsU2h2bnlsNlZqNHJrQ1lCTnZaTS8rSE83NzZYeTBmVXIyN2E4blFlMGZvQWl3bmp1TmJ1cWZvSFJGcDhoQTFicUZoSXNvL3JqaG53OVY5eTg0WmJFYVBTNllTRC8xYVJuY1JQVlh4c2ptUno3MWh6ejJKL3J6NEhtTHB2S2R1RzVtMTVwc2VzbXVJcjNHcTlUbWFkK0NjdEhNd09vWDBWbGtaR2xXbnFHdGg2cGVwVGplRG1zS0ZHMHc1TE04WGNlazJYMW04b01Td2ozS09sNjZYWXRZSFFCUTlTVUFyTExsM3lhU29PZS90c1pJTmwyVFliWjd4L3E1QXV3N1k5Ry9qZ09pOUI2aGVvejFCWDdmeVBMUnFSL0dJdkMzZHFCMklIbzhTcnNDZldZQWNtN1lzUWF5TDVBdVZkTTU4WHJvVUgxc080YzlLVitlQmFnMk84bzVqZjVQSk1wdmNNOERZTFNsRXVjQXdPNzVyOG9YNXdjUStndmJOQ2V0RlJnQkEwL0xReWV2UGpsZ0lxVTRzbU5xY0xDMlFubnFYZ05ES3BxeEIwSEV2N3ZLa3VXaWowaDlKMSt1N2Z6V0ZnQjVmbVJMa1RtbkF4eU1LTVN6K0NnTEVGdFEzWi9wdndubU5JaVlZc0FmcHdHRHp6QWVPTHd6Z2NBQzRPUVp4VU1jQ0ViSm50SkFycldzTHlrZjFUb21sUThnM0lCM3dkS3BiZEFBWU9RRzhxM3RiQnhsY2FvVzlNN3kzYllBVVFXaW8waXRxRkdhQWlNNWZjcmZVRTh6aFFVUEJ3YUZjZlhZb01iUXo5ejJFUUdDa3pkcWczN2RwcitZd2dFaVNzWjJIVk5YY1FDMFpYWXp6cFYxMi85bUs0ZnB6UkE1eXhjVzJUeTVkZ2NnVC9oU0N0TWc4S3phV25lakZQNGlTUzIrQUE2NTRJalJMd2VCMTU5djVXVDZjRUhpNU1WbzM1YWpWVFFIUTlzTzNlZnlybm1FVGMxMFdnRHMzdkdFM1FVTXRvSVc5UkRJSHloeEwzd21CNFVCaVYzd3VIV3JjWUFpbGcydFF0SDBUZkxabU9XM3o4anJzZXFCdGtrQ0JkU0Nld3BJNVpFY1c1ZURVcXFwcDBBQ3JMMW1rdUo0ZWN2c1IzQjM4MHppUDlxYmgvbFo1TEVBRzdCZERBVUU5UElCWEVzV3ltRldhUmdGNHN4aDVpUDZDR054QU5xNUJLMEt5b1V3TDQ4QldyQ1FiTWZuNHdKQjVSbFdhTXZRZFJWQ3ljejZnWHdseC9zQU9ESVZyTDhVQVlBaUZ0aGRMT2JWWW1ZZUdOUkRnMTRNRHd6azFJbUFKU2pPV1NtbEtNL2l2YjVRSzFnd0I1bTZmTHltSEozbjVuMjU2K1BWQjNCWklaUmhXRE9Tb05kMTY5cm1BZ0RETURuUkptNzlBTXFnR25ucWkrL2VYalNZTWY5dENXdlJEdEtrRVVVZHJNc1drbllQZnJDMmdsUmRWaStMNU1mU21YZkFnL1dIR1R3UE1ISXdOSHJEbGpvUUFxOHZpTmVYT3dGTzgrd2VmZnAzOUxaNzQxOWw2MVVSdVAvWDZqUWVQYi80RWE2Z2xaWU9RM3IwR3l3V0RhM3J1dklYWTFadDZ2Ym9VeWNjSm1pRXh3ZzhOaENmbEVGaVR2d1ptb1MyZmdMcjM1WGxvMWZHV0ZOYXZRb0tIUmZndUlUZGVBUlBCVWRjQU54UnVBTEs2SHllaHg0UTJIMHpJVkI1RFRWRFQxRHdoNVY5Z1BYdGpyakJIdWhGaklIWVdnOVhncndub1RUcEVxeGl0U0VaWlh2UDB0WkJvVlQzZVZRN25sL005SkxMdGtqcWJ5VDZ2eTMvYU1keDI0andFcjNPR0VPL3A4aUV4UXN3Z08zVHQydzJYbFVXd0tUSEc2WEptUWRaVm1qbXE4cUU4a0R1TmpRUUJVQ2JiSzF3WFljL2syS0Y2RE1EdUZzL0R5QjE1VTBiL3hxM1FVU1MvOTMyRDI5KzR1WmlEVGVCWS8zSmV3OGtHa2c4RVdNSFNQUXRXSUhNWXN1K25jN0lCMm1VYVVpMmJjY2luL2xpbGc5T0hqcGxta1VBNHBhdUpldzBhTk5sMTA3TlFrSTYvNy8xSDM1dDdTeVdJTkNLaWQwbjhqeW1BRkw1ZGFiZXc3dDllUU42SUhSY0RqcHRrZnordUZXN2xxeVVqbzV5WFo5ZjVhRnNDdzZMSkl3SEk3OEVkTWxsMTZXVlgwb25BRXE1c3dCQmNVcHdWdEh0Ym5NNnFCWWVlMW92bjJ5OHJucjZTRCtoM0JzY2hPTENIQzNkaTA0cGJYMWNYSkI2Rmg1Ym00aVNmZHFIbGlGMC8vWHZIT1Y0MXNicnBqWkREK2tGZ0ZMdXZIbjl0bXhxL3RRUkNFQStnSGdLaWl0SUM3TitqTlZYeWtxQ0JxUTdrUDZRbEtKNUc5dVhsNWU4RjJtUFVmdzJ4dUpUY3dNSHlCd1E1U3ZlSEUvYXVDWHU4N3Y2N3lYUGVPRmRzOFhHK2ZLMkUyU1RRcDdIUG9SbzZ0Uy9zWDA4cjh0L1J4OW1vTzNEMUJtTjIvY2NvSzBIM3BrQXFuYmUzcjlKaDdMbXIzRzE5STcrZmo5anRYZzVBUG9mbE1UdjU0cUE5K3JMdG5SVHZwYmVETURsanE4OXFRREEvUG9DY2x1cmpKVGxRc1EzUjlqQml4TU1QWnR4cEJXaHgwTHVMN2tXNlFwbm1RZ2J1YTVBbDNmV3c3WThaWjJCQlhETEk0UW5MVVQ1dko4Rnl6Tm1kcTNEUEpzdHJPYVZ4WnpYOE0vRHBOV2pZZ2VJbnZqcE9wbXlXdkFZQXNQaVpxNjFnM1A2SjYzYnNvRzEvQXhpK2Q1cDN1aGhzb2hGQythQTBJYW5RYlNESnJmOGltdnJQR1NiWnlQNys3NHlNUUFhS2I4dFhBNVRaeFlkYmlpdW1hcHpBUUFJeDhXdVlpRHFCbHBxYjh2UkFvQ2xGd1lBcFNnMjU2QllId0NaVU9Ta0FKQy9EQUFGemNQTzR1NkdvNUJ0S1JRL0J3UElZQURROHF5WlhUTVpaQ2NXKzRVWEY2T3N5WkRXRlErOERxS0tXVGdBTWhjSTR3SEFLTGF0RSt3dUNvQzZMSzVjRHdDb0FDYktkeGQ5RmdyR25jVXJuTnRIdjlNN2gxSTZsLzhGQVZPMnltNURQU0lBQUFBQVNVVk9SSzVDWUlJPVwiLFxuICAgIGRvd25sb2Fkczoge1xuICAgICAgY2hyb21lOiBcImh0dHBzOi8vY2hyb21lLmdvb2dsZS5jb20vd2Vic3RvcmUvZGV0YWlsL2tlcGxyL2Rta2FtY2tub2drZ2NkZmhoYmRkY2doYWNoa2VqZWFwXCIsXG4gICAgICBmaXJlZm94OiBcImh0dHBzOi8vYWRkb25zLm1vemlsbGEub3JnL2VuLVVTL2ZpcmVmb3gvYWRkb24va2VwbHJcIixcbiAgICAgIGVkZ2U6IFwiaHR0cHM6Ly9taWNyb3NvZnRlZGdlLm1pY3Jvc29mdC5jb20vYWRkb25zL2RldGFpbC9rZXBsci9vY29kZ21tZmZia2tlZWNtYWRjaWpqaGttZW9oaW5laVwiXG4gICAgfVxuICB9LFxuICB7XG4gICAgaWQ6IFwiZm9yZGVmaVwiLFxuICAgIG5hbWU6IFwiRm9yZGVmaVwiLFxuICAgIGljb246IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpRaUlHaGxhV2RvZEQwaU1qUWlJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0S1BHY2dZMnhwY0Mxd1lYUm9QU0oxY213b0kyTnNhWEF3WHpFek5EazBYelkyTWpVMEtTSStDanh3WVhSb0lHUTlJazB4TUM0NE56WTVJREUxTGpZek56aElNUzQxVmpFNExqTTVPVU14TGpVZ01Ua3VPREF4TXlBeUxqWXpORFEzSURJd0xqa3pPQ0EwTGpBek16a3lJREl3TGprek9FZzRMakkwT1RreVRERXdMamczTmprZ01UVXVOak0zT0ZvaUlHWnBiR3c5SWlNM09UazBSa1lpTHo0S1BIQmhkR2dnWkQwaVRURXVOU0E1TGpjM05UVXhTREU1TGpBMU1UWk1NVGN1TURFek9TQXhNeTQ0TnpFeFNERXVOVlk1TGpjM05UVXhXaUlnWm1sc2JEMGlJelE0TmtSR1JpSXZQZ284Y0dGMGFDQmtQU0pOTnk0Mk5UazVOaUF6U0RFdU5USTBOREZXT0M0d01EY3dORWd5TWk0ME5qRXlWak5JTVRZdU16STFObFkyTGpjek9UUTBTREUxTGpBMk1EWldNMGc0TGpreU5UQXlWall1TnpNNU5EUklOeTQyTlRrNU5sWXpXaUlnWm1sc2JEMGlJelZEUkRGR1FTSXZQZ284TDJjK0NqeGtaV1p6UGdvOFkyeHBjRkJoZEdnZ2FXUTlJbU5zYVhBd1h6RXpORGswWHpZMk1qVTBJajRLUEhKbFkzUWdkMmxrZEdnOUlqSXhJaUJvWldsbmFIUTlJakU0SWlCbWFXeHNQU0ozYUdsMFpTSWdkSEpoYm5ObWIzSnRQU0owY21GdWMyeGhkR1VvTVM0MUlETXBJaTgrQ2p3dlkyeHBjRkJoZEdnK0Nqd3ZaR1ZtY3o0S1BDOXpkbWMrQ2c9PVwiLFxuICAgIGRvd25sb2Fkczoge1xuICAgICAgY2hyb21lOiBcImh0dHBzOi8vY2hyb21lLmdvb2dsZS5jb20vd2Vic3RvcmUvZGV0YWlsL2ZvcmRlZmkvaGNtZWhlbmNjamRtZmJvamFwY2Jjb2ZrZ2RwYm5sbGVcIlxuICAgIH1cbiAgfVxuXTtcbnZhciB6LCBqLCBQLCBWLCBlZSwgaywgRjtcbmNsYXNzIExvY2FsU3RvcmFnZVdyYXBwZXIge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgVCh0aGlzLCBWKSwgVCh0aGlzLCBrKSwgVCh0aGlzLCB6LCAhMSksIFQodGhpcywgaiwgdm9pZCAwKSwgVCh0aGlzLCBQLCB2b2lkIDApLCBfKHRoaXMsIFwidmFsdWVcIiksIEIodGhpcywgUCwgZSksIEUodGhpcywgaywgRikuY2FsbCh0aGlzKTtcbiAgfVxuICBzZXQoZSkge1xuICAgIHJldHVybiAhTih0aGlzLCB6KSAmJiAhRSh0aGlzLCBrLCBGKS5jYWxsKHRoaXMpID8gITEgOiAodGhpcy5kZWxldGUoKSwgdGhpcy52YWx1ZSA9IGUsIGUgJiYgKEIodGhpcywgaiwgYCR7Tih0aGlzLCBQKX0tJHtnZW5lcmF0ZVVJRCgpfWApLCBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShOKHRoaXMsIGopLCBlKSksICEwKTtcbiAgfVxuICBnZXQoKSB7XG4gICAgcmV0dXJuIEUodGhpcywgViwgZWUpLmNhbGwodGhpcyksIHRoaXMudmFsdWU7XG4gIH1cbiAgZGVsZXRlKCkge1xuICAgIHJldHVybiAhTih0aGlzLCB6KSAmJiAhRSh0aGlzLCBrLCBGKS5jYWxsKHRoaXMpID8gITEgOiAodGhpcy52YWx1ZSA9IG51bGwsIE4odGhpcywgaikgJiYgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oTih0aGlzLCBqKSksICEwKTtcbiAgfVxufVxueiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBqID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpLCBlZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnZhbHVlICYmIHRoaXMuc2V0KHRoaXMudmFsdWUpO1xufSwgayA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpLCBGID0gZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgIU4odGhpcywgeikgJiYgdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIChCKHRoaXMsIGosIE9iamVjdC5rZXlzKGxvY2FsU3RvcmFnZSkuZmluZChcbiAgICAgICh0KSA9PiB0LnN0YXJ0c1dpdGgoTih0aGlzLCBQKSlcbiAgICApKSwgQih0aGlzLCB6LCAhMCksIE4odGhpcywgaikgJiYgdGhpcy5zZXQobG9jYWxTdG9yYWdlLmdldEl0ZW0oTih0aGlzLCBqKSkpKTtcbiAgfSBjYXRjaCAodCkge1xuICAgIGNvbnNvbGUud2Fybih0KTtcbiAgfVxuICByZXR1cm4gTih0aGlzLCB6KTtcbn07XG5jb25zdCBQZXJtaXNzaW9uID0ge1xuICBBQ0NPVU5UUzogXCJhY2NvdW50c1wiXG59O1xuZnVuY3Rpb24gZmlsdGVyQnkodCwgZSkge1xuICB2YXIgbywgbjtcbiAgaWYgKChvID0gZT8uaW5jbHVkZSkgIT0gbnVsbCAmJiBvLmxlbmd0aCkge1xuICAgIGNvbnN0IHIgPSBuZXcgU2V0KGUuaW5jbHVkZSk7XG4gICAgcmV0dXJuIHQuZmlsdGVyKChpKSA9PiByLmhhcyhpLmlkKSk7XG4gIH1cbiAgaWYgKChuID0gZT8uZXhjbHVkZSkgIT0gbnVsbCAmJiBuLmxlbmd0aCkge1xuICAgIGNvbnN0IHIgPSBuZXcgU2V0KGUuZXhjbHVkZSk7XG4gICAgcmV0dXJuIHQuZmlsdGVyKChpKSA9PiAhci5oYXMoaS5pZCkpO1xuICB9XG4gIHJldHVybiB0O1xufVxuY29uc3QgZmlsdGVyQnlBdXRob3JpemVkID0gYXN5bmMgKHQpID0+IHtcbiAgY29uc3QgZSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHQubWFwKGFzeW5jIChvKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IG8ucmVxdWVzdCh7XG4gICAgICAgICAgdHlwZTogXCJ3YWxsZXRfZ2V0UGVybWlzc2lvbnNcIlxuICAgICAgICB9KSkuaW5jbHVkZXMoUGVybWlzc2lvbi5BQ0NPVU5UUyk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG4gIHJldHVybiB0LmZpbHRlcigobywgbikgPT4gZVtuXSk7XG59LCB2aXJ0dWFsV2FsbGV0S2V5cyA9IGVuc3VyZUtleXNBcnJheSh7XG4gIGlkOiAhMCxcbiAgbmFtZTogITAsXG4gIGljb246ICEwLFxuICB3aW5kb3dLZXk6ICEwLFxuICBsb2FkV2FsbGV0OiAhMCxcbiAgaGFzU3VwcG9ydDogITBcbn0pLCBmdWxsV2FsbGV0S2V5cyA9IGVuc3VyZUtleXNBcnJheSh7XG4gIGlkOiAhMCxcbiAgbmFtZTogITAsXG4gIHZlcnNpb246ICEwLFxuICBpY29uOiAhMCxcbiAgcmVxdWVzdDogITAsXG4gIG9uOiAhMCxcbiAgb2ZmOiAhMFxufSk7XG5mdW5jdGlvbiBjcmVhdGVXYWxsZXRHdWFyZCh0KSB7XG4gIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGUgIT09IG51bGwgJiYgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiB0LmV2ZXJ5KChvKSA9PiBvIGluIGUpO1xuICB9O1xufVxuY29uc3QgaXNGdWxsV2FsbGV0ID0gY3JlYXRlV2FsbGV0R3VhcmQoZnVsbFdhbGxldEtleXMpLCBpc1ZpcnR1YWxXYWxsZXQgPSBjcmVhdGVXYWxsZXRHdWFyZCh2aXJ0dWFsV2FsbGV0S2V5cyk7XG5mdW5jdGlvbiBpc1dhbGxldE9iamVjdCh0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGlzRnVsbFdhbGxldCh0KSB8fCBpc1ZpcnR1YWxXYWxsZXQodCk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIHNjYW5PYmplY3RGb3JXYWxsZXRzKHQsIGUpIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCkucmVkdWNlKChvLCBuKSA9PiB7XG4gICAgICBpZiAobi5zdGFydHNXaXRoKFwic3RhcmtuZXRcIikpIHtcbiAgICAgICAgY29uc3QgciA9IHRbbl07XG4gICAgICAgIGUocikgJiYgIW9bci5pZF0gJiYgKG9bci5pZF0gPSByKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH0sIHt9KVxuICApO1xufVxuY29uc3Qgc29ydEJ5ID0gKHQsIGUpID0+IHtcbiAgaWYgKGUgJiYgQXJyYXkuaXNBcnJheShlKSkge1xuICAgIHQuc29ydCgobiwgcikgPT4gZS5pbmRleE9mKG4uaWQpIC0gZS5pbmRleE9mKHIuaWQpKTtcbiAgICBjb25zdCBvID0gdC5sZW5ndGggLSBlLmxlbmd0aDtcbiAgICByZXR1cm4gW1xuICAgICAgLi4udC5zbGljZShvKSxcbiAgICAgIC4uLnNodWZmbGUodC5zbGljZSgwLCBvKSlcbiAgICBdO1xuICB9IGVsc2VcbiAgICByZXR1cm4gc2h1ZmZsZSh0KTtcbn0sIHZpcnR1YWxXYWxsZXRzID0gW21ldGFNYXNrVmlydHVhbFdhbGxldF07XG5mdW5jdGlvbiBpbml0aWF0ZVZpcnR1YWxXYWxsZXRzKHQpIHtcbiAgdmlydHVhbFdhbGxldHMuZm9yRWFjaChhc3luYyAoZSkgPT4ge1xuICAgIGUud2luZG93S2V5IGluIHQgfHwgYXdhaXQgZS5oYXNTdXBwb3J0KHQpICYmICh0W2Uud2luZG93S2V5XSA9IGUpO1xuICB9KTtcbn1cbmNvbnN0IHZpcnR1YWxXYWxsZXRzTWFwID0ge307XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlVmlydHVhbFdhbGxldCh0LCBlKSB7XG4gIGxldCBvID0gdmlydHVhbFdhbGxldHNNYXBbZS5pZF07XG4gIHJldHVybiBvIHx8IChvID0gYXdhaXQgZS5sb2FkV2FsbGV0KHQpLCB2aXJ0dWFsV2FsbGV0c01hcFtlLmlkXSA9IG8pLCBvO1xufVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHdpbmRvd09iamVjdDogc3NyU2FmZVdpbmRvdyA/PyB7fSxcbiAgaXNXYWxsZXRPYmplY3QsXG4gIHN0b3JhZ2VGYWN0b3J5SW1wbGVtZW50YXRpb246ICh0KSA9PiBuZXcgTG9jYWxTdG9yYWdlV3JhcHBlcih0KVxufTtcbmZ1bmN0aW9uIGdldFN0YXJrbmV0KHQgPSB7fSkge1xuICBjb25zdCB7IHN0b3JhZ2VGYWN0b3J5SW1wbGVtZW50YXRpb246IGUsIHdpbmRvd09iamVjdDogbywgaXNXYWxsZXRPYmplY3Q6IG4gfSA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi50XG4gIH0sIHIgPSBlKFwiZ3N3LWxhc3RcIik7XG4gIHJldHVybiBpbml0aWF0ZVZpcnR1YWxXYWxsZXRzKG8pLCB7XG4gICAgZ2V0QXZhaWxhYmxlV2FsbGV0czogYXN5bmMgKGkgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgYSA9IHNjYW5PYmplY3RGb3JXYWxsZXRzKFxuICAgICAgICBvLFxuICAgICAgICBuXG4gICAgICApO1xuICAgICAgcmV0dXJuIHBpcGUkMShcbiAgICAgICAgKHMpID0+IGZpbHRlckJ5KHMsIGkpLFxuICAgICAgICAocykgPT4gc29ydEJ5KHMsIGkuc29ydClcbiAgICAgICkoYSk7XG4gICAgfSxcbiAgICBnZXRBdXRob3JpemVkV2FsbGV0czogYXN5bmMgKGkgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgYSA9IHNjYW5PYmplY3RGb3JXYWxsZXRzKFxuICAgICAgICBvLFxuICAgICAgICBuXG4gICAgICApO1xuICAgICAgcmV0dXJuIHBpcGUkMShcbiAgICAgICAgKHMpID0+IGZpbHRlckJ5QXV0aG9yaXplZChzKSxcbiAgICAgICAgKHMpID0+IGZpbHRlckJ5KHMsIGkpLFxuICAgICAgICAocykgPT4gc29ydEJ5KHMsIGkuc29ydClcbiAgICAgICkoYSk7XG4gICAgfSxcbiAgICBnZXREaXNjb3ZlcnlXYWxsZXRzOiBhc3luYyAoaSA9IHt9KSA9PiBwaXBlJDEoXG4gICAgICAoYSkgPT4gZmlsdGVyQnkoYSwgaSksXG4gICAgICAoYSkgPT4gc29ydEJ5KGEsIGkuc29ydClcbiAgICApKHdhbGxldHMpLFxuICAgIGdldExhc3RDb25uZWN0ZWRXYWxsZXQ6IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGkgPSByLmdldCgpLCBhID0gc2Nhbk9iamVjdEZvcldhbGxldHMobywgbikuZmluZChcbiAgICAgICAgKGMpID0+IGMuaWQgPT09IGlcbiAgICAgICksIFtzXSA9IGF3YWl0IGZpbHRlckJ5QXV0aG9yaXplZChcbiAgICAgICAgYSA/IFthXSA6IFtdXG4gICAgICApO1xuICAgICAgcmV0dXJuIHMgfHwgKHIuZGVsZXRlKCksIG51bGwpO1xuICAgIH0sXG4gICAgZGlzY292ZXJWaXJ0dWFsV2FsbGV0czogYXN5bmMgKGkgPSBbXSkgPT4ge1xuICAgICAgY29uc3QgYSA9IG5ldyBTZXQoaSksIHMgPSBhLnNpemUgPiAwID8gdmlydHVhbFdhbGxldHMuZmlsdGVyKFxuICAgICAgICAoYykgPT4gYS5oYXMoYy5uYW1lKSB8fCBhLmhhcyhjLmlkKVxuICAgICAgKSA6IHZpcnR1YWxXYWxsZXRzO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHMubWFwKGFzeW5jIChjKSA9PiB7XG4gICAgICAgICAgYXdhaXQgYy5oYXNTdXBwb3J0KG8pICYmIChvW2Mud2luZG93S2V5XSA9IGMpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9LFxuICAgIGVuYWJsZTogYXN5bmMgKGksIGEpID0+IHtcbiAgICAgIGxldCBzO1xuICAgICAgaWYgKGlzVmlydHVhbFdhbGxldChpKSlcbiAgICAgICAgcyA9IGF3YWl0IHJlc29sdmVWaXJ0dWFsV2FsbGV0KG8sIGkpO1xuICAgICAgZWxzZSBpZiAoaXNGdWxsV2FsbGV0KGkpKVxuICAgICAgICBzID0gaTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3YWxsZXQgb2JqZWN0XCIpO1xuICAgICAgYXdhaXQgcy5yZXF1ZXN0KHtcbiAgICAgICAgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzXCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIHNpbGVudF9tb2RlOiBhPy5zaWxlbnRfbW9kZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGMgPSBhd2FpdCBzLnJlcXVlc3Qoe1xuICAgICAgICB0eXBlOiBcIndhbGxldF9nZXRQZXJtaXNzaW9uc1wiXG4gICAgICB9KTtcbiAgICAgIGlmICghKGMgIT0gbnVsbCAmJiBjLmluY2x1ZGVzKFBlcm1pc3Npb24uQUNDT1VOVFMpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbm5lY3QgdG8gd2FsbGV0XCIpO1xuICAgICAgcmV0dXJuIHIuc2V0KHMuaWQpLCBzO1xuICAgIH0sXG4gICAgZGlzY29ubmVjdDogYXN5bmMgKHsgY2xlYXJMYXN0V2FsbGV0OiBpIH0gPSB7fSkgPT4ge1xuICAgICAgaSAmJiByLmRlbGV0ZSgpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IG1haW4gPSBnZXRTdGFya25ldCgpO1xuZXhwb3J0IHtcbiAgbWFpbiBhcyBtXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/core-d21d2e96.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/getStarknetChainId-7c4b3163.js":
/*!****************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/getStarknetChainId-7c4b3163.js ***!
  \****************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   g: () => (/* binding */ S)\n/* harmony export */ });\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! starknet */ \"(ssr)/./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs\");\n\nconst S = (n) => n === starknet__WEBPACK_IMPORTED_MODULE_0__.constants.StarknetChainId.SN_MAIN ? starknet__WEBPACK_IMPORTED_MODULE_0__.constants.StarknetChainId.SN_MAIN : starknet__WEBPACK_IMPORTED_MODULE_0__.constants.StarknetChainId.SN_SEPOLIA;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9nZXRTdGFya25ldENoYWluSWQtN2M0YjMxNjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEM7QUFDMUMsdUJBQXVCLCtDQUFDLDJCQUEyQiwrQ0FBQywyQkFBMkIsK0NBQUM7QUFHOUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdGFya25ldGtpdEAyLjEwLjRfYnVmZmVydXRpbEA0LjAuOV9zdGFya25ldEA2LjI0LjFfZW5jb2RpbmdAMC4xLjEzX190eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDYuMC41X3pvZEAzLjI1LjUwL25vZGVfbW9kdWxlcy9zdGFya25ldGtpdC9kaXN0L2dldFN0YXJrbmV0Q2hhaW5JZC03YzRiMzE2My5qcz84OWI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbnN0YW50cyBhcyB0IH0gZnJvbSBcInN0YXJrbmV0XCI7XG5jb25zdCBTID0gKG4pID0+IG4gPT09IHQuU3RhcmtuZXRDaGFpbklkLlNOX01BSU4gPyB0LlN0YXJrbmV0Q2hhaW5JZC5TTl9NQUlOIDogdC5TdGFya25ldENoYWluSWQuU05fU0VQT0xJQTtcbmV4cG9ydCB7XG4gIFMgYXMgZ1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/getStarknetChainId-7c4b3163.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-1c1d2b10.js":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-1c1d2b10.js ***!
  \***************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getStarknetWindowObject: () => (/* binding */ o4)\n/* harmony export */ });\n/* harmony import */ var _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lastConnected-e9351912.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/lastConnected-e9351912.js\");\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! starknet */ \"(ssr)/./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var _index_d4f30f2e_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-d4f30f2e.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-d4f30f2e.js\");\n/* harmony import */ var _core_d21d2e96_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core-d21d2e96.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/core-d21d2e96.js\");\n/* harmony import */ var _getStarknetChainId_7c4b3163_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getStarknetChainId-7c4b3163.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/getStarknetChainId-7c4b3163.js\");\n/* harmony import */ var _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index-9bb48f8a.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-9bb48f8a.js\");\nvar cl = Object.defineProperty;\nvar hl = (r, e, t) => e in r ? cl(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;\nvar He = (r, e, t) => (hl(r, typeof e != \"symbol\" ? e + \"\" : e, t), t);\n\n\n\n\n\n\nvar Ro = { exports: {} }, fn = typeof Reflect == \"object\" ? Reflect : null, wf = fn && typeof fn.apply == \"function\" ? fn.apply : function(e, t, i) {\n  return Function.prototype.apply.call(e, t, i);\n}, Ms;\nfn && typeof fn.ownKeys == \"function\" ? Ms = fn.ownKeys : Object.getOwnPropertySymbols ? Ms = function(e) {\n  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));\n} : Ms = function(e) {\n  return Object.getOwnPropertyNames(e);\n};\nfunction ll(r) {\n  console && console.warn && console.warn(r);\n}\nvar Nh = Number.isNaN || function(e) {\n  return e !== e;\n};\nfunction nt() {\n  nt.init.call(this);\n}\nRo.exports = nt;\nRo.exports.once = gl;\nnt.EventEmitter = nt;\nnt.prototype._events = void 0;\nnt.prototype._eventsCount = 0;\nnt.prototype._maxListeners = void 0;\nvar _f = 10;\nfunction ra(r) {\n  if (typeof r != \"function\")\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof r);\n}\nObject.defineProperty(nt, \"defaultMaxListeners\", {\n  enumerable: !0,\n  get: function() {\n    return _f;\n  },\n  set: function(r) {\n    if (typeof r != \"number\" || r < 0 || Nh(r))\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + r + \".\");\n    _f = r;\n  }\n});\nnt.init = function() {\n  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;\n};\nnt.prototype.setMaxListeners = function(e) {\n  if (typeof e != \"number\" || e < 0 || Nh(e))\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + e + \".\");\n  return this._maxListeners = e, this;\n};\nfunction Th(r) {\n  return r._maxListeners === void 0 ? nt.defaultMaxListeners : r._maxListeners;\n}\nnt.prototype.getMaxListeners = function() {\n  return Th(this);\n};\nnt.prototype.emit = function(e) {\n  for (var t = [], i = 1; i < arguments.length; i++)\n    t.push(arguments[i]);\n  var n = e === \"error\", s = this._events;\n  if (s !== void 0)\n    n = n && s.error === void 0;\n  else if (!n)\n    return !1;\n  if (n) {\n    var o;\n    if (t.length > 0 && (o = t[0]), o instanceof Error)\n      throw o;\n    var f = new Error(\"Unhandled error.\" + (o ? \" (\" + o.message + \")\" : \"\"));\n    throw f.context = o, f;\n  }\n  var h = s[e];\n  if (h === void 0)\n    return !1;\n  if (typeof h == \"function\")\n    wf(h, this, t);\n  else\n    for (var d = h.length, v = qh(h, d), i = 0; i < d; ++i)\n      wf(v[i], this, t);\n  return !0;\n};\nfunction Ch(r, e, t, i) {\n  var n, s, o;\n  if (ra(t), s = r._events, s === void 0 ? (s = r._events = /* @__PURE__ */ Object.create(null), r._eventsCount = 0) : (s.newListener !== void 0 && (r.emit(\n    \"newListener\",\n    e,\n    t.listener ? t.listener : t\n  ), s = r._events), o = s[e]), o === void 0)\n    o = s[e] = t, ++r._eventsCount;\n  else if (typeof o == \"function\" ? o = s[e] = i ? [t, o] : [o, t] : i ? o.unshift(t) : o.push(t), n = Th(r), n > 0 && o.length > n && !o.warned) {\n    o.warned = !0;\n    var f = new Error(\"Possible EventEmitter memory leak detected. \" + o.length + \" \" + String(e) + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n    f.name = \"MaxListenersExceededWarning\", f.emitter = r, f.type = e, f.count = o.length, ll(f);\n  }\n  return r;\n}\nnt.prototype.addListener = function(e, t) {\n  return Ch(this, e, t, !1);\n};\nnt.prototype.on = nt.prototype.addListener;\nnt.prototype.prependListener = function(e, t) {\n  return Ch(this, e, t, !0);\n};\nfunction pl() {\n  if (!this.fired)\n    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);\n}\nfunction $h(r, e, t) {\n  var i = { fired: !1, wrapFn: void 0, target: r, type: e, listener: t }, n = pl.bind(i);\n  return n.listener = t, i.wrapFn = n, n;\n}\nnt.prototype.once = function(e, t) {\n  return ra(t), this.on(e, $h(this, e, t)), this;\n};\nnt.prototype.prependOnceListener = function(e, t) {\n  return ra(t), this.prependListener(e, $h(this, e, t)), this;\n};\nnt.prototype.removeListener = function(e, t) {\n  var i, n, s, o, f;\n  if (ra(t), n = this._events, n === void 0)\n    return this;\n  if (i = n[e], i === void 0)\n    return this;\n  if (i === t || i.listener === t)\n    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete n[e], n.removeListener && this.emit(\"removeListener\", e, i.listener || t));\n  else if (typeof i != \"function\") {\n    for (s = -1, o = i.length - 1; o >= 0; o--)\n      if (i[o] === t || i[o].listener === t) {\n        f = i[o].listener, s = o;\n        break;\n      }\n    if (s < 0)\n      return this;\n    s === 0 ? i.shift() : vl(i, s), i.length === 1 && (n[e] = i[0]), n.removeListener !== void 0 && this.emit(\"removeListener\", e, f || t);\n  }\n  return this;\n};\nnt.prototype.off = nt.prototype.removeListener;\nnt.prototype.removeAllListeners = function(e) {\n  var t, i, n;\n  if (i = this._events, i === void 0)\n    return this;\n  if (i.removeListener === void 0)\n    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[e]), this;\n  if (arguments.length === 0) {\n    var s = Object.keys(i), o;\n    for (n = 0; n < s.length; ++n)\n      o = s[n], o !== \"removeListener\" && this.removeAllListeners(o);\n    return this.removeAllListeners(\"removeListener\"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;\n  }\n  if (t = i[e], typeof t == \"function\")\n    this.removeListener(e, t);\n  else if (t !== void 0)\n    for (n = t.length - 1; n >= 0; n--)\n      this.removeListener(e, t[n]);\n  return this;\n};\nfunction Lh(r, e, t) {\n  var i = r._events;\n  if (i === void 0)\n    return [];\n  var n = i[e];\n  return n === void 0 ? [] : typeof n == \"function\" ? t ? [n.listener || n] : [n] : t ? bl(n) : qh(n, n.length);\n}\nnt.prototype.listeners = function(e) {\n  return Lh(this, e, !0);\n};\nnt.prototype.rawListeners = function(e) {\n  return Lh(this, e, !1);\n};\nnt.listenerCount = function(r, e) {\n  return typeof r.listenerCount == \"function\" ? r.listenerCount(e) : Fh.call(r, e);\n};\nnt.prototype.listenerCount = Fh;\nfunction Fh(r) {\n  var e = this._events;\n  if (e !== void 0) {\n    var t = e[r];\n    if (typeof t == \"function\")\n      return 1;\n    if (t !== void 0)\n      return t.length;\n  }\n  return 0;\n}\nnt.prototype.eventNames = function() {\n  return this._eventsCount > 0 ? Ms(this._events) : [];\n};\nfunction qh(r, e) {\n  for (var t = new Array(e), i = 0; i < e; ++i)\n    t[i] = r[i];\n  return t;\n}\nfunction vl(r, e) {\n  for (; e + 1 < r.length; e++)\n    r[e] = r[e + 1];\n  r.pop();\n}\nfunction bl(r) {\n  for (var e = new Array(r.length), t = 0; t < e.length; ++t)\n    e[t] = r[t].listener || r[t];\n  return e;\n}\nfunction gl(r, e) {\n  return new Promise(function(t, i) {\n    function n(o) {\n      r.removeListener(e, s), i(o);\n    }\n    function s() {\n      typeof r.removeListener == \"function\" && r.removeListener(\"error\", n), t([].slice.call(arguments));\n    }\n    Uh(r, e, s, { once: !0 }), e !== \"error\" && yl(r, n, { once: !0 });\n  });\n}\nfunction yl(r, e, t) {\n  typeof r.on == \"function\" && Uh(r, \"error\", e, t);\n}\nfunction Uh(r, e, t, i) {\n  if (typeof r.on == \"function\")\n    i.once ? r.once(e, t) : r.on(e, t);\n  else if (typeof r.addEventListener == \"function\")\n    r.addEventListener(e, function n(s) {\n      i.once && r.removeEventListener(e, n), t(s);\n    });\n  else\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof r);\n}\nvar ir = Ro.exports;\nconst zh = /* @__PURE__ */ (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.d)(ir);\nvar ie = {};\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar ao = function(r, e) {\n  return ao = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {\n    t.__proto__ = i;\n  } || function(t, i) {\n    for (var n in i)\n      i.hasOwnProperty(n) && (t[n] = i[n]);\n  }, ao(r, e);\n};\nfunction ml(r, e) {\n  ao(r, e);\n  function t() {\n    this.constructor = r;\n  }\n  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());\n}\nvar oo = function() {\n  return oo = Object.assign || function(e) {\n    for (var t, i = 1, n = arguments.length; i < n; i++) {\n      t = arguments[i];\n      for (var s in t)\n        Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);\n    }\n    return e;\n  }, oo.apply(this, arguments);\n};\nfunction wl(r, e) {\n  var t = {};\n  for (var i in r)\n    Object.prototype.hasOwnProperty.call(r, i) && e.indexOf(i) < 0 && (t[i] = r[i]);\n  if (r != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var n = 0, i = Object.getOwnPropertySymbols(r); n < i.length; n++)\n      e.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(r, i[n]) && (t[i[n]] = r[i[n]]);\n  return t;\n}\nfunction _l(r, e, t, i) {\n  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;\n  if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n    s = Reflect.decorate(r, e, t, i);\n  else\n    for (var f = r.length - 1; f >= 0; f--)\n      (o = r[f]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);\n  return n > 3 && s && Object.defineProperty(e, t, s), s;\n}\nfunction xl(r, e) {\n  return function(t, i) {\n    e(t, i, r);\n  };\n}\nfunction El(r, e) {\n  if (typeof Reflect == \"object\" && typeof Reflect.metadata == \"function\")\n    return Reflect.metadata(r, e);\n}\nfunction Sl(r, e, t, i) {\n  function n(s) {\n    return s instanceof t ? s : new t(function(o) {\n      o(s);\n    });\n  }\n  return new (t || (t = Promise))(function(s, o) {\n    function f(v) {\n      try {\n        d(i.next(v));\n      } catch (w) {\n        o(w);\n      }\n    }\n    function h(v) {\n      try {\n        d(i.throw(v));\n      } catch (w) {\n        o(w);\n      }\n    }\n    function d(v) {\n      v.done ? s(v.value) : n(v.value).then(f, h);\n    }\n    d((i = i.apply(r, e || [])).next());\n  });\n}\nfunction Ml(r, e) {\n  var t = { label: 0, sent: function() {\n    if (s[0] & 1)\n      throw s[1];\n    return s[1];\n  }, trys: [], ops: [] }, i, n, s, o;\n  return o = { next: f(0), throw: f(1), return: f(2) }, typeof Symbol == \"function\" && (o[Symbol.iterator] = function() {\n    return this;\n  }), o;\n  function f(d) {\n    return function(v) {\n      return h([d, v]);\n    };\n  }\n  function h(d) {\n    if (i)\n      throw new TypeError(\"Generator is already executing.\");\n    for (; t; )\n      try {\n        if (i = 1, n && (s = d[0] & 2 ? n.return : d[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) && !(s = s.call(n, d[1])).done)\n          return s;\n        switch (n = 0, s && (d = [d[0] & 2, s.value]), d[0]) {\n          case 0:\n          case 1:\n            s = d;\n            break;\n          case 4:\n            return t.label++, { value: d[1], done: !1 };\n          case 5:\n            t.label++, n = d[1], d = [0];\n            continue;\n          case 7:\n            d = t.ops.pop(), t.trys.pop();\n            continue;\n          default:\n            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (d[0] === 6 || d[0] === 2)) {\n              t = 0;\n              continue;\n            }\n            if (d[0] === 3 && (!s || d[1] > s[0] && d[1] < s[3])) {\n              t.label = d[1];\n              break;\n            }\n            if (d[0] === 6 && t.label < s[1]) {\n              t.label = s[1], s = d;\n              break;\n            }\n            if (s && t.label < s[2]) {\n              t.label = s[2], t.ops.push(d);\n              break;\n            }\n            s[2] && t.ops.pop(), t.trys.pop();\n            continue;\n        }\n        d = e.call(r, t);\n      } catch (v) {\n        d = [6, v], n = 0;\n      } finally {\n        i = s = 0;\n      }\n    if (d[0] & 5)\n      throw d[1];\n    return { value: d[0] ? d[1] : void 0, done: !0 };\n  }\n}\nfunction Il(r, e, t, i) {\n  i === void 0 && (i = t), r[i] = e[t];\n}\nfunction Al(r, e) {\n  for (var t in r)\n    t !== \"default\" && !e.hasOwnProperty(t) && (e[t] = r[t]);\n}\nfunction fo(r) {\n  var e = typeof Symbol == \"function\" && Symbol.iterator, t = e && r[e], i = 0;\n  if (t)\n    return t.call(r);\n  if (r && typeof r.length == \"number\")\n    return {\n      next: function() {\n        return r && i >= r.length && (r = void 0), { value: r && r[i++], done: !r };\n      }\n    };\n  throw new TypeError(e ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction Bh(r, e) {\n  var t = typeof Symbol == \"function\" && r[Symbol.iterator];\n  if (!t)\n    return r;\n  var i = t.call(r), n, s = [], o;\n  try {\n    for (; (e === void 0 || e-- > 0) && !(n = i.next()).done; )\n      s.push(n.value);\n  } catch (f) {\n    o = { error: f };\n  } finally {\n    try {\n      n && !n.done && (t = i.return) && t.call(i);\n    } finally {\n      if (o)\n        throw o.error;\n    }\n  }\n  return s;\n}\nfunction Dl() {\n  for (var r = [], e = 0; e < arguments.length; e++)\n    r = r.concat(Bh(arguments[e]));\n  return r;\n}\nfunction Pl() {\n  for (var r = 0, e = 0, t = arguments.length; e < t; e++)\n    r += arguments[e].length;\n  for (var i = Array(r), n = 0, e = 0; e < t; e++)\n    for (var s = arguments[e], o = 0, f = s.length; o < f; o++, n++)\n      i[n] = s[o];\n  return i;\n}\nfunction Wn(r) {\n  return this instanceof Wn ? (this.v = r, this) : new Wn(r);\n}\nfunction Ol(r, e, t) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var i = t.apply(r, e || []), n, s = [];\n  return n = {}, o(\"next\"), o(\"throw\"), o(\"return\"), n[Symbol.asyncIterator] = function() {\n    return this;\n  }, n;\n  function o(A) {\n    i[A] && (n[A] = function(I) {\n      return new Promise(function(D, N) {\n        s.push([A, I, D, N]) > 1 || f(A, I);\n      });\n    });\n  }\n  function f(A, I) {\n    try {\n      h(i[A](I));\n    } catch (D) {\n      w(s[0][3], D);\n    }\n  }\n  function h(A) {\n    A.value instanceof Wn ? Promise.resolve(A.value.v).then(d, v) : w(s[0][2], A);\n  }\n  function d(A) {\n    f(\"next\", A);\n  }\n  function v(A) {\n    f(\"throw\", A);\n  }\n  function w(A, I) {\n    A(I), s.shift(), s.length && f(s[0][0], s[0][1]);\n  }\n}\nfunction Rl(r) {\n  var e, t;\n  return e = {}, i(\"next\"), i(\"throw\", function(n) {\n    throw n;\n  }), i(\"return\"), e[Symbol.iterator] = function() {\n    return this;\n  }, e;\n  function i(n, s) {\n    e[n] = r[n] ? function(o) {\n      return (t = !t) ? { value: Wn(r[n](o)), done: n === \"return\" } : s ? s(o) : o;\n    } : s;\n  }\n}\nfunction Nl(r) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var e = r[Symbol.asyncIterator], t;\n  return e ? e.call(r) : (r = typeof fo == \"function\" ? fo(r) : r[Symbol.iterator](), t = {}, i(\"next\"), i(\"throw\"), i(\"return\"), t[Symbol.asyncIterator] = function() {\n    return this;\n  }, t);\n  function i(s) {\n    t[s] = r[s] && function(o) {\n      return new Promise(function(f, h) {\n        o = r[s](o), n(f, h, o.done, o.value);\n      });\n    };\n  }\n  function n(s, o, f, h) {\n    Promise.resolve(h).then(function(d) {\n      s({ value: d, done: f });\n    }, o);\n  }\n}\nfunction Tl(r, e) {\n  return Object.defineProperty ? Object.defineProperty(r, \"raw\", { value: e }) : r.raw = e, r;\n}\nfunction Cl(r) {\n  if (r && r.__esModule)\n    return r;\n  var e = {};\n  if (r != null)\n    for (var t in r)\n      Object.hasOwnProperty.call(r, t) && (e[t] = r[t]);\n  return e.default = r, e;\n}\nfunction $l(r) {\n  return r && r.__esModule ? r : { default: r };\n}\nfunction Ll(r, e) {\n  if (!e.has(r))\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  return e.get(r);\n}\nfunction Fl(r, e, t) {\n  if (!e.has(r))\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  return e.set(r, t), t;\n}\nconst ql = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  get __assign() {\n    return oo;\n  },\n  __asyncDelegator: Rl,\n  __asyncGenerator: Ol,\n  __asyncValues: Nl,\n  __await: Wn,\n  __awaiter: Sl,\n  __classPrivateFieldGet: Ll,\n  __classPrivateFieldSet: Fl,\n  __createBinding: Il,\n  __decorate: _l,\n  __exportStar: Al,\n  __extends: ml,\n  __generator: Ml,\n  __importDefault: $l,\n  __importStar: Cl,\n  __makeTemplateObject: Tl,\n  __metadata: El,\n  __param: xl,\n  __read: Bh,\n  __rest: wl,\n  __spread: Dl,\n  __spreadArrays: Pl,\n  __values: fo\n}, Symbol.toStringTag, { value: \"Module\" })), Qn = /* @__PURE__ */ (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.g)(ql);\nvar Na = {}, Rn = {}, xf;\nfunction Ul() {\n  if (xf)\n    return Rn;\n  xf = 1, Object.defineProperty(Rn, \"__esModule\", { value: !0 }), Rn.delay = void 0;\n  function r(e) {\n    return new Promise((t) => {\n      setTimeout(() => {\n        t(!0);\n      }, e);\n    });\n  }\n  return Rn.delay = r, Rn;\n}\nvar Oi = {}, Ta = {}, Ri = {}, Ef;\nfunction zl() {\n  return Ef || (Ef = 1, Object.defineProperty(Ri, \"__esModule\", { value: !0 }), Ri.ONE_THOUSAND = Ri.ONE_HUNDRED = void 0, Ri.ONE_HUNDRED = 100, Ri.ONE_THOUSAND = 1e3), Ri;\n}\nvar Ca = {}, Sf;\nfunction Bl() {\n  return Sf || (Sf = 1, function(r) {\n    Object.defineProperty(r, \"__esModule\", { value: !0 }), r.ONE_YEAR = r.FOUR_WEEKS = r.THREE_WEEKS = r.TWO_WEEKS = r.ONE_WEEK = r.THIRTY_DAYS = r.SEVEN_DAYS = r.FIVE_DAYS = r.THREE_DAYS = r.ONE_DAY = r.TWENTY_FOUR_HOURS = r.TWELVE_HOURS = r.SIX_HOURS = r.THREE_HOURS = r.ONE_HOUR = r.SIXTY_MINUTES = r.THIRTY_MINUTES = r.TEN_MINUTES = r.FIVE_MINUTES = r.ONE_MINUTE = r.SIXTY_SECONDS = r.THIRTY_SECONDS = r.TEN_SECONDS = r.FIVE_SECONDS = r.ONE_SECOND = void 0, r.ONE_SECOND = 1, r.FIVE_SECONDS = 5, r.TEN_SECONDS = 10, r.THIRTY_SECONDS = 30, r.SIXTY_SECONDS = 60, r.ONE_MINUTE = r.SIXTY_SECONDS, r.FIVE_MINUTES = r.ONE_MINUTE * 5, r.TEN_MINUTES = r.ONE_MINUTE * 10, r.THIRTY_MINUTES = r.ONE_MINUTE * 30, r.SIXTY_MINUTES = r.ONE_MINUTE * 60, r.ONE_HOUR = r.SIXTY_MINUTES, r.THREE_HOURS = r.ONE_HOUR * 3, r.SIX_HOURS = r.ONE_HOUR * 6, r.TWELVE_HOURS = r.ONE_HOUR * 12, r.TWENTY_FOUR_HOURS = r.ONE_HOUR * 24, r.ONE_DAY = r.TWENTY_FOUR_HOURS, r.THREE_DAYS = r.ONE_DAY * 3, r.FIVE_DAYS = r.ONE_DAY * 5, r.SEVEN_DAYS = r.ONE_DAY * 7, r.THIRTY_DAYS = r.ONE_DAY * 30, r.ONE_WEEK = r.SEVEN_DAYS, r.TWO_WEEKS = r.ONE_WEEK * 2, r.THREE_WEEKS = r.ONE_WEEK * 3, r.FOUR_WEEKS = r.ONE_WEEK * 4, r.ONE_YEAR = r.ONE_DAY * 365;\n  }(Ca)), Ca;\n}\nvar Mf;\nfunction kh() {\n  return Mf || (Mf = 1, function(r) {\n    Object.defineProperty(r, \"__esModule\", { value: !0 });\n    const e = Qn;\n    e.__exportStar(zl(), r), e.__exportStar(Bl(), r);\n  }(Ta)), Ta;\n}\nvar If;\nfunction kl() {\n  if (If)\n    return Oi;\n  If = 1, Object.defineProperty(Oi, \"__esModule\", { value: !0 }), Oi.fromMiliseconds = Oi.toMiliseconds = void 0;\n  const r = kh();\n  function e(i) {\n    return i * r.ONE_THOUSAND;\n  }\n  Oi.toMiliseconds = e;\n  function t(i) {\n    return Math.floor(i / r.ONE_THOUSAND);\n  }\n  return Oi.fromMiliseconds = t, Oi;\n}\nvar Af;\nfunction jl() {\n  return Af || (Af = 1, function(r) {\n    Object.defineProperty(r, \"__esModule\", { value: !0 });\n    const e = Qn;\n    e.__exportStar(Ul(), r), e.__exportStar(kl(), r);\n  }(Na)), Na;\n}\nvar tn = {}, Df;\nfunction Kl() {\n  if (Df)\n    return tn;\n  Df = 1, Object.defineProperty(tn, \"__esModule\", { value: !0 }), tn.Watch = void 0;\n  class r {\n    constructor() {\n      this.timestamps = /* @__PURE__ */ new Map();\n    }\n    start(t) {\n      if (this.timestamps.has(t))\n        throw new Error(`Watch already started for label: ${t}`);\n      this.timestamps.set(t, { started: Date.now() });\n    }\n    stop(t) {\n      const i = this.get(t);\n      if (typeof i.elapsed < \"u\")\n        throw new Error(`Watch already stopped for label: ${t}`);\n      const n = Date.now() - i.started;\n      this.timestamps.set(t, { started: i.started, elapsed: n });\n    }\n    get(t) {\n      const i = this.timestamps.get(t);\n      if (typeof i > \"u\")\n        throw new Error(`No timestamp found for label: ${t}`);\n      return i;\n    }\n    elapsed(t) {\n      const i = this.get(t);\n      return i.elapsed || Date.now() - i.started;\n    }\n  }\n  return tn.Watch = r, tn.default = r, tn;\n}\nvar $a = {}, Nn = {}, Pf;\nfunction Hl() {\n  if (Pf)\n    return Nn;\n  Pf = 1, Object.defineProperty(Nn, \"__esModule\", { value: !0 }), Nn.IWatch = void 0;\n  class r {\n  }\n  return Nn.IWatch = r, Nn;\n}\nvar Of;\nfunction Vl() {\n  return Of || (Of = 1, function(r) {\n    Object.defineProperty(r, \"__esModule\", { value: !0 }), Qn.__exportStar(Hl(), r);\n  }($a)), $a;\n}\n(function(r) {\n  Object.defineProperty(r, \"__esModule\", { value: !0 });\n  const e = Qn;\n  e.__exportStar(jl(), r), e.__exportStar(Kl(), r), e.__exportStar(Vl(), r), e.__exportStar(kh(), r);\n})(ie);\nclass Wi {\n}\nlet Wl = class extends Wi {\n  constructor(e) {\n    super();\n  }\n};\nconst Rf = ie.FIVE_SECONDS, gn = { pulse: \"heartbeat_pulse\" };\nlet Gl = class jh extends Wl {\n  constructor(e) {\n    super(e), this.events = new ir.EventEmitter(), this.interval = Rf, this.interval = e?.interval || Rf;\n  }\n  static async init(e) {\n    const t = new jh(e);\n    return await t.init(), t;\n  }\n  async init() {\n    await this.initialize();\n  }\n  stop() {\n    clearInterval(this.intervalRef);\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async initialize() {\n    this.intervalRef = setInterval(() => this.pulse(), ie.toMiliseconds(this.interval));\n  }\n  pulse() {\n    this.events.emit(gn.pulse);\n  }\n};\nconst Jl = /\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/, Yl = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/, Xl = /^\\s*[\"[{]|^\\s*-?\\d{1,16}(\\.\\d{1,17})?([Ee][+-]?\\d+)?\\s*$/;\nfunction Zl(r, e) {\n  if (r === \"__proto__\" || r === \"constructor\" && e && typeof e == \"object\" && \"prototype\" in e) {\n    Ql(r);\n    return;\n  }\n  return e;\n}\nfunction Ql(r) {\n  console.warn(`[destr] Dropping \"${r}\" key to prevent prototype pollution.`);\n}\nfunction ms(r, e = {}) {\n  if (typeof r != \"string\")\n    return r;\n  const t = r.trim();\n  if (\n    // eslint-disable-next-line unicorn/prefer-at\n    r[0] === '\"' && r.endsWith('\"') && !r.includes(\"\\\\\")\n  )\n    return t.slice(1, -1);\n  if (t.length <= 9) {\n    const i = t.toLowerCase();\n    if (i === \"true\")\n      return !0;\n    if (i === \"false\")\n      return !1;\n    if (i === \"undefined\")\n      return;\n    if (i === \"null\")\n      return null;\n    if (i === \"nan\")\n      return Number.NaN;\n    if (i === \"infinity\")\n      return Number.POSITIVE_INFINITY;\n    if (i === \"-infinity\")\n      return Number.NEGATIVE_INFINITY;\n  }\n  if (!Xl.test(r)) {\n    if (e.strict)\n      throw new SyntaxError(\"[destr] Invalid JSON\");\n    return r;\n  }\n  try {\n    if (Jl.test(r) || Yl.test(r)) {\n      if (e.strict)\n        throw new Error(\"[destr] Possible prototype pollution\");\n      return JSON.parse(r, Zl);\n    }\n    return JSON.parse(r);\n  } catch (i) {\n    if (e.strict)\n      throw i;\n    return r;\n  }\n}\nfunction e0(r) {\n  return !r || typeof r.then != \"function\" ? Promise.resolve(r) : r;\n}\nfunction xt(r, ...e) {\n  try {\n    return e0(r(...e));\n  } catch (t) {\n    return Promise.reject(t);\n  }\n}\nfunction t0(r) {\n  const e = typeof r;\n  return r === null || e !== \"object\" && e !== \"function\";\n}\nfunction r0(r) {\n  const e = Object.getPrototypeOf(r);\n  return !e || e.isPrototypeOf(Object);\n}\nfunction Is(r) {\n  if (t0(r))\n    return String(r);\n  if (r0(r) || Array.isArray(r))\n    return JSON.stringify(r);\n  if (typeof r.toJSON == \"function\")\n    return Is(r.toJSON());\n  throw new Error(\"[unstorage] Cannot stringify value!\");\n}\nconst co = \"base64:\";\nfunction i0(r) {\n  return typeof r == \"string\" ? r : co + a0(r);\n}\nfunction n0(r) {\n  return typeof r != \"string\" || !r.startsWith(co) ? r : s0(r.slice(co.length));\n}\nfunction s0(r) {\n  return globalThis.Buffer ? Buffer.from(r, \"base64\") : Uint8Array.from(\n    globalThis.atob(r),\n    (e) => e.codePointAt(0)\n  );\n}\nfunction a0(r) {\n  return globalThis.Buffer ? Buffer.from(r).toString(\"base64\") : globalThis.btoa(String.fromCodePoint(...r));\n}\nfunction Wt(r) {\n  return r && r.split(\"?\")[0]?.replace(/[/\\\\]/g, \":\").replace(/:+/g, \":\").replace(/^:|:$/g, \"\") || \"\";\n}\nfunction o0(...r) {\n  return Wt(r.join(\":\"));\n}\nfunction ws(r) {\n  return r = Wt(r), r ? r + \":\" : \"\";\n}\nconst f0 = \"memory\", c0 = () => {\n  const r = /* @__PURE__ */ new Map();\n  return {\n    name: f0,\n    getInstance: () => r,\n    hasItem(e) {\n      return r.has(e);\n    },\n    getItem(e) {\n      return r.get(e) ?? null;\n    },\n    getItemRaw(e) {\n      return r.get(e) ?? null;\n    },\n    setItem(e, t) {\n      r.set(e, t);\n    },\n    setItemRaw(e, t) {\n      r.set(e, t);\n    },\n    removeItem(e) {\n      r.delete(e);\n    },\n    getKeys() {\n      return [...r.keys()];\n    },\n    clear() {\n      r.clear();\n    },\n    dispose() {\n      r.clear();\n    }\n  };\n};\nfunction h0(r = {}) {\n  const e = {\n    mounts: { \"\": r.driver || c0() },\n    mountpoints: [\"\"],\n    watching: !1,\n    watchListeners: [],\n    unwatch: {}\n  }, t = (d) => {\n    for (const v of e.mountpoints)\n      if (d.startsWith(v))\n        return {\n          base: v,\n          relativeKey: d.slice(v.length),\n          driver: e.mounts[v]\n        };\n    return {\n      base: \"\",\n      relativeKey: d,\n      driver: e.mounts[\"\"]\n    };\n  }, i = (d, v) => e.mountpoints.filter(\n    (w) => w.startsWith(d) || v && d.startsWith(w)\n  ).map((w) => ({\n    relativeBase: d.length > w.length ? d.slice(w.length) : void 0,\n    mountpoint: w,\n    driver: e.mounts[w]\n  })), n = (d, v) => {\n    if (e.watching) {\n      v = Wt(v);\n      for (const w of e.watchListeners)\n        w(d, v);\n    }\n  }, s = async () => {\n    if (!e.watching) {\n      e.watching = !0;\n      for (const d in e.mounts)\n        e.unwatch[d] = await Nf(\n          e.mounts[d],\n          n,\n          d\n        );\n    }\n  }, o = async () => {\n    if (e.watching) {\n      for (const d in e.unwatch)\n        await e.unwatch[d]();\n      e.unwatch = {}, e.watching = !1;\n    }\n  }, f = (d, v, w) => {\n    const A = /* @__PURE__ */ new Map(), I = (D) => {\n      let N = A.get(D.base);\n      return N || (N = {\n        driver: D.driver,\n        base: D.base,\n        items: []\n      }, A.set(D.base, N)), N;\n    };\n    for (const D of d) {\n      const N = typeof D == \"string\", k = Wt(N ? D : D.key), j = N ? void 0 : D.value, T = N || !D.options ? v : { ...v, ...D.options }, K = t(k);\n      I(K).items.push({\n        key: k,\n        value: j,\n        relativeKey: K.relativeKey,\n        options: T\n      });\n    }\n    return Promise.all([...A.values()].map((D) => w(D))).then(\n      (D) => D.flat()\n    );\n  }, h = {\n    // Item\n    hasItem(d, v = {}) {\n      d = Wt(d);\n      const { relativeKey: w, driver: A } = t(d);\n      return xt(A.hasItem, w, v);\n    },\n    getItem(d, v = {}) {\n      d = Wt(d);\n      const { relativeKey: w, driver: A } = t(d);\n      return xt(A.getItem, w, v).then(\n        (I) => ms(I)\n      );\n    },\n    getItems(d, v = {}) {\n      return f(d, v, (w) => w.driver.getItems ? xt(\n        w.driver.getItems,\n        w.items.map((A) => ({\n          key: A.relativeKey,\n          options: A.options\n        })),\n        v\n      ).then(\n        (A) => A.map((I) => ({\n          key: o0(w.base, I.key),\n          value: ms(I.value)\n        }))\n      ) : Promise.all(\n        w.items.map((A) => xt(\n          w.driver.getItem,\n          A.relativeKey,\n          A.options\n        ).then((I) => ({\n          key: A.key,\n          value: ms(I)\n        })))\n      ));\n    },\n    getItemRaw(d, v = {}) {\n      d = Wt(d);\n      const { relativeKey: w, driver: A } = t(d);\n      return A.getItemRaw ? xt(A.getItemRaw, w, v) : xt(A.getItem, w, v).then(\n        (I) => n0(I)\n      );\n    },\n    async setItem(d, v, w = {}) {\n      if (v === void 0)\n        return h.removeItem(d);\n      d = Wt(d);\n      const { relativeKey: A, driver: I } = t(d);\n      I.setItem && (await xt(I.setItem, A, Is(v), w), I.watch || n(\"update\", d));\n    },\n    async setItems(d, v) {\n      await f(d, v, async (w) => {\n        if (w.driver.setItems)\n          return xt(\n            w.driver.setItems,\n            w.items.map((A) => ({\n              key: A.relativeKey,\n              value: Is(A.value),\n              options: A.options\n            })),\n            v\n          );\n        w.driver.setItem && await Promise.all(\n          w.items.map((A) => xt(\n            w.driver.setItem,\n            A.relativeKey,\n            Is(A.value),\n            A.options\n          ))\n        );\n      });\n    },\n    async setItemRaw(d, v, w = {}) {\n      if (v === void 0)\n        return h.removeItem(d, w);\n      d = Wt(d);\n      const { relativeKey: A, driver: I } = t(d);\n      if (I.setItemRaw)\n        await xt(I.setItemRaw, A, v, w);\n      else if (I.setItem)\n        await xt(I.setItem, A, i0(v), w);\n      else\n        return;\n      I.watch || n(\"update\", d);\n    },\n    async removeItem(d, v = {}) {\n      typeof v == \"boolean\" && (v = { removeMeta: v }), d = Wt(d);\n      const { relativeKey: w, driver: A } = t(d);\n      A.removeItem && (await xt(A.removeItem, w, v), (v.removeMeta || v.removeMata) && await xt(A.removeItem, w + \"$\", v), A.watch || n(\"remove\", d));\n    },\n    // Meta\n    async getMeta(d, v = {}) {\n      typeof v == \"boolean\" && (v = { nativeOnly: v }), d = Wt(d);\n      const { relativeKey: w, driver: A } = t(d), I = /* @__PURE__ */ Object.create(null);\n      if (A.getMeta && Object.assign(I, await xt(A.getMeta, w, v)), !v.nativeOnly) {\n        const D = await xt(\n          A.getItem,\n          w + \"$\",\n          v\n        ).then((N) => ms(N));\n        D && typeof D == \"object\" && (typeof D.atime == \"string\" && (D.atime = new Date(D.atime)), typeof D.mtime == \"string\" && (D.mtime = new Date(D.mtime)), Object.assign(I, D));\n      }\n      return I;\n    },\n    setMeta(d, v, w = {}) {\n      return this.setItem(d + \"$\", v, w);\n    },\n    removeMeta(d, v = {}) {\n      return this.removeItem(d + \"$\", v);\n    },\n    // Keys\n    async getKeys(d, v = {}) {\n      d = ws(d);\n      const w = i(d, !0);\n      let A = [];\n      const I = [];\n      for (const D of w) {\n        const N = await xt(\n          D.driver.getKeys,\n          D.relativeBase,\n          v\n        );\n        for (const k of N) {\n          const j = D.mountpoint + Wt(k);\n          A.some((T) => j.startsWith(T)) || I.push(j);\n        }\n        A = [\n          D.mountpoint,\n          ...A.filter((k) => !k.startsWith(D.mountpoint))\n        ];\n      }\n      return d ? I.filter(\n        (D) => D.startsWith(d) && D[D.length - 1] !== \"$\"\n      ) : I.filter((D) => D[D.length - 1] !== \"$\");\n    },\n    // Utils\n    async clear(d, v = {}) {\n      d = ws(d), await Promise.all(\n        i(d, !1).map(async (w) => {\n          if (w.driver.clear)\n            return xt(w.driver.clear, w.relativeBase, v);\n          if (w.driver.removeItem) {\n            const A = await w.driver.getKeys(w.relativeBase || \"\", v);\n            return Promise.all(\n              A.map((I) => w.driver.removeItem(I, v))\n            );\n          }\n        })\n      );\n    },\n    async dispose() {\n      await Promise.all(\n        Object.values(e.mounts).map((d) => Tf(d))\n      );\n    },\n    async watch(d) {\n      return await s(), e.watchListeners.push(d), async () => {\n        e.watchListeners = e.watchListeners.filter(\n          (v) => v !== d\n        ), e.watchListeners.length === 0 && await o();\n      };\n    },\n    async unwatch() {\n      e.watchListeners = [], await o();\n    },\n    // Mount\n    mount(d, v) {\n      if (d = ws(d), d && e.mounts[d])\n        throw new Error(`already mounted at ${d}`);\n      return d && (e.mountpoints.push(d), e.mountpoints.sort((w, A) => A.length - w.length)), e.mounts[d] = v, e.watching && Promise.resolve(Nf(v, n, d)).then((w) => {\n        e.unwatch[d] = w;\n      }).catch(console.error), h;\n    },\n    async unmount(d, v = !0) {\n      d = ws(d), !(!d || !e.mounts[d]) && (e.watching && d in e.unwatch && (e.unwatch[d]?.(), delete e.unwatch[d]), v && await Tf(e.mounts[d]), e.mountpoints = e.mountpoints.filter((w) => w !== d), delete e.mounts[d]);\n    },\n    getMount(d = \"\") {\n      d = Wt(d) + \":\";\n      const v = t(d);\n      return {\n        driver: v.driver,\n        base: v.base\n      };\n    },\n    getMounts(d = \"\", v = {}) {\n      return d = Wt(d), i(d, v.parents).map((A) => ({\n        driver: A.driver,\n        base: A.mountpoint\n      }));\n    },\n    // Aliases\n    keys: (d, v = {}) => h.getKeys(d, v),\n    get: (d, v = {}) => h.getItem(d, v),\n    set: (d, v, w = {}) => h.setItem(d, v, w),\n    has: (d, v = {}) => h.hasItem(d, v),\n    del: (d, v = {}) => h.removeItem(d, v),\n    remove: (d, v = {}) => h.removeItem(d, v)\n  };\n  return h;\n}\nfunction Nf(r, e, t) {\n  return r.watch ? r.watch((i, n) => e(i, t + n)) : () => {\n  };\n}\nasync function Tf(r) {\n  typeof r.dispose == \"function\" && await xt(r.dispose);\n}\nfunction Gi(r) {\n  return new Promise((e, t) => {\n    r.oncomplete = r.onsuccess = () => e(r.result), r.onabort = r.onerror = () => t(r.error);\n  });\n}\nfunction Kh(r, e) {\n  const t = indexedDB.open(r);\n  t.onupgradeneeded = () => t.result.createObjectStore(e);\n  const i = Gi(t);\n  return (n, s) => i.then((o) => s(o.transaction(e, n).objectStore(e)));\n}\nlet La;\nfunction es() {\n  return La || (La = Kh(\"keyval-store\", \"keyval\")), La;\n}\nfunction Cf(r, e = es()) {\n  return e(\"readonly\", (t) => Gi(t.get(r)));\n}\nfunction u0(r, e, t = es()) {\n  return t(\"readwrite\", (i) => (i.put(e, r), Gi(i.transaction)));\n}\nfunction d0(r, e = es()) {\n  return e(\"readwrite\", (t) => (t.delete(r), Gi(t.transaction)));\n}\nfunction l0(r = es()) {\n  return r(\"readwrite\", (e) => (e.clear(), Gi(e.transaction)));\n}\nfunction p0(r, e) {\n  return r.openCursor().onsuccess = function() {\n    this.result && (e(this.result), this.result.continue());\n  }, Gi(r.transaction);\n}\nfunction v0(r = es()) {\n  return r(\"readonly\", (e) => {\n    if (e.getAllKeys)\n      return Gi(e.getAllKeys());\n    const t = [];\n    return p0(e, (i) => t.push(i.key)).then(() => t);\n  });\n}\nconst b0 = (r) => JSON.stringify(r, (e, t) => typeof t == \"bigint\" ? t.toString() + \"n\" : t), g0 = (r) => {\n  const e = /([\\[:])?(\\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\\}\\]])/g, t = r.replace(e, '$1\"$2n\"$3');\n  return JSON.parse(t, (i, n) => typeof n == \"string\" && n.match(/^\\d+n$/) ? BigInt(n.substring(0, n.length - 1)) : n);\n};\nfunction un(r) {\n  if (typeof r != \"string\")\n    throw new Error(`Cannot safe json parse value of type ${typeof r}`);\n  try {\n    return g0(r);\n  } catch {\n    return r;\n  }\n}\nfunction ji(r) {\n  return typeof r == \"string\" ? r : b0(r) || \"\";\n}\nconst y0 = \"idb-keyval\";\nvar m0 = (r = {}) => {\n  const e = r.base && r.base.length > 0 ? `${r.base}:` : \"\", t = (n) => e + n;\n  let i;\n  return r.dbName && r.storeName && (i = Kh(r.dbName, r.storeName)), { name: y0, options: r, async hasItem(n) {\n    return !(typeof await Cf(t(n), i) > \"u\");\n  }, async getItem(n) {\n    return await Cf(t(n), i) ?? null;\n  }, setItem(n, s) {\n    return u0(t(n), s, i);\n  }, removeItem(n) {\n    return d0(t(n), i);\n  }, getKeys() {\n    return v0(i);\n  }, clear() {\n    return l0(i);\n  } };\n};\nconst w0 = \"WALLET_CONNECT_V2_INDEXED_DB\", _0 = \"keyvaluestorage\";\nlet x0 = class {\n  constructor() {\n    this.indexedDb = h0({ driver: m0({ dbName: w0, storeName: _0 }) });\n  }\n  async getKeys() {\n    return this.indexedDb.getKeys();\n  }\n  async getEntries() {\n    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);\n  }\n  async getItem(e) {\n    const t = await this.indexedDb.getItem(e);\n    if (t !== null)\n      return t;\n  }\n  async setItem(e, t) {\n    await this.indexedDb.setItem(e, ji(t));\n  }\n  async removeItem(e) {\n    await this.indexedDb.removeItem(e);\n  }\n};\nvar Fa = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {}, As = { exports: {} };\n(function() {\n  let r;\n  function e() {\n  }\n  r = e, r.prototype.getItem = function(t) {\n    return this.hasOwnProperty(t) ? String(this[t]) : null;\n  }, r.prototype.setItem = function(t, i) {\n    this[t] = String(i);\n  }, r.prototype.removeItem = function(t) {\n    delete this[t];\n  }, r.prototype.clear = function() {\n    const t = this;\n    Object.keys(t).forEach(function(i) {\n      t[i] = void 0, delete t[i];\n    });\n  }, r.prototype.key = function(t) {\n    return t = t || 0, Object.keys(this)[t];\n  }, r.prototype.__defineGetter__(\"length\", function() {\n    return Object.keys(this).length;\n  }), typeof Fa < \"u\" && Fa.localStorage ? As.exports = Fa.localStorage : typeof window < \"u\" && window.localStorage ? As.exports = window.localStorage : As.exports = new e();\n})();\nfunction E0(r) {\n  var e;\n  return [r[0], un((e = r[1]) != null ? e : \"\")];\n}\nlet S0 = class {\n  constructor() {\n    this.localStorage = As.exports;\n  }\n  async getKeys() {\n    return Object.keys(this.localStorage);\n  }\n  async getEntries() {\n    return Object.entries(this.localStorage).map(E0);\n  }\n  async getItem(e) {\n    const t = this.localStorage.getItem(e);\n    if (t !== null)\n      return un(t);\n  }\n  async setItem(e, t) {\n    this.localStorage.setItem(e, ji(t));\n  }\n  async removeItem(e) {\n    this.localStorage.removeItem(e);\n  }\n};\nconst M0 = \"wc_storage_version\", $f = 1, I0 = async (r, e, t) => {\n  const i = M0, n = await e.getItem(i);\n  if (n && n >= $f) {\n    t(e);\n    return;\n  }\n  const s = await r.getKeys();\n  if (!s.length) {\n    t(e);\n    return;\n  }\n  const o = [];\n  for (; s.length; ) {\n    const f = s.shift();\n    if (!f)\n      continue;\n    const h = f.toLowerCase();\n    if (h.includes(\"wc@\") || h.includes(\"walletconnect\") || h.includes(\"wc_\") || h.includes(\"wallet_connect\")) {\n      const d = await r.getItem(f);\n      await e.setItem(f, d), o.push(f);\n    }\n  }\n  await e.setItem(i, $f), t(e), A0(r, o);\n}, A0 = async (r, e) => {\n  e.length && e.forEach(async (t) => {\n    await r.removeItem(t);\n  });\n};\nlet D0 = class {\n  constructor() {\n    this.initialized = !1, this.setInitialized = (t) => {\n      this.storage = t, this.initialized = !0;\n    };\n    const e = new S0();\n    this.storage = e;\n    try {\n      const t = new x0();\n      I0(e, t, this.setInitialized);\n    } catch {\n      this.initialized = !0;\n    }\n  }\n  async getKeys() {\n    return await this.initialize(), this.storage.getKeys();\n  }\n  async getEntries() {\n    return await this.initialize(), this.storage.getEntries();\n  }\n  async getItem(e) {\n    return await this.initialize(), this.storage.getItem(e);\n  }\n  async setItem(e, t) {\n    return await this.initialize(), this.storage.setItem(e, t);\n  }\n  async removeItem(e) {\n    return await this.initialize(), this.storage.removeItem(e);\n  }\n  async initialize() {\n    this.initialized || await new Promise((e) => {\n      const t = setInterval(() => {\n        this.initialized && (clearInterval(t), e());\n      }, 20);\n    });\n  }\n};\nfunction P0(r) {\n  try {\n    return JSON.stringify(r);\n  } catch {\n    return '\"[Circular]\"';\n  }\n}\nvar O0 = R0;\nfunction R0(r, e, t) {\n  var i = t && t.stringify || P0, n = 1;\n  if (typeof r == \"object\" && r !== null) {\n    var s = e.length + n;\n    if (s === 1)\n      return r;\n    var o = new Array(s);\n    o[0] = i(r);\n    for (var f = 1; f < s; f++)\n      o[f] = i(e[f]);\n    return o.join(\" \");\n  }\n  if (typeof r != \"string\")\n    return r;\n  var h = e.length;\n  if (h === 0)\n    return r;\n  for (var d = \"\", v = 1 - n, w = -1, A = r && r.length || 0, I = 0; I < A; ) {\n    if (r.charCodeAt(I) === 37 && I + 1 < A) {\n      switch (w = w > -1 ? w : 0, r.charCodeAt(I + 1)) {\n        case 100:\n        case 102:\n          if (v >= h || e[v] == null)\n            break;\n          w < I && (d += r.slice(w, I)), d += Number(e[v]), w = I + 2, I++;\n          break;\n        case 105:\n          if (v >= h || e[v] == null)\n            break;\n          w < I && (d += r.slice(w, I)), d += Math.floor(Number(e[v])), w = I + 2, I++;\n          break;\n        case 79:\n        case 111:\n        case 106:\n          if (v >= h || e[v] === void 0)\n            break;\n          w < I && (d += r.slice(w, I));\n          var D = typeof e[v];\n          if (D === \"string\") {\n            d += \"'\" + e[v] + \"'\", w = I + 2, I++;\n            break;\n          }\n          if (D === \"function\") {\n            d += e[v].name || \"<anonymous>\", w = I + 2, I++;\n            break;\n          }\n          d += i(e[v]), w = I + 2, I++;\n          break;\n        case 115:\n          if (v >= h)\n            break;\n          w < I && (d += r.slice(w, I)), d += String(e[v]), w = I + 2, I++;\n          break;\n        case 37:\n          w < I && (d += r.slice(w, I)), d += \"%\", w = I + 2, I++, v--;\n          break;\n      }\n      ++v;\n    }\n    ++I;\n  }\n  return w === -1 ? r : (w < A && (d += r.slice(w)), d);\n}\nconst Lf = O0;\nvar an = $r;\nconst Gn = B0().console || {}, N0 = {\n  mapHttpRequest: _s,\n  mapHttpResponse: _s,\n  wrapRequestSerializer: qa,\n  wrapResponseSerializer: qa,\n  wrapErrorSerializer: qa,\n  req: _s,\n  res: _s,\n  err: F0\n};\nfunction T0(r, e) {\n  return Array.isArray(r) ? r.filter(function(i) {\n    return i !== \"!stdSerializers.err\";\n  }) : r === !0 ? Object.keys(e) : !1;\n}\nfunction $r(r) {\n  r = r || {}, r.browser = r.browser || {};\n  const e = r.browser.transmit;\n  if (e && typeof e.send != \"function\")\n    throw Error(\"pino: transmit option must have a send function\");\n  const t = r.browser.write || Gn;\n  r.browser.write && (r.browser.asObject = !0);\n  const i = r.serializers || {}, n = T0(r.browser.serialize, i);\n  let s = r.browser.serialize;\n  Array.isArray(r.browser.serialize) && r.browser.serialize.indexOf(\"!stdSerializers.err\") > -1 && (s = !1);\n  const o = [\"error\", \"fatal\", \"warn\", \"info\", \"debug\", \"trace\"];\n  typeof t == \"function\" && (t.error = t.fatal = t.warn = t.info = t.debug = t.trace = t), r.enabled === !1 && (r.level = \"silent\");\n  const f = r.level || \"info\", h = Object.create(t);\n  h.log || (h.log = Jn), Object.defineProperty(h, \"levelVal\", {\n    get: v\n  }), Object.defineProperty(h, \"level\", {\n    get: w,\n    set: A\n  });\n  const d = {\n    transmit: e,\n    serialize: n,\n    asObject: r.browser.asObject,\n    levels: o,\n    timestamp: q0(r)\n  };\n  h.levels = $r.levels, h.level = f, h.setMaxListeners = h.getMaxListeners = h.emit = h.addListener = h.on = h.prependListener = h.once = h.prependOnceListener = h.removeListener = h.removeAllListeners = h.listeners = h.listenerCount = h.eventNames = h.write = h.flush = Jn, h.serializers = i, h._serialize = n, h._stdErrSerialize = s, h.child = I, e && (h._logEvent = ho());\n  function v() {\n    return this.level === \"silent\" ? 1 / 0 : this.levels.values[this.level];\n  }\n  function w() {\n    return this._level;\n  }\n  function A(D) {\n    if (D !== \"silent\" && !this.levels.values[D])\n      throw Error(\"unknown level \" + D);\n    this._level = D, rn(d, h, \"error\", \"log\"), rn(d, h, \"fatal\", \"error\"), rn(d, h, \"warn\", \"error\"), rn(d, h, \"info\", \"log\"), rn(d, h, \"debug\", \"log\"), rn(d, h, \"trace\", \"log\");\n  }\n  function I(D, N) {\n    if (!D)\n      throw new Error(\"missing bindings for child Pino\");\n    N = N || {}, n && D.serializers && (N.serializers = D.serializers);\n    const k = N.serializers;\n    if (n && k) {\n      var j = Object.assign({}, i, k), T = r.browser.serialize === !0 ? Object.keys(j) : n;\n      delete D.serializers, ia([D], T, j, this._stdErrSerialize);\n    }\n    function K($) {\n      this._childLevel = ($._childLevel | 0) + 1, this.error = nn($, D, \"error\"), this.fatal = nn($, D, \"fatal\"), this.warn = nn($, D, \"warn\"), this.info = nn($, D, \"info\"), this.debug = nn($, D, \"debug\"), this.trace = nn($, D, \"trace\"), j && (this.serializers = j, this._serialize = T), e && (this._logEvent = ho(\n        [].concat($._logEvent.bindings, D)\n      ));\n    }\n    return K.prototype = this, new K(this);\n  }\n  return h;\n}\n$r.levels = {\n  values: {\n    fatal: 60,\n    error: 50,\n    warn: 40,\n    info: 30,\n    debug: 20,\n    trace: 10\n  },\n  labels: {\n    10: \"trace\",\n    20: \"debug\",\n    30: \"info\",\n    40: \"warn\",\n    50: \"error\",\n    60: \"fatal\"\n  }\n};\n$r.stdSerializers = N0;\n$r.stdTimeFunctions = Object.assign({}, { nullTime: Hh, epochTime: Vh, unixTime: U0, isoTime: z0 });\nfunction rn(r, e, t, i) {\n  const n = Object.getPrototypeOf(e);\n  e[t] = e.levelVal > e.levels.values[t] ? Jn : n[t] ? n[t] : Gn[t] || Gn[i] || Jn, C0(r, e, t);\n}\nfunction C0(r, e, t) {\n  !r.transmit && e[t] === Jn || (e[t] = function(i) {\n    return function() {\n      const s = r.timestamp(), o = new Array(arguments.length), f = Object.getPrototypeOf && Object.getPrototypeOf(this) === Gn ? Gn : this;\n      for (var h = 0; h < o.length; h++)\n        o[h] = arguments[h];\n      if (r.serialize && !r.asObject && ia(o, this._serialize, this.serializers, this._stdErrSerialize), r.asObject ? i.call(f, $0(this, t, o, s)) : i.apply(f, o), r.transmit) {\n        const d = r.transmit.level || e.level, v = $r.levels.values[d], w = $r.levels.values[t];\n        if (w < v)\n          return;\n        L0(this, {\n          ts: s,\n          methodLevel: t,\n          methodValue: w,\n          transmitLevel: d,\n          transmitValue: $r.levels.values[r.transmit.level || e.level],\n          send: r.transmit.send,\n          val: e.levelVal\n        }, o);\n      }\n    };\n  }(e[t]));\n}\nfunction $0(r, e, t, i) {\n  r._serialize && ia(t, r._serialize, r.serializers, r._stdErrSerialize);\n  const n = t.slice();\n  let s = n[0];\n  const o = {};\n  i && (o.time = i), o.level = $r.levels.values[e];\n  let f = (r._childLevel | 0) + 1;\n  if (f < 1 && (f = 1), s !== null && typeof s == \"object\") {\n    for (; f-- && typeof n[0] == \"object\"; )\n      Object.assign(o, n.shift());\n    s = n.length ? Lf(n.shift(), n) : void 0;\n  } else\n    typeof s == \"string\" && (s = Lf(n.shift(), n));\n  return s !== void 0 && (o.msg = s), o;\n}\nfunction ia(r, e, t, i) {\n  for (const n in r)\n    if (i && r[n] instanceof Error)\n      r[n] = $r.stdSerializers.err(r[n]);\n    else if (typeof r[n] == \"object\" && !Array.isArray(r[n]))\n      for (const s in r[n])\n        e && e.indexOf(s) > -1 && s in t && (r[n][s] = t[s](r[n][s]));\n}\nfunction nn(r, e, t) {\n  return function() {\n    const i = new Array(1 + arguments.length);\n    i[0] = e;\n    for (var n = 1; n < i.length; n++)\n      i[n] = arguments[n - 1];\n    return r[t].apply(this, i);\n  };\n}\nfunction L0(r, e, t) {\n  const i = e.send, n = e.ts, s = e.methodLevel, o = e.methodValue, f = e.val, h = r._logEvent.bindings;\n  ia(\n    t,\n    r._serialize || Object.keys(r.serializers),\n    r.serializers,\n    r._stdErrSerialize === void 0 ? !0 : r._stdErrSerialize\n  ), r._logEvent.ts = n, r._logEvent.messages = t.filter(function(d) {\n    return h.indexOf(d) === -1;\n  }), r._logEvent.level.label = s, r._logEvent.level.value = o, i(s, r._logEvent, f), r._logEvent = ho(h);\n}\nfunction ho(r) {\n  return {\n    ts: 0,\n    messages: [],\n    bindings: r || [],\n    level: { label: \"\", value: 0 }\n  };\n}\nfunction F0(r) {\n  const e = {\n    type: r.constructor.name,\n    msg: r.message,\n    stack: r.stack\n  };\n  for (const t in r)\n    e[t] === void 0 && (e[t] = r[t]);\n  return e;\n}\nfunction q0(r) {\n  return typeof r.timestamp == \"function\" ? r.timestamp : r.timestamp === !1 ? Hh : Vh;\n}\nfunction _s() {\n  return {};\n}\nfunction qa(r) {\n  return r;\n}\nfunction Jn() {\n}\nfunction Hh() {\n  return !1;\n}\nfunction Vh() {\n  return Date.now();\n}\nfunction U0() {\n  return Math.round(Date.now() / 1e3);\n}\nfunction z0() {\n  return new Date(Date.now()).toISOString();\n}\nfunction B0() {\n  function r(e) {\n    return typeof e < \"u\" && e;\n  }\n  try {\n    return typeof globalThis < \"u\" || Object.defineProperty(Object.prototype, \"globalThis\", {\n      get: function() {\n        return delete Object.prototype.globalThis, this.globalThis = this;\n      },\n      configurable: !0\n    }), globalThis;\n  } catch {\n    return r(self) || r(window) || r(this) || {};\n  }\n}\nconst na = /* @__PURE__ */ (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.d)(an), k0 = { level: \"info\" }, ts = \"custom_context\", No = 1e3 * 1024;\nlet j0 = class {\n  constructor(e) {\n    this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;\n  }\n  get value() {\n    return this.nodeValue;\n  }\n  get size() {\n    return this.sizeInBytes;\n  }\n}, Ff = class {\n  constructor(e) {\n    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;\n  }\n  append(e) {\n    const t = new j0(e);\n    if (t.size > this.maxSizeInBytes)\n      throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`);\n    for (; this.size + t.size > this.maxSizeInBytes; )\n      this.shift();\n    this.head ? (this.tail && (this.tail.next = t), this.tail = t) : (this.head = t, this.tail = t), this.lengthInNodes++, this.sizeInBytes += t.size;\n  }\n  shift() {\n    if (!this.head)\n      return;\n    const e = this.head;\n    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;\n  }\n  toArray() {\n    const e = [];\n    let t = this.head;\n    for (; t !== null; )\n      e.push(t.value), t = t.next;\n    return e;\n  }\n  get length() {\n    return this.lengthInNodes;\n  }\n  get size() {\n    return this.sizeInBytes;\n  }\n  toOrderedArray() {\n    return Array.from(this);\n  }\n  [Symbol.iterator]() {\n    let e = this.head;\n    return { next: () => {\n      if (!e)\n        return { done: !0, value: null };\n      const t = e.value;\n      return e = e.next, { done: !1, value: t };\n    } };\n  }\n}, Wh = class {\n  constructor(e, t = No) {\n    this.level = e ?? \"error\", this.levelValue = an.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t, this.logs = new Ff(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n  forwardToConsole(e, t) {\n    t === an.levels.values.error ? console.error(e) : t === an.levels.values.warn ? console.warn(e) : t === an.levels.values.debug ? console.debug(e) : t === an.levels.values.trace ? console.trace(e) : console.log(e);\n  }\n  appendToLogs(e) {\n    this.logs.append(ji({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e }));\n    const t = typeof e == \"string\" ? JSON.parse(e).level : e.level;\n    t >= this.levelValue && this.forwardToConsole(e, t);\n  }\n  getLogs() {\n    return this.logs;\n  }\n  clearLogs() {\n    this.logs = new Ff(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n  getLogArray() {\n    return Array.from(this.logs);\n  }\n  logsToBlob(e) {\n    const t = this.getLogArray();\n    return t.push(ji({ extraMetadata: e })), new Blob(t, { type: \"application/json\" });\n  }\n};\nclass K0 {\n  constructor(e, t = No) {\n    this.baseChunkLogger = new Wh(e, t);\n  }\n  write(e) {\n    this.baseChunkLogger.appendToLogs(e);\n  }\n  getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n  clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n  getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n  logsToBlob(e) {\n    return this.baseChunkLogger.logsToBlob(e);\n  }\n  downloadLogsBlobInBrowser(e) {\n    const t = URL.createObjectURL(this.logsToBlob(e)), i = document.createElement(\"a\");\n    i.href = t, i.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(i), i.click(), document.body.removeChild(i), URL.revokeObjectURL(t);\n  }\n}\nclass H0 {\n  constructor(e, t = No) {\n    this.baseChunkLogger = new Wh(e, t);\n  }\n  write(e) {\n    this.baseChunkLogger.appendToLogs(e);\n  }\n  getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n  clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n  getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n  logsToBlob(e) {\n    return this.baseChunkLogger.logsToBlob(e);\n  }\n}\nvar V0 = Object.defineProperty, W0 = Object.defineProperties, G0 = Object.getOwnPropertyDescriptors, qf = Object.getOwnPropertySymbols, J0 = Object.prototype.hasOwnProperty, Y0 = Object.prototype.propertyIsEnumerable, Uf = (r, e, t) => e in r ? V0(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Ls = (r, e) => {\n  for (var t in e || (e = {}))\n    J0.call(e, t) && Uf(r, t, e[t]);\n  if (qf)\n    for (var t of qf(e))\n      Y0.call(e, t) && Uf(r, t, e[t]);\n  return r;\n}, Fs = (r, e) => W0(r, G0(e));\nfunction To(r) {\n  return Fs(Ls({}, r), { level: r?.level || k0.level });\n}\nfunction X0(r, e = ts) {\n  return r[e] || \"\";\n}\nfunction Z0(r, e, t = ts) {\n  return r[t] = e, r;\n}\nfunction Zt(r, e = ts) {\n  let t = \"\";\n  return typeof r.bindings > \"u\" ? t = X0(r, e) : t = r.bindings().context || \"\", t;\n}\nfunction Q0(r, e, t = ts) {\n  const i = Zt(r, t);\n  return i.trim() ? `${i}/${e}` : e;\n}\nfunction kt(r, e, t = ts) {\n  const i = Q0(r, e, t), n = r.child({ context: i });\n  return Z0(n, i, t);\n}\nfunction ep(r) {\n  var e, t;\n  const i = new K0((e = r.opts) == null ? void 0 : e.level, r.maxSizeInBytes);\n  return { logger: na(Fs(Ls({}, r.opts), { level: \"trace\", browser: Fs(Ls({}, (t = r.opts) == null ? void 0 : t.browser), { write: (n) => i.write(n) }) })), chunkLoggerController: i };\n}\nfunction tp(r) {\n  var e;\n  const t = new H0((e = r.opts) == null ? void 0 : e.level, r.maxSizeInBytes);\n  return { logger: na(Fs(Ls({}, r.opts), { level: \"trace\" }), t), chunkLoggerController: t };\n}\nfunction rp(r) {\n  return typeof r.loggerOverride < \"u\" && typeof r.loggerOverride != \"string\" ? { logger: r.loggerOverride, chunkLoggerController: null } : typeof window < \"u\" ? ep(r) : tp(r);\n}\nlet ip = class extends Wi {\n  constructor(e) {\n    super(), this.opts = e, this.protocol = \"wc\", this.version = 2;\n  }\n}, np = class extends Wi {\n  constructor(e, t) {\n    super(), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map();\n  }\n};\nclass sp {\n  constructor(e, t) {\n    this.logger = e, this.core = t;\n  }\n}\nlet ap = class extends Wi {\n  constructor(e, t) {\n    super(), this.relayer = e, this.logger = t;\n  }\n};\nclass op extends Wi {\n  constructor(e) {\n    super();\n  }\n}\nclass fp {\n  constructor(e, t, i, n) {\n    this.core = e, this.logger = t, this.name = i;\n  }\n}\nlet cp = class extends Wi {\n  constructor(e, t) {\n    super(), this.relayer = e, this.logger = t;\n  }\n}, hp = class extends Wi {\n  constructor(e, t) {\n    super(), this.core = e, this.logger = t;\n  }\n}, up = class {\n  constructor(e, t, i) {\n    this.core = e, this.logger = t, this.store = i;\n  }\n}, dp = class {\n  constructor(e, t) {\n    this.projectId = e, this.logger = t;\n  }\n}, lp = class {\n  constructor(e, t, i) {\n    this.core = e, this.logger = t, this.telemetryEnabled = i;\n  }\n}, pp = class {\n  constructor(e) {\n    this.opts = e, this.protocol = \"wc\", this.version = 2;\n  }\n}, vp = class {\n  constructor(e) {\n    this.client = e;\n  }\n};\nvar Co = {}, Ei = {}, sa = {}, aa = {};\nObject.defineProperty(aa, \"__esModule\", { value: !0 });\naa.BrowserRandomSource = void 0;\nconst zf = 65536;\nclass bp {\n  constructor() {\n    this.isAvailable = !1, this.isInstantiated = !1;\n    const e = typeof self < \"u\" ? self.crypto || self.msCrypto : null;\n    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);\n  }\n  randomBytes(e) {\n    if (!this.isAvailable || !this._crypto)\n      throw new Error(\"Browser random byte generator is not available.\");\n    const t = new Uint8Array(e);\n    for (let i = 0; i < t.length; i += zf)\n      this._crypto.getRandomValues(t.subarray(i, i + Math.min(t.length - i, zf)));\n    return t;\n  }\n}\naa.BrowserRandomSource = bp;\nfunction gp(r) {\n  throw new Error('Could not dynamically require \"' + r + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n}\nvar oa = {}, nr = {};\nObject.defineProperty(nr, \"__esModule\", { value: !0 });\nfunction yp(r) {\n  for (var e = 0; e < r.length; e++)\n    r[e] = 0;\n  return r;\n}\nnr.wipe = yp;\nconst mp = {}, wp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: mp\n}, Symbol.toStringTag, { value: \"Module\" })), fa = /* @__PURE__ */ (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.g)(wp);\nObject.defineProperty(oa, \"__esModule\", { value: !0 });\noa.NodeRandomSource = void 0;\nconst _p = nr;\nclass xp {\n  constructor() {\n    if (this.isAvailable = !1, this.isInstantiated = !1, typeof gp < \"u\") {\n      const e = fa;\n      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);\n    }\n  }\n  randomBytes(e) {\n    if (!this.isAvailable || !this._crypto)\n      throw new Error(\"Node.js random byte generator is not available.\");\n    let t = this._crypto.randomBytes(e);\n    if (t.length !== e)\n      throw new Error(\"NodeRandomSource: got fewer bytes than requested\");\n    const i = new Uint8Array(e);\n    for (let n = 0; n < i.length; n++)\n      i[n] = t[n];\n    return (0, _p.wipe)(t), i;\n  }\n}\noa.NodeRandomSource = xp;\nObject.defineProperty(sa, \"__esModule\", { value: !0 });\nsa.SystemRandomSource = void 0;\nconst Ep = aa, Sp = oa;\nclass Mp {\n  constructor() {\n    if (this.isAvailable = !1, this.name = \"\", this._source = new Ep.BrowserRandomSource(), this._source.isAvailable) {\n      this.isAvailable = !0, this.name = \"Browser\";\n      return;\n    }\n    if (this._source = new Sp.NodeRandomSource(), this._source.isAvailable) {\n      this.isAvailable = !0, this.name = \"Node\";\n      return;\n    }\n  }\n  randomBytes(e) {\n    if (!this.isAvailable)\n      throw new Error(\"System random byte generator is not available.\");\n    return this._source.randomBytes(e);\n  }\n}\nsa.SystemRandomSource = Mp;\nvar Ve = {}, Gh = {};\n(function(r) {\n  Object.defineProperty(r, \"__esModule\", { value: !0 });\n  function e(f, h) {\n    var d = f >>> 16 & 65535, v = f & 65535, w = h >>> 16 & 65535, A = h & 65535;\n    return v * A + (d * A + v * w << 16 >>> 0) | 0;\n  }\n  r.mul = Math.imul || e;\n  function t(f, h) {\n    return f + h | 0;\n  }\n  r.add = t;\n  function i(f, h) {\n    return f - h | 0;\n  }\n  r.sub = i;\n  function n(f, h) {\n    return f << h | f >>> 32 - h;\n  }\n  r.rotl = n;\n  function s(f, h) {\n    return f << 32 - h | f >>> h;\n  }\n  r.rotr = s;\n  function o(f) {\n    return typeof f == \"number\" && isFinite(f) && Math.floor(f) === f;\n  }\n  r.isInteger = Number.isInteger || o, r.MAX_SAFE_INTEGER = 9007199254740991, r.isSafeInteger = function(f) {\n    return r.isInteger(f) && f >= -r.MAX_SAFE_INTEGER && f <= r.MAX_SAFE_INTEGER;\n  };\n})(Gh);\nObject.defineProperty(Ve, \"__esModule\", { value: !0 });\nvar Jh = Gh;\nfunction Ip(r, e) {\n  return e === void 0 && (e = 0), (r[e + 0] << 8 | r[e + 1]) << 16 >> 16;\n}\nVe.readInt16BE = Ip;\nfunction Ap(r, e) {\n  return e === void 0 && (e = 0), (r[e + 0] << 8 | r[e + 1]) >>> 0;\n}\nVe.readUint16BE = Ap;\nfunction Dp(r, e) {\n  return e === void 0 && (e = 0), (r[e + 1] << 8 | r[e]) << 16 >> 16;\n}\nVe.readInt16LE = Dp;\nfunction Pp(r, e) {\n  return e === void 0 && (e = 0), (r[e + 1] << 8 | r[e]) >>> 0;\n}\nVe.readUint16LE = Pp;\nfunction Yh(r, e, t) {\n  return e === void 0 && (e = new Uint8Array(2)), t === void 0 && (t = 0), e[t + 0] = r >>> 8, e[t + 1] = r >>> 0, e;\n}\nVe.writeUint16BE = Yh;\nVe.writeInt16BE = Yh;\nfunction Xh(r, e, t) {\n  return e === void 0 && (e = new Uint8Array(2)), t === void 0 && (t = 0), e[t + 0] = r >>> 0, e[t + 1] = r >>> 8, e;\n}\nVe.writeUint16LE = Xh;\nVe.writeInt16LE = Xh;\nfunction uo(r, e) {\n  return e === void 0 && (e = 0), r[e] << 24 | r[e + 1] << 16 | r[e + 2] << 8 | r[e + 3];\n}\nVe.readInt32BE = uo;\nfunction lo(r, e) {\n  return e === void 0 && (e = 0), (r[e] << 24 | r[e + 1] << 16 | r[e + 2] << 8 | r[e + 3]) >>> 0;\n}\nVe.readUint32BE = lo;\nfunction po(r, e) {\n  return e === void 0 && (e = 0), r[e + 3] << 24 | r[e + 2] << 16 | r[e + 1] << 8 | r[e];\n}\nVe.readInt32LE = po;\nfunction vo(r, e) {\n  return e === void 0 && (e = 0), (r[e + 3] << 24 | r[e + 2] << 16 | r[e + 1] << 8 | r[e]) >>> 0;\n}\nVe.readUint32LE = vo;\nfunction qs(r, e, t) {\n  return e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0), e[t + 0] = r >>> 24, e[t + 1] = r >>> 16, e[t + 2] = r >>> 8, e[t + 3] = r >>> 0, e;\n}\nVe.writeUint32BE = qs;\nVe.writeInt32BE = qs;\nfunction Us(r, e, t) {\n  return e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0), e[t + 0] = r >>> 0, e[t + 1] = r >>> 8, e[t + 2] = r >>> 16, e[t + 3] = r >>> 24, e;\n}\nVe.writeUint32LE = Us;\nVe.writeInt32LE = Us;\nfunction Op(r, e) {\n  e === void 0 && (e = 0);\n  var t = uo(r, e), i = uo(r, e + 4);\n  return t * 4294967296 + i - (i >> 31) * 4294967296;\n}\nVe.readInt64BE = Op;\nfunction Rp(r, e) {\n  e === void 0 && (e = 0);\n  var t = lo(r, e), i = lo(r, e + 4);\n  return t * 4294967296 + i;\n}\nVe.readUint64BE = Rp;\nfunction Np(r, e) {\n  e === void 0 && (e = 0);\n  var t = po(r, e), i = po(r, e + 4);\n  return i * 4294967296 + t - (t >> 31) * 4294967296;\n}\nVe.readInt64LE = Np;\nfunction Tp(r, e) {\n  e === void 0 && (e = 0);\n  var t = vo(r, e), i = vo(r, e + 4);\n  return i * 4294967296 + t;\n}\nVe.readUint64LE = Tp;\nfunction Zh(r, e, t) {\n  return e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0), qs(r / 4294967296 >>> 0, e, t), qs(r >>> 0, e, t + 4), e;\n}\nVe.writeUint64BE = Zh;\nVe.writeInt64BE = Zh;\nfunction Qh(r, e, t) {\n  return e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0), Us(r >>> 0, e, t), Us(r / 4294967296 >>> 0, e, t + 4), e;\n}\nVe.writeUint64LE = Qh;\nVe.writeInt64LE = Qh;\nfunction Cp(r, e, t) {\n  if (t === void 0 && (t = 0), r % 8 !== 0)\n    throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n  if (r / 8 > e.length - t)\n    throw new Error(\"readUintBE: array is too short for the given bitLength\");\n  for (var i = 0, n = 1, s = r / 8 + t - 1; s >= t; s--)\n    i += e[s] * n, n *= 256;\n  return i;\n}\nVe.readUintBE = Cp;\nfunction $p(r, e, t) {\n  if (t === void 0 && (t = 0), r % 8 !== 0)\n    throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n  if (r / 8 > e.length - t)\n    throw new Error(\"readUintLE: array is too short for the given bitLength\");\n  for (var i = 0, n = 1, s = t; s < t + r / 8; s++)\n    i += e[s] * n, n *= 256;\n  return i;\n}\nVe.readUintLE = $p;\nfunction Lp(r, e, t, i) {\n  if (t === void 0 && (t = new Uint8Array(r / 8)), i === void 0 && (i = 0), r % 8 !== 0)\n    throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n  if (!Jh.isSafeInteger(e))\n    throw new Error(\"writeUintBE value must be an integer\");\n  for (var n = 1, s = r / 8 + i - 1; s >= i; s--)\n    t[s] = e / n & 255, n *= 256;\n  return t;\n}\nVe.writeUintBE = Lp;\nfunction Fp(r, e, t, i) {\n  if (t === void 0 && (t = new Uint8Array(r / 8)), i === void 0 && (i = 0), r % 8 !== 0)\n    throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n  if (!Jh.isSafeInteger(e))\n    throw new Error(\"writeUintLE value must be an integer\");\n  for (var n = 1, s = i; s < i + r / 8; s++)\n    t[s] = e / n & 255, n *= 256;\n  return t;\n}\nVe.writeUintLE = Fp;\nfunction qp(r, e) {\n  e === void 0 && (e = 0);\n  var t = new DataView(r.buffer, r.byteOffset, r.byteLength);\n  return t.getFloat32(e);\n}\nVe.readFloat32BE = qp;\nfunction Up(r, e) {\n  e === void 0 && (e = 0);\n  var t = new DataView(r.buffer, r.byteOffset, r.byteLength);\n  return t.getFloat32(e, !0);\n}\nVe.readFloat32LE = Up;\nfunction zp(r, e) {\n  e === void 0 && (e = 0);\n  var t = new DataView(r.buffer, r.byteOffset, r.byteLength);\n  return t.getFloat64(e);\n}\nVe.readFloat64BE = zp;\nfunction Bp(r, e) {\n  e === void 0 && (e = 0);\n  var t = new DataView(r.buffer, r.byteOffset, r.byteLength);\n  return t.getFloat64(e, !0);\n}\nVe.readFloat64LE = Bp;\nfunction kp(r, e, t) {\n  e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0);\n  var i = new DataView(e.buffer, e.byteOffset, e.byteLength);\n  return i.setFloat32(t, r), e;\n}\nVe.writeFloat32BE = kp;\nfunction jp(r, e, t) {\n  e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0);\n  var i = new DataView(e.buffer, e.byteOffset, e.byteLength);\n  return i.setFloat32(t, r, !0), e;\n}\nVe.writeFloat32LE = jp;\nfunction Kp(r, e, t) {\n  e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0);\n  var i = new DataView(e.buffer, e.byteOffset, e.byteLength);\n  return i.setFloat64(t, r), e;\n}\nVe.writeFloat64BE = Kp;\nfunction Hp(r, e, t) {\n  e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0);\n  var i = new DataView(e.buffer, e.byteOffset, e.byteLength);\n  return i.setFloat64(t, r, !0), e;\n}\nVe.writeFloat64LE = Hp;\n(function(r) {\n  Object.defineProperty(r, \"__esModule\", { value: !0 }), r.randomStringForEntropy = r.randomString = r.randomUint32 = r.randomBytes = r.defaultRandomSource = void 0;\n  const e = sa, t = Ve, i = nr;\n  r.defaultRandomSource = new e.SystemRandomSource();\n  function n(d, v = r.defaultRandomSource) {\n    return v.randomBytes(d);\n  }\n  r.randomBytes = n;\n  function s(d = r.defaultRandomSource) {\n    const v = n(4, d), w = (0, t.readUint32LE)(v);\n    return (0, i.wipe)(v), w;\n  }\n  r.randomUint32 = s;\n  const o = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  function f(d, v = o, w = r.defaultRandomSource) {\n    if (v.length < 2)\n      throw new Error(\"randomString charset is too short\");\n    if (v.length > 256)\n      throw new Error(\"randomString charset is too long\");\n    let A = \"\";\n    const I = v.length, D = 256 - 256 % I;\n    for (; d > 0; ) {\n      const N = n(Math.ceil(d * 256 / D), w);\n      for (let k = 0; k < N.length && d > 0; k++) {\n        const j = N[k];\n        j < D && (A += v.charAt(j % I), d--);\n      }\n      (0, i.wipe)(N);\n    }\n    return A;\n  }\n  r.randomString = f;\n  function h(d, v = o, w = r.defaultRandomSource) {\n    const A = Math.ceil(d / (Math.log(v.length) / Math.LN2));\n    return f(A, v, w);\n  }\n  r.randomStringForEntropy = h;\n})(Ei);\nvar eu = {};\n(function(r) {\n  Object.defineProperty(r, \"__esModule\", { value: !0 });\n  var e = Ve, t = nr;\n  r.DIGEST_LENGTH = 64, r.BLOCK_SIZE = 128;\n  var i = (\n    /** @class */\n    function() {\n      function f() {\n        this.digestLength = r.DIGEST_LENGTH, this.blockSize = r.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();\n      }\n      return f.prototype._initState = function() {\n        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;\n      }, f.prototype.reset = function() {\n        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;\n      }, f.prototype.clean = function() {\n        t.wipe(this._buffer), t.wipe(this._tempHi), t.wipe(this._tempLo), this.reset();\n      }, f.prototype.update = function(h, d) {\n        if (d === void 0 && (d = h.length), this._finished)\n          throw new Error(\"SHA512: can't update because hash was finished.\");\n        var v = 0;\n        if (this._bytesHashed += d, this._bufferLength > 0) {\n          for (; this._bufferLength < r.BLOCK_SIZE && d > 0; )\n            this._buffer[this._bufferLength++] = h[v++], d--;\n          this._bufferLength === this.blockSize && (s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);\n        }\n        for (d >= this.blockSize && (v = s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, h, v, d), d %= this.blockSize); d > 0; )\n          this._buffer[this._bufferLength++] = h[v++], d--;\n        return this;\n      }, f.prototype.finish = function(h) {\n        if (!this._finished) {\n          var d = this._bytesHashed, v = this._bufferLength, w = d / 536870912 | 0, A = d << 3, I = d % 128 < 112 ? 128 : 256;\n          this._buffer[v] = 128;\n          for (var D = v + 1; D < I - 8; D++)\n            this._buffer[D] = 0;\n          e.writeUint32BE(w, this._buffer, I - 8), e.writeUint32BE(A, this._buffer, I - 4), s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, I), this._finished = !0;\n        }\n        for (var D = 0; D < this.digestLength / 8; D++)\n          e.writeUint32BE(this._stateHi[D], h, D * 8), e.writeUint32BE(this._stateLo[D], h, D * 8 + 4);\n        return this;\n      }, f.prototype.digest = function() {\n        var h = new Uint8Array(this.digestLength);\n        return this.finish(h), h;\n      }, f.prototype.saveState = function() {\n        if (this._finished)\n          throw new Error(\"SHA256: cannot save finished state\");\n        return {\n          stateHi: new Int32Array(this._stateHi),\n          stateLo: new Int32Array(this._stateLo),\n          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,\n          bufferLength: this._bufferLength,\n          bytesHashed: this._bytesHashed\n        };\n      }, f.prototype.restoreState = function(h) {\n        return this._stateHi.set(h.stateHi), this._stateLo.set(h.stateLo), this._bufferLength = h.bufferLength, h.buffer && this._buffer.set(h.buffer), this._bytesHashed = h.bytesHashed, this._finished = !1, this;\n      }, f.prototype.cleanSavedState = function(h) {\n        t.wipe(h.stateHi), t.wipe(h.stateLo), h.buffer && t.wipe(h.buffer), h.bufferLength = 0, h.bytesHashed = 0;\n      }, f;\n    }()\n  );\n  r.SHA512 = i;\n  var n = new Int32Array([\n    1116352408,\n    3609767458,\n    1899447441,\n    602891725,\n    3049323471,\n    3964484399,\n    3921009573,\n    2173295548,\n    961987163,\n    4081628472,\n    1508970993,\n    3053834265,\n    2453635748,\n    2937671579,\n    2870763221,\n    3664609560,\n    3624381080,\n    2734883394,\n    310598401,\n    1164996542,\n    607225278,\n    1323610764,\n    1426881987,\n    3590304994,\n    1925078388,\n    4068182383,\n    2162078206,\n    991336113,\n    2614888103,\n    633803317,\n    3248222580,\n    3479774868,\n    3835390401,\n    2666613458,\n    4022224774,\n    944711139,\n    264347078,\n    2341262773,\n    604807628,\n    2007800933,\n    770255983,\n    1495990901,\n    1249150122,\n    1856431235,\n    1555081692,\n    3175218132,\n    1996064986,\n    2198950837,\n    2554220882,\n    3999719339,\n    2821834349,\n    766784016,\n    2952996808,\n    2566594879,\n    3210313671,\n    3203337956,\n    3336571891,\n    1034457026,\n    3584528711,\n    2466948901,\n    113926993,\n    3758326383,\n    338241895,\n    168717936,\n    666307205,\n    1188179964,\n    773529912,\n    1546045734,\n    1294757372,\n    1522805485,\n    1396182291,\n    2643833823,\n    1695183700,\n    2343527390,\n    1986661051,\n    1014477480,\n    2177026350,\n    1206759142,\n    2456956037,\n    344077627,\n    2730485921,\n    1290863460,\n    2820302411,\n    3158454273,\n    3259730800,\n    3505952657,\n    3345764771,\n    106217008,\n    3516065817,\n    3606008344,\n    3600352804,\n    1432725776,\n    4094571909,\n    1467031594,\n    275423344,\n    851169720,\n    430227734,\n    3100823752,\n    506948616,\n    1363258195,\n    659060556,\n    3750685593,\n    883997877,\n    3785050280,\n    958139571,\n    3318307427,\n    1322822218,\n    3812723403,\n    1537002063,\n    2003034995,\n    1747873779,\n    3602036899,\n    1955562222,\n    1575990012,\n    2024104815,\n    1125592928,\n    2227730452,\n    2716904306,\n    2361852424,\n    442776044,\n    2428436474,\n    593698344,\n    2756734187,\n    3733110249,\n    3204031479,\n    2999351573,\n    3329325298,\n    3815920427,\n    3391569614,\n    3928383900,\n    3515267271,\n    566280711,\n    3940187606,\n    3454069534,\n    4118630271,\n    4000239992,\n    116418474,\n    1914138554,\n    174292421,\n    2731055270,\n    289380356,\n    3203993006,\n    460393269,\n    320620315,\n    685471733,\n    587496836,\n    852142971,\n    1086792851,\n    1017036298,\n    365543100,\n    1126000580,\n    2618297676,\n    1288033470,\n    3409855158,\n    1501505948,\n    4234509866,\n    1607167915,\n    987167468,\n    1816402316,\n    1246189591\n  ]);\n  function s(f, h, d, v, w, A, I) {\n    for (var D = d[0], N = d[1], k = d[2], j = d[3], T = d[4], K = d[5], $ = d[6], z = d[7], B = v[0], _ = v[1], R = v[2], J = v[3], Q = v[4], O = v[5], p = v[6], l = v[7], a, c, b, E, S, x, u, m; I >= 128; ) {\n      for (var g = 0; g < 16; g++) {\n        var P = 8 * g + A;\n        f[g] = e.readUint32BE(w, P), h[g] = e.readUint32BE(w, P + 4);\n      }\n      for (var g = 0; g < 80; g++) {\n        var G = D, M = N, H = k, C = j, q = T, L = K, y = $, F = z, W = B, Y = _, X = R, ee = J, we = Q, Me = O, he = p, Re = l;\n        if (a = z, c = l, S = c & 65535, x = c >>> 16, u = a & 65535, m = a >>> 16, a = (T >>> 14 | Q << 32 - 14) ^ (T >>> 18 | Q << 32 - 18) ^ (Q >>> 41 - 32 | T << 32 - (41 - 32)), c = (Q >>> 14 | T << 32 - 14) ^ (Q >>> 18 | T << 32 - 18) ^ (T >>> 41 - 32 | Q << 32 - (41 - 32)), S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, a = T & K ^ ~T & $, c = Q & O ^ ~Q & p, S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, a = n[g * 2], c = n[g * 2 + 1], S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, a = f[g % 16], c = h[g % 16], S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, x += S >>> 16, u += x >>> 16, m += u >>> 16, b = u & 65535 | m << 16, E = S & 65535 | x << 16, a = b, c = E, S = c & 65535, x = c >>> 16, u = a & 65535, m = a >>> 16, a = (D >>> 28 | B << 32 - 28) ^ (B >>> 34 - 32 | D << 32 - (34 - 32)) ^ (B >>> 39 - 32 | D << 32 - (39 - 32)), c = (B >>> 28 | D << 32 - 28) ^ (D >>> 34 - 32 | B << 32 - (34 - 32)) ^ (D >>> 39 - 32 | B << 32 - (39 - 32)), S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, a = D & N ^ D & k ^ N & k, c = B & _ ^ B & R ^ _ & R, S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, x += S >>> 16, u += x >>> 16, m += u >>> 16, F = u & 65535 | m << 16, Re = S & 65535 | x << 16, a = C, c = ee, S = c & 65535, x = c >>> 16, u = a & 65535, m = a >>> 16, a = b, c = E, S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, x += S >>> 16, u += x >>> 16, m += u >>> 16, C = u & 65535 | m << 16, ee = S & 65535 | x << 16, N = G, k = M, j = H, T = C, K = q, $ = L, z = y, D = F, _ = W, R = Y, J = X, Q = ee, O = we, p = Me, l = he, B = Re, g % 16 === 15)\n          for (var P = 0; P < 16; P++)\n            a = f[P], c = h[P], S = c & 65535, x = c >>> 16, u = a & 65535, m = a >>> 16, a = f[(P + 9) % 16], c = h[(P + 9) % 16], S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, b = f[(P + 1) % 16], E = h[(P + 1) % 16], a = (b >>> 1 | E << 32 - 1) ^ (b >>> 8 | E << 32 - 8) ^ b >>> 7, c = (E >>> 1 | b << 32 - 1) ^ (E >>> 8 | b << 32 - 8) ^ (E >>> 7 | b << 32 - 7), S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, b = f[(P + 14) % 16], E = h[(P + 14) % 16], a = (b >>> 19 | E << 32 - 19) ^ (E >>> 61 - 32 | b << 32 - (61 - 32)) ^ b >>> 6, c = (E >>> 19 | b << 32 - 19) ^ (b >>> 61 - 32 | E << 32 - (61 - 32)) ^ (E >>> 6 | b << 32 - 6), S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, x += S >>> 16, u += x >>> 16, m += u >>> 16, f[P] = u & 65535 | m << 16, h[P] = S & 65535 | x << 16;\n      }\n      a = D, c = B, S = c & 65535, x = c >>> 16, u = a & 65535, m = a >>> 16, a = d[0], c = v[0], S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, x += S >>> 16, u += x >>> 16, m += u >>> 16, d[0] = D = u & 65535 | m << 16, v[0] = B = S & 65535 | x << 16, a = N, c = _, S = c & 65535, x = c >>> 16, u = a & 65535, m = a >>> 16, a = d[1], c = v[1], S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, x += S >>> 16, u += x >>> 16, m += u >>> 16, d[1] = N = u & 65535 | m << 16, v[1] = _ = S & 65535 | x << 16, a = k, c = R, S = c & 65535, x = c >>> 16, u = a & 65535, m = a >>> 16, a = d[2], c = v[2], S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, x += S >>> 16, u += x >>> 16, m += u >>> 16, d[2] = k = u & 65535 | m << 16, v[2] = R = S & 65535 | x << 16, a = j, c = J, S = c & 65535, x = c >>> 16, u = a & 65535, m = a >>> 16, a = d[3], c = v[3], S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, x += S >>> 16, u += x >>> 16, m += u >>> 16, d[3] = j = u & 65535 | m << 16, v[3] = J = S & 65535 | x << 16, a = T, c = Q, S = c & 65535, x = c >>> 16, u = a & 65535, m = a >>> 16, a = d[4], c = v[4], S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, x += S >>> 16, u += x >>> 16, m += u >>> 16, d[4] = T = u & 65535 | m << 16, v[4] = Q = S & 65535 | x << 16, a = K, c = O, S = c & 65535, x = c >>> 16, u = a & 65535, m = a >>> 16, a = d[5], c = v[5], S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, x += S >>> 16, u += x >>> 16, m += u >>> 16, d[5] = K = u & 65535 | m << 16, v[5] = O = S & 65535 | x << 16, a = $, c = p, S = c & 65535, x = c >>> 16, u = a & 65535, m = a >>> 16, a = d[6], c = v[6], S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, x += S >>> 16, u += x >>> 16, m += u >>> 16, d[6] = $ = u & 65535 | m << 16, v[6] = p = S & 65535 | x << 16, a = z, c = l, S = c & 65535, x = c >>> 16, u = a & 65535, m = a >>> 16, a = d[7], c = v[7], S += c & 65535, x += c >>> 16, u += a & 65535, m += a >>> 16, x += S >>> 16, u += x >>> 16, m += u >>> 16, d[7] = z = u & 65535 | m << 16, v[7] = l = S & 65535 | x << 16, A += 128, I -= 128;\n    }\n    return A;\n  }\n  function o(f) {\n    var h = new i();\n    h.update(f);\n    var d = h.digest();\n    return h.clean(), d;\n  }\n  r.hash = o;\n})(eu);\n(function(r) {\n  Object.defineProperty(r, \"__esModule\", { value: !0 }), r.convertSecretKeyToX25519 = r.convertPublicKeyToX25519 = r.verify = r.sign = r.extractPublicKeyFromSecretKey = r.generateKeyPair = r.generateKeyPairFromSeed = r.SEED_LENGTH = r.SECRET_KEY_LENGTH = r.PUBLIC_KEY_LENGTH = r.SIGNATURE_LENGTH = void 0;\n  const e = Ei, t = eu, i = nr;\n  r.SIGNATURE_LENGTH = 64, r.PUBLIC_KEY_LENGTH = 32, r.SECRET_KEY_LENGTH = 64, r.SEED_LENGTH = 32;\n  function n(C) {\n    const q = new Float64Array(16);\n    if (C)\n      for (let L = 0; L < C.length; L++)\n        q[L] = C[L];\n    return q;\n  }\n  const s = new Uint8Array(32);\n  s[0] = 9;\n  const o = n(), f = n([1]), h = n([\n    30883,\n    4953,\n    19914,\n    30187,\n    55467,\n    16705,\n    2637,\n    112,\n    59544,\n    30585,\n    16505,\n    36039,\n    65139,\n    11119,\n    27886,\n    20995\n  ]), d = n([\n    61785,\n    9906,\n    39828,\n    60374,\n    45398,\n    33411,\n    5274,\n    224,\n    53552,\n    61171,\n    33010,\n    6542,\n    64743,\n    22239,\n    55772,\n    9222\n  ]), v = n([\n    54554,\n    36645,\n    11616,\n    51542,\n    42930,\n    38181,\n    51040,\n    26924,\n    56412,\n    64982,\n    57905,\n    49316,\n    21502,\n    52590,\n    14035,\n    8553\n  ]), w = n([\n    26200,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214\n  ]), A = n([\n    41136,\n    18958,\n    6951,\n    50414,\n    58488,\n    44335,\n    6150,\n    12099,\n    55207,\n    15867,\n    153,\n    11085,\n    57099,\n    20417,\n    9344,\n    11139\n  ]);\n  function I(C, q) {\n    for (let L = 0; L < 16; L++)\n      C[L] = q[L] | 0;\n  }\n  function D(C) {\n    let q = 1;\n    for (let L = 0; L < 16; L++) {\n      let y = C[L] + q + 65535;\n      q = Math.floor(y / 65536), C[L] = y - q * 65536;\n    }\n    C[0] += q - 1 + 37 * (q - 1);\n  }\n  function N(C, q, L) {\n    const y = ~(L - 1);\n    for (let F = 0; F < 16; F++) {\n      const W = y & (C[F] ^ q[F]);\n      C[F] ^= W, q[F] ^= W;\n    }\n  }\n  function k(C, q) {\n    const L = n(), y = n();\n    for (let F = 0; F < 16; F++)\n      y[F] = q[F];\n    D(y), D(y), D(y);\n    for (let F = 0; F < 2; F++) {\n      L[0] = y[0] - 65517;\n      for (let Y = 1; Y < 15; Y++)\n        L[Y] = y[Y] - 65535 - (L[Y - 1] >> 16 & 1), L[Y - 1] &= 65535;\n      L[15] = y[15] - 32767 - (L[14] >> 16 & 1);\n      const W = L[15] >> 16 & 1;\n      L[14] &= 65535, N(y, L, 1 - W);\n    }\n    for (let F = 0; F < 16; F++)\n      C[2 * F] = y[F] & 255, C[2 * F + 1] = y[F] >> 8;\n  }\n  function j(C, q) {\n    let L = 0;\n    for (let y = 0; y < 32; y++)\n      L |= C[y] ^ q[y];\n    return (1 & L - 1 >>> 8) - 1;\n  }\n  function T(C, q) {\n    const L = new Uint8Array(32), y = new Uint8Array(32);\n    return k(L, C), k(y, q), j(L, y);\n  }\n  function K(C) {\n    const q = new Uint8Array(32);\n    return k(q, C), q[0] & 1;\n  }\n  function $(C, q) {\n    for (let L = 0; L < 16; L++)\n      C[L] = q[2 * L] + (q[2 * L + 1] << 8);\n    C[15] &= 32767;\n  }\n  function z(C, q, L) {\n    for (let y = 0; y < 16; y++)\n      C[y] = q[y] + L[y];\n  }\n  function B(C, q, L) {\n    for (let y = 0; y < 16; y++)\n      C[y] = q[y] - L[y];\n  }\n  function _(C, q, L) {\n    let y, F, W = 0, Y = 0, X = 0, ee = 0, we = 0, Me = 0, he = 0, Re = 0, xe = 0, se = 0, ge = 0, le = 0, ne = 0, ue = 0, fe = 0, te = 0, pe = 0, _e = 0, re = 0, Ee = 0, Se = 0, oe = 0, De = 0, Ie = 0, Pe = 0, Ge = 0, Ye = 0, Ae = 0, Ze = 0, et = 0, Ne = 0, Ce = L[0], Te = L[1], de = L[2], $e = L[3], Le = L[4], ce = L[5], Ue = L[6], ze = L[7], ye = L[8], Be = L[9], ke = L[10], ve = L[11], Fe = L[12], Oe = L[13], me = L[14], je = L[15];\n    y = q[0], W += y * Ce, Y += y * Te, X += y * de, ee += y * $e, we += y * Le, Me += y * ce, he += y * Ue, Re += y * ze, xe += y * ye, se += y * Be, ge += y * ke, le += y * ve, ne += y * Fe, ue += y * Oe, fe += y * me, te += y * je, y = q[1], Y += y * Ce, X += y * Te, ee += y * de, we += y * $e, Me += y * Le, he += y * ce, Re += y * Ue, xe += y * ze, se += y * ye, ge += y * Be, le += y * ke, ne += y * ve, ue += y * Fe, fe += y * Oe, te += y * me, pe += y * je, y = q[2], X += y * Ce, ee += y * Te, we += y * de, Me += y * $e, he += y * Le, Re += y * ce, xe += y * Ue, se += y * ze, ge += y * ye, le += y * Be, ne += y * ke, ue += y * ve, fe += y * Fe, te += y * Oe, pe += y * me, _e += y * je, y = q[3], ee += y * Ce, we += y * Te, Me += y * de, he += y * $e, Re += y * Le, xe += y * ce, se += y * Ue, ge += y * ze, le += y * ye, ne += y * Be, ue += y * ke, fe += y * ve, te += y * Fe, pe += y * Oe, _e += y * me, re += y * je, y = q[4], we += y * Ce, Me += y * Te, he += y * de, Re += y * $e, xe += y * Le, se += y * ce, ge += y * Ue, le += y * ze, ne += y * ye, ue += y * Be, fe += y * ke, te += y * ve, pe += y * Fe, _e += y * Oe, re += y * me, Ee += y * je, y = q[5], Me += y * Ce, he += y * Te, Re += y * de, xe += y * $e, se += y * Le, ge += y * ce, le += y * Ue, ne += y * ze, ue += y * ye, fe += y * Be, te += y * ke, pe += y * ve, _e += y * Fe, re += y * Oe, Ee += y * me, Se += y * je, y = q[6], he += y * Ce, Re += y * Te, xe += y * de, se += y * $e, ge += y * Le, le += y * ce, ne += y * Ue, ue += y * ze, fe += y * ye, te += y * Be, pe += y * ke, _e += y * ve, re += y * Fe, Ee += y * Oe, Se += y * me, oe += y * je, y = q[7], Re += y * Ce, xe += y * Te, se += y * de, ge += y * $e, le += y * Le, ne += y * ce, ue += y * Ue, fe += y * ze, te += y * ye, pe += y * Be, _e += y * ke, re += y * ve, Ee += y * Fe, Se += y * Oe, oe += y * me, De += y * je, y = q[8], xe += y * Ce, se += y * Te, ge += y * de, le += y * $e, ne += y * Le, ue += y * ce, fe += y * Ue, te += y * ze, pe += y * ye, _e += y * Be, re += y * ke, Ee += y * ve, Se += y * Fe, oe += y * Oe, De += y * me, Ie += y * je, y = q[9], se += y * Ce, ge += y * Te, le += y * de, ne += y * $e, ue += y * Le, fe += y * ce, te += y * Ue, pe += y * ze, _e += y * ye, re += y * Be, Ee += y * ke, Se += y * ve, oe += y * Fe, De += y * Oe, Ie += y * me, Pe += y * je, y = q[10], ge += y * Ce, le += y * Te, ne += y * de, ue += y * $e, fe += y * Le, te += y * ce, pe += y * Ue, _e += y * ze, re += y * ye, Ee += y * Be, Se += y * ke, oe += y * ve, De += y * Fe, Ie += y * Oe, Pe += y * me, Ge += y * je, y = q[11], le += y * Ce, ne += y * Te, ue += y * de, fe += y * $e, te += y * Le, pe += y * ce, _e += y * Ue, re += y * ze, Ee += y * ye, Se += y * Be, oe += y * ke, De += y * ve, Ie += y * Fe, Pe += y * Oe, Ge += y * me, Ye += y * je, y = q[12], ne += y * Ce, ue += y * Te, fe += y * de, te += y * $e, pe += y * Le, _e += y * ce, re += y * Ue, Ee += y * ze, Se += y * ye, oe += y * Be, De += y * ke, Ie += y * ve, Pe += y * Fe, Ge += y * Oe, Ye += y * me, Ae += y * je, y = q[13], ue += y * Ce, fe += y * Te, te += y * de, pe += y * $e, _e += y * Le, re += y * ce, Ee += y * Ue, Se += y * ze, oe += y * ye, De += y * Be, Ie += y * ke, Pe += y * ve, Ge += y * Fe, Ye += y * Oe, Ae += y * me, Ze += y * je, y = q[14], fe += y * Ce, te += y * Te, pe += y * de, _e += y * $e, re += y * Le, Ee += y * ce, Se += y * Ue, oe += y * ze, De += y * ye, Ie += y * Be, Pe += y * ke, Ge += y * ve, Ye += y * Fe, Ae += y * Oe, Ze += y * me, et += y * je, y = q[15], te += y * Ce, pe += y * Te, _e += y * de, re += y * $e, Ee += y * Le, Se += y * ce, oe += y * Ue, De += y * ze, Ie += y * ye, Pe += y * Be, Ge += y * ke, Ye += y * ve, Ae += y * Fe, Ze += y * Oe, et += y * me, Ne += y * je, W += 38 * pe, Y += 38 * _e, X += 38 * re, ee += 38 * Ee, we += 38 * Se, Me += 38 * oe, he += 38 * De, Re += 38 * Ie, xe += 38 * Pe, se += 38 * Ge, ge += 38 * Ye, le += 38 * Ae, ne += 38 * Ze, ue += 38 * et, fe += 38 * Ne, F = 1, y = W + F + 65535, F = Math.floor(y / 65536), W = y - F * 65536, y = Y + F + 65535, F = Math.floor(y / 65536), Y = y - F * 65536, y = X + F + 65535, F = Math.floor(y / 65536), X = y - F * 65536, y = ee + F + 65535, F = Math.floor(y / 65536), ee = y - F * 65536, y = we + F + 65535, F = Math.floor(y / 65536), we = y - F * 65536, y = Me + F + 65535, F = Math.floor(y / 65536), Me = y - F * 65536, y = he + F + 65535, F = Math.floor(y / 65536), he = y - F * 65536, y = Re + F + 65535, F = Math.floor(y / 65536), Re = y - F * 65536, y = xe + F + 65535, F = Math.floor(y / 65536), xe = y - F * 65536, y = se + F + 65535, F = Math.floor(y / 65536), se = y - F * 65536, y = ge + F + 65535, F = Math.floor(y / 65536), ge = y - F * 65536, y = le + F + 65535, F = Math.floor(y / 65536), le = y - F * 65536, y = ne + F + 65535, F = Math.floor(y / 65536), ne = y - F * 65536, y = ue + F + 65535, F = Math.floor(y / 65536), ue = y - F * 65536, y = fe + F + 65535, F = Math.floor(y / 65536), fe = y - F * 65536, y = te + F + 65535, F = Math.floor(y / 65536), te = y - F * 65536, W += F - 1 + 37 * (F - 1), F = 1, y = W + F + 65535, F = Math.floor(y / 65536), W = y - F * 65536, y = Y + F + 65535, F = Math.floor(y / 65536), Y = y - F * 65536, y = X + F + 65535, F = Math.floor(y / 65536), X = y - F * 65536, y = ee + F + 65535, F = Math.floor(y / 65536), ee = y - F * 65536, y = we + F + 65535, F = Math.floor(y / 65536), we = y - F * 65536, y = Me + F + 65535, F = Math.floor(y / 65536), Me = y - F * 65536, y = he + F + 65535, F = Math.floor(y / 65536), he = y - F * 65536, y = Re + F + 65535, F = Math.floor(y / 65536), Re = y - F * 65536, y = xe + F + 65535, F = Math.floor(y / 65536), xe = y - F * 65536, y = se + F + 65535, F = Math.floor(y / 65536), se = y - F * 65536, y = ge + F + 65535, F = Math.floor(y / 65536), ge = y - F * 65536, y = le + F + 65535, F = Math.floor(y / 65536), le = y - F * 65536, y = ne + F + 65535, F = Math.floor(y / 65536), ne = y - F * 65536, y = ue + F + 65535, F = Math.floor(y / 65536), ue = y - F * 65536, y = fe + F + 65535, F = Math.floor(y / 65536), fe = y - F * 65536, y = te + F + 65535, F = Math.floor(y / 65536), te = y - F * 65536, W += F - 1 + 37 * (F - 1), C[0] = W, C[1] = Y, C[2] = X, C[3] = ee, C[4] = we, C[5] = Me, C[6] = he, C[7] = Re, C[8] = xe, C[9] = se, C[10] = ge, C[11] = le, C[12] = ne, C[13] = ue, C[14] = fe, C[15] = te;\n  }\n  function R(C, q) {\n    _(C, q, q);\n  }\n  function J(C, q) {\n    const L = n();\n    let y;\n    for (y = 0; y < 16; y++)\n      L[y] = q[y];\n    for (y = 253; y >= 0; y--)\n      R(L, L), y !== 2 && y !== 4 && _(L, L, q);\n    for (y = 0; y < 16; y++)\n      C[y] = L[y];\n  }\n  function Q(C, q) {\n    const L = n();\n    let y;\n    for (y = 0; y < 16; y++)\n      L[y] = q[y];\n    for (y = 250; y >= 0; y--)\n      R(L, L), y !== 1 && _(L, L, q);\n    for (y = 0; y < 16; y++)\n      C[y] = L[y];\n  }\n  function O(C, q) {\n    const L = n(), y = n(), F = n(), W = n(), Y = n(), X = n(), ee = n(), we = n(), Me = n();\n    B(L, C[1], C[0]), B(Me, q[1], q[0]), _(L, L, Me), z(y, C[0], C[1]), z(Me, q[0], q[1]), _(y, y, Me), _(F, C[3], q[3]), _(F, F, d), _(W, C[2], q[2]), z(W, W, W), B(Y, y, L), B(X, W, F), z(ee, W, F), z(we, y, L), _(C[0], Y, X), _(C[1], we, ee), _(C[2], ee, X), _(C[3], Y, we);\n  }\n  function p(C, q, L) {\n    for (let y = 0; y < 4; y++)\n      N(C[y], q[y], L);\n  }\n  function l(C, q) {\n    const L = n(), y = n(), F = n();\n    J(F, q[2]), _(L, q[0], F), _(y, q[1], F), k(C, y), C[31] ^= K(L) << 7;\n  }\n  function a(C, q, L) {\n    I(C[0], o), I(C[1], f), I(C[2], f), I(C[3], o);\n    for (let y = 255; y >= 0; --y) {\n      const F = L[y / 8 | 0] >> (y & 7) & 1;\n      p(C, q, F), O(q, C), O(C, C), p(C, q, F);\n    }\n  }\n  function c(C, q) {\n    const L = [n(), n(), n(), n()];\n    I(L[0], v), I(L[1], w), I(L[2], f), _(L[3], v, w), a(C, L, q);\n  }\n  function b(C) {\n    if (C.length !== r.SEED_LENGTH)\n      throw new Error(`ed25519: seed must be ${r.SEED_LENGTH} bytes`);\n    const q = (0, t.hash)(C);\n    q[0] &= 248, q[31] &= 127, q[31] |= 64;\n    const L = new Uint8Array(32), y = [n(), n(), n(), n()];\n    c(y, q), l(L, y);\n    const F = new Uint8Array(64);\n    return F.set(C), F.set(L, 32), {\n      publicKey: L,\n      secretKey: F\n    };\n  }\n  r.generateKeyPairFromSeed = b;\n  function E(C) {\n    const q = (0, e.randomBytes)(32, C), L = b(q);\n    return (0, i.wipe)(q), L;\n  }\n  r.generateKeyPair = E;\n  function S(C) {\n    if (C.length !== r.SECRET_KEY_LENGTH)\n      throw new Error(`ed25519: secret key must be ${r.SECRET_KEY_LENGTH} bytes`);\n    return new Uint8Array(C.subarray(32));\n  }\n  r.extractPublicKeyFromSecretKey = S;\n  const x = new Float64Array([\n    237,\n    211,\n    245,\n    92,\n    26,\n    99,\n    18,\n    88,\n    214,\n    156,\n    247,\n    162,\n    222,\n    249,\n    222,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    16\n  ]);\n  function u(C, q) {\n    let L, y, F, W;\n    for (y = 63; y >= 32; --y) {\n      for (L = 0, F = y - 32, W = y - 12; F < W; ++F)\n        q[F] += L - 16 * q[y] * x[F - (y - 32)], L = Math.floor((q[F] + 128) / 256), q[F] -= L * 256;\n      q[F] += L, q[y] = 0;\n    }\n    for (L = 0, F = 0; F < 32; F++)\n      q[F] += L - (q[31] >> 4) * x[F], L = q[F] >> 8, q[F] &= 255;\n    for (F = 0; F < 32; F++)\n      q[F] -= L * x[F];\n    for (y = 0; y < 32; y++)\n      q[y + 1] += q[y] >> 8, C[y] = q[y] & 255;\n  }\n  function m(C) {\n    const q = new Float64Array(64);\n    for (let L = 0; L < 64; L++)\n      q[L] = C[L];\n    for (let L = 0; L < 64; L++)\n      C[L] = 0;\n    u(C, q);\n  }\n  function g(C, q) {\n    const L = new Float64Array(64), y = [n(), n(), n(), n()], F = (0, t.hash)(C.subarray(0, 32));\n    F[0] &= 248, F[31] &= 127, F[31] |= 64;\n    const W = new Uint8Array(64);\n    W.set(F.subarray(32), 32);\n    const Y = new t.SHA512();\n    Y.update(W.subarray(32)), Y.update(q);\n    const X = Y.digest();\n    Y.clean(), m(X), c(y, X), l(W, y), Y.reset(), Y.update(W.subarray(0, 32)), Y.update(C.subarray(32)), Y.update(q);\n    const ee = Y.digest();\n    m(ee);\n    for (let we = 0; we < 32; we++)\n      L[we] = X[we];\n    for (let we = 0; we < 32; we++)\n      for (let Me = 0; Me < 32; Me++)\n        L[we + Me] += ee[we] * F[Me];\n    return u(W.subarray(32), L), W;\n  }\n  r.sign = g;\n  function P(C, q) {\n    const L = n(), y = n(), F = n(), W = n(), Y = n(), X = n(), ee = n();\n    return I(C[2], f), $(C[1], q), R(F, C[1]), _(W, F, h), B(F, F, C[2]), z(W, C[2], W), R(Y, W), R(X, Y), _(ee, X, Y), _(L, ee, F), _(L, L, W), Q(L, L), _(L, L, F), _(L, L, W), _(L, L, W), _(C[0], L, W), R(y, C[0]), _(y, y, W), T(y, F) && _(C[0], C[0], A), R(y, C[0]), _(y, y, W), T(y, F) ? -1 : (K(C[0]) === q[31] >> 7 && B(C[0], o, C[0]), _(C[3], C[0], C[1]), 0);\n  }\n  function G(C, q, L) {\n    const y = new Uint8Array(32), F = [n(), n(), n(), n()], W = [n(), n(), n(), n()];\n    if (L.length !== r.SIGNATURE_LENGTH)\n      throw new Error(`ed25519: signature must be ${r.SIGNATURE_LENGTH} bytes`);\n    if (P(W, C))\n      return !1;\n    const Y = new t.SHA512();\n    Y.update(L.subarray(0, 32)), Y.update(C), Y.update(q);\n    const X = Y.digest();\n    return m(X), a(F, W, X), c(W, L.subarray(32)), O(F, W), l(y, F), !j(L, y);\n  }\n  r.verify = G;\n  function M(C) {\n    let q = [n(), n(), n(), n()];\n    if (P(q, C))\n      throw new Error(\"Ed25519: invalid public key\");\n    let L = n(), y = n(), F = q[1];\n    z(L, f, F), B(y, f, F), J(y, y), _(L, L, y);\n    let W = new Uint8Array(32);\n    return k(W, L), W;\n  }\n  r.convertPublicKeyToX25519 = M;\n  function H(C) {\n    const q = (0, t.hash)(C.subarray(0, 32));\n    q[0] &= 248, q[31] &= 127, q[31] |= 64;\n    const L = new Uint8Array(q.subarray(0, 32));\n    return (0, i.wipe)(q), L;\n  }\n  r.convertSecretKeyToX25519 = H;\n})(Co);\nconst Vp = \"EdDSA\", Wp = \"JWT\", zs = \".\", ca = \"base64url\", tu = \"utf8\", ru = \"utf8\", Gp = \":\", Jp = \"did\", Yp = \"key\", Bf = \"base58btc\", Xp = \"z\", Zp = \"K36\", Qp = 32;\nfunction iu(r = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r);\n}\nfunction Ds(r, e) {\n  e || (e = r.reduce((n, s) => n + s.length, 0));\n  const t = iu(e);\n  let i = 0;\n  for (const n of r)\n    t.set(n, i), i += n.length;\n  return t;\n}\nfunction e1(r, e) {\n  if (r.length >= 255)\n    throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), i = 0; i < t.length; i++)\n    t[i] = 255;\n  for (var n = 0; n < r.length; n++) {\n    var s = r.charAt(n), o = s.charCodeAt(0);\n    if (t[o] !== 255)\n      throw new TypeError(s + \" is ambiguous\");\n    t[o] = n;\n  }\n  var f = r.length, h = r.charAt(0), d = Math.log(f) / Math.log(256), v = Math.log(256) / Math.log(f);\n  function w(D) {\n    if (D instanceof Uint8Array || (ArrayBuffer.isView(D) ? D = new Uint8Array(D.buffer, D.byteOffset, D.byteLength) : Array.isArray(D) && (D = Uint8Array.from(D))), !(D instanceof Uint8Array))\n      throw new TypeError(\"Expected Uint8Array\");\n    if (D.length === 0)\n      return \"\";\n    for (var N = 0, k = 0, j = 0, T = D.length; j !== T && D[j] === 0; )\n      j++, N++;\n    for (var K = (T - j) * v + 1 >>> 0, $ = new Uint8Array(K); j !== T; ) {\n      for (var z = D[j], B = 0, _ = K - 1; (z !== 0 || B < k) && _ !== -1; _--, B++)\n        z += 256 * $[_] >>> 0, $[_] = z % f >>> 0, z = z / f >>> 0;\n      if (z !== 0)\n        throw new Error(\"Non-zero carry\");\n      k = B, j++;\n    }\n    for (var R = K - k; R !== K && $[R] === 0; )\n      R++;\n    for (var J = h.repeat(N); R < K; ++R)\n      J += r.charAt($[R]);\n    return J;\n  }\n  function A(D) {\n    if (typeof D != \"string\")\n      throw new TypeError(\"Expected String\");\n    if (D.length === 0)\n      return new Uint8Array();\n    var N = 0;\n    if (D[N] !== \" \") {\n      for (var k = 0, j = 0; D[N] === h; )\n        k++, N++;\n      for (var T = (D.length - N) * d + 1 >>> 0, K = new Uint8Array(T); D[N]; ) {\n        var $ = t[D.charCodeAt(N)];\n        if ($ === 255)\n          return;\n        for (var z = 0, B = T - 1; ($ !== 0 || z < j) && B !== -1; B--, z++)\n          $ += f * K[B] >>> 0, K[B] = $ % 256 >>> 0, $ = $ / 256 >>> 0;\n        if ($ !== 0)\n          throw new Error(\"Non-zero carry\");\n        j = z, N++;\n      }\n      if (D[N] !== \" \") {\n        for (var _ = T - j; _ !== T && K[_] === 0; )\n          _++;\n        for (var R = new Uint8Array(k + (T - _)), J = k; _ !== T; )\n          R[J++] = K[_++];\n        return R;\n      }\n    }\n  }\n  function I(D) {\n    var N = A(D);\n    if (N)\n      return N;\n    throw new Error(`Non-${e} character`);\n  }\n  return {\n    encode: w,\n    decodeUnsafe: A,\n    decode: I\n  };\n}\nvar t1 = e1, r1 = t1;\nconst i1 = (r) => {\n  if (r instanceof Uint8Array && r.constructor.name === \"Uint8Array\")\n    return r;\n  if (r instanceof ArrayBuffer)\n    return new Uint8Array(r);\n  if (ArrayBuffer.isView(r))\n    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);\n  throw new Error(\"Unknown type, must be binary type\");\n}, n1 = (r) => new TextEncoder().encode(r), s1 = (r) => new TextDecoder().decode(r);\nclass a1 {\n  constructor(e, t, i) {\n    this.name = e, this.prefix = t, this.baseEncode = i;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array)\n      return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass o1 {\n  constructor(e, t, i) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)\n      throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint)\n        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else\n      throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return nu(this, e);\n  }\n}\nclass f1 {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return nu(this, e);\n  }\n  decode(e) {\n    const t = e[0], i = this.decoders[t];\n    if (i)\n      return i.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst nu = (r, e) => new f1({\n  ...r.decoders || { [r.prefix]: r },\n  ...e.decoders || { [e.prefix]: e }\n});\nclass c1 {\n  constructor(e, t, i, n) {\n    this.name = e, this.prefix = t, this.baseEncode = i, this.baseDecode = n, this.encoder = new a1(e, t, i), this.decoder = new o1(e, t, n);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst ha = ({ name: r, prefix: e, encode: t, decode: i }) => new c1(r, e, t, i), rs = ({ prefix: r, name: e, alphabet: t }) => {\n  const { encode: i, decode: n } = r1(t, e);\n  return ha({\n    prefix: r,\n    name: e,\n    encode: i,\n    decode: (s) => i1(n(s))\n  });\n}, h1 = (r, e, t, i) => {\n  const n = {};\n  for (let v = 0; v < e.length; ++v)\n    n[e[v]] = v;\n  let s = r.length;\n  for (; r[s - 1] === \"=\"; )\n    --s;\n  const o = new Uint8Array(s * t / 8 | 0);\n  let f = 0, h = 0, d = 0;\n  for (let v = 0; v < s; ++v) {\n    const w = n[r[v]];\n    if (w === void 0)\n      throw new SyntaxError(`Non-${i} character`);\n    h = h << t | w, f += t, f >= 8 && (f -= 8, o[d++] = 255 & h >> f);\n  }\n  if (f >= t || 255 & h << 8 - f)\n    throw new SyntaxError(\"Unexpected end of data\");\n  return o;\n}, u1 = (r, e, t) => {\n  const i = e[e.length - 1] === \"=\", n = (1 << t) - 1;\n  let s = \"\", o = 0, f = 0;\n  for (let h = 0; h < r.length; ++h)\n    for (f = f << 8 | r[h], o += 8; o > t; )\n      o -= t, s += e[n & f >> o];\n  if (o && (s += e[n & f << t - o]), i)\n    for (; s.length * t & 7; )\n      s += \"=\";\n  return s;\n}, Rt = ({ name: r, prefix: e, bitsPerChar: t, alphabet: i }) => ha({\n  prefix: e,\n  name: r,\n  encode(n) {\n    return u1(n, i, t);\n  },\n  decode(n) {\n    return h1(n, i, t, r);\n  }\n}), d1 = ha({\n  prefix: \"\\0\",\n  name: \"identity\",\n  encode: (r) => s1(r),\n  decode: (r) => n1(r)\n}), l1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  identity: d1\n}, Symbol.toStringTag, { value: \"Module\" })), p1 = Rt({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n}), v1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base2: p1\n}, Symbol.toStringTag, { value: \"Module\" })), b1 = Rt({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n}), g1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base8: b1\n}, Symbol.toStringTag, { value: \"Module\" })), y1 = rs({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n}), m1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base10: y1\n}, Symbol.toStringTag, { value: \"Module\" })), w1 = Rt({\n  prefix: \"f\",\n  name: \"base16\",\n  alphabet: \"0123456789abcdef\",\n  bitsPerChar: 4\n}), _1 = Rt({\n  prefix: \"F\",\n  name: \"base16upper\",\n  alphabet: \"0123456789ABCDEF\",\n  bitsPerChar: 4\n}), x1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base16: w1,\n  base16upper: _1\n}, Symbol.toStringTag, { value: \"Module\" })), E1 = Rt({\n  prefix: \"b\",\n  name: \"base32\",\n  alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n  bitsPerChar: 5\n}), S1 = Rt({\n  prefix: \"B\",\n  name: \"base32upper\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  bitsPerChar: 5\n}), M1 = Rt({\n  prefix: \"c\",\n  name: \"base32pad\",\n  alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n  bitsPerChar: 5\n}), I1 = Rt({\n  prefix: \"C\",\n  name: \"base32padupper\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n  bitsPerChar: 5\n}), A1 = Rt({\n  prefix: \"v\",\n  name: \"base32hex\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n  bitsPerChar: 5\n}), D1 = Rt({\n  prefix: \"V\",\n  name: \"base32hexupper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  bitsPerChar: 5\n}), P1 = Rt({\n  prefix: \"t\",\n  name: \"base32hexpad\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n  bitsPerChar: 5\n}), O1 = Rt({\n  prefix: \"T\",\n  name: \"base32hexpadupper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n  bitsPerChar: 5\n}), R1 = Rt({\n  prefix: \"h\",\n  name: \"base32z\",\n  alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n  bitsPerChar: 5\n}), N1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base32: E1,\n  base32hex: A1,\n  base32hexpad: P1,\n  base32hexpadupper: O1,\n  base32hexupper: D1,\n  base32pad: M1,\n  base32padupper: I1,\n  base32upper: S1,\n  base32z: R1\n}, Symbol.toStringTag, { value: \"Module\" })), T1 = rs({\n  prefix: \"k\",\n  name: \"base36\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n}), C1 = rs({\n  prefix: \"K\",\n  name: \"base36upper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n}), $1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base36: T1,\n  base36upper: C1\n}, Symbol.toStringTag, { value: \"Module\" })), L1 = rs({\n  name: \"base58btc\",\n  prefix: \"z\",\n  alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n}), F1 = rs({\n  name: \"base58flickr\",\n  prefix: \"Z\",\n  alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n}), q1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base58btc: L1,\n  base58flickr: F1\n}, Symbol.toStringTag, { value: \"Module\" })), U1 = Rt({\n  prefix: \"m\",\n  name: \"base64\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n  bitsPerChar: 6\n}), z1 = Rt({\n  prefix: \"M\",\n  name: \"base64pad\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n  bitsPerChar: 6\n}), B1 = Rt({\n  prefix: \"u\",\n  name: \"base64url\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n  bitsPerChar: 6\n}), k1 = Rt({\n  prefix: \"U\",\n  name: \"base64urlpad\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n  bitsPerChar: 6\n}), j1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base64: U1,\n  base64pad: z1,\n  base64url: B1,\n  base64urlpad: k1\n}, Symbol.toStringTag, { value: \"Module\" })), su = Array.from(\"\"), K1 = su.reduce((r, e, t) => (r[t] = e, r), []), H1 = su.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);\nfunction V1(r) {\n  return r.reduce((e, t) => (e += K1[t], e), \"\");\n}\nfunction W1(r) {\n  const e = [];\n  for (const t of r) {\n    const i = H1[t.codePointAt(0)];\n    if (i === void 0)\n      throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(i);\n  }\n  return new Uint8Array(e);\n}\nconst G1 = ha({\n  prefix: \"\",\n  name: \"base256emoji\",\n  encode: V1,\n  decode: W1\n}), J1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base256emoji: G1\n}, Symbol.toStringTag, { value: \"Module\" }));\nnew TextEncoder();\nnew TextDecoder();\nconst kf = {\n  ...l1,\n  ...v1,\n  ...g1,\n  ...m1,\n  ...x1,\n  ...N1,\n  ...$1,\n  ...q1,\n  ...j1,\n  ...J1\n};\nfunction au(r, e, t, i) {\n  return {\n    name: r,\n    prefix: e,\n    encoder: {\n      name: r,\n      prefix: e,\n      encode: t\n    },\n    decoder: { decode: i }\n  };\n}\nconst jf = au(\"utf8\", \"u\", (r) => \"u\" + new TextDecoder(\"utf8\").decode(r), (r) => new TextEncoder().encode(r.substring(1))), Ua = au(\"ascii\", \"a\", (r) => {\n  let e = \"a\";\n  for (let t = 0; t < r.length; t++)\n    e += String.fromCharCode(r[t]);\n  return e;\n}, (r) => {\n  r = r.substring(1);\n  const e = iu(r.length);\n  for (let t = 0; t < r.length; t++)\n    e[t] = r.charCodeAt(t);\n  return e;\n}), ou = {\n  utf8: jf,\n  \"utf-8\": jf,\n  hex: kf.base16,\n  latin1: Ua,\n  ascii: Ua,\n  binary: Ua,\n  ...kf\n};\nfunction Mt(r, e = \"utf8\") {\n  const t = ou[e];\n  if (!t)\n    throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString(\"utf8\") : t.encoder.encode(r).substring(1);\n}\nfunction St(r, e = \"utf8\") {\n  const t = ou[e];\n  if (!t)\n    throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, \"utf8\") : t.decoder.decode(`${t.prefix}${r}`);\n}\nfunction Kf(r) {\n  return un(Mt(St(r, ca), tu));\n}\nfunction Bs(r) {\n  return Mt(St(ji(r), tu), ca);\n}\nfunction fu(r) {\n  const e = St(Zp, Bf), t = Xp + Mt(Ds([e, r]), Bf);\n  return [Jp, Yp, t].join(Gp);\n}\nfunction Y1(r) {\n  return Mt(r, ca);\n}\nfunction X1(r) {\n  return St(r, ca);\n}\nfunction Z1(r) {\n  return St([Bs(r.header), Bs(r.payload)].join(zs), ru);\n}\nfunction Q1(r) {\n  return [\n    Bs(r.header),\n    Bs(r.payload),\n    Y1(r.signature)\n  ].join(zs);\n}\nfunction bo(r) {\n  const e = r.split(zs), t = Kf(e[0]), i = Kf(e[1]), n = X1(e[2]), s = St(e.slice(0, 2).join(zs), ru);\n  return { header: t, payload: i, signature: n, data: s };\n}\nfunction Hf(r = Ei.randomBytes(Qp)) {\n  return Co.generateKeyPairFromSeed(r);\n}\nasync function ev(r, e, t, i, n = ie.fromMiliseconds(Date.now())) {\n  const s = { alg: Vp, typ: Wp }, o = fu(i.publicKey), f = n + t, h = { iss: o, sub: r, aud: e, iat: n, exp: f }, d = Z1({ header: s, payload: h }), v = Co.sign(i.secretKey, d);\n  return Q1({ header: s, payload: h, signature: v });\n}\nvar Vf = globalThis && globalThis.__spreadArray || function(r, e, t) {\n  if (t || arguments.length === 2)\n    for (var i = 0, n = e.length, s; i < n; i++)\n      (s || !(i in e)) && (s || (s = Array.prototype.slice.call(e, 0, i)), s[i] = e[i]);\n  return r.concat(s || Array.prototype.slice.call(e));\n}, tv = (\n  /** @class */\n  function() {\n    function r(e, t, i) {\n      this.name = e, this.version = t, this.os = i, this.type = \"browser\";\n    }\n    return r;\n  }()\n), rv = (\n  /** @class */\n  function() {\n    function r(e) {\n      this.version = e, this.type = \"node\", this.name = \"node\", this.os = process.platform;\n    }\n    return r;\n  }()\n), iv = (\n  /** @class */\n  function() {\n    function r(e, t, i, n) {\n      this.name = e, this.version = t, this.os = i, this.bot = n, this.type = \"bot-device\";\n    }\n    return r;\n  }()\n), nv = (\n  /** @class */\n  function() {\n    function r() {\n      this.type = \"bot\", this.bot = !0, this.name = \"bot\", this.version = null, this.os = null;\n    }\n    return r;\n  }()\n), sv = (\n  /** @class */\n  function() {\n    function r() {\n      this.type = \"react-native\", this.name = \"react-native\", this.version = null, this.os = null;\n    }\n    return r;\n  }()\n), av = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, ov = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\\ Jeeves\\/Teoma|ia_archiver)/, Wf = 3, fv = [\n  [\"aol\", /AOLShield\\/([0-9\\._]+)/],\n  [\"edge\", /Edge\\/([0-9\\._]+)/],\n  [\"edge-ios\", /EdgiOS\\/([0-9\\._]+)/],\n  [\"yandexbrowser\", /YaBrowser\\/([0-9\\._]+)/],\n  [\"kakaotalk\", /KAKAOTALK\\s([0-9\\.]+)/],\n  [\"samsung\", /SamsungBrowser\\/([0-9\\.]+)/],\n  [\"silk\", /\\bSilk\\/([0-9._-]+)\\b/],\n  [\"miui\", /MiuiBrowser\\/([0-9\\.]+)$/],\n  [\"beaker\", /BeakerBrowser\\/([0-9\\.]+)/],\n  [\"edge-chromium\", /EdgA?\\/([0-9\\.]+)/],\n  [\n    \"chromium-webview\",\n    /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/\n  ],\n  [\"chrome\", /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"phantomjs\", /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"crios\", /CriOS\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"firefox\", /Firefox\\/([0-9\\.]+)(?:\\s|$)/],\n  [\"fxios\", /FxiOS\\/([0-9\\.]+)/],\n  [\"opera-mini\", /Opera Mini.*Version\\/([0-9\\.]+)/],\n  [\"opera\", /Opera\\/([0-9\\.]+)(?:\\s|$)/],\n  [\"opera\", /OPR\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"pie\", /^Microsoft Pocket Internet Explorer\\/(\\d+\\.\\d+)$/],\n  [\"pie\", /^Mozilla\\/\\d\\.\\d+\\s\\(compatible;\\s(?:MSP?IE|MSInternet Explorer) (\\d+\\.\\d+);.*Windows CE.*\\)$/],\n  [\"netfront\", /^Mozilla\\/\\d\\.\\d+.*NetFront\\/(\\d.\\d)/],\n  [\"ie\", /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/],\n  [\"ie\", /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/],\n  [\"ie\", /MSIE\\s(7\\.0)/],\n  [\"bb10\", /BB10;\\sTouch.*Version\\/([0-9\\.]+)/],\n  [\"android\", /Android\\s([0-9\\.]+)/],\n  [\"ios\", /Version\\/([0-9\\._]+).*Mobile.*Safari.*/],\n  [\"safari\", /Version\\/([0-9\\._]+).*Safari/],\n  [\"facebook\", /FB[AS]V\\/([0-9\\.]+)/],\n  [\"instagram\", /Instagram\\s([0-9\\.]+)/],\n  [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Mobile/],\n  [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/],\n  [\"curl\", /^curl\\/([0-9\\.]+)$/],\n  [\"searchbot\", av]\n], Gf = [\n  [\"iOS\", /iP(hone|od|ad)/],\n  [\"Android OS\", /Android/],\n  [\"BlackBerry OS\", /BlackBerry|BB10/],\n  [\"Windows Mobile\", /IEMobile/],\n  [\"Amazon OS\", /Kindle/],\n  [\"Windows 3.11\", /Win16/],\n  [\"Windows 95\", /(Windows 95)|(Win95)|(Windows_95)/],\n  [\"Windows 98\", /(Windows 98)|(Win98)/],\n  [\"Windows 2000\", /(Windows NT 5.0)|(Windows 2000)/],\n  [\"Windows XP\", /(Windows NT 5.1)|(Windows XP)/],\n  [\"Windows Server 2003\", /(Windows NT 5.2)/],\n  [\"Windows Vista\", /(Windows NT 6.0)/],\n  [\"Windows 7\", /(Windows NT 6.1)/],\n  [\"Windows 8\", /(Windows NT 6.2)/],\n  [\"Windows 8.1\", /(Windows NT 6.3)/],\n  [\"Windows 10\", /(Windows NT 10.0)/],\n  [\"Windows ME\", /Windows ME/],\n  [\"Windows CE\", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],\n  [\"Open BSD\", /OpenBSD/],\n  [\"Sun OS\", /SunOS/],\n  [\"Chrome OS\", /CrOS/],\n  [\"Linux\", /(Linux)|(X11)/],\n  [\"Mac OS\", /(Mac_PowerPC)|(Macintosh)/],\n  [\"QNX\", /QNX/],\n  [\"BeOS\", /BeOS/],\n  [\"OS/2\", /OS\\/2/]\n];\nfunction cu(r) {\n  return r ? Jf(r) : typeof document > \"u\" && typeof navigator < \"u\" && navigator.product === \"ReactNative\" ? new sv() : typeof navigator < \"u\" ? Jf(navigator.userAgent) : uv();\n}\nfunction cv(r) {\n  return r !== \"\" && fv.reduce(function(e, t) {\n    var i = t[0], n = t[1];\n    if (e)\n      return e;\n    var s = n.exec(r);\n    return !!s && [i, s];\n  }, !1);\n}\nfunction Jf(r) {\n  var e = cv(r);\n  if (!e)\n    return null;\n  var t = e[0], i = e[1];\n  if (t === \"searchbot\")\n    return new nv();\n  var n = i[1] && i[1].split(\".\").join(\"_\").split(\"_\").slice(0, 3);\n  n ? n.length < Wf && (n = Vf(Vf([], n, !0), dv(Wf - n.length), !0)) : n = [];\n  var s = n.join(\".\"), o = hv(r), f = ov.exec(r);\n  return f && f[1] ? new iv(t, s, o, f[1]) : new tv(t, s, o);\n}\nfunction hv(r) {\n  for (var e = 0, t = Gf.length; e < t; e++) {\n    var i = Gf[e], n = i[0], s = i[1], o = s.exec(r);\n    if (o)\n      return n;\n  }\n  return null;\n}\nfunction uv() {\n  var r = typeof process < \"u\" && process.version;\n  return r ? new rv(process.version.slice(1)) : null;\n}\nfunction dv(r) {\n  for (var e = [], t = 0; t < r; t++)\n    e.push(\"0\");\n  return e;\n}\nvar ot = {};\nObject.defineProperty(ot, \"__esModule\", { value: !0 });\not.getLocalStorage = ot.getLocalStorageOrThrow = ot.getCrypto = ot.getCryptoOrThrow = hu = ot.getLocation = ot.getLocationOrThrow = $o = ot.getNavigator = ot.getNavigatorOrThrow = is = ot.getDocument = ot.getDocumentOrThrow = ot.getFromWindowOrThrow = ot.getFromWindow = void 0;\nfunction Ji(r) {\n  let e;\n  return typeof window < \"u\" && typeof window[r] < \"u\" && (e = window[r]), e;\n}\not.getFromWindow = Ji;\nfunction yn(r) {\n  const e = Ji(r);\n  if (!e)\n    throw new Error(`${r} is not defined in Window`);\n  return e;\n}\not.getFromWindowOrThrow = yn;\nfunction lv() {\n  return yn(\"document\");\n}\not.getDocumentOrThrow = lv;\nfunction pv() {\n  return Ji(\"document\");\n}\nvar is = ot.getDocument = pv;\nfunction vv() {\n  return yn(\"navigator\");\n}\not.getNavigatorOrThrow = vv;\nfunction bv() {\n  return Ji(\"navigator\");\n}\nvar $o = ot.getNavigator = bv;\nfunction gv() {\n  return yn(\"location\");\n}\not.getLocationOrThrow = gv;\nfunction yv() {\n  return Ji(\"location\");\n}\nvar hu = ot.getLocation = yv;\nfunction mv() {\n  return yn(\"crypto\");\n}\not.getCryptoOrThrow = mv;\nfunction wv() {\n  return Ji(\"crypto\");\n}\not.getCrypto = wv;\nfunction _v() {\n  return yn(\"localStorage\");\n}\not.getLocalStorageOrThrow = _v;\nfunction xv() {\n  return Ji(\"localStorage\");\n}\not.getLocalStorage = xv;\nvar Lo = {};\nObject.defineProperty(Lo, \"__esModule\", { value: !0 });\nvar uu = Lo.getWindowMetadata = void 0;\nconst Yf = ot;\nfunction Ev() {\n  let r, e;\n  try {\n    r = Yf.getDocumentOrThrow(), e = Yf.getLocationOrThrow();\n  } catch {\n    return null;\n  }\n  function t() {\n    const w = r.getElementsByTagName(\"link\"), A = [];\n    for (let I = 0; I < w.length; I++) {\n      const D = w[I], N = D.getAttribute(\"rel\");\n      if (N && N.toLowerCase().indexOf(\"icon\") > -1) {\n        const k = D.getAttribute(\"href\");\n        if (k)\n          if (k.toLowerCase().indexOf(\"https:\") === -1 && k.toLowerCase().indexOf(\"http:\") === -1 && k.indexOf(\"//\") !== 0) {\n            let j = e.protocol + \"//\" + e.host;\n            if (k.indexOf(\"/\") === 0)\n              j += k;\n            else {\n              const T = e.pathname.split(\"/\");\n              T.pop();\n              const K = T.join(\"/\");\n              j += K + \"/\" + k;\n            }\n            A.push(j);\n          } else if (k.indexOf(\"//\") === 0) {\n            const j = e.protocol + k;\n            A.push(j);\n          } else\n            A.push(k);\n      }\n    }\n    return A;\n  }\n  function i(...w) {\n    const A = r.getElementsByTagName(\"meta\");\n    for (let I = 0; I < A.length; I++) {\n      const D = A[I], N = [\"itemprop\", \"property\", \"name\"].map((k) => D.getAttribute(k)).filter((k) => k ? w.includes(k) : !1);\n      if (N.length && N) {\n        const k = D.getAttribute(\"content\");\n        if (k)\n          return k;\n      }\n    }\n    return \"\";\n  }\n  function n() {\n    let w = i(\"name\", \"og:site_name\", \"og:title\", \"twitter:title\");\n    return w || (w = r.title), w;\n  }\n  function s() {\n    return i(\"description\", \"og:description\", \"twitter:description\", \"keywords\");\n  }\n  const o = n(), f = s(), h = e.origin, d = t();\n  return {\n    description: f,\n    url: h,\n    icons: d,\n    name: o\n  };\n}\nuu = Lo.getWindowMetadata = Ev;\nvar Yn = {}, Sv = (r) => encodeURIComponent(r).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), du = \"%[a-f0-9]{2}\", Xf = new RegExp(\"(\" + du + \")|([^%]+?)\", \"gi\"), Zf = new RegExp(\"(\" + du + \")+\", \"gi\");\nfunction go(r, e) {\n  try {\n    return [decodeURIComponent(r.join(\"\"))];\n  } catch {\n  }\n  if (r.length === 1)\n    return r;\n  e = e || 1;\n  var t = r.slice(0, e), i = r.slice(e);\n  return Array.prototype.concat.call([], go(t), go(i));\n}\nfunction Mv(r) {\n  try {\n    return decodeURIComponent(r);\n  } catch {\n    for (var e = r.match(Xf) || [], t = 1; t < e.length; t++)\n      r = go(e, t).join(\"\"), e = r.match(Xf) || [];\n    return r;\n  }\n}\nfunction Iv(r) {\n  for (var e = {\n    \"%FE%FF\": \"\",\n    \"%FF%FE\": \"\"\n  }, t = Zf.exec(r); t; ) {\n    try {\n      e[t[0]] = decodeURIComponent(t[0]);\n    } catch {\n      var i = Mv(t[0]);\n      i !== t[0] && (e[t[0]] = i);\n    }\n    t = Zf.exec(r);\n  }\n  e[\"%C2\"] = \"\";\n  for (var n = Object.keys(e), s = 0; s < n.length; s++) {\n    var o = n[s];\n    r = r.replace(new RegExp(o, \"g\"), e[o]);\n  }\n  return r;\n}\nvar Av = function(r) {\n  if (typeof r != \"string\")\n    throw new TypeError(\"Expected `encodedURI` to be of type `string`, got `\" + typeof r + \"`\");\n  try {\n    return r = r.replace(/\\+/g, \" \"), decodeURIComponent(r);\n  } catch {\n    return Iv(r);\n  }\n}, Dv = (r, e) => {\n  if (!(typeof r == \"string\" && typeof e == \"string\"))\n    throw new TypeError(\"Expected the arguments to be of type `string`\");\n  if (e === \"\")\n    return [r];\n  const t = r.indexOf(e);\n  return t === -1 ? [r] : [\n    r.slice(0, t),\n    r.slice(t + e.length)\n  ];\n}, Pv = function(r, e) {\n  for (var t = {}, i = Object.keys(r), n = Array.isArray(e), s = 0; s < i.length; s++) {\n    var o = i[s], f = r[o];\n    (n ? e.indexOf(o) !== -1 : e(o, f, r)) && (t[o] = f);\n  }\n  return t;\n};\n(function(r) {\n  const e = Sv, t = Av, i = Dv, n = Pv, s = (T) => T == null, o = Symbol(\"encodeFragmentIdentifier\");\n  function f(T) {\n    switch (T.arrayFormat) {\n      case \"index\":\n        return (K) => ($, z) => {\n          const B = $.length;\n          return z === void 0 || T.skipNull && z === null || T.skipEmptyString && z === \"\" ? $ : z === null ? [...$, [v(K, T), \"[\", B, \"]\"].join(\"\")] : [\n            ...$,\n            [v(K, T), \"[\", v(B, T), \"]=\", v(z, T)].join(\"\")\n          ];\n        };\n      case \"bracket\":\n        return (K) => ($, z) => z === void 0 || T.skipNull && z === null || T.skipEmptyString && z === \"\" ? $ : z === null ? [...$, [v(K, T), \"[]\"].join(\"\")] : [...$, [v(K, T), \"[]=\", v(z, T)].join(\"\")];\n      case \"colon-list-separator\":\n        return (K) => ($, z) => z === void 0 || T.skipNull && z === null || T.skipEmptyString && z === \"\" ? $ : z === null ? [...$, [v(K, T), \":list=\"].join(\"\")] : [...$, [v(K, T), \":list=\", v(z, T)].join(\"\")];\n      case \"comma\":\n      case \"separator\":\n      case \"bracket-separator\": {\n        const K = T.arrayFormat === \"bracket-separator\" ? \"[]=\" : \"=\";\n        return ($) => (z, B) => B === void 0 || T.skipNull && B === null || T.skipEmptyString && B === \"\" ? z : (B = B === null ? \"\" : B, z.length === 0 ? [[v($, T), K, v(B, T)].join(\"\")] : [[z, v(B, T)].join(T.arrayFormatSeparator)]);\n      }\n      default:\n        return (K) => ($, z) => z === void 0 || T.skipNull && z === null || T.skipEmptyString && z === \"\" ? $ : z === null ? [...$, v(K, T)] : [...$, [v(K, T), \"=\", v(z, T)].join(\"\")];\n    }\n  }\n  function h(T) {\n    let K;\n    switch (T.arrayFormat) {\n      case \"index\":\n        return ($, z, B) => {\n          if (K = /\\[(\\d*)\\]$/.exec($), $ = $.replace(/\\[\\d*\\]$/, \"\"), !K) {\n            B[$] = z;\n            return;\n          }\n          B[$] === void 0 && (B[$] = {}), B[$][K[1]] = z;\n        };\n      case \"bracket\":\n        return ($, z, B) => {\n          if (K = /(\\[\\])$/.exec($), $ = $.replace(/\\[\\]$/, \"\"), !K) {\n            B[$] = z;\n            return;\n          }\n          if (B[$] === void 0) {\n            B[$] = [z];\n            return;\n          }\n          B[$] = [].concat(B[$], z);\n        };\n      case \"colon-list-separator\":\n        return ($, z, B) => {\n          if (K = /(:list)$/.exec($), $ = $.replace(/:list$/, \"\"), !K) {\n            B[$] = z;\n            return;\n          }\n          if (B[$] === void 0) {\n            B[$] = [z];\n            return;\n          }\n          B[$] = [].concat(B[$], z);\n        };\n      case \"comma\":\n      case \"separator\":\n        return ($, z, B) => {\n          const _ = typeof z == \"string\" && z.includes(T.arrayFormatSeparator), R = typeof z == \"string\" && !_ && w(z, T).includes(T.arrayFormatSeparator);\n          z = R ? w(z, T) : z;\n          const J = _ || R ? z.split(T.arrayFormatSeparator).map((Q) => w(Q, T)) : z === null ? z : w(z, T);\n          B[$] = J;\n        };\n      case \"bracket-separator\":\n        return ($, z, B) => {\n          const _ = /(\\[\\])$/.test($);\n          if ($ = $.replace(/\\[\\]$/, \"\"), !_) {\n            B[$] = z && w(z, T);\n            return;\n          }\n          const R = z === null ? [] : z.split(T.arrayFormatSeparator).map((J) => w(J, T));\n          if (B[$] === void 0) {\n            B[$] = R;\n            return;\n          }\n          B[$] = [].concat(B[$], R);\n        };\n      default:\n        return ($, z, B) => {\n          if (B[$] === void 0) {\n            B[$] = z;\n            return;\n          }\n          B[$] = [].concat(B[$], z);\n        };\n    }\n  }\n  function d(T) {\n    if (typeof T != \"string\" || T.length !== 1)\n      throw new TypeError(\"arrayFormatSeparator must be single character string\");\n  }\n  function v(T, K) {\n    return K.encode ? K.strict ? e(T) : encodeURIComponent(T) : T;\n  }\n  function w(T, K) {\n    return K.decode ? t(T) : T;\n  }\n  function A(T) {\n    return Array.isArray(T) ? T.sort() : typeof T == \"object\" ? A(Object.keys(T)).sort((K, $) => Number(K) - Number($)).map((K) => T[K]) : T;\n  }\n  function I(T) {\n    const K = T.indexOf(\"#\");\n    return K !== -1 && (T = T.slice(0, K)), T;\n  }\n  function D(T) {\n    let K = \"\";\n    const $ = T.indexOf(\"#\");\n    return $ !== -1 && (K = T.slice($)), K;\n  }\n  function N(T) {\n    T = I(T);\n    const K = T.indexOf(\"?\");\n    return K === -1 ? \"\" : T.slice(K + 1);\n  }\n  function k(T, K) {\n    return K.parseNumbers && !Number.isNaN(Number(T)) && typeof T == \"string\" && T.trim() !== \"\" ? T = Number(T) : K.parseBooleans && T !== null && (T.toLowerCase() === \"true\" || T.toLowerCase() === \"false\") && (T = T.toLowerCase() === \"true\"), T;\n  }\n  function j(T, K) {\n    K = Object.assign({\n      decode: !0,\n      sort: !0,\n      arrayFormat: \"none\",\n      arrayFormatSeparator: \",\",\n      parseNumbers: !1,\n      parseBooleans: !1\n    }, K), d(K.arrayFormatSeparator);\n    const $ = h(K), z = /* @__PURE__ */ Object.create(null);\n    if (typeof T != \"string\" || (T = T.trim().replace(/^[?#&]/, \"\"), !T))\n      return z;\n    for (const B of T.split(\"&\")) {\n      if (B === \"\")\n        continue;\n      let [_, R] = i(K.decode ? B.replace(/\\+/g, \" \") : B, \"=\");\n      R = R === void 0 ? null : [\"comma\", \"separator\", \"bracket-separator\"].includes(K.arrayFormat) ? R : w(R, K), $(w(_, K), R, z);\n    }\n    for (const B of Object.keys(z)) {\n      const _ = z[B];\n      if (typeof _ == \"object\" && _ !== null)\n        for (const R of Object.keys(_))\n          _[R] = k(_[R], K);\n      else\n        z[B] = k(_, K);\n    }\n    return K.sort === !1 ? z : (K.sort === !0 ? Object.keys(z).sort() : Object.keys(z).sort(K.sort)).reduce((B, _) => {\n      const R = z[_];\n      return R && typeof R == \"object\" && !Array.isArray(R) ? B[_] = A(R) : B[_] = R, B;\n    }, /* @__PURE__ */ Object.create(null));\n  }\n  r.extract = N, r.parse = j, r.stringify = (T, K) => {\n    if (!T)\n      return \"\";\n    K = Object.assign({\n      encode: !0,\n      strict: !0,\n      arrayFormat: \"none\",\n      arrayFormatSeparator: \",\"\n    }, K), d(K.arrayFormatSeparator);\n    const $ = (R) => K.skipNull && s(T[R]) || K.skipEmptyString && T[R] === \"\", z = f(K), B = {};\n    for (const R of Object.keys(T))\n      $(R) || (B[R] = T[R]);\n    const _ = Object.keys(B);\n    return K.sort !== !1 && _.sort(K.sort), _.map((R) => {\n      const J = T[R];\n      return J === void 0 ? \"\" : J === null ? v(R, K) : Array.isArray(J) ? J.length === 0 && K.arrayFormat === \"bracket-separator\" ? v(R, K) + \"[]\" : J.reduce(z(R), []).join(\"&\") : v(R, K) + \"=\" + v(J, K);\n    }).filter((R) => R.length > 0).join(\"&\");\n  }, r.parseUrl = (T, K) => {\n    K = Object.assign({\n      decode: !0\n    }, K);\n    const [$, z] = i(T, \"#\");\n    return Object.assign(\n      {\n        url: $.split(\"?\")[0] || \"\",\n        query: j(N(T), K)\n      },\n      K && K.parseFragmentIdentifier && z ? { fragmentIdentifier: w(z, K) } : {}\n    );\n  }, r.stringifyUrl = (T, K) => {\n    K = Object.assign({\n      encode: !0,\n      strict: !0,\n      [o]: !0\n    }, K);\n    const $ = I(T.url).split(\"?\")[0] || \"\", z = r.extract(T.url), B = r.parse(z, { sort: !1 }), _ = Object.assign(B, T.query);\n    let R = r.stringify(_, K);\n    R && (R = `?${R}`);\n    let J = D(T.url);\n    return T.fragmentIdentifier && (J = `#${K[o] ? v(T.fragmentIdentifier, K) : T.fragmentIdentifier}`), `${$}${R}${J}`;\n  }, r.pick = (T, K, $) => {\n    $ = Object.assign({\n      parseFragmentIdentifier: !0,\n      [o]: !1\n    }, $);\n    const { url: z, query: B, fragmentIdentifier: _ } = r.parseUrl(T, $);\n    return r.stringifyUrl({\n      url: z,\n      query: n(B, K),\n      fragmentIdentifier: _\n    }, $);\n  }, r.exclude = (T, K, $) => {\n    const z = Array.isArray(K) ? (B) => !K.includes(B) : (B, _) => !K(B, _);\n    return r.pick(T, z, $);\n  };\n})(Yn);\nvar lu = { exports: {} };\n/**\n * [js-sha3]{@link https://github.com/emn178/js-sha3}\n *\n * @version 0.8.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2015-2018\n * @license MIT\n */\n(function(r) {\n  (function() {\n    var e = \"input is invalid type\", t = \"finalize already called\", i = typeof window == \"object\", n = i ? window : {};\n    n.JS_SHA3_NO_WINDOW && (i = !1);\n    var s = !i && typeof self == \"object\", o = !n.JS_SHA3_NO_NODE_JS && typeof process == \"object\" && process.versions && process.versions.node;\n    o ? n = _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.c : s && (n = self);\n    var f = !n.JS_SHA3_NO_COMMON_JS && !0 && r.exports, h = !n.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < \"u\", d = \"0123456789abcdef\".split(\"\"), v = [31, 7936, 2031616, 520093696], w = [4, 1024, 262144, 67108864], A = [1, 256, 65536, 16777216], I = [6, 1536, 393216, 100663296], D = [0, 8, 16, 24], N = [\n      1,\n      0,\n      32898,\n      0,\n      32906,\n      2147483648,\n      2147516416,\n      2147483648,\n      32907,\n      0,\n      2147483649,\n      0,\n      2147516545,\n      2147483648,\n      32777,\n      2147483648,\n      138,\n      0,\n      136,\n      0,\n      2147516425,\n      0,\n      2147483658,\n      0,\n      2147516555,\n      0,\n      139,\n      2147483648,\n      32905,\n      2147483648,\n      32771,\n      2147483648,\n      32770,\n      2147483648,\n      128,\n      2147483648,\n      32778,\n      0,\n      2147483658,\n      2147483648,\n      2147516545,\n      2147483648,\n      32896,\n      2147483648,\n      2147483649,\n      0,\n      2147516424,\n      2147483648\n    ], k = [224, 256, 384, 512], j = [128, 256], T = [\"hex\", \"buffer\", \"arrayBuffer\", \"array\", \"digest\"], K = {\n      128: 168,\n      256: 136\n    };\n    (n.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(M) {\n      return Object.prototype.toString.call(M) === \"[object Array]\";\n    }), h && (n.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(M) {\n      return typeof M == \"object\" && M.buffer && M.buffer.constructor === ArrayBuffer;\n    });\n    for (var $ = function(M, H, C) {\n      return function(q) {\n        return new g(M, H, M).update(q)[C]();\n      };\n    }, z = function(M, H, C) {\n      return function(q, L) {\n        return new g(M, H, L).update(q)[C]();\n      };\n    }, B = function(M, H, C) {\n      return function(q, L, y, F) {\n        return a[\"cshake\" + M].update(q, L, y, F)[C]();\n      };\n    }, _ = function(M, H, C) {\n      return function(q, L, y, F) {\n        return a[\"kmac\" + M].update(q, L, y, F)[C]();\n      };\n    }, R = function(M, H, C, q) {\n      for (var L = 0; L < T.length; ++L) {\n        var y = T[L];\n        M[y] = H(C, q, y);\n      }\n      return M;\n    }, J = function(M, H) {\n      var C = $(M, H, \"hex\");\n      return C.create = function() {\n        return new g(M, H, M);\n      }, C.update = function(q) {\n        return C.create().update(q);\n      }, R(C, $, M, H);\n    }, Q = function(M, H) {\n      var C = z(M, H, \"hex\");\n      return C.create = function(q) {\n        return new g(M, H, q);\n      }, C.update = function(q, L) {\n        return C.create(L).update(q);\n      }, R(C, z, M, H);\n    }, O = function(M, H) {\n      var C = K[M], q = B(M, H, \"hex\");\n      return q.create = function(L, y, F) {\n        return !y && !F ? a[\"shake\" + M].create(L) : new g(M, H, L).bytepad([y, F], C);\n      }, q.update = function(L, y, F, W) {\n        return q.create(y, F, W).update(L);\n      }, R(q, B, M, H);\n    }, p = function(M, H) {\n      var C = K[M], q = _(M, H, \"hex\");\n      return q.create = function(L, y, F) {\n        return new P(M, H, y).bytepad([\"KMAC\", F], C).bytepad([L], C);\n      }, q.update = function(L, y, F, W) {\n        return q.create(L, F, W).update(y);\n      }, R(q, _, M, H);\n    }, l = [\n      { name: \"keccak\", padding: A, bits: k, createMethod: J },\n      { name: \"sha3\", padding: I, bits: k, createMethod: J },\n      { name: \"shake\", padding: v, bits: j, createMethod: Q },\n      { name: \"cshake\", padding: w, bits: j, createMethod: O },\n      { name: \"kmac\", padding: w, bits: j, createMethod: p }\n    ], a = {}, c = [], b = 0; b < l.length; ++b)\n      for (var E = l[b], S = E.bits, x = 0; x < S.length; ++x) {\n        var u = E.name + \"_\" + S[x];\n        if (c.push(u), a[u] = E.createMethod(S[x], E.padding), E.name !== \"sha3\") {\n          var m = E.name + S[x];\n          c.push(m), a[m] = a[u];\n        }\n      }\n    function g(M, H, C) {\n      this.blocks = [], this.s = [], this.padding = H, this.outputBits = C, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (M << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = C >> 5, this.extraBytes = (C & 31) >> 3;\n      for (var q = 0; q < 50; ++q)\n        this.s[q] = 0;\n    }\n    g.prototype.update = function(M) {\n      if (this.finalized)\n        throw new Error(t);\n      var H, C = typeof M;\n      if (C !== \"string\") {\n        if (C === \"object\") {\n          if (M === null)\n            throw new Error(e);\n          if (h && M.constructor === ArrayBuffer)\n            M = new Uint8Array(M);\n          else if (!Array.isArray(M) && (!h || !ArrayBuffer.isView(M)))\n            throw new Error(e);\n        } else\n          throw new Error(e);\n        H = !0;\n      }\n      for (var q = this.blocks, L = this.byteCount, y = M.length, F = this.blockCount, W = 0, Y = this.s, X, ee; W < y; ) {\n        if (this.reset)\n          for (this.reset = !1, q[0] = this.block, X = 1; X < F + 1; ++X)\n            q[X] = 0;\n        if (H)\n          for (X = this.start; W < y && X < L; ++W)\n            q[X >> 2] |= M[W] << D[X++ & 3];\n        else\n          for (X = this.start; W < y && X < L; ++W)\n            ee = M.charCodeAt(W), ee < 128 ? q[X >> 2] |= ee << D[X++ & 3] : ee < 2048 ? (q[X >> 2] |= (192 | ee >> 6) << D[X++ & 3], q[X >> 2] |= (128 | ee & 63) << D[X++ & 3]) : ee < 55296 || ee >= 57344 ? (q[X >> 2] |= (224 | ee >> 12) << D[X++ & 3], q[X >> 2] |= (128 | ee >> 6 & 63) << D[X++ & 3], q[X >> 2] |= (128 | ee & 63) << D[X++ & 3]) : (ee = 65536 + ((ee & 1023) << 10 | M.charCodeAt(++W) & 1023), q[X >> 2] |= (240 | ee >> 18) << D[X++ & 3], q[X >> 2] |= (128 | ee >> 12 & 63) << D[X++ & 3], q[X >> 2] |= (128 | ee >> 6 & 63) << D[X++ & 3], q[X >> 2] |= (128 | ee & 63) << D[X++ & 3]);\n        if (this.lastByteIndex = X, X >= L) {\n          for (this.start = X - L, this.block = q[F], X = 0; X < F; ++X)\n            Y[X] ^= q[X];\n          G(Y), this.reset = !0;\n        } else\n          this.start = X;\n      }\n      return this;\n    }, g.prototype.encode = function(M, H) {\n      var C = M & 255, q = 1, L = [C];\n      for (M = M >> 8, C = M & 255; C > 0; )\n        L.unshift(C), M = M >> 8, C = M & 255, ++q;\n      return H ? L.push(q) : L.unshift(q), this.update(L), L.length;\n    }, g.prototype.encodeString = function(M) {\n      var H, C = typeof M;\n      if (C !== \"string\") {\n        if (C === \"object\") {\n          if (M === null)\n            throw new Error(e);\n          if (h && M.constructor === ArrayBuffer)\n            M = new Uint8Array(M);\n          else if (!Array.isArray(M) && (!h || !ArrayBuffer.isView(M)))\n            throw new Error(e);\n        } else\n          throw new Error(e);\n        H = !0;\n      }\n      var q = 0, L = M.length;\n      if (H)\n        q = L;\n      else\n        for (var y = 0; y < M.length; ++y) {\n          var F = M.charCodeAt(y);\n          F < 128 ? q += 1 : F < 2048 ? q += 2 : F < 55296 || F >= 57344 ? q += 3 : (F = 65536 + ((F & 1023) << 10 | M.charCodeAt(++y) & 1023), q += 4);\n        }\n      return q += this.encode(q * 8), this.update(M), q;\n    }, g.prototype.bytepad = function(M, H) {\n      for (var C = this.encode(H), q = 0; q < M.length; ++q)\n        C += this.encodeString(M[q]);\n      var L = H - C % H, y = [];\n      return y.length = L, this.update(y), this;\n    }, g.prototype.finalize = function() {\n      if (!this.finalized) {\n        this.finalized = !0;\n        var M = this.blocks, H = this.lastByteIndex, C = this.blockCount, q = this.s;\n        if (M[H >> 2] |= this.padding[H & 3], this.lastByteIndex === this.byteCount)\n          for (M[0] = M[C], H = 1; H < C + 1; ++H)\n            M[H] = 0;\n        for (M[C - 1] |= 2147483648, H = 0; H < C; ++H)\n          q[H] ^= M[H];\n        G(q);\n      }\n    }, g.prototype.toString = g.prototype.hex = function() {\n      this.finalize();\n      for (var M = this.blockCount, H = this.s, C = this.outputBlocks, q = this.extraBytes, L = 0, y = 0, F = \"\", W; y < C; ) {\n        for (L = 0; L < M && y < C; ++L, ++y)\n          W = H[L], F += d[W >> 4 & 15] + d[W & 15] + d[W >> 12 & 15] + d[W >> 8 & 15] + d[W >> 20 & 15] + d[W >> 16 & 15] + d[W >> 28 & 15] + d[W >> 24 & 15];\n        y % M === 0 && (G(H), L = 0);\n      }\n      return q && (W = H[L], F += d[W >> 4 & 15] + d[W & 15], q > 1 && (F += d[W >> 12 & 15] + d[W >> 8 & 15]), q > 2 && (F += d[W >> 20 & 15] + d[W >> 16 & 15])), F;\n    }, g.prototype.arrayBuffer = function() {\n      this.finalize();\n      var M = this.blockCount, H = this.s, C = this.outputBlocks, q = this.extraBytes, L = 0, y = 0, F = this.outputBits >> 3, W;\n      q ? W = new ArrayBuffer(C + 1 << 2) : W = new ArrayBuffer(F);\n      for (var Y = new Uint32Array(W); y < C; ) {\n        for (L = 0; L < M && y < C; ++L, ++y)\n          Y[y] = H[L];\n        y % M === 0 && G(H);\n      }\n      return q && (Y[L] = H[L], W = W.slice(0, F)), W;\n    }, g.prototype.buffer = g.prototype.arrayBuffer, g.prototype.digest = g.prototype.array = function() {\n      this.finalize();\n      for (var M = this.blockCount, H = this.s, C = this.outputBlocks, q = this.extraBytes, L = 0, y = 0, F = [], W, Y; y < C; ) {\n        for (L = 0; L < M && y < C; ++L, ++y)\n          W = y << 2, Y = H[L], F[W] = Y & 255, F[W + 1] = Y >> 8 & 255, F[W + 2] = Y >> 16 & 255, F[W + 3] = Y >> 24 & 255;\n        y % M === 0 && G(H);\n      }\n      return q && (W = y << 2, Y = H[L], F[W] = Y & 255, q > 1 && (F[W + 1] = Y >> 8 & 255), q > 2 && (F[W + 2] = Y >> 16 & 255)), F;\n    };\n    function P(M, H, C) {\n      g.call(this, M, H, C);\n    }\n    P.prototype = new g(), P.prototype.finalize = function() {\n      return this.encode(this.outputBits, !0), g.prototype.finalize.call(this);\n    };\n    var G = function(M) {\n      var H, C, q, L, y, F, W, Y, X, ee, we, Me, he, Re, xe, se, ge, le, ne, ue, fe, te, pe, _e, re, Ee, Se, oe, De, Ie, Pe, Ge, Ye, Ae, Ze, et, Ne, Ce, Te, de, $e, Le, ce, Ue, ze, ye, Be, ke, ve, Fe, Oe, me, je, rt, qe, it, Je, tt, jt, Kt, Ht, Vt, gt;\n      for (q = 0; q < 48; q += 2)\n        L = M[0] ^ M[10] ^ M[20] ^ M[30] ^ M[40], y = M[1] ^ M[11] ^ M[21] ^ M[31] ^ M[41], F = M[2] ^ M[12] ^ M[22] ^ M[32] ^ M[42], W = M[3] ^ M[13] ^ M[23] ^ M[33] ^ M[43], Y = M[4] ^ M[14] ^ M[24] ^ M[34] ^ M[44], X = M[5] ^ M[15] ^ M[25] ^ M[35] ^ M[45], ee = M[6] ^ M[16] ^ M[26] ^ M[36] ^ M[46], we = M[7] ^ M[17] ^ M[27] ^ M[37] ^ M[47], Me = M[8] ^ M[18] ^ M[28] ^ M[38] ^ M[48], he = M[9] ^ M[19] ^ M[29] ^ M[39] ^ M[49], H = Me ^ (F << 1 | W >>> 31), C = he ^ (W << 1 | F >>> 31), M[0] ^= H, M[1] ^= C, M[10] ^= H, M[11] ^= C, M[20] ^= H, M[21] ^= C, M[30] ^= H, M[31] ^= C, M[40] ^= H, M[41] ^= C, H = L ^ (Y << 1 | X >>> 31), C = y ^ (X << 1 | Y >>> 31), M[2] ^= H, M[3] ^= C, M[12] ^= H, M[13] ^= C, M[22] ^= H, M[23] ^= C, M[32] ^= H, M[33] ^= C, M[42] ^= H, M[43] ^= C, H = F ^ (ee << 1 | we >>> 31), C = W ^ (we << 1 | ee >>> 31), M[4] ^= H, M[5] ^= C, M[14] ^= H, M[15] ^= C, M[24] ^= H, M[25] ^= C, M[34] ^= H, M[35] ^= C, M[44] ^= H, M[45] ^= C, H = Y ^ (Me << 1 | he >>> 31), C = X ^ (he << 1 | Me >>> 31), M[6] ^= H, M[7] ^= C, M[16] ^= H, M[17] ^= C, M[26] ^= H, M[27] ^= C, M[36] ^= H, M[37] ^= C, M[46] ^= H, M[47] ^= C, H = ee ^ (L << 1 | y >>> 31), C = we ^ (y << 1 | L >>> 31), M[8] ^= H, M[9] ^= C, M[18] ^= H, M[19] ^= C, M[28] ^= H, M[29] ^= C, M[38] ^= H, M[39] ^= C, M[48] ^= H, M[49] ^= C, Re = M[0], xe = M[1], ye = M[11] << 4 | M[10] >>> 28, Be = M[10] << 4 | M[11] >>> 28, oe = M[20] << 3 | M[21] >>> 29, De = M[21] << 3 | M[20] >>> 29, Kt = M[31] << 9 | M[30] >>> 23, Ht = M[30] << 9 | M[31] >>> 23, Le = M[40] << 18 | M[41] >>> 14, ce = M[41] << 18 | M[40] >>> 14, Ae = M[2] << 1 | M[3] >>> 31, Ze = M[3] << 1 | M[2] >>> 31, se = M[13] << 12 | M[12] >>> 20, ge = M[12] << 12 | M[13] >>> 20, ke = M[22] << 10 | M[23] >>> 22, ve = M[23] << 10 | M[22] >>> 22, Ie = M[33] << 13 | M[32] >>> 19, Pe = M[32] << 13 | M[33] >>> 19, Vt = M[42] << 2 | M[43] >>> 30, gt = M[43] << 2 | M[42] >>> 30, rt = M[5] << 30 | M[4] >>> 2, qe = M[4] << 30 | M[5] >>> 2, et = M[14] << 6 | M[15] >>> 26, Ne = M[15] << 6 | M[14] >>> 26, le = M[25] << 11 | M[24] >>> 21, ne = M[24] << 11 | M[25] >>> 21, Fe = M[34] << 15 | M[35] >>> 17, Oe = M[35] << 15 | M[34] >>> 17, Ge = M[45] << 29 | M[44] >>> 3, Ye = M[44] << 29 | M[45] >>> 3, _e = M[6] << 28 | M[7] >>> 4, re = M[7] << 28 | M[6] >>> 4, it = M[17] << 23 | M[16] >>> 9, Je = M[16] << 23 | M[17] >>> 9, Ce = M[26] << 25 | M[27] >>> 7, Te = M[27] << 25 | M[26] >>> 7, ue = M[36] << 21 | M[37] >>> 11, fe = M[37] << 21 | M[36] >>> 11, me = M[47] << 24 | M[46] >>> 8, je = M[46] << 24 | M[47] >>> 8, Ue = M[8] << 27 | M[9] >>> 5, ze = M[9] << 27 | M[8] >>> 5, Ee = M[18] << 20 | M[19] >>> 12, Se = M[19] << 20 | M[18] >>> 12, tt = M[29] << 7 | M[28] >>> 25, jt = M[28] << 7 | M[29] >>> 25, de = M[38] << 8 | M[39] >>> 24, $e = M[39] << 8 | M[38] >>> 24, te = M[48] << 14 | M[49] >>> 18, pe = M[49] << 14 | M[48] >>> 18, M[0] = Re ^ ~se & le, M[1] = xe ^ ~ge & ne, M[10] = _e ^ ~Ee & oe, M[11] = re ^ ~Se & De, M[20] = Ae ^ ~et & Ce, M[21] = Ze ^ ~Ne & Te, M[30] = Ue ^ ~ye & ke, M[31] = ze ^ ~Be & ve, M[40] = rt ^ ~it & tt, M[41] = qe ^ ~Je & jt, M[2] = se ^ ~le & ue, M[3] = ge ^ ~ne & fe, M[12] = Ee ^ ~oe & Ie, M[13] = Se ^ ~De & Pe, M[22] = et ^ ~Ce & de, M[23] = Ne ^ ~Te & $e, M[32] = ye ^ ~ke & Fe, M[33] = Be ^ ~ve & Oe, M[42] = it ^ ~tt & Kt, M[43] = Je ^ ~jt & Ht, M[4] = le ^ ~ue & te, M[5] = ne ^ ~fe & pe, M[14] = oe ^ ~Ie & Ge, M[15] = De ^ ~Pe & Ye, M[24] = Ce ^ ~de & Le, M[25] = Te ^ ~$e & ce, M[34] = ke ^ ~Fe & me, M[35] = ve ^ ~Oe & je, M[44] = tt ^ ~Kt & Vt, M[45] = jt ^ ~Ht & gt, M[6] = ue ^ ~te & Re, M[7] = fe ^ ~pe & xe, M[16] = Ie ^ ~Ge & _e, M[17] = Pe ^ ~Ye & re, M[26] = de ^ ~Le & Ae, M[27] = $e ^ ~ce & Ze, M[36] = Fe ^ ~me & Ue, M[37] = Oe ^ ~je & ze, M[46] = Kt ^ ~Vt & rt, M[47] = Ht ^ ~gt & qe, M[8] = te ^ ~Re & se, M[9] = pe ^ ~xe & ge, M[18] = Ge ^ ~_e & Ee, M[19] = Ye ^ ~re & Se, M[28] = Le ^ ~Ae & et, M[29] = ce ^ ~Ze & Ne, M[38] = me ^ ~Ue & ye, M[39] = je ^ ~ze & Be, M[48] = Vt ^ ~rt & it, M[49] = gt ^ ~qe & Je, M[0] ^= N[q], M[1] ^= N[q + 1];\n    };\n    if (f)\n      r.exports = a;\n    else\n      for (b = 0; b < c.length; ++b)\n        n[c[b]] = a[c[b]];\n  })();\n})(lu);\nvar Ov = lu.exports;\nconst Rv = /* @__PURE__ */ (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.d)(Ov), Nv = \"logger/5.7.0\";\nlet Qf = !1, ec = !1;\nconst Ps = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };\nlet tc = Ps.default, za = null;\nfunction Tv() {\n  try {\n    const r = [];\n    if ([\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((e) => {\n      try {\n        if (\"test\".normalize(e) !== \"test\")\n          throw new Error(\"bad normalize\");\n      } catch {\n        r.push(e);\n      }\n    }), r.length)\n      throw new Error(\"missing \" + r.join(\", \"));\n    if (String.fromCharCode(233).normalize(\"NFD\") !== String.fromCharCode(101, 769))\n      throw new Error(\"broken implementation\");\n  } catch (r) {\n    return r.message;\n  }\n  return null;\n}\nconst rc = Tv();\nvar yo;\n(function(r) {\n  r.DEBUG = \"DEBUG\", r.INFO = \"INFO\", r.WARNING = \"WARNING\", r.ERROR = \"ERROR\", r.OFF = \"OFF\";\n})(yo || (yo = {}));\nvar Sr;\n(function(r) {\n  r.UNKNOWN_ERROR = \"UNKNOWN_ERROR\", r.NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\", r.UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\", r.NETWORK_ERROR = \"NETWORK_ERROR\", r.SERVER_ERROR = \"SERVER_ERROR\", r.TIMEOUT = \"TIMEOUT\", r.BUFFER_OVERRUN = \"BUFFER_OVERRUN\", r.NUMERIC_FAULT = \"NUMERIC_FAULT\", r.MISSING_NEW = \"MISSING_NEW\", r.INVALID_ARGUMENT = \"INVALID_ARGUMENT\", r.MISSING_ARGUMENT = \"MISSING_ARGUMENT\", r.UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\", r.CALL_EXCEPTION = \"CALL_EXCEPTION\", r.INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\", r.NONCE_EXPIRED = \"NONCE_EXPIRED\", r.REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\", r.UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\", r.TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\", r.ACTION_REJECTED = \"ACTION_REJECTED\";\n})(Sr || (Sr = {}));\nconst ic = \"0123456789abcdef\";\nclass ht {\n  constructor(e) {\n    Object.defineProperty(this, \"version\", {\n      enumerable: !0,\n      value: e,\n      writable: !1\n    });\n  }\n  _log(e, t) {\n    const i = e.toLowerCase();\n    Ps[i] == null && this.throwArgumentError(\"invalid log level name\", \"logLevel\", e), !(tc > Ps[i]) && console.log.apply(console, t);\n  }\n  debug(...e) {\n    this._log(ht.levels.DEBUG, e);\n  }\n  info(...e) {\n    this._log(ht.levels.INFO, e);\n  }\n  warn(...e) {\n    this._log(ht.levels.WARNING, e);\n  }\n  makeError(e, t, i) {\n    if (ec)\n      return this.makeError(\"censored error\", t, {});\n    t || (t = ht.errors.UNKNOWN_ERROR), i || (i = {});\n    const n = [];\n    Object.keys(i).forEach((h) => {\n      const d = i[h];\n      try {\n        if (d instanceof Uint8Array) {\n          let v = \"\";\n          for (let w = 0; w < d.length; w++)\n            v += ic[d[w] >> 4], v += ic[d[w] & 15];\n          n.push(h + \"=Uint8Array(0x\" + v + \")\");\n        } else\n          n.push(h + \"=\" + JSON.stringify(d));\n      } catch {\n        n.push(h + \"=\" + JSON.stringify(i[h].toString()));\n      }\n    }), n.push(`code=${t}`), n.push(`version=${this.version}`);\n    const s = e;\n    let o = \"\";\n    switch (t) {\n      case Sr.NUMERIC_FAULT: {\n        o = \"NUMERIC_FAULT\";\n        const h = e;\n        switch (h) {\n          case \"overflow\":\n          case \"underflow\":\n          case \"division-by-zero\":\n            o += \"-\" + h;\n            break;\n          case \"negative-power\":\n          case \"negative-width\":\n            o += \"-unsupported\";\n            break;\n          case \"unbound-bitwise-result\":\n            o += \"-unbound-result\";\n            break;\n        }\n        break;\n      }\n      case Sr.CALL_EXCEPTION:\n      case Sr.INSUFFICIENT_FUNDS:\n      case Sr.MISSING_NEW:\n      case Sr.NONCE_EXPIRED:\n      case Sr.REPLACEMENT_UNDERPRICED:\n      case Sr.TRANSACTION_REPLACED:\n      case Sr.UNPREDICTABLE_GAS_LIMIT:\n        o = t;\n        break;\n    }\n    o && (e += \" [ See: https://links.ethers.org/v5-errors-\" + o + \" ]\"), n.length && (e += \" (\" + n.join(\", \") + \")\");\n    const f = new Error(e);\n    return f.reason = s, f.code = t, Object.keys(i).forEach(function(h) {\n      f[h] = i[h];\n    }), f;\n  }\n  throwError(e, t, i) {\n    throw this.makeError(e, t, i);\n  }\n  throwArgumentError(e, t, i) {\n    return this.throwError(e, ht.errors.INVALID_ARGUMENT, {\n      argument: t,\n      value: i\n    });\n  }\n  assert(e, t, i, n) {\n    e || this.throwError(t, i, n);\n  }\n  assertArgument(e, t, i, n) {\n    e || this.throwArgumentError(t, i, n);\n  }\n  checkNormalize(e) {\n    rc && this.throwError(\"platform missing String.prototype.normalize\", ht.errors.UNSUPPORTED_OPERATION, {\n      operation: \"String.prototype.normalize\",\n      form: rc\n    });\n  }\n  checkSafeUint53(e, t) {\n    typeof e == \"number\" && (t == null && (t = \"value not safe\"), (e < 0 || e >= 9007199254740991) && this.throwError(t, ht.errors.NUMERIC_FAULT, {\n      operation: \"checkSafeInteger\",\n      fault: \"out-of-safe-range\",\n      value: e\n    }), e % 1 && this.throwError(t, ht.errors.NUMERIC_FAULT, {\n      operation: \"checkSafeInteger\",\n      fault: \"non-integer\",\n      value: e\n    }));\n  }\n  checkArgumentCount(e, t, i) {\n    i ? i = \": \" + i : i = \"\", e < t && this.throwError(\"missing argument\" + i, ht.errors.MISSING_ARGUMENT, {\n      count: e,\n      expectedCount: t\n    }), e > t && this.throwError(\"too many arguments\" + i, ht.errors.UNEXPECTED_ARGUMENT, {\n      count: e,\n      expectedCount: t\n    });\n  }\n  checkNew(e, t) {\n    (e === Object || e == null) && this.throwError(\"missing new\", ht.errors.MISSING_NEW, { name: t.name });\n  }\n  checkAbstract(e, t) {\n    e === t ? this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(t.name) + \" directly; use a sub-class\", ht.errors.UNSUPPORTED_OPERATION, { name: e.name, operation: \"new\" }) : (e === Object || e == null) && this.throwError(\"missing new\", ht.errors.MISSING_NEW, { name: t.name });\n  }\n  static globalLogger() {\n    return za || (za = new ht(Nv)), za;\n  }\n  static setCensorship(e, t) {\n    if (!e && t && this.globalLogger().throwError(\"cannot permanently disable censorship\", ht.errors.UNSUPPORTED_OPERATION, {\n      operation: \"setCensorship\"\n    }), Qf) {\n      if (!e)\n        return;\n      this.globalLogger().throwError(\"error censorship permanent\", ht.errors.UNSUPPORTED_OPERATION, {\n        operation: \"setCensorship\"\n      });\n    }\n    ec = !!e, Qf = !!t;\n  }\n  static setLogLevel(e) {\n    const t = Ps[e.toLowerCase()];\n    if (t == null) {\n      ht.globalLogger().warn(\"invalid log level - \" + e);\n      return;\n    }\n    tc = t;\n  }\n  static from(e) {\n    return new ht(e);\n  }\n}\nht.errors = Sr;\nht.levels = yo;\nconst Cv = \"bytes/5.7.0\", vt = new ht(Cv);\nfunction pu(r) {\n  return !!r.toHexString;\n}\nfunction cn(r) {\n  return r.slice || (r.slice = function() {\n    const e = Array.prototype.slice.call(arguments);\n    return cn(new Uint8Array(Array.prototype.slice.apply(r, e)));\n  }), r;\n}\nfunction $v(r) {\n  return Lr(r) && !(r.length % 2) || Fo(r);\n}\nfunction nc(r) {\n  return typeof r == \"number\" && r == r && r % 1 === 0;\n}\nfunction Fo(r) {\n  if (r == null)\n    return !1;\n  if (r.constructor === Uint8Array)\n    return !0;\n  if (typeof r == \"string\" || !nc(r.length) || r.length < 0)\n    return !1;\n  for (let e = 0; e < r.length; e++) {\n    const t = r[e];\n    if (!nc(t) || t < 0 || t >= 256)\n      return !1;\n  }\n  return !0;\n}\nfunction yt(r, e) {\n  if (e || (e = {}), typeof r == \"number\") {\n    vt.checkSafeUint53(r, \"invalid arrayify value\");\n    const t = [];\n    for (; r; )\n      t.unshift(r & 255), r = parseInt(String(r / 256));\n    return t.length === 0 && t.push(0), cn(new Uint8Array(t));\n  }\n  if (e.allowMissingPrefix && typeof r == \"string\" && r.substring(0, 2) !== \"0x\" && (r = \"0x\" + r), pu(r) && (r = r.toHexString()), Lr(r)) {\n    let t = r.substring(2);\n    t.length % 2 && (e.hexPad === \"left\" ? t = \"0\" + t : e.hexPad === \"right\" ? t += \"0\" : vt.throwArgumentError(\"hex data is odd-length\", \"value\", r));\n    const i = [];\n    for (let n = 0; n < t.length; n += 2)\n      i.push(parseInt(t.substring(n, n + 2), 16));\n    return cn(new Uint8Array(i));\n  }\n  return Fo(r) ? cn(new Uint8Array(r)) : vt.throwArgumentError(\"invalid arrayify value\", \"value\", r);\n}\nfunction Lv(r) {\n  const e = r.map((n) => yt(n)), t = e.reduce((n, s) => n + s.length, 0), i = new Uint8Array(t);\n  return e.reduce((n, s) => (i.set(s, n), n + s.length), 0), cn(i);\n}\nfunction Fv(r, e) {\n  r = yt(r), r.length > e && vt.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n  const t = new Uint8Array(e);\n  return t.set(r, e - r.length), cn(t);\n}\nfunction Lr(r, e) {\n  return !(typeof r != \"string\" || !r.match(/^0x[0-9A-Fa-f]*$/) || e && r.length !== 2 + 2 * e);\n}\nconst Ba = \"0123456789abcdef\";\nfunction Jt(r, e) {\n  if (e || (e = {}), typeof r == \"number\") {\n    vt.checkSafeUint53(r, \"invalid hexlify value\");\n    let t = \"\";\n    for (; r; )\n      t = Ba[r & 15] + t, r = Math.floor(r / 16);\n    return t.length ? (t.length % 2 && (t = \"0\" + t), \"0x\" + t) : \"0x00\";\n  }\n  if (typeof r == \"bigint\")\n    return r = r.toString(16), r.length % 2 ? \"0x0\" + r : \"0x\" + r;\n  if (e.allowMissingPrefix && typeof r == \"string\" && r.substring(0, 2) !== \"0x\" && (r = \"0x\" + r), pu(r))\n    return r.toHexString();\n  if (Lr(r))\n    return r.length % 2 && (e.hexPad === \"left\" ? r = \"0x0\" + r.substring(2) : e.hexPad === \"right\" ? r += \"0\" : vt.throwArgumentError(\"hex data is odd-length\", \"value\", r)), r.toLowerCase();\n  if (Fo(r)) {\n    let t = \"0x\";\n    for (let i = 0; i < r.length; i++) {\n      let n = r[i];\n      t += Ba[(n & 240) >> 4] + Ba[n & 15];\n    }\n    return t;\n  }\n  return vt.throwArgumentError(\"invalid hexlify value\", \"value\", r);\n}\nfunction qv(r) {\n  if (typeof r != \"string\")\n    r = Jt(r);\n  else if (!Lr(r) || r.length % 2)\n    return null;\n  return (r.length - 2) / 2;\n}\nfunction sc(r, e, t) {\n  return typeof r != \"string\" ? r = Jt(r) : (!Lr(r) || r.length % 2) && vt.throwArgumentError(\"invalid hexData\", \"value\", r), e = 2 + 2 * e, t != null ? \"0x\" + r.substring(e, 2 + 2 * t) : \"0x\" + r.substring(e);\n}\nfunction hn(r, e) {\n  for (typeof r != \"string\" ? r = Jt(r) : Lr(r) || vt.throwArgumentError(\"invalid hex string\", \"value\", r), r.length > 2 * e + 2 && vt.throwArgumentError(\"value out of range\", \"value\", arguments[1]); r.length < 2 * e + 2; )\n    r = \"0x0\" + r.substring(2);\n  return r;\n}\nfunction vu(r) {\n  const e = {\n    r: \"0x\",\n    s: \"0x\",\n    _vs: \"0x\",\n    recoveryParam: 0,\n    v: 0,\n    yParityAndS: \"0x\",\n    compact: \"0x\"\n  };\n  if ($v(r)) {\n    let t = yt(r);\n    t.length === 64 ? (e.v = 27 + (t[32] >> 7), t[32] &= 127, e.r = Jt(t.slice(0, 32)), e.s = Jt(t.slice(32, 64))) : t.length === 65 ? (e.r = Jt(t.slice(0, 32)), e.s = Jt(t.slice(32, 64)), e.v = t[64]) : vt.throwArgumentError(\"invalid signature string\", \"signature\", r), e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : vt.throwArgumentError(\"signature invalid v byte\", \"signature\", r)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (t[32] |= 128), e._vs = Jt(t.slice(32, 64));\n  } else {\n    if (e.r = r.r, e.s = r.s, e.v = r.v, e.recoveryParam = r.recoveryParam, e._vs = r._vs, e._vs != null) {\n      const n = Fv(yt(e._vs), 32);\n      e._vs = Jt(n);\n      const s = n[0] >= 128 ? 1 : 0;\n      e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && vt.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", r), n[0] &= 127;\n      const o = Jt(n);\n      e.s == null ? e.s = o : e.s !== o && vt.throwArgumentError(\"signature v mismatch _vs\", \"signature\", r);\n    }\n    if (e.recoveryParam == null)\n      e.v == null ? vt.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", r) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;\n    else if (e.v == null)\n      e.v = 27 + e.recoveryParam;\n    else {\n      const n = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;\n      e.recoveryParam !== n && vt.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", r);\n    }\n    e.r == null || !Lr(e.r) ? vt.throwArgumentError(\"signature missing or invalid r\", \"signature\", r) : e.r = hn(e.r, 32), e.s == null || !Lr(e.s) ? vt.throwArgumentError(\"signature missing or invalid s\", \"signature\", r) : e.s = hn(e.s, 32);\n    const t = yt(e.s);\n    t[0] >= 128 && vt.throwArgumentError(\"signature s out of range\", \"signature\", r), e.recoveryParam && (t[0] |= 128);\n    const i = Jt(t);\n    e._vs && (Lr(e._vs) || vt.throwArgumentError(\"signature invalid _vs\", \"signature\", r), e._vs = hn(e._vs, 32)), e._vs == null ? e._vs = i : e._vs !== i && vt.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", r);\n  }\n  return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e;\n}\nfunction qo(r) {\n  return \"0x\" + Rv.keccak_256(yt(r));\n}\nvar Uo = { exports: {} };\nUo.exports;\n(function(r) {\n  (function(e, t) {\n    function i(l, a) {\n      if (!l)\n        throw new Error(a || \"Assertion failed\");\n    }\n    function n(l, a) {\n      l.super_ = a;\n      var c = function() {\n      };\n      c.prototype = a.prototype, l.prototype = new c(), l.prototype.constructor = l;\n    }\n    function s(l, a, c) {\n      if (s.isBN(l))\n        return l;\n      this.negative = 0, this.words = null, this.length = 0, this.red = null, l !== null && ((a === \"le\" || a === \"be\") && (c = a, a = 10), this._init(l || 0, a || 10, c || \"be\"));\n    }\n    typeof e == \"object\" ? e.exports = s : t.BN = s, s.BN = s, s.wordSize = 26;\n    var o;\n    try {\n      typeof window < \"u\" && typeof window.Buffer < \"u\" ? o = window.Buffer : o = fa.Buffer;\n    } catch {\n    }\n    s.isBN = function(a) {\n      return a instanceof s ? !0 : a !== null && typeof a == \"object\" && a.constructor.wordSize === s.wordSize && Array.isArray(a.words);\n    }, s.max = function(a, c) {\n      return a.cmp(c) > 0 ? a : c;\n    }, s.min = function(a, c) {\n      return a.cmp(c) < 0 ? a : c;\n    }, s.prototype._init = function(a, c, b) {\n      if (typeof a == \"number\")\n        return this._initNumber(a, c, b);\n      if (typeof a == \"object\")\n        return this._initArray(a, c, b);\n      c === \"hex\" && (c = 16), i(c === (c | 0) && c >= 2 && c <= 36), a = a.toString().replace(/\\s+/g, \"\");\n      var E = 0;\n      a[0] === \"-\" && (E++, this.negative = 1), E < a.length && (c === 16 ? this._parseHex(a, E, b) : (this._parseBase(a, c, E), b === \"le\" && this._initArray(this.toArray(), c, b)));\n    }, s.prototype._initNumber = function(a, c, b) {\n      a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [\n        a & 67108863,\n        a / 67108864 & 67108863\n      ], this.length = 2) : (i(a < 9007199254740992), this.words = [\n        a & 67108863,\n        a / 67108864 & 67108863,\n        1\n      ], this.length = 3), b === \"le\" && this._initArray(this.toArray(), c, b);\n    }, s.prototype._initArray = function(a, c, b) {\n      if (i(typeof a.length == \"number\"), a.length <= 0)\n        return this.words = [0], this.length = 1, this;\n      this.length = Math.ceil(a.length / 3), this.words = new Array(this.length);\n      for (var E = 0; E < this.length; E++)\n        this.words[E] = 0;\n      var S, x, u = 0;\n      if (b === \"be\")\n        for (E = a.length - 1, S = 0; E >= 0; E -= 3)\n          x = a[E] | a[E - 1] << 8 | a[E - 2] << 16, this.words[S] |= x << u & 67108863, this.words[S + 1] = x >>> 26 - u & 67108863, u += 24, u >= 26 && (u -= 26, S++);\n      else if (b === \"le\")\n        for (E = 0, S = 0; E < a.length; E += 3)\n          x = a[E] | a[E + 1] << 8 | a[E + 2] << 16, this.words[S] |= x << u & 67108863, this.words[S + 1] = x >>> 26 - u & 67108863, u += 24, u >= 26 && (u -= 26, S++);\n      return this._strip();\n    };\n    function f(l, a) {\n      var c = l.charCodeAt(a);\n      if (c >= 48 && c <= 57)\n        return c - 48;\n      if (c >= 65 && c <= 70)\n        return c - 55;\n      if (c >= 97 && c <= 102)\n        return c - 87;\n      i(!1, \"Invalid character in \" + l);\n    }\n    function h(l, a, c) {\n      var b = f(l, c);\n      return c - 1 >= a && (b |= f(l, c - 1) << 4), b;\n    }\n    s.prototype._parseHex = function(a, c, b) {\n      this.length = Math.ceil((a.length - c) / 6), this.words = new Array(this.length);\n      for (var E = 0; E < this.length; E++)\n        this.words[E] = 0;\n      var S = 0, x = 0, u;\n      if (b === \"be\")\n        for (E = a.length - 1; E >= c; E -= 2)\n          u = h(a, c, E) << S, this.words[x] |= u & 67108863, S >= 18 ? (S -= 18, x += 1, this.words[x] |= u >>> 26) : S += 8;\n      else {\n        var m = a.length - c;\n        for (E = m % 2 === 0 ? c + 1 : c; E < a.length; E += 2)\n          u = h(a, c, E) << S, this.words[x] |= u & 67108863, S >= 18 ? (S -= 18, x += 1, this.words[x] |= u >>> 26) : S += 8;\n      }\n      this._strip();\n    };\n    function d(l, a, c, b) {\n      for (var E = 0, S = 0, x = Math.min(l.length, c), u = a; u < x; u++) {\n        var m = l.charCodeAt(u) - 48;\n        E *= b, m >= 49 ? S = m - 49 + 10 : m >= 17 ? S = m - 17 + 10 : S = m, i(m >= 0 && S < b, \"Invalid character\"), E += S;\n      }\n      return E;\n    }\n    s.prototype._parseBase = function(a, c, b) {\n      this.words = [0], this.length = 1;\n      for (var E = 0, S = 1; S <= 67108863; S *= c)\n        E++;\n      E--, S = S / c | 0;\n      for (var x = a.length - b, u = x % E, m = Math.min(x, x - u) + b, g = 0, P = b; P < m; P += E)\n        g = d(a, P, P + E, c), this.imuln(S), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);\n      if (u !== 0) {\n        var G = 1;\n        for (g = d(a, P, a.length, c), P = 0; P < u; P++)\n          G *= c;\n        this.imuln(G), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);\n      }\n      this._strip();\n    }, s.prototype.copy = function(a) {\n      a.words = new Array(this.length);\n      for (var c = 0; c < this.length; c++)\n        a.words[c] = this.words[c];\n      a.length = this.length, a.negative = this.negative, a.red = this.red;\n    };\n    function v(l, a) {\n      l.words = a.words, l.length = a.length, l.negative = a.negative, l.red = a.red;\n    }\n    if (s.prototype._move = function(a) {\n      v(a, this);\n    }, s.prototype.clone = function() {\n      var a = new s(null);\n      return this.copy(a), a;\n    }, s.prototype._expand = function(a) {\n      for (; this.length < a; )\n        this.words[this.length++] = 0;\n      return this;\n    }, s.prototype._strip = function() {\n      for (; this.length > 1 && this.words[this.length - 1] === 0; )\n        this.length--;\n      return this._normSign();\n    }, s.prototype._normSign = function() {\n      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;\n    }, typeof Symbol < \"u\" && typeof Symbol.for == \"function\")\n      try {\n        s.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = w;\n      } catch {\n        s.prototype.inspect = w;\n      }\n    else\n      s.prototype.inspect = w;\n    function w() {\n      return (this.red ? \"<BN-R: \" : \"<BN: \") + this.toString(16) + \">\";\n    }\n    var A = [\n      \"\",\n      \"0\",\n      \"00\",\n      \"000\",\n      \"0000\",\n      \"00000\",\n      \"000000\",\n      \"0000000\",\n      \"00000000\",\n      \"000000000\",\n      \"0000000000\",\n      \"00000000000\",\n      \"000000000000\",\n      \"0000000000000\",\n      \"00000000000000\",\n      \"000000000000000\",\n      \"0000000000000000\",\n      \"00000000000000000\",\n      \"000000000000000000\",\n      \"0000000000000000000\",\n      \"00000000000000000000\",\n      \"000000000000000000000\",\n      \"0000000000000000000000\",\n      \"00000000000000000000000\",\n      \"000000000000000000000000\",\n      \"0000000000000000000000000\"\n    ], I = [\n      0,\n      0,\n      25,\n      16,\n      12,\n      11,\n      10,\n      9,\n      8,\n      8,\n      7,\n      7,\n      7,\n      7,\n      6,\n      6,\n      6,\n      6,\n      6,\n      6,\n      6,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5\n    ], D = [\n      0,\n      0,\n      33554432,\n      43046721,\n      16777216,\n      48828125,\n      60466176,\n      40353607,\n      16777216,\n      43046721,\n      1e7,\n      19487171,\n      35831808,\n      62748517,\n      7529536,\n      11390625,\n      16777216,\n      24137569,\n      34012224,\n      47045881,\n      64e6,\n      4084101,\n      5153632,\n      6436343,\n      7962624,\n      9765625,\n      11881376,\n      14348907,\n      17210368,\n      20511149,\n      243e5,\n      28629151,\n      33554432,\n      39135393,\n      45435424,\n      52521875,\n      60466176\n    ];\n    s.prototype.toString = function(a, c) {\n      a = a || 10, c = c | 0 || 1;\n      var b;\n      if (a === 16 || a === \"hex\") {\n        b = \"\";\n        for (var E = 0, S = 0, x = 0; x < this.length; x++) {\n          var u = this.words[x], m = ((u << E | S) & 16777215).toString(16);\n          S = u >>> 24 - E & 16777215, E += 2, E >= 26 && (E -= 26, x--), S !== 0 || x !== this.length - 1 ? b = A[6 - m.length] + m + b : b = m + b;\n        }\n        for (S !== 0 && (b = S.toString(16) + b); b.length % c !== 0; )\n          b = \"0\" + b;\n        return this.negative !== 0 && (b = \"-\" + b), b;\n      }\n      if (a === (a | 0) && a >= 2 && a <= 36) {\n        var g = I[a], P = D[a];\n        b = \"\";\n        var G = this.clone();\n        for (G.negative = 0; !G.isZero(); ) {\n          var M = G.modrn(P).toString(a);\n          G = G.idivn(P), G.isZero() ? b = M + b : b = A[g - M.length] + M + b;\n        }\n        for (this.isZero() && (b = \"0\" + b); b.length % c !== 0; )\n          b = \"0\" + b;\n        return this.negative !== 0 && (b = \"-\" + b), b;\n      }\n      i(!1, \"Base should be between 2 and 36\");\n    }, s.prototype.toNumber = function() {\n      var a = this.words[0];\n      return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, \"Number can only safely store up to 53 bits\"), this.negative !== 0 ? -a : a;\n    }, s.prototype.toJSON = function() {\n      return this.toString(16, 2);\n    }, o && (s.prototype.toBuffer = function(a, c) {\n      return this.toArrayLike(o, a, c);\n    }), s.prototype.toArray = function(a, c) {\n      return this.toArrayLike(Array, a, c);\n    };\n    var N = function(a, c) {\n      return a.allocUnsafe ? a.allocUnsafe(c) : new a(c);\n    };\n    s.prototype.toArrayLike = function(a, c, b) {\n      this._strip();\n      var E = this.byteLength(), S = b || Math.max(1, E);\n      i(E <= S, \"byte array longer than desired length\"), i(S > 0, \"Requested array length <= 0\");\n      var x = N(a, S), u = c === \"le\" ? \"LE\" : \"BE\";\n      return this[\"_toArrayLike\" + u](x, E), x;\n    }, s.prototype._toArrayLikeLE = function(a, c) {\n      for (var b = 0, E = 0, S = 0, x = 0; S < this.length; S++) {\n        var u = this.words[S] << x | E;\n        a[b++] = u & 255, b < a.length && (a[b++] = u >> 8 & 255), b < a.length && (a[b++] = u >> 16 & 255), x === 6 ? (b < a.length && (a[b++] = u >> 24 & 255), E = 0, x = 0) : (E = u >>> 24, x += 2);\n      }\n      if (b < a.length)\n        for (a[b++] = E; b < a.length; )\n          a[b++] = 0;\n    }, s.prototype._toArrayLikeBE = function(a, c) {\n      for (var b = a.length - 1, E = 0, S = 0, x = 0; S < this.length; S++) {\n        var u = this.words[S] << x | E;\n        a[b--] = u & 255, b >= 0 && (a[b--] = u >> 8 & 255), b >= 0 && (a[b--] = u >> 16 & 255), x === 6 ? (b >= 0 && (a[b--] = u >> 24 & 255), E = 0, x = 0) : (E = u >>> 24, x += 2);\n      }\n      if (b >= 0)\n        for (a[b--] = E; b >= 0; )\n          a[b--] = 0;\n    }, Math.clz32 ? s.prototype._countBits = function(a) {\n      return 32 - Math.clz32(a);\n    } : s.prototype._countBits = function(a) {\n      var c = a, b = 0;\n      return c >= 4096 && (b += 13, c >>>= 13), c >= 64 && (b += 7, c >>>= 7), c >= 8 && (b += 4, c >>>= 4), c >= 2 && (b += 2, c >>>= 2), b + c;\n    }, s.prototype._zeroBits = function(a) {\n      if (a === 0)\n        return 26;\n      var c = a, b = 0;\n      return c & 8191 || (b += 13, c >>>= 13), c & 127 || (b += 7, c >>>= 7), c & 15 || (b += 4, c >>>= 4), c & 3 || (b += 2, c >>>= 2), c & 1 || b++, b;\n    }, s.prototype.bitLength = function() {\n      var a = this.words[this.length - 1], c = this._countBits(a);\n      return (this.length - 1) * 26 + c;\n    };\n    function k(l) {\n      for (var a = new Array(l.bitLength()), c = 0; c < a.length; c++) {\n        var b = c / 26 | 0, E = c % 26;\n        a[c] = l.words[b] >>> E & 1;\n      }\n      return a;\n    }\n    s.prototype.zeroBits = function() {\n      if (this.isZero())\n        return 0;\n      for (var a = 0, c = 0; c < this.length; c++) {\n        var b = this._zeroBits(this.words[c]);\n        if (a += b, b !== 26)\n          break;\n      }\n      return a;\n    }, s.prototype.byteLength = function() {\n      return Math.ceil(this.bitLength() / 8);\n    }, s.prototype.toTwos = function(a) {\n      return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone();\n    }, s.prototype.fromTwos = function(a) {\n      return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone();\n    }, s.prototype.isNeg = function() {\n      return this.negative !== 0;\n    }, s.prototype.neg = function() {\n      return this.clone().ineg();\n    }, s.prototype.ineg = function() {\n      return this.isZero() || (this.negative ^= 1), this;\n    }, s.prototype.iuor = function(a) {\n      for (; this.length < a.length; )\n        this.words[this.length++] = 0;\n      for (var c = 0; c < a.length; c++)\n        this.words[c] = this.words[c] | a.words[c];\n      return this._strip();\n    }, s.prototype.ior = function(a) {\n      return i((this.negative | a.negative) === 0), this.iuor(a);\n    }, s.prototype.or = function(a) {\n      return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this);\n    }, s.prototype.uor = function(a) {\n      return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this);\n    }, s.prototype.iuand = function(a) {\n      var c;\n      this.length > a.length ? c = a : c = this;\n      for (var b = 0; b < c.length; b++)\n        this.words[b] = this.words[b] & a.words[b];\n      return this.length = c.length, this._strip();\n    }, s.prototype.iand = function(a) {\n      return i((this.negative | a.negative) === 0), this.iuand(a);\n    }, s.prototype.and = function(a) {\n      return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this);\n    }, s.prototype.uand = function(a) {\n      return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this);\n    }, s.prototype.iuxor = function(a) {\n      var c, b;\n      this.length > a.length ? (c = this, b = a) : (c = a, b = this);\n      for (var E = 0; E < b.length; E++)\n        this.words[E] = c.words[E] ^ b.words[E];\n      if (this !== c)\n        for (; E < c.length; E++)\n          this.words[E] = c.words[E];\n      return this.length = c.length, this._strip();\n    }, s.prototype.ixor = function(a) {\n      return i((this.negative | a.negative) === 0), this.iuxor(a);\n    }, s.prototype.xor = function(a) {\n      return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this);\n    }, s.prototype.uxor = function(a) {\n      return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this);\n    }, s.prototype.inotn = function(a) {\n      i(typeof a == \"number\" && a >= 0);\n      var c = Math.ceil(a / 26) | 0, b = a % 26;\n      this._expand(c), b > 0 && c--;\n      for (var E = 0; E < c; E++)\n        this.words[E] = ~this.words[E] & 67108863;\n      return b > 0 && (this.words[E] = ~this.words[E] & 67108863 >> 26 - b), this._strip();\n    }, s.prototype.notn = function(a) {\n      return this.clone().inotn(a);\n    }, s.prototype.setn = function(a, c) {\n      i(typeof a == \"number\" && a >= 0);\n      var b = a / 26 | 0, E = a % 26;\n      return this._expand(b + 1), c ? this.words[b] = this.words[b] | 1 << E : this.words[b] = this.words[b] & ~(1 << E), this._strip();\n    }, s.prototype.iadd = function(a) {\n      var c;\n      if (this.negative !== 0 && a.negative === 0)\n        return this.negative = 0, c = this.isub(a), this.negative ^= 1, this._normSign();\n      if (this.negative === 0 && a.negative !== 0)\n        return a.negative = 0, c = this.isub(a), a.negative = 1, c._normSign();\n      var b, E;\n      this.length > a.length ? (b = this, E = a) : (b = a, E = this);\n      for (var S = 0, x = 0; x < E.length; x++)\n        c = (b.words[x] | 0) + (E.words[x] | 0) + S, this.words[x] = c & 67108863, S = c >>> 26;\n      for (; S !== 0 && x < b.length; x++)\n        c = (b.words[x] | 0) + S, this.words[x] = c & 67108863, S = c >>> 26;\n      if (this.length = b.length, S !== 0)\n        this.words[this.length] = S, this.length++;\n      else if (b !== this)\n        for (; x < b.length; x++)\n          this.words[x] = b.words[x];\n      return this;\n    }, s.prototype.add = function(a) {\n      var c;\n      return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, c = this.sub(a), a.negative ^= 1, c) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, c = a.sub(this), this.negative = 1, c) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this);\n    }, s.prototype.isub = function(a) {\n      if (a.negative !== 0) {\n        a.negative = 0;\n        var c = this.iadd(a);\n        return a.negative = 1, c._normSign();\n      } else if (this.negative !== 0)\n        return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign();\n      var b = this.cmp(a);\n      if (b === 0)\n        return this.negative = 0, this.length = 1, this.words[0] = 0, this;\n      var E, S;\n      b > 0 ? (E = this, S = a) : (E = a, S = this);\n      for (var x = 0, u = 0; u < S.length; u++)\n        c = (E.words[u] | 0) - (S.words[u] | 0) + x, x = c >> 26, this.words[u] = c & 67108863;\n      for (; x !== 0 && u < E.length; u++)\n        c = (E.words[u] | 0) + x, x = c >> 26, this.words[u] = c & 67108863;\n      if (x === 0 && u < E.length && E !== this)\n        for (; u < E.length; u++)\n          this.words[u] = E.words[u];\n      return this.length = Math.max(this.length, u), E !== this && (this.negative = 1), this._strip();\n    }, s.prototype.sub = function(a) {\n      return this.clone().isub(a);\n    };\n    function j(l, a, c) {\n      c.negative = a.negative ^ l.negative;\n      var b = l.length + a.length | 0;\n      c.length = b, b = b - 1 | 0;\n      var E = l.words[0] | 0, S = a.words[0] | 0, x = E * S, u = x & 67108863, m = x / 67108864 | 0;\n      c.words[0] = u;\n      for (var g = 1; g < b; g++) {\n        for (var P = m >>> 26, G = m & 67108863, M = Math.min(g, a.length - 1), H = Math.max(0, g - l.length + 1); H <= M; H++) {\n          var C = g - H | 0;\n          E = l.words[C] | 0, S = a.words[H] | 0, x = E * S + G, P += x / 67108864 | 0, G = x & 67108863;\n        }\n        c.words[g] = G | 0, m = P | 0;\n      }\n      return m !== 0 ? c.words[g] = m | 0 : c.length--, c._strip();\n    }\n    var T = function(a, c, b) {\n      var E = a.words, S = c.words, x = b.words, u = 0, m, g, P, G = E[0] | 0, M = G & 8191, H = G >>> 13, C = E[1] | 0, q = C & 8191, L = C >>> 13, y = E[2] | 0, F = y & 8191, W = y >>> 13, Y = E[3] | 0, X = Y & 8191, ee = Y >>> 13, we = E[4] | 0, Me = we & 8191, he = we >>> 13, Re = E[5] | 0, xe = Re & 8191, se = Re >>> 13, ge = E[6] | 0, le = ge & 8191, ne = ge >>> 13, ue = E[7] | 0, fe = ue & 8191, te = ue >>> 13, pe = E[8] | 0, _e = pe & 8191, re = pe >>> 13, Ee = E[9] | 0, Se = Ee & 8191, oe = Ee >>> 13, De = S[0] | 0, Ie = De & 8191, Pe = De >>> 13, Ge = S[1] | 0, Ye = Ge & 8191, Ae = Ge >>> 13, Ze = S[2] | 0, et = Ze & 8191, Ne = Ze >>> 13, Ce = S[3] | 0, Te = Ce & 8191, de = Ce >>> 13, $e = S[4] | 0, Le = $e & 8191, ce = $e >>> 13, Ue = S[5] | 0, ze = Ue & 8191, ye = Ue >>> 13, Be = S[6] | 0, ke = Be & 8191, ve = Be >>> 13, Fe = S[7] | 0, Oe = Fe & 8191, me = Fe >>> 13, je = S[8] | 0, rt = je & 8191, qe = je >>> 13, it = S[9] | 0, Je = it & 8191, tt = it >>> 13;\n      b.negative = a.negative ^ c.negative, b.length = 19, m = Math.imul(M, Ie), g = Math.imul(M, Pe), g = g + Math.imul(H, Ie) | 0, P = Math.imul(H, Pe);\n      var jt = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, m = Math.imul(q, Ie), g = Math.imul(q, Pe), g = g + Math.imul(L, Ie) | 0, P = Math.imul(L, Pe), m = m + Math.imul(M, Ye) | 0, g = g + Math.imul(M, Ae) | 0, g = g + Math.imul(H, Ye) | 0, P = P + Math.imul(H, Ae) | 0;\n      var Kt = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, m = Math.imul(F, Ie), g = Math.imul(F, Pe), g = g + Math.imul(W, Ie) | 0, P = Math.imul(W, Pe), m = m + Math.imul(q, Ye) | 0, g = g + Math.imul(q, Ae) | 0, g = g + Math.imul(L, Ye) | 0, P = P + Math.imul(L, Ae) | 0, m = m + Math.imul(M, et) | 0, g = g + Math.imul(M, Ne) | 0, g = g + Math.imul(H, et) | 0, P = P + Math.imul(H, Ne) | 0;\n      var Ht = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, m = Math.imul(X, Ie), g = Math.imul(X, Pe), g = g + Math.imul(ee, Ie) | 0, P = Math.imul(ee, Pe), m = m + Math.imul(F, Ye) | 0, g = g + Math.imul(F, Ae) | 0, g = g + Math.imul(W, Ye) | 0, P = P + Math.imul(W, Ae) | 0, m = m + Math.imul(q, et) | 0, g = g + Math.imul(q, Ne) | 0, g = g + Math.imul(L, et) | 0, P = P + Math.imul(L, Ne) | 0, m = m + Math.imul(M, Te) | 0, g = g + Math.imul(M, de) | 0, g = g + Math.imul(H, Te) | 0, P = P + Math.imul(H, de) | 0;\n      var Vt = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (Vt >>> 26) | 0, Vt &= 67108863, m = Math.imul(Me, Ie), g = Math.imul(Me, Pe), g = g + Math.imul(he, Ie) | 0, P = Math.imul(he, Pe), m = m + Math.imul(X, Ye) | 0, g = g + Math.imul(X, Ae) | 0, g = g + Math.imul(ee, Ye) | 0, P = P + Math.imul(ee, Ae) | 0, m = m + Math.imul(F, et) | 0, g = g + Math.imul(F, Ne) | 0, g = g + Math.imul(W, et) | 0, P = P + Math.imul(W, Ne) | 0, m = m + Math.imul(q, Te) | 0, g = g + Math.imul(q, de) | 0, g = g + Math.imul(L, Te) | 0, P = P + Math.imul(L, de) | 0, m = m + Math.imul(M, Le) | 0, g = g + Math.imul(M, ce) | 0, g = g + Math.imul(H, Le) | 0, P = P + Math.imul(H, ce) | 0;\n      var gt = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, m = Math.imul(xe, Ie), g = Math.imul(xe, Pe), g = g + Math.imul(se, Ie) | 0, P = Math.imul(se, Pe), m = m + Math.imul(Me, Ye) | 0, g = g + Math.imul(Me, Ae) | 0, g = g + Math.imul(he, Ye) | 0, P = P + Math.imul(he, Ae) | 0, m = m + Math.imul(X, et) | 0, g = g + Math.imul(X, Ne) | 0, g = g + Math.imul(ee, et) | 0, P = P + Math.imul(ee, Ne) | 0, m = m + Math.imul(F, Te) | 0, g = g + Math.imul(F, de) | 0, g = g + Math.imul(W, Te) | 0, P = P + Math.imul(W, de) | 0, m = m + Math.imul(q, Le) | 0, g = g + Math.imul(q, ce) | 0, g = g + Math.imul(L, Le) | 0, P = P + Math.imul(L, ce) | 0, m = m + Math.imul(M, ze) | 0, g = g + Math.imul(M, ye) | 0, g = g + Math.imul(H, ze) | 0, P = P + Math.imul(H, ye) | 0;\n      var Vr = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, m = Math.imul(le, Ie), g = Math.imul(le, Pe), g = g + Math.imul(ne, Ie) | 0, P = Math.imul(ne, Pe), m = m + Math.imul(xe, Ye) | 0, g = g + Math.imul(xe, Ae) | 0, g = g + Math.imul(se, Ye) | 0, P = P + Math.imul(se, Ae) | 0, m = m + Math.imul(Me, et) | 0, g = g + Math.imul(Me, Ne) | 0, g = g + Math.imul(he, et) | 0, P = P + Math.imul(he, Ne) | 0, m = m + Math.imul(X, Te) | 0, g = g + Math.imul(X, de) | 0, g = g + Math.imul(ee, Te) | 0, P = P + Math.imul(ee, de) | 0, m = m + Math.imul(F, Le) | 0, g = g + Math.imul(F, ce) | 0, g = g + Math.imul(W, Le) | 0, P = P + Math.imul(W, ce) | 0, m = m + Math.imul(q, ze) | 0, g = g + Math.imul(q, ye) | 0, g = g + Math.imul(L, ze) | 0, P = P + Math.imul(L, ye) | 0, m = m + Math.imul(M, ke) | 0, g = g + Math.imul(M, ve) | 0, g = g + Math.imul(H, ke) | 0, P = P + Math.imul(H, ve) | 0;\n      var Wr = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, m = Math.imul(fe, Ie), g = Math.imul(fe, Pe), g = g + Math.imul(te, Ie) | 0, P = Math.imul(te, Pe), m = m + Math.imul(le, Ye) | 0, g = g + Math.imul(le, Ae) | 0, g = g + Math.imul(ne, Ye) | 0, P = P + Math.imul(ne, Ae) | 0, m = m + Math.imul(xe, et) | 0, g = g + Math.imul(xe, Ne) | 0, g = g + Math.imul(se, et) | 0, P = P + Math.imul(se, Ne) | 0, m = m + Math.imul(Me, Te) | 0, g = g + Math.imul(Me, de) | 0, g = g + Math.imul(he, Te) | 0, P = P + Math.imul(he, de) | 0, m = m + Math.imul(X, Le) | 0, g = g + Math.imul(X, ce) | 0, g = g + Math.imul(ee, Le) | 0, P = P + Math.imul(ee, ce) | 0, m = m + Math.imul(F, ze) | 0, g = g + Math.imul(F, ye) | 0, g = g + Math.imul(W, ze) | 0, P = P + Math.imul(W, ye) | 0, m = m + Math.imul(q, ke) | 0, g = g + Math.imul(q, ve) | 0, g = g + Math.imul(L, ke) | 0, P = P + Math.imul(L, ve) | 0, m = m + Math.imul(M, Oe) | 0, g = g + Math.imul(M, me) | 0, g = g + Math.imul(H, Oe) | 0, P = P + Math.imul(H, me) | 0;\n      var Gr = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, m = Math.imul(_e, Ie), g = Math.imul(_e, Pe), g = g + Math.imul(re, Ie) | 0, P = Math.imul(re, Pe), m = m + Math.imul(fe, Ye) | 0, g = g + Math.imul(fe, Ae) | 0, g = g + Math.imul(te, Ye) | 0, P = P + Math.imul(te, Ae) | 0, m = m + Math.imul(le, et) | 0, g = g + Math.imul(le, Ne) | 0, g = g + Math.imul(ne, et) | 0, P = P + Math.imul(ne, Ne) | 0, m = m + Math.imul(xe, Te) | 0, g = g + Math.imul(xe, de) | 0, g = g + Math.imul(se, Te) | 0, P = P + Math.imul(se, de) | 0, m = m + Math.imul(Me, Le) | 0, g = g + Math.imul(Me, ce) | 0, g = g + Math.imul(he, Le) | 0, P = P + Math.imul(he, ce) | 0, m = m + Math.imul(X, ze) | 0, g = g + Math.imul(X, ye) | 0, g = g + Math.imul(ee, ze) | 0, P = P + Math.imul(ee, ye) | 0, m = m + Math.imul(F, ke) | 0, g = g + Math.imul(F, ve) | 0, g = g + Math.imul(W, ke) | 0, P = P + Math.imul(W, ve) | 0, m = m + Math.imul(q, Oe) | 0, g = g + Math.imul(q, me) | 0, g = g + Math.imul(L, Oe) | 0, P = P + Math.imul(L, me) | 0, m = m + Math.imul(M, rt) | 0, g = g + Math.imul(M, qe) | 0, g = g + Math.imul(H, rt) | 0, P = P + Math.imul(H, qe) | 0;\n      var Jr = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, m = Math.imul(Se, Ie), g = Math.imul(Se, Pe), g = g + Math.imul(oe, Ie) | 0, P = Math.imul(oe, Pe), m = m + Math.imul(_e, Ye) | 0, g = g + Math.imul(_e, Ae) | 0, g = g + Math.imul(re, Ye) | 0, P = P + Math.imul(re, Ae) | 0, m = m + Math.imul(fe, et) | 0, g = g + Math.imul(fe, Ne) | 0, g = g + Math.imul(te, et) | 0, P = P + Math.imul(te, Ne) | 0, m = m + Math.imul(le, Te) | 0, g = g + Math.imul(le, de) | 0, g = g + Math.imul(ne, Te) | 0, P = P + Math.imul(ne, de) | 0, m = m + Math.imul(xe, Le) | 0, g = g + Math.imul(xe, ce) | 0, g = g + Math.imul(se, Le) | 0, P = P + Math.imul(se, ce) | 0, m = m + Math.imul(Me, ze) | 0, g = g + Math.imul(Me, ye) | 0, g = g + Math.imul(he, ze) | 0, P = P + Math.imul(he, ye) | 0, m = m + Math.imul(X, ke) | 0, g = g + Math.imul(X, ve) | 0, g = g + Math.imul(ee, ke) | 0, P = P + Math.imul(ee, ve) | 0, m = m + Math.imul(F, Oe) | 0, g = g + Math.imul(F, me) | 0, g = g + Math.imul(W, Oe) | 0, P = P + Math.imul(W, me) | 0, m = m + Math.imul(q, rt) | 0, g = g + Math.imul(q, qe) | 0, g = g + Math.imul(L, rt) | 0, P = P + Math.imul(L, qe) | 0, m = m + Math.imul(M, Je) | 0, g = g + Math.imul(M, tt) | 0, g = g + Math.imul(H, Je) | 0, P = P + Math.imul(H, tt) | 0;\n      var Yr = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, m = Math.imul(Se, Ye), g = Math.imul(Se, Ae), g = g + Math.imul(oe, Ye) | 0, P = Math.imul(oe, Ae), m = m + Math.imul(_e, et) | 0, g = g + Math.imul(_e, Ne) | 0, g = g + Math.imul(re, et) | 0, P = P + Math.imul(re, Ne) | 0, m = m + Math.imul(fe, Te) | 0, g = g + Math.imul(fe, de) | 0, g = g + Math.imul(te, Te) | 0, P = P + Math.imul(te, de) | 0, m = m + Math.imul(le, Le) | 0, g = g + Math.imul(le, ce) | 0, g = g + Math.imul(ne, Le) | 0, P = P + Math.imul(ne, ce) | 0, m = m + Math.imul(xe, ze) | 0, g = g + Math.imul(xe, ye) | 0, g = g + Math.imul(se, ze) | 0, P = P + Math.imul(se, ye) | 0, m = m + Math.imul(Me, ke) | 0, g = g + Math.imul(Me, ve) | 0, g = g + Math.imul(he, ke) | 0, P = P + Math.imul(he, ve) | 0, m = m + Math.imul(X, Oe) | 0, g = g + Math.imul(X, me) | 0, g = g + Math.imul(ee, Oe) | 0, P = P + Math.imul(ee, me) | 0, m = m + Math.imul(F, rt) | 0, g = g + Math.imul(F, qe) | 0, g = g + Math.imul(W, rt) | 0, P = P + Math.imul(W, qe) | 0, m = m + Math.imul(q, Je) | 0, g = g + Math.imul(q, tt) | 0, g = g + Math.imul(L, Je) | 0, P = P + Math.imul(L, tt) | 0;\n      var or = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, m = Math.imul(Se, et), g = Math.imul(Se, Ne), g = g + Math.imul(oe, et) | 0, P = Math.imul(oe, Ne), m = m + Math.imul(_e, Te) | 0, g = g + Math.imul(_e, de) | 0, g = g + Math.imul(re, Te) | 0, P = P + Math.imul(re, de) | 0, m = m + Math.imul(fe, Le) | 0, g = g + Math.imul(fe, ce) | 0, g = g + Math.imul(te, Le) | 0, P = P + Math.imul(te, ce) | 0, m = m + Math.imul(le, ze) | 0, g = g + Math.imul(le, ye) | 0, g = g + Math.imul(ne, ze) | 0, P = P + Math.imul(ne, ye) | 0, m = m + Math.imul(xe, ke) | 0, g = g + Math.imul(xe, ve) | 0, g = g + Math.imul(se, ke) | 0, P = P + Math.imul(se, ve) | 0, m = m + Math.imul(Me, Oe) | 0, g = g + Math.imul(Me, me) | 0, g = g + Math.imul(he, Oe) | 0, P = P + Math.imul(he, me) | 0, m = m + Math.imul(X, rt) | 0, g = g + Math.imul(X, qe) | 0, g = g + Math.imul(ee, rt) | 0, P = P + Math.imul(ee, qe) | 0, m = m + Math.imul(F, Je) | 0, g = g + Math.imul(F, tt) | 0, g = g + Math.imul(W, Je) | 0, P = P + Math.imul(W, tt) | 0;\n      var Xr = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, m = Math.imul(Se, Te), g = Math.imul(Se, de), g = g + Math.imul(oe, Te) | 0, P = Math.imul(oe, de), m = m + Math.imul(_e, Le) | 0, g = g + Math.imul(_e, ce) | 0, g = g + Math.imul(re, Le) | 0, P = P + Math.imul(re, ce) | 0, m = m + Math.imul(fe, ze) | 0, g = g + Math.imul(fe, ye) | 0, g = g + Math.imul(te, ze) | 0, P = P + Math.imul(te, ye) | 0, m = m + Math.imul(le, ke) | 0, g = g + Math.imul(le, ve) | 0, g = g + Math.imul(ne, ke) | 0, P = P + Math.imul(ne, ve) | 0, m = m + Math.imul(xe, Oe) | 0, g = g + Math.imul(xe, me) | 0, g = g + Math.imul(se, Oe) | 0, P = P + Math.imul(se, me) | 0, m = m + Math.imul(Me, rt) | 0, g = g + Math.imul(Me, qe) | 0, g = g + Math.imul(he, rt) | 0, P = P + Math.imul(he, qe) | 0, m = m + Math.imul(X, Je) | 0, g = g + Math.imul(X, tt) | 0, g = g + Math.imul(ee, Je) | 0, P = P + Math.imul(ee, tt) | 0;\n      var Zr = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, m = Math.imul(Se, Le), g = Math.imul(Se, ce), g = g + Math.imul(oe, Le) | 0, P = Math.imul(oe, ce), m = m + Math.imul(_e, ze) | 0, g = g + Math.imul(_e, ye) | 0, g = g + Math.imul(re, ze) | 0, P = P + Math.imul(re, ye) | 0, m = m + Math.imul(fe, ke) | 0, g = g + Math.imul(fe, ve) | 0, g = g + Math.imul(te, ke) | 0, P = P + Math.imul(te, ve) | 0, m = m + Math.imul(le, Oe) | 0, g = g + Math.imul(le, me) | 0, g = g + Math.imul(ne, Oe) | 0, P = P + Math.imul(ne, me) | 0, m = m + Math.imul(xe, rt) | 0, g = g + Math.imul(xe, qe) | 0, g = g + Math.imul(se, rt) | 0, P = P + Math.imul(se, qe) | 0, m = m + Math.imul(Me, Je) | 0, g = g + Math.imul(Me, tt) | 0, g = g + Math.imul(he, Je) | 0, P = P + Math.imul(he, tt) | 0;\n      var $t = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, m = Math.imul(Se, ze), g = Math.imul(Se, ye), g = g + Math.imul(oe, ze) | 0, P = Math.imul(oe, ye), m = m + Math.imul(_e, ke) | 0, g = g + Math.imul(_e, ve) | 0, g = g + Math.imul(re, ke) | 0, P = P + Math.imul(re, ve) | 0, m = m + Math.imul(fe, Oe) | 0, g = g + Math.imul(fe, me) | 0, g = g + Math.imul(te, Oe) | 0, P = P + Math.imul(te, me) | 0, m = m + Math.imul(le, rt) | 0, g = g + Math.imul(le, qe) | 0, g = g + Math.imul(ne, rt) | 0, P = P + Math.imul(ne, qe) | 0, m = m + Math.imul(xe, Je) | 0, g = g + Math.imul(xe, tt) | 0, g = g + Math.imul(se, Je) | 0, P = P + Math.imul(se, tt) | 0;\n      var Qr = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, m = Math.imul(Se, ke), g = Math.imul(Se, ve), g = g + Math.imul(oe, ke) | 0, P = Math.imul(oe, ve), m = m + Math.imul(_e, Oe) | 0, g = g + Math.imul(_e, me) | 0, g = g + Math.imul(re, Oe) | 0, P = P + Math.imul(re, me) | 0, m = m + Math.imul(fe, rt) | 0, g = g + Math.imul(fe, qe) | 0, g = g + Math.imul(te, rt) | 0, P = P + Math.imul(te, qe) | 0, m = m + Math.imul(le, Je) | 0, g = g + Math.imul(le, tt) | 0, g = g + Math.imul(ne, Je) | 0, P = P + Math.imul(ne, tt) | 0;\n      var ei = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (ei >>> 26) | 0, ei &= 67108863, m = Math.imul(Se, Oe), g = Math.imul(Se, me), g = g + Math.imul(oe, Oe) | 0, P = Math.imul(oe, me), m = m + Math.imul(_e, rt) | 0, g = g + Math.imul(_e, qe) | 0, g = g + Math.imul(re, rt) | 0, P = P + Math.imul(re, qe) | 0, m = m + Math.imul(fe, Je) | 0, g = g + Math.imul(fe, tt) | 0, g = g + Math.imul(te, Je) | 0, P = P + Math.imul(te, tt) | 0;\n      var ti = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (ti >>> 26) | 0, ti &= 67108863, m = Math.imul(Se, rt), g = Math.imul(Se, qe), g = g + Math.imul(oe, rt) | 0, P = Math.imul(oe, qe), m = m + Math.imul(_e, Je) | 0, g = g + Math.imul(_e, tt) | 0, g = g + Math.imul(re, Je) | 0, P = P + Math.imul(re, tt) | 0;\n      var An = (u + m | 0) + ((g & 8191) << 13) | 0;\n      u = (P + (g >>> 13) | 0) + (An >>> 26) | 0, An &= 67108863, m = Math.imul(Se, Je), g = Math.imul(Se, tt), g = g + Math.imul(oe, Je) | 0, P = Math.imul(oe, tt);\n      var Dn = (u + m | 0) + ((g & 8191) << 13) | 0;\n      return u = (P + (g >>> 13) | 0) + (Dn >>> 26) | 0, Dn &= 67108863, x[0] = jt, x[1] = Kt, x[2] = Ht, x[3] = Vt, x[4] = gt, x[5] = Vr, x[6] = Wr, x[7] = Gr, x[8] = Jr, x[9] = Yr, x[10] = or, x[11] = Xr, x[12] = Zr, x[13] = $t, x[14] = Qr, x[15] = ei, x[16] = ti, x[17] = An, x[18] = Dn, u !== 0 && (x[19] = u, b.length++), b;\n    };\n    Math.imul || (T = j);\n    function K(l, a, c) {\n      c.negative = a.negative ^ l.negative, c.length = l.length + a.length;\n      for (var b = 0, E = 0, S = 0; S < c.length - 1; S++) {\n        var x = E;\n        E = 0;\n        for (var u = b & 67108863, m = Math.min(S, a.length - 1), g = Math.max(0, S - l.length + 1); g <= m; g++) {\n          var P = S - g, G = l.words[P] | 0, M = a.words[g] | 0, H = G * M, C = H & 67108863;\n          x = x + (H / 67108864 | 0) | 0, C = C + u | 0, u = C & 67108863, x = x + (C >>> 26) | 0, E += x >>> 26, x &= 67108863;\n        }\n        c.words[S] = u, b = x, x = E;\n      }\n      return b !== 0 ? c.words[S] = b : c.length--, c._strip();\n    }\n    function $(l, a, c) {\n      return K(l, a, c);\n    }\n    s.prototype.mulTo = function(a, c) {\n      var b, E = this.length + a.length;\n      return this.length === 10 && a.length === 10 ? b = T(this, a, c) : E < 63 ? b = j(this, a, c) : E < 1024 ? b = K(this, a, c) : b = $(this, a, c), b;\n    }, s.prototype.mul = function(a) {\n      var c = new s(null);\n      return c.words = new Array(this.length + a.length), this.mulTo(a, c);\n    }, s.prototype.mulf = function(a) {\n      var c = new s(null);\n      return c.words = new Array(this.length + a.length), $(this, a, c);\n    }, s.prototype.imul = function(a) {\n      return this.clone().mulTo(a, this);\n    }, s.prototype.imuln = function(a) {\n      var c = a < 0;\n      c && (a = -a), i(typeof a == \"number\"), i(a < 67108864);\n      for (var b = 0, E = 0; E < this.length; E++) {\n        var S = (this.words[E] | 0) * a, x = (S & 67108863) + (b & 67108863);\n        b >>= 26, b += S / 67108864 | 0, b += x >>> 26, this.words[E] = x & 67108863;\n      }\n      return b !== 0 && (this.words[E] = b, this.length++), c ? this.ineg() : this;\n    }, s.prototype.muln = function(a) {\n      return this.clone().imuln(a);\n    }, s.prototype.sqr = function() {\n      return this.mul(this);\n    }, s.prototype.isqr = function() {\n      return this.imul(this.clone());\n    }, s.prototype.pow = function(a) {\n      var c = k(a);\n      if (c.length === 0)\n        return new s(1);\n      for (var b = this, E = 0; E < c.length && c[E] === 0; E++, b = b.sqr())\n        ;\n      if (++E < c.length)\n        for (var S = b.sqr(); E < c.length; E++, S = S.sqr())\n          c[E] !== 0 && (b = b.mul(S));\n      return b;\n    }, s.prototype.iushln = function(a) {\n      i(typeof a == \"number\" && a >= 0);\n      var c = a % 26, b = (a - c) / 26, E = 67108863 >>> 26 - c << 26 - c, S;\n      if (c !== 0) {\n        var x = 0;\n        for (S = 0; S < this.length; S++) {\n          var u = this.words[S] & E, m = (this.words[S] | 0) - u << c;\n          this.words[S] = m | x, x = u >>> 26 - c;\n        }\n        x && (this.words[S] = x, this.length++);\n      }\n      if (b !== 0) {\n        for (S = this.length - 1; S >= 0; S--)\n          this.words[S + b] = this.words[S];\n        for (S = 0; S < b; S++)\n          this.words[S] = 0;\n        this.length += b;\n      }\n      return this._strip();\n    }, s.prototype.ishln = function(a) {\n      return i(this.negative === 0), this.iushln(a);\n    }, s.prototype.iushrn = function(a, c, b) {\n      i(typeof a == \"number\" && a >= 0);\n      var E;\n      c ? E = (c - c % 26) / 26 : E = 0;\n      var S = a % 26, x = Math.min((a - S) / 26, this.length), u = 67108863 ^ 67108863 >>> S << S, m = b;\n      if (E -= x, E = Math.max(0, E), m) {\n        for (var g = 0; g < x; g++)\n          m.words[g] = this.words[g];\n        m.length = x;\n      }\n      if (x !== 0)\n        if (this.length > x)\n          for (this.length -= x, g = 0; g < this.length; g++)\n            this.words[g] = this.words[g + x];\n        else\n          this.words[0] = 0, this.length = 1;\n      var P = 0;\n      for (g = this.length - 1; g >= 0 && (P !== 0 || g >= E); g--) {\n        var G = this.words[g] | 0;\n        this.words[g] = P << 26 - S | G >>> S, P = G & u;\n      }\n      return m && P !== 0 && (m.words[m.length++] = P), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();\n    }, s.prototype.ishrn = function(a, c, b) {\n      return i(this.negative === 0), this.iushrn(a, c, b);\n    }, s.prototype.shln = function(a) {\n      return this.clone().ishln(a);\n    }, s.prototype.ushln = function(a) {\n      return this.clone().iushln(a);\n    }, s.prototype.shrn = function(a) {\n      return this.clone().ishrn(a);\n    }, s.prototype.ushrn = function(a) {\n      return this.clone().iushrn(a);\n    }, s.prototype.testn = function(a) {\n      i(typeof a == \"number\" && a >= 0);\n      var c = a % 26, b = (a - c) / 26, E = 1 << c;\n      if (this.length <= b)\n        return !1;\n      var S = this.words[b];\n      return !!(S & E);\n    }, s.prototype.imaskn = function(a) {\n      i(typeof a == \"number\" && a >= 0);\n      var c = a % 26, b = (a - c) / 26;\n      if (i(this.negative === 0, \"imaskn works only with positive numbers\"), this.length <= b)\n        return this;\n      if (c !== 0 && b++, this.length = Math.min(b, this.length), c !== 0) {\n        var E = 67108863 ^ 67108863 >>> c << c;\n        this.words[this.length - 1] &= E;\n      }\n      return this._strip();\n    }, s.prototype.maskn = function(a) {\n      return this.clone().imaskn(a);\n    }, s.prototype.iaddn = function(a) {\n      return i(typeof a == \"number\"), i(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a);\n    }, s.prototype._iaddn = function(a) {\n      this.words[0] += a;\n      for (var c = 0; c < this.length && this.words[c] >= 67108864; c++)\n        this.words[c] -= 67108864, c === this.length - 1 ? this.words[c + 1] = 1 : this.words[c + 1]++;\n      return this.length = Math.max(this.length, c + 1), this;\n    }, s.prototype.isubn = function(a) {\n      if (i(typeof a == \"number\"), i(a < 67108864), a < 0)\n        return this.iaddn(-a);\n      if (this.negative !== 0)\n        return this.negative = 0, this.iaddn(a), this.negative = 1, this;\n      if (this.words[0] -= a, this.length === 1 && this.words[0] < 0)\n        this.words[0] = -this.words[0], this.negative = 1;\n      else\n        for (var c = 0; c < this.length && this.words[c] < 0; c++)\n          this.words[c] += 67108864, this.words[c + 1] -= 1;\n      return this._strip();\n    }, s.prototype.addn = function(a) {\n      return this.clone().iaddn(a);\n    }, s.prototype.subn = function(a) {\n      return this.clone().isubn(a);\n    }, s.prototype.iabs = function() {\n      return this.negative = 0, this;\n    }, s.prototype.abs = function() {\n      return this.clone().iabs();\n    }, s.prototype._ishlnsubmul = function(a, c, b) {\n      var E = a.length + b, S;\n      this._expand(E);\n      var x, u = 0;\n      for (S = 0; S < a.length; S++) {\n        x = (this.words[S + b] | 0) + u;\n        var m = (a.words[S] | 0) * c;\n        x -= m & 67108863, u = (x >> 26) - (m / 67108864 | 0), this.words[S + b] = x & 67108863;\n      }\n      for (; S < this.length - b; S++)\n        x = (this.words[S + b] | 0) + u, u = x >> 26, this.words[S + b] = x & 67108863;\n      if (u === 0)\n        return this._strip();\n      for (i(u === -1), u = 0, S = 0; S < this.length; S++)\n        x = -(this.words[S] | 0) + u, u = x >> 26, this.words[S] = x & 67108863;\n      return this.negative = 1, this._strip();\n    }, s.prototype._wordDiv = function(a, c) {\n      var b = this.length - a.length, E = this.clone(), S = a, x = S.words[S.length - 1] | 0, u = this._countBits(x);\n      b = 26 - u, b !== 0 && (S = S.ushln(b), E.iushln(b), x = S.words[S.length - 1] | 0);\n      var m = E.length - S.length, g;\n      if (c !== \"mod\") {\n        g = new s(null), g.length = m + 1, g.words = new Array(g.length);\n        for (var P = 0; P < g.length; P++)\n          g.words[P] = 0;\n      }\n      var G = E.clone()._ishlnsubmul(S, 1, m);\n      G.negative === 0 && (E = G, g && (g.words[m] = 1));\n      for (var M = m - 1; M >= 0; M--) {\n        var H = (E.words[S.length + M] | 0) * 67108864 + (E.words[S.length + M - 1] | 0);\n        for (H = Math.min(H / x | 0, 67108863), E._ishlnsubmul(S, H, M); E.negative !== 0; )\n          H--, E.negative = 0, E._ishlnsubmul(S, 1, M), E.isZero() || (E.negative ^= 1);\n        g && (g.words[M] = H);\n      }\n      return g && g._strip(), E._strip(), c !== \"div\" && b !== 0 && E.iushrn(b), {\n        div: g || null,\n        mod: E\n      };\n    }, s.prototype.divmod = function(a, c, b) {\n      if (i(!a.isZero()), this.isZero())\n        return {\n          div: new s(0),\n          mod: new s(0)\n        };\n      var E, S, x;\n      return this.negative !== 0 && a.negative === 0 ? (x = this.neg().divmod(a, c), c !== \"mod\" && (E = x.div.neg()), c !== \"div\" && (S = x.mod.neg(), b && S.negative !== 0 && S.iadd(a)), {\n        div: E,\n        mod: S\n      }) : this.negative === 0 && a.negative !== 0 ? (x = this.divmod(a.neg(), c), c !== \"mod\" && (E = x.div.neg()), {\n        div: E,\n        mod: x.mod\n      }) : this.negative & a.negative ? (x = this.neg().divmod(a.neg(), c), c !== \"div\" && (S = x.mod.neg(), b && S.negative !== 0 && S.isub(a)), {\n        div: x.div,\n        mod: S\n      }) : a.length > this.length || this.cmp(a) < 0 ? {\n        div: new s(0),\n        mod: this\n      } : a.length === 1 ? c === \"div\" ? {\n        div: this.divn(a.words[0]),\n        mod: null\n      } : c === \"mod\" ? {\n        div: null,\n        mod: new s(this.modrn(a.words[0]))\n      } : {\n        div: this.divn(a.words[0]),\n        mod: new s(this.modrn(a.words[0]))\n      } : this._wordDiv(a, c);\n    }, s.prototype.div = function(a) {\n      return this.divmod(a, \"div\", !1).div;\n    }, s.prototype.mod = function(a) {\n      return this.divmod(a, \"mod\", !1).mod;\n    }, s.prototype.umod = function(a) {\n      return this.divmod(a, \"mod\", !0).mod;\n    }, s.prototype.divRound = function(a) {\n      var c = this.divmod(a);\n      if (c.mod.isZero())\n        return c.div;\n      var b = c.div.negative !== 0 ? c.mod.isub(a) : c.mod, E = a.ushrn(1), S = a.andln(1), x = b.cmp(E);\n      return x < 0 || S === 1 && x === 0 ? c.div : c.div.negative !== 0 ? c.div.isubn(1) : c.div.iaddn(1);\n    }, s.prototype.modrn = function(a) {\n      var c = a < 0;\n      c && (a = -a), i(a <= 67108863);\n      for (var b = (1 << 26) % a, E = 0, S = this.length - 1; S >= 0; S--)\n        E = (b * E + (this.words[S] | 0)) % a;\n      return c ? -E : E;\n    }, s.prototype.modn = function(a) {\n      return this.modrn(a);\n    }, s.prototype.idivn = function(a) {\n      var c = a < 0;\n      c && (a = -a), i(a <= 67108863);\n      for (var b = 0, E = this.length - 1; E >= 0; E--) {\n        var S = (this.words[E] | 0) + b * 67108864;\n        this.words[E] = S / a | 0, b = S % a;\n      }\n      return this._strip(), c ? this.ineg() : this;\n    }, s.prototype.divn = function(a) {\n      return this.clone().idivn(a);\n    }, s.prototype.egcd = function(a) {\n      i(a.negative === 0), i(!a.isZero());\n      var c = this, b = a.clone();\n      c.negative !== 0 ? c = c.umod(a) : c = c.clone();\n      for (var E = new s(1), S = new s(0), x = new s(0), u = new s(1), m = 0; c.isEven() && b.isEven(); )\n        c.iushrn(1), b.iushrn(1), ++m;\n      for (var g = b.clone(), P = c.clone(); !c.isZero(); ) {\n        for (var G = 0, M = 1; !(c.words[0] & M) && G < 26; ++G, M <<= 1)\n          ;\n        if (G > 0)\n          for (c.iushrn(G); G-- > 0; )\n            (E.isOdd() || S.isOdd()) && (E.iadd(g), S.isub(P)), E.iushrn(1), S.iushrn(1);\n        for (var H = 0, C = 1; !(b.words[0] & C) && H < 26; ++H, C <<= 1)\n          ;\n        if (H > 0)\n          for (b.iushrn(H); H-- > 0; )\n            (x.isOdd() || u.isOdd()) && (x.iadd(g), u.isub(P)), x.iushrn(1), u.iushrn(1);\n        c.cmp(b) >= 0 ? (c.isub(b), E.isub(x), S.isub(u)) : (b.isub(c), x.isub(E), u.isub(S));\n      }\n      return {\n        a: x,\n        b: u,\n        gcd: b.iushln(m)\n      };\n    }, s.prototype._invmp = function(a) {\n      i(a.negative === 0), i(!a.isZero());\n      var c = this, b = a.clone();\n      c.negative !== 0 ? c = c.umod(a) : c = c.clone();\n      for (var E = new s(1), S = new s(0), x = b.clone(); c.cmpn(1) > 0 && b.cmpn(1) > 0; ) {\n        for (var u = 0, m = 1; !(c.words[0] & m) && u < 26; ++u, m <<= 1)\n          ;\n        if (u > 0)\n          for (c.iushrn(u); u-- > 0; )\n            E.isOdd() && E.iadd(x), E.iushrn(1);\n        for (var g = 0, P = 1; !(b.words[0] & P) && g < 26; ++g, P <<= 1)\n          ;\n        if (g > 0)\n          for (b.iushrn(g); g-- > 0; )\n            S.isOdd() && S.iadd(x), S.iushrn(1);\n        c.cmp(b) >= 0 ? (c.isub(b), E.isub(S)) : (b.isub(c), S.isub(E));\n      }\n      var G;\n      return c.cmpn(1) === 0 ? G = E : G = S, G.cmpn(0) < 0 && G.iadd(a), G;\n    }, s.prototype.gcd = function(a) {\n      if (this.isZero())\n        return a.abs();\n      if (a.isZero())\n        return this.abs();\n      var c = this.clone(), b = a.clone();\n      c.negative = 0, b.negative = 0;\n      for (var E = 0; c.isEven() && b.isEven(); E++)\n        c.iushrn(1), b.iushrn(1);\n      do {\n        for (; c.isEven(); )\n          c.iushrn(1);\n        for (; b.isEven(); )\n          b.iushrn(1);\n        var S = c.cmp(b);\n        if (S < 0) {\n          var x = c;\n          c = b, b = x;\n        } else if (S === 0 || b.cmpn(1) === 0)\n          break;\n        c.isub(b);\n      } while (!0);\n      return b.iushln(E);\n    }, s.prototype.invm = function(a) {\n      return this.egcd(a).a.umod(a);\n    }, s.prototype.isEven = function() {\n      return (this.words[0] & 1) === 0;\n    }, s.prototype.isOdd = function() {\n      return (this.words[0] & 1) === 1;\n    }, s.prototype.andln = function(a) {\n      return this.words[0] & a;\n    }, s.prototype.bincn = function(a) {\n      i(typeof a == \"number\");\n      var c = a % 26, b = (a - c) / 26, E = 1 << c;\n      if (this.length <= b)\n        return this._expand(b + 1), this.words[b] |= E, this;\n      for (var S = E, x = b; S !== 0 && x < this.length; x++) {\n        var u = this.words[x] | 0;\n        u += S, S = u >>> 26, u &= 67108863, this.words[x] = u;\n      }\n      return S !== 0 && (this.words[x] = S, this.length++), this;\n    }, s.prototype.isZero = function() {\n      return this.length === 1 && this.words[0] === 0;\n    }, s.prototype.cmpn = function(a) {\n      var c = a < 0;\n      if (this.negative !== 0 && !c)\n        return -1;\n      if (this.negative === 0 && c)\n        return 1;\n      this._strip();\n      var b;\n      if (this.length > 1)\n        b = 1;\n      else {\n        c && (a = -a), i(a <= 67108863, \"Number is too big\");\n        var E = this.words[0] | 0;\n        b = E === a ? 0 : E < a ? -1 : 1;\n      }\n      return this.negative !== 0 ? -b | 0 : b;\n    }, s.prototype.cmp = function(a) {\n      if (this.negative !== 0 && a.negative === 0)\n        return -1;\n      if (this.negative === 0 && a.negative !== 0)\n        return 1;\n      var c = this.ucmp(a);\n      return this.negative !== 0 ? -c | 0 : c;\n    }, s.prototype.ucmp = function(a) {\n      if (this.length > a.length)\n        return 1;\n      if (this.length < a.length)\n        return -1;\n      for (var c = 0, b = this.length - 1; b >= 0; b--) {\n        var E = this.words[b] | 0, S = a.words[b] | 0;\n        if (E !== S) {\n          E < S ? c = -1 : E > S && (c = 1);\n          break;\n        }\n      }\n      return c;\n    }, s.prototype.gtn = function(a) {\n      return this.cmpn(a) === 1;\n    }, s.prototype.gt = function(a) {\n      return this.cmp(a) === 1;\n    }, s.prototype.gten = function(a) {\n      return this.cmpn(a) >= 0;\n    }, s.prototype.gte = function(a) {\n      return this.cmp(a) >= 0;\n    }, s.prototype.ltn = function(a) {\n      return this.cmpn(a) === -1;\n    }, s.prototype.lt = function(a) {\n      return this.cmp(a) === -1;\n    }, s.prototype.lten = function(a) {\n      return this.cmpn(a) <= 0;\n    }, s.prototype.lte = function(a) {\n      return this.cmp(a) <= 0;\n    }, s.prototype.eqn = function(a) {\n      return this.cmpn(a) === 0;\n    }, s.prototype.eq = function(a) {\n      return this.cmp(a) === 0;\n    }, s.red = function(a) {\n      return new O(a);\n    }, s.prototype.toRed = function(a) {\n      return i(!this.red, \"Already a number in reduction context\"), i(this.negative === 0, \"red works only with positives\"), a.convertTo(this)._forceRed(a);\n    }, s.prototype.fromRed = function() {\n      return i(this.red, \"fromRed works only with numbers in reduction context\"), this.red.convertFrom(this);\n    }, s.prototype._forceRed = function(a) {\n      return this.red = a, this;\n    }, s.prototype.forceRed = function(a) {\n      return i(!this.red, \"Already a number in reduction context\"), this._forceRed(a);\n    }, s.prototype.redAdd = function(a) {\n      return i(this.red, \"redAdd works only with red numbers\"), this.red.add(this, a);\n    }, s.prototype.redIAdd = function(a) {\n      return i(this.red, \"redIAdd works only with red numbers\"), this.red.iadd(this, a);\n    }, s.prototype.redSub = function(a) {\n      return i(this.red, \"redSub works only with red numbers\"), this.red.sub(this, a);\n    }, s.prototype.redISub = function(a) {\n      return i(this.red, \"redISub works only with red numbers\"), this.red.isub(this, a);\n    }, s.prototype.redShl = function(a) {\n      return i(this.red, \"redShl works only with red numbers\"), this.red.shl(this, a);\n    }, s.prototype.redMul = function(a) {\n      return i(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, a), this.red.mul(this, a);\n    }, s.prototype.redIMul = function(a) {\n      return i(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, a), this.red.imul(this, a);\n    }, s.prototype.redSqr = function() {\n      return i(this.red, \"redSqr works only with red numbers\"), this.red._verify1(this), this.red.sqr(this);\n    }, s.prototype.redISqr = function() {\n      return i(this.red, \"redISqr works only with red numbers\"), this.red._verify1(this), this.red.isqr(this);\n    }, s.prototype.redSqrt = function() {\n      return i(this.red, \"redSqrt works only with red numbers\"), this.red._verify1(this), this.red.sqrt(this);\n    }, s.prototype.redInvm = function() {\n      return i(this.red, \"redInvm works only with red numbers\"), this.red._verify1(this), this.red.invm(this);\n    }, s.prototype.redNeg = function() {\n      return i(this.red, \"redNeg works only with red numbers\"), this.red._verify1(this), this.red.neg(this);\n    }, s.prototype.redPow = function(a) {\n      return i(this.red && !a.red, \"redPow(normalNum)\"), this.red._verify1(this), this.red.pow(this, a);\n    };\n    var z = {\n      k256: null,\n      p224: null,\n      p192: null,\n      p25519: null\n    };\n    function B(l, a) {\n      this.name = l, this.p = new s(a, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();\n    }\n    B.prototype._tmp = function() {\n      var a = new s(null);\n      return a.words = new Array(Math.ceil(this.n / 13)), a;\n    }, B.prototype.ireduce = function(a) {\n      var c = a, b;\n      do\n        this.split(c, this.tmp), c = this.imulK(c), c = c.iadd(this.tmp), b = c.bitLength();\n      while (b > this.n);\n      var E = b < this.n ? -1 : c.ucmp(this.p);\n      return E === 0 ? (c.words[0] = 0, c.length = 1) : E > 0 ? c.isub(this.p) : c.strip !== void 0 ? c.strip() : c._strip(), c;\n    }, B.prototype.split = function(a, c) {\n      a.iushrn(this.n, 0, c);\n    }, B.prototype.imulK = function(a) {\n      return a.imul(this.k);\n    };\n    function _() {\n      B.call(\n        this,\n        \"k256\",\n        \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\"\n      );\n    }\n    n(_, B), _.prototype.split = function(a, c) {\n      for (var b = 4194303, E = Math.min(a.length, 9), S = 0; S < E; S++)\n        c.words[S] = a.words[S];\n      if (c.length = E, a.length <= 9) {\n        a.words[0] = 0, a.length = 1;\n        return;\n      }\n      var x = a.words[9];\n      for (c.words[c.length++] = x & b, S = 10; S < a.length; S++) {\n        var u = a.words[S] | 0;\n        a.words[S - 10] = (u & b) << 4 | x >>> 22, x = u;\n      }\n      x >>>= 22, a.words[S - 10] = x, x === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9;\n    }, _.prototype.imulK = function(a) {\n      a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2;\n      for (var c = 0, b = 0; b < a.length; b++) {\n        var E = a.words[b] | 0;\n        c += E * 977, a.words[b] = c & 67108863, c = E * 64 + (c / 67108864 | 0);\n      }\n      return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a;\n    };\n    function R() {\n      B.call(\n        this,\n        \"p224\",\n        \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\"\n      );\n    }\n    n(R, B);\n    function J() {\n      B.call(\n        this,\n        \"p192\",\n        \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\"\n      );\n    }\n    n(J, B);\n    function Q() {\n      B.call(\n        this,\n        \"25519\",\n        \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\"\n      );\n    }\n    n(Q, B), Q.prototype.imulK = function(a) {\n      for (var c = 0, b = 0; b < a.length; b++) {\n        var E = (a.words[b] | 0) * 19 + c, S = E & 67108863;\n        E >>>= 26, a.words[b] = S, c = E;\n      }\n      return c !== 0 && (a.words[a.length++] = c), a;\n    }, s._prime = function(a) {\n      if (z[a])\n        return z[a];\n      var c;\n      if (a === \"k256\")\n        c = new _();\n      else if (a === \"p224\")\n        c = new R();\n      else if (a === \"p192\")\n        c = new J();\n      else if (a === \"p25519\")\n        c = new Q();\n      else\n        throw new Error(\"Unknown prime \" + a);\n      return z[a] = c, c;\n    };\n    function O(l) {\n      if (typeof l == \"string\") {\n        var a = s._prime(l);\n        this.m = a.p, this.prime = a;\n      } else\n        i(l.gtn(1), \"modulus must be greater than 1\"), this.m = l, this.prime = null;\n    }\n    O.prototype._verify1 = function(a) {\n      i(a.negative === 0, \"red works only with positives\"), i(a.red, \"red works only with red numbers\");\n    }, O.prototype._verify2 = function(a, c) {\n      i((a.negative | c.negative) === 0, \"red works only with positives\"), i(\n        a.red && a.red === c.red,\n        \"red works only with red numbers\"\n      );\n    }, O.prototype.imod = function(a) {\n      return this.prime ? this.prime.ireduce(a)._forceRed(this) : (v(a, a.umod(this.m)._forceRed(this)), a);\n    }, O.prototype.neg = function(a) {\n      return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);\n    }, O.prototype.add = function(a, c) {\n      this._verify2(a, c);\n      var b = a.add(c);\n      return b.cmp(this.m) >= 0 && b.isub(this.m), b._forceRed(this);\n    }, O.prototype.iadd = function(a, c) {\n      this._verify2(a, c);\n      var b = a.iadd(c);\n      return b.cmp(this.m) >= 0 && b.isub(this.m), b;\n    }, O.prototype.sub = function(a, c) {\n      this._verify2(a, c);\n      var b = a.sub(c);\n      return b.cmpn(0) < 0 && b.iadd(this.m), b._forceRed(this);\n    }, O.prototype.isub = function(a, c) {\n      this._verify2(a, c);\n      var b = a.isub(c);\n      return b.cmpn(0) < 0 && b.iadd(this.m), b;\n    }, O.prototype.shl = function(a, c) {\n      return this._verify1(a), this.imod(a.ushln(c));\n    }, O.prototype.imul = function(a, c) {\n      return this._verify2(a, c), this.imod(a.imul(c));\n    }, O.prototype.mul = function(a, c) {\n      return this._verify2(a, c), this.imod(a.mul(c));\n    }, O.prototype.isqr = function(a) {\n      return this.imul(a, a.clone());\n    }, O.prototype.sqr = function(a) {\n      return this.mul(a, a);\n    }, O.prototype.sqrt = function(a) {\n      if (a.isZero())\n        return a.clone();\n      var c = this.m.andln(3);\n      if (i(c % 2 === 1), c === 3) {\n        var b = this.m.add(new s(1)).iushrn(2);\n        return this.pow(a, b);\n      }\n      for (var E = this.m.subn(1), S = 0; !E.isZero() && E.andln(1) === 0; )\n        S++, E.iushrn(1);\n      i(!E.isZero());\n      var x = new s(1).toRed(this), u = x.redNeg(), m = this.m.subn(1).iushrn(1), g = this.m.bitLength();\n      for (g = new s(2 * g * g).toRed(this); this.pow(g, m).cmp(u) !== 0; )\n        g.redIAdd(u);\n      for (var P = this.pow(g, E), G = this.pow(a, E.addn(1).iushrn(1)), M = this.pow(a, E), H = S; M.cmp(x) !== 0; ) {\n        for (var C = M, q = 0; C.cmp(x) !== 0; q++)\n          C = C.redSqr();\n        i(q < H);\n        var L = this.pow(P, new s(1).iushln(H - q - 1));\n        G = G.redMul(L), P = L.redSqr(), M = M.redMul(P), H = q;\n      }\n      return G;\n    }, O.prototype.invm = function(a) {\n      var c = a._invmp(this.m);\n      return c.negative !== 0 ? (c.negative = 0, this.imod(c).redNeg()) : this.imod(c);\n    }, O.prototype.pow = function(a, c) {\n      if (c.isZero())\n        return new s(1).toRed(this);\n      if (c.cmpn(1) === 0)\n        return a.clone();\n      var b = 4, E = new Array(1 << b);\n      E[0] = new s(1).toRed(this), E[1] = a;\n      for (var S = 2; S < E.length; S++)\n        E[S] = this.mul(E[S - 1], a);\n      var x = E[0], u = 0, m = 0, g = c.bitLength() % 26;\n      for (g === 0 && (g = 26), S = c.length - 1; S >= 0; S--) {\n        for (var P = c.words[S], G = g - 1; G >= 0; G--) {\n          var M = P >> G & 1;\n          if (x !== E[0] && (x = this.sqr(x)), M === 0 && u === 0) {\n            m = 0;\n            continue;\n          }\n          u <<= 1, u |= M, m++, !(m !== b && (S !== 0 || G !== 0)) && (x = this.mul(x, E[u]), m = 0, u = 0);\n        }\n        g = 26;\n      }\n      return x;\n    }, O.prototype.convertTo = function(a) {\n      var c = a.umod(this.m);\n      return c === a ? c.clone() : c;\n    }, O.prototype.convertFrom = function(a) {\n      var c = a.clone();\n      return c.red = null, c;\n    }, s.mont = function(a) {\n      return new p(a);\n    };\n    function p(l) {\n      O.call(this, l), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);\n    }\n    n(p, O), p.prototype.convertTo = function(a) {\n      return this.imod(a.ushln(this.shift));\n    }, p.prototype.convertFrom = function(a) {\n      var c = this.imod(a.mul(this.rinv));\n      return c.red = null, c;\n    }, p.prototype.imul = function(a, c) {\n      if (a.isZero() || c.isZero())\n        return a.words[0] = 0, a.length = 1, a;\n      var b = a.imul(c), E = b.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), S = b.isub(E).iushrn(this.shift), x = S;\n      return S.cmp(this.m) >= 0 ? x = S.isub(this.m) : S.cmpn(0) < 0 && (x = S.iadd(this.m)), x._forceRed(this);\n    }, p.prototype.mul = function(a, c) {\n      if (a.isZero() || c.isZero())\n        return new s(0)._forceRed(this);\n      var b = a.mul(c), E = b.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), S = b.isub(E).iushrn(this.shift), x = S;\n      return S.cmp(this.m) >= 0 ? x = S.isub(this.m) : S.cmpn(0) < 0 && (x = S.iadd(this.m)), x._forceRed(this);\n    }, p.prototype.invm = function(a) {\n      var c = this.imod(a._invmp(this.m).mul(this.r2));\n      return c._forceRed(this);\n    };\n  })(r, _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.c);\n})(Uo);\nvar Uv = Uo.exports;\nconst Ke = /* @__PURE__ */ (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.d)(Uv);\nvar zv = Ke.BN;\nfunction Bv(r) {\n  return new zv(r, 36).toString(16);\n}\nconst kv = \"strings/5.7.0\", jv = new ht(kv);\nvar ks;\n(function(r) {\n  r.current = \"\", r.NFC = \"NFC\", r.NFD = \"NFD\", r.NFKC = \"NFKC\", r.NFKD = \"NFKD\";\n})(ks || (ks = {}));\nvar ac;\n(function(r) {\n  r.UNEXPECTED_CONTINUE = \"unexpected continuation byte\", r.BAD_PREFIX = \"bad codepoint prefix\", r.OVERRUN = \"string overrun\", r.MISSING_CONTINUE = \"missing continuation byte\", r.OUT_OF_RANGE = \"out of UTF-8 range\", r.UTF16_SURROGATE = \"UTF-16 surrogate\", r.OVERLONG = \"overlong representation\";\n})(ac || (ac = {}));\nfunction ka(r, e = ks.current) {\n  e != ks.current && (jv.checkNormalize(), r = r.normalize(e));\n  let t = [];\n  for (let i = 0; i < r.length; i++) {\n    const n = r.charCodeAt(i);\n    if (n < 128)\n      t.push(n);\n    else if (n < 2048)\n      t.push(n >> 6 | 192), t.push(n & 63 | 128);\n    else if ((n & 64512) == 55296) {\n      i++;\n      const s = r.charCodeAt(i);\n      if (i >= r.length || (s & 64512) !== 56320)\n        throw new Error(\"invalid utf-8 string\");\n      const o = 65536 + ((n & 1023) << 10) + (s & 1023);\n      t.push(o >> 18 | 240), t.push(o >> 12 & 63 | 128), t.push(o >> 6 & 63 | 128), t.push(o & 63 | 128);\n    } else\n      t.push(n >> 12 | 224), t.push(n >> 6 & 63 | 128), t.push(n & 63 | 128);\n  }\n  return yt(t);\n}\nconst Kv = `\u0019Ethereum Signed Message:\n`;\nfunction bu(r) {\n  return typeof r == \"string\" && (r = ka(r)), qo(Lv([\n    ka(Kv),\n    ka(String(r.length)),\n    r\n  ]));\n}\nconst Hv = \"address/5.7.0\", kn = new ht(Hv);\nfunction oc(r) {\n  Lr(r, 20) || kn.throwArgumentError(\"invalid address\", \"address\", r), r = r.toLowerCase();\n  const e = r.substring(2).split(\"\"), t = new Uint8Array(40);\n  for (let n = 0; n < 40; n++)\n    t[n] = e[n].charCodeAt(0);\n  const i = yt(qo(t));\n  for (let n = 0; n < 40; n += 2)\n    i[n >> 1] >> 4 >= 8 && (e[n] = e[n].toUpperCase()), (i[n >> 1] & 15) >= 8 && (e[n + 1] = e[n + 1].toUpperCase());\n  return \"0x\" + e.join(\"\");\n}\nconst Vv = 9007199254740991;\nfunction Wv(r) {\n  return Math.log10 ? Math.log10(r) : Math.log(r) / Math.LN10;\n}\nconst zo = {};\nfor (let r = 0; r < 10; r++)\n  zo[String(r)] = String(r);\nfor (let r = 0; r < 26; r++)\n  zo[String.fromCharCode(65 + r)] = String(10 + r);\nconst fc = Math.floor(Wv(Vv));\nfunction Gv(r) {\n  r = r.toUpperCase(), r = r.substring(4) + r.substring(0, 2) + \"00\";\n  let e = r.split(\"\").map((i) => zo[i]).join(\"\");\n  for (; e.length >= fc; ) {\n    let i = e.substring(0, fc);\n    e = parseInt(i, 10) % 97 + e.substring(i.length);\n  }\n  let t = String(98 - parseInt(e, 10) % 97);\n  for (; t.length < 2; )\n    t = \"0\" + t;\n  return t;\n}\nfunction Jv(r) {\n  let e = null;\n  if (typeof r != \"string\" && kn.throwArgumentError(\"invalid address\", \"address\", r), r.match(/^(0x)?[0-9a-fA-F]{40}$/))\n    r.substring(0, 2) !== \"0x\" && (r = \"0x\" + r), e = oc(r), r.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== r && kn.throwArgumentError(\"bad address checksum\", \"address\", r);\n  else if (r.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n    for (r.substring(2, 4) !== Gv(r) && kn.throwArgumentError(\"bad icap checksum\", \"address\", r), e = Bv(r.substring(4)); e.length < 40; )\n      e = \"0\" + e;\n    e = oc(\"0x\" + e);\n  } else\n    kn.throwArgumentError(\"invalid address\", \"address\", r);\n  return e;\n}\nglobalThis && globalThis.__awaiter;\nfunction Tn(r, e, t) {\n  Object.defineProperty(r, e, {\n    enumerable: !0,\n    value: t,\n    writable: !1\n  });\n}\nvar ns = {}, Qe = {}, Yi = gu;\nfunction gu(r, e) {\n  if (!r)\n    throw new Error(e || \"Assertion failed\");\n}\ngu.equal = function(e, t, i) {\n  if (e != t)\n    throw new Error(i || \"Assertion failed: \" + e + \" != \" + t);\n};\nvar mo = { exports: {} };\ntypeof Object.create == \"function\" ? mo.exports = function(e, t) {\n  t && (e.super_ = t, e.prototype = Object.create(t.prototype, {\n    constructor: {\n      value: e,\n      enumerable: !1,\n      writable: !0,\n      configurable: !0\n    }\n  }));\n} : mo.exports = function(e, t) {\n  if (t) {\n    e.super_ = t;\n    var i = function() {\n    };\n    i.prototype = t.prototype, e.prototype = new i(), e.prototype.constructor = e;\n  }\n};\nvar ua = mo.exports, Yv = Yi, Xv = ua;\nQe.inherits = Xv;\nfunction Zv(r, e) {\n  return (r.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= r.length ? !1 : (r.charCodeAt(e + 1) & 64512) === 56320;\n}\nfunction Qv(r, e) {\n  if (Array.isArray(r))\n    return r.slice();\n  if (!r)\n    return [];\n  var t = [];\n  if (typeof r == \"string\")\n    if (e) {\n      if (e === \"hex\")\n        for (r = r.replace(/[^a-z0-9]+/ig, \"\"), r.length % 2 !== 0 && (r = \"0\" + r), n = 0; n < r.length; n += 2)\n          t.push(parseInt(r[n] + r[n + 1], 16));\n    } else\n      for (var i = 0, n = 0; n < r.length; n++) {\n        var s = r.charCodeAt(n);\n        s < 128 ? t[i++] = s : s < 2048 ? (t[i++] = s >> 6 | 192, t[i++] = s & 63 | 128) : Zv(r, n) ? (s = 65536 + ((s & 1023) << 10) + (r.charCodeAt(++n) & 1023), t[i++] = s >> 18 | 240, t[i++] = s >> 12 & 63 | 128, t[i++] = s >> 6 & 63 | 128, t[i++] = s & 63 | 128) : (t[i++] = s >> 12 | 224, t[i++] = s >> 6 & 63 | 128, t[i++] = s & 63 | 128);\n      }\n  else\n    for (n = 0; n < r.length; n++)\n      t[n] = r[n] | 0;\n  return t;\n}\nQe.toArray = Qv;\nfunction eb(r) {\n  for (var e = \"\", t = 0; t < r.length; t++)\n    e += mu(r[t].toString(16));\n  return e;\n}\nQe.toHex = eb;\nfunction yu(r) {\n  var e = r >>> 24 | r >>> 8 & 65280 | r << 8 & 16711680 | (r & 255) << 24;\n  return e >>> 0;\n}\nQe.htonl = yu;\nfunction tb(r, e) {\n  for (var t = \"\", i = 0; i < r.length; i++) {\n    var n = r[i];\n    e === \"little\" && (n = yu(n)), t += wu(n.toString(16));\n  }\n  return t;\n}\nQe.toHex32 = tb;\nfunction mu(r) {\n  return r.length === 1 ? \"0\" + r : r;\n}\nQe.zero2 = mu;\nfunction wu(r) {\n  return r.length === 7 ? \"0\" + r : r.length === 6 ? \"00\" + r : r.length === 5 ? \"000\" + r : r.length === 4 ? \"0000\" + r : r.length === 3 ? \"00000\" + r : r.length === 2 ? \"000000\" + r : r.length === 1 ? \"0000000\" + r : r;\n}\nQe.zero8 = wu;\nfunction rb(r, e, t, i) {\n  var n = t - e;\n  Yv(n % 4 === 0);\n  for (var s = new Array(n / 4), o = 0, f = e; o < s.length; o++, f += 4) {\n    var h;\n    i === \"big\" ? h = r[f] << 24 | r[f + 1] << 16 | r[f + 2] << 8 | r[f + 3] : h = r[f + 3] << 24 | r[f + 2] << 16 | r[f + 1] << 8 | r[f], s[o] = h >>> 0;\n  }\n  return s;\n}\nQe.join32 = rb;\nfunction ib(r, e) {\n  for (var t = new Array(r.length * 4), i = 0, n = 0; i < r.length; i++, n += 4) {\n    var s = r[i];\n    e === \"big\" ? (t[n] = s >>> 24, t[n + 1] = s >>> 16 & 255, t[n + 2] = s >>> 8 & 255, t[n + 3] = s & 255) : (t[n + 3] = s >>> 24, t[n + 2] = s >>> 16 & 255, t[n + 1] = s >>> 8 & 255, t[n] = s & 255);\n  }\n  return t;\n}\nQe.split32 = ib;\nfunction nb(r, e) {\n  return r >>> e | r << 32 - e;\n}\nQe.rotr32 = nb;\nfunction sb(r, e) {\n  return r << e | r >>> 32 - e;\n}\nQe.rotl32 = sb;\nfunction ab(r, e) {\n  return r + e >>> 0;\n}\nQe.sum32 = ab;\nfunction ob(r, e, t) {\n  return r + e + t >>> 0;\n}\nQe.sum32_3 = ob;\nfunction fb(r, e, t, i) {\n  return r + e + t + i >>> 0;\n}\nQe.sum32_4 = fb;\nfunction cb(r, e, t, i, n) {\n  return r + e + t + i + n >>> 0;\n}\nQe.sum32_5 = cb;\nfunction hb(r, e, t, i) {\n  var n = r[e], s = r[e + 1], o = i + s >>> 0, f = (o < i ? 1 : 0) + t + n;\n  r[e] = f >>> 0, r[e + 1] = o;\n}\nQe.sum64 = hb;\nfunction ub(r, e, t, i) {\n  var n = e + i >>> 0, s = (n < e ? 1 : 0) + r + t;\n  return s >>> 0;\n}\nQe.sum64_hi = ub;\nfunction db(r, e, t, i) {\n  var n = e + i;\n  return n >>> 0;\n}\nQe.sum64_lo = db;\nfunction lb(r, e, t, i, n, s, o, f) {\n  var h = 0, d = e;\n  d = d + i >>> 0, h += d < e ? 1 : 0, d = d + s >>> 0, h += d < s ? 1 : 0, d = d + f >>> 0, h += d < f ? 1 : 0;\n  var v = r + t + n + o + h;\n  return v >>> 0;\n}\nQe.sum64_4_hi = lb;\nfunction pb(r, e, t, i, n, s, o, f) {\n  var h = e + i + s + f;\n  return h >>> 0;\n}\nQe.sum64_4_lo = pb;\nfunction vb(r, e, t, i, n, s, o, f, h, d) {\n  var v = 0, w = e;\n  w = w + i >>> 0, v += w < e ? 1 : 0, w = w + s >>> 0, v += w < s ? 1 : 0, w = w + f >>> 0, v += w < f ? 1 : 0, w = w + d >>> 0, v += w < d ? 1 : 0;\n  var A = r + t + n + o + h + v;\n  return A >>> 0;\n}\nQe.sum64_5_hi = vb;\nfunction bb(r, e, t, i, n, s, o, f, h, d) {\n  var v = e + i + s + f + d;\n  return v >>> 0;\n}\nQe.sum64_5_lo = bb;\nfunction gb(r, e, t) {\n  var i = e << 32 - t | r >>> t;\n  return i >>> 0;\n}\nQe.rotr64_hi = gb;\nfunction yb(r, e, t) {\n  var i = r << 32 - t | e >>> t;\n  return i >>> 0;\n}\nQe.rotr64_lo = yb;\nfunction mb(r, e, t) {\n  return r >>> t;\n}\nQe.shr64_hi = mb;\nfunction wb(r, e, t) {\n  var i = r << 32 - t | e >>> t;\n  return i >>> 0;\n}\nQe.shr64_lo = wb;\nvar mn = {}, cc = Qe, _b = Yi;\nfunction da() {\n  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = \"big\", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;\n}\nmn.BlockHash = da;\nda.prototype.update = function(e, t) {\n  if (e = cc.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {\n    e = this.pending;\n    var i = e.length % this._delta8;\n    this.pending = e.slice(e.length - i, e.length), this.pending.length === 0 && (this.pending = null), e = cc.join32(e, 0, e.length - i, this.endian);\n    for (var n = 0; n < e.length; n += this._delta32)\n      this._update(e, n, n + this._delta32);\n  }\n  return this;\n};\nda.prototype.digest = function(e) {\n  return this.update(this._pad()), _b(this.pending === null), this._digest(e);\n};\nda.prototype._pad = function() {\n  var e = this.pendingTotal, t = this._delta8, i = t - (e + this.padLength) % t, n = new Array(i + this.padLength);\n  n[0] = 128;\n  for (var s = 1; s < i; s++)\n    n[s] = 0;\n  if (e <<= 3, this.endian === \"big\") {\n    for (var o = 8; o < this.padLength; o++)\n      n[s++] = 0;\n    n[s++] = 0, n[s++] = 0, n[s++] = 0, n[s++] = 0, n[s++] = e >>> 24 & 255, n[s++] = e >>> 16 & 255, n[s++] = e >>> 8 & 255, n[s++] = e & 255;\n  } else\n    for (n[s++] = e & 255, n[s++] = e >>> 8 & 255, n[s++] = e >>> 16 & 255, n[s++] = e >>> 24 & 255, n[s++] = 0, n[s++] = 0, n[s++] = 0, n[s++] = 0, o = 8; o < this.padLength; o++)\n      n[s++] = 0;\n  return n;\n};\nvar wn = {}, Kr = {}, xb = Qe, Fr = xb.rotr32;\nfunction Eb(r, e, t, i) {\n  if (r === 0)\n    return _u(e, t, i);\n  if (r === 1 || r === 3)\n    return Eu(e, t, i);\n  if (r === 2)\n    return xu(e, t, i);\n}\nKr.ft_1 = Eb;\nfunction _u(r, e, t) {\n  return r & e ^ ~r & t;\n}\nKr.ch32 = _u;\nfunction xu(r, e, t) {\n  return r & e ^ r & t ^ e & t;\n}\nKr.maj32 = xu;\nfunction Eu(r, e, t) {\n  return r ^ e ^ t;\n}\nKr.p32 = Eu;\nfunction Sb(r) {\n  return Fr(r, 2) ^ Fr(r, 13) ^ Fr(r, 22);\n}\nKr.s0_256 = Sb;\nfunction Mb(r) {\n  return Fr(r, 6) ^ Fr(r, 11) ^ Fr(r, 25);\n}\nKr.s1_256 = Mb;\nfunction Ib(r) {\n  return Fr(r, 7) ^ Fr(r, 18) ^ r >>> 3;\n}\nKr.g0_256 = Ib;\nfunction Ab(r) {\n  return Fr(r, 17) ^ Fr(r, 19) ^ r >>> 10;\n}\nKr.g1_256 = Ab;\nvar dn = Qe, Db = mn, Pb = Kr, ja = dn.rotl32, Cn = dn.sum32, Ob = dn.sum32_5, Rb = Pb.ft_1, Su = Db.BlockHash, Nb = [\n  1518500249,\n  1859775393,\n  2400959708,\n  3395469782\n];\nfunction zr() {\n  if (!(this instanceof zr))\n    return new zr();\n  Su.call(this), this.h = [\n    1732584193,\n    4023233417,\n    2562383102,\n    271733878,\n    3285377520\n  ], this.W = new Array(80);\n}\ndn.inherits(zr, Su);\nvar Tb = zr;\nzr.blockSize = 512;\nzr.outSize = 160;\nzr.hmacStrength = 80;\nzr.padLength = 64;\nzr.prototype._update = function(e, t) {\n  for (var i = this.W, n = 0; n < 16; n++)\n    i[n] = e[t + n];\n  for (; n < i.length; n++)\n    i[n] = ja(i[n - 3] ^ i[n - 8] ^ i[n - 14] ^ i[n - 16], 1);\n  var s = this.h[0], o = this.h[1], f = this.h[2], h = this.h[3], d = this.h[4];\n  for (n = 0; n < i.length; n++) {\n    var v = ~~(n / 20), w = Ob(ja(s, 5), Rb(v, o, f, h), d, i[n], Nb[v]);\n    d = h, h = f, f = ja(o, 30), o = s, s = w;\n  }\n  this.h[0] = Cn(this.h[0], s), this.h[1] = Cn(this.h[1], o), this.h[2] = Cn(this.h[2], f), this.h[3] = Cn(this.h[3], h), this.h[4] = Cn(this.h[4], d);\n};\nzr.prototype._digest = function(e) {\n  return e === \"hex\" ? dn.toHex32(this.h, \"big\") : dn.split32(this.h, \"big\");\n};\nvar ln = Qe, Cb = mn, _n = Kr, $b = Yi, wr = ln.sum32, Lb = ln.sum32_4, Fb = ln.sum32_5, qb = _n.ch32, Ub = _n.maj32, zb = _n.s0_256, Bb = _n.s1_256, kb = _n.g0_256, jb = _n.g1_256, Mu = Cb.BlockHash, Kb = [\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n];\nfunction Br() {\n  if (!(this instanceof Br))\n    return new Br();\n  Mu.call(this), this.h = [\n    1779033703,\n    3144134277,\n    1013904242,\n    2773480762,\n    1359893119,\n    2600822924,\n    528734635,\n    1541459225\n  ], this.k = Kb, this.W = new Array(64);\n}\nln.inherits(Br, Mu);\nvar Iu = Br;\nBr.blockSize = 512;\nBr.outSize = 256;\nBr.hmacStrength = 192;\nBr.padLength = 64;\nBr.prototype._update = function(e, t) {\n  for (var i = this.W, n = 0; n < 16; n++)\n    i[n] = e[t + n];\n  for (; n < i.length; n++)\n    i[n] = Lb(jb(i[n - 2]), i[n - 7], kb(i[n - 15]), i[n - 16]);\n  var s = this.h[0], o = this.h[1], f = this.h[2], h = this.h[3], d = this.h[4], v = this.h[5], w = this.h[6], A = this.h[7];\n  for ($b(this.k.length === i.length), n = 0; n < i.length; n++) {\n    var I = Fb(A, Bb(d), qb(d, v, w), this.k[n], i[n]), D = wr(zb(s), Ub(s, o, f));\n    A = w, w = v, v = d, d = wr(h, I), h = f, f = o, o = s, s = wr(I, D);\n  }\n  this.h[0] = wr(this.h[0], s), this.h[1] = wr(this.h[1], o), this.h[2] = wr(this.h[2], f), this.h[3] = wr(this.h[3], h), this.h[4] = wr(this.h[4], d), this.h[5] = wr(this.h[5], v), this.h[6] = wr(this.h[6], w), this.h[7] = wr(this.h[7], A);\n};\nBr.prototype._digest = function(e) {\n  return e === \"hex\" ? ln.toHex32(this.h, \"big\") : ln.split32(this.h, \"big\");\n};\nvar wo = Qe, Au = Iu;\nfunction ui() {\n  if (!(this instanceof ui))\n    return new ui();\n  Au.call(this), this.h = [\n    3238371032,\n    914150663,\n    812702999,\n    4144912697,\n    4290775857,\n    1750603025,\n    1694076839,\n    3204075428\n  ];\n}\nwo.inherits(ui, Au);\nvar Hb = ui;\nui.blockSize = 512;\nui.outSize = 224;\nui.hmacStrength = 192;\nui.padLength = 64;\nui.prototype._digest = function(e) {\n  return e === \"hex\" ? wo.toHex32(this.h.slice(0, 7), \"big\") : wo.split32(this.h.slice(0, 7), \"big\");\n};\nvar Yt = Qe, Vb = mn, Wb = Yi, qr = Yt.rotr64_hi, Ur = Yt.rotr64_lo, Du = Yt.shr64_hi, Pu = Yt.shr64_lo, bi = Yt.sum64, Ka = Yt.sum64_hi, Ha = Yt.sum64_lo, Gb = Yt.sum64_4_hi, Jb = Yt.sum64_4_lo, Yb = Yt.sum64_5_hi, Xb = Yt.sum64_5_lo, Ou = Vb.BlockHash, Zb = [\n  1116352408,\n  3609767458,\n  1899447441,\n  602891725,\n  3049323471,\n  3964484399,\n  3921009573,\n  2173295548,\n  961987163,\n  4081628472,\n  1508970993,\n  3053834265,\n  2453635748,\n  2937671579,\n  2870763221,\n  3664609560,\n  3624381080,\n  2734883394,\n  310598401,\n  1164996542,\n  607225278,\n  1323610764,\n  1426881987,\n  3590304994,\n  1925078388,\n  4068182383,\n  2162078206,\n  991336113,\n  2614888103,\n  633803317,\n  3248222580,\n  3479774868,\n  3835390401,\n  2666613458,\n  4022224774,\n  944711139,\n  264347078,\n  2341262773,\n  604807628,\n  2007800933,\n  770255983,\n  1495990901,\n  1249150122,\n  1856431235,\n  1555081692,\n  3175218132,\n  1996064986,\n  2198950837,\n  2554220882,\n  3999719339,\n  2821834349,\n  766784016,\n  2952996808,\n  2566594879,\n  3210313671,\n  3203337956,\n  3336571891,\n  1034457026,\n  3584528711,\n  2466948901,\n  113926993,\n  3758326383,\n  338241895,\n  168717936,\n  666307205,\n  1188179964,\n  773529912,\n  1546045734,\n  1294757372,\n  1522805485,\n  1396182291,\n  2643833823,\n  1695183700,\n  2343527390,\n  1986661051,\n  1014477480,\n  2177026350,\n  1206759142,\n  2456956037,\n  344077627,\n  2730485921,\n  1290863460,\n  2820302411,\n  3158454273,\n  3259730800,\n  3505952657,\n  3345764771,\n  106217008,\n  3516065817,\n  3606008344,\n  3600352804,\n  1432725776,\n  4094571909,\n  1467031594,\n  275423344,\n  851169720,\n  430227734,\n  3100823752,\n  506948616,\n  1363258195,\n  659060556,\n  3750685593,\n  883997877,\n  3785050280,\n  958139571,\n  3318307427,\n  1322822218,\n  3812723403,\n  1537002063,\n  2003034995,\n  1747873779,\n  3602036899,\n  1955562222,\n  1575990012,\n  2024104815,\n  1125592928,\n  2227730452,\n  2716904306,\n  2361852424,\n  442776044,\n  2428436474,\n  593698344,\n  2756734187,\n  3733110249,\n  3204031479,\n  2999351573,\n  3329325298,\n  3815920427,\n  3391569614,\n  3928383900,\n  3515267271,\n  566280711,\n  3940187606,\n  3454069534,\n  4118630271,\n  4000239992,\n  116418474,\n  1914138554,\n  174292421,\n  2731055270,\n  289380356,\n  3203993006,\n  460393269,\n  320620315,\n  685471733,\n  587496836,\n  852142971,\n  1086792851,\n  1017036298,\n  365543100,\n  1126000580,\n  2618297676,\n  1288033470,\n  3409855158,\n  1501505948,\n  4234509866,\n  1607167915,\n  987167468,\n  1816402316,\n  1246189591\n];\nfunction Ar() {\n  if (!(this instanceof Ar))\n    return new Ar();\n  Ou.call(this), this.h = [\n    1779033703,\n    4089235720,\n    3144134277,\n    2227873595,\n    1013904242,\n    4271175723,\n    2773480762,\n    1595750129,\n    1359893119,\n    2917565137,\n    2600822924,\n    725511199,\n    528734635,\n    4215389547,\n    1541459225,\n    327033209\n  ], this.k = Zb, this.W = new Array(160);\n}\nYt.inherits(Ar, Ou);\nvar Ru = Ar;\nAr.blockSize = 1024;\nAr.outSize = 512;\nAr.hmacStrength = 192;\nAr.padLength = 128;\nAr.prototype._prepareBlock = function(e, t) {\n  for (var i = this.W, n = 0; n < 32; n++)\n    i[n] = e[t + n];\n  for (; n < i.length; n += 2) {\n    var s = cg(i[n - 4], i[n - 3]), o = hg(i[n - 4], i[n - 3]), f = i[n - 14], h = i[n - 13], d = og(i[n - 30], i[n - 29]), v = fg(i[n - 30], i[n - 29]), w = i[n - 32], A = i[n - 31];\n    i[n] = Gb(\n      s,\n      o,\n      f,\n      h,\n      d,\n      v,\n      w,\n      A\n    ), i[n + 1] = Jb(\n      s,\n      o,\n      f,\n      h,\n      d,\n      v,\n      w,\n      A\n    );\n  }\n};\nAr.prototype._update = function(e, t) {\n  this._prepareBlock(e, t);\n  var i = this.W, n = this.h[0], s = this.h[1], o = this.h[2], f = this.h[3], h = this.h[4], d = this.h[5], v = this.h[6], w = this.h[7], A = this.h[8], I = this.h[9], D = this.h[10], N = this.h[11], k = this.h[12], j = this.h[13], T = this.h[14], K = this.h[15];\n  Wb(this.k.length === i.length);\n  for (var $ = 0; $ < i.length; $ += 2) {\n    var z = T, B = K, _ = sg(A, I), R = ag(A, I), J = Qb(A, I, D, N, k), Q = eg(A, I, D, N, k, j), O = this.k[$], p = this.k[$ + 1], l = i[$], a = i[$ + 1], c = Yb(\n      z,\n      B,\n      _,\n      R,\n      J,\n      Q,\n      O,\n      p,\n      l,\n      a\n    ), b = Xb(\n      z,\n      B,\n      _,\n      R,\n      J,\n      Q,\n      O,\n      p,\n      l,\n      a\n    );\n    z = ig(n, s), B = ng(n, s), _ = tg(n, s, o, f, h), R = rg(n, s, o, f, h, d);\n    var E = Ka(z, B, _, R), S = Ha(z, B, _, R);\n    T = k, K = j, k = D, j = N, D = A, N = I, A = Ka(v, w, c, b), I = Ha(w, w, c, b), v = h, w = d, h = o, d = f, o = n, f = s, n = Ka(c, b, E, S), s = Ha(c, b, E, S);\n  }\n  bi(this.h, 0, n, s), bi(this.h, 2, o, f), bi(this.h, 4, h, d), bi(this.h, 6, v, w), bi(this.h, 8, A, I), bi(this.h, 10, D, N), bi(this.h, 12, k, j), bi(this.h, 14, T, K);\n};\nAr.prototype._digest = function(e) {\n  return e === \"hex\" ? Yt.toHex32(this.h, \"big\") : Yt.split32(this.h, \"big\");\n};\nfunction Qb(r, e, t, i, n) {\n  var s = r & t ^ ~r & n;\n  return s < 0 && (s += 4294967296), s;\n}\nfunction eg(r, e, t, i, n, s) {\n  var o = e & i ^ ~e & s;\n  return o < 0 && (o += 4294967296), o;\n}\nfunction tg(r, e, t, i, n) {\n  var s = r & t ^ r & n ^ t & n;\n  return s < 0 && (s += 4294967296), s;\n}\nfunction rg(r, e, t, i, n, s) {\n  var o = e & i ^ e & s ^ i & s;\n  return o < 0 && (o += 4294967296), o;\n}\nfunction ig(r, e) {\n  var t = qr(r, e, 28), i = qr(e, r, 2), n = qr(e, r, 7), s = t ^ i ^ n;\n  return s < 0 && (s += 4294967296), s;\n}\nfunction ng(r, e) {\n  var t = Ur(r, e, 28), i = Ur(e, r, 2), n = Ur(e, r, 7), s = t ^ i ^ n;\n  return s < 0 && (s += 4294967296), s;\n}\nfunction sg(r, e) {\n  var t = qr(r, e, 14), i = qr(r, e, 18), n = qr(e, r, 9), s = t ^ i ^ n;\n  return s < 0 && (s += 4294967296), s;\n}\nfunction ag(r, e) {\n  var t = Ur(r, e, 14), i = Ur(r, e, 18), n = Ur(e, r, 9), s = t ^ i ^ n;\n  return s < 0 && (s += 4294967296), s;\n}\nfunction og(r, e) {\n  var t = qr(r, e, 1), i = qr(r, e, 8), n = Du(r, e, 7), s = t ^ i ^ n;\n  return s < 0 && (s += 4294967296), s;\n}\nfunction fg(r, e) {\n  var t = Ur(r, e, 1), i = Ur(r, e, 8), n = Pu(r, e, 7), s = t ^ i ^ n;\n  return s < 0 && (s += 4294967296), s;\n}\nfunction cg(r, e) {\n  var t = qr(r, e, 19), i = qr(e, r, 29), n = Du(r, e, 6), s = t ^ i ^ n;\n  return s < 0 && (s += 4294967296), s;\n}\nfunction hg(r, e) {\n  var t = Ur(r, e, 19), i = Ur(e, r, 29), n = Pu(r, e, 6), s = t ^ i ^ n;\n  return s < 0 && (s += 4294967296), s;\n}\nvar _o = Qe, Nu = Ru;\nfunction di() {\n  if (!(this instanceof di))\n    return new di();\n  Nu.call(this), this.h = [\n    3418070365,\n    3238371032,\n    1654270250,\n    914150663,\n    2438529370,\n    812702999,\n    355462360,\n    4144912697,\n    1731405415,\n    4290775857,\n    2394180231,\n    1750603025,\n    3675008525,\n    1694076839,\n    1203062813,\n    3204075428\n  ];\n}\n_o.inherits(di, Nu);\nvar ug = di;\ndi.blockSize = 1024;\ndi.outSize = 384;\ndi.hmacStrength = 192;\ndi.padLength = 128;\ndi.prototype._digest = function(e) {\n  return e === \"hex\" ? _o.toHex32(this.h.slice(0, 12), \"big\") : _o.split32(this.h.slice(0, 12), \"big\");\n};\nwn.sha1 = Tb;\nwn.sha224 = Hb;\nwn.sha256 = Iu;\nwn.sha384 = ug;\nwn.sha512 = Ru;\nvar Tu = {}, Ki = Qe, dg = mn, xs = Ki.rotl32, hc = Ki.sum32, $n = Ki.sum32_3, uc = Ki.sum32_4, Cu = dg.BlockHash;\nfunction kr() {\n  if (!(this instanceof kr))\n    return new kr();\n  Cu.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = \"little\";\n}\nKi.inherits(kr, Cu);\nTu.ripemd160 = kr;\nkr.blockSize = 512;\nkr.outSize = 160;\nkr.hmacStrength = 192;\nkr.padLength = 64;\nkr.prototype._update = function(e, t) {\n  for (var i = this.h[0], n = this.h[1], s = this.h[2], o = this.h[3], f = this.h[4], h = i, d = n, v = s, w = o, A = f, I = 0; I < 80; I++) {\n    var D = hc(\n      xs(\n        uc(i, dc(I, n, s, o), e[vg[I] + t], lg(I)),\n        gg[I]\n      ),\n      f\n    );\n    i = f, f = o, o = xs(s, 10), s = n, n = D, D = hc(\n      xs(\n        uc(h, dc(79 - I, d, v, w), e[bg[I] + t], pg(I)),\n        yg[I]\n      ),\n      A\n    ), h = A, A = w, w = xs(v, 10), v = d, d = D;\n  }\n  D = $n(this.h[1], s, w), this.h[1] = $n(this.h[2], o, A), this.h[2] = $n(this.h[3], f, h), this.h[3] = $n(this.h[4], i, d), this.h[4] = $n(this.h[0], n, v), this.h[0] = D;\n};\nkr.prototype._digest = function(e) {\n  return e === \"hex\" ? Ki.toHex32(this.h, \"little\") : Ki.split32(this.h, \"little\");\n};\nfunction dc(r, e, t, i) {\n  return r <= 15 ? e ^ t ^ i : r <= 31 ? e & t | ~e & i : r <= 47 ? (e | ~t) ^ i : r <= 63 ? e & i | t & ~i : e ^ (t | ~i);\n}\nfunction lg(r) {\n  return r <= 15 ? 0 : r <= 31 ? 1518500249 : r <= 47 ? 1859775393 : r <= 63 ? 2400959708 : 2840853838;\n}\nfunction pg(r) {\n  return r <= 15 ? 1352829926 : r <= 31 ? 1548603684 : r <= 47 ? 1836072691 : r <= 63 ? 2053994217 : 0;\n}\nvar vg = [\n  0,\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  7,\n  4,\n  13,\n  1,\n  10,\n  6,\n  15,\n  3,\n  12,\n  0,\n  9,\n  5,\n  2,\n  14,\n  11,\n  8,\n  3,\n  10,\n  14,\n  4,\n  9,\n  15,\n  8,\n  1,\n  2,\n  7,\n  0,\n  6,\n  13,\n  11,\n  5,\n  12,\n  1,\n  9,\n  11,\n  10,\n  0,\n  8,\n  12,\n  4,\n  13,\n  3,\n  7,\n  15,\n  14,\n  5,\n  6,\n  2,\n  4,\n  0,\n  5,\n  9,\n  7,\n  12,\n  2,\n  10,\n  14,\n  1,\n  3,\n  8,\n  11,\n  6,\n  15,\n  13\n], bg = [\n  5,\n  14,\n  7,\n  0,\n  9,\n  2,\n  11,\n  4,\n  13,\n  6,\n  15,\n  8,\n  1,\n  10,\n  3,\n  12,\n  6,\n  11,\n  3,\n  7,\n  0,\n  13,\n  5,\n  10,\n  14,\n  15,\n  8,\n  12,\n  4,\n  9,\n  1,\n  2,\n  15,\n  5,\n  1,\n  3,\n  7,\n  14,\n  6,\n  9,\n  11,\n  8,\n  12,\n  2,\n  10,\n  0,\n  4,\n  13,\n  8,\n  6,\n  4,\n  1,\n  3,\n  11,\n  15,\n  0,\n  5,\n  12,\n  2,\n  13,\n  9,\n  7,\n  10,\n  14,\n  12,\n  15,\n  10,\n  4,\n  1,\n  5,\n  8,\n  7,\n  6,\n  2,\n  13,\n  14,\n  0,\n  3,\n  9,\n  11\n], gg = [\n  11,\n  14,\n  15,\n  12,\n  5,\n  8,\n  7,\n  9,\n  11,\n  13,\n  14,\n  15,\n  6,\n  7,\n  9,\n  8,\n  7,\n  6,\n  8,\n  13,\n  11,\n  9,\n  7,\n  15,\n  7,\n  12,\n  15,\n  9,\n  11,\n  7,\n  13,\n  12,\n  11,\n  13,\n  6,\n  7,\n  14,\n  9,\n  13,\n  15,\n  14,\n  8,\n  13,\n  6,\n  5,\n  12,\n  7,\n  5,\n  11,\n  12,\n  14,\n  15,\n  14,\n  15,\n  9,\n  8,\n  9,\n  14,\n  5,\n  6,\n  8,\n  6,\n  5,\n  12,\n  9,\n  15,\n  5,\n  11,\n  6,\n  8,\n  13,\n  12,\n  5,\n  12,\n  13,\n  14,\n  11,\n  8,\n  5,\n  6\n], yg = [\n  8,\n  9,\n  9,\n  11,\n  13,\n  15,\n  15,\n  5,\n  7,\n  7,\n  8,\n  11,\n  14,\n  14,\n  12,\n  6,\n  9,\n  13,\n  15,\n  7,\n  12,\n  8,\n  9,\n  11,\n  7,\n  7,\n  12,\n  7,\n  6,\n  15,\n  13,\n  11,\n  9,\n  7,\n  15,\n  11,\n  8,\n  6,\n  6,\n  14,\n  12,\n  13,\n  5,\n  14,\n  13,\n  13,\n  7,\n  5,\n  15,\n  5,\n  8,\n  11,\n  14,\n  14,\n  6,\n  14,\n  6,\n  9,\n  12,\n  9,\n  12,\n  5,\n  15,\n  8,\n  8,\n  5,\n  12,\n  9,\n  12,\n  5,\n  14,\n  6,\n  8,\n  13,\n  6,\n  5,\n  15,\n  13,\n  11,\n  11\n], mg = Qe, wg = Yi;\nfunction pn(r, e, t) {\n  if (!(this instanceof pn))\n    return new pn(r, e, t);\n  this.Hash = r, this.blockSize = r.blockSize / 8, this.outSize = r.outSize / 8, this.inner = null, this.outer = null, this._init(mg.toArray(e, t));\n}\nvar _g = pn;\npn.prototype._init = function(e) {\n  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), wg(e.length <= this.blockSize);\n  for (var t = e.length; t < this.blockSize; t++)\n    e.push(0);\n  for (t = 0; t < e.length; t++)\n    e[t] ^= 54;\n  for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++)\n    e[t] ^= 106;\n  this.outer = new this.Hash().update(e);\n};\npn.prototype.update = function(e, t) {\n  return this.inner.update(e, t), this;\n};\npn.prototype.digest = function(e) {\n  return this.outer.update(this.inner.digest()), this.outer.digest(e);\n};\n(function(r) {\n  var e = r;\n  e.utils = Qe, e.common = mn, e.sha = wn, e.ripemd = Tu, e.hmac = _g, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;\n})(ns);\nconst si = /* @__PURE__ */ (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.d)(ns);\nfunction xn(r, e, t) {\n  return t = {\n    path: e,\n    exports: {},\n    require: function(i, n) {\n      return xg(i, n ?? t.path);\n    }\n  }, r(t, t.exports), t.exports;\n}\nfunction xg() {\n  throw new Error(\"Dynamic requires are not currently supported by @rollup/plugin-commonjs\");\n}\nvar Bo = $u;\nfunction $u(r, e) {\n  if (!r)\n    throw new Error(e || \"Assertion failed\");\n}\n$u.equal = function(e, t, i) {\n  if (e != t)\n    throw new Error(i || \"Assertion failed: \" + e + \" != \" + t);\n};\nvar Mr = xn(function(r, e) {\n  var t = e;\n  function i(o, f) {\n    if (Array.isArray(o))\n      return o.slice();\n    if (!o)\n      return [];\n    var h = [];\n    if (typeof o != \"string\") {\n      for (var d = 0; d < o.length; d++)\n        h[d] = o[d] | 0;\n      return h;\n    }\n    if (f === \"hex\") {\n      o = o.replace(/[^a-z0-9]+/ig, \"\"), o.length % 2 !== 0 && (o = \"0\" + o);\n      for (var d = 0; d < o.length; d += 2)\n        h.push(parseInt(o[d] + o[d + 1], 16));\n    } else\n      for (var d = 0; d < o.length; d++) {\n        var v = o.charCodeAt(d), w = v >> 8, A = v & 255;\n        w ? h.push(w, A) : h.push(A);\n      }\n    return h;\n  }\n  t.toArray = i;\n  function n(o) {\n    return o.length === 1 ? \"0\" + o : o;\n  }\n  t.zero2 = n;\n  function s(o) {\n    for (var f = \"\", h = 0; h < o.length; h++)\n      f += n(o[h].toString(16));\n    return f;\n  }\n  t.toHex = s, t.encode = function(f, h) {\n    return h === \"hex\" ? s(f) : f;\n  };\n}), sr = xn(function(r, e) {\n  var t = e;\n  t.assert = Bo, t.toArray = Mr.toArray, t.zero2 = Mr.zero2, t.toHex = Mr.toHex, t.encode = Mr.encode;\n  function i(h, d, v) {\n    var w = new Array(Math.max(h.bitLength(), v) + 1);\n    w.fill(0);\n    for (var A = 1 << d + 1, I = h.clone(), D = 0; D < w.length; D++) {\n      var N, k = I.andln(A - 1);\n      I.isOdd() ? (k > (A >> 1) - 1 ? N = (A >> 1) - k : N = k, I.isubn(N)) : N = 0, w[D] = N, I.iushrn(1);\n    }\n    return w;\n  }\n  t.getNAF = i;\n  function n(h, d) {\n    var v = [\n      [],\n      []\n    ];\n    h = h.clone(), d = d.clone();\n    for (var w = 0, A = 0, I; h.cmpn(-w) > 0 || d.cmpn(-A) > 0; ) {\n      var D = h.andln(3) + w & 3, N = d.andln(3) + A & 3;\n      D === 3 && (D = -1), N === 3 && (N = -1);\n      var k;\n      D & 1 ? (I = h.andln(7) + w & 7, (I === 3 || I === 5) && N === 2 ? k = -D : k = D) : k = 0, v[0].push(k);\n      var j;\n      N & 1 ? (I = d.andln(7) + A & 7, (I === 3 || I === 5) && D === 2 ? j = -N : j = N) : j = 0, v[1].push(j), 2 * w === k + 1 && (w = 1 - w), 2 * A === j + 1 && (A = 1 - A), h.iushrn(1), d.iushrn(1);\n    }\n    return v;\n  }\n  t.getJSF = n;\n  function s(h, d, v) {\n    var w = \"_\" + d;\n    h.prototype[d] = function() {\n      return this[w] !== void 0 ? this[w] : this[w] = v.call(this);\n    };\n  }\n  t.cachedProperty = s;\n  function o(h) {\n    return typeof h == \"string\" ? t.toArray(h, \"hex\") : h;\n  }\n  t.parseBytes = o;\n  function f(h) {\n    return new Ke(h, \"hex\", \"le\");\n  }\n  t.intFromLE = f;\n}), js = sr.getNAF, Eg = sr.getJSF, Ks = sr.assert;\nfunction Si(r, e) {\n  this.type = r, this.p = new Ke(e.p, 16), this.red = e.prime ? Ke.red(e.prime) : Ke.mont(this.p), this.zero = new Ke(0).toRed(this.red), this.one = new Ke(1).toRed(this.red), this.two = new Ke(2).toRed(this.red), this.n = e.n && new Ke(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;\n  var t = this.n && this.p.div(this.n);\n  !t || t.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));\n}\nvar Xi = Si;\nSi.prototype.point = function() {\n  throw new Error(\"Not implemented\");\n};\nSi.prototype.validate = function() {\n  throw new Error(\"Not implemented\");\n};\nSi.prototype._fixedNafMul = function(e, t) {\n  Ks(e.precomputed);\n  var i = e._getDoubles(), n = js(t, 1, this._bitLength), s = (1 << i.step + 1) - (i.step % 2 === 0 ? 2 : 1);\n  s /= 3;\n  var o = [], f, h;\n  for (f = 0; f < n.length; f += i.step) {\n    h = 0;\n    for (var d = f + i.step - 1; d >= f; d--)\n      h = (h << 1) + n[d];\n    o.push(h);\n  }\n  for (var v = this.jpoint(null, null, null), w = this.jpoint(null, null, null), A = s; A > 0; A--) {\n    for (f = 0; f < o.length; f++)\n      h = o[f], h === A ? w = w.mixedAdd(i.points[f]) : h === -A && (w = w.mixedAdd(i.points[f].neg()));\n    v = v.add(w);\n  }\n  return v.toP();\n};\nSi.prototype._wnafMul = function(e, t) {\n  var i = 4, n = e._getNAFPoints(i);\n  i = n.wnd;\n  for (var s = n.points, o = js(t, i, this._bitLength), f = this.jpoint(null, null, null), h = o.length - 1; h >= 0; h--) {\n    for (var d = 0; h >= 0 && o[h] === 0; h--)\n      d++;\n    if (h >= 0 && d++, f = f.dblp(d), h < 0)\n      break;\n    var v = o[h];\n    Ks(v !== 0), e.type === \"affine\" ? v > 0 ? f = f.mixedAdd(s[v - 1 >> 1]) : f = f.mixedAdd(s[-v - 1 >> 1].neg()) : v > 0 ? f = f.add(s[v - 1 >> 1]) : f = f.add(s[-v - 1 >> 1].neg());\n  }\n  return e.type === \"affine\" ? f.toP() : f;\n};\nSi.prototype._wnafMulAdd = function(e, t, i, n, s) {\n  var o = this._wnafT1, f = this._wnafT2, h = this._wnafT3, d = 0, v, w, A;\n  for (v = 0; v < n; v++) {\n    A = t[v];\n    var I = A._getNAFPoints(e);\n    o[v] = I.wnd, f[v] = I.points;\n  }\n  for (v = n - 1; v >= 1; v -= 2) {\n    var D = v - 1, N = v;\n    if (o[D] !== 1 || o[N] !== 1) {\n      h[D] = js(i[D], o[D], this._bitLength), h[N] = js(i[N], o[N], this._bitLength), d = Math.max(h[D].length, d), d = Math.max(h[N].length, d);\n      continue;\n    }\n    var k = [\n      t[D],\n      /* 1 */\n      null,\n      /* 3 */\n      null,\n      /* 5 */\n      t[N]\n      /* 7 */\n    ];\n    t[D].y.cmp(t[N].y) === 0 ? (k[1] = t[D].add(t[N]), k[2] = t[D].toJ().mixedAdd(t[N].neg())) : t[D].y.cmp(t[N].y.redNeg()) === 0 ? (k[1] = t[D].toJ().mixedAdd(t[N]), k[2] = t[D].add(t[N].neg())) : (k[1] = t[D].toJ().mixedAdd(t[N]), k[2] = t[D].toJ().mixedAdd(t[N].neg()));\n    var j = [\n      -3,\n      /* -1 -1 */\n      -1,\n      /* -1 0 */\n      -5,\n      /* -1 1 */\n      -7,\n      /* 0 -1 */\n      0,\n      /* 0 0 */\n      7,\n      /* 0 1 */\n      5,\n      /* 1 -1 */\n      1,\n      /* 1 0 */\n      3\n      /* 1 1 */\n    ], T = Eg(i[D], i[N]);\n    for (d = Math.max(T[0].length, d), h[D] = new Array(d), h[N] = new Array(d), w = 0; w < d; w++) {\n      var K = T[0][w] | 0, $ = T[1][w] | 0;\n      h[D][w] = j[(K + 1) * 3 + ($ + 1)], h[N][w] = 0, f[D] = k;\n    }\n  }\n  var z = this.jpoint(null, null, null), B = this._wnafT4;\n  for (v = d; v >= 0; v--) {\n    for (var _ = 0; v >= 0; ) {\n      var R = !0;\n      for (w = 0; w < n; w++)\n        B[w] = h[w][v] | 0, B[w] !== 0 && (R = !1);\n      if (!R)\n        break;\n      _++, v--;\n    }\n    if (v >= 0 && _++, z = z.dblp(_), v < 0)\n      break;\n    for (w = 0; w < n; w++) {\n      var J = B[w];\n      J !== 0 && (J > 0 ? A = f[w][J - 1 >> 1] : J < 0 && (A = f[w][-J - 1 >> 1].neg()), A.type === \"affine\" ? z = z.mixedAdd(A) : z = z.add(A));\n    }\n  }\n  for (v = 0; v < n; v++)\n    f[v] = null;\n  return s ? z : z.toP();\n};\nfunction vr(r, e) {\n  this.curve = r, this.type = e, this.precomputed = null;\n}\nSi.BasePoint = vr;\nvr.prototype.eq = function() {\n  throw new Error(\"Not implemented\");\n};\nvr.prototype.validate = function() {\n  return this.curve.validate(this);\n};\nSi.prototype.decodePoint = function(e, t) {\n  e = sr.toArray(e, t);\n  var i = this.p.byteLength();\n  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * i) {\n    e[0] === 6 ? Ks(e[e.length - 1] % 2 === 0) : e[0] === 7 && Ks(e[e.length - 1] % 2 === 1);\n    var n = this.point(\n      e.slice(1, 1 + i),\n      e.slice(1 + i, 1 + 2 * i)\n    );\n    return n;\n  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === i)\n    return this.pointFromX(e.slice(1, 1 + i), e[0] === 3);\n  throw new Error(\"Unknown point format\");\n};\nvr.prototype.encodeCompressed = function(e) {\n  return this.encode(e, !0);\n};\nvr.prototype._encode = function(e) {\n  var t = this.curve.p.byteLength(), i = this.getX().toArray(\"be\", t);\n  return e ? [this.getY().isEven() ? 2 : 3].concat(i) : [4].concat(i, this.getY().toArray(\"be\", t));\n};\nvr.prototype.encode = function(e, t) {\n  return sr.encode(this._encode(t), e);\n};\nvr.prototype.precompute = function(e) {\n  if (this.precomputed)\n    return this;\n  var t = {\n    doubles: null,\n    naf: null,\n    beta: null\n  };\n  return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this;\n};\nvr.prototype._hasDoubles = function(e) {\n  if (!this.precomputed)\n    return !1;\n  var t = this.precomputed.doubles;\n  return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1;\n};\nvr.prototype._getDoubles = function(e, t) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n  for (var i = [this], n = this, s = 0; s < t; s += e) {\n    for (var o = 0; o < e; o++)\n      n = n.dbl();\n    i.push(n);\n  }\n  return {\n    step: e,\n    points: i\n  };\n};\nvr.prototype._getNAFPoints = function(e) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n  for (var t = [this], i = (1 << e) - 1, n = i === 1 ? null : this.dbl(), s = 1; s < i; s++)\n    t[s] = t[s - 1].add(n);\n  return {\n    wnd: e,\n    points: t\n  };\n};\nvr.prototype._getBeta = function() {\n  return null;\n};\nvr.prototype.dblp = function(e) {\n  for (var t = this, i = 0; i < e; i++)\n    t = t.dbl();\n  return t;\n};\nvar ko = xn(function(r) {\n  typeof Object.create == \"function\" ? r.exports = function(t, i) {\n    i && (t.super_ = i, t.prototype = Object.create(i.prototype, {\n      constructor: {\n        value: t,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }));\n  } : r.exports = function(t, i) {\n    if (i) {\n      t.super_ = i;\n      var n = function() {\n      };\n      n.prototype = i.prototype, t.prototype = new n(), t.prototype.constructor = t;\n    }\n  };\n}), Sg = sr.assert;\nfunction br(r) {\n  Xi.call(this, \"short\", r), this.a = new Ke(r.a, 16).toRed(this.red), this.b = new Ke(r.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(r), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);\n}\nko(br, Xi);\nvar Mg = br;\nbr.prototype._getEndomorphism = function(e) {\n  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {\n    var t, i;\n    if (e.beta)\n      t = new Ke(e.beta, 16).toRed(this.red);\n    else {\n      var n = this._getEndoRoots(this.p);\n      t = n[0].cmp(n[1]) < 0 ? n[0] : n[1], t = t.toRed(this.red);\n    }\n    if (e.lambda)\n      i = new Ke(e.lambda, 16);\n    else {\n      var s = this._getEndoRoots(this.n);\n      this.g.mul(s[0]).x.cmp(this.g.x.redMul(t)) === 0 ? i = s[0] : (i = s[1], Sg(this.g.mul(i).x.cmp(this.g.x.redMul(t)) === 0));\n    }\n    var o;\n    return e.basis ? o = e.basis.map(function(f) {\n      return {\n        a: new Ke(f.a, 16),\n        b: new Ke(f.b, 16)\n      };\n    }) : o = this._getEndoBasis(i), {\n      beta: t,\n      lambda: i,\n      basis: o\n    };\n  }\n};\nbr.prototype._getEndoRoots = function(e) {\n  var t = e === this.p ? this.red : Ke.mont(e), i = new Ke(2).toRed(t).redInvm(), n = i.redNeg(), s = new Ke(3).toRed(t).redNeg().redSqrt().redMul(i), o = n.redAdd(s).fromRed(), f = n.redSub(s).fromRed();\n  return [o, f];\n};\nbr.prototype._getEndoBasis = function(e) {\n  for (var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), i = e, n = this.n.clone(), s = new Ke(1), o = new Ke(0), f = new Ke(0), h = new Ke(1), d, v, w, A, I, D, N, k = 0, j, T; i.cmpn(0) !== 0; ) {\n    var K = n.div(i);\n    j = n.sub(K.mul(i)), T = f.sub(K.mul(s));\n    var $ = h.sub(K.mul(o));\n    if (!w && j.cmp(t) < 0)\n      d = N.neg(), v = s, w = j.neg(), A = T;\n    else if (w && ++k === 2)\n      break;\n    N = j, n = i, i = j, f = s, s = T, h = o, o = $;\n  }\n  I = j.neg(), D = T;\n  var z = w.sqr().add(A.sqr()), B = I.sqr().add(D.sqr());\n  return B.cmp(z) >= 0 && (I = d, D = v), w.negative && (w = w.neg(), A = A.neg()), I.negative && (I = I.neg(), D = D.neg()), [\n    { a: w, b: A },\n    { a: I, b: D }\n  ];\n};\nbr.prototype._endoSplit = function(e) {\n  var t = this.endo.basis, i = t[0], n = t[1], s = n.b.mul(e).divRound(this.n), o = i.b.neg().mul(e).divRound(this.n), f = s.mul(i.a), h = o.mul(n.a), d = s.mul(i.b), v = o.mul(n.b), w = e.sub(f).sub(h), A = d.add(v).neg();\n  return { k1: w, k2: A };\n};\nbr.prototype.pointFromX = function(e, t) {\n  e = new Ke(e, 16), e.red || (e = e.toRed(this.red));\n  var i = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), n = i.redSqrt();\n  if (n.redSqr().redSub(i).cmp(this.zero) !== 0)\n    throw new Error(\"invalid point\");\n  var s = n.fromRed().isOdd();\n  return (t && !s || !t && s) && (n = n.redNeg()), this.point(e, n);\n};\nbr.prototype.validate = function(e) {\n  if (e.inf)\n    return !0;\n  var t = e.x, i = e.y, n = this.a.redMul(t), s = t.redSqr().redMul(t).redIAdd(n).redIAdd(this.b);\n  return i.redSqr().redISub(s).cmpn(0) === 0;\n};\nbr.prototype._endoWnafMulAdd = function(e, t, i) {\n  for (var n = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {\n    var f = this._endoSplit(t[o]), h = e[o], d = h._getBeta();\n    f.k1.negative && (f.k1.ineg(), h = h.neg(!0)), f.k2.negative && (f.k2.ineg(), d = d.neg(!0)), n[o * 2] = h, n[o * 2 + 1] = d, s[o * 2] = f.k1, s[o * 2 + 1] = f.k2;\n  }\n  for (var v = this._wnafMulAdd(1, n, s, o * 2, i), w = 0; w < o * 2; w++)\n    n[w] = null, s[w] = null;\n  return v;\n};\nfunction Dt(r, e, t, i) {\n  Xi.BasePoint.call(this, r, \"affine\"), e === null && t === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new Ke(e, 16), this.y = new Ke(t, 16), i && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);\n}\nko(Dt, Xi.BasePoint);\nbr.prototype.point = function(e, t, i) {\n  return new Dt(this, e, t, i);\n};\nbr.prototype.pointFromJSON = function(e, t) {\n  return Dt.fromJSON(this, e, t);\n};\nDt.prototype._getBeta = function() {\n  if (this.curve.endo) {\n    var e = this.precomputed;\n    if (e && e.beta)\n      return e.beta;\n    var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n    if (e) {\n      var i = this.curve, n = function(s) {\n        return i.point(s.x.redMul(i.endo.beta), s.y);\n      };\n      e.beta = t, t.precomputed = {\n        beta: null,\n        naf: e.naf && {\n          wnd: e.naf.wnd,\n          points: e.naf.points.map(n)\n        },\n        doubles: e.doubles && {\n          step: e.doubles.step,\n          points: e.doubles.points.map(n)\n        }\n      };\n    }\n    return t;\n  }\n};\nDt.prototype.toJSON = function() {\n  return this.precomputed ? [this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1)\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1)\n    }\n  }] : [this.x, this.y];\n};\nDt.fromJSON = function(e, t, i) {\n  typeof t == \"string\" && (t = JSON.parse(t));\n  var n = e.point(t[0], t[1], i);\n  if (!t[2])\n    return n;\n  function s(f) {\n    return e.point(f[0], f[1], i);\n  }\n  var o = t[2];\n  return n.precomputed = {\n    beta: null,\n    doubles: o.doubles && {\n      step: o.doubles.step,\n      points: [n].concat(o.doubles.points.map(s))\n    },\n    naf: o.naf && {\n      wnd: o.naf.wnd,\n      points: [n].concat(o.naf.points.map(s))\n    }\n  }, n;\n};\nDt.prototype.inspect = function() {\n  return this.isInfinity() ? \"<EC Point Infinity>\" : \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" y: \" + this.y.fromRed().toString(16, 2) + \">\";\n};\nDt.prototype.isInfinity = function() {\n  return this.inf;\n};\nDt.prototype.add = function(e) {\n  if (this.inf)\n    return e;\n  if (e.inf)\n    return this;\n  if (this.eq(e))\n    return this.dbl();\n  if (this.neg().eq(e))\n    return this.curve.point(null, null);\n  if (this.x.cmp(e.x) === 0)\n    return this.curve.point(null, null);\n  var t = this.y.redSub(e.y);\n  t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));\n  var i = t.redSqr().redISub(this.x).redISub(e.x), n = t.redMul(this.x.redSub(i)).redISub(this.y);\n  return this.curve.point(i, n);\n};\nDt.prototype.dbl = function() {\n  if (this.inf)\n    return this;\n  var e = this.y.redAdd(this.y);\n  if (e.cmpn(0) === 0)\n    return this.curve.point(null, null);\n  var t = this.curve.a, i = this.x.redSqr(), n = e.redInvm(), s = i.redAdd(i).redIAdd(i).redIAdd(t).redMul(n), o = s.redSqr().redISub(this.x.redAdd(this.x)), f = s.redMul(this.x.redSub(o)).redISub(this.y);\n  return this.curve.point(o, f);\n};\nDt.prototype.getX = function() {\n  return this.x.fromRed();\n};\nDt.prototype.getY = function() {\n  return this.y.fromRed();\n};\nDt.prototype.mul = function(e) {\n  return e = new Ke(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);\n};\nDt.prototype.mulAdd = function(e, t, i) {\n  var n = [this, t], s = [e, i];\n  return this.curve.endo ? this.curve._endoWnafMulAdd(n, s) : this.curve._wnafMulAdd(1, n, s, 2);\n};\nDt.prototype.jmulAdd = function(e, t, i) {\n  var n = [this, t], s = [e, i];\n  return this.curve.endo ? this.curve._endoWnafMulAdd(n, s, !0) : this.curve._wnafMulAdd(1, n, s, 2, !0);\n};\nDt.prototype.eq = function(e) {\n  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);\n};\nDt.prototype.neg = function(e) {\n  if (this.inf)\n    return this;\n  var t = this.curve.point(this.x, this.y.redNeg());\n  if (e && this.precomputed) {\n    var i = this.precomputed, n = function(s) {\n      return s.neg();\n    };\n    t.precomputed = {\n      naf: i.naf && {\n        wnd: i.naf.wnd,\n        points: i.naf.points.map(n)\n      },\n      doubles: i.doubles && {\n        step: i.doubles.step,\n        points: i.doubles.points.map(n)\n      }\n    };\n  }\n  return t;\n};\nDt.prototype.toJ = function() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n  var e = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return e;\n};\nfunction Nt(r, e, t, i) {\n  Xi.BasePoint.call(this, r, \"jacobian\"), e === null && t === null && i === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Ke(0)) : (this.x = new Ke(e, 16), this.y = new Ke(t, 16), this.z = new Ke(i, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;\n}\nko(Nt, Xi.BasePoint);\nbr.prototype.jpoint = function(e, t, i) {\n  return new Nt(this, e, t, i);\n};\nNt.prototype.toP = function() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n  var e = this.z.redInvm(), t = e.redSqr(), i = this.x.redMul(t), n = this.y.redMul(t).redMul(e);\n  return this.curve.point(i, n);\n};\nNt.prototype.neg = function() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\nNt.prototype.add = function(e) {\n  if (this.isInfinity())\n    return e;\n  if (e.isInfinity())\n    return this;\n  var t = e.z.redSqr(), i = this.z.redSqr(), n = this.x.redMul(t), s = e.x.redMul(i), o = this.y.redMul(t.redMul(e.z)), f = e.y.redMul(i.redMul(this.z)), h = n.redSub(s), d = o.redSub(f);\n  if (h.cmpn(0) === 0)\n    return d.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();\n  var v = h.redSqr(), w = v.redMul(h), A = n.redMul(v), I = d.redSqr().redIAdd(w).redISub(A).redISub(A), D = d.redMul(A.redISub(I)).redISub(o.redMul(w)), N = this.z.redMul(e.z).redMul(h);\n  return this.curve.jpoint(I, D, N);\n};\nNt.prototype.mixedAdd = function(e) {\n  if (this.isInfinity())\n    return e.toJ();\n  if (e.isInfinity())\n    return this;\n  var t = this.z.redSqr(), i = this.x, n = e.x.redMul(t), s = this.y, o = e.y.redMul(t).redMul(this.z), f = i.redSub(n), h = s.redSub(o);\n  if (f.cmpn(0) === 0)\n    return h.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();\n  var d = f.redSqr(), v = d.redMul(f), w = i.redMul(d), A = h.redSqr().redIAdd(v).redISub(w).redISub(w), I = h.redMul(w.redISub(A)).redISub(s.redMul(v)), D = this.z.redMul(f);\n  return this.curve.jpoint(A, I, D);\n};\nNt.prototype.dblp = function(e) {\n  if (e === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!e)\n    return this.dbl();\n  var t;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var i = this;\n    for (t = 0; t < e; t++)\n      i = i.dbl();\n    return i;\n  }\n  var n = this.curve.a, s = this.curve.tinv, o = this.x, f = this.y, h = this.z, d = h.redSqr().redSqr(), v = f.redAdd(f);\n  for (t = 0; t < e; t++) {\n    var w = o.redSqr(), A = v.redSqr(), I = A.redSqr(), D = w.redAdd(w).redIAdd(w).redIAdd(n.redMul(d)), N = o.redMul(A), k = D.redSqr().redISub(N.redAdd(N)), j = N.redISub(k), T = D.redMul(j);\n    T = T.redIAdd(T).redISub(I);\n    var K = v.redMul(h);\n    t + 1 < e && (d = d.redMul(I)), o = k, h = K, v = T;\n  }\n  return this.curve.jpoint(o, v.redMul(s), h);\n};\nNt.prototype.dbl = function() {\n  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();\n};\nNt.prototype._zeroDbl = function() {\n  var e, t, i;\n  if (this.zOne) {\n    var n = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), f = this.x.redAdd(s).redSqr().redISub(n).redISub(o);\n    f = f.redIAdd(f);\n    var h = n.redAdd(n).redIAdd(n), d = h.redSqr().redISub(f).redISub(f), v = o.redIAdd(o);\n    v = v.redIAdd(v), v = v.redIAdd(v), e = d, t = h.redMul(f.redISub(d)).redISub(v), i = this.y.redAdd(this.y);\n  } else {\n    var w = this.x.redSqr(), A = this.y.redSqr(), I = A.redSqr(), D = this.x.redAdd(A).redSqr().redISub(w).redISub(I);\n    D = D.redIAdd(D);\n    var N = w.redAdd(w).redIAdd(w), k = N.redSqr(), j = I.redIAdd(I);\n    j = j.redIAdd(j), j = j.redIAdd(j), e = k.redISub(D).redISub(D), t = N.redMul(D.redISub(e)).redISub(j), i = this.y.redMul(this.z), i = i.redIAdd(i);\n  }\n  return this.curve.jpoint(e, t, i);\n};\nNt.prototype._threeDbl = function() {\n  var e, t, i;\n  if (this.zOne) {\n    var n = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), f = this.x.redAdd(s).redSqr().redISub(n).redISub(o);\n    f = f.redIAdd(f);\n    var h = n.redAdd(n).redIAdd(n).redIAdd(this.curve.a), d = h.redSqr().redISub(f).redISub(f);\n    e = d;\n    var v = o.redIAdd(o);\n    v = v.redIAdd(v), v = v.redIAdd(v), t = h.redMul(f.redISub(d)).redISub(v), i = this.y.redAdd(this.y);\n  } else {\n    var w = this.z.redSqr(), A = this.y.redSqr(), I = this.x.redMul(A), D = this.x.redSub(w).redMul(this.x.redAdd(w));\n    D = D.redAdd(D).redIAdd(D);\n    var N = I.redIAdd(I);\n    N = N.redIAdd(N);\n    var k = N.redAdd(N);\n    e = D.redSqr().redISub(k), i = this.y.redAdd(this.z).redSqr().redISub(A).redISub(w);\n    var j = A.redSqr();\n    j = j.redIAdd(j), j = j.redIAdd(j), j = j.redIAdd(j), t = D.redMul(N.redISub(e)).redISub(j);\n  }\n  return this.curve.jpoint(e, t, i);\n};\nNt.prototype._dbl = function() {\n  var e = this.curve.a, t = this.x, i = this.y, n = this.z, s = n.redSqr().redSqr(), o = t.redSqr(), f = i.redSqr(), h = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)), d = t.redAdd(t);\n  d = d.redIAdd(d);\n  var v = d.redMul(f), w = h.redSqr().redISub(v.redAdd(v)), A = v.redISub(w), I = f.redSqr();\n  I = I.redIAdd(I), I = I.redIAdd(I), I = I.redIAdd(I);\n  var D = h.redMul(A).redISub(I), N = i.redAdd(i).redMul(n);\n  return this.curve.jpoint(w, D, N);\n};\nNt.prototype.trpl = function() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n  var e = this.x.redSqr(), t = this.y.redSqr(), i = this.z.redSqr(), n = t.redSqr(), s = e.redAdd(e).redIAdd(e), o = s.redSqr(), f = this.x.redAdd(t).redSqr().redISub(e).redISub(n);\n  f = f.redIAdd(f), f = f.redAdd(f).redIAdd(f), f = f.redISub(o);\n  var h = f.redSqr(), d = n.redIAdd(n);\n  d = d.redIAdd(d), d = d.redIAdd(d), d = d.redIAdd(d);\n  var v = s.redIAdd(f).redSqr().redISub(o).redISub(h).redISub(d), w = t.redMul(v);\n  w = w.redIAdd(w), w = w.redIAdd(w);\n  var A = this.x.redMul(h).redISub(w);\n  A = A.redIAdd(A), A = A.redIAdd(A);\n  var I = this.y.redMul(v.redMul(d.redISub(v)).redISub(f.redMul(h)));\n  I = I.redIAdd(I), I = I.redIAdd(I), I = I.redIAdd(I);\n  var D = this.z.redAdd(f).redSqr().redISub(i).redISub(h);\n  return this.curve.jpoint(A, I, D);\n};\nNt.prototype.mul = function(e, t) {\n  return e = new Ke(e, t), this.curve._wnafMul(this, e);\n};\nNt.prototype.eq = function(e) {\n  if (e.type === \"affine\")\n    return this.eq(e.toJ());\n  if (this === e)\n    return !0;\n  var t = this.z.redSqr(), i = e.z.redSqr();\n  if (this.x.redMul(i).redISub(e.x.redMul(t)).cmpn(0) !== 0)\n    return !1;\n  var n = t.redMul(this.z), s = i.redMul(e.z);\n  return this.y.redMul(s).redISub(e.y.redMul(n)).cmpn(0) === 0;\n};\nNt.prototype.eqXToP = function(e) {\n  var t = this.z.redSqr(), i = e.toRed(this.curve.red).redMul(t);\n  if (this.x.cmp(i) === 0)\n    return !0;\n  for (var n = e.clone(), s = this.curve.redN.redMul(t); ; ) {\n    if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)\n      return !1;\n    if (i.redIAdd(s), this.x.cmp(i) === 0)\n      return !0;\n  }\n};\nNt.prototype.inspect = function() {\n  return this.isInfinity() ? \"<EC JPoint Infinity>\" : \"<EC JPoint x: \" + this.x.toString(16, 2) + \" y: \" + this.y.toString(16, 2) + \" z: \" + this.z.toString(16, 2) + \">\";\n};\nNt.prototype.isInfinity = function() {\n  return this.z.cmpn(0) === 0;\n};\nvar Os = xn(function(r, e) {\n  var t = e;\n  t.base = Xi, t.short = Mg, t.mont = /*RicMoo:ethers:require(./mont)*/\n  null, t.edwards = /*RicMoo:ethers:require(./edwards)*/\n  null;\n}), Rs = xn(function(r, e) {\n  var t = e, i = sr.assert;\n  function n(f) {\n    f.type === \"short\" ? this.curve = new Os.short(f) : f.type === \"edwards\" ? this.curve = new Os.edwards(f) : this.curve = new Os.mont(f), this.g = this.curve.g, this.n = this.curve.n, this.hash = f.hash, i(this.g.validate(), \"Invalid curve\"), i(this.g.mul(this.n).isInfinity(), \"Invalid curve, G*N != O\");\n  }\n  t.PresetCurve = n;\n  function s(f, h) {\n    Object.defineProperty(t, f, {\n      configurable: !0,\n      enumerable: !0,\n      get: function() {\n        var d = new n(h);\n        return Object.defineProperty(t, f, {\n          configurable: !0,\n          enumerable: !0,\n          value: d\n        }), d;\n      }\n    });\n  }\n  s(\"p192\", {\n    type: \"short\",\n    prime: \"p192\",\n    p: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\",\n    a: \"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc\",\n    b: \"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1\",\n    n: \"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831\",\n    hash: si.sha256,\n    gRed: !1,\n    g: [\n      \"188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012\",\n      \"07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811\"\n    ]\n  }), s(\"p224\", {\n    type: \"short\",\n    prime: \"p224\",\n    p: \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\",\n    a: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe\",\n    b: \"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4\",\n    n: \"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d\",\n    hash: si.sha256,\n    gRed: !1,\n    g: [\n      \"b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21\",\n      \"bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34\"\n    ]\n  }), s(\"p256\", {\n    type: \"short\",\n    prime: null,\n    p: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff\",\n    a: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc\",\n    b: \"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b\",\n    n: \"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551\",\n    hash: si.sha256,\n    gRed: !1,\n    g: [\n      \"6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296\",\n      \"4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5\"\n    ]\n  }), s(\"p384\", {\n    type: \"short\",\n    prime: null,\n    p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff\",\n    a: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc\",\n    b: \"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef\",\n    n: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973\",\n    hash: si.sha384,\n    gRed: !1,\n    g: [\n      \"aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7\",\n      \"3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f\"\n    ]\n  }), s(\"p521\", {\n    type: \"short\",\n    prime: null,\n    p: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff\",\n    a: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc\",\n    b: \"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00\",\n    n: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409\",\n    hash: si.sha512,\n    gRed: !1,\n    g: [\n      \"000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66\",\n      \"00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650\"\n    ]\n  }), s(\"curve25519\", {\n    type: \"mont\",\n    prime: \"p25519\",\n    p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n    a: \"76d06\",\n    b: \"1\",\n    n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n    hash: si.sha256,\n    gRed: !1,\n    g: [\n      \"9\"\n    ]\n  }), s(\"ed25519\", {\n    type: \"edwards\",\n    prime: \"p25519\",\n    p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n    a: \"-1\",\n    c: \"1\",\n    // -121665 * (121666^(-1)) (mod P)\n    d: \"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3\",\n    n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n    hash: si.sha256,\n    gRed: !1,\n    g: [\n      \"216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\",\n      // 4/5\n      \"6666666666666666666666666666666666666666666666666666666666666658\"\n    ]\n  });\n  var o;\n  try {\n    o = /*RicMoo:ethers:require(./precomputed/secp256k1)*/\n    null.crash();\n  } catch {\n    o = void 0;\n  }\n  s(\"secp256k1\", {\n    type: \"short\",\n    prime: \"k256\",\n    p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\",\n    a: \"0\",\n    b: \"7\",\n    n: \"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141\",\n    h: \"1\",\n    hash: si.sha256,\n    // Precomputed endomorphism\n    beta: \"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\",\n    lambda: \"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72\",\n    basis: [\n      {\n        a: \"3086d221a7d46bcde86c90e49284eb15\",\n        b: \"-e4437ed6010e88286f547fa90abfe4c3\"\n      },\n      {\n        a: \"114ca50f7a8e2f3f657c1108d9d44cfd8\",\n        b: \"3086d221a7d46bcde86c90e49284eb15\"\n      }\n    ],\n    gRed: !1,\n    g: [\n      \"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n      \"483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n      o\n    ]\n  });\n});\nfunction _i(r) {\n  if (!(this instanceof _i))\n    return new _i(r);\n  this.hash = r.hash, this.predResist = !!r.predResist, this.outLen = this.hash.outSize, this.minEntropy = r.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;\n  var e = Mr.toArray(r.entropy, r.entropyEnc || \"hex\"), t = Mr.toArray(r.nonce, r.nonceEnc || \"hex\"), i = Mr.toArray(r.pers, r.persEnc || \"hex\");\n  Bo(\n    e.length >= this.minEntropy / 8,\n    \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\"\n  ), this._init(e, t, i);\n}\nvar Lu = _i;\n_i.prototype._init = function(e, t, i) {\n  var n = e.concat(t).concat(i);\n  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);\n  for (var s = 0; s < this.V.length; s++)\n    this.K[s] = 0, this.V[s] = 1;\n  this._update(n), this._reseed = 1, this.reseedInterval = 281474976710656;\n};\n_i.prototype._hmac = function() {\n  return new si.hmac(this.hash, this.K);\n};\n_i.prototype._update = function(e) {\n  var t = this._hmac().update(this.V).update([0]);\n  e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());\n};\n_i.prototype.reseed = function(e, t, i, n) {\n  typeof t != \"string\" && (n = i, i = t, t = null), e = Mr.toArray(e, t), i = Mr.toArray(i, n), Bo(\n    e.length >= this.minEntropy / 8,\n    \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\"\n  ), this._update(e.concat(i || [])), this._reseed = 1;\n};\n_i.prototype.generate = function(e, t, i, n) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error(\"Reseed is required\");\n  typeof t != \"string\" && (n = i, i = t, t = null), i && (i = Mr.toArray(i, n || \"hex\"), this._update(i));\n  for (var s = []; s.length < e; )\n    this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);\n  var o = s.slice(0, e);\n  return this._update(i), this._reseed++, Mr.encode(o, t);\n};\nvar xo = sr.assert;\nfunction qt(r, e) {\n  this.ec = r, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);\n}\nvar jo = qt;\nqt.fromPublic = function(e, t, i) {\n  return t instanceof qt ? t : new qt(e, {\n    pub: t,\n    pubEnc: i\n  });\n};\nqt.fromPrivate = function(e, t, i) {\n  return t instanceof qt ? t : new qt(e, {\n    priv: t,\n    privEnc: i\n  });\n};\nqt.prototype.validate = function() {\n  var e = this.getPublic();\n  return e.isInfinity() ? { result: !1, reason: \"Invalid public key\" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: \"Public key * N != O\" } : { result: !1, reason: \"Public key is not a point\" };\n};\nqt.prototype.getPublic = function(e, t) {\n  return typeof e == \"string\" && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub;\n};\nqt.prototype.getPrivate = function(e) {\n  return e === \"hex\" ? this.priv.toString(16, 2) : this.priv;\n};\nqt.prototype._importPrivate = function(e, t) {\n  this.priv = new Ke(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n);\n};\nqt.prototype._importPublic = function(e, t) {\n  if (e.x || e.y) {\n    this.ec.curve.type === \"mont\" ? xo(e.x, \"Need x coordinate\") : (this.ec.curve.type === \"short\" || this.ec.curve.type === \"edwards\") && xo(e.x && e.y, \"Need both x and y coordinate\"), this.pub = this.ec.curve.point(e.x, e.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(e, t);\n};\nqt.prototype.derive = function(e) {\n  return e.validate() || xo(e.validate(), \"public point not validated\"), e.mul(this.priv).getX();\n};\nqt.prototype.sign = function(e, t, i) {\n  return this.ec.sign(e, this, t, i);\n};\nqt.prototype.verify = function(e, t) {\n  return this.ec.verify(e, t, this);\n};\nqt.prototype.inspect = function() {\n  return \"<Key priv: \" + (this.priv && this.priv.toString(16, 2)) + \" pub: \" + (this.pub && this.pub.inspect()) + \" >\";\n};\nvar Ig = sr.assert;\nfunction la(r, e) {\n  if (r instanceof la)\n    return r;\n  this._importDER(r, e) || (Ig(r.r && r.s, \"Signature without r or s\"), this.r = new Ke(r.r, 16), this.s = new Ke(r.s, 16), r.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = r.recoveryParam);\n}\nvar pa = la;\nfunction Ag() {\n  this.place = 0;\n}\nfunction Va(r, e) {\n  var t = r[e.place++];\n  if (!(t & 128))\n    return t;\n  var i = t & 15;\n  if (i === 0 || i > 4)\n    return !1;\n  for (var n = 0, s = 0, o = e.place; s < i; s++, o++)\n    n <<= 8, n |= r[o], n >>>= 0;\n  return n <= 127 ? !1 : (e.place = o, n);\n}\nfunction lc(r) {\n  for (var e = 0, t = r.length - 1; !r[e] && !(r[e + 1] & 128) && e < t; )\n    e++;\n  return e === 0 ? r : r.slice(e);\n}\nla.prototype._importDER = function(e, t) {\n  e = sr.toArray(e, t);\n  var i = new Ag();\n  if (e[i.place++] !== 48)\n    return !1;\n  var n = Va(e, i);\n  if (n === !1 || n + i.place !== e.length || e[i.place++] !== 2)\n    return !1;\n  var s = Va(e, i);\n  if (s === !1)\n    return !1;\n  var o = e.slice(i.place, s + i.place);\n  if (i.place += s, e[i.place++] !== 2)\n    return !1;\n  var f = Va(e, i);\n  if (f === !1 || e.length !== f + i.place)\n    return !1;\n  var h = e.slice(i.place, f + i.place);\n  if (o[0] === 0)\n    if (o[1] & 128)\n      o = o.slice(1);\n    else\n      return !1;\n  if (h[0] === 0)\n    if (h[1] & 128)\n      h = h.slice(1);\n    else\n      return !1;\n  return this.r = new Ke(o), this.s = new Ke(h), this.recoveryParam = null, !0;\n};\nfunction Wa(r, e) {\n  if (e < 128) {\n    r.push(e);\n    return;\n  }\n  var t = 1 + (Math.log(e) / Math.LN2 >>> 3);\n  for (r.push(t | 128); --t; )\n    r.push(e >>> (t << 3) & 255);\n  r.push(e);\n}\nla.prototype.toDER = function(e) {\n  var t = this.r.toArray(), i = this.s.toArray();\n  for (t[0] & 128 && (t = [0].concat(t)), i[0] & 128 && (i = [0].concat(i)), t = lc(t), i = lc(i); !i[0] && !(i[1] & 128); )\n    i = i.slice(1);\n  var n = [2];\n  Wa(n, t.length), n = n.concat(t), n.push(2), Wa(n, i.length);\n  var s = n.concat(i), o = [48];\n  return Wa(o, s.length), o = o.concat(s), sr.encode(o, e);\n};\nvar Dg = (\n  /*RicMoo:ethers:require(brorand)*/\n  function() {\n    throw new Error(\"unsupported\");\n  }\n), Fu = sr.assert;\nfunction lr(r) {\n  if (!(this instanceof lr))\n    return new lr(r);\n  typeof r == \"string\" && (Fu(\n    Object.prototype.hasOwnProperty.call(Rs, r),\n    \"Unknown curve \" + r\n  ), r = Rs[r]), r instanceof Rs.PresetCurve && (r = { curve: r }), this.curve = r.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = r.curve.g, this.g.precompute(r.curve.n.bitLength() + 1), this.hash = r.hash || r.curve.hash;\n}\nvar Pg = lr;\nlr.prototype.keyPair = function(e) {\n  return new jo(this, e);\n};\nlr.prototype.keyFromPrivate = function(e, t) {\n  return jo.fromPrivate(this, e, t);\n};\nlr.prototype.keyFromPublic = function(e, t) {\n  return jo.fromPublic(this, e, t);\n};\nlr.prototype.genKeyPair = function(e) {\n  e || (e = {});\n  for (var t = new Lu({\n    hash: this.hash,\n    pers: e.pers,\n    persEnc: e.persEnc || \"utf8\",\n    entropy: e.entropy || Dg(this.hash.hmacStrength),\n    entropyEnc: e.entropy && e.entropyEnc || \"utf8\",\n    nonce: this.n.toArray()\n  }), i = this.n.byteLength(), n = this.n.sub(new Ke(2)); ; ) {\n    var s = new Ke(t.generate(i));\n    if (!(s.cmp(n) > 0))\n      return s.iaddn(1), this.keyFromPrivate(s);\n  }\n};\nlr.prototype._truncateToN = function(e, t) {\n  var i = e.byteLength() * 8 - this.n.bitLength();\n  return i > 0 && (e = e.ushrn(i)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;\n};\nlr.prototype.sign = function(e, t, i, n) {\n  typeof i == \"object\" && (n = i, i = null), n || (n = {}), t = this.keyFromPrivate(t, i), e = this._truncateToN(new Ke(e, 16));\n  for (var s = this.n.byteLength(), o = t.getPrivate().toArray(\"be\", s), f = e.toArray(\"be\", s), h = new Lu({\n    hash: this.hash,\n    entropy: o,\n    nonce: f,\n    pers: n.pers,\n    persEnc: n.persEnc || \"utf8\"\n  }), d = this.n.sub(new Ke(1)), v = 0; ; v++) {\n    var w = n.k ? n.k(v) : new Ke(h.generate(this.n.byteLength()));\n    if (w = this._truncateToN(w, !0), !(w.cmpn(1) <= 0 || w.cmp(d) >= 0)) {\n      var A = this.g.mul(w);\n      if (!A.isInfinity()) {\n        var I = A.getX(), D = I.umod(this.n);\n        if (D.cmpn(0) !== 0) {\n          var N = w.invm(this.n).mul(D.mul(t.getPrivate()).iadd(e));\n          if (N = N.umod(this.n), N.cmpn(0) !== 0) {\n            var k = (A.getY().isOdd() ? 1 : 0) | (I.cmp(D) !== 0 ? 2 : 0);\n            return n.canonical && N.cmp(this.nh) > 0 && (N = this.n.sub(N), k ^= 1), new pa({ r: D, s: N, recoveryParam: k });\n          }\n        }\n      }\n    }\n  }\n};\nlr.prototype.verify = function(e, t, i, n) {\n  e = this._truncateToN(new Ke(e, 16)), i = this.keyFromPublic(i, n), t = new pa(t, \"hex\");\n  var s = t.r, o = t.s;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0)\n    return !1;\n  var f = o.invm(this.n), h = f.mul(e).umod(this.n), d = f.mul(s).umod(this.n), v;\n  return this.curve._maxwellTrick ? (v = this.g.jmulAdd(h, i.getPublic(), d), v.isInfinity() ? !1 : v.eqXToP(s)) : (v = this.g.mulAdd(h, i.getPublic(), d), v.isInfinity() ? !1 : v.getX().umod(this.n).cmp(s) === 0);\n};\nlr.prototype.recoverPubKey = function(r, e, t, i) {\n  Fu((3 & t) === t, \"The recovery param is more than two bits\"), e = new pa(e, i);\n  var n = this.n, s = new Ke(r), o = e.r, f = e.s, h = t & 1, d = t >> 1;\n  if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && d)\n    throw new Error(\"Unable to find sencond key candinate\");\n  d ? o = this.curve.pointFromX(o.add(this.curve.n), h) : o = this.curve.pointFromX(o, h);\n  var v = e.r.invm(n), w = n.sub(s).mul(v).umod(n), A = f.mul(v).umod(n);\n  return this.g.mulAdd(w, o, A);\n};\nlr.prototype.getKeyRecoveryParam = function(r, e, t, i) {\n  if (e = new pa(e, i), e.recoveryParam !== null)\n    return e.recoveryParam;\n  for (var n = 0; n < 4; n++) {\n    var s;\n    try {\n      s = this.recoverPubKey(r, e, n);\n    } catch {\n      continue;\n    }\n    if (s.eq(t))\n      return n;\n  }\n  throw new Error(\"Unable to find valid recovery factor\");\n};\nvar Og = xn(function(r, e) {\n  var t = e;\n  t.version = \"6.5.4\", t.utils = sr, t.rand = /*RicMoo:ethers:require(brorand)*/\n  function() {\n    throw new Error(\"unsupported\");\n  }, t.curve = Os, t.curves = Rs, t.ec = Pg, t.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/\n  null;\n}), Rg = Og.ec;\nconst Ng = \"signing-key/5.7.0\", Eo = new ht(Ng);\nlet Ga = null;\nfunction Cr() {\n  return Ga || (Ga = new Rg(\"secp256k1\")), Ga;\n}\nclass Tg {\n  constructor(e) {\n    Tn(this, \"curve\", \"secp256k1\"), Tn(this, \"privateKey\", Jt(e)), qv(this.privateKey) !== 32 && Eo.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n    const t = Cr().keyFromPrivate(yt(this.privateKey));\n    Tn(this, \"publicKey\", \"0x\" + t.getPublic(!1, \"hex\")), Tn(this, \"compressedPublicKey\", \"0x\" + t.getPublic(!0, \"hex\")), Tn(this, \"_isSigningKey\", !0);\n  }\n  _addPoint(e) {\n    const t = Cr().keyFromPublic(yt(this.publicKey)), i = Cr().keyFromPublic(yt(e));\n    return \"0x\" + t.pub.add(i.pub).encodeCompressed(\"hex\");\n  }\n  signDigest(e) {\n    const t = Cr().keyFromPrivate(yt(this.privateKey)), i = yt(e);\n    i.length !== 32 && Eo.throwArgumentError(\"bad digest length\", \"digest\", e);\n    const n = t.sign(i, { canonical: !0 });\n    return vu({\n      recoveryParam: n.recoveryParam,\n      r: hn(\"0x\" + n.r.toString(16), 32),\n      s: hn(\"0x\" + n.s.toString(16), 32)\n    });\n  }\n  computeSharedSecret(e) {\n    const t = Cr().keyFromPrivate(yt(this.privateKey)), i = Cr().keyFromPublic(yt(qu(e)));\n    return hn(\"0x\" + t.derive(i.getPublic()).toString(16), 32);\n  }\n  static isSigningKey(e) {\n    return !!(e && e._isSigningKey);\n  }\n}\nfunction Cg(r, e) {\n  const t = vu(e), i = { r: yt(t.r), s: yt(t.s) };\n  return \"0x\" + Cr().recoverPubKey(yt(r), i, t.recoveryParam).encode(\"hex\", !1);\n}\nfunction qu(r, e) {\n  const t = yt(r);\n  if (t.length === 32) {\n    const i = new Tg(t);\n    return e ? \"0x\" + Cr().keyFromPrivate(t).getPublic(!0, \"hex\") : i.publicKey;\n  } else {\n    if (t.length === 33)\n      return e ? Jt(t) : \"0x\" + Cr().keyFromPublic(t).getPublic(!1, \"hex\");\n    if (t.length === 65)\n      return e ? \"0x\" + Cr().keyFromPublic(t).getPublic(!0, \"hex\") : Jt(t);\n  }\n  return Eo.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\nvar pc;\n(function(r) {\n  r[r.legacy = 0] = \"legacy\", r[r.eip2930 = 1] = \"eip2930\", r[r.eip1559 = 2] = \"eip1559\";\n})(pc || (pc = {}));\nfunction $g(r) {\n  const e = qu(r);\n  return Jv(sc(qo(sc(e, 1)), 12));\n}\nfunction Lg(r, e) {\n  return $g(Cg(yt(r), e));\n}\nvar Ko = {}, va = {};\nObject.defineProperty(va, \"__esModule\", { value: !0 });\nvar Ft = Ve, So = nr, Fg = 20;\nfunction qg(r, e, t) {\n  for (var i = 1634760805, n = 857760878, s = 2036477234, o = 1797285236, f = t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0], h = t[7] << 24 | t[6] << 16 | t[5] << 8 | t[4], d = t[11] << 24 | t[10] << 16 | t[9] << 8 | t[8], v = t[15] << 24 | t[14] << 16 | t[13] << 8 | t[12], w = t[19] << 24 | t[18] << 16 | t[17] << 8 | t[16], A = t[23] << 24 | t[22] << 16 | t[21] << 8 | t[20], I = t[27] << 24 | t[26] << 16 | t[25] << 8 | t[24], D = t[31] << 24 | t[30] << 16 | t[29] << 8 | t[28], N = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], k = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], j = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], T = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], K = i, $ = n, z = s, B = o, _ = f, R = h, J = d, Q = v, O = w, p = A, l = I, a = D, c = N, b = k, E = j, S = T, x = 0; x < Fg; x += 2)\n    K = K + _ | 0, c ^= K, c = c >>> 32 - 16 | c << 16, O = O + c | 0, _ ^= O, _ = _ >>> 32 - 12 | _ << 12, $ = $ + R | 0, b ^= $, b = b >>> 32 - 16 | b << 16, p = p + b | 0, R ^= p, R = R >>> 32 - 12 | R << 12, z = z + J | 0, E ^= z, E = E >>> 32 - 16 | E << 16, l = l + E | 0, J ^= l, J = J >>> 32 - 12 | J << 12, B = B + Q | 0, S ^= B, S = S >>> 32 - 16 | S << 16, a = a + S | 0, Q ^= a, Q = Q >>> 32 - 12 | Q << 12, z = z + J | 0, E ^= z, E = E >>> 32 - 8 | E << 8, l = l + E | 0, J ^= l, J = J >>> 32 - 7 | J << 7, B = B + Q | 0, S ^= B, S = S >>> 32 - 8 | S << 8, a = a + S | 0, Q ^= a, Q = Q >>> 32 - 7 | Q << 7, $ = $ + R | 0, b ^= $, b = b >>> 32 - 8 | b << 8, p = p + b | 0, R ^= p, R = R >>> 32 - 7 | R << 7, K = K + _ | 0, c ^= K, c = c >>> 32 - 8 | c << 8, O = O + c | 0, _ ^= O, _ = _ >>> 32 - 7 | _ << 7, K = K + R | 0, S ^= K, S = S >>> 32 - 16 | S << 16, l = l + S | 0, R ^= l, R = R >>> 32 - 12 | R << 12, $ = $ + J | 0, c ^= $, c = c >>> 32 - 16 | c << 16, a = a + c | 0, J ^= a, J = J >>> 32 - 12 | J << 12, z = z + Q | 0, b ^= z, b = b >>> 32 - 16 | b << 16, O = O + b | 0, Q ^= O, Q = Q >>> 32 - 12 | Q << 12, B = B + _ | 0, E ^= B, E = E >>> 32 - 16 | E << 16, p = p + E | 0, _ ^= p, _ = _ >>> 32 - 12 | _ << 12, z = z + Q | 0, b ^= z, b = b >>> 32 - 8 | b << 8, O = O + b | 0, Q ^= O, Q = Q >>> 32 - 7 | Q << 7, B = B + _ | 0, E ^= B, E = E >>> 32 - 8 | E << 8, p = p + E | 0, _ ^= p, _ = _ >>> 32 - 7 | _ << 7, $ = $ + J | 0, c ^= $, c = c >>> 32 - 8 | c << 8, a = a + c | 0, J ^= a, J = J >>> 32 - 7 | J << 7, K = K + R | 0, S ^= K, S = S >>> 32 - 8 | S << 8, l = l + S | 0, R ^= l, R = R >>> 32 - 7 | R << 7;\n  Ft.writeUint32LE(K + i | 0, r, 0), Ft.writeUint32LE($ + n | 0, r, 4), Ft.writeUint32LE(z + s | 0, r, 8), Ft.writeUint32LE(B + o | 0, r, 12), Ft.writeUint32LE(_ + f | 0, r, 16), Ft.writeUint32LE(R + h | 0, r, 20), Ft.writeUint32LE(J + d | 0, r, 24), Ft.writeUint32LE(Q + v | 0, r, 28), Ft.writeUint32LE(O + w | 0, r, 32), Ft.writeUint32LE(p + A | 0, r, 36), Ft.writeUint32LE(l + I | 0, r, 40), Ft.writeUint32LE(a + D | 0, r, 44), Ft.writeUint32LE(c + N | 0, r, 48), Ft.writeUint32LE(b + k | 0, r, 52), Ft.writeUint32LE(E + j | 0, r, 56), Ft.writeUint32LE(S + T | 0, r, 60);\n}\nfunction Uu(r, e, t, i, n) {\n  if (n === void 0 && (n = 0), r.length !== 32)\n    throw new Error(\"ChaCha: key size must be 32 bytes\");\n  if (i.length < t.length)\n    throw new Error(\"ChaCha: destination is shorter than source\");\n  var s, o;\n  if (n === 0) {\n    if (e.length !== 8 && e.length !== 12)\n      throw new Error(\"ChaCha nonce must be 8 or 12 bytes\");\n    s = new Uint8Array(16), o = s.length - e.length, s.set(e, o);\n  } else {\n    if (e.length !== 16)\n      throw new Error(\"ChaCha nonce with counter must be 16 bytes\");\n    s = e, o = n;\n  }\n  for (var f = new Uint8Array(64), h = 0; h < t.length; h += 64) {\n    qg(f, s, r);\n    for (var d = h; d < h + 64 && d < t.length; d++)\n      i[d] = t[d] ^ f[d - h];\n    zg(s, 0, o);\n  }\n  return So.wipe(f), n === 0 && So.wipe(s), i;\n}\nva.streamXOR = Uu;\nfunction Ug(r, e, t, i) {\n  return i === void 0 && (i = 0), So.wipe(t), Uu(r, e, t, t, i);\n}\nva.stream = Ug;\nfunction zg(r, e, t) {\n  for (var i = 1; t--; )\n    i = i + (r[e] & 255) | 0, r[e] = i & 255, i >>>= 8, e++;\n  if (i > 0)\n    throw new Error(\"ChaCha: counter overflow\");\n}\nvar zu = {}, Mi = {};\nObject.defineProperty(Mi, \"__esModule\", { value: !0 });\nfunction Bg(r, e, t) {\n  return ~(r - 1) & e | r - 1 & t;\n}\nMi.select = Bg;\nfunction kg(r, e) {\n  return (r | 0) - (e | 0) - 1 >>> 31 & 1;\n}\nMi.lessOrEqual = kg;\nfunction Bu(r, e) {\n  if (r.length !== e.length)\n    return 0;\n  for (var t = 0, i = 0; i < r.length; i++)\n    t |= r[i] ^ e[i];\n  return 1 & t - 1 >>> 8;\n}\nMi.compare = Bu;\nfunction jg(r, e) {\n  return r.length === 0 || e.length === 0 ? !1 : Bu(r, e) !== 0;\n}\nMi.equal = jg;\n(function(r) {\n  Object.defineProperty(r, \"__esModule\", { value: !0 });\n  var e = Mi, t = nr;\n  r.DIGEST_LENGTH = 16;\n  var i = (\n    /** @class */\n    function() {\n      function o(f) {\n        this.digestLength = r.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;\n        var h = f[0] | f[1] << 8;\n        this._r[0] = h & 8191;\n        var d = f[2] | f[3] << 8;\n        this._r[1] = (h >>> 13 | d << 3) & 8191;\n        var v = f[4] | f[5] << 8;\n        this._r[2] = (d >>> 10 | v << 6) & 7939;\n        var w = f[6] | f[7] << 8;\n        this._r[3] = (v >>> 7 | w << 9) & 8191;\n        var A = f[8] | f[9] << 8;\n        this._r[4] = (w >>> 4 | A << 12) & 255, this._r[5] = A >>> 1 & 8190;\n        var I = f[10] | f[11] << 8;\n        this._r[6] = (A >>> 14 | I << 2) & 8191;\n        var D = f[12] | f[13] << 8;\n        this._r[7] = (I >>> 11 | D << 5) & 8065;\n        var N = f[14] | f[15] << 8;\n        this._r[8] = (D >>> 8 | N << 8) & 8191, this._r[9] = N >>> 5 & 127, this._pad[0] = f[16] | f[17] << 8, this._pad[1] = f[18] | f[19] << 8, this._pad[2] = f[20] | f[21] << 8, this._pad[3] = f[22] | f[23] << 8, this._pad[4] = f[24] | f[25] << 8, this._pad[5] = f[26] | f[27] << 8, this._pad[6] = f[28] | f[29] << 8, this._pad[7] = f[30] | f[31] << 8;\n      }\n      return o.prototype._blocks = function(f, h, d) {\n        for (var v = this._fin ? 0 : 2048, w = this._h[0], A = this._h[1], I = this._h[2], D = this._h[3], N = this._h[4], k = this._h[5], j = this._h[6], T = this._h[7], K = this._h[8], $ = this._h[9], z = this._r[0], B = this._r[1], _ = this._r[2], R = this._r[3], J = this._r[4], Q = this._r[5], O = this._r[6], p = this._r[7], l = this._r[8], a = this._r[9]; d >= 16; ) {\n          var c = f[h + 0] | f[h + 1] << 8;\n          w += c & 8191;\n          var b = f[h + 2] | f[h + 3] << 8;\n          A += (c >>> 13 | b << 3) & 8191;\n          var E = f[h + 4] | f[h + 5] << 8;\n          I += (b >>> 10 | E << 6) & 8191;\n          var S = f[h + 6] | f[h + 7] << 8;\n          D += (E >>> 7 | S << 9) & 8191;\n          var x = f[h + 8] | f[h + 9] << 8;\n          N += (S >>> 4 | x << 12) & 8191, k += x >>> 1 & 8191;\n          var u = f[h + 10] | f[h + 11] << 8;\n          j += (x >>> 14 | u << 2) & 8191;\n          var m = f[h + 12] | f[h + 13] << 8;\n          T += (u >>> 11 | m << 5) & 8191;\n          var g = f[h + 14] | f[h + 15] << 8;\n          K += (m >>> 8 | g << 8) & 8191, $ += g >>> 5 | v;\n          var P = 0, G = P;\n          G += w * z, G += A * (5 * a), G += I * (5 * l), G += D * (5 * p), G += N * (5 * O), P = G >>> 13, G &= 8191, G += k * (5 * Q), G += j * (5 * J), G += T * (5 * R), G += K * (5 * _), G += $ * (5 * B), P += G >>> 13, G &= 8191;\n          var M = P;\n          M += w * B, M += A * z, M += I * (5 * a), M += D * (5 * l), M += N * (5 * p), P = M >>> 13, M &= 8191, M += k * (5 * O), M += j * (5 * Q), M += T * (5 * J), M += K * (5 * R), M += $ * (5 * _), P += M >>> 13, M &= 8191;\n          var H = P;\n          H += w * _, H += A * B, H += I * z, H += D * (5 * a), H += N * (5 * l), P = H >>> 13, H &= 8191, H += k * (5 * p), H += j * (5 * O), H += T * (5 * Q), H += K * (5 * J), H += $ * (5 * R), P += H >>> 13, H &= 8191;\n          var C = P;\n          C += w * R, C += A * _, C += I * B, C += D * z, C += N * (5 * a), P = C >>> 13, C &= 8191, C += k * (5 * l), C += j * (5 * p), C += T * (5 * O), C += K * (5 * Q), C += $ * (5 * J), P += C >>> 13, C &= 8191;\n          var q = P;\n          q += w * J, q += A * R, q += I * _, q += D * B, q += N * z, P = q >>> 13, q &= 8191, q += k * (5 * a), q += j * (5 * l), q += T * (5 * p), q += K * (5 * O), q += $ * (5 * Q), P += q >>> 13, q &= 8191;\n          var L = P;\n          L += w * Q, L += A * J, L += I * R, L += D * _, L += N * B, P = L >>> 13, L &= 8191, L += k * z, L += j * (5 * a), L += T * (5 * l), L += K * (5 * p), L += $ * (5 * O), P += L >>> 13, L &= 8191;\n          var y = P;\n          y += w * O, y += A * Q, y += I * J, y += D * R, y += N * _, P = y >>> 13, y &= 8191, y += k * B, y += j * z, y += T * (5 * a), y += K * (5 * l), y += $ * (5 * p), P += y >>> 13, y &= 8191;\n          var F = P;\n          F += w * p, F += A * O, F += I * Q, F += D * J, F += N * R, P = F >>> 13, F &= 8191, F += k * _, F += j * B, F += T * z, F += K * (5 * a), F += $ * (5 * l), P += F >>> 13, F &= 8191;\n          var W = P;\n          W += w * l, W += A * p, W += I * O, W += D * Q, W += N * J, P = W >>> 13, W &= 8191, W += k * R, W += j * _, W += T * B, W += K * z, W += $ * (5 * a), P += W >>> 13, W &= 8191;\n          var Y = P;\n          Y += w * a, Y += A * l, Y += I * p, Y += D * O, Y += N * Q, P = Y >>> 13, Y &= 8191, Y += k * J, Y += j * R, Y += T * _, Y += K * B, Y += $ * z, P += Y >>> 13, Y &= 8191, P = (P << 2) + P | 0, P = P + G | 0, G = P & 8191, P = P >>> 13, M += P, w = G, A = M, I = H, D = C, N = q, k = L, j = y, T = F, K = W, $ = Y, h += 16, d -= 16;\n        }\n        this._h[0] = w, this._h[1] = A, this._h[2] = I, this._h[3] = D, this._h[4] = N, this._h[5] = k, this._h[6] = j, this._h[7] = T, this._h[8] = K, this._h[9] = $;\n      }, o.prototype.finish = function(f, h) {\n        h === void 0 && (h = 0);\n        var d = new Uint16Array(10), v, w, A, I;\n        if (this._leftover) {\n          for (I = this._leftover, this._buffer[I++] = 1; I < 16; I++)\n            this._buffer[I] = 0;\n          this._fin = 1, this._blocks(this._buffer, 0, 16);\n        }\n        for (v = this._h[1] >>> 13, this._h[1] &= 8191, I = 2; I < 10; I++)\n          this._h[I] += v, v = this._h[I] >>> 13, this._h[I] &= 8191;\n        for (this._h[0] += v * 5, v = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += v, v = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += v, d[0] = this._h[0] + 5, v = d[0] >>> 13, d[0] &= 8191, I = 1; I < 10; I++)\n          d[I] = this._h[I] + v, v = d[I] >>> 13, d[I] &= 8191;\n        for (d[9] -= 8192, w = (v ^ 1) - 1, I = 0; I < 10; I++)\n          d[I] &= w;\n        for (w = ~w, I = 0; I < 10; I++)\n          this._h[I] = this._h[I] & w | d[I];\n        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, A = this._h[0] + this._pad[0], this._h[0] = A & 65535, I = 1; I < 8; I++)\n          A = (this._h[I] + this._pad[I] | 0) + (A >>> 16) | 0, this._h[I] = A & 65535;\n        return f[h + 0] = this._h[0] >>> 0, f[h + 1] = this._h[0] >>> 8, f[h + 2] = this._h[1] >>> 0, f[h + 3] = this._h[1] >>> 8, f[h + 4] = this._h[2] >>> 0, f[h + 5] = this._h[2] >>> 8, f[h + 6] = this._h[3] >>> 0, f[h + 7] = this._h[3] >>> 8, f[h + 8] = this._h[4] >>> 0, f[h + 9] = this._h[4] >>> 8, f[h + 10] = this._h[5] >>> 0, f[h + 11] = this._h[5] >>> 8, f[h + 12] = this._h[6] >>> 0, f[h + 13] = this._h[6] >>> 8, f[h + 14] = this._h[7] >>> 0, f[h + 15] = this._h[7] >>> 8, this._finished = !0, this;\n      }, o.prototype.update = function(f) {\n        var h = 0, d = f.length, v;\n        if (this._leftover) {\n          v = 16 - this._leftover, v > d && (v = d);\n          for (var w = 0; w < v; w++)\n            this._buffer[this._leftover + w] = f[h + w];\n          if (d -= v, h += v, this._leftover += v, this._leftover < 16)\n            return this;\n          this._blocks(this._buffer, 0, 16), this._leftover = 0;\n        }\n        if (d >= 16 && (v = d - d % 16, this._blocks(f, h, v), h += v, d -= v), d) {\n          for (var w = 0; w < d; w++)\n            this._buffer[this._leftover + w] = f[h + w];\n          this._leftover += d;\n        }\n        return this;\n      }, o.prototype.digest = function() {\n        if (this._finished)\n          throw new Error(\"Poly1305 was finished\");\n        var f = new Uint8Array(16);\n        return this.finish(f), f;\n      }, o.prototype.clean = function() {\n        return t.wipe(this._buffer), t.wipe(this._r), t.wipe(this._h), t.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;\n      }, o;\n    }()\n  );\n  r.Poly1305 = i;\n  function n(o, f) {\n    var h = new i(o);\n    h.update(f);\n    var d = h.digest();\n    return h.clean(), d;\n  }\n  r.oneTimeAuth = n;\n  function s(o, f) {\n    return o.length !== r.DIGEST_LENGTH || f.length !== r.DIGEST_LENGTH ? !1 : e.equal(o, f);\n  }\n  r.equal = s;\n})(zu);\n(function(r) {\n  Object.defineProperty(r, \"__esModule\", { value: !0 });\n  var e = va, t = zu, i = nr, n = Ve, s = Mi;\n  r.KEY_LENGTH = 32, r.NONCE_LENGTH = 12, r.TAG_LENGTH = 16;\n  var o = new Uint8Array(16), f = (\n    /** @class */\n    function() {\n      function h(d) {\n        if (this.nonceLength = r.NONCE_LENGTH, this.tagLength = r.TAG_LENGTH, d.length !== r.KEY_LENGTH)\n          throw new Error(\"ChaCha20Poly1305 needs 32-byte key\");\n        this._key = new Uint8Array(d);\n      }\n      return h.prototype.seal = function(d, v, w, A) {\n        if (d.length > 16)\n          throw new Error(\"ChaCha20Poly1305: incorrect nonce length\");\n        var I = new Uint8Array(16);\n        I.set(d, I.length - d.length);\n        var D = new Uint8Array(32);\n        e.stream(this._key, I, D, 4);\n        var N = v.length + this.tagLength, k;\n        if (A) {\n          if (A.length !== N)\n            throw new Error(\"ChaCha20Poly1305: incorrect destination length\");\n          k = A;\n        } else\n          k = new Uint8Array(N);\n        return e.streamXOR(this._key, I, v, k, 4), this._authenticate(k.subarray(k.length - this.tagLength, k.length), D, k.subarray(0, k.length - this.tagLength), w), i.wipe(I), k;\n      }, h.prototype.open = function(d, v, w, A) {\n        if (d.length > 16)\n          throw new Error(\"ChaCha20Poly1305: incorrect nonce length\");\n        if (v.length < this.tagLength)\n          return null;\n        var I = new Uint8Array(16);\n        I.set(d, I.length - d.length);\n        var D = new Uint8Array(32);\n        e.stream(this._key, I, D, 4);\n        var N = new Uint8Array(this.tagLength);\n        if (this._authenticate(N, D, v.subarray(0, v.length - this.tagLength), w), !s.equal(N, v.subarray(v.length - this.tagLength, v.length)))\n          return null;\n        var k = v.length - this.tagLength, j;\n        if (A) {\n          if (A.length !== k)\n            throw new Error(\"ChaCha20Poly1305: incorrect destination length\");\n          j = A;\n        } else\n          j = new Uint8Array(k);\n        return e.streamXOR(this._key, I, v.subarray(0, v.length - this.tagLength), j, 4), i.wipe(I), j;\n      }, h.prototype.clean = function() {\n        return i.wipe(this._key), this;\n      }, h.prototype._authenticate = function(d, v, w, A) {\n        var I = new t.Poly1305(v);\n        A && (I.update(A), A.length % 16 > 0 && I.update(o.subarray(A.length % 16))), I.update(w), w.length % 16 > 0 && I.update(o.subarray(w.length % 16));\n        var D = new Uint8Array(8);\n        A && n.writeUint64LE(A.length, D), I.update(D), n.writeUint64LE(w.length, D), I.update(D);\n        for (var N = I.digest(), k = 0; k < N.length; k++)\n          d[k] = N[k];\n        I.clean(), i.wipe(N), i.wipe(D);\n      }, h;\n    }()\n  );\n  r.ChaCha20Poly1305 = f;\n})(Ko);\nvar ku = {}, ss = {}, Ho = {};\nObject.defineProperty(Ho, \"__esModule\", { value: !0 });\nfunction Kg(r) {\n  return typeof r.saveState < \"u\" && typeof r.restoreState < \"u\" && typeof r.cleanSavedState < \"u\";\n}\nHo.isSerializableHash = Kg;\nObject.defineProperty(ss, \"__esModule\", { value: !0 });\nvar Dr = Ho, Hg = Mi, Vg = nr, ju = (\n  /** @class */\n  function() {\n    function r(e, t) {\n      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;\n      var i = new Uint8Array(this.blockSize);\n      t.length > this.blockSize ? this._inner.update(t).finish(i).clean() : i.set(t);\n      for (var n = 0; n < i.length; n++)\n        i[n] ^= 54;\n      this._inner.update(i);\n      for (var n = 0; n < i.length; n++)\n        i[n] ^= 106;\n      this._outer.update(i), Dr.isSerializableHash(this._inner) && Dr.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), Vg.wipe(i);\n    }\n    return r.prototype.reset = function() {\n      if (!Dr.isSerializableHash(this._inner) || !Dr.isSerializableHash(this._outer))\n        throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;\n    }, r.prototype.clean = function() {\n      Dr.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), Dr.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();\n    }, r.prototype.update = function(e) {\n      return this._inner.update(e), this;\n    }, r.prototype.finish = function(e) {\n      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);\n    }, r.prototype.digest = function() {\n      var e = new Uint8Array(this.digestLength);\n      return this.finish(e), e;\n    }, r.prototype.saveState = function() {\n      if (!Dr.isSerializableHash(this._inner))\n        throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n      return this._inner.saveState();\n    }, r.prototype.restoreState = function(e) {\n      if (!Dr.isSerializableHash(this._inner) || !Dr.isSerializableHash(this._outer))\n        throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;\n    }, r.prototype.cleanSavedState = function(e) {\n      if (!Dr.isSerializableHash(this._inner))\n        throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n      this._inner.cleanSavedState(e);\n    }, r;\n  }()\n);\nss.HMAC = ju;\nfunction Wg(r, e, t) {\n  var i = new ju(r, e);\n  i.update(t);\n  var n = i.digest();\n  return i.clean(), n;\n}\nss.hmac = Wg;\nss.equal = Hg.equal;\nObject.defineProperty(ku, \"__esModule\", { value: !0 });\nvar vc = ss, bc = nr, Gg = (\n  /** @class */\n  function() {\n    function r(e, t, i, n) {\n      i === void 0 && (i = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = n;\n      var s = vc.hmac(this._hash, i, t);\n      this._hmac = new vc.HMAC(e, s), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;\n    }\n    return r.prototype._fillBuffer = function() {\n      this._counter[0]++;\n      var e = this._counter[0];\n      if (e === 0)\n        throw new Error(\"hkdf: cannot expand more\");\n      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;\n    }, r.prototype.expand = function(e) {\n      for (var t = new Uint8Array(e), i = 0; i < t.length; i++)\n        this._bufpos === this._buffer.length && this._fillBuffer(), t[i] = this._buffer[this._bufpos++];\n      return t;\n    }, r.prototype.clean = function() {\n      this._hmac.clean(), bc.wipe(this._buffer), bc.wipe(this._counter), this._bufpos = 0;\n    }, r;\n  }()\n), Jg = ku.HKDF = Gg, as = {};\n(function(r) {\n  Object.defineProperty(r, \"__esModule\", { value: !0 });\n  var e = Ve, t = nr;\n  r.DIGEST_LENGTH = 32, r.BLOCK_SIZE = 64;\n  var i = (\n    /** @class */\n    function() {\n      function f() {\n        this.digestLength = r.DIGEST_LENGTH, this.blockSize = r.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();\n      }\n      return f.prototype._initState = function() {\n        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;\n      }, f.prototype.reset = function() {\n        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;\n      }, f.prototype.clean = function() {\n        t.wipe(this._buffer), t.wipe(this._temp), this.reset();\n      }, f.prototype.update = function(h, d) {\n        if (d === void 0 && (d = h.length), this._finished)\n          throw new Error(\"SHA256: can't update because hash was finished.\");\n        var v = 0;\n        if (this._bytesHashed += d, this._bufferLength > 0) {\n          for (; this._bufferLength < this.blockSize && d > 0; )\n            this._buffer[this._bufferLength++] = h[v++], d--;\n          this._bufferLength === this.blockSize && (s(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);\n        }\n        for (d >= this.blockSize && (v = s(this._temp, this._state, h, v, d), d %= this.blockSize); d > 0; )\n          this._buffer[this._bufferLength++] = h[v++], d--;\n        return this;\n      }, f.prototype.finish = function(h) {\n        if (!this._finished) {\n          var d = this._bytesHashed, v = this._bufferLength, w = d / 536870912 | 0, A = d << 3, I = d % 64 < 56 ? 64 : 128;\n          this._buffer[v] = 128;\n          for (var D = v + 1; D < I - 8; D++)\n            this._buffer[D] = 0;\n          e.writeUint32BE(w, this._buffer, I - 8), e.writeUint32BE(A, this._buffer, I - 4), s(this._temp, this._state, this._buffer, 0, I), this._finished = !0;\n        }\n        for (var D = 0; D < this.digestLength / 4; D++)\n          e.writeUint32BE(this._state[D], h, D * 4);\n        return this;\n      }, f.prototype.digest = function() {\n        var h = new Uint8Array(this.digestLength);\n        return this.finish(h), h;\n      }, f.prototype.saveState = function() {\n        if (this._finished)\n          throw new Error(\"SHA256: cannot save finished state\");\n        return {\n          state: new Int32Array(this._state),\n          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,\n          bufferLength: this._bufferLength,\n          bytesHashed: this._bytesHashed\n        };\n      }, f.prototype.restoreState = function(h) {\n        return this._state.set(h.state), this._bufferLength = h.bufferLength, h.buffer && this._buffer.set(h.buffer), this._bytesHashed = h.bytesHashed, this._finished = !1, this;\n      }, f.prototype.cleanSavedState = function(h) {\n        t.wipe(h.state), h.buffer && t.wipe(h.buffer), h.bufferLength = 0, h.bytesHashed = 0;\n      }, f;\n    }()\n  );\n  r.SHA256 = i;\n  var n = new Int32Array([\n    1116352408,\n    1899447441,\n    3049323471,\n    3921009573,\n    961987163,\n    1508970993,\n    2453635748,\n    2870763221,\n    3624381080,\n    310598401,\n    607225278,\n    1426881987,\n    1925078388,\n    2162078206,\n    2614888103,\n    3248222580,\n    3835390401,\n    4022224774,\n    264347078,\n    604807628,\n    770255983,\n    1249150122,\n    1555081692,\n    1996064986,\n    2554220882,\n    2821834349,\n    2952996808,\n    3210313671,\n    3336571891,\n    3584528711,\n    113926993,\n    338241895,\n    666307205,\n    773529912,\n    1294757372,\n    1396182291,\n    1695183700,\n    1986661051,\n    2177026350,\n    2456956037,\n    2730485921,\n    2820302411,\n    3259730800,\n    3345764771,\n    3516065817,\n    3600352804,\n    4094571909,\n    275423344,\n    430227734,\n    506948616,\n    659060556,\n    883997877,\n    958139571,\n    1322822218,\n    1537002063,\n    1747873779,\n    1955562222,\n    2024104815,\n    2227730452,\n    2361852424,\n    2428436474,\n    2756734187,\n    3204031479,\n    3329325298\n  ]);\n  function s(f, h, d, v, w) {\n    for (; w >= 64; ) {\n      for (var A = h[0], I = h[1], D = h[2], N = h[3], k = h[4], j = h[5], T = h[6], K = h[7], $ = 0; $ < 16; $++) {\n        var z = v + $ * 4;\n        f[$] = e.readUint32BE(d, z);\n      }\n      for (var $ = 16; $ < 64; $++) {\n        var B = f[$ - 2], _ = (B >>> 17 | B << 32 - 17) ^ (B >>> 19 | B << 32 - 19) ^ B >>> 10;\n        B = f[$ - 15];\n        var R = (B >>> 7 | B << 32 - 7) ^ (B >>> 18 | B << 32 - 18) ^ B >>> 3;\n        f[$] = (_ + f[$ - 7] | 0) + (R + f[$ - 16] | 0);\n      }\n      for (var $ = 0; $ < 64; $++) {\n        var _ = (((k >>> 6 | k << 26) ^ (k >>> 11 | k << 21) ^ (k >>> 25 | k << 7)) + (k & j ^ ~k & T) | 0) + (K + (n[$] + f[$] | 0) | 0) | 0, R = ((A >>> 2 | A << 32 - 2) ^ (A >>> 13 | A << 32 - 13) ^ (A >>> 22 | A << 32 - 22)) + (A & I ^ A & D ^ I & D) | 0;\n        K = T, T = j, j = k, k = N + _ | 0, N = D, D = I, I = A, A = _ + R | 0;\n      }\n      h[0] += A, h[1] += I, h[2] += D, h[3] += N, h[4] += k, h[5] += j, h[6] += T, h[7] += K, v += 64, w -= 64;\n    }\n    return v;\n  }\n  function o(f) {\n    var h = new i();\n    h.update(f);\n    var d = h.digest();\n    return h.clean(), d;\n  }\n  r.hash = o;\n})(as);\nvar Vo = {};\n(function(r) {\n  Object.defineProperty(r, \"__esModule\", { value: !0 }), r.sharedKey = r.generateKeyPair = r.generateKeyPairFromSeed = r.scalarMultBase = r.scalarMult = r.SHARED_KEY_LENGTH = r.SECRET_KEY_LENGTH = r.PUBLIC_KEY_LENGTH = void 0;\n  const e = Ei, t = nr;\n  r.PUBLIC_KEY_LENGTH = 32, r.SECRET_KEY_LENGTH = 32, r.SHARED_KEY_LENGTH = 32;\n  function i($) {\n    const z = new Float64Array(16);\n    if ($)\n      for (let B = 0; B < $.length; B++)\n        z[B] = $[B];\n    return z;\n  }\n  const n = new Uint8Array(32);\n  n[0] = 9;\n  const s = i([56129, 1]);\n  function o($) {\n    let z = 1;\n    for (let B = 0; B < 16; B++) {\n      let _ = $[B] + z + 65535;\n      z = Math.floor(_ / 65536), $[B] = _ - z * 65536;\n    }\n    $[0] += z - 1 + 37 * (z - 1);\n  }\n  function f($, z, B) {\n    const _ = ~(B - 1);\n    for (let R = 0; R < 16; R++) {\n      const J = _ & ($[R] ^ z[R]);\n      $[R] ^= J, z[R] ^= J;\n    }\n  }\n  function h($, z) {\n    const B = i(), _ = i();\n    for (let R = 0; R < 16; R++)\n      _[R] = z[R];\n    o(_), o(_), o(_);\n    for (let R = 0; R < 2; R++) {\n      B[0] = _[0] - 65517;\n      for (let Q = 1; Q < 15; Q++)\n        B[Q] = _[Q] - 65535 - (B[Q - 1] >> 16 & 1), B[Q - 1] &= 65535;\n      B[15] = _[15] - 32767 - (B[14] >> 16 & 1);\n      const J = B[15] >> 16 & 1;\n      B[14] &= 65535, f(_, B, 1 - J);\n    }\n    for (let R = 0; R < 16; R++)\n      $[2 * R] = _[R] & 255, $[2 * R + 1] = _[R] >> 8;\n  }\n  function d($, z) {\n    for (let B = 0; B < 16; B++)\n      $[B] = z[2 * B] + (z[2 * B + 1] << 8);\n    $[15] &= 32767;\n  }\n  function v($, z, B) {\n    for (let _ = 0; _ < 16; _++)\n      $[_] = z[_] + B[_];\n  }\n  function w($, z, B) {\n    for (let _ = 0; _ < 16; _++)\n      $[_] = z[_] - B[_];\n  }\n  function A($, z, B) {\n    let _, R, J = 0, Q = 0, O = 0, p = 0, l = 0, a = 0, c = 0, b = 0, E = 0, S = 0, x = 0, u = 0, m = 0, g = 0, P = 0, G = 0, M = 0, H = 0, C = 0, q = 0, L = 0, y = 0, F = 0, W = 0, Y = 0, X = 0, ee = 0, we = 0, Me = 0, he = 0, Re = 0, xe = B[0], se = B[1], ge = B[2], le = B[3], ne = B[4], ue = B[5], fe = B[6], te = B[7], pe = B[8], _e = B[9], re = B[10], Ee = B[11], Se = B[12], oe = B[13], De = B[14], Ie = B[15];\n    _ = z[0], J += _ * xe, Q += _ * se, O += _ * ge, p += _ * le, l += _ * ne, a += _ * ue, c += _ * fe, b += _ * te, E += _ * pe, S += _ * _e, x += _ * re, u += _ * Ee, m += _ * Se, g += _ * oe, P += _ * De, G += _ * Ie, _ = z[1], Q += _ * xe, O += _ * se, p += _ * ge, l += _ * le, a += _ * ne, c += _ * ue, b += _ * fe, E += _ * te, S += _ * pe, x += _ * _e, u += _ * re, m += _ * Ee, g += _ * Se, P += _ * oe, G += _ * De, M += _ * Ie, _ = z[2], O += _ * xe, p += _ * se, l += _ * ge, a += _ * le, c += _ * ne, b += _ * ue, E += _ * fe, S += _ * te, x += _ * pe, u += _ * _e, m += _ * re, g += _ * Ee, P += _ * Se, G += _ * oe, M += _ * De, H += _ * Ie, _ = z[3], p += _ * xe, l += _ * se, a += _ * ge, c += _ * le, b += _ * ne, E += _ * ue, S += _ * fe, x += _ * te, u += _ * pe, m += _ * _e, g += _ * re, P += _ * Ee, G += _ * Se, M += _ * oe, H += _ * De, C += _ * Ie, _ = z[4], l += _ * xe, a += _ * se, c += _ * ge, b += _ * le, E += _ * ne, S += _ * ue, x += _ * fe, u += _ * te, m += _ * pe, g += _ * _e, P += _ * re, G += _ * Ee, M += _ * Se, H += _ * oe, C += _ * De, q += _ * Ie, _ = z[5], a += _ * xe, c += _ * se, b += _ * ge, E += _ * le, S += _ * ne, x += _ * ue, u += _ * fe, m += _ * te, g += _ * pe, P += _ * _e, G += _ * re, M += _ * Ee, H += _ * Se, C += _ * oe, q += _ * De, L += _ * Ie, _ = z[6], c += _ * xe, b += _ * se, E += _ * ge, S += _ * le, x += _ * ne, u += _ * ue, m += _ * fe, g += _ * te, P += _ * pe, G += _ * _e, M += _ * re, H += _ * Ee, C += _ * Se, q += _ * oe, L += _ * De, y += _ * Ie, _ = z[7], b += _ * xe, E += _ * se, S += _ * ge, x += _ * le, u += _ * ne, m += _ * ue, g += _ * fe, P += _ * te, G += _ * pe, M += _ * _e, H += _ * re, C += _ * Ee, q += _ * Se, L += _ * oe, y += _ * De, F += _ * Ie, _ = z[8], E += _ * xe, S += _ * se, x += _ * ge, u += _ * le, m += _ * ne, g += _ * ue, P += _ * fe, G += _ * te, M += _ * pe, H += _ * _e, C += _ * re, q += _ * Ee, L += _ * Se, y += _ * oe, F += _ * De, W += _ * Ie, _ = z[9], S += _ * xe, x += _ * se, u += _ * ge, m += _ * le, g += _ * ne, P += _ * ue, G += _ * fe, M += _ * te, H += _ * pe, C += _ * _e, q += _ * re, L += _ * Ee, y += _ * Se, F += _ * oe, W += _ * De, Y += _ * Ie, _ = z[10], x += _ * xe, u += _ * se, m += _ * ge, g += _ * le, P += _ * ne, G += _ * ue, M += _ * fe, H += _ * te, C += _ * pe, q += _ * _e, L += _ * re, y += _ * Ee, F += _ * Se, W += _ * oe, Y += _ * De, X += _ * Ie, _ = z[11], u += _ * xe, m += _ * se, g += _ * ge, P += _ * le, G += _ * ne, M += _ * ue, H += _ * fe, C += _ * te, q += _ * pe, L += _ * _e, y += _ * re, F += _ * Ee, W += _ * Se, Y += _ * oe, X += _ * De, ee += _ * Ie, _ = z[12], m += _ * xe, g += _ * se, P += _ * ge, G += _ * le, M += _ * ne, H += _ * ue, C += _ * fe, q += _ * te, L += _ * pe, y += _ * _e, F += _ * re, W += _ * Ee, Y += _ * Se, X += _ * oe, ee += _ * De, we += _ * Ie, _ = z[13], g += _ * xe, P += _ * se, G += _ * ge, M += _ * le, H += _ * ne, C += _ * ue, q += _ * fe, L += _ * te, y += _ * pe, F += _ * _e, W += _ * re, Y += _ * Ee, X += _ * Se, ee += _ * oe, we += _ * De, Me += _ * Ie, _ = z[14], P += _ * xe, G += _ * se, M += _ * ge, H += _ * le, C += _ * ne, q += _ * ue, L += _ * fe, y += _ * te, F += _ * pe, W += _ * _e, Y += _ * re, X += _ * Ee, ee += _ * Se, we += _ * oe, Me += _ * De, he += _ * Ie, _ = z[15], G += _ * xe, M += _ * se, H += _ * ge, C += _ * le, q += _ * ne, L += _ * ue, y += _ * fe, F += _ * te, W += _ * pe, Y += _ * _e, X += _ * re, ee += _ * Ee, we += _ * Se, Me += _ * oe, he += _ * De, Re += _ * Ie, J += 38 * M, Q += 38 * H, O += 38 * C, p += 38 * q, l += 38 * L, a += 38 * y, c += 38 * F, b += 38 * W, E += 38 * Y, S += 38 * X, x += 38 * ee, u += 38 * we, m += 38 * Me, g += 38 * he, P += 38 * Re, R = 1, _ = J + R + 65535, R = Math.floor(_ / 65536), J = _ - R * 65536, _ = Q + R + 65535, R = Math.floor(_ / 65536), Q = _ - R * 65536, _ = O + R + 65535, R = Math.floor(_ / 65536), O = _ - R * 65536, _ = p + R + 65535, R = Math.floor(_ / 65536), p = _ - R * 65536, _ = l + R + 65535, R = Math.floor(_ / 65536), l = _ - R * 65536, _ = a + R + 65535, R = Math.floor(_ / 65536), a = _ - R * 65536, _ = c + R + 65535, R = Math.floor(_ / 65536), c = _ - R * 65536, _ = b + R + 65535, R = Math.floor(_ / 65536), b = _ - R * 65536, _ = E + R + 65535, R = Math.floor(_ / 65536), E = _ - R * 65536, _ = S + R + 65535, R = Math.floor(_ / 65536), S = _ - R * 65536, _ = x + R + 65535, R = Math.floor(_ / 65536), x = _ - R * 65536, _ = u + R + 65535, R = Math.floor(_ / 65536), u = _ - R * 65536, _ = m + R + 65535, R = Math.floor(_ / 65536), m = _ - R * 65536, _ = g + R + 65535, R = Math.floor(_ / 65536), g = _ - R * 65536, _ = P + R + 65535, R = Math.floor(_ / 65536), P = _ - R * 65536, _ = G + R + 65535, R = Math.floor(_ / 65536), G = _ - R * 65536, J += R - 1 + 37 * (R - 1), R = 1, _ = J + R + 65535, R = Math.floor(_ / 65536), J = _ - R * 65536, _ = Q + R + 65535, R = Math.floor(_ / 65536), Q = _ - R * 65536, _ = O + R + 65535, R = Math.floor(_ / 65536), O = _ - R * 65536, _ = p + R + 65535, R = Math.floor(_ / 65536), p = _ - R * 65536, _ = l + R + 65535, R = Math.floor(_ / 65536), l = _ - R * 65536, _ = a + R + 65535, R = Math.floor(_ / 65536), a = _ - R * 65536, _ = c + R + 65535, R = Math.floor(_ / 65536), c = _ - R * 65536, _ = b + R + 65535, R = Math.floor(_ / 65536), b = _ - R * 65536, _ = E + R + 65535, R = Math.floor(_ / 65536), E = _ - R * 65536, _ = S + R + 65535, R = Math.floor(_ / 65536), S = _ - R * 65536, _ = x + R + 65535, R = Math.floor(_ / 65536), x = _ - R * 65536, _ = u + R + 65535, R = Math.floor(_ / 65536), u = _ - R * 65536, _ = m + R + 65535, R = Math.floor(_ / 65536), m = _ - R * 65536, _ = g + R + 65535, R = Math.floor(_ / 65536), g = _ - R * 65536, _ = P + R + 65535, R = Math.floor(_ / 65536), P = _ - R * 65536, _ = G + R + 65535, R = Math.floor(_ / 65536), G = _ - R * 65536, J += R - 1 + 37 * (R - 1), $[0] = J, $[1] = Q, $[2] = O, $[3] = p, $[4] = l, $[5] = a, $[6] = c, $[7] = b, $[8] = E, $[9] = S, $[10] = x, $[11] = u, $[12] = m, $[13] = g, $[14] = P, $[15] = G;\n  }\n  function I($, z) {\n    A($, z, z);\n  }\n  function D($, z) {\n    const B = i();\n    for (let _ = 0; _ < 16; _++)\n      B[_] = z[_];\n    for (let _ = 253; _ >= 0; _--)\n      I(B, B), _ !== 2 && _ !== 4 && A(B, B, z);\n    for (let _ = 0; _ < 16; _++)\n      $[_] = B[_];\n  }\n  function N($, z) {\n    const B = new Uint8Array(32), _ = new Float64Array(80), R = i(), J = i(), Q = i(), O = i(), p = i(), l = i();\n    for (let E = 0; E < 31; E++)\n      B[E] = $[E];\n    B[31] = $[31] & 127 | 64, B[0] &= 248, d(_, z);\n    for (let E = 0; E < 16; E++)\n      J[E] = _[E];\n    R[0] = O[0] = 1;\n    for (let E = 254; E >= 0; --E) {\n      const S = B[E >>> 3] >>> (E & 7) & 1;\n      f(R, J, S), f(Q, O, S), v(p, R, Q), w(R, R, Q), v(Q, J, O), w(J, J, O), I(O, p), I(l, R), A(R, Q, R), A(Q, J, p), v(p, R, Q), w(R, R, Q), I(J, R), w(Q, O, l), A(R, Q, s), v(R, R, O), A(Q, Q, R), A(R, O, l), A(O, J, _), I(J, p), f(R, J, S), f(Q, O, S);\n    }\n    for (let E = 0; E < 16; E++)\n      _[E + 16] = R[E], _[E + 32] = Q[E], _[E + 48] = J[E], _[E + 64] = O[E];\n    const a = _.subarray(32), c = _.subarray(16);\n    D(a, a), A(c, c, a);\n    const b = new Uint8Array(32);\n    return h(b, c), b;\n  }\n  r.scalarMult = N;\n  function k($) {\n    return N($, n);\n  }\n  r.scalarMultBase = k;\n  function j($) {\n    if ($.length !== r.SECRET_KEY_LENGTH)\n      throw new Error(`x25519: seed must be ${r.SECRET_KEY_LENGTH} bytes`);\n    const z = new Uint8Array($);\n    return {\n      publicKey: k(z),\n      secretKey: z\n    };\n  }\n  r.generateKeyPairFromSeed = j;\n  function T($) {\n    const z = (0, e.randomBytes)(32, $), B = j(z);\n    return (0, t.wipe)(z), B;\n  }\n  r.generateKeyPair = T;\n  function K($, z, B = !1) {\n    if ($.length !== r.PUBLIC_KEY_LENGTH)\n      throw new Error(\"X25519: incorrect secret key length\");\n    if (z.length !== r.PUBLIC_KEY_LENGTH)\n      throw new Error(\"X25519: incorrect public key length\");\n    const _ = N($, z);\n    if (B) {\n      let R = 0;\n      for (let J = 0; J < _.length; J++)\n        R |= _[J];\n      if (R === 0)\n        throw new Error(\"X25519: invalid shared key\");\n    }\n    return _;\n  }\n  r.sharedKey = K;\n})(Vo);\nvar Ku = {};\nconst Yg = \"elliptic\", Xg = \"6.6.1\", Zg = \"EC cryptography\", Qg = \"lib/elliptic.js\", e2 = [\n  \"lib\"\n], t2 = {\n  lint: \"eslint lib test\",\n  \"lint:fix\": \"npm run lint -- --fix\",\n  unit: \"istanbul test _mocha --reporter=spec test/index.js\",\n  test: \"npm run lint && npm run unit\",\n  version: \"grunt dist && git add dist/\"\n}, r2 = {\n  type: \"git\",\n  url: \"git@github.com:indutny/elliptic\"\n}, i2 = [\n  \"EC\",\n  \"Elliptic\",\n  \"curve\",\n  \"Cryptography\"\n], n2 = \"Fedor Indutny <fedor@indutny.com>\", s2 = \"MIT\", a2 = {\n  url: \"https://github.com/indutny/elliptic/issues\"\n}, o2 = \"https://github.com/indutny/elliptic\", f2 = {\n  brfs: \"^2.0.2\",\n  coveralls: \"^3.1.0\",\n  eslint: \"^7.6.0\",\n  grunt: \"^1.2.1\",\n  \"grunt-browserify\": \"^5.3.0\",\n  \"grunt-cli\": \"^1.3.2\",\n  \"grunt-contrib-connect\": \"^3.0.0\",\n  \"grunt-contrib-copy\": \"^1.0.0\",\n  \"grunt-contrib-uglify\": \"^5.0.0\",\n  \"grunt-mocha-istanbul\": \"^5.0.2\",\n  \"grunt-saucelabs\": \"^9.0.1\",\n  istanbul: \"^0.4.5\",\n  mocha: \"^8.0.1\"\n}, c2 = {\n  \"bn.js\": \"^4.11.9\",\n  brorand: \"^1.1.0\",\n  \"hash.js\": \"^1.0.0\",\n  \"hmac-drbg\": \"^1.0.1\",\n  inherits: \"^2.0.4\",\n  \"minimalistic-assert\": \"^1.0.1\",\n  \"minimalistic-crypto-utils\": \"^1.0.1\"\n}, h2 = {\n  name: Yg,\n  version: Xg,\n  description: Zg,\n  main: Qg,\n  files: e2,\n  scripts: t2,\n  repository: r2,\n  keywords: i2,\n  author: n2,\n  license: s2,\n  bugs: a2,\n  homepage: o2,\n  devDependencies: f2,\n  dependencies: c2\n};\nvar ar = {}, Wo = { exports: {} };\nWo.exports;\n(function(r) {\n  (function(e, t) {\n    function i(O, p) {\n      if (!O)\n        throw new Error(p || \"Assertion failed\");\n    }\n    function n(O, p) {\n      O.super_ = p;\n      var l = function() {\n      };\n      l.prototype = p.prototype, O.prototype = new l(), O.prototype.constructor = O;\n    }\n    function s(O, p, l) {\n      if (s.isBN(O))\n        return O;\n      this.negative = 0, this.words = null, this.length = 0, this.red = null, O !== null && ((p === \"le\" || p === \"be\") && (l = p, p = 10), this._init(O || 0, p || 10, l || \"be\"));\n    }\n    typeof e == \"object\" ? e.exports = s : t.BN = s, s.BN = s, s.wordSize = 26;\n    var o;\n    try {\n      typeof window < \"u\" && typeof window.Buffer < \"u\" ? o = window.Buffer : o = fa.Buffer;\n    } catch {\n    }\n    s.isBN = function(p) {\n      return p instanceof s ? !0 : p !== null && typeof p == \"object\" && p.constructor.wordSize === s.wordSize && Array.isArray(p.words);\n    }, s.max = function(p, l) {\n      return p.cmp(l) > 0 ? p : l;\n    }, s.min = function(p, l) {\n      return p.cmp(l) < 0 ? p : l;\n    }, s.prototype._init = function(p, l, a) {\n      if (typeof p == \"number\")\n        return this._initNumber(p, l, a);\n      if (typeof p == \"object\")\n        return this._initArray(p, l, a);\n      l === \"hex\" && (l = 16), i(l === (l | 0) && l >= 2 && l <= 36), p = p.toString().replace(/\\s+/g, \"\");\n      var c = 0;\n      p[0] === \"-\" && (c++, this.negative = 1), c < p.length && (l === 16 ? this._parseHex(p, c, a) : (this._parseBase(p, l, c), a === \"le\" && this._initArray(this.toArray(), l, a)));\n    }, s.prototype._initNumber = function(p, l, a) {\n      p < 0 && (this.negative = 1, p = -p), p < 67108864 ? (this.words = [p & 67108863], this.length = 1) : p < 4503599627370496 ? (this.words = [\n        p & 67108863,\n        p / 67108864 & 67108863\n      ], this.length = 2) : (i(p < 9007199254740992), this.words = [\n        p & 67108863,\n        p / 67108864 & 67108863,\n        1\n      ], this.length = 3), a === \"le\" && this._initArray(this.toArray(), l, a);\n    }, s.prototype._initArray = function(p, l, a) {\n      if (i(typeof p.length == \"number\"), p.length <= 0)\n        return this.words = [0], this.length = 1, this;\n      this.length = Math.ceil(p.length / 3), this.words = new Array(this.length);\n      for (var c = 0; c < this.length; c++)\n        this.words[c] = 0;\n      var b, E, S = 0;\n      if (a === \"be\")\n        for (c = p.length - 1, b = 0; c >= 0; c -= 3)\n          E = p[c] | p[c - 1] << 8 | p[c - 2] << 16, this.words[b] |= E << S & 67108863, this.words[b + 1] = E >>> 26 - S & 67108863, S += 24, S >= 26 && (S -= 26, b++);\n      else if (a === \"le\")\n        for (c = 0, b = 0; c < p.length; c += 3)\n          E = p[c] | p[c + 1] << 8 | p[c + 2] << 16, this.words[b] |= E << S & 67108863, this.words[b + 1] = E >>> 26 - S & 67108863, S += 24, S >= 26 && (S -= 26, b++);\n      return this.strip();\n    };\n    function f(O, p) {\n      var l = O.charCodeAt(p);\n      return l >= 65 && l <= 70 ? l - 55 : l >= 97 && l <= 102 ? l - 87 : l - 48 & 15;\n    }\n    function h(O, p, l) {\n      var a = f(O, l);\n      return l - 1 >= p && (a |= f(O, l - 1) << 4), a;\n    }\n    s.prototype._parseHex = function(p, l, a) {\n      this.length = Math.ceil((p.length - l) / 6), this.words = new Array(this.length);\n      for (var c = 0; c < this.length; c++)\n        this.words[c] = 0;\n      var b = 0, E = 0, S;\n      if (a === \"be\")\n        for (c = p.length - 1; c >= l; c -= 2)\n          S = h(p, l, c) << b, this.words[E] |= S & 67108863, b >= 18 ? (b -= 18, E += 1, this.words[E] |= S >>> 26) : b += 8;\n      else {\n        var x = p.length - l;\n        for (c = x % 2 === 0 ? l + 1 : l; c < p.length; c += 2)\n          S = h(p, l, c) << b, this.words[E] |= S & 67108863, b >= 18 ? (b -= 18, E += 1, this.words[E] |= S >>> 26) : b += 8;\n      }\n      this.strip();\n    };\n    function d(O, p, l, a) {\n      for (var c = 0, b = Math.min(O.length, l), E = p; E < b; E++) {\n        var S = O.charCodeAt(E) - 48;\n        c *= a, S >= 49 ? c += S - 49 + 10 : S >= 17 ? c += S - 17 + 10 : c += S;\n      }\n      return c;\n    }\n    s.prototype._parseBase = function(p, l, a) {\n      this.words = [0], this.length = 1;\n      for (var c = 0, b = 1; b <= 67108863; b *= l)\n        c++;\n      c--, b = b / l | 0;\n      for (var E = p.length - a, S = E % c, x = Math.min(E, E - S) + a, u = 0, m = a; m < x; m += c)\n        u = d(p, m, m + c, l), this.imuln(b), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u);\n      if (S !== 0) {\n        var g = 1;\n        for (u = d(p, m, p.length, l), m = 0; m < S; m++)\n          g *= l;\n        this.imuln(g), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u);\n      }\n      this.strip();\n    }, s.prototype.copy = function(p) {\n      p.words = new Array(this.length);\n      for (var l = 0; l < this.length; l++)\n        p.words[l] = this.words[l];\n      p.length = this.length, p.negative = this.negative, p.red = this.red;\n    }, s.prototype.clone = function() {\n      var p = new s(null);\n      return this.copy(p), p;\n    }, s.prototype._expand = function(p) {\n      for (; this.length < p; )\n        this.words[this.length++] = 0;\n      return this;\n    }, s.prototype.strip = function() {\n      for (; this.length > 1 && this.words[this.length - 1] === 0; )\n        this.length--;\n      return this._normSign();\n    }, s.prototype._normSign = function() {\n      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;\n    }, s.prototype.inspect = function() {\n      return (this.red ? \"<BN-R: \" : \"<BN: \") + this.toString(16) + \">\";\n    };\n    var v = [\n      \"\",\n      \"0\",\n      \"00\",\n      \"000\",\n      \"0000\",\n      \"00000\",\n      \"000000\",\n      \"0000000\",\n      \"00000000\",\n      \"000000000\",\n      \"0000000000\",\n      \"00000000000\",\n      \"000000000000\",\n      \"0000000000000\",\n      \"00000000000000\",\n      \"000000000000000\",\n      \"0000000000000000\",\n      \"00000000000000000\",\n      \"000000000000000000\",\n      \"0000000000000000000\",\n      \"00000000000000000000\",\n      \"000000000000000000000\",\n      \"0000000000000000000000\",\n      \"00000000000000000000000\",\n      \"000000000000000000000000\",\n      \"0000000000000000000000000\"\n    ], w = [\n      0,\n      0,\n      25,\n      16,\n      12,\n      11,\n      10,\n      9,\n      8,\n      8,\n      7,\n      7,\n      7,\n      7,\n      6,\n      6,\n      6,\n      6,\n      6,\n      6,\n      6,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5\n    ], A = [\n      0,\n      0,\n      33554432,\n      43046721,\n      16777216,\n      48828125,\n      60466176,\n      40353607,\n      16777216,\n      43046721,\n      1e7,\n      19487171,\n      35831808,\n      62748517,\n      7529536,\n      11390625,\n      16777216,\n      24137569,\n      34012224,\n      47045881,\n      64e6,\n      4084101,\n      5153632,\n      6436343,\n      7962624,\n      9765625,\n      11881376,\n      14348907,\n      17210368,\n      20511149,\n      243e5,\n      28629151,\n      33554432,\n      39135393,\n      45435424,\n      52521875,\n      60466176\n    ];\n    s.prototype.toString = function(p, l) {\n      p = p || 10, l = l | 0 || 1;\n      var a;\n      if (p === 16 || p === \"hex\") {\n        a = \"\";\n        for (var c = 0, b = 0, E = 0; E < this.length; E++) {\n          var S = this.words[E], x = ((S << c | b) & 16777215).toString(16);\n          b = S >>> 24 - c & 16777215, c += 2, c >= 26 && (c -= 26, E--), b !== 0 || E !== this.length - 1 ? a = v[6 - x.length] + x + a : a = x + a;\n        }\n        for (b !== 0 && (a = b.toString(16) + a); a.length % l !== 0; )\n          a = \"0\" + a;\n        return this.negative !== 0 && (a = \"-\" + a), a;\n      }\n      if (p === (p | 0) && p >= 2 && p <= 36) {\n        var u = w[p], m = A[p];\n        a = \"\";\n        var g = this.clone();\n        for (g.negative = 0; !g.isZero(); ) {\n          var P = g.modn(m).toString(p);\n          g = g.idivn(m), g.isZero() ? a = P + a : a = v[u - P.length] + P + a;\n        }\n        for (this.isZero() && (a = \"0\" + a); a.length % l !== 0; )\n          a = \"0\" + a;\n        return this.negative !== 0 && (a = \"-\" + a), a;\n      }\n      i(!1, \"Base should be between 2 and 36\");\n    }, s.prototype.toNumber = function() {\n      var p = this.words[0];\n      return this.length === 2 ? p += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? p += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, \"Number can only safely store up to 53 bits\"), this.negative !== 0 ? -p : p;\n    }, s.prototype.toJSON = function() {\n      return this.toString(16);\n    }, s.prototype.toBuffer = function(p, l) {\n      return i(typeof o < \"u\"), this.toArrayLike(o, p, l);\n    }, s.prototype.toArray = function(p, l) {\n      return this.toArrayLike(Array, p, l);\n    }, s.prototype.toArrayLike = function(p, l, a) {\n      var c = this.byteLength(), b = a || Math.max(1, c);\n      i(c <= b, \"byte array longer than desired length\"), i(b > 0, \"Requested array length <= 0\"), this.strip();\n      var E = l === \"le\", S = new p(b), x, u, m = this.clone();\n      if (E) {\n        for (u = 0; !m.isZero(); u++)\n          x = m.andln(255), m.iushrn(8), S[u] = x;\n        for (; u < b; u++)\n          S[u] = 0;\n      } else {\n        for (u = 0; u < b - c; u++)\n          S[u] = 0;\n        for (u = 0; !m.isZero(); u++)\n          x = m.andln(255), m.iushrn(8), S[b - u - 1] = x;\n      }\n      return S;\n    }, Math.clz32 ? s.prototype._countBits = function(p) {\n      return 32 - Math.clz32(p);\n    } : s.prototype._countBits = function(p) {\n      var l = p, a = 0;\n      return l >= 4096 && (a += 13, l >>>= 13), l >= 64 && (a += 7, l >>>= 7), l >= 8 && (a += 4, l >>>= 4), l >= 2 && (a += 2, l >>>= 2), a + l;\n    }, s.prototype._zeroBits = function(p) {\n      if (p === 0)\n        return 26;\n      var l = p, a = 0;\n      return l & 8191 || (a += 13, l >>>= 13), l & 127 || (a += 7, l >>>= 7), l & 15 || (a += 4, l >>>= 4), l & 3 || (a += 2, l >>>= 2), l & 1 || a++, a;\n    }, s.prototype.bitLength = function() {\n      var p = this.words[this.length - 1], l = this._countBits(p);\n      return (this.length - 1) * 26 + l;\n    };\n    function I(O) {\n      for (var p = new Array(O.bitLength()), l = 0; l < p.length; l++) {\n        var a = l / 26 | 0, c = l % 26;\n        p[l] = (O.words[a] & 1 << c) >>> c;\n      }\n      return p;\n    }\n    s.prototype.zeroBits = function() {\n      if (this.isZero())\n        return 0;\n      for (var p = 0, l = 0; l < this.length; l++) {\n        var a = this._zeroBits(this.words[l]);\n        if (p += a, a !== 26)\n          break;\n      }\n      return p;\n    }, s.prototype.byteLength = function() {\n      return Math.ceil(this.bitLength() / 8);\n    }, s.prototype.toTwos = function(p) {\n      return this.negative !== 0 ? this.abs().inotn(p).iaddn(1) : this.clone();\n    }, s.prototype.fromTwos = function(p) {\n      return this.testn(p - 1) ? this.notn(p).iaddn(1).ineg() : this.clone();\n    }, s.prototype.isNeg = function() {\n      return this.negative !== 0;\n    }, s.prototype.neg = function() {\n      return this.clone().ineg();\n    }, s.prototype.ineg = function() {\n      return this.isZero() || (this.negative ^= 1), this;\n    }, s.prototype.iuor = function(p) {\n      for (; this.length < p.length; )\n        this.words[this.length++] = 0;\n      for (var l = 0; l < p.length; l++)\n        this.words[l] = this.words[l] | p.words[l];\n      return this.strip();\n    }, s.prototype.ior = function(p) {\n      return i((this.negative | p.negative) === 0), this.iuor(p);\n    }, s.prototype.or = function(p) {\n      return this.length > p.length ? this.clone().ior(p) : p.clone().ior(this);\n    }, s.prototype.uor = function(p) {\n      return this.length > p.length ? this.clone().iuor(p) : p.clone().iuor(this);\n    }, s.prototype.iuand = function(p) {\n      var l;\n      this.length > p.length ? l = p : l = this;\n      for (var a = 0; a < l.length; a++)\n        this.words[a] = this.words[a] & p.words[a];\n      return this.length = l.length, this.strip();\n    }, s.prototype.iand = function(p) {\n      return i((this.negative | p.negative) === 0), this.iuand(p);\n    }, s.prototype.and = function(p) {\n      return this.length > p.length ? this.clone().iand(p) : p.clone().iand(this);\n    }, s.prototype.uand = function(p) {\n      return this.length > p.length ? this.clone().iuand(p) : p.clone().iuand(this);\n    }, s.prototype.iuxor = function(p) {\n      var l, a;\n      this.length > p.length ? (l = this, a = p) : (l = p, a = this);\n      for (var c = 0; c < a.length; c++)\n        this.words[c] = l.words[c] ^ a.words[c];\n      if (this !== l)\n        for (; c < l.length; c++)\n          this.words[c] = l.words[c];\n      return this.length = l.length, this.strip();\n    }, s.prototype.ixor = function(p) {\n      return i((this.negative | p.negative) === 0), this.iuxor(p);\n    }, s.prototype.xor = function(p) {\n      return this.length > p.length ? this.clone().ixor(p) : p.clone().ixor(this);\n    }, s.prototype.uxor = function(p) {\n      return this.length > p.length ? this.clone().iuxor(p) : p.clone().iuxor(this);\n    }, s.prototype.inotn = function(p) {\n      i(typeof p == \"number\" && p >= 0);\n      var l = Math.ceil(p / 26) | 0, a = p % 26;\n      this._expand(l), a > 0 && l--;\n      for (var c = 0; c < l; c++)\n        this.words[c] = ~this.words[c] & 67108863;\n      return a > 0 && (this.words[c] = ~this.words[c] & 67108863 >> 26 - a), this.strip();\n    }, s.prototype.notn = function(p) {\n      return this.clone().inotn(p);\n    }, s.prototype.setn = function(p, l) {\n      i(typeof p == \"number\" && p >= 0);\n      var a = p / 26 | 0, c = p % 26;\n      return this._expand(a + 1), l ? this.words[a] = this.words[a] | 1 << c : this.words[a] = this.words[a] & ~(1 << c), this.strip();\n    }, s.prototype.iadd = function(p) {\n      var l;\n      if (this.negative !== 0 && p.negative === 0)\n        return this.negative = 0, l = this.isub(p), this.negative ^= 1, this._normSign();\n      if (this.negative === 0 && p.negative !== 0)\n        return p.negative = 0, l = this.isub(p), p.negative = 1, l._normSign();\n      var a, c;\n      this.length > p.length ? (a = this, c = p) : (a = p, c = this);\n      for (var b = 0, E = 0; E < c.length; E++)\n        l = (a.words[E] | 0) + (c.words[E] | 0) + b, this.words[E] = l & 67108863, b = l >>> 26;\n      for (; b !== 0 && E < a.length; E++)\n        l = (a.words[E] | 0) + b, this.words[E] = l & 67108863, b = l >>> 26;\n      if (this.length = a.length, b !== 0)\n        this.words[this.length] = b, this.length++;\n      else if (a !== this)\n        for (; E < a.length; E++)\n          this.words[E] = a.words[E];\n      return this;\n    }, s.prototype.add = function(p) {\n      var l;\n      return p.negative !== 0 && this.negative === 0 ? (p.negative = 0, l = this.sub(p), p.negative ^= 1, l) : p.negative === 0 && this.negative !== 0 ? (this.negative = 0, l = p.sub(this), this.negative = 1, l) : this.length > p.length ? this.clone().iadd(p) : p.clone().iadd(this);\n    }, s.prototype.isub = function(p) {\n      if (p.negative !== 0) {\n        p.negative = 0;\n        var l = this.iadd(p);\n        return p.negative = 1, l._normSign();\n      } else if (this.negative !== 0)\n        return this.negative = 0, this.iadd(p), this.negative = 1, this._normSign();\n      var a = this.cmp(p);\n      if (a === 0)\n        return this.negative = 0, this.length = 1, this.words[0] = 0, this;\n      var c, b;\n      a > 0 ? (c = this, b = p) : (c = p, b = this);\n      for (var E = 0, S = 0; S < b.length; S++)\n        l = (c.words[S] | 0) - (b.words[S] | 0) + E, E = l >> 26, this.words[S] = l & 67108863;\n      for (; E !== 0 && S < c.length; S++)\n        l = (c.words[S] | 0) + E, E = l >> 26, this.words[S] = l & 67108863;\n      if (E === 0 && S < c.length && c !== this)\n        for (; S < c.length; S++)\n          this.words[S] = c.words[S];\n      return this.length = Math.max(this.length, S), c !== this && (this.negative = 1), this.strip();\n    }, s.prototype.sub = function(p) {\n      return this.clone().isub(p);\n    };\n    function D(O, p, l) {\n      l.negative = p.negative ^ O.negative;\n      var a = O.length + p.length | 0;\n      l.length = a, a = a - 1 | 0;\n      var c = O.words[0] | 0, b = p.words[0] | 0, E = c * b, S = E & 67108863, x = E / 67108864 | 0;\n      l.words[0] = S;\n      for (var u = 1; u < a; u++) {\n        for (var m = x >>> 26, g = x & 67108863, P = Math.min(u, p.length - 1), G = Math.max(0, u - O.length + 1); G <= P; G++) {\n          var M = u - G | 0;\n          c = O.words[M] | 0, b = p.words[G] | 0, E = c * b + g, m += E / 67108864 | 0, g = E & 67108863;\n        }\n        l.words[u] = g | 0, x = m | 0;\n      }\n      return x !== 0 ? l.words[u] = x | 0 : l.length--, l.strip();\n    }\n    var N = function(p, l, a) {\n      var c = p.words, b = l.words, E = a.words, S = 0, x, u, m, g = c[0] | 0, P = g & 8191, G = g >>> 13, M = c[1] | 0, H = M & 8191, C = M >>> 13, q = c[2] | 0, L = q & 8191, y = q >>> 13, F = c[3] | 0, W = F & 8191, Y = F >>> 13, X = c[4] | 0, ee = X & 8191, we = X >>> 13, Me = c[5] | 0, he = Me & 8191, Re = Me >>> 13, xe = c[6] | 0, se = xe & 8191, ge = xe >>> 13, le = c[7] | 0, ne = le & 8191, ue = le >>> 13, fe = c[8] | 0, te = fe & 8191, pe = fe >>> 13, _e = c[9] | 0, re = _e & 8191, Ee = _e >>> 13, Se = b[0] | 0, oe = Se & 8191, De = Se >>> 13, Ie = b[1] | 0, Pe = Ie & 8191, Ge = Ie >>> 13, Ye = b[2] | 0, Ae = Ye & 8191, Ze = Ye >>> 13, et = b[3] | 0, Ne = et & 8191, Ce = et >>> 13, Te = b[4] | 0, de = Te & 8191, $e = Te >>> 13, Le = b[5] | 0, ce = Le & 8191, Ue = Le >>> 13, ze = b[6] | 0, ye = ze & 8191, Be = ze >>> 13, ke = b[7] | 0, ve = ke & 8191, Fe = ke >>> 13, Oe = b[8] | 0, me = Oe & 8191, je = Oe >>> 13, rt = b[9] | 0, qe = rt & 8191, it = rt >>> 13;\n      a.negative = p.negative ^ l.negative, a.length = 19, x = Math.imul(P, oe), u = Math.imul(P, De), u = u + Math.imul(G, oe) | 0, m = Math.imul(G, De);\n      var Je = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, x = Math.imul(H, oe), u = Math.imul(H, De), u = u + Math.imul(C, oe) | 0, m = Math.imul(C, De), x = x + Math.imul(P, Pe) | 0, u = u + Math.imul(P, Ge) | 0, u = u + Math.imul(G, Pe) | 0, m = m + Math.imul(G, Ge) | 0;\n      var tt = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, x = Math.imul(L, oe), u = Math.imul(L, De), u = u + Math.imul(y, oe) | 0, m = Math.imul(y, De), x = x + Math.imul(H, Pe) | 0, u = u + Math.imul(H, Ge) | 0, u = u + Math.imul(C, Pe) | 0, m = m + Math.imul(C, Ge) | 0, x = x + Math.imul(P, Ae) | 0, u = u + Math.imul(P, Ze) | 0, u = u + Math.imul(G, Ae) | 0, m = m + Math.imul(G, Ze) | 0;\n      var jt = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, x = Math.imul(W, oe), u = Math.imul(W, De), u = u + Math.imul(Y, oe) | 0, m = Math.imul(Y, De), x = x + Math.imul(L, Pe) | 0, u = u + Math.imul(L, Ge) | 0, u = u + Math.imul(y, Pe) | 0, m = m + Math.imul(y, Ge) | 0, x = x + Math.imul(H, Ae) | 0, u = u + Math.imul(H, Ze) | 0, u = u + Math.imul(C, Ae) | 0, m = m + Math.imul(C, Ze) | 0, x = x + Math.imul(P, Ne) | 0, u = u + Math.imul(P, Ce) | 0, u = u + Math.imul(G, Ne) | 0, m = m + Math.imul(G, Ce) | 0;\n      var Kt = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, x = Math.imul(ee, oe), u = Math.imul(ee, De), u = u + Math.imul(we, oe) | 0, m = Math.imul(we, De), x = x + Math.imul(W, Pe) | 0, u = u + Math.imul(W, Ge) | 0, u = u + Math.imul(Y, Pe) | 0, m = m + Math.imul(Y, Ge) | 0, x = x + Math.imul(L, Ae) | 0, u = u + Math.imul(L, Ze) | 0, u = u + Math.imul(y, Ae) | 0, m = m + Math.imul(y, Ze) | 0, x = x + Math.imul(H, Ne) | 0, u = u + Math.imul(H, Ce) | 0, u = u + Math.imul(C, Ne) | 0, m = m + Math.imul(C, Ce) | 0, x = x + Math.imul(P, de) | 0, u = u + Math.imul(P, $e) | 0, u = u + Math.imul(G, de) | 0, m = m + Math.imul(G, $e) | 0;\n      var Ht = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, x = Math.imul(he, oe), u = Math.imul(he, De), u = u + Math.imul(Re, oe) | 0, m = Math.imul(Re, De), x = x + Math.imul(ee, Pe) | 0, u = u + Math.imul(ee, Ge) | 0, u = u + Math.imul(we, Pe) | 0, m = m + Math.imul(we, Ge) | 0, x = x + Math.imul(W, Ae) | 0, u = u + Math.imul(W, Ze) | 0, u = u + Math.imul(Y, Ae) | 0, m = m + Math.imul(Y, Ze) | 0, x = x + Math.imul(L, Ne) | 0, u = u + Math.imul(L, Ce) | 0, u = u + Math.imul(y, Ne) | 0, m = m + Math.imul(y, Ce) | 0, x = x + Math.imul(H, de) | 0, u = u + Math.imul(H, $e) | 0, u = u + Math.imul(C, de) | 0, m = m + Math.imul(C, $e) | 0, x = x + Math.imul(P, ce) | 0, u = u + Math.imul(P, Ue) | 0, u = u + Math.imul(G, ce) | 0, m = m + Math.imul(G, Ue) | 0;\n      var Vt = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (Vt >>> 26) | 0, Vt &= 67108863, x = Math.imul(se, oe), u = Math.imul(se, De), u = u + Math.imul(ge, oe) | 0, m = Math.imul(ge, De), x = x + Math.imul(he, Pe) | 0, u = u + Math.imul(he, Ge) | 0, u = u + Math.imul(Re, Pe) | 0, m = m + Math.imul(Re, Ge) | 0, x = x + Math.imul(ee, Ae) | 0, u = u + Math.imul(ee, Ze) | 0, u = u + Math.imul(we, Ae) | 0, m = m + Math.imul(we, Ze) | 0, x = x + Math.imul(W, Ne) | 0, u = u + Math.imul(W, Ce) | 0, u = u + Math.imul(Y, Ne) | 0, m = m + Math.imul(Y, Ce) | 0, x = x + Math.imul(L, de) | 0, u = u + Math.imul(L, $e) | 0, u = u + Math.imul(y, de) | 0, m = m + Math.imul(y, $e) | 0, x = x + Math.imul(H, ce) | 0, u = u + Math.imul(H, Ue) | 0, u = u + Math.imul(C, ce) | 0, m = m + Math.imul(C, Ue) | 0, x = x + Math.imul(P, ye) | 0, u = u + Math.imul(P, Be) | 0, u = u + Math.imul(G, ye) | 0, m = m + Math.imul(G, Be) | 0;\n      var gt = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, x = Math.imul(ne, oe), u = Math.imul(ne, De), u = u + Math.imul(ue, oe) | 0, m = Math.imul(ue, De), x = x + Math.imul(se, Pe) | 0, u = u + Math.imul(se, Ge) | 0, u = u + Math.imul(ge, Pe) | 0, m = m + Math.imul(ge, Ge) | 0, x = x + Math.imul(he, Ae) | 0, u = u + Math.imul(he, Ze) | 0, u = u + Math.imul(Re, Ae) | 0, m = m + Math.imul(Re, Ze) | 0, x = x + Math.imul(ee, Ne) | 0, u = u + Math.imul(ee, Ce) | 0, u = u + Math.imul(we, Ne) | 0, m = m + Math.imul(we, Ce) | 0, x = x + Math.imul(W, de) | 0, u = u + Math.imul(W, $e) | 0, u = u + Math.imul(Y, de) | 0, m = m + Math.imul(Y, $e) | 0, x = x + Math.imul(L, ce) | 0, u = u + Math.imul(L, Ue) | 0, u = u + Math.imul(y, ce) | 0, m = m + Math.imul(y, Ue) | 0, x = x + Math.imul(H, ye) | 0, u = u + Math.imul(H, Be) | 0, u = u + Math.imul(C, ye) | 0, m = m + Math.imul(C, Be) | 0, x = x + Math.imul(P, ve) | 0, u = u + Math.imul(P, Fe) | 0, u = u + Math.imul(G, ve) | 0, m = m + Math.imul(G, Fe) | 0;\n      var Vr = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, x = Math.imul(te, oe), u = Math.imul(te, De), u = u + Math.imul(pe, oe) | 0, m = Math.imul(pe, De), x = x + Math.imul(ne, Pe) | 0, u = u + Math.imul(ne, Ge) | 0, u = u + Math.imul(ue, Pe) | 0, m = m + Math.imul(ue, Ge) | 0, x = x + Math.imul(se, Ae) | 0, u = u + Math.imul(se, Ze) | 0, u = u + Math.imul(ge, Ae) | 0, m = m + Math.imul(ge, Ze) | 0, x = x + Math.imul(he, Ne) | 0, u = u + Math.imul(he, Ce) | 0, u = u + Math.imul(Re, Ne) | 0, m = m + Math.imul(Re, Ce) | 0, x = x + Math.imul(ee, de) | 0, u = u + Math.imul(ee, $e) | 0, u = u + Math.imul(we, de) | 0, m = m + Math.imul(we, $e) | 0, x = x + Math.imul(W, ce) | 0, u = u + Math.imul(W, Ue) | 0, u = u + Math.imul(Y, ce) | 0, m = m + Math.imul(Y, Ue) | 0, x = x + Math.imul(L, ye) | 0, u = u + Math.imul(L, Be) | 0, u = u + Math.imul(y, ye) | 0, m = m + Math.imul(y, Be) | 0, x = x + Math.imul(H, ve) | 0, u = u + Math.imul(H, Fe) | 0, u = u + Math.imul(C, ve) | 0, m = m + Math.imul(C, Fe) | 0, x = x + Math.imul(P, me) | 0, u = u + Math.imul(P, je) | 0, u = u + Math.imul(G, me) | 0, m = m + Math.imul(G, je) | 0;\n      var Wr = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, x = Math.imul(re, oe), u = Math.imul(re, De), u = u + Math.imul(Ee, oe) | 0, m = Math.imul(Ee, De), x = x + Math.imul(te, Pe) | 0, u = u + Math.imul(te, Ge) | 0, u = u + Math.imul(pe, Pe) | 0, m = m + Math.imul(pe, Ge) | 0, x = x + Math.imul(ne, Ae) | 0, u = u + Math.imul(ne, Ze) | 0, u = u + Math.imul(ue, Ae) | 0, m = m + Math.imul(ue, Ze) | 0, x = x + Math.imul(se, Ne) | 0, u = u + Math.imul(se, Ce) | 0, u = u + Math.imul(ge, Ne) | 0, m = m + Math.imul(ge, Ce) | 0, x = x + Math.imul(he, de) | 0, u = u + Math.imul(he, $e) | 0, u = u + Math.imul(Re, de) | 0, m = m + Math.imul(Re, $e) | 0, x = x + Math.imul(ee, ce) | 0, u = u + Math.imul(ee, Ue) | 0, u = u + Math.imul(we, ce) | 0, m = m + Math.imul(we, Ue) | 0, x = x + Math.imul(W, ye) | 0, u = u + Math.imul(W, Be) | 0, u = u + Math.imul(Y, ye) | 0, m = m + Math.imul(Y, Be) | 0, x = x + Math.imul(L, ve) | 0, u = u + Math.imul(L, Fe) | 0, u = u + Math.imul(y, ve) | 0, m = m + Math.imul(y, Fe) | 0, x = x + Math.imul(H, me) | 0, u = u + Math.imul(H, je) | 0, u = u + Math.imul(C, me) | 0, m = m + Math.imul(C, je) | 0, x = x + Math.imul(P, qe) | 0, u = u + Math.imul(P, it) | 0, u = u + Math.imul(G, qe) | 0, m = m + Math.imul(G, it) | 0;\n      var Gr = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, x = Math.imul(re, Pe), u = Math.imul(re, Ge), u = u + Math.imul(Ee, Pe) | 0, m = Math.imul(Ee, Ge), x = x + Math.imul(te, Ae) | 0, u = u + Math.imul(te, Ze) | 0, u = u + Math.imul(pe, Ae) | 0, m = m + Math.imul(pe, Ze) | 0, x = x + Math.imul(ne, Ne) | 0, u = u + Math.imul(ne, Ce) | 0, u = u + Math.imul(ue, Ne) | 0, m = m + Math.imul(ue, Ce) | 0, x = x + Math.imul(se, de) | 0, u = u + Math.imul(se, $e) | 0, u = u + Math.imul(ge, de) | 0, m = m + Math.imul(ge, $e) | 0, x = x + Math.imul(he, ce) | 0, u = u + Math.imul(he, Ue) | 0, u = u + Math.imul(Re, ce) | 0, m = m + Math.imul(Re, Ue) | 0, x = x + Math.imul(ee, ye) | 0, u = u + Math.imul(ee, Be) | 0, u = u + Math.imul(we, ye) | 0, m = m + Math.imul(we, Be) | 0, x = x + Math.imul(W, ve) | 0, u = u + Math.imul(W, Fe) | 0, u = u + Math.imul(Y, ve) | 0, m = m + Math.imul(Y, Fe) | 0, x = x + Math.imul(L, me) | 0, u = u + Math.imul(L, je) | 0, u = u + Math.imul(y, me) | 0, m = m + Math.imul(y, je) | 0, x = x + Math.imul(H, qe) | 0, u = u + Math.imul(H, it) | 0, u = u + Math.imul(C, qe) | 0, m = m + Math.imul(C, it) | 0;\n      var Jr = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, x = Math.imul(re, Ae), u = Math.imul(re, Ze), u = u + Math.imul(Ee, Ae) | 0, m = Math.imul(Ee, Ze), x = x + Math.imul(te, Ne) | 0, u = u + Math.imul(te, Ce) | 0, u = u + Math.imul(pe, Ne) | 0, m = m + Math.imul(pe, Ce) | 0, x = x + Math.imul(ne, de) | 0, u = u + Math.imul(ne, $e) | 0, u = u + Math.imul(ue, de) | 0, m = m + Math.imul(ue, $e) | 0, x = x + Math.imul(se, ce) | 0, u = u + Math.imul(se, Ue) | 0, u = u + Math.imul(ge, ce) | 0, m = m + Math.imul(ge, Ue) | 0, x = x + Math.imul(he, ye) | 0, u = u + Math.imul(he, Be) | 0, u = u + Math.imul(Re, ye) | 0, m = m + Math.imul(Re, Be) | 0, x = x + Math.imul(ee, ve) | 0, u = u + Math.imul(ee, Fe) | 0, u = u + Math.imul(we, ve) | 0, m = m + Math.imul(we, Fe) | 0, x = x + Math.imul(W, me) | 0, u = u + Math.imul(W, je) | 0, u = u + Math.imul(Y, me) | 0, m = m + Math.imul(Y, je) | 0, x = x + Math.imul(L, qe) | 0, u = u + Math.imul(L, it) | 0, u = u + Math.imul(y, qe) | 0, m = m + Math.imul(y, it) | 0;\n      var Yr = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, x = Math.imul(re, Ne), u = Math.imul(re, Ce), u = u + Math.imul(Ee, Ne) | 0, m = Math.imul(Ee, Ce), x = x + Math.imul(te, de) | 0, u = u + Math.imul(te, $e) | 0, u = u + Math.imul(pe, de) | 0, m = m + Math.imul(pe, $e) | 0, x = x + Math.imul(ne, ce) | 0, u = u + Math.imul(ne, Ue) | 0, u = u + Math.imul(ue, ce) | 0, m = m + Math.imul(ue, Ue) | 0, x = x + Math.imul(se, ye) | 0, u = u + Math.imul(se, Be) | 0, u = u + Math.imul(ge, ye) | 0, m = m + Math.imul(ge, Be) | 0, x = x + Math.imul(he, ve) | 0, u = u + Math.imul(he, Fe) | 0, u = u + Math.imul(Re, ve) | 0, m = m + Math.imul(Re, Fe) | 0, x = x + Math.imul(ee, me) | 0, u = u + Math.imul(ee, je) | 0, u = u + Math.imul(we, me) | 0, m = m + Math.imul(we, je) | 0, x = x + Math.imul(W, qe) | 0, u = u + Math.imul(W, it) | 0, u = u + Math.imul(Y, qe) | 0, m = m + Math.imul(Y, it) | 0;\n      var or = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, x = Math.imul(re, de), u = Math.imul(re, $e), u = u + Math.imul(Ee, de) | 0, m = Math.imul(Ee, $e), x = x + Math.imul(te, ce) | 0, u = u + Math.imul(te, Ue) | 0, u = u + Math.imul(pe, ce) | 0, m = m + Math.imul(pe, Ue) | 0, x = x + Math.imul(ne, ye) | 0, u = u + Math.imul(ne, Be) | 0, u = u + Math.imul(ue, ye) | 0, m = m + Math.imul(ue, Be) | 0, x = x + Math.imul(se, ve) | 0, u = u + Math.imul(se, Fe) | 0, u = u + Math.imul(ge, ve) | 0, m = m + Math.imul(ge, Fe) | 0, x = x + Math.imul(he, me) | 0, u = u + Math.imul(he, je) | 0, u = u + Math.imul(Re, me) | 0, m = m + Math.imul(Re, je) | 0, x = x + Math.imul(ee, qe) | 0, u = u + Math.imul(ee, it) | 0, u = u + Math.imul(we, qe) | 0, m = m + Math.imul(we, it) | 0;\n      var Xr = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, x = Math.imul(re, ce), u = Math.imul(re, Ue), u = u + Math.imul(Ee, ce) | 0, m = Math.imul(Ee, Ue), x = x + Math.imul(te, ye) | 0, u = u + Math.imul(te, Be) | 0, u = u + Math.imul(pe, ye) | 0, m = m + Math.imul(pe, Be) | 0, x = x + Math.imul(ne, ve) | 0, u = u + Math.imul(ne, Fe) | 0, u = u + Math.imul(ue, ve) | 0, m = m + Math.imul(ue, Fe) | 0, x = x + Math.imul(se, me) | 0, u = u + Math.imul(se, je) | 0, u = u + Math.imul(ge, me) | 0, m = m + Math.imul(ge, je) | 0, x = x + Math.imul(he, qe) | 0, u = u + Math.imul(he, it) | 0, u = u + Math.imul(Re, qe) | 0, m = m + Math.imul(Re, it) | 0;\n      var Zr = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, x = Math.imul(re, ye), u = Math.imul(re, Be), u = u + Math.imul(Ee, ye) | 0, m = Math.imul(Ee, Be), x = x + Math.imul(te, ve) | 0, u = u + Math.imul(te, Fe) | 0, u = u + Math.imul(pe, ve) | 0, m = m + Math.imul(pe, Fe) | 0, x = x + Math.imul(ne, me) | 0, u = u + Math.imul(ne, je) | 0, u = u + Math.imul(ue, me) | 0, m = m + Math.imul(ue, je) | 0, x = x + Math.imul(se, qe) | 0, u = u + Math.imul(se, it) | 0, u = u + Math.imul(ge, qe) | 0, m = m + Math.imul(ge, it) | 0;\n      var $t = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, x = Math.imul(re, ve), u = Math.imul(re, Fe), u = u + Math.imul(Ee, ve) | 0, m = Math.imul(Ee, Fe), x = x + Math.imul(te, me) | 0, u = u + Math.imul(te, je) | 0, u = u + Math.imul(pe, me) | 0, m = m + Math.imul(pe, je) | 0, x = x + Math.imul(ne, qe) | 0, u = u + Math.imul(ne, it) | 0, u = u + Math.imul(ue, qe) | 0, m = m + Math.imul(ue, it) | 0;\n      var Qr = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, x = Math.imul(re, me), u = Math.imul(re, je), u = u + Math.imul(Ee, me) | 0, m = Math.imul(Ee, je), x = x + Math.imul(te, qe) | 0, u = u + Math.imul(te, it) | 0, u = u + Math.imul(pe, qe) | 0, m = m + Math.imul(pe, it) | 0;\n      var ei = (S + x | 0) + ((u & 8191) << 13) | 0;\n      S = (m + (u >>> 13) | 0) + (ei >>> 26) | 0, ei &= 67108863, x = Math.imul(re, qe), u = Math.imul(re, it), u = u + Math.imul(Ee, qe) | 0, m = Math.imul(Ee, it);\n      var ti = (S + x | 0) + ((u & 8191) << 13) | 0;\n      return S = (m + (u >>> 13) | 0) + (ti >>> 26) | 0, ti &= 67108863, E[0] = Je, E[1] = tt, E[2] = jt, E[3] = Kt, E[4] = Ht, E[5] = Vt, E[6] = gt, E[7] = Vr, E[8] = Wr, E[9] = Gr, E[10] = Jr, E[11] = Yr, E[12] = or, E[13] = Xr, E[14] = Zr, E[15] = $t, E[16] = Qr, E[17] = ei, E[18] = ti, S !== 0 && (E[19] = S, a.length++), a;\n    };\n    Math.imul || (N = D);\n    function k(O, p, l) {\n      l.negative = p.negative ^ O.negative, l.length = O.length + p.length;\n      for (var a = 0, c = 0, b = 0; b < l.length - 1; b++) {\n        var E = c;\n        c = 0;\n        for (var S = a & 67108863, x = Math.min(b, p.length - 1), u = Math.max(0, b - O.length + 1); u <= x; u++) {\n          var m = b - u, g = O.words[m] | 0, P = p.words[u] | 0, G = g * P, M = G & 67108863;\n          E = E + (G / 67108864 | 0) | 0, M = M + S | 0, S = M & 67108863, E = E + (M >>> 26) | 0, c += E >>> 26, E &= 67108863;\n        }\n        l.words[b] = S, a = E, E = c;\n      }\n      return a !== 0 ? l.words[b] = a : l.length--, l.strip();\n    }\n    function j(O, p, l) {\n      var a = new T();\n      return a.mulp(O, p, l);\n    }\n    s.prototype.mulTo = function(p, l) {\n      var a, c = this.length + p.length;\n      return this.length === 10 && p.length === 10 ? a = N(this, p, l) : c < 63 ? a = D(this, p, l) : c < 1024 ? a = k(this, p, l) : a = j(this, p, l), a;\n    };\n    function T(O, p) {\n      this.x = O, this.y = p;\n    }\n    T.prototype.makeRBT = function(p) {\n      for (var l = new Array(p), a = s.prototype._countBits(p) - 1, c = 0; c < p; c++)\n        l[c] = this.revBin(c, a, p);\n      return l;\n    }, T.prototype.revBin = function(p, l, a) {\n      if (p === 0 || p === a - 1)\n        return p;\n      for (var c = 0, b = 0; b < l; b++)\n        c |= (p & 1) << l - b - 1, p >>= 1;\n      return c;\n    }, T.prototype.permute = function(p, l, a, c, b, E) {\n      for (var S = 0; S < E; S++)\n        c[S] = l[p[S]], b[S] = a[p[S]];\n    }, T.prototype.transform = function(p, l, a, c, b, E) {\n      this.permute(E, p, l, a, c, b);\n      for (var S = 1; S < b; S <<= 1)\n        for (var x = S << 1, u = Math.cos(2 * Math.PI / x), m = Math.sin(2 * Math.PI / x), g = 0; g < b; g += x)\n          for (var P = u, G = m, M = 0; M < S; M++) {\n            var H = a[g + M], C = c[g + M], q = a[g + M + S], L = c[g + M + S], y = P * q - G * L;\n            L = P * L + G * q, q = y, a[g + M] = H + q, c[g + M] = C + L, a[g + M + S] = H - q, c[g + M + S] = C - L, M !== x && (y = u * P - m * G, G = u * G + m * P, P = y);\n          }\n    }, T.prototype.guessLen13b = function(p, l) {\n      var a = Math.max(l, p) | 1, c = a & 1, b = 0;\n      for (a = a / 2 | 0; a; a = a >>> 1)\n        b++;\n      return 1 << b + 1 + c;\n    }, T.prototype.conjugate = function(p, l, a) {\n      if (!(a <= 1))\n        for (var c = 0; c < a / 2; c++) {\n          var b = p[c];\n          p[c] = p[a - c - 1], p[a - c - 1] = b, b = l[c], l[c] = -l[a - c - 1], l[a - c - 1] = -b;\n        }\n    }, T.prototype.normalize13b = function(p, l) {\n      for (var a = 0, c = 0; c < l / 2; c++) {\n        var b = Math.round(p[2 * c + 1] / l) * 8192 + Math.round(p[2 * c] / l) + a;\n        p[c] = b & 67108863, b < 67108864 ? a = 0 : a = b / 67108864 | 0;\n      }\n      return p;\n    }, T.prototype.convert13b = function(p, l, a, c) {\n      for (var b = 0, E = 0; E < l; E++)\n        b = b + (p[E] | 0), a[2 * E] = b & 8191, b = b >>> 13, a[2 * E + 1] = b & 8191, b = b >>> 13;\n      for (E = 2 * l; E < c; ++E)\n        a[E] = 0;\n      i(b === 0), i((b & -8192) === 0);\n    }, T.prototype.stub = function(p) {\n      for (var l = new Array(p), a = 0; a < p; a++)\n        l[a] = 0;\n      return l;\n    }, T.prototype.mulp = function(p, l, a) {\n      var c = 2 * this.guessLen13b(p.length, l.length), b = this.makeRBT(c), E = this.stub(c), S = new Array(c), x = new Array(c), u = new Array(c), m = new Array(c), g = new Array(c), P = new Array(c), G = a.words;\n      G.length = c, this.convert13b(p.words, p.length, S, c), this.convert13b(l.words, l.length, m, c), this.transform(S, E, x, u, c, b), this.transform(m, E, g, P, c, b);\n      for (var M = 0; M < c; M++) {\n        var H = x[M] * g[M] - u[M] * P[M];\n        u[M] = x[M] * P[M] + u[M] * g[M], x[M] = H;\n      }\n      return this.conjugate(x, u, c), this.transform(x, u, G, E, c, b), this.conjugate(G, E, c), this.normalize13b(G, c), a.negative = p.negative ^ l.negative, a.length = p.length + l.length, a.strip();\n    }, s.prototype.mul = function(p) {\n      var l = new s(null);\n      return l.words = new Array(this.length + p.length), this.mulTo(p, l);\n    }, s.prototype.mulf = function(p) {\n      var l = new s(null);\n      return l.words = new Array(this.length + p.length), j(this, p, l);\n    }, s.prototype.imul = function(p) {\n      return this.clone().mulTo(p, this);\n    }, s.prototype.imuln = function(p) {\n      i(typeof p == \"number\"), i(p < 67108864);\n      for (var l = 0, a = 0; a < this.length; a++) {\n        var c = (this.words[a] | 0) * p, b = (c & 67108863) + (l & 67108863);\n        l >>= 26, l += c / 67108864 | 0, l += b >>> 26, this.words[a] = b & 67108863;\n      }\n      return l !== 0 && (this.words[a] = l, this.length++), this;\n    }, s.prototype.muln = function(p) {\n      return this.clone().imuln(p);\n    }, s.prototype.sqr = function() {\n      return this.mul(this);\n    }, s.prototype.isqr = function() {\n      return this.imul(this.clone());\n    }, s.prototype.pow = function(p) {\n      var l = I(p);\n      if (l.length === 0)\n        return new s(1);\n      for (var a = this, c = 0; c < l.length && l[c] === 0; c++, a = a.sqr())\n        ;\n      if (++c < l.length)\n        for (var b = a.sqr(); c < l.length; c++, b = b.sqr())\n          l[c] !== 0 && (a = a.mul(b));\n      return a;\n    }, s.prototype.iushln = function(p) {\n      i(typeof p == \"number\" && p >= 0);\n      var l = p % 26, a = (p - l) / 26, c = 67108863 >>> 26 - l << 26 - l, b;\n      if (l !== 0) {\n        var E = 0;\n        for (b = 0; b < this.length; b++) {\n          var S = this.words[b] & c, x = (this.words[b] | 0) - S << l;\n          this.words[b] = x | E, E = S >>> 26 - l;\n        }\n        E && (this.words[b] = E, this.length++);\n      }\n      if (a !== 0) {\n        for (b = this.length - 1; b >= 0; b--)\n          this.words[b + a] = this.words[b];\n        for (b = 0; b < a; b++)\n          this.words[b] = 0;\n        this.length += a;\n      }\n      return this.strip();\n    }, s.prototype.ishln = function(p) {\n      return i(this.negative === 0), this.iushln(p);\n    }, s.prototype.iushrn = function(p, l, a) {\n      i(typeof p == \"number\" && p >= 0);\n      var c;\n      l ? c = (l - l % 26) / 26 : c = 0;\n      var b = p % 26, E = Math.min((p - b) / 26, this.length), S = 67108863 ^ 67108863 >>> b << b, x = a;\n      if (c -= E, c = Math.max(0, c), x) {\n        for (var u = 0; u < E; u++)\n          x.words[u] = this.words[u];\n        x.length = E;\n      }\n      if (E !== 0)\n        if (this.length > E)\n          for (this.length -= E, u = 0; u < this.length; u++)\n            this.words[u] = this.words[u + E];\n        else\n          this.words[0] = 0, this.length = 1;\n      var m = 0;\n      for (u = this.length - 1; u >= 0 && (m !== 0 || u >= c); u--) {\n        var g = this.words[u] | 0;\n        this.words[u] = m << 26 - b | g >>> b, m = g & S;\n      }\n      return x && m !== 0 && (x.words[x.length++] = m), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();\n    }, s.prototype.ishrn = function(p, l, a) {\n      return i(this.negative === 0), this.iushrn(p, l, a);\n    }, s.prototype.shln = function(p) {\n      return this.clone().ishln(p);\n    }, s.prototype.ushln = function(p) {\n      return this.clone().iushln(p);\n    }, s.prototype.shrn = function(p) {\n      return this.clone().ishrn(p);\n    }, s.prototype.ushrn = function(p) {\n      return this.clone().iushrn(p);\n    }, s.prototype.testn = function(p) {\n      i(typeof p == \"number\" && p >= 0);\n      var l = p % 26, a = (p - l) / 26, c = 1 << l;\n      if (this.length <= a)\n        return !1;\n      var b = this.words[a];\n      return !!(b & c);\n    }, s.prototype.imaskn = function(p) {\n      i(typeof p == \"number\" && p >= 0);\n      var l = p % 26, a = (p - l) / 26;\n      if (i(this.negative === 0, \"imaskn works only with positive numbers\"), this.length <= a)\n        return this;\n      if (l !== 0 && a++, this.length = Math.min(a, this.length), l !== 0) {\n        var c = 67108863 ^ 67108863 >>> l << l;\n        this.words[this.length - 1] &= c;\n      }\n      return this.strip();\n    }, s.prototype.maskn = function(p) {\n      return this.clone().imaskn(p);\n    }, s.prototype.iaddn = function(p) {\n      return i(typeof p == \"number\"), i(p < 67108864), p < 0 ? this.isubn(-p) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < p ? (this.words[0] = p - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(p), this.negative = 1, this) : this._iaddn(p);\n    }, s.prototype._iaddn = function(p) {\n      this.words[0] += p;\n      for (var l = 0; l < this.length && this.words[l] >= 67108864; l++)\n        this.words[l] -= 67108864, l === this.length - 1 ? this.words[l + 1] = 1 : this.words[l + 1]++;\n      return this.length = Math.max(this.length, l + 1), this;\n    }, s.prototype.isubn = function(p) {\n      if (i(typeof p == \"number\"), i(p < 67108864), p < 0)\n        return this.iaddn(-p);\n      if (this.negative !== 0)\n        return this.negative = 0, this.iaddn(p), this.negative = 1, this;\n      if (this.words[0] -= p, this.length === 1 && this.words[0] < 0)\n        this.words[0] = -this.words[0], this.negative = 1;\n      else\n        for (var l = 0; l < this.length && this.words[l] < 0; l++)\n          this.words[l] += 67108864, this.words[l + 1] -= 1;\n      return this.strip();\n    }, s.prototype.addn = function(p) {\n      return this.clone().iaddn(p);\n    }, s.prototype.subn = function(p) {\n      return this.clone().isubn(p);\n    }, s.prototype.iabs = function() {\n      return this.negative = 0, this;\n    }, s.prototype.abs = function() {\n      return this.clone().iabs();\n    }, s.prototype._ishlnsubmul = function(p, l, a) {\n      var c = p.length + a, b;\n      this._expand(c);\n      var E, S = 0;\n      for (b = 0; b < p.length; b++) {\n        E = (this.words[b + a] | 0) + S;\n        var x = (p.words[b] | 0) * l;\n        E -= x & 67108863, S = (E >> 26) - (x / 67108864 | 0), this.words[b + a] = E & 67108863;\n      }\n      for (; b < this.length - a; b++)\n        E = (this.words[b + a] | 0) + S, S = E >> 26, this.words[b + a] = E & 67108863;\n      if (S === 0)\n        return this.strip();\n      for (i(S === -1), S = 0, b = 0; b < this.length; b++)\n        E = -(this.words[b] | 0) + S, S = E >> 26, this.words[b] = E & 67108863;\n      return this.negative = 1, this.strip();\n    }, s.prototype._wordDiv = function(p, l) {\n      var a = this.length - p.length, c = this.clone(), b = p, E = b.words[b.length - 1] | 0, S = this._countBits(E);\n      a = 26 - S, a !== 0 && (b = b.ushln(a), c.iushln(a), E = b.words[b.length - 1] | 0);\n      var x = c.length - b.length, u;\n      if (l !== \"mod\") {\n        u = new s(null), u.length = x + 1, u.words = new Array(u.length);\n        for (var m = 0; m < u.length; m++)\n          u.words[m] = 0;\n      }\n      var g = c.clone()._ishlnsubmul(b, 1, x);\n      g.negative === 0 && (c = g, u && (u.words[x] = 1));\n      for (var P = x - 1; P >= 0; P--) {\n        var G = (c.words[b.length + P] | 0) * 67108864 + (c.words[b.length + P - 1] | 0);\n        for (G = Math.min(G / E | 0, 67108863), c._ishlnsubmul(b, G, P); c.negative !== 0; )\n          G--, c.negative = 0, c._ishlnsubmul(b, 1, P), c.isZero() || (c.negative ^= 1);\n        u && (u.words[P] = G);\n      }\n      return u && u.strip(), c.strip(), l !== \"div\" && a !== 0 && c.iushrn(a), {\n        div: u || null,\n        mod: c\n      };\n    }, s.prototype.divmod = function(p, l, a) {\n      if (i(!p.isZero()), this.isZero())\n        return {\n          div: new s(0),\n          mod: new s(0)\n        };\n      var c, b, E;\n      return this.negative !== 0 && p.negative === 0 ? (E = this.neg().divmod(p, l), l !== \"mod\" && (c = E.div.neg()), l !== \"div\" && (b = E.mod.neg(), a && b.negative !== 0 && b.iadd(p)), {\n        div: c,\n        mod: b\n      }) : this.negative === 0 && p.negative !== 0 ? (E = this.divmod(p.neg(), l), l !== \"mod\" && (c = E.div.neg()), {\n        div: c,\n        mod: E.mod\n      }) : this.negative & p.negative ? (E = this.neg().divmod(p.neg(), l), l !== \"div\" && (b = E.mod.neg(), a && b.negative !== 0 && b.isub(p)), {\n        div: E.div,\n        mod: b\n      }) : p.length > this.length || this.cmp(p) < 0 ? {\n        div: new s(0),\n        mod: this\n      } : p.length === 1 ? l === \"div\" ? {\n        div: this.divn(p.words[0]),\n        mod: null\n      } : l === \"mod\" ? {\n        div: null,\n        mod: new s(this.modn(p.words[0]))\n      } : {\n        div: this.divn(p.words[0]),\n        mod: new s(this.modn(p.words[0]))\n      } : this._wordDiv(p, l);\n    }, s.prototype.div = function(p) {\n      return this.divmod(p, \"div\", !1).div;\n    }, s.prototype.mod = function(p) {\n      return this.divmod(p, \"mod\", !1).mod;\n    }, s.prototype.umod = function(p) {\n      return this.divmod(p, \"mod\", !0).mod;\n    }, s.prototype.divRound = function(p) {\n      var l = this.divmod(p);\n      if (l.mod.isZero())\n        return l.div;\n      var a = l.div.negative !== 0 ? l.mod.isub(p) : l.mod, c = p.ushrn(1), b = p.andln(1), E = a.cmp(c);\n      return E < 0 || b === 1 && E === 0 ? l.div : l.div.negative !== 0 ? l.div.isubn(1) : l.div.iaddn(1);\n    }, s.prototype.modn = function(p) {\n      i(p <= 67108863);\n      for (var l = (1 << 26) % p, a = 0, c = this.length - 1; c >= 0; c--)\n        a = (l * a + (this.words[c] | 0)) % p;\n      return a;\n    }, s.prototype.idivn = function(p) {\n      i(p <= 67108863);\n      for (var l = 0, a = this.length - 1; a >= 0; a--) {\n        var c = (this.words[a] | 0) + l * 67108864;\n        this.words[a] = c / p | 0, l = c % p;\n      }\n      return this.strip();\n    }, s.prototype.divn = function(p) {\n      return this.clone().idivn(p);\n    }, s.prototype.egcd = function(p) {\n      i(p.negative === 0), i(!p.isZero());\n      var l = this, a = p.clone();\n      l.negative !== 0 ? l = l.umod(p) : l = l.clone();\n      for (var c = new s(1), b = new s(0), E = new s(0), S = new s(1), x = 0; l.isEven() && a.isEven(); )\n        l.iushrn(1), a.iushrn(1), ++x;\n      for (var u = a.clone(), m = l.clone(); !l.isZero(); ) {\n        for (var g = 0, P = 1; !(l.words[0] & P) && g < 26; ++g, P <<= 1)\n          ;\n        if (g > 0)\n          for (l.iushrn(g); g-- > 0; )\n            (c.isOdd() || b.isOdd()) && (c.iadd(u), b.isub(m)), c.iushrn(1), b.iushrn(1);\n        for (var G = 0, M = 1; !(a.words[0] & M) && G < 26; ++G, M <<= 1)\n          ;\n        if (G > 0)\n          for (a.iushrn(G); G-- > 0; )\n            (E.isOdd() || S.isOdd()) && (E.iadd(u), S.isub(m)), E.iushrn(1), S.iushrn(1);\n        l.cmp(a) >= 0 ? (l.isub(a), c.isub(E), b.isub(S)) : (a.isub(l), E.isub(c), S.isub(b));\n      }\n      return {\n        a: E,\n        b: S,\n        gcd: a.iushln(x)\n      };\n    }, s.prototype._invmp = function(p) {\n      i(p.negative === 0), i(!p.isZero());\n      var l = this, a = p.clone();\n      l.negative !== 0 ? l = l.umod(p) : l = l.clone();\n      for (var c = new s(1), b = new s(0), E = a.clone(); l.cmpn(1) > 0 && a.cmpn(1) > 0; ) {\n        for (var S = 0, x = 1; !(l.words[0] & x) && S < 26; ++S, x <<= 1)\n          ;\n        if (S > 0)\n          for (l.iushrn(S); S-- > 0; )\n            c.isOdd() && c.iadd(E), c.iushrn(1);\n        for (var u = 0, m = 1; !(a.words[0] & m) && u < 26; ++u, m <<= 1)\n          ;\n        if (u > 0)\n          for (a.iushrn(u); u-- > 0; )\n            b.isOdd() && b.iadd(E), b.iushrn(1);\n        l.cmp(a) >= 0 ? (l.isub(a), c.isub(b)) : (a.isub(l), b.isub(c));\n      }\n      var g;\n      return l.cmpn(1) === 0 ? g = c : g = b, g.cmpn(0) < 0 && g.iadd(p), g;\n    }, s.prototype.gcd = function(p) {\n      if (this.isZero())\n        return p.abs();\n      if (p.isZero())\n        return this.abs();\n      var l = this.clone(), a = p.clone();\n      l.negative = 0, a.negative = 0;\n      for (var c = 0; l.isEven() && a.isEven(); c++)\n        l.iushrn(1), a.iushrn(1);\n      do {\n        for (; l.isEven(); )\n          l.iushrn(1);\n        for (; a.isEven(); )\n          a.iushrn(1);\n        var b = l.cmp(a);\n        if (b < 0) {\n          var E = l;\n          l = a, a = E;\n        } else if (b === 0 || a.cmpn(1) === 0)\n          break;\n        l.isub(a);\n      } while (!0);\n      return a.iushln(c);\n    }, s.prototype.invm = function(p) {\n      return this.egcd(p).a.umod(p);\n    }, s.prototype.isEven = function() {\n      return (this.words[0] & 1) === 0;\n    }, s.prototype.isOdd = function() {\n      return (this.words[0] & 1) === 1;\n    }, s.prototype.andln = function(p) {\n      return this.words[0] & p;\n    }, s.prototype.bincn = function(p) {\n      i(typeof p == \"number\");\n      var l = p % 26, a = (p - l) / 26, c = 1 << l;\n      if (this.length <= a)\n        return this._expand(a + 1), this.words[a] |= c, this;\n      for (var b = c, E = a; b !== 0 && E < this.length; E++) {\n        var S = this.words[E] | 0;\n        S += b, b = S >>> 26, S &= 67108863, this.words[E] = S;\n      }\n      return b !== 0 && (this.words[E] = b, this.length++), this;\n    }, s.prototype.isZero = function() {\n      return this.length === 1 && this.words[0] === 0;\n    }, s.prototype.cmpn = function(p) {\n      var l = p < 0;\n      if (this.negative !== 0 && !l)\n        return -1;\n      if (this.negative === 0 && l)\n        return 1;\n      this.strip();\n      var a;\n      if (this.length > 1)\n        a = 1;\n      else {\n        l && (p = -p), i(p <= 67108863, \"Number is too big\");\n        var c = this.words[0] | 0;\n        a = c === p ? 0 : c < p ? -1 : 1;\n      }\n      return this.negative !== 0 ? -a | 0 : a;\n    }, s.prototype.cmp = function(p) {\n      if (this.negative !== 0 && p.negative === 0)\n        return -1;\n      if (this.negative === 0 && p.negative !== 0)\n        return 1;\n      var l = this.ucmp(p);\n      return this.negative !== 0 ? -l | 0 : l;\n    }, s.prototype.ucmp = function(p) {\n      if (this.length > p.length)\n        return 1;\n      if (this.length < p.length)\n        return -1;\n      for (var l = 0, a = this.length - 1; a >= 0; a--) {\n        var c = this.words[a] | 0, b = p.words[a] | 0;\n        if (c !== b) {\n          c < b ? l = -1 : c > b && (l = 1);\n          break;\n        }\n      }\n      return l;\n    }, s.prototype.gtn = function(p) {\n      return this.cmpn(p) === 1;\n    }, s.prototype.gt = function(p) {\n      return this.cmp(p) === 1;\n    }, s.prototype.gten = function(p) {\n      return this.cmpn(p) >= 0;\n    }, s.prototype.gte = function(p) {\n      return this.cmp(p) >= 0;\n    }, s.prototype.ltn = function(p) {\n      return this.cmpn(p) === -1;\n    }, s.prototype.lt = function(p) {\n      return this.cmp(p) === -1;\n    }, s.prototype.lten = function(p) {\n      return this.cmpn(p) <= 0;\n    }, s.prototype.lte = function(p) {\n      return this.cmp(p) <= 0;\n    }, s.prototype.eqn = function(p) {\n      return this.cmpn(p) === 0;\n    }, s.prototype.eq = function(p) {\n      return this.cmp(p) === 0;\n    }, s.red = function(p) {\n      return new J(p);\n    }, s.prototype.toRed = function(p) {\n      return i(!this.red, \"Already a number in reduction context\"), i(this.negative === 0, \"red works only with positives\"), p.convertTo(this)._forceRed(p);\n    }, s.prototype.fromRed = function() {\n      return i(this.red, \"fromRed works only with numbers in reduction context\"), this.red.convertFrom(this);\n    }, s.prototype._forceRed = function(p) {\n      return this.red = p, this;\n    }, s.prototype.forceRed = function(p) {\n      return i(!this.red, \"Already a number in reduction context\"), this._forceRed(p);\n    }, s.prototype.redAdd = function(p) {\n      return i(this.red, \"redAdd works only with red numbers\"), this.red.add(this, p);\n    }, s.prototype.redIAdd = function(p) {\n      return i(this.red, \"redIAdd works only with red numbers\"), this.red.iadd(this, p);\n    }, s.prototype.redSub = function(p) {\n      return i(this.red, \"redSub works only with red numbers\"), this.red.sub(this, p);\n    }, s.prototype.redISub = function(p) {\n      return i(this.red, \"redISub works only with red numbers\"), this.red.isub(this, p);\n    }, s.prototype.redShl = function(p) {\n      return i(this.red, \"redShl works only with red numbers\"), this.red.shl(this, p);\n    }, s.prototype.redMul = function(p) {\n      return i(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, p), this.red.mul(this, p);\n    }, s.prototype.redIMul = function(p) {\n      return i(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, p), this.red.imul(this, p);\n    }, s.prototype.redSqr = function() {\n      return i(this.red, \"redSqr works only with red numbers\"), this.red._verify1(this), this.red.sqr(this);\n    }, s.prototype.redISqr = function() {\n      return i(this.red, \"redISqr works only with red numbers\"), this.red._verify1(this), this.red.isqr(this);\n    }, s.prototype.redSqrt = function() {\n      return i(this.red, \"redSqrt works only with red numbers\"), this.red._verify1(this), this.red.sqrt(this);\n    }, s.prototype.redInvm = function() {\n      return i(this.red, \"redInvm works only with red numbers\"), this.red._verify1(this), this.red.invm(this);\n    }, s.prototype.redNeg = function() {\n      return i(this.red, \"redNeg works only with red numbers\"), this.red._verify1(this), this.red.neg(this);\n    }, s.prototype.redPow = function(p) {\n      return i(this.red && !p.red, \"redPow(normalNum)\"), this.red._verify1(this), this.red.pow(this, p);\n    };\n    var K = {\n      k256: null,\n      p224: null,\n      p192: null,\n      p25519: null\n    };\n    function $(O, p) {\n      this.name = O, this.p = new s(p, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();\n    }\n    $.prototype._tmp = function() {\n      var p = new s(null);\n      return p.words = new Array(Math.ceil(this.n / 13)), p;\n    }, $.prototype.ireduce = function(p) {\n      var l = p, a;\n      do\n        this.split(l, this.tmp), l = this.imulK(l), l = l.iadd(this.tmp), a = l.bitLength();\n      while (a > this.n);\n      var c = a < this.n ? -1 : l.ucmp(this.p);\n      return c === 0 ? (l.words[0] = 0, l.length = 1) : c > 0 ? l.isub(this.p) : l.strip !== void 0 ? l.strip() : l._strip(), l;\n    }, $.prototype.split = function(p, l) {\n      p.iushrn(this.n, 0, l);\n    }, $.prototype.imulK = function(p) {\n      return p.imul(this.k);\n    };\n    function z() {\n      $.call(\n        this,\n        \"k256\",\n        \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\"\n      );\n    }\n    n(z, $), z.prototype.split = function(p, l) {\n      for (var a = 4194303, c = Math.min(p.length, 9), b = 0; b < c; b++)\n        l.words[b] = p.words[b];\n      if (l.length = c, p.length <= 9) {\n        p.words[0] = 0, p.length = 1;\n        return;\n      }\n      var E = p.words[9];\n      for (l.words[l.length++] = E & a, b = 10; b < p.length; b++) {\n        var S = p.words[b] | 0;\n        p.words[b - 10] = (S & a) << 4 | E >>> 22, E = S;\n      }\n      E >>>= 22, p.words[b - 10] = E, E === 0 && p.length > 10 ? p.length -= 10 : p.length -= 9;\n    }, z.prototype.imulK = function(p) {\n      p.words[p.length] = 0, p.words[p.length + 1] = 0, p.length += 2;\n      for (var l = 0, a = 0; a < p.length; a++) {\n        var c = p.words[a] | 0;\n        l += c * 977, p.words[a] = l & 67108863, l = c * 64 + (l / 67108864 | 0);\n      }\n      return p.words[p.length - 1] === 0 && (p.length--, p.words[p.length - 1] === 0 && p.length--), p;\n    };\n    function B() {\n      $.call(\n        this,\n        \"p224\",\n        \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\"\n      );\n    }\n    n(B, $);\n    function _() {\n      $.call(\n        this,\n        \"p192\",\n        \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\"\n      );\n    }\n    n(_, $);\n    function R() {\n      $.call(\n        this,\n        \"25519\",\n        \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\"\n      );\n    }\n    n(R, $), R.prototype.imulK = function(p) {\n      for (var l = 0, a = 0; a < p.length; a++) {\n        var c = (p.words[a] | 0) * 19 + l, b = c & 67108863;\n        c >>>= 26, p.words[a] = b, l = c;\n      }\n      return l !== 0 && (p.words[p.length++] = l), p;\n    }, s._prime = function(p) {\n      if (K[p])\n        return K[p];\n      var l;\n      if (p === \"k256\")\n        l = new z();\n      else if (p === \"p224\")\n        l = new B();\n      else if (p === \"p192\")\n        l = new _();\n      else if (p === \"p25519\")\n        l = new R();\n      else\n        throw new Error(\"Unknown prime \" + p);\n      return K[p] = l, l;\n    };\n    function J(O) {\n      if (typeof O == \"string\") {\n        var p = s._prime(O);\n        this.m = p.p, this.prime = p;\n      } else\n        i(O.gtn(1), \"modulus must be greater than 1\"), this.m = O, this.prime = null;\n    }\n    J.prototype._verify1 = function(p) {\n      i(p.negative === 0, \"red works only with positives\"), i(p.red, \"red works only with red numbers\");\n    }, J.prototype._verify2 = function(p, l) {\n      i((p.negative | l.negative) === 0, \"red works only with positives\"), i(\n        p.red && p.red === l.red,\n        \"red works only with red numbers\"\n      );\n    }, J.prototype.imod = function(p) {\n      return this.prime ? this.prime.ireduce(p)._forceRed(this) : p.umod(this.m)._forceRed(this);\n    }, J.prototype.neg = function(p) {\n      return p.isZero() ? p.clone() : this.m.sub(p)._forceRed(this);\n    }, J.prototype.add = function(p, l) {\n      this._verify2(p, l);\n      var a = p.add(l);\n      return a.cmp(this.m) >= 0 && a.isub(this.m), a._forceRed(this);\n    }, J.prototype.iadd = function(p, l) {\n      this._verify2(p, l);\n      var a = p.iadd(l);\n      return a.cmp(this.m) >= 0 && a.isub(this.m), a;\n    }, J.prototype.sub = function(p, l) {\n      this._verify2(p, l);\n      var a = p.sub(l);\n      return a.cmpn(0) < 0 && a.iadd(this.m), a._forceRed(this);\n    }, J.prototype.isub = function(p, l) {\n      this._verify2(p, l);\n      var a = p.isub(l);\n      return a.cmpn(0) < 0 && a.iadd(this.m), a;\n    }, J.prototype.shl = function(p, l) {\n      return this._verify1(p), this.imod(p.ushln(l));\n    }, J.prototype.imul = function(p, l) {\n      return this._verify2(p, l), this.imod(p.imul(l));\n    }, J.prototype.mul = function(p, l) {\n      return this._verify2(p, l), this.imod(p.mul(l));\n    }, J.prototype.isqr = function(p) {\n      return this.imul(p, p.clone());\n    }, J.prototype.sqr = function(p) {\n      return this.mul(p, p);\n    }, J.prototype.sqrt = function(p) {\n      if (p.isZero())\n        return p.clone();\n      var l = this.m.andln(3);\n      if (i(l % 2 === 1), l === 3) {\n        var a = this.m.add(new s(1)).iushrn(2);\n        return this.pow(p, a);\n      }\n      for (var c = this.m.subn(1), b = 0; !c.isZero() && c.andln(1) === 0; )\n        b++, c.iushrn(1);\n      i(!c.isZero());\n      var E = new s(1).toRed(this), S = E.redNeg(), x = this.m.subn(1).iushrn(1), u = this.m.bitLength();\n      for (u = new s(2 * u * u).toRed(this); this.pow(u, x).cmp(S) !== 0; )\n        u.redIAdd(S);\n      for (var m = this.pow(u, c), g = this.pow(p, c.addn(1).iushrn(1)), P = this.pow(p, c), G = b; P.cmp(E) !== 0; ) {\n        for (var M = P, H = 0; M.cmp(E) !== 0; H++)\n          M = M.redSqr();\n        i(H < G);\n        var C = this.pow(m, new s(1).iushln(G - H - 1));\n        g = g.redMul(C), m = C.redSqr(), P = P.redMul(m), G = H;\n      }\n      return g;\n    }, J.prototype.invm = function(p) {\n      var l = p._invmp(this.m);\n      return l.negative !== 0 ? (l.negative = 0, this.imod(l).redNeg()) : this.imod(l);\n    }, J.prototype.pow = function(p, l) {\n      if (l.isZero())\n        return new s(1).toRed(this);\n      if (l.cmpn(1) === 0)\n        return p.clone();\n      var a = 4, c = new Array(1 << a);\n      c[0] = new s(1).toRed(this), c[1] = p;\n      for (var b = 2; b < c.length; b++)\n        c[b] = this.mul(c[b - 1], p);\n      var E = c[0], S = 0, x = 0, u = l.bitLength() % 26;\n      for (u === 0 && (u = 26), b = l.length - 1; b >= 0; b--) {\n        for (var m = l.words[b], g = u - 1; g >= 0; g--) {\n          var P = m >> g & 1;\n          if (E !== c[0] && (E = this.sqr(E)), P === 0 && S === 0) {\n            x = 0;\n            continue;\n          }\n          S <<= 1, S |= P, x++, !(x !== a && (b !== 0 || g !== 0)) && (E = this.mul(E, c[S]), x = 0, S = 0);\n        }\n        u = 26;\n      }\n      return E;\n    }, J.prototype.convertTo = function(p) {\n      var l = p.umod(this.m);\n      return l === p ? l.clone() : l;\n    }, J.prototype.convertFrom = function(p) {\n      var l = p.clone();\n      return l.red = null, l;\n    }, s.mont = function(p) {\n      return new Q(p);\n    };\n    function Q(O) {\n      J.call(this, O), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);\n    }\n    n(Q, J), Q.prototype.convertTo = function(p) {\n      return this.imod(p.ushln(this.shift));\n    }, Q.prototype.convertFrom = function(p) {\n      var l = this.imod(p.mul(this.rinv));\n      return l.red = null, l;\n    }, Q.prototype.imul = function(p, l) {\n      if (p.isZero() || l.isZero())\n        return p.words[0] = 0, p.length = 1, p;\n      var a = p.imul(l), c = a.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), b = a.isub(c).iushrn(this.shift), E = b;\n      return b.cmp(this.m) >= 0 ? E = b.isub(this.m) : b.cmpn(0) < 0 && (E = b.iadd(this.m)), E._forceRed(this);\n    }, Q.prototype.mul = function(p, l) {\n      if (p.isZero() || l.isZero())\n        return new s(0)._forceRed(this);\n      var a = p.mul(l), c = a.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), b = a.isub(c).iushrn(this.shift), E = b;\n      return b.cmp(this.m) >= 0 ? E = b.isub(this.m) : b.cmpn(0) < 0 && (E = b.iadd(this.m)), E._forceRed(this);\n    }, Q.prototype.invm = function(p) {\n      var l = this.imod(p._invmp(this.m).mul(this.r2));\n      return l._forceRed(this);\n    };\n  })(r, _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.c);\n})(Wo);\nvar li = Wo.exports, Go = {};\n(function(r) {\n  var e = r;\n  function t(s, o) {\n    if (Array.isArray(s))\n      return s.slice();\n    if (!s)\n      return [];\n    var f = [];\n    if (typeof s != \"string\") {\n      for (var h = 0; h < s.length; h++)\n        f[h] = s[h] | 0;\n      return f;\n    }\n    if (o === \"hex\") {\n      s = s.replace(/[^a-z0-9]+/ig, \"\"), s.length % 2 !== 0 && (s = \"0\" + s);\n      for (var h = 0; h < s.length; h += 2)\n        f.push(parseInt(s[h] + s[h + 1], 16));\n    } else\n      for (var h = 0; h < s.length; h++) {\n        var d = s.charCodeAt(h), v = d >> 8, w = d & 255;\n        v ? f.push(v, w) : f.push(w);\n      }\n    return f;\n  }\n  e.toArray = t;\n  function i(s) {\n    return s.length === 1 ? \"0\" + s : s;\n  }\n  e.zero2 = i;\n  function n(s) {\n    for (var o = \"\", f = 0; f < s.length; f++)\n      o += i(s[f].toString(16));\n    return o;\n  }\n  e.toHex = n, e.encode = function(o, f) {\n    return f === \"hex\" ? n(o) : o;\n  };\n})(Go);\n(function(r) {\n  var e = r, t = li, i = Yi, n = Go;\n  e.assert = i, e.toArray = n.toArray, e.zero2 = n.zero2, e.toHex = n.toHex, e.encode = n.encode;\n  function s(v, w, A) {\n    var I = new Array(Math.max(v.bitLength(), A) + 1), D;\n    for (D = 0; D < I.length; D += 1)\n      I[D] = 0;\n    var N = 1 << w + 1, k = v.clone();\n    for (D = 0; D < I.length; D++) {\n      var j, T = k.andln(N - 1);\n      k.isOdd() ? (T > (N >> 1) - 1 ? j = (N >> 1) - T : j = T, k.isubn(j)) : j = 0, I[D] = j, k.iushrn(1);\n    }\n    return I;\n  }\n  e.getNAF = s;\n  function o(v, w) {\n    var A = [\n      [],\n      []\n    ];\n    v = v.clone(), w = w.clone();\n    for (var I = 0, D = 0, N; v.cmpn(-I) > 0 || w.cmpn(-D) > 0; ) {\n      var k = v.andln(3) + I & 3, j = w.andln(3) + D & 3;\n      k === 3 && (k = -1), j === 3 && (j = -1);\n      var T;\n      k & 1 ? (N = v.andln(7) + I & 7, (N === 3 || N === 5) && j === 2 ? T = -k : T = k) : T = 0, A[0].push(T);\n      var K;\n      j & 1 ? (N = w.andln(7) + D & 7, (N === 3 || N === 5) && k === 2 ? K = -j : K = j) : K = 0, A[1].push(K), 2 * I === T + 1 && (I = 1 - I), 2 * D === K + 1 && (D = 1 - D), v.iushrn(1), w.iushrn(1);\n    }\n    return A;\n  }\n  e.getJSF = o;\n  function f(v, w, A) {\n    var I = \"_\" + w;\n    v.prototype[w] = function() {\n      return this[I] !== void 0 ? this[I] : this[I] = A.call(this);\n    };\n  }\n  e.cachedProperty = f;\n  function h(v) {\n    return typeof v == \"string\" ? e.toArray(v, \"hex\") : v;\n  }\n  e.parseBytes = h;\n  function d(v) {\n    return new t(v, \"hex\", \"le\");\n  }\n  e.intFromLE = d;\n})(ar);\nvar Jo = { exports: {} }, Ja;\nJo.exports = function(e) {\n  return Ja || (Ja = new yi(null)), Ja.generate(e);\n};\nfunction yi(r) {\n  this.rand = r;\n}\nJo.exports.Rand = yi;\nyi.prototype.generate = function(e) {\n  return this._rand(e);\n};\nyi.prototype._rand = function(e) {\n  if (this.rand.getBytes)\n    return this.rand.getBytes(e);\n  for (var t = new Uint8Array(e), i = 0; i < t.length; i++)\n    t[i] = this.rand.getByte();\n  return t;\n};\nif (typeof self == \"object\")\n  self.crypto && self.crypto.getRandomValues ? yi.prototype._rand = function(e) {\n    var t = new Uint8Array(e);\n    return self.crypto.getRandomValues(t), t;\n  } : self.msCrypto && self.msCrypto.getRandomValues ? yi.prototype._rand = function(e) {\n    var t = new Uint8Array(e);\n    return self.msCrypto.getRandomValues(t), t;\n  } : typeof window == \"object\" && (yi.prototype._rand = function() {\n    throw new Error(\"Not implemented yet\");\n  });\nelse\n  try {\n    var gc = fa;\n    if (typeof gc.randomBytes != \"function\")\n      throw new Error(\"Not supported\");\n    yi.prototype._rand = function(e) {\n      return gc.randomBytes(e);\n    };\n  } catch {\n  }\nvar Hu = Jo.exports, Yo = {}, Ni = li, os = ar, Hs = os.getNAF, u2 = os.getJSF, Vs = os.assert;\nfunction Ii(r, e) {\n  this.type = r, this.p = new Ni(e.p, 16), this.red = e.prime ? Ni.red(e.prime) : Ni.mont(this.p), this.zero = new Ni(0).toRed(this.red), this.one = new Ni(1).toRed(this.red), this.two = new Ni(2).toRed(this.red), this.n = e.n && new Ni(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;\n  var t = this.n && this.p.div(this.n);\n  !t || t.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));\n}\nvar ba = Ii;\nIi.prototype.point = function() {\n  throw new Error(\"Not implemented\");\n};\nIi.prototype.validate = function() {\n  throw new Error(\"Not implemented\");\n};\nIi.prototype._fixedNafMul = function(e, t) {\n  Vs(e.precomputed);\n  var i = e._getDoubles(), n = Hs(t, 1, this._bitLength), s = (1 << i.step + 1) - (i.step % 2 === 0 ? 2 : 1);\n  s /= 3;\n  var o = [], f, h;\n  for (f = 0; f < n.length; f += i.step) {\n    h = 0;\n    for (var d = f + i.step - 1; d >= f; d--)\n      h = (h << 1) + n[d];\n    o.push(h);\n  }\n  for (var v = this.jpoint(null, null, null), w = this.jpoint(null, null, null), A = s; A > 0; A--) {\n    for (f = 0; f < o.length; f++)\n      h = o[f], h === A ? w = w.mixedAdd(i.points[f]) : h === -A && (w = w.mixedAdd(i.points[f].neg()));\n    v = v.add(w);\n  }\n  return v.toP();\n};\nIi.prototype._wnafMul = function(e, t) {\n  var i = 4, n = e._getNAFPoints(i);\n  i = n.wnd;\n  for (var s = n.points, o = Hs(t, i, this._bitLength), f = this.jpoint(null, null, null), h = o.length - 1; h >= 0; h--) {\n    for (var d = 0; h >= 0 && o[h] === 0; h--)\n      d++;\n    if (h >= 0 && d++, f = f.dblp(d), h < 0)\n      break;\n    var v = o[h];\n    Vs(v !== 0), e.type === \"affine\" ? v > 0 ? f = f.mixedAdd(s[v - 1 >> 1]) : f = f.mixedAdd(s[-v - 1 >> 1].neg()) : v > 0 ? f = f.add(s[v - 1 >> 1]) : f = f.add(s[-v - 1 >> 1].neg());\n  }\n  return e.type === \"affine\" ? f.toP() : f;\n};\nIi.prototype._wnafMulAdd = function(e, t, i, n, s) {\n  var o = this._wnafT1, f = this._wnafT2, h = this._wnafT3, d = 0, v, w, A;\n  for (v = 0; v < n; v++) {\n    A = t[v];\n    var I = A._getNAFPoints(e);\n    o[v] = I.wnd, f[v] = I.points;\n  }\n  for (v = n - 1; v >= 1; v -= 2) {\n    var D = v - 1, N = v;\n    if (o[D] !== 1 || o[N] !== 1) {\n      h[D] = Hs(i[D], o[D], this._bitLength), h[N] = Hs(i[N], o[N], this._bitLength), d = Math.max(h[D].length, d), d = Math.max(h[N].length, d);\n      continue;\n    }\n    var k = [\n      t[D],\n      /* 1 */\n      null,\n      /* 3 */\n      null,\n      /* 5 */\n      t[N]\n      /* 7 */\n    ];\n    t[D].y.cmp(t[N].y) === 0 ? (k[1] = t[D].add(t[N]), k[2] = t[D].toJ().mixedAdd(t[N].neg())) : t[D].y.cmp(t[N].y.redNeg()) === 0 ? (k[1] = t[D].toJ().mixedAdd(t[N]), k[2] = t[D].add(t[N].neg())) : (k[1] = t[D].toJ().mixedAdd(t[N]), k[2] = t[D].toJ().mixedAdd(t[N].neg()));\n    var j = [\n      -3,\n      /* -1 -1 */\n      -1,\n      /* -1 0 */\n      -5,\n      /* -1 1 */\n      -7,\n      /* 0 -1 */\n      0,\n      /* 0 0 */\n      7,\n      /* 0 1 */\n      5,\n      /* 1 -1 */\n      1,\n      /* 1 0 */\n      3\n      /* 1 1 */\n    ], T = u2(i[D], i[N]);\n    for (d = Math.max(T[0].length, d), h[D] = new Array(d), h[N] = new Array(d), w = 0; w < d; w++) {\n      var K = T[0][w] | 0, $ = T[1][w] | 0;\n      h[D][w] = j[(K + 1) * 3 + ($ + 1)], h[N][w] = 0, f[D] = k;\n    }\n  }\n  var z = this.jpoint(null, null, null), B = this._wnafT4;\n  for (v = d; v >= 0; v--) {\n    for (var _ = 0; v >= 0; ) {\n      var R = !0;\n      for (w = 0; w < n; w++)\n        B[w] = h[w][v] | 0, B[w] !== 0 && (R = !1);\n      if (!R)\n        break;\n      _++, v--;\n    }\n    if (v >= 0 && _++, z = z.dblp(_), v < 0)\n      break;\n    for (w = 0; w < n; w++) {\n      var J = B[w];\n      J !== 0 && (J > 0 ? A = f[w][J - 1 >> 1] : J < 0 && (A = f[w][-J - 1 >> 1].neg()), A.type === \"affine\" ? z = z.mixedAdd(A) : z = z.add(A));\n    }\n  }\n  for (v = 0; v < n; v++)\n    f[v] = null;\n  return s ? z : z.toP();\n};\nfunction gr(r, e) {\n  this.curve = r, this.type = e, this.precomputed = null;\n}\nIi.BasePoint = gr;\ngr.prototype.eq = function() {\n  throw new Error(\"Not implemented\");\n};\ngr.prototype.validate = function() {\n  return this.curve.validate(this);\n};\nIi.prototype.decodePoint = function(e, t) {\n  e = os.toArray(e, t);\n  var i = this.p.byteLength();\n  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * i) {\n    e[0] === 6 ? Vs(e[e.length - 1] % 2 === 0) : e[0] === 7 && Vs(e[e.length - 1] % 2 === 1);\n    var n = this.point(\n      e.slice(1, 1 + i),\n      e.slice(1 + i, 1 + 2 * i)\n    );\n    return n;\n  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === i)\n    return this.pointFromX(e.slice(1, 1 + i), e[0] === 3);\n  throw new Error(\"Unknown point format\");\n};\ngr.prototype.encodeCompressed = function(e) {\n  return this.encode(e, !0);\n};\ngr.prototype._encode = function(e) {\n  var t = this.curve.p.byteLength(), i = this.getX().toArray(\"be\", t);\n  return e ? [this.getY().isEven() ? 2 : 3].concat(i) : [4].concat(i, this.getY().toArray(\"be\", t));\n};\ngr.prototype.encode = function(e, t) {\n  return os.encode(this._encode(t), e);\n};\ngr.prototype.precompute = function(e) {\n  if (this.precomputed)\n    return this;\n  var t = {\n    doubles: null,\n    naf: null,\n    beta: null\n  };\n  return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this;\n};\ngr.prototype._hasDoubles = function(e) {\n  if (!this.precomputed)\n    return !1;\n  var t = this.precomputed.doubles;\n  return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1;\n};\ngr.prototype._getDoubles = function(e, t) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n  for (var i = [this], n = this, s = 0; s < t; s += e) {\n    for (var o = 0; o < e; o++)\n      n = n.dbl();\n    i.push(n);\n  }\n  return {\n    step: e,\n    points: i\n  };\n};\ngr.prototype._getNAFPoints = function(e) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n  for (var t = [this], i = (1 << e) - 1, n = i === 1 ? null : this.dbl(), s = 1; s < i; s++)\n    t[s] = t[s - 1].add(n);\n  return {\n    wnd: e,\n    points: t\n  };\n};\ngr.prototype._getBeta = function() {\n  return null;\n};\ngr.prototype.dblp = function(e) {\n  for (var t = this, i = 0; i < e; i++)\n    t = t.dbl();\n  return t;\n};\nvar d2 = ar, pt = li, Xo = ua, En = ba, l2 = d2.assert;\nfunction yr(r) {\n  En.call(this, \"short\", r), this.a = new pt(r.a, 16).toRed(this.red), this.b = new pt(r.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(r), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);\n}\nXo(yr, En);\nvar p2 = yr;\nyr.prototype._getEndomorphism = function(e) {\n  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {\n    var t, i;\n    if (e.beta)\n      t = new pt(e.beta, 16).toRed(this.red);\n    else {\n      var n = this._getEndoRoots(this.p);\n      t = n[0].cmp(n[1]) < 0 ? n[0] : n[1], t = t.toRed(this.red);\n    }\n    if (e.lambda)\n      i = new pt(e.lambda, 16);\n    else {\n      var s = this._getEndoRoots(this.n);\n      this.g.mul(s[0]).x.cmp(this.g.x.redMul(t)) === 0 ? i = s[0] : (i = s[1], l2(this.g.mul(i).x.cmp(this.g.x.redMul(t)) === 0));\n    }\n    var o;\n    return e.basis ? o = e.basis.map(function(f) {\n      return {\n        a: new pt(f.a, 16),\n        b: new pt(f.b, 16)\n      };\n    }) : o = this._getEndoBasis(i), {\n      beta: t,\n      lambda: i,\n      basis: o\n    };\n  }\n};\nyr.prototype._getEndoRoots = function(e) {\n  var t = e === this.p ? this.red : pt.mont(e), i = new pt(2).toRed(t).redInvm(), n = i.redNeg(), s = new pt(3).toRed(t).redNeg().redSqrt().redMul(i), o = n.redAdd(s).fromRed(), f = n.redSub(s).fromRed();\n  return [o, f];\n};\nyr.prototype._getEndoBasis = function(e) {\n  for (var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), i = e, n = this.n.clone(), s = new pt(1), o = new pt(0), f = new pt(0), h = new pt(1), d, v, w, A, I, D, N, k = 0, j, T; i.cmpn(0) !== 0; ) {\n    var K = n.div(i);\n    j = n.sub(K.mul(i)), T = f.sub(K.mul(s));\n    var $ = h.sub(K.mul(o));\n    if (!w && j.cmp(t) < 0)\n      d = N.neg(), v = s, w = j.neg(), A = T;\n    else if (w && ++k === 2)\n      break;\n    N = j, n = i, i = j, f = s, s = T, h = o, o = $;\n  }\n  I = j.neg(), D = T;\n  var z = w.sqr().add(A.sqr()), B = I.sqr().add(D.sqr());\n  return B.cmp(z) >= 0 && (I = d, D = v), w.negative && (w = w.neg(), A = A.neg()), I.negative && (I = I.neg(), D = D.neg()), [\n    { a: w, b: A },\n    { a: I, b: D }\n  ];\n};\nyr.prototype._endoSplit = function(e) {\n  var t = this.endo.basis, i = t[0], n = t[1], s = n.b.mul(e).divRound(this.n), o = i.b.neg().mul(e).divRound(this.n), f = s.mul(i.a), h = o.mul(n.a), d = s.mul(i.b), v = o.mul(n.b), w = e.sub(f).sub(h), A = d.add(v).neg();\n  return { k1: w, k2: A };\n};\nyr.prototype.pointFromX = function(e, t) {\n  e = new pt(e, 16), e.red || (e = e.toRed(this.red));\n  var i = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), n = i.redSqrt();\n  if (n.redSqr().redSub(i).cmp(this.zero) !== 0)\n    throw new Error(\"invalid point\");\n  var s = n.fromRed().isOdd();\n  return (t && !s || !t && s) && (n = n.redNeg()), this.point(e, n);\n};\nyr.prototype.validate = function(e) {\n  if (e.inf)\n    return !0;\n  var t = e.x, i = e.y, n = this.a.redMul(t), s = t.redSqr().redMul(t).redIAdd(n).redIAdd(this.b);\n  return i.redSqr().redISub(s).cmpn(0) === 0;\n};\nyr.prototype._endoWnafMulAdd = function(e, t, i) {\n  for (var n = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {\n    var f = this._endoSplit(t[o]), h = e[o], d = h._getBeta();\n    f.k1.negative && (f.k1.ineg(), h = h.neg(!0)), f.k2.negative && (f.k2.ineg(), d = d.neg(!0)), n[o * 2] = h, n[o * 2 + 1] = d, s[o * 2] = f.k1, s[o * 2 + 1] = f.k2;\n  }\n  for (var v = this._wnafMulAdd(1, n, s, o * 2, i), w = 0; w < o * 2; w++)\n    n[w] = null, s[w] = null;\n  return v;\n};\nfunction Pt(r, e, t, i) {\n  En.BasePoint.call(this, r, \"affine\"), e === null && t === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new pt(e, 16), this.y = new pt(t, 16), i && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);\n}\nXo(Pt, En.BasePoint);\nyr.prototype.point = function(e, t, i) {\n  return new Pt(this, e, t, i);\n};\nyr.prototype.pointFromJSON = function(e, t) {\n  return Pt.fromJSON(this, e, t);\n};\nPt.prototype._getBeta = function() {\n  if (this.curve.endo) {\n    var e = this.precomputed;\n    if (e && e.beta)\n      return e.beta;\n    var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n    if (e) {\n      var i = this.curve, n = function(s) {\n        return i.point(s.x.redMul(i.endo.beta), s.y);\n      };\n      e.beta = t, t.precomputed = {\n        beta: null,\n        naf: e.naf && {\n          wnd: e.naf.wnd,\n          points: e.naf.points.map(n)\n        },\n        doubles: e.doubles && {\n          step: e.doubles.step,\n          points: e.doubles.points.map(n)\n        }\n      };\n    }\n    return t;\n  }\n};\nPt.prototype.toJSON = function() {\n  return this.precomputed ? [this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1)\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1)\n    }\n  }] : [this.x, this.y];\n};\nPt.fromJSON = function(e, t, i) {\n  typeof t == \"string\" && (t = JSON.parse(t));\n  var n = e.point(t[0], t[1], i);\n  if (!t[2])\n    return n;\n  function s(f) {\n    return e.point(f[0], f[1], i);\n  }\n  var o = t[2];\n  return n.precomputed = {\n    beta: null,\n    doubles: o.doubles && {\n      step: o.doubles.step,\n      points: [n].concat(o.doubles.points.map(s))\n    },\n    naf: o.naf && {\n      wnd: o.naf.wnd,\n      points: [n].concat(o.naf.points.map(s))\n    }\n  }, n;\n};\nPt.prototype.inspect = function() {\n  return this.isInfinity() ? \"<EC Point Infinity>\" : \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" y: \" + this.y.fromRed().toString(16, 2) + \">\";\n};\nPt.prototype.isInfinity = function() {\n  return this.inf;\n};\nPt.prototype.add = function(e) {\n  if (this.inf)\n    return e;\n  if (e.inf)\n    return this;\n  if (this.eq(e))\n    return this.dbl();\n  if (this.neg().eq(e))\n    return this.curve.point(null, null);\n  if (this.x.cmp(e.x) === 0)\n    return this.curve.point(null, null);\n  var t = this.y.redSub(e.y);\n  t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));\n  var i = t.redSqr().redISub(this.x).redISub(e.x), n = t.redMul(this.x.redSub(i)).redISub(this.y);\n  return this.curve.point(i, n);\n};\nPt.prototype.dbl = function() {\n  if (this.inf)\n    return this;\n  var e = this.y.redAdd(this.y);\n  if (e.cmpn(0) === 0)\n    return this.curve.point(null, null);\n  var t = this.curve.a, i = this.x.redSqr(), n = e.redInvm(), s = i.redAdd(i).redIAdd(i).redIAdd(t).redMul(n), o = s.redSqr().redISub(this.x.redAdd(this.x)), f = s.redMul(this.x.redSub(o)).redISub(this.y);\n  return this.curve.point(o, f);\n};\nPt.prototype.getX = function() {\n  return this.x.fromRed();\n};\nPt.prototype.getY = function() {\n  return this.y.fromRed();\n};\nPt.prototype.mul = function(e) {\n  return e = new pt(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);\n};\nPt.prototype.mulAdd = function(e, t, i) {\n  var n = [this, t], s = [e, i];\n  return this.curve.endo ? this.curve._endoWnafMulAdd(n, s) : this.curve._wnafMulAdd(1, n, s, 2);\n};\nPt.prototype.jmulAdd = function(e, t, i) {\n  var n = [this, t], s = [e, i];\n  return this.curve.endo ? this.curve._endoWnafMulAdd(n, s, !0) : this.curve._wnafMulAdd(1, n, s, 2, !0);\n};\nPt.prototype.eq = function(e) {\n  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);\n};\nPt.prototype.neg = function(e) {\n  if (this.inf)\n    return this;\n  var t = this.curve.point(this.x, this.y.redNeg());\n  if (e && this.precomputed) {\n    var i = this.precomputed, n = function(s) {\n      return s.neg();\n    };\n    t.precomputed = {\n      naf: i.naf && {\n        wnd: i.naf.wnd,\n        points: i.naf.points.map(n)\n      },\n      doubles: i.doubles && {\n        step: i.doubles.step,\n        points: i.doubles.points.map(n)\n      }\n    };\n  }\n  return t;\n};\nPt.prototype.toJ = function() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n  var e = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return e;\n};\nfunction Tt(r, e, t, i) {\n  En.BasePoint.call(this, r, \"jacobian\"), e === null && t === null && i === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new pt(0)) : (this.x = new pt(e, 16), this.y = new pt(t, 16), this.z = new pt(i, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;\n}\nXo(Tt, En.BasePoint);\nyr.prototype.jpoint = function(e, t, i) {\n  return new Tt(this, e, t, i);\n};\nTt.prototype.toP = function() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n  var e = this.z.redInvm(), t = e.redSqr(), i = this.x.redMul(t), n = this.y.redMul(t).redMul(e);\n  return this.curve.point(i, n);\n};\nTt.prototype.neg = function() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\nTt.prototype.add = function(e) {\n  if (this.isInfinity())\n    return e;\n  if (e.isInfinity())\n    return this;\n  var t = e.z.redSqr(), i = this.z.redSqr(), n = this.x.redMul(t), s = e.x.redMul(i), o = this.y.redMul(t.redMul(e.z)), f = e.y.redMul(i.redMul(this.z)), h = n.redSub(s), d = o.redSub(f);\n  if (h.cmpn(0) === 0)\n    return d.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();\n  var v = h.redSqr(), w = v.redMul(h), A = n.redMul(v), I = d.redSqr().redIAdd(w).redISub(A).redISub(A), D = d.redMul(A.redISub(I)).redISub(o.redMul(w)), N = this.z.redMul(e.z).redMul(h);\n  return this.curve.jpoint(I, D, N);\n};\nTt.prototype.mixedAdd = function(e) {\n  if (this.isInfinity())\n    return e.toJ();\n  if (e.isInfinity())\n    return this;\n  var t = this.z.redSqr(), i = this.x, n = e.x.redMul(t), s = this.y, o = e.y.redMul(t).redMul(this.z), f = i.redSub(n), h = s.redSub(o);\n  if (f.cmpn(0) === 0)\n    return h.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();\n  var d = f.redSqr(), v = d.redMul(f), w = i.redMul(d), A = h.redSqr().redIAdd(v).redISub(w).redISub(w), I = h.redMul(w.redISub(A)).redISub(s.redMul(v)), D = this.z.redMul(f);\n  return this.curve.jpoint(A, I, D);\n};\nTt.prototype.dblp = function(e) {\n  if (e === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!e)\n    return this.dbl();\n  var t;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var i = this;\n    for (t = 0; t < e; t++)\n      i = i.dbl();\n    return i;\n  }\n  var n = this.curve.a, s = this.curve.tinv, o = this.x, f = this.y, h = this.z, d = h.redSqr().redSqr(), v = f.redAdd(f);\n  for (t = 0; t < e; t++) {\n    var w = o.redSqr(), A = v.redSqr(), I = A.redSqr(), D = w.redAdd(w).redIAdd(w).redIAdd(n.redMul(d)), N = o.redMul(A), k = D.redSqr().redISub(N.redAdd(N)), j = N.redISub(k), T = D.redMul(j);\n    T = T.redIAdd(T).redISub(I);\n    var K = v.redMul(h);\n    t + 1 < e && (d = d.redMul(I)), o = k, h = K, v = T;\n  }\n  return this.curve.jpoint(o, v.redMul(s), h);\n};\nTt.prototype.dbl = function() {\n  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();\n};\nTt.prototype._zeroDbl = function() {\n  var e, t, i;\n  if (this.zOne) {\n    var n = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), f = this.x.redAdd(s).redSqr().redISub(n).redISub(o);\n    f = f.redIAdd(f);\n    var h = n.redAdd(n).redIAdd(n), d = h.redSqr().redISub(f).redISub(f), v = o.redIAdd(o);\n    v = v.redIAdd(v), v = v.redIAdd(v), e = d, t = h.redMul(f.redISub(d)).redISub(v), i = this.y.redAdd(this.y);\n  } else {\n    var w = this.x.redSqr(), A = this.y.redSqr(), I = A.redSqr(), D = this.x.redAdd(A).redSqr().redISub(w).redISub(I);\n    D = D.redIAdd(D);\n    var N = w.redAdd(w).redIAdd(w), k = N.redSqr(), j = I.redIAdd(I);\n    j = j.redIAdd(j), j = j.redIAdd(j), e = k.redISub(D).redISub(D), t = N.redMul(D.redISub(e)).redISub(j), i = this.y.redMul(this.z), i = i.redIAdd(i);\n  }\n  return this.curve.jpoint(e, t, i);\n};\nTt.prototype._threeDbl = function() {\n  var e, t, i;\n  if (this.zOne) {\n    var n = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), f = this.x.redAdd(s).redSqr().redISub(n).redISub(o);\n    f = f.redIAdd(f);\n    var h = n.redAdd(n).redIAdd(n).redIAdd(this.curve.a), d = h.redSqr().redISub(f).redISub(f);\n    e = d;\n    var v = o.redIAdd(o);\n    v = v.redIAdd(v), v = v.redIAdd(v), t = h.redMul(f.redISub(d)).redISub(v), i = this.y.redAdd(this.y);\n  } else {\n    var w = this.z.redSqr(), A = this.y.redSqr(), I = this.x.redMul(A), D = this.x.redSub(w).redMul(this.x.redAdd(w));\n    D = D.redAdd(D).redIAdd(D);\n    var N = I.redIAdd(I);\n    N = N.redIAdd(N);\n    var k = N.redAdd(N);\n    e = D.redSqr().redISub(k), i = this.y.redAdd(this.z).redSqr().redISub(A).redISub(w);\n    var j = A.redSqr();\n    j = j.redIAdd(j), j = j.redIAdd(j), j = j.redIAdd(j), t = D.redMul(N.redISub(e)).redISub(j);\n  }\n  return this.curve.jpoint(e, t, i);\n};\nTt.prototype._dbl = function() {\n  var e = this.curve.a, t = this.x, i = this.y, n = this.z, s = n.redSqr().redSqr(), o = t.redSqr(), f = i.redSqr(), h = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)), d = t.redAdd(t);\n  d = d.redIAdd(d);\n  var v = d.redMul(f), w = h.redSqr().redISub(v.redAdd(v)), A = v.redISub(w), I = f.redSqr();\n  I = I.redIAdd(I), I = I.redIAdd(I), I = I.redIAdd(I);\n  var D = h.redMul(A).redISub(I), N = i.redAdd(i).redMul(n);\n  return this.curve.jpoint(w, D, N);\n};\nTt.prototype.trpl = function() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n  var e = this.x.redSqr(), t = this.y.redSqr(), i = this.z.redSqr(), n = t.redSqr(), s = e.redAdd(e).redIAdd(e), o = s.redSqr(), f = this.x.redAdd(t).redSqr().redISub(e).redISub(n);\n  f = f.redIAdd(f), f = f.redAdd(f).redIAdd(f), f = f.redISub(o);\n  var h = f.redSqr(), d = n.redIAdd(n);\n  d = d.redIAdd(d), d = d.redIAdd(d), d = d.redIAdd(d);\n  var v = s.redIAdd(f).redSqr().redISub(o).redISub(h).redISub(d), w = t.redMul(v);\n  w = w.redIAdd(w), w = w.redIAdd(w);\n  var A = this.x.redMul(h).redISub(w);\n  A = A.redIAdd(A), A = A.redIAdd(A);\n  var I = this.y.redMul(v.redMul(d.redISub(v)).redISub(f.redMul(h)));\n  I = I.redIAdd(I), I = I.redIAdd(I), I = I.redIAdd(I);\n  var D = this.z.redAdd(f).redSqr().redISub(i).redISub(h);\n  return this.curve.jpoint(A, I, D);\n};\nTt.prototype.mul = function(e, t) {\n  return e = new pt(e, t), this.curve._wnafMul(this, e);\n};\nTt.prototype.eq = function(e) {\n  if (e.type === \"affine\")\n    return this.eq(e.toJ());\n  if (this === e)\n    return !0;\n  var t = this.z.redSqr(), i = e.z.redSqr();\n  if (this.x.redMul(i).redISub(e.x.redMul(t)).cmpn(0) !== 0)\n    return !1;\n  var n = t.redMul(this.z), s = i.redMul(e.z);\n  return this.y.redMul(s).redISub(e.y.redMul(n)).cmpn(0) === 0;\n};\nTt.prototype.eqXToP = function(e) {\n  var t = this.z.redSqr(), i = e.toRed(this.curve.red).redMul(t);\n  if (this.x.cmp(i) === 0)\n    return !0;\n  for (var n = e.clone(), s = this.curve.redN.redMul(t); ; ) {\n    if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)\n      return !1;\n    if (i.redIAdd(s), this.x.cmp(i) === 0)\n      return !0;\n  }\n};\nTt.prototype.inspect = function() {\n  return this.isInfinity() ? \"<EC JPoint Infinity>\" : \"<EC JPoint x: \" + this.x.toString(16, 2) + \" y: \" + this.y.toString(16, 2) + \" z: \" + this.z.toString(16, 2) + \">\";\n};\nTt.prototype.isInfinity = function() {\n  return this.z.cmpn(0) === 0;\n};\nvar on = li, Vu = ua, ga = ba, v2 = ar;\nfunction Sn(r) {\n  ga.call(this, \"mont\", r), this.a = new on(r.a, 16).toRed(this.red), this.b = new on(r.b, 16).toRed(this.red), this.i4 = new on(4).toRed(this.red).redInvm(), this.two = new on(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));\n}\nVu(Sn, ga);\nvar b2 = Sn;\nSn.prototype.validate = function(e) {\n  var t = e.normalize().x, i = t.redSqr(), n = i.redMul(t).redAdd(i.redMul(this.a)).redAdd(t), s = n.redSqrt();\n  return s.redSqr().cmp(n) === 0;\n};\nfunction At(r, e, t) {\n  ga.BasePoint.call(this, r, \"projective\"), e === null && t === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new on(e, 16), this.z = new on(t, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));\n}\nVu(At, ga.BasePoint);\nSn.prototype.decodePoint = function(e, t) {\n  return this.point(v2.toArray(e, t), 1);\n};\nSn.prototype.point = function(e, t) {\n  return new At(this, e, t);\n};\nSn.prototype.pointFromJSON = function(e) {\n  return At.fromJSON(this, e);\n};\nAt.prototype.precompute = function() {\n};\nAt.prototype._encode = function() {\n  return this.getX().toArray(\"be\", this.curve.p.byteLength());\n};\nAt.fromJSON = function(e, t) {\n  return new At(e, t[0], t[1] || e.one);\n};\nAt.prototype.inspect = function() {\n  return this.isInfinity() ? \"<EC Point Infinity>\" : \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" z: \" + this.z.fromRed().toString(16, 2) + \">\";\n};\nAt.prototype.isInfinity = function() {\n  return this.z.cmpn(0) === 0;\n};\nAt.prototype.dbl = function() {\n  var e = this.x.redAdd(this.z), t = e.redSqr(), i = this.x.redSub(this.z), n = i.redSqr(), s = t.redSub(n), o = t.redMul(n), f = s.redMul(n.redAdd(this.curve.a24.redMul(s)));\n  return this.curve.point(o, f);\n};\nAt.prototype.add = function() {\n  throw new Error(\"Not supported on Montgomery curve\");\n};\nAt.prototype.diffAdd = function(e, t) {\n  var i = this.x.redAdd(this.z), n = this.x.redSub(this.z), s = e.x.redAdd(e.z), o = e.x.redSub(e.z), f = o.redMul(i), h = s.redMul(n), d = t.z.redMul(f.redAdd(h).redSqr()), v = t.x.redMul(f.redISub(h).redSqr());\n  return this.curve.point(d, v);\n};\nAt.prototype.mul = function(e) {\n  for (var t = e.clone(), i = this, n = this.curve.point(null, null), s = this, o = []; t.cmpn(0) !== 0; t.iushrn(1))\n    o.push(t.andln(1));\n  for (var f = o.length - 1; f >= 0; f--)\n    o[f] === 0 ? (i = i.diffAdd(n, s), n = n.dbl()) : (n = i.diffAdd(n, s), i = i.dbl());\n  return n;\n};\nAt.prototype.mulAdd = function() {\n  throw new Error(\"Not supported on Montgomery curve\");\n};\nAt.prototype.jumlAdd = function() {\n  throw new Error(\"Not supported on Montgomery curve\");\n};\nAt.prototype.eq = function(e) {\n  return this.getX().cmp(e.getX()) === 0;\n};\nAt.prototype.normalize = function() {\n  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;\n};\nAt.prototype.getX = function() {\n  return this.normalize(), this.x.fromRed();\n};\nvar g2 = ar, ci = li, Wu = ua, ya = ba, y2 = g2.assert;\nfunction Hr(r) {\n  this.twisted = (r.a | 0) !== 1, this.mOneA = this.twisted && (r.a | 0) === -1, this.extended = this.mOneA, ya.call(this, \"edwards\", r), this.a = new ci(r.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new ci(r.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new ci(r.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), y2(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (r.c | 0) === 1;\n}\nWu(Hr, ya);\nvar m2 = Hr;\nHr.prototype._mulA = function(e) {\n  return this.mOneA ? e.redNeg() : this.a.redMul(e);\n};\nHr.prototype._mulC = function(e) {\n  return this.oneC ? e : this.c.redMul(e);\n};\nHr.prototype.jpoint = function(e, t, i, n) {\n  return this.point(e, t, i, n);\n};\nHr.prototype.pointFromX = function(e, t) {\n  e = new ci(e, 16), e.red || (e = e.toRed(this.red));\n  var i = e.redSqr(), n = this.c2.redSub(this.a.redMul(i)), s = this.one.redSub(this.c2.redMul(this.d).redMul(i)), o = n.redMul(s.redInvm()), f = o.redSqrt();\n  if (f.redSqr().redSub(o).cmp(this.zero) !== 0)\n    throw new Error(\"invalid point\");\n  var h = f.fromRed().isOdd();\n  return (t && !h || !t && h) && (f = f.redNeg()), this.point(e, f);\n};\nHr.prototype.pointFromY = function(e, t) {\n  e = new ci(e, 16), e.red || (e = e.toRed(this.red));\n  var i = e.redSqr(), n = i.redSub(this.c2), s = i.redMul(this.d).redMul(this.c2).redSub(this.a), o = n.redMul(s.redInvm());\n  if (o.cmp(this.zero) === 0) {\n    if (t)\n      throw new Error(\"invalid point\");\n    return this.point(this.zero, e);\n  }\n  var f = o.redSqrt();\n  if (f.redSqr().redSub(o).cmp(this.zero) !== 0)\n    throw new Error(\"invalid point\");\n  return f.fromRed().isOdd() !== t && (f = f.redNeg()), this.point(f, e);\n};\nHr.prototype.validate = function(e) {\n  if (e.isInfinity())\n    return !0;\n  e.normalize();\n  var t = e.x.redSqr(), i = e.y.redSqr(), n = t.redMul(this.a).redAdd(i), s = this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(i)));\n  return n.cmp(s) === 0;\n};\nfunction ft(r, e, t, i, n) {\n  ya.BasePoint.call(this, r, \"projective\"), e === null && t === null && i === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new ci(e, 16), this.y = new ci(t, 16), this.z = i ? new ci(i, 16) : this.curve.one, this.t = n && new ci(n, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));\n}\nWu(ft, ya.BasePoint);\nHr.prototype.pointFromJSON = function(e) {\n  return ft.fromJSON(this, e);\n};\nHr.prototype.point = function(e, t, i, n) {\n  return new ft(this, e, t, i, n);\n};\nft.fromJSON = function(e, t) {\n  return new ft(e, t[0], t[1], t[2]);\n};\nft.prototype.inspect = function() {\n  return this.isInfinity() ? \"<EC Point Infinity>\" : \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" y: \" + this.y.fromRed().toString(16, 2) + \" z: \" + this.z.fromRed().toString(16, 2) + \">\";\n};\nft.prototype.isInfinity = function() {\n  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);\n};\nft.prototype._extDbl = function() {\n  var e = this.x.redSqr(), t = this.y.redSqr(), i = this.z.redSqr();\n  i = i.redIAdd(i);\n  var n = this.curve._mulA(e), s = this.x.redAdd(this.y).redSqr().redISub(e).redISub(t), o = n.redAdd(t), f = o.redSub(i), h = n.redSub(t), d = s.redMul(f), v = o.redMul(h), w = s.redMul(h), A = f.redMul(o);\n  return this.curve.point(d, v, A, w);\n};\nft.prototype._projDbl = function() {\n  var e = this.x.redAdd(this.y).redSqr(), t = this.x.redSqr(), i = this.y.redSqr(), n, s, o, f, h, d;\n  if (this.curve.twisted) {\n    f = this.curve._mulA(t);\n    var v = f.redAdd(i);\n    this.zOne ? (n = e.redSub(t).redSub(i).redMul(v.redSub(this.curve.two)), s = v.redMul(f.redSub(i)), o = v.redSqr().redSub(v).redSub(v)) : (h = this.z.redSqr(), d = v.redSub(h).redISub(h), n = e.redSub(t).redISub(i).redMul(d), s = v.redMul(f.redSub(i)), o = v.redMul(d));\n  } else\n    f = t.redAdd(i), h = this.curve._mulC(this.z).redSqr(), d = f.redSub(h).redSub(h), n = this.curve._mulC(e.redISub(f)).redMul(d), s = this.curve._mulC(f).redMul(t.redISub(i)), o = f.redMul(d);\n  return this.curve.point(n, s, o);\n};\nft.prototype.dbl = function() {\n  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();\n};\nft.prototype._extAdd = function(e) {\n  var t = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), i = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), n = this.t.redMul(this.curve.dd).redMul(e.t), s = this.z.redMul(e.z.redAdd(e.z)), o = i.redSub(t), f = s.redSub(n), h = s.redAdd(n), d = i.redAdd(t), v = o.redMul(f), w = h.redMul(d), A = o.redMul(d), I = f.redMul(h);\n  return this.curve.point(v, w, I, A);\n};\nft.prototype._projAdd = function(e) {\n  var t = this.z.redMul(e.z), i = t.redSqr(), n = this.x.redMul(e.x), s = this.y.redMul(e.y), o = this.curve.d.redMul(n).redMul(s), f = i.redSub(o), h = i.redAdd(o), d = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(n).redISub(s), v = t.redMul(f).redMul(d), w, A;\n  return this.curve.twisted ? (w = t.redMul(h).redMul(s.redSub(this.curve._mulA(n))), A = f.redMul(h)) : (w = t.redMul(h).redMul(s.redSub(n)), A = this.curve._mulC(f).redMul(h)), this.curve.point(v, w, A);\n};\nft.prototype.add = function(e) {\n  return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);\n};\nft.prototype.mul = function(e) {\n  return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);\n};\nft.prototype.mulAdd = function(e, t, i) {\n  return this.curve._wnafMulAdd(1, [this, t], [e, i], 2, !1);\n};\nft.prototype.jmulAdd = function(e, t, i) {\n  return this.curve._wnafMulAdd(1, [this, t], [e, i], 2, !0);\n};\nft.prototype.normalize = function() {\n  if (this.zOne)\n    return this;\n  var e = this.z.redInvm();\n  return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;\n};\nft.prototype.neg = function() {\n  return this.curve.point(\n    this.x.redNeg(),\n    this.y,\n    this.z,\n    this.t && this.t.redNeg()\n  );\n};\nft.prototype.getX = function() {\n  return this.normalize(), this.x.fromRed();\n};\nft.prototype.getY = function() {\n  return this.normalize(), this.y.fromRed();\n};\nft.prototype.eq = function(e) {\n  return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;\n};\nft.prototype.eqXToP = function(e) {\n  var t = e.toRed(this.curve.red).redMul(this.z);\n  if (this.x.cmp(t) === 0)\n    return !0;\n  for (var i = e.clone(), n = this.curve.redN.redMul(this.z); ; ) {\n    if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)\n      return !1;\n    if (t.redIAdd(n), this.x.cmp(t) === 0)\n      return !0;\n  }\n};\nft.prototype.toP = ft.prototype.normalize;\nft.prototype.mixedAdd = ft.prototype.add;\n(function(r) {\n  var e = r;\n  e.base = ba, e.short = p2, e.mont = b2, e.edwards = m2;\n})(Yo);\nvar ma = {}, Ya, yc;\nfunction w2() {\n  return yc || (yc = 1, Ya = {\n    doubles: {\n      step: 4,\n      points: [\n        [\n          \"e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a\",\n          \"f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821\"\n        ],\n        [\n          \"8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508\",\n          \"11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n        ],\n        [\n          \"175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739\",\n          \"d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695\"\n        ],\n        [\n          \"363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640\",\n          \"4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9\"\n        ],\n        [\n          \"8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c\",\n          \"4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36\"\n        ],\n        [\n          \"723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda\",\n          \"96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f\"\n        ],\n        [\n          \"eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa\",\n          \"5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999\"\n        ],\n        [\n          \"100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0\",\n          \"cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09\"\n        ],\n        [\n          \"e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d\",\n          \"9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d\"\n        ],\n        [\n          \"feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d\",\n          \"e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088\"\n        ],\n        [\n          \"da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1\",\n          \"9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d\"\n        ],\n        [\n          \"53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0\",\n          \"5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8\"\n        ],\n        [\n          \"8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047\",\n          \"10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a\"\n        ],\n        [\n          \"385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862\",\n          \"283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453\"\n        ],\n        [\n          \"6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7\",\n          \"7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160\"\n        ],\n        [\n          \"3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd\",\n          \"56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0\"\n        ],\n        [\n          \"85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83\",\n          \"7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6\"\n        ],\n        [\n          \"948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a\",\n          \"53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589\"\n        ],\n        [\n          \"6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8\",\n          \"bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17\"\n        ],\n        [\n          \"e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d\",\n          \"4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda\"\n        ],\n        [\n          \"e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725\",\n          \"7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd\"\n        ],\n        [\n          \"213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754\",\n          \"4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2\"\n        ],\n        [\n          \"4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c\",\n          \"17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6\"\n        ],\n        [\n          \"fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6\",\n          \"6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f\"\n        ],\n        [\n          \"76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39\",\n          \"c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01\"\n        ],\n        [\n          \"c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891\",\n          \"893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3\"\n        ],\n        [\n          \"d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b\",\n          \"febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f\"\n        ],\n        [\n          \"b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03\",\n          \"2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7\"\n        ],\n        [\n          \"e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d\",\n          \"eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78\"\n        ],\n        [\n          \"a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070\",\n          \"7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1\"\n        ],\n        [\n          \"90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4\",\n          \"e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150\"\n        ],\n        [\n          \"8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da\",\n          \"662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82\"\n        ],\n        [\n          \"e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11\",\n          \"1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc\"\n        ],\n        [\n          \"8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e\",\n          \"efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b\"\n        ],\n        [\n          \"e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41\",\n          \"2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51\"\n        ],\n        [\n          \"b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef\",\n          \"67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45\"\n        ],\n        [\n          \"d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8\",\n          \"db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120\"\n        ],\n        [\n          \"324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d\",\n          \"648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84\"\n        ],\n        [\n          \"4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96\",\n          \"35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d\"\n        ],\n        [\n          \"9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd\",\n          \"ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d\"\n        ],\n        [\n          \"6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5\",\n          \"9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8\"\n        ],\n        [\n          \"a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266\",\n          \"40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8\"\n        ],\n        [\n          \"7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71\",\n          \"34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac\"\n        ],\n        [\n          \"928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac\",\n          \"c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f\"\n        ],\n        [\n          \"85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751\",\n          \"1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962\"\n        ],\n        [\n          \"ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e\",\n          \"493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907\"\n        ],\n        [\n          \"827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241\",\n          \"c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec\"\n        ],\n        [\n          \"eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3\",\n          \"be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d\"\n        ],\n        [\n          \"e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f\",\n          \"4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414\"\n        ],\n        [\n          \"1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19\",\n          \"aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd\"\n        ],\n        [\n          \"146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be\",\n          \"b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0\"\n        ],\n        [\n          \"fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9\",\n          \"6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811\"\n        ],\n        [\n          \"da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2\",\n          \"8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1\"\n        ],\n        [\n          \"a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13\",\n          \"7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c\"\n        ],\n        [\n          \"174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c\",\n          \"ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73\"\n        ],\n        [\n          \"959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba\",\n          \"2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd\"\n        ],\n        [\n          \"d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151\",\n          \"e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405\"\n        ],\n        [\n          \"64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073\",\n          \"d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589\"\n        ],\n        [\n          \"8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458\",\n          \"38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e\"\n        ],\n        [\n          \"13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b\",\n          \"69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27\"\n        ],\n        [\n          \"bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366\",\n          \"d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1\"\n        ],\n        [\n          \"8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa\",\n          \"40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482\"\n        ],\n        [\n          \"8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0\",\n          \"620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945\"\n        ],\n        [\n          \"dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787\",\n          \"7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573\"\n        ],\n        [\n          \"f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e\",\n          \"ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82\"\n        ]\n      ]\n    },\n    naf: {\n      wnd: 7,\n      points: [\n        [\n          \"f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9\",\n          \"388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672\"\n        ],\n        [\n          \"2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4\",\n          \"d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6\"\n        ],\n        [\n          \"5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc\",\n          \"6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da\"\n        ],\n        [\n          \"acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe\",\n          \"cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37\"\n        ],\n        [\n          \"774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb\",\n          \"d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b\"\n        ],\n        [\n          \"f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8\",\n          \"ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81\"\n        ],\n        [\n          \"d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e\",\n          \"581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58\"\n        ],\n        [\n          \"defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34\",\n          \"4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77\"\n        ],\n        [\n          \"2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c\",\n          \"85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a\"\n        ],\n        [\n          \"352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5\",\n          \"321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c\"\n        ],\n        [\n          \"2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f\",\n          \"2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67\"\n        ],\n        [\n          \"9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714\",\n          \"73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402\"\n        ],\n        [\n          \"daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729\",\n          \"a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55\"\n        ],\n        [\n          \"c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db\",\n          \"2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482\"\n        ],\n        [\n          \"6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4\",\n          \"e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82\"\n        ],\n        [\n          \"1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5\",\n          \"b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396\"\n        ],\n        [\n          \"605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479\",\n          \"2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49\"\n        ],\n        [\n          \"62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d\",\n          \"80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf\"\n        ],\n        [\n          \"80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f\",\n          \"1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a\"\n        ],\n        [\n          \"7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb\",\n          \"d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7\"\n        ],\n        [\n          \"d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9\",\n          \"eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933\"\n        ],\n        [\n          \"49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963\",\n          \"758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a\"\n        ],\n        [\n          \"77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74\",\n          \"958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6\"\n        ],\n        [\n          \"f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530\",\n          \"e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37\"\n        ],\n        [\n          \"463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b\",\n          \"5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e\"\n        ],\n        [\n          \"f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247\",\n          \"cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6\"\n        ],\n        [\n          \"caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1\",\n          \"cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476\"\n        ],\n        [\n          \"2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120\",\n          \"4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40\"\n        ],\n        [\n          \"7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435\",\n          \"91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61\"\n        ],\n        [\n          \"754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18\",\n          \"673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683\"\n        ],\n        [\n          \"e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8\",\n          \"59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5\"\n        ],\n        [\n          \"186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb\",\n          \"3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b\"\n        ],\n        [\n          \"df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f\",\n          \"55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417\"\n        ],\n        [\n          \"5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143\",\n          \"efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868\"\n        ],\n        [\n          \"290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba\",\n          \"e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a\"\n        ],\n        [\n          \"af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45\",\n          \"f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6\"\n        ],\n        [\n          \"766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a\",\n          \"744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996\"\n        ],\n        [\n          \"59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e\",\n          \"c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e\"\n        ],\n        [\n          \"f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8\",\n          \"e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d\"\n        ],\n        [\n          \"7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c\",\n          \"30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2\"\n        ],\n        [\n          \"948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519\",\n          \"e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e\"\n        ],\n        [\n          \"7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab\",\n          \"100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437\"\n        ],\n        [\n          \"3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca\",\n          \"ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311\"\n        ],\n        [\n          \"d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf\",\n          \"8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4\"\n        ],\n        [\n          \"1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610\",\n          \"68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575\"\n        ],\n        [\n          \"733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4\",\n          \"f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d\"\n        ],\n        [\n          \"15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c\",\n          \"d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d\"\n        ],\n        [\n          \"a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940\",\n          \"edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629\"\n        ],\n        [\n          \"e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980\",\n          \"a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06\"\n        ],\n        [\n          \"311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3\",\n          \"66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374\"\n        ],\n        [\n          \"34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf\",\n          \"9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee\"\n        ],\n        [\n          \"f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63\",\n          \"4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1\"\n        ],\n        [\n          \"d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448\",\n          \"fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b\"\n        ],\n        [\n          \"32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf\",\n          \"5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661\"\n        ],\n        [\n          \"7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5\",\n          \"8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6\"\n        ],\n        [\n          \"ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6\",\n          \"8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e\"\n        ],\n        [\n          \"16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5\",\n          \"5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d\"\n        ],\n        [\n          \"eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99\",\n          \"f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc\"\n        ],\n        [\n          \"78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51\",\n          \"f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4\"\n        ],\n        [\n          \"494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5\",\n          \"42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c\"\n        ],\n        [\n          \"a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5\",\n          \"204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b\"\n        ],\n        [\n          \"c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997\",\n          \"4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913\"\n        ],\n        [\n          \"841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881\",\n          \"73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154\"\n        ],\n        [\n          \"5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5\",\n          \"39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865\"\n        ],\n        [\n          \"36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66\",\n          \"d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc\"\n        ],\n        [\n          \"336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726\",\n          \"ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224\"\n        ],\n        [\n          \"8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede\",\n          \"6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e\"\n        ],\n        [\n          \"1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94\",\n          \"60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6\"\n        ],\n        [\n          \"85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31\",\n          \"3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511\"\n        ],\n        [\n          \"29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51\",\n          \"b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b\"\n        ],\n        [\n          \"a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252\",\n          \"ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2\"\n        ],\n        [\n          \"4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5\",\n          \"cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c\"\n        ],\n        [\n          \"d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b\",\n          \"6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3\"\n        ],\n        [\n          \"ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4\",\n          \"322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d\"\n        ],\n        [\n          \"af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f\",\n          \"6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700\"\n        ],\n        [\n          \"e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889\",\n          \"2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4\"\n        ],\n        [\n          \"591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246\",\n          \"b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196\"\n        ],\n        [\n          \"11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984\",\n          \"998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4\"\n        ],\n        [\n          \"3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a\",\n          \"b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257\"\n        ],\n        [\n          \"cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030\",\n          \"bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13\"\n        ],\n        [\n          \"c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197\",\n          \"6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096\"\n        ],\n        [\n          \"c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593\",\n          \"c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38\"\n        ],\n        [\n          \"a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef\",\n          \"21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f\"\n        ],\n        [\n          \"347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38\",\n          \"60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448\"\n        ],\n        [\n          \"da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a\",\n          \"49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a\"\n        ],\n        [\n          \"c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111\",\n          \"5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4\"\n        ],\n        [\n          \"4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502\",\n          \"7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437\"\n        ],\n        [\n          \"3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea\",\n          \"be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7\"\n        ],\n        [\n          \"cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26\",\n          \"8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d\"\n        ],\n        [\n          \"b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986\",\n          \"39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a\"\n        ],\n        [\n          \"d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e\",\n          \"62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54\"\n        ],\n        [\n          \"48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4\",\n          \"25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77\"\n        ],\n        [\n          \"dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda\",\n          \"ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517\"\n        ],\n        [\n          \"6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859\",\n          \"cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10\"\n        ],\n        [\n          \"e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f\",\n          \"f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125\"\n        ],\n        [\n          \"eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c\",\n          \"6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e\"\n        ],\n        [\n          \"13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942\",\n          \"fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1\"\n        ],\n        [\n          \"ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a\",\n          \"1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2\"\n        ],\n        [\n          \"b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80\",\n          \"5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423\"\n        ],\n        [\n          \"ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d\",\n          \"438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8\"\n        ],\n        [\n          \"8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1\",\n          \"cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758\"\n        ],\n        [\n          \"52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63\",\n          \"c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375\"\n        ],\n        [\n          \"e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352\",\n          \"6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d\"\n        ],\n        [\n          \"7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193\",\n          \"ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec\"\n        ],\n        [\n          \"5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00\",\n          \"9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0\"\n        ],\n        [\n          \"32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58\",\n          \"ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c\"\n        ],\n        [\n          \"e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7\",\n          \"d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4\"\n        ],\n        [\n          \"8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8\",\n          \"c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f\"\n        ],\n        [\n          \"4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e\",\n          \"67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649\"\n        ],\n        [\n          \"3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d\",\n          \"cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826\"\n        ],\n        [\n          \"674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b\",\n          \"299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5\"\n        ],\n        [\n          \"d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f\",\n          \"f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87\"\n        ],\n        [\n          \"30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6\",\n          \"462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b\"\n        ],\n        [\n          \"be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297\",\n          \"62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc\"\n        ],\n        [\n          \"93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a\",\n          \"7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c\"\n        ],\n        [\n          \"b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c\",\n          \"ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f\"\n        ],\n        [\n          \"d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52\",\n          \"4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a\"\n        ],\n        [\n          \"d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb\",\n          \"bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46\"\n        ],\n        [\n          \"463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065\",\n          \"bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f\"\n        ],\n        [\n          \"7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917\",\n          \"603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03\"\n        ],\n        [\n          \"74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9\",\n          \"cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08\"\n        ],\n        [\n          \"30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3\",\n          \"553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8\"\n        ],\n        [\n          \"9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57\",\n          \"712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373\"\n        ],\n        [\n          \"176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66\",\n          \"ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3\"\n        ],\n        [\n          \"75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8\",\n          \"9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8\"\n        ],\n        [\n          \"809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721\",\n          \"9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1\"\n        ],\n        [\n          \"1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180\",\n          \"4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9\"\n        ]\n      ]\n    }\n  }), Ya;\n}\n(function(r) {\n  var e = r, t = ns, i = Yo, n = ar, s = n.assert;\n  function o(d) {\n    d.type === \"short\" ? this.curve = new i.short(d) : d.type === \"edwards\" ? this.curve = new i.edwards(d) : this.curve = new i.mont(d), this.g = this.curve.g, this.n = this.curve.n, this.hash = d.hash, s(this.g.validate(), \"Invalid curve\"), s(this.g.mul(this.n).isInfinity(), \"Invalid curve, G*N != O\");\n  }\n  e.PresetCurve = o;\n  function f(d, v) {\n    Object.defineProperty(e, d, {\n      configurable: !0,\n      enumerable: !0,\n      get: function() {\n        var w = new o(v);\n        return Object.defineProperty(e, d, {\n          configurable: !0,\n          enumerable: !0,\n          value: w\n        }), w;\n      }\n    });\n  }\n  f(\"p192\", {\n    type: \"short\",\n    prime: \"p192\",\n    p: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\",\n    a: \"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc\",\n    b: \"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1\",\n    n: \"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831\",\n    hash: t.sha256,\n    gRed: !1,\n    g: [\n      \"188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012\",\n      \"07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811\"\n    ]\n  }), f(\"p224\", {\n    type: \"short\",\n    prime: \"p224\",\n    p: \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\",\n    a: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe\",\n    b: \"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4\",\n    n: \"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d\",\n    hash: t.sha256,\n    gRed: !1,\n    g: [\n      \"b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21\",\n      \"bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34\"\n    ]\n  }), f(\"p256\", {\n    type: \"short\",\n    prime: null,\n    p: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff\",\n    a: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc\",\n    b: \"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b\",\n    n: \"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551\",\n    hash: t.sha256,\n    gRed: !1,\n    g: [\n      \"6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296\",\n      \"4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5\"\n    ]\n  }), f(\"p384\", {\n    type: \"short\",\n    prime: null,\n    p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff\",\n    a: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc\",\n    b: \"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef\",\n    n: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973\",\n    hash: t.sha384,\n    gRed: !1,\n    g: [\n      \"aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7\",\n      \"3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f\"\n    ]\n  }), f(\"p521\", {\n    type: \"short\",\n    prime: null,\n    p: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff\",\n    a: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc\",\n    b: \"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00\",\n    n: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409\",\n    hash: t.sha512,\n    gRed: !1,\n    g: [\n      \"000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66\",\n      \"00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650\"\n    ]\n  }), f(\"curve25519\", {\n    type: \"mont\",\n    prime: \"p25519\",\n    p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n    a: \"76d06\",\n    b: \"1\",\n    n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n    hash: t.sha256,\n    gRed: !1,\n    g: [\n      \"9\"\n    ]\n  }), f(\"ed25519\", {\n    type: \"edwards\",\n    prime: \"p25519\",\n    p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n    a: \"-1\",\n    c: \"1\",\n    // -121665 * (121666^(-1)) (mod P)\n    d: \"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3\",\n    n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n    hash: t.sha256,\n    gRed: !1,\n    g: [\n      \"216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\",\n      // 4/5\n      \"6666666666666666666666666666666666666666666666666666666666666658\"\n    ]\n  });\n  var h;\n  try {\n    h = w2();\n  } catch {\n    h = void 0;\n  }\n  f(\"secp256k1\", {\n    type: \"short\",\n    prime: \"k256\",\n    p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\",\n    a: \"0\",\n    b: \"7\",\n    n: \"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141\",\n    h: \"1\",\n    hash: t.sha256,\n    // Precomputed endomorphism\n    beta: \"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\",\n    lambda: \"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72\",\n    basis: [\n      {\n        a: \"3086d221a7d46bcde86c90e49284eb15\",\n        b: \"-e4437ed6010e88286f547fa90abfe4c3\"\n      },\n      {\n        a: \"114ca50f7a8e2f3f657c1108d9d44cfd8\",\n        b: \"3086d221a7d46bcde86c90e49284eb15\"\n      }\n    ],\n    gRed: !1,\n    g: [\n      \"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n      \"483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n      h\n    ]\n  });\n})(ma);\nvar _2 = ns, ki = Go, Gu = Yi;\nfunction xi(r) {\n  if (!(this instanceof xi))\n    return new xi(r);\n  this.hash = r.hash, this.predResist = !!r.predResist, this.outLen = this.hash.outSize, this.minEntropy = r.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;\n  var e = ki.toArray(r.entropy, r.entropyEnc || \"hex\"), t = ki.toArray(r.nonce, r.nonceEnc || \"hex\"), i = ki.toArray(r.pers, r.persEnc || \"hex\");\n  Gu(\n    e.length >= this.minEntropy / 8,\n    \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\"\n  ), this._init(e, t, i);\n}\nvar x2 = xi;\nxi.prototype._init = function(e, t, i) {\n  var n = e.concat(t).concat(i);\n  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);\n  for (var s = 0; s < this.V.length; s++)\n    this.K[s] = 0, this.V[s] = 1;\n  this._update(n), this._reseed = 1, this.reseedInterval = 281474976710656;\n};\nxi.prototype._hmac = function() {\n  return new _2.hmac(this.hash, this.K);\n};\nxi.prototype._update = function(e) {\n  var t = this._hmac().update(this.V).update([0]);\n  e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());\n};\nxi.prototype.reseed = function(e, t, i, n) {\n  typeof t != \"string\" && (n = i, i = t, t = null), e = ki.toArray(e, t), i = ki.toArray(i, n), Gu(\n    e.length >= this.minEntropy / 8,\n    \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\"\n  ), this._update(e.concat(i || [])), this._reseed = 1;\n};\nxi.prototype.generate = function(e, t, i, n) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error(\"Reseed is required\");\n  typeof t != \"string\" && (n = i, i = t, t = null), i && (i = ki.toArray(i, n || \"hex\"), this._update(i));\n  for (var s = []; s.length < e; )\n    this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);\n  var o = s.slice(0, e);\n  return this._update(i), this._reseed++, ki.encode(o, t);\n};\nvar E2 = li, S2 = ar, Mo = S2.assert;\nfunction Ut(r, e) {\n  this.ec = r, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);\n}\nvar M2 = Ut;\nUt.fromPublic = function(e, t, i) {\n  return t instanceof Ut ? t : new Ut(e, {\n    pub: t,\n    pubEnc: i\n  });\n};\nUt.fromPrivate = function(e, t, i) {\n  return t instanceof Ut ? t : new Ut(e, {\n    priv: t,\n    privEnc: i\n  });\n};\nUt.prototype.validate = function() {\n  var e = this.getPublic();\n  return e.isInfinity() ? { result: !1, reason: \"Invalid public key\" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: \"Public key * N != O\" } : { result: !1, reason: \"Public key is not a point\" };\n};\nUt.prototype.getPublic = function(e, t) {\n  return typeof e == \"string\" && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub;\n};\nUt.prototype.getPrivate = function(e) {\n  return e === \"hex\" ? this.priv.toString(16, 2) : this.priv;\n};\nUt.prototype._importPrivate = function(e, t) {\n  this.priv = new E2(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n);\n};\nUt.prototype._importPublic = function(e, t) {\n  if (e.x || e.y) {\n    this.ec.curve.type === \"mont\" ? Mo(e.x, \"Need x coordinate\") : (this.ec.curve.type === \"short\" || this.ec.curve.type === \"edwards\") && Mo(e.x && e.y, \"Need both x and y coordinate\"), this.pub = this.ec.curve.point(e.x, e.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(e, t);\n};\nUt.prototype.derive = function(e) {\n  return e.validate() || Mo(e.validate(), \"public point not validated\"), e.mul(this.priv).getX();\n};\nUt.prototype.sign = function(e, t, i) {\n  return this.ec.sign(e, this, t, i);\n};\nUt.prototype.verify = function(e, t, i) {\n  return this.ec.verify(e, t, this, void 0, i);\n};\nUt.prototype.inspect = function() {\n  return \"<Key priv: \" + (this.priv && this.priv.toString(16, 2)) + \" pub: \" + (this.pub && this.pub.inspect()) + \" >\";\n};\nvar Ws = li, Zo = ar, I2 = Zo.assert;\nfunction wa(r, e) {\n  if (r instanceof wa)\n    return r;\n  this._importDER(r, e) || (I2(r.r && r.s, \"Signature without r or s\"), this.r = new Ws(r.r, 16), this.s = new Ws(r.s, 16), r.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = r.recoveryParam);\n}\nvar A2 = wa;\nfunction D2() {\n  this.place = 0;\n}\nfunction Xa(r, e) {\n  var t = r[e.place++];\n  if (!(t & 128))\n    return t;\n  var i = t & 15;\n  if (i === 0 || i > 4 || r[e.place] === 0)\n    return !1;\n  for (var n = 0, s = 0, o = e.place; s < i; s++, o++)\n    n <<= 8, n |= r[o], n >>>= 0;\n  return n <= 127 ? !1 : (e.place = o, n);\n}\nfunction mc(r) {\n  for (var e = 0, t = r.length - 1; !r[e] && !(r[e + 1] & 128) && e < t; )\n    e++;\n  return e === 0 ? r : r.slice(e);\n}\nwa.prototype._importDER = function(e, t) {\n  e = Zo.toArray(e, t);\n  var i = new D2();\n  if (e[i.place++] !== 48)\n    return !1;\n  var n = Xa(e, i);\n  if (n === !1 || n + i.place !== e.length || e[i.place++] !== 2)\n    return !1;\n  var s = Xa(e, i);\n  if (s === !1 || e[i.place] & 128)\n    return !1;\n  var o = e.slice(i.place, s + i.place);\n  if (i.place += s, e[i.place++] !== 2)\n    return !1;\n  var f = Xa(e, i);\n  if (f === !1 || e.length !== f + i.place || e[i.place] & 128)\n    return !1;\n  var h = e.slice(i.place, f + i.place);\n  if (o[0] === 0)\n    if (o[1] & 128)\n      o = o.slice(1);\n    else\n      return !1;\n  if (h[0] === 0)\n    if (h[1] & 128)\n      h = h.slice(1);\n    else\n      return !1;\n  return this.r = new Ws(o), this.s = new Ws(h), this.recoveryParam = null, !0;\n};\nfunction Za(r, e) {\n  if (e < 128) {\n    r.push(e);\n    return;\n  }\n  var t = 1 + (Math.log(e) / Math.LN2 >>> 3);\n  for (r.push(t | 128); --t; )\n    r.push(e >>> (t << 3) & 255);\n  r.push(e);\n}\nwa.prototype.toDER = function(e) {\n  var t = this.r.toArray(), i = this.s.toArray();\n  for (t[0] & 128 && (t = [0].concat(t)), i[0] & 128 && (i = [0].concat(i)), t = mc(t), i = mc(i); !i[0] && !(i[1] & 128); )\n    i = i.slice(1);\n  var n = [2];\n  Za(n, t.length), n = n.concat(t), n.push(2), Za(n, i.length);\n  var s = n.concat(i), o = [48];\n  return Za(o, s.length), o = o.concat(s), Zo.encode(o, e);\n};\nvar Ir = li, Ju = x2, P2 = ar, Qa = ma, O2 = Hu, Fi = P2.assert, Qo = M2, _a = A2;\nfunction pr(r) {\n  if (!(this instanceof pr))\n    return new pr(r);\n  typeof r == \"string\" && (Fi(\n    Object.prototype.hasOwnProperty.call(Qa, r),\n    \"Unknown curve \" + r\n  ), r = Qa[r]), r instanceof Qa.PresetCurve && (r = { curve: r }), this.curve = r.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = r.curve.g, this.g.precompute(r.curve.n.bitLength() + 1), this.hash = r.hash || r.curve.hash;\n}\nvar R2 = pr;\npr.prototype.keyPair = function(e) {\n  return new Qo(this, e);\n};\npr.prototype.keyFromPrivate = function(e, t) {\n  return Qo.fromPrivate(this, e, t);\n};\npr.prototype.keyFromPublic = function(e, t) {\n  return Qo.fromPublic(this, e, t);\n};\npr.prototype.genKeyPair = function(e) {\n  e || (e = {});\n  for (var t = new Ju({\n    hash: this.hash,\n    pers: e.pers,\n    persEnc: e.persEnc || \"utf8\",\n    entropy: e.entropy || O2(this.hash.hmacStrength),\n    entropyEnc: e.entropy && e.entropyEnc || \"utf8\",\n    nonce: this.n.toArray()\n  }), i = this.n.byteLength(), n = this.n.sub(new Ir(2)); ; ) {\n    var s = new Ir(t.generate(i));\n    if (!(s.cmp(n) > 0))\n      return s.iaddn(1), this.keyFromPrivate(s);\n  }\n};\npr.prototype._truncateToN = function(e, t, i) {\n  var n;\n  if (Ir.isBN(e) || typeof e == \"number\")\n    e = new Ir(e, 16), n = e.byteLength();\n  else if (typeof e == \"object\")\n    n = e.length, e = new Ir(e, 16);\n  else {\n    var s = e.toString();\n    n = s.length + 1 >>> 1, e = new Ir(s, 16);\n  }\n  typeof i != \"number\" && (i = n * 8);\n  var o = i - this.n.bitLength();\n  return o > 0 && (e = e.ushrn(o)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;\n};\npr.prototype.sign = function(e, t, i, n) {\n  if (typeof i == \"object\" && (n = i, i = null), n || (n = {}), typeof e != \"string\" && typeof e != \"number\" && !Ir.isBN(e)) {\n    Fi(\n      typeof e == \"object\" && e && typeof e.length == \"number\",\n      \"Expected message to be an array-like, a hex string, or a BN instance\"\n    ), Fi(e.length >>> 0 === e.length);\n    for (var s = 0; s < e.length; s++)\n      Fi((e[s] & 255) === e[s]);\n  }\n  t = this.keyFromPrivate(t, i), e = this._truncateToN(e, !1, n.msgBitLength), Fi(!e.isNeg(), \"Can not sign a negative message\");\n  var o = this.n.byteLength(), f = t.getPrivate().toArray(\"be\", o), h = e.toArray(\"be\", o);\n  Fi(new Ir(h).eq(e), \"Can not sign message\");\n  for (var d = new Ju({\n    hash: this.hash,\n    entropy: f,\n    nonce: h,\n    pers: n.pers,\n    persEnc: n.persEnc || \"utf8\"\n  }), v = this.n.sub(new Ir(1)), w = 0; ; w++) {\n    var A = n.k ? n.k(w) : new Ir(d.generate(this.n.byteLength()));\n    if (A = this._truncateToN(A, !0), !(A.cmpn(1) <= 0 || A.cmp(v) >= 0)) {\n      var I = this.g.mul(A);\n      if (!I.isInfinity()) {\n        var D = I.getX(), N = D.umod(this.n);\n        if (N.cmpn(0) !== 0) {\n          var k = A.invm(this.n).mul(N.mul(t.getPrivate()).iadd(e));\n          if (k = k.umod(this.n), k.cmpn(0) !== 0) {\n            var j = (I.getY().isOdd() ? 1 : 0) | (D.cmp(N) !== 0 ? 2 : 0);\n            return n.canonical && k.cmp(this.nh) > 0 && (k = this.n.sub(k), j ^= 1), new _a({ r: N, s: k, recoveryParam: j });\n          }\n        }\n      }\n    }\n  }\n};\npr.prototype.verify = function(e, t, i, n, s) {\n  s || (s = {}), e = this._truncateToN(e, !1, s.msgBitLength), i = this.keyFromPublic(i, n), t = new _a(t, \"hex\");\n  var o = t.r, f = t.s;\n  if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0 || f.cmpn(1) < 0 || f.cmp(this.n) >= 0)\n    return !1;\n  var h = f.invm(this.n), d = h.mul(e).umod(this.n), v = h.mul(o).umod(this.n), w;\n  return this.curve._maxwellTrick ? (w = this.g.jmulAdd(d, i.getPublic(), v), w.isInfinity() ? !1 : w.eqXToP(o)) : (w = this.g.mulAdd(d, i.getPublic(), v), w.isInfinity() ? !1 : w.getX().umod(this.n).cmp(o) === 0);\n};\npr.prototype.recoverPubKey = function(r, e, t, i) {\n  Fi((3 & t) === t, \"The recovery param is more than two bits\"), e = new _a(e, i);\n  var n = this.n, s = new Ir(r), o = e.r, f = e.s, h = t & 1, d = t >> 1;\n  if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && d)\n    throw new Error(\"Unable to find sencond key candinate\");\n  d ? o = this.curve.pointFromX(o.add(this.curve.n), h) : o = this.curve.pointFromX(o, h);\n  var v = e.r.invm(n), w = n.sub(s).mul(v).umod(n), A = f.mul(v).umod(n);\n  return this.g.mulAdd(w, o, A);\n};\npr.prototype.getKeyRecoveryParam = function(r, e, t, i) {\n  if (e = new _a(e, i), e.recoveryParam !== null)\n    return e.recoveryParam;\n  for (var n = 0; n < 4; n++) {\n    var s;\n    try {\n      s = this.recoverPubKey(r, e, n);\n    } catch {\n      continue;\n    }\n    if (s.eq(t))\n      return n;\n  }\n  throw new Error(\"Unable to find valid recovery factor\");\n};\nvar fs = ar, Yu = fs.assert, wc = fs.parseBytes, Mn = fs.cachedProperty;\nfunction It(r, e) {\n  this.eddsa = r, this._secret = wc(e.secret), r.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = wc(e.pub);\n}\nIt.fromPublic = function(e, t) {\n  return t instanceof It ? t : new It(e, { pub: t });\n};\nIt.fromSecret = function(e, t) {\n  return t instanceof It ? t : new It(e, { secret: t });\n};\nIt.prototype.secret = function() {\n  return this._secret;\n};\nMn(It, \"pubBytes\", function() {\n  return this.eddsa.encodePoint(this.pub());\n});\nMn(It, \"pub\", function() {\n  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());\n});\nMn(It, \"privBytes\", function() {\n  var e = this.eddsa, t = this.hash(), i = e.encodingLength - 1, n = t.slice(0, e.encodingLength);\n  return n[0] &= 248, n[i] &= 127, n[i] |= 64, n;\n});\nMn(It, \"priv\", function() {\n  return this.eddsa.decodeInt(this.privBytes());\n});\nMn(It, \"hash\", function() {\n  return this.eddsa.hash().update(this.secret()).digest();\n});\nMn(It, \"messagePrefix\", function() {\n  return this.hash().slice(this.eddsa.encodingLength);\n});\nIt.prototype.sign = function(e) {\n  return Yu(this._secret, \"KeyPair can only verify\"), this.eddsa.sign(e, this);\n};\nIt.prototype.verify = function(e, t) {\n  return this.eddsa.verify(e, t, this);\n};\nIt.prototype.getSecret = function(e) {\n  return Yu(this._secret, \"KeyPair is public only\"), fs.encode(this.secret(), e);\n};\nIt.prototype.getPublic = function(e) {\n  return fs.encode(this.pubBytes(), e);\n};\nvar N2 = It, T2 = li, xa = ar, _c = xa.assert, Ea = xa.cachedProperty, C2 = xa.parseBytes;\nfunction Zi(r, e) {\n  this.eddsa = r, typeof e != \"object\" && (e = C2(e)), Array.isArray(e) && (_c(e.length === r.encodingLength * 2, \"Signature has invalid size\"), e = {\n    R: e.slice(0, r.encodingLength),\n    S: e.slice(r.encodingLength)\n  }), _c(e.R && e.S, \"Signature without R or S\"), r.isPoint(e.R) && (this._R = e.R), e.S instanceof T2 && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;\n}\nEa(Zi, \"S\", function() {\n  return this.eddsa.decodeInt(this.Sencoded());\n});\nEa(Zi, \"R\", function() {\n  return this.eddsa.decodePoint(this.Rencoded());\n});\nEa(Zi, \"Rencoded\", function() {\n  return this.eddsa.encodePoint(this.R());\n});\nEa(Zi, \"Sencoded\", function() {\n  return this.eddsa.encodeInt(this.S());\n});\nZi.prototype.toBytes = function() {\n  return this.Rencoded().concat(this.Sencoded());\n};\nZi.prototype.toHex = function() {\n  return xa.encode(this.toBytes(), \"hex\").toUpperCase();\n};\nvar $2 = Zi, L2 = ns, F2 = ma, vn = ar, q2 = vn.assert, Xu = vn.parseBytes, Zu = N2, xc = $2;\nfunction Xt(r) {\n  if (q2(r === \"ed25519\", \"only tested with ed25519 so far\"), !(this instanceof Xt))\n    return new Xt(r);\n  r = F2[r].curve, this.curve = r, this.g = r.g, this.g.precompute(r.n.bitLength() + 1), this.pointClass = r.point().constructor, this.encodingLength = Math.ceil(r.n.bitLength() / 8), this.hash = L2.sha512;\n}\nvar U2 = Xt;\nXt.prototype.sign = function(e, t) {\n  e = Xu(e);\n  var i = this.keyFromSecret(t), n = this.hashInt(i.messagePrefix(), e), s = this.g.mul(n), o = this.encodePoint(s), f = this.hashInt(o, i.pubBytes(), e).mul(i.priv()), h = n.add(f).umod(this.curve.n);\n  return this.makeSignature({ R: s, S: h, Rencoded: o });\n};\nXt.prototype.verify = function(e, t, i) {\n  if (e = Xu(e), t = this.makeSignature(t), t.S().gte(t.eddsa.curve.n) || t.S().isNeg())\n    return !1;\n  var n = this.keyFromPublic(i), s = this.hashInt(t.Rencoded(), n.pubBytes(), e), o = this.g.mul(t.S()), f = t.R().add(n.pub().mul(s));\n  return f.eq(o);\n};\nXt.prototype.hashInt = function() {\n  for (var e = this.hash(), t = 0; t < arguments.length; t++)\n    e.update(arguments[t]);\n  return vn.intFromLE(e.digest()).umod(this.curve.n);\n};\nXt.prototype.keyFromPublic = function(e) {\n  return Zu.fromPublic(this, e);\n};\nXt.prototype.keyFromSecret = function(e) {\n  return Zu.fromSecret(this, e);\n};\nXt.prototype.makeSignature = function(e) {\n  return e instanceof xc ? e : new xc(this, e);\n};\nXt.prototype.encodePoint = function(e) {\n  var t = e.getY().toArray(\"le\", this.encodingLength);\n  return t[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, t;\n};\nXt.prototype.decodePoint = function(e) {\n  e = vn.parseBytes(e);\n  var t = e.length - 1, i = e.slice(0, t).concat(e[t] & -129), n = (e[t] & 128) !== 0, s = vn.intFromLE(i);\n  return this.curve.pointFromY(s, n);\n};\nXt.prototype.encodeInt = function(e) {\n  return e.toArray(\"le\", this.encodingLength);\n};\nXt.prototype.decodeInt = function(e) {\n  return vn.intFromLE(e);\n};\nXt.prototype.isPoint = function(e) {\n  return e instanceof this.pointClass;\n};\n(function(r) {\n  var e = r;\n  e.version = h2.version, e.utils = ar, e.rand = Hu, e.curve = Yo, e.curves = ma, e.ec = R2, e.eddsa = U2;\n})(Ku);\nconst z2 = { waku: { publish: \"waku_publish\", batchPublish: \"waku_batchPublish\", subscribe: \"waku_subscribe\", batchSubscribe: \"waku_batchSubscribe\", subscription: \"waku_subscription\", unsubscribe: \"waku_unsubscribe\", batchUnsubscribe: \"waku_batchUnsubscribe\", batchFetchMessages: \"waku_batchFetchMessages\" }, irn: { publish: \"irn_publish\", batchPublish: \"irn_batchPublish\", subscribe: \"irn_subscribe\", batchSubscribe: \"irn_batchSubscribe\", subscription: \"irn_subscription\", unsubscribe: \"irn_unsubscribe\", batchUnsubscribe: \"irn_batchUnsubscribe\", batchFetchMessages: \"irn_batchFetchMessages\" }, iridium: { publish: \"iridium_publish\", batchPublish: \"iridium_batchPublish\", subscribe: \"iridium_subscribe\", batchSubscribe: \"iridium_batchSubscribe\", subscription: \"iridium_subscription\", unsubscribe: \"iridium_unsubscribe\", batchUnsubscribe: \"iridium_batchUnsubscribe\", batchFetchMessages: \"iridium_batchFetchMessages\" } }, ef = \":\";\nfunction Ns(r) {\n  const [e, t] = r.split(ef);\n  return { namespace: e, reference: t };\n}\nfunction B2(r) {\n  const { namespace: e, reference: t } = r;\n  return [e, t].join(ef);\n}\nfunction k2(r) {\n  const [e, t, i] = r.split(ef);\n  return { namespace: e, reference: t, address: i };\n}\nfunction j2(r, e) {\n  const t = [];\n  return r.forEach((i) => {\n    const n = e(i);\n    t.includes(n) || t.push(n);\n  }), t;\n}\nfunction K2(r) {\n  const { namespace: e, reference: t } = k2(r);\n  return B2({ namespace: e, reference: t });\n}\nfunction H2(r) {\n  return j2(r, K2);\n}\nfunction Qu(r, e = []) {\n  const t = [];\n  return Object.keys(r).forEach((i) => {\n    if (e.length && !e.includes(i))\n      return;\n    const n = r[i];\n    t.push(...n.accounts);\n  }), t;\n}\nfunction ed(r, e = []) {\n  const t = [];\n  return Object.keys(r).forEach((i) => {\n    if (e.length && !e.includes(i))\n      return;\n    const n = r[i];\n    t.push(...H2(n.accounts));\n  }), t;\n}\nfunction V2(r, e = []) {\n  const t = [];\n  return Object.keys(r).forEach((i) => {\n    if (e.length && !e.includes(i))\n      return;\n    const n = r[i];\n    t.push(...tf(i, n));\n  }), t;\n}\nfunction tf(r, e) {\n  return r.includes(\":\") ? [r] : e.chains || [];\n}\nvar W2 = Object.defineProperty, Ec = Object.getOwnPropertySymbols, G2 = Object.prototype.hasOwnProperty, J2 = Object.prototype.propertyIsEnumerable, Sc = (r, e, t) => e in r ? W2(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Mc = (r, e) => {\n  for (var t in e || (e = {}))\n    G2.call(e, t) && Sc(r, t, e[t]);\n  if (Ec)\n    for (var t of Ec(e))\n      J2.call(e, t) && Sc(r, t, e[t]);\n  return r;\n};\nconst Y2 = \"ReactNative\", rr = { reactNative: \"react-native\", node: \"node\", browser: \"browser\", unknown: \"unknown\" }, X2 = \"js\";\nfunction Gs() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction Ai() {\n  return !is() && !!$o() && navigator.product === Y2;\n}\nfunction Z2() {\n  return Ai() && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\" && (global == null ? void 0 : global.Platform.OS) === \"android\";\n}\nfunction Q2() {\n  return Ai() && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\" && (global == null ? void 0 : global.Platform.OS) === \"ios\";\n}\nfunction cs() {\n  return !Gs() && !!$o() && !!is();\n}\nfunction hs() {\n  return Ai() ? rr.reactNative : Gs() ? rr.node : cs() ? rr.browser : rr.unknown;\n}\nfunction Ic() {\n  var r;\n  try {\n    return Ai() && typeof global < \"u\" && typeof (global == null ? void 0 : global.Application) < \"u\" ? (r = global.Application) == null ? void 0 : r.applicationId : void 0;\n  } catch {\n    return;\n  }\n}\nfunction ey(r, e) {\n  let t = Yn.parse(r);\n  return t = Mc(Mc({}, t), e), r = Yn.stringify(t), r;\n}\nfunction td() {\n  return uu() || { name: \"\", description: \"\", url: \"\", icons: [\"\"] };\n}\nfunction ty() {\n  if (hs() === rr.reactNative && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\") {\n    const { OS: t, Version: i } = global.Platform;\n    return [t, i].join(\"-\");\n  }\n  const r = cu();\n  if (r === null)\n    return \"unknown\";\n  const e = r.os ? r.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return r.type === \"browser\" ? [e, r.name, r.version].join(\"-\") : [e, r.version].join(\"-\");\n}\nfunction ry() {\n  var r;\n  const e = hs();\n  return e === rr.browser ? [e, ((r = hu()) == null ? void 0 : r.host) || \"unknown\"].join(\":\") : e;\n}\nfunction rd(r, e, t) {\n  const i = ty(), n = ry();\n  return [[r, e].join(\"-\"), [X2, t].join(\"-\"), i, n].join(\"/\");\n}\nfunction iy({ protocol: r, version: e, relayUrl: t, sdkVersion: i, auth: n, projectId: s, useOnCloseEvent: o, bundleId: f, packageName: h }) {\n  const d = t.split(\"?\"), v = rd(r, e, i), w = { auth: n, ua: v, projectId: s, useOnCloseEvent: o || void 0, packageName: h || void 0, bundleId: f || void 0 }, A = ey(d[1] || \"\", w);\n  return d[0] + \"?\" + A;\n}\nfunction Ui(r, e) {\n  return r.filter((t) => e.includes(t)).length === r.length;\n}\nfunction id(r) {\n  return Object.fromEntries(r.entries());\n}\nfunction nd(r) {\n  return new Map(Object.entries(r));\n}\nfunction Li(r = ie.FIVE_MINUTES, e) {\n  const t = ie.toMiliseconds(r || ie.FIVE_MINUTES);\n  let i, n, s, o;\n  return { resolve: (f) => {\n    s && i && (clearTimeout(s), i(f), o = Promise.resolve(f));\n  }, reject: (f) => {\n    s && n && (clearTimeout(s), n(f));\n  }, done: () => new Promise((f, h) => {\n    if (o)\n      return f(o);\n    s = setTimeout(() => {\n      const d = new Error(e);\n      o = Promise.reject(d), h(d);\n    }, t), i = f, n = h;\n  }) };\n}\nfunction mi(r, e, t) {\n  return new Promise(async (i, n) => {\n    const s = setTimeout(() => n(new Error(t)), e);\n    try {\n      const o = await r;\n      i(o);\n    } catch (o) {\n      n(o);\n    }\n    clearTimeout(s);\n  });\n}\nfunction sd(r, e) {\n  if (typeof e == \"string\" && e.startsWith(`${r}:`))\n    return e;\n  if (r.toLowerCase() === \"topic\") {\n    if (typeof e != \"string\")\n      throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${e}`;\n  } else if (r.toLowerCase() === \"id\") {\n    if (typeof e != \"number\")\n      throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${e}`;\n  }\n  throw new Error(`Unknown expirer target type: ${r}`);\n}\nfunction ny(r) {\n  return sd(\"topic\", r);\n}\nfunction sy(r) {\n  return sd(\"id\", r);\n}\nfunction ad(r) {\n  const [e, t] = r.split(\":\"), i = { id: void 0, topic: void 0 };\n  if (e === \"topic\" && typeof t == \"string\")\n    i.topic = t;\n  else if (e === \"id\" && Number.isInteger(Number(t)))\n    i.id = Number(t);\n  else\n    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);\n  return i;\n}\nfunction mt(r, e) {\n  return ie.fromMiliseconds((e || Date.now()) + ie.toMiliseconds(r));\n}\nfunction gi(r) {\n  return Date.now() >= ie.toMiliseconds(r);\n}\nfunction Xe(r, e) {\n  return `${r}${e ? `:${e}` : \"\"}`;\n}\nfunction ay(r = [], e = []) {\n  return [.../* @__PURE__ */ new Set([...r, ...e])];\n}\nasync function oy({ id: r, topic: e, wcDeepLink: t }) {\n  var i;\n  try {\n    if (!t)\n      return;\n    const n = typeof t == \"string\" ? JSON.parse(t) : t, s = n?.href;\n    if (typeof s != \"string\")\n      return;\n    const o = fy(s, r, e), f = hs();\n    if (f === rr.browser) {\n      if (!((i = is()) != null && i.hasFocus())) {\n        console.warn(\"Document does not have focus, skipping deeplink.\");\n        return;\n      }\n      o.startsWith(\"https://\") || o.startsWith(\"http://\") ? window.open(o, \"_blank\", \"noreferrer noopener\") : window.open(o, hy() ? \"_blank\" : \"_self\", \"noreferrer noopener\");\n    } else\n      f === rr.reactNative && typeof (global == null ? void 0 : global.Linking) < \"u\" && await global.Linking.openURL(o);\n  } catch (n) {\n    console.error(n);\n  }\n}\nfunction fy(r, e, t) {\n  const i = `requestId=${e}&sessionTopic=${t}`;\n  r.endsWith(\"/\") && (r = r.slice(0, -1));\n  let n = `${r}`;\n  if (r.startsWith(\"https://t.me\")) {\n    const s = r.includes(\"?\") ? \"&startapp=\" : \"?startapp=\";\n    n = `${n}${s}${uy(i, !0)}`;\n  } else\n    n = `${n}/wc?${i}`;\n  return n;\n}\nasync function cy(r, e) {\n  let t = \"\";\n  try {\n    if (cs() && (t = localStorage.getItem(e), t))\n      return t;\n    t = await r.getItem(e);\n  } catch (i) {\n    console.error(i);\n  }\n  return t;\n}\nfunction Ac(r, e) {\n  if (!r.includes(e))\n    return null;\n  const t = r.split(/([&,?,=])/), i = t.indexOf(e);\n  return t[i + 2];\n}\nfunction Dc() {\n  return typeof crypto < \"u\" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/gu, (r) => {\n    const e = Math.random() * 16 | 0;\n    return (r === \"x\" ? e : e & 3 | 8).toString(16);\n  });\n}\nfunction rf() {\n  return typeof process < \"u\" && process.env.IS_VITEST === \"true\";\n}\nfunction hy() {\n  return typeof window < \"u\" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);\n}\nfunction uy(r, e = !1) {\n  const t = Buffer.from(r).toString(\"base64\");\n  return e ? t.replace(/[=]/g, \"\") : t;\n}\nfunction od(r) {\n  return Buffer.from(r, \"base64\").toString(\"utf-8\");\n}\nfunction dy(r) {\n  return new Promise((e) => setTimeout(e, r));\n}\nconst ly = \"https://rpc.walletconnect.org/v1\";\nasync function py(r, e, t, i, n, s) {\n  switch (t.t) {\n    case \"eip191\":\n      return vy(r, e, t.s);\n    case \"eip1271\":\n      return await by(r, e, t.s, i, n, s);\n    default:\n      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`);\n  }\n}\nfunction vy(r, e, t) {\n  return Lg(bu(e), t).toLowerCase() === r.toLowerCase();\n}\nasync function by(r, e, t, i, n, s) {\n  const o = Ns(i);\n  if (!o.namespace || !o.reference)\n    throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${i}`);\n  try {\n    const f = \"0x1626ba7e\", h = \"0000000000000000000000000000000000000000000000000000000000000040\", d = \"0000000000000000000000000000000000000000000000000000000000000041\", v = t.substring(2), w = bu(e).substring(2), A = f + w + h + d + v, I = await fetch(`${s || ly}/?chainId=${i}&projectId=${n}`, { method: \"POST\", body: JSON.stringify({ id: gy(), jsonrpc: \"2.0\", method: \"eth_call\", params: [{ to: r, data: A }, \"latest\"] }) }), { result: D } = await I.json();\n    return D ? D.slice(0, f.length).toLowerCase() === f.toLowerCase() : !1;\n  } catch (f) {\n    return console.error(\"isValidEip1271Signature: \", f), !1;\n  }\n}\nfunction gy() {\n  return Date.now() + Math.floor(Math.random() * 1e3);\n}\nvar yy = Object.defineProperty, my = Object.defineProperties, wy = Object.getOwnPropertyDescriptors, Pc = Object.getOwnPropertySymbols, _y = Object.prototype.hasOwnProperty, xy = Object.prototype.propertyIsEnumerable, Oc = (r, e, t) => e in r ? yy(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Ey = (r, e) => {\n  for (var t in e || (e = {}))\n    _y.call(e, t) && Oc(r, t, e[t]);\n  if (Pc)\n    for (var t of Pc(e))\n      xy.call(e, t) && Oc(r, t, e[t]);\n  return r;\n}, Sy = (r, e) => my(r, wy(e));\nconst My = \"did:pkh:\", nf = (r) => r?.split(\":\"), Iy = (r) => {\n  const e = r && nf(r);\n  if (e)\n    return r.includes(My) ? e[3] : e[1];\n}, Io = (r) => {\n  const e = r && nf(r);\n  if (e)\n    return e[2] + \":\" + e[3];\n}, Js = (r) => {\n  const e = r && nf(r);\n  if (e)\n    return e.pop();\n};\nasync function Rc(r) {\n  const { cacao: e, projectId: t } = r, { s: i, p: n } = e, s = fd(n, n.iss), o = Js(n.iss);\n  return await py(o, s, i, Io(n.iss), t);\n}\nconst fd = (r, e) => {\n  const t = `${r.domain} wants you to sign in with your Ethereum account:`, i = Js(e);\n  if (!r.aud && !r.uri)\n    throw new Error(\"Either `aud` or `uri` is required to construct the message\");\n  let n = r.statement || void 0;\n  const s = `URI: ${r.aud || r.uri}`, o = `Version: ${r.version}`, f = `Chain ID: ${Iy(e)}`, h = `Nonce: ${r.nonce}`, d = `Issued At: ${r.iat}`, v = r.exp ? `Expiration Time: ${r.exp}` : void 0, w = r.nbf ? `Not Before: ${r.nbf}` : void 0, A = r.requestId ? `Request ID: ${r.requestId}` : void 0, I = r.resources ? `Resources:${r.resources.map((N) => `\n- ${N}`).join(\"\")}` : void 0, D = Ts(r.resources);\n  if (D) {\n    const N = Xn(D);\n    n = $y(n, N);\n  }\n  return [t, i, \"\", n, \"\", s, o, f, h, d, v, w, A, I].filter((N) => N != null).join(`\n`);\n};\nfunction Ay(r) {\n  return Buffer.from(JSON.stringify(r)).toString(\"base64\");\n}\nfunction Dy(r) {\n  return JSON.parse(Buffer.from(r, \"base64\").toString(\"utf-8\"));\n}\nfunction Hi(r) {\n  if (!r)\n    throw new Error(\"No recap provided, value is undefined\");\n  if (!r.att)\n    throw new Error(\"No `att` property found\");\n  const e = Object.keys(r.att);\n  if (!(e != null && e.length))\n    throw new Error(\"No resources found in `att` property\");\n  e.forEach((t) => {\n    const i = r.att[t];\n    if (Array.isArray(i))\n      throw new Error(`Resource must be an object: ${t}`);\n    if (typeof i != \"object\")\n      throw new Error(`Resource must be an object: ${t}`);\n    if (!Object.keys(i).length)\n      throw new Error(`Resource object is empty: ${t}`);\n    Object.keys(i).forEach((n) => {\n      const s = i[n];\n      if (!Array.isArray(s))\n        throw new Error(`Ability limits ${n} must be an array of objects, found: ${s}`);\n      if (!s.length)\n        throw new Error(`Value of ${n} is empty array, must be an array with objects`);\n      s.forEach((o) => {\n        if (typeof o != \"object\")\n          throw new Error(`Ability limits (${n}) must be an array of objects, found: ${o}`);\n      });\n    });\n  });\n}\nfunction Py(r, e, t, i = {}) {\n  return t?.sort((n, s) => n.localeCompare(s)), { att: { [r]: Oy(e, t, i) } };\n}\nfunction Oy(r, e, t = {}) {\n  e = e?.sort((n, s) => n.localeCompare(s));\n  const i = e.map((n) => ({ [`${r}/${n}`]: [t] }));\n  return Object.assign({}, ...i);\n}\nfunction cd(r) {\n  return Hi(r), `urn:recap:${Ay(r).replace(/=/g, \"\")}`;\n}\nfunction Xn(r) {\n  const e = Dy(r.replace(\"urn:recap:\", \"\"));\n  return Hi(e), e;\n}\nfunction Ry(r, e, t) {\n  const i = Py(r, e, t);\n  return cd(i);\n}\nfunction Ny(r) {\n  return r && r.includes(\"urn:recap:\");\n}\nfunction Ty(r, e) {\n  const t = Xn(r), i = Xn(e), n = Cy(t, i);\n  return cd(n);\n}\nfunction Cy(r, e) {\n  Hi(r), Hi(e);\n  const t = Object.keys(r.att).concat(Object.keys(e.att)).sort((n, s) => n.localeCompare(s)), i = { att: {} };\n  return t.forEach((n) => {\n    var s, o;\n    Object.keys(((s = r.att) == null ? void 0 : s[n]) || {}).concat(Object.keys(((o = e.att) == null ? void 0 : o[n]) || {})).sort((f, h) => f.localeCompare(h)).forEach((f) => {\n      var h, d;\n      i.att[n] = Sy(Ey({}, i.att[n]), { [f]: ((h = r.att[n]) == null ? void 0 : h[f]) || ((d = e.att[n]) == null ? void 0 : d[f]) });\n    });\n  }), i;\n}\nfunction $y(r = \"\", e) {\n  Hi(e);\n  const t = \"I further authorize the stated URI to perform the following actions on my behalf: \";\n  if (r.includes(t))\n    return r;\n  const i = [];\n  let n = 0;\n  Object.keys(e.att).forEach((f) => {\n    const h = Object.keys(e.att[f]).map((w) => ({ ability: w.split(\"/\")[0], action: w.split(\"/\")[1] }));\n    h.sort((w, A) => w.action.localeCompare(A.action));\n    const d = {};\n    h.forEach((w) => {\n      d[w.ability] || (d[w.ability] = []), d[w.ability].push(w.action);\n    });\n    const v = Object.keys(d).map((w) => (n++, `(${n}) '${w}': '${d[w].join(\"', '\")}' for '${f}'.`));\n    i.push(v.join(\", \").replace(\".,\", \".\"));\n  });\n  const s = i.join(\" \"), o = `${t}${s}`;\n  return `${r ? r + \" \" : \"\"}${o}`;\n}\nfunction Nc(r) {\n  var e;\n  const t = Xn(r);\n  Hi(t);\n  const i = (e = t.att) == null ? void 0 : e.eip155;\n  return i ? Object.keys(i).map((n) => n.split(\"/\")[1]) : [];\n}\nfunction Tc(r) {\n  const e = Xn(r);\n  Hi(e);\n  const t = [];\n  return Object.values(e.att).forEach((i) => {\n    Object.values(i).forEach((n) => {\n      var s;\n      (s = n?.[0]) != null && s.chains && t.push(n[0].chains);\n    });\n  }), [...new Set(t.flat())];\n}\nfunction Ts(r) {\n  if (!r)\n    return;\n  const e = r?.[r.length - 1];\n  return Ny(e) ? e : void 0;\n}\nconst hd = \"base10\", Bt = \"base16\", wi = \"base64pad\", Ln = \"base64url\", us = \"utf8\", ud = 0, hi = 1, ds = 2, Ly = 0, Cc = 1, Kn = 12, sf = 32;\nfunction Fy() {\n  const r = Vo.generateKeyPair();\n  return { privateKey: Mt(r.secretKey, Bt), publicKey: Mt(r.publicKey, Bt) };\n}\nfunction Ao() {\n  const r = Ei.randomBytes(sf);\n  return Mt(r, Bt);\n}\nfunction qy(r, e) {\n  const t = Vo.sharedKey(St(r, Bt), St(e, Bt), !0), i = new Jg(as.SHA256, t).expand(sf);\n  return Mt(i, Bt);\n}\nfunction Cs(r) {\n  const e = as.hash(St(r, Bt));\n  return Mt(e, Bt);\n}\nfunction fi(r) {\n  const e = as.hash(St(r, us));\n  return Mt(e, Bt);\n}\nfunction dd(r) {\n  return St(`${r}`, hd);\n}\nfunction Vi(r) {\n  return Number(Mt(r, hd));\n}\nfunction Uy(r) {\n  const e = dd(typeof r.type < \"u\" ? r.type : ud);\n  if (Vi(e) === hi && typeof r.senderPublicKey > \"u\")\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof r.senderPublicKey < \"u\" ? St(r.senderPublicKey, Bt) : void 0, i = typeof r.iv < \"u\" ? St(r.iv, Bt) : Ei.randomBytes(Kn), n = new Ko.ChaCha20Poly1305(St(r.symKey, Bt)).seal(i, St(r.message, us));\n  return ld({ type: e, sealed: n, iv: i, senderPublicKey: t, encoding: r.encoding });\n}\nfunction zy(r, e) {\n  const t = dd(ds), i = Ei.randomBytes(Kn), n = St(r, us);\n  return ld({ type: t, sealed: n, iv: i, encoding: e });\n}\nfunction By(r) {\n  const e = new Ko.ChaCha20Poly1305(St(r.symKey, Bt)), { sealed: t, iv: i } = Zn({ encoded: r.encoded, encoding: r?.encoding }), n = e.open(i, t);\n  if (n === null)\n    throw new Error(\"Failed to decrypt\");\n  return Mt(n, us);\n}\nfunction ky(r, e) {\n  const { sealed: t } = Zn({ encoded: r, encoding: e });\n  return Mt(t, us);\n}\nfunction ld(r) {\n  const { encoding: e = wi } = r;\n  if (Vi(r.type) === ds)\n    return Mt(Ds([r.type, r.sealed]), e);\n  if (Vi(r.type) === hi) {\n    if (typeof r.senderPublicKey > \"u\")\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    return Mt(Ds([r.type, r.senderPublicKey, r.iv, r.sealed]), e);\n  }\n  return Mt(Ds([r.type, r.iv, r.sealed]), e);\n}\nfunction Zn(r) {\n  const { encoded: e, encoding: t = wi } = r, i = St(e, t), n = i.slice(Ly, Cc), s = Cc;\n  if (Vi(n) === hi) {\n    const d = s + sf, v = d + Kn, w = i.slice(s, d), A = i.slice(d, v), I = i.slice(v);\n    return { type: n, sealed: I, iv: A, senderPublicKey: w };\n  }\n  if (Vi(n) === ds) {\n    const d = i.slice(s), v = Ei.randomBytes(Kn);\n    return { type: n, sealed: d, iv: v };\n  }\n  const o = s + Kn, f = i.slice(s, o), h = i.slice(o);\n  return { type: n, sealed: h, iv: f };\n}\nfunction jy(r, e) {\n  const t = Zn({ encoded: r, encoding: e?.encoding });\n  return pd({ type: Vi(t.type), senderPublicKey: typeof t.senderPublicKey < \"u\" ? Mt(t.senderPublicKey, Bt) : void 0, receiverPublicKey: e?.receiverPublicKey });\n}\nfunction pd(r) {\n  const e = r?.type || ud;\n  if (e === hi) {\n    if (typeof r?.senderPublicKey > \"u\")\n      throw new Error(\"missing sender public key\");\n    if (typeof r?.receiverPublicKey > \"u\")\n      throw new Error(\"missing receiver public key\");\n  }\n  return { type: e, senderPublicKey: r?.senderPublicKey, receiverPublicKey: r?.receiverPublicKey };\n}\nfunction $c(r) {\n  return r.type === hi && typeof r.senderPublicKey == \"string\" && typeof r.receiverPublicKey == \"string\";\n}\nfunction Lc(r) {\n  return r.type === ds;\n}\nfunction Ky(r) {\n  return new Ku.ec(\"p256\").keyFromPublic({ x: Buffer.from(r.x, \"base64\").toString(\"hex\"), y: Buffer.from(r.y, \"base64\").toString(\"hex\") }, \"hex\");\n}\nfunction Hy(r) {\n  let e = r.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const t = e.length % 4;\n  return t > 0 && (e += \"=\".repeat(4 - t)), e;\n}\nfunction Vy(r) {\n  return Buffer.from(Hy(r), \"base64\");\n}\nfunction Wy(r, e) {\n  const [t, i, n] = r.split(\".\"), s = Vy(n);\n  if (s.length !== 64)\n    throw new Error(\"Invalid signature length\");\n  const o = s.slice(0, 32).toString(\"hex\"), f = s.slice(32, 64).toString(\"hex\"), h = `${t}.${i}`, d = new as.SHA256().update(Buffer.from(h)).digest(), v = Ky(e), w = Buffer.from(d).toString(\"hex\");\n  if (!v.verify(w, { r: o, s: f }))\n    throw new Error(\"Invalid signature\");\n  return bo(r).payload;\n}\nconst Gy = \"irn\";\nfunction Ys(r) {\n  return r?.relay || { protocol: Gy };\n}\nfunction jn(r) {\n  const e = z2[r];\n  if (typeof e > \"u\")\n    throw new Error(`Relay Protocol not supported: ${r}`);\n  return e;\n}\nvar Jy = Object.defineProperty, Yy = Object.defineProperties, Xy = Object.getOwnPropertyDescriptors, Fc = Object.getOwnPropertySymbols, Zy = Object.prototype.hasOwnProperty, Qy = Object.prototype.propertyIsEnumerable, qc = (r, e, t) => e in r ? Jy(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Uc = (r, e) => {\n  for (var t in e || (e = {}))\n    Zy.call(e, t) && qc(r, t, e[t]);\n  if (Fc)\n    for (var t of Fc(e))\n      Qy.call(e, t) && qc(r, t, e[t]);\n  return r;\n}, em = (r, e) => Yy(r, Xy(e));\nfunction tm(r, e = \"-\") {\n  const t = {}, i = \"relay\" + e;\n  return Object.keys(r).forEach((n) => {\n    if (n.startsWith(i)) {\n      const s = n.replace(i, \"\"), o = r[n];\n      t[s] = o;\n    }\n  }), t;\n}\nfunction zc(r) {\n  if (!r.includes(\"wc:\")) {\n    const h = od(r);\n    h != null && h.includes(\"wc:\") && (r = h);\n  }\n  r = r.includes(\"wc://\") ? r.replace(\"wc://\", \"\") : r, r = r.includes(\"wc:\") ? r.replace(\"wc:\", \"\") : r;\n  const e = r.indexOf(\":\"), t = r.indexOf(\"?\") !== -1 ? r.indexOf(\"?\") : void 0, i = r.substring(0, e), n = r.substring(e + 1, t).split(\"@\"), s = typeof t < \"u\" ? r.substring(t) : \"\", o = Yn.parse(s), f = typeof o.methods == \"string\" ? o.methods.split(\",\") : void 0;\n  return { protocol: i, topic: rm(n[0]), version: parseInt(n[1], 10), symKey: o.symKey, relay: tm(o), methods: f, expiryTimestamp: o.expiryTimestamp ? parseInt(o.expiryTimestamp, 10) : void 0 };\n}\nfunction rm(r) {\n  return r.startsWith(\"//\") ? r.substring(2) : r;\n}\nfunction im(r, e = \"-\") {\n  const t = \"relay\", i = {};\n  return Object.keys(r).forEach((n) => {\n    const s = t + e + n;\n    r[n] && (i[s] = r[n]);\n  }), i;\n}\nfunction Bc(r) {\n  return `${r.protocol}:${r.topic}@${r.version}?` + Yn.stringify(Uc(em(Uc({ symKey: r.symKey }, im(r.relay)), { expiryTimestamp: r.expiryTimestamp }), r.methods ? { methods: r.methods.join(\",\") } : {}));\n}\nfunction Es(r, e, t) {\n  return `${r}?wc_ev=${t}&topic=${e}`;\n}\nfunction In(r) {\n  const e = [];\n  return r.forEach((t) => {\n    const [i, n] = t.split(\":\");\n    e.push(`${i}:${n}`);\n  }), e;\n}\nfunction nm(r) {\n  const e = [];\n  return Object.values(r).forEach((t) => {\n    e.push(...In(t.accounts));\n  }), e;\n}\nfunction sm(r, e) {\n  const t = [];\n  return Object.values(r).forEach((i) => {\n    In(i.accounts).includes(e) && t.push(...i.methods);\n  }), t;\n}\nfunction am(r, e) {\n  const t = [];\n  return Object.values(r).forEach((i) => {\n    In(i.accounts).includes(e) && t.push(...i.events);\n  }), t;\n}\nfunction om(r) {\n  const e = {};\n  return r?.forEach((t) => {\n    const [i, n] = t.split(\":\");\n    e[i] || (e[i] = { accounts: [], chains: [], events: [] }), e[i].accounts.push(t), e[i].chains.push(`${i}:${n}`);\n  }), e;\n}\nfunction kc(r, e) {\n  e = e.map((i) => i.replace(\"did:pkh:\", \"\"));\n  const t = om(e);\n  for (const [i, n] of Object.entries(t))\n    n.methods ? n.methods = ay(n.methods, r) : n.methods = r, n.events = [\"chainChanged\", \"accountsChanged\"];\n  return t;\n}\nconst fm = { INVALID_METHOD: { message: \"Invalid method.\", code: 1001 }, INVALID_EVENT: { message: \"Invalid event.\", code: 1002 }, INVALID_UPDATE_REQUEST: { message: \"Invalid update request.\", code: 1003 }, INVALID_EXTEND_REQUEST: { message: \"Invalid extend request.\", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: \"Invalid session settle request.\", code: 1005 }, UNAUTHORIZED_METHOD: { message: \"Unauthorized method.\", code: 3001 }, UNAUTHORIZED_EVENT: { message: \"Unauthorized event.\", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: \"Unauthorized update request.\", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: \"Unauthorized extend request.\", code: 3004 }, USER_REJECTED: { message: \"User rejected.\", code: 5e3 }, USER_REJECTED_CHAINS: { message: \"User rejected chains.\", code: 5001 }, USER_REJECTED_METHODS: { message: \"User rejected methods.\", code: 5002 }, USER_REJECTED_EVENTS: { message: \"User rejected events.\", code: 5003 }, UNSUPPORTED_CHAINS: { message: \"Unsupported chains.\", code: 5100 }, UNSUPPORTED_METHODS: { message: \"Unsupported methods.\", code: 5101 }, UNSUPPORTED_EVENTS: { message: \"Unsupported events.\", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: \"Unsupported accounts.\", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: \"Unsupported namespace key.\", code: 5104 }, USER_DISCONNECTED: { message: \"User disconnected.\", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: \"Session settlement failed.\", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: \"Unsupported wc_ method.\", code: 10001 } }, cm = { NOT_INITIALIZED: { message: \"Not initialized.\", code: 1 }, NO_MATCHING_KEY: { message: \"No matching key.\", code: 2 }, RESTORE_WILL_OVERRIDE: { message: \"Restore will override.\", code: 3 }, RESUBSCRIBED: { message: \"Resubscribed.\", code: 4 }, MISSING_OR_INVALID: { message: \"Missing or invalid.\", code: 5 }, EXPIRED: { message: \"Expired.\", code: 6 }, UNKNOWN_TYPE: { message: \"Unknown type.\", code: 7 }, MISMATCHED_TOPIC: { message: \"Mismatched topic.\", code: 8 }, NON_CONFORMING_NAMESPACES: { message: \"Non conforming namespaces.\", code: 9 } };\nfunction ae(r, e) {\n  const { message: t, code: i } = cm[r];\n  return { message: e ? `${t} ${e}` : t, code: i };\n}\nfunction st(r, e) {\n  const { message: t, code: i } = fm[r];\n  return { message: e ? `${t} ${e}` : t, code: i };\n}\nfunction Sa(r, e) {\n  return Array.isArray(r) ? typeof e < \"u\" && r.length ? r.every(e) : !0 : !1;\n}\nfunction Xs(r) {\n  return Object.getPrototypeOf(r) === Object.prototype && Object.keys(r).length;\n}\nfunction zt(r) {\n  return typeof r > \"u\";\n}\nfunction bt(r, e) {\n  return e && zt(r) ? !0 : typeof r == \"string\" && !!r.trim().length;\n}\nfunction af(r, e) {\n  return e && zt(r) ? !0 : typeof r == \"number\" && !isNaN(r);\n}\nfunction hm(r, e) {\n  const { requiredNamespaces: t } = e, i = Object.keys(r.namespaces), n = Object.keys(t);\n  let s = !0;\n  return Ui(n, i) ? (i.forEach((o) => {\n    const { accounts: f, methods: h, events: d } = r.namespaces[o], v = In(f), w = t[o];\n    (!Ui(tf(o, w), v) || !Ui(w.methods, h) || !Ui(w.events, d)) && (s = !1);\n  }), s) : !1;\n}\nfunction Zs(r) {\n  return bt(r, !1) && r.includes(\":\") ? r.split(\":\").length === 2 : !1;\n}\nfunction um(r) {\n  if (bt(r, !1) && r.includes(\":\")) {\n    const e = r.split(\":\");\n    if (e.length === 3) {\n      const t = e[0] + \":\" + e[1];\n      return !!e[2] && Zs(t);\n    }\n  }\n  return !1;\n}\nfunction dm(r) {\n  function e(t) {\n    try {\n      return typeof new URL(t) < \"u\";\n    } catch {\n      return !1;\n    }\n  }\n  try {\n    if (bt(r, !1)) {\n      if (e(r))\n        return !0;\n      const t = od(r);\n      return e(t);\n    }\n  } catch {\n  }\n  return !1;\n}\nfunction lm(r) {\n  var e;\n  return (e = r?.proposer) == null ? void 0 : e.publicKey;\n}\nfunction pm(r) {\n  return r?.topic;\n}\nfunction vm(r, e) {\n  let t = null;\n  return bt(r?.publicKey, !1) || (t = ae(\"MISSING_OR_INVALID\", `${e} controller public key should be a string`)), t;\n}\nfunction jc(r) {\n  let e = !0;\n  return Sa(r) ? r.length && (e = r.every((t) => bt(t, !1))) : e = !1, e;\n}\nfunction bm(r, e, t) {\n  let i = null;\n  return Sa(e) && e.length ? e.forEach((n) => {\n    i || Zs(n) || (i = st(\"UNSUPPORTED_CHAINS\", `${t}, chain ${n} should be a string and conform to \"namespace:chainId\" format`));\n  }) : Zs(r) || (i = st(\"UNSUPPORTED_CHAINS\", `${t}, chains must be defined as \"namespace:chainId\" e.g. \"eip155:1\": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: [\"eip155:1\", \"eip155:5\"] }`)), i;\n}\nfunction gm(r, e, t) {\n  let i = null;\n  return Object.entries(r).forEach(([n, s]) => {\n    if (i)\n      return;\n    const o = bm(n, tf(n, s), `${e} ${t}`);\n    o && (i = o);\n  }), i;\n}\nfunction ym(r, e) {\n  let t = null;\n  return Sa(r) ? r.forEach((i) => {\n    t || um(i) || (t = st(\"UNSUPPORTED_ACCOUNTS\", `${e}, account ${i} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = st(\"UNSUPPORTED_ACCOUNTS\", `${e}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\nfunction mm(r, e) {\n  let t = null;\n  return Object.values(r).forEach((i) => {\n    if (t)\n      return;\n    const n = ym(i?.accounts, `${e} namespace`);\n    n && (t = n);\n  }), t;\n}\nfunction wm(r, e) {\n  let t = null;\n  return jc(r?.methods) ? jc(r?.events) || (t = st(\"UNSUPPORTED_EVENTS\", `${e}, events should be an array of strings or empty array for no events`)) : t = st(\"UNSUPPORTED_METHODS\", `${e}, methods should be an array of strings or empty array for no methods`), t;\n}\nfunction vd(r, e) {\n  let t = null;\n  return Object.values(r).forEach((i) => {\n    if (t)\n      return;\n    const n = wm(i, `${e}, namespace`);\n    n && (t = n);\n  }), t;\n}\nfunction _m(r, e, t) {\n  let i = null;\n  if (r && Xs(r)) {\n    const n = vd(r, e);\n    n && (i = n);\n    const s = gm(r, e, t);\n    s && (i = s);\n  } else\n    i = ae(\"MISSING_OR_INVALID\", `${e}, ${t} should be an object with data`);\n  return i;\n}\nfunction eo(r, e) {\n  let t = null;\n  if (r && Xs(r)) {\n    const i = vd(r, e);\n    i && (t = i);\n    const n = mm(r, e);\n    n && (t = n);\n  } else\n    t = ae(\"MISSING_OR_INVALID\", `${e}, namespaces should be an object with data`);\n  return t;\n}\nfunction bd(r) {\n  return bt(r.protocol, !0);\n}\nfunction xm(r, e) {\n  let t = !1;\n  return e && !r ? t = !0 : r && Sa(r) && r.length && r.forEach((i) => {\n    t = bd(i);\n  }), t;\n}\nfunction Em(r) {\n  return typeof r == \"number\";\n}\nfunction Gt(r) {\n  return typeof r < \"u\" && typeof r !== null;\n}\nfunction Sm(r) {\n  return !(!r || typeof r != \"object\" || !r.code || !af(r.code, !1) || !r.message || !bt(r.message, !1));\n}\nfunction Mm(r) {\n  return !(zt(r) || !bt(r.method, !1));\n}\nfunction Im(r) {\n  return !(zt(r) || zt(r.result) && zt(r.error) || !af(r.id, !1) || !bt(r.jsonrpc, !1));\n}\nfunction Am(r) {\n  return !(zt(r) || !bt(r.name, !1));\n}\nfunction Kc(r, e) {\n  return !(!Zs(e) || !nm(r).includes(e));\n}\nfunction Dm(r, e, t) {\n  return bt(t, !1) ? sm(r, e).includes(t) : !1;\n}\nfunction Pm(r, e, t) {\n  return bt(t, !1) ? am(r, e).includes(t) : !1;\n}\nfunction Hc(r, e, t) {\n  let i = null;\n  const n = Om(r), s = Rm(e), o = Object.keys(n), f = Object.keys(s), h = Vc(Object.keys(r)), d = Vc(Object.keys(e)), v = h.filter((w) => !d.includes(w));\n  return v.length && (i = ae(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${v.toString()}\n      Received: ${Object.keys(e).toString()}`)), Ui(o, f) || (i = ae(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces chains don't satisfy required namespaces.\n      Required: ${o.toString()}\n      Approved: ${f.toString()}`)), Object.keys(e).forEach((w) => {\n    if (!w.includes(\":\") || i)\n      return;\n    const A = In(e[w].accounts);\n    A.includes(w) || (i = ae(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy namespace accounts for ${w}\n        Required: ${w}\n        Approved: ${A.toString()}`));\n  }), o.forEach((w) => {\n    i || (Ui(n[w].methods, s[w].methods) ? Ui(n[w].events, s[w].events) || (i = ae(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy namespace events for ${w}`)) : i = ae(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy namespace methods for ${w}`));\n  }), i;\n}\nfunction Om(r) {\n  const e = {};\n  return Object.keys(r).forEach((t) => {\n    var i;\n    t.includes(\":\") ? e[t] = r[t] : (i = r[t].chains) == null || i.forEach((n) => {\n      e[n] = { methods: r[t].methods, events: r[t].events };\n    });\n  }), e;\n}\nfunction Vc(r) {\n  return [...new Set(r.map((e) => e.includes(\":\") ? e.split(\":\")[0] : e))];\n}\nfunction Rm(r) {\n  const e = {};\n  return Object.keys(r).forEach((t) => {\n    t.includes(\":\") ? e[t] = r[t] : In(r[t].accounts)?.forEach((n) => {\n      e[n] = { accounts: r[t].accounts.filter((s) => s.includes(`${n}:`)), methods: r[t].methods, events: r[t].events };\n    });\n  }), e;\n}\nfunction Nm(r, e) {\n  return af(r, !1) && r <= e.max && r >= e.min;\n}\nfunction Wc() {\n  const r = hs();\n  return new Promise((e) => {\n    switch (r) {\n      case rr.browser:\n        e(Tm());\n        break;\n      case rr.reactNative:\n        e(Cm());\n        break;\n      case rr.node:\n        e($m());\n        break;\n      default:\n        e(!0);\n    }\n  });\n}\nfunction Tm() {\n  return cs() && navigator?.onLine;\n}\nasync function Cm() {\n  return Ai() && typeof global < \"u\" && global != null && global.NetInfo ? (await (global == null ? void 0 : global.NetInfo.fetch()))?.isConnected : !0;\n}\nfunction $m() {\n  return !0;\n}\nfunction Lm(r) {\n  switch (hs()) {\n    case rr.browser:\n      Fm(r);\n      break;\n    case rr.reactNative:\n      qm(r);\n      break;\n  }\n}\nfunction Fm(r) {\n  !Ai() && cs() && (window.addEventListener(\"online\", () => r(!0)), window.addEventListener(\"offline\", () => r(!1)));\n}\nfunction qm(r) {\n  Ai() && typeof global < \"u\" && global != null && global.NetInfo && global?.NetInfo.addEventListener((e) => r(e?.isConnected));\n}\nconst to = {};\nclass Fn {\n  static get(e) {\n    return to[e];\n  }\n  static set(e, t) {\n    to[e] = t;\n  }\n  static delete(e) {\n    delete to[e];\n  }\n}\nconst Um = \"PARSE_ERROR\", zm = \"INVALID_REQUEST\", Bm = \"METHOD_NOT_FOUND\", km = \"INVALID_PARAMS\", gd = \"INTERNAL_ERROR\", of = \"SERVER_ERROR\", jm = [-32700, -32600, -32601, -32602, -32603], Hn = {\n  [Um]: { code: -32700, message: \"Parse error\" },\n  [zm]: { code: -32600, message: \"Invalid Request\" },\n  [Bm]: { code: -32601, message: \"Method not found\" },\n  [km]: { code: -32602, message: \"Invalid params\" },\n  [gd]: { code: -32603, message: \"Internal error\" },\n  [of]: { code: -32e3, message: \"Server error\" }\n}, yd = of;\nfunction Km(r) {\n  return jm.includes(r);\n}\nfunction Gc(r) {\n  return Object.keys(Hn).includes(r) ? Hn[r] : Hn[yd];\n}\nfunction Hm(r) {\n  const e = Object.values(Hn).find((t) => t.code === r);\n  return e || Hn[yd];\n}\nfunction Vm(r, e, t) {\n  return r.message.includes(\"getaddrinfo ENOTFOUND\") || r.message.includes(\"connect ECONNREFUSED\") ? new Error(`Unavailable ${t} RPC url at ${e}`) : r;\n}\nvar md = {}, ii = {}, Jc;\nfunction Wm() {\n  if (Jc)\n    return ii;\n  Jc = 1, Object.defineProperty(ii, \"__esModule\", { value: !0 }), ii.isBrowserCryptoAvailable = ii.getSubtleCrypto = ii.getBrowerCrypto = void 0;\n  function r() {\n    return (_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.c === null || _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.c === void 0 ? void 0 : _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.c.crypto) || (_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.c === null || _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.c === void 0 ? void 0 : _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.c.msCrypto) || {};\n  }\n  ii.getBrowerCrypto = r;\n  function e() {\n    const i = r();\n    return i.subtle || i.webkitSubtle;\n  }\n  ii.getSubtleCrypto = e;\n  function t() {\n    return !!r() && !!e();\n  }\n  return ii.isBrowserCryptoAvailable = t, ii;\n}\nvar ni = {}, Yc;\nfunction Gm() {\n  if (Yc)\n    return ni;\n  Yc = 1, Object.defineProperty(ni, \"__esModule\", { value: !0 }), ni.isBrowser = ni.isNode = ni.isReactNative = void 0;\n  function r() {\n    return typeof document > \"u\" && typeof navigator < \"u\" && navigator.product === \"ReactNative\";\n  }\n  ni.isReactNative = r;\n  function e() {\n    return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n  }\n  ni.isNode = e;\n  function t() {\n    return !r() && !e();\n  }\n  return ni.isBrowser = t, ni;\n}\n(function(r) {\n  Object.defineProperty(r, \"__esModule\", { value: !0 });\n  const e = Qn;\n  e.__exportStar(Wm(), r), e.__exportStar(Gm(), r);\n})(md);\nfunction oi(r = 3) {\n  const e = Date.now() * Math.pow(10, r), t = Math.floor(Math.random() * Math.pow(10, r));\n  return e + t;\n}\nfunction zi(r = 6) {\n  return BigInt(oi(r));\n}\nfunction Bi(r, e, t) {\n  return {\n    id: t || oi(),\n    jsonrpc: \"2.0\",\n    method: r,\n    params: e\n  };\n}\nfunction Ma(r, e) {\n  return {\n    id: r,\n    jsonrpc: \"2.0\",\n    result: e\n  };\n}\nfunction Ia(r, e, t) {\n  return {\n    id: r,\n    jsonrpc: \"2.0\",\n    error: Jm(e, t)\n  };\n}\nfunction Jm(r, e) {\n  return typeof r > \"u\" ? Gc(gd) : (typeof r == \"string\" && (r = Object.assign(Object.assign({}, Gc(of)), { message: r })), typeof e < \"u\" && (r.data = e), Km(r.code) && (r = Hm(r.code)), r);\n}\nclass wd {\n}\nlet Ym = class extends wd {\n  constructor(e) {\n    super();\n  }\n};\nclass Xm extends wd {\n  constructor() {\n    super();\n  }\n}\nlet Zm = class extends Xm {\n  constructor(e) {\n    super();\n  }\n};\nconst Qm = \"^wss?:\";\nfunction e3(r) {\n  const e = r.match(new RegExp(/^\\w+:/, \"gi\"));\n  if (!(!e || !e.length))\n    return e[0];\n}\nfunction t3(r, e) {\n  const t = e3(r);\n  return typeof t > \"u\" ? !1 : new RegExp(e).test(t);\n}\nfunction Xc(r) {\n  return t3(r, Qm);\n}\nfunction r3(r) {\n  return new RegExp(\"wss?://localhost(:d{2,5})?\").test(r);\n}\nfunction _d(r) {\n  return typeof r == \"object\" && \"id\" in r && \"jsonrpc\" in r && r.jsonrpc === \"2.0\";\n}\nfunction ff(r) {\n  return _d(r) && \"method\" in r;\n}\nfunction Aa(r) {\n  return _d(r) && (Rr(r) || dr(r));\n}\nfunction Rr(r) {\n  return \"result\" in r;\n}\nfunction dr(r) {\n  return \"error\" in r;\n}\nclass xd extends Zm {\n  constructor(e) {\n    super(e), this.events = new ir.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();\n  }\n  async connect(e = this.connection) {\n    await this.open(e);\n  }\n  async disconnect() {\n    await this.close();\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async request(e, t) {\n    return this.requestStrict(Bi(e.method, e.params || [], e.id || zi().toString()), t);\n  }\n  async requestStrict(e, t) {\n    return new Promise(async (i, n) => {\n      if (!this.connection.connected)\n        try {\n          await this.open();\n        } catch (s) {\n          n(s);\n        }\n      this.events.on(`${e.id}`, (s) => {\n        dr(s) ? n(s.error) : i(s.result);\n      });\n      try {\n        await this.connection.send(e, t);\n      } catch (s) {\n        n(s);\n      }\n    });\n  }\n  setConnection(e = this.connection) {\n    return e;\n  }\n  onPayload(e) {\n    this.events.emit(\"payload\", e), Aa(e) ? this.events.emit(`${e.id}`, e) : this.events.emit(\"message\", { type: e.method, data: e.params });\n  }\n  onClose(e) {\n    e && e.code === 3e3 && this.events.emit(\"error\", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : \"\"}`)), this.events.emit(\"disconnect\");\n  }\n  async open(e = this.connection) {\n    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == \"string\" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit(\"connect\"));\n  }\n  async close() {\n    await this.connection.close();\n  }\n  registerEventListeners() {\n    this.hasRegisteredEventListeners || (this.connection.on(\"payload\", (e) => this.onPayload(e)), this.connection.on(\"close\", (e) => this.onClose(e)), this.connection.on(\"error\", (e) => this.events.emit(\"error\", e)), this.connection.on(\"register_error\", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);\n  }\n}\nconst i3 = () => typeof WebSocket < \"u\" ? WebSocket : typeof global < \"u\" && typeof global.WebSocket < \"u\" ? global.WebSocket : typeof window < \"u\" && typeof window.WebSocket < \"u\" ? window.WebSocket : typeof self < \"u\" && typeof self.WebSocket < \"u\" ? self.WebSocket : require(\"ws\"), n3 = () => typeof WebSocket < \"u\" || typeof global < \"u\" && typeof global.WebSocket < \"u\" || typeof window < \"u\" && typeof window.WebSocket < \"u\" || typeof self < \"u\" && typeof self.WebSocket < \"u\", Zc = (r) => r.split(\"?\")[0], Qc = 10, s3 = i3();\nclass a3 {\n  constructor(e) {\n    if (this.url = e, this.events = new ir.EventEmitter(), this.registering = !1, !Xc(e))\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);\n    this.url = e;\n  }\n  get connected() {\n    return typeof this.socket < \"u\";\n  }\n  get connecting() {\n    return this.registering;\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async open(e = this.url) {\n    await this.register(e);\n  }\n  async close() {\n    return new Promise((e, t) => {\n      if (typeof this.socket > \"u\") {\n        t(new Error(\"Connection already closed\"));\n        return;\n      }\n      this.socket.onclose = (i) => {\n        this.onClose(i), e();\n      }, this.socket.close();\n    });\n  }\n  async send(e) {\n    typeof this.socket > \"u\" && (this.socket = await this.register());\n    try {\n      this.socket.send(ji(e));\n    } catch (t) {\n      this.onError(e.id, t);\n    }\n  }\n  register(e = this.url) {\n    if (!Xc(e))\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);\n    if (this.registering) {\n      const t = this.events.getMaxListeners();\n      return (this.events.listenerCount(\"register_error\") >= t || this.events.listenerCount(\"open\") >= t) && this.events.setMaxListeners(t + 1), new Promise((i, n) => {\n        this.events.once(\"register_error\", (s) => {\n          this.resetMaxListeners(), n(s);\n        }), this.events.once(\"open\", () => {\n          if (this.resetMaxListeners(), typeof this.socket > \"u\")\n            return n(new Error(\"WebSocket connection is missing or invalid\"));\n          i(this.socket);\n        });\n      });\n    }\n    return this.url = e, this.registering = !0, new Promise((t, i) => {\n      const n = md.isReactNative() ? void 0 : { rejectUnauthorized: !r3(e) }, s = new s3(e, [], n);\n      n3() ? s.onerror = (o) => {\n        const f = o;\n        i(this.emitError(f.error));\n      } : s.on(\"error\", (o) => {\n        i(this.emitError(o));\n      }), s.onopen = () => {\n        this.onOpen(s), t(s);\n      };\n    });\n  }\n  onOpen(e) {\n    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = !1, this.events.emit(\"open\");\n  }\n  onClose(e) {\n    this.socket = void 0, this.registering = !1, this.events.emit(\"close\", e);\n  }\n  onPayload(e) {\n    if (typeof e.data > \"u\")\n      return;\n    const t = typeof e.data == \"string\" ? un(e.data) : e.data;\n    this.events.emit(\"payload\", t);\n  }\n  onError(e, t) {\n    const i = this.parseError(t), n = i.message || i.toString(), s = Ia(e, n);\n    this.events.emit(\"payload\", s);\n  }\n  parseError(e, t = this.url) {\n    return Vm(e, Zc(t), \"WS\");\n  }\n  resetMaxListeners() {\n    this.events.getMaxListeners() > Qc && this.events.setMaxListeners(Qc);\n  }\n  emitError(e) {\n    const t = this.parseError(new Error(e?.message || `WebSocket connection failed for host: ${Zc(this.url)}`));\n    return this.events.emit(\"register_error\", t), t;\n  }\n}\nvar Qs = { exports: {} };\nQs.exports;\n(function(r, e) {\n  var t = 200, i = \"__lodash_hash_undefined__\", n = 1, s = 2, o = 9007199254740991, f = \"[object Arguments]\", h = \"[object Array]\", d = \"[object AsyncFunction]\", v = \"[object Boolean]\", w = \"[object Date]\", A = \"[object Error]\", I = \"[object Function]\", D = \"[object GeneratorFunction]\", N = \"[object Map]\", k = \"[object Number]\", j = \"[object Null]\", T = \"[object Object]\", K = \"[object Promise]\", $ = \"[object Proxy]\", z = \"[object RegExp]\", B = \"[object Set]\", _ = \"[object String]\", R = \"[object Symbol]\", J = \"[object Undefined]\", Q = \"[object WeakMap]\", O = \"[object ArrayBuffer]\", p = \"[object DataView]\", l = \"[object Float32Array]\", a = \"[object Float64Array]\", c = \"[object Int8Array]\", b = \"[object Int16Array]\", E = \"[object Int32Array]\", S = \"[object Uint8Array]\", x = \"[object Uint8ClampedArray]\", u = \"[object Uint16Array]\", m = \"[object Uint32Array]\", g = /[\\\\^$.*+?()[\\]{}|]/g, P = /^\\[object .+?Constructor\\]$/, G = /^(?:0|[1-9]\\d*)$/, M = {};\n  M[l] = M[a] = M[c] = M[b] = M[E] = M[S] = M[x] = M[u] = M[m] = !0, M[f] = M[h] = M[O] = M[v] = M[p] = M[w] = M[A] = M[I] = M[N] = M[k] = M[T] = M[z] = M[B] = M[_] = M[Q] = !1;\n  var H = typeof _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.c == \"object\" && _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.c && _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.c.Object === Object && _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.c, C = typeof self == \"object\" && self && self.Object === Object && self, q = H || C || Function(\"return this\")(), L = e && !e.nodeType && e, y = L && !0 && r && !r.nodeType && r, F = y && y.exports === L, W = F && H.process, Y = function() {\n    try {\n      return W && W.binding && W.binding(\"util\");\n    } catch {\n    }\n  }(), X = Y && Y.isTypedArray;\n  function ee(U, V) {\n    for (var Z = -1, be = U == null ? 0 : U.length, ct = 0, We = []; ++Z < be; ) {\n      var dt = U[Z];\n      V(dt, Z, U) && (We[ct++] = dt);\n    }\n    return We;\n  }\n  function we(U, V) {\n    for (var Z = -1, be = V.length, ct = U.length; ++Z < be; )\n      U[ct + Z] = V[Z];\n    return U;\n  }\n  function Me(U, V) {\n    for (var Z = -1, be = U == null ? 0 : U.length; ++Z < be; )\n      if (V(U[Z], Z, U))\n        return !0;\n    return !1;\n  }\n  function he(U, V) {\n    for (var Z = -1, be = Array(U); ++Z < U; )\n      be[Z] = V(Z);\n    return be;\n  }\n  function Re(U) {\n    return function(V) {\n      return U(V);\n    };\n  }\n  function xe(U, V) {\n    return U.has(V);\n  }\n  function se(U, V) {\n    return U?.[V];\n  }\n  function ge(U) {\n    var V = -1, Z = Array(U.size);\n    return U.forEach(function(be, ct) {\n      Z[++V] = [ct, be];\n    }), Z;\n  }\n  function le(U, V) {\n    return function(Z) {\n      return U(V(Z));\n    };\n  }\n  function ne(U) {\n    var V = -1, Z = Array(U.size);\n    return U.forEach(function(be) {\n      Z[++V] = be;\n    }), Z;\n  }\n  var ue = Array.prototype, fe = Function.prototype, te = Object.prototype, pe = q[\"__core-js_shared__\"], _e = fe.toString, re = te.hasOwnProperty, Ee = function() {\n    var U = /[^.]+$/.exec(pe && pe.keys && pe.keys.IE_PROTO || \"\");\n    return U ? \"Symbol(src)_1.\" + U : \"\";\n  }(), Se = te.toString, oe = RegExp(\n    \"^\" + _e.call(re).replace(g, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n  ), De = F ? q.Buffer : void 0, Ie = q.Symbol, Pe = q.Uint8Array, Ge = te.propertyIsEnumerable, Ye = ue.splice, Ae = Ie ? Ie.toStringTag : void 0, Ze = Object.getOwnPropertySymbols, et = De ? De.isBuffer : void 0, Ne = le(Object.keys, Object), Ce = en(q, \"DataView\"), Te = en(q, \"Map\"), de = en(q, \"Promise\"), $e = en(q, \"Set\"), Le = en(q, \"WeakMap\"), ce = en(Object, \"create\"), Ue = Di(Ce), ze = Di(Te), ye = Di(de), Be = Di($e), ke = Di(Le), ve = Ie ? Ie.prototype : void 0, Fe = ve ? ve.valueOf : void 0;\n  function Oe(U) {\n    var V = -1, Z = U == null ? 0 : U.length;\n    for (this.clear(); ++V < Z; ) {\n      var be = U[V];\n      this.set(be[0], be[1]);\n    }\n  }\n  function me() {\n    this.__data__ = ce ? ce(null) : {}, this.size = 0;\n  }\n  function je(U) {\n    var V = this.has(U) && delete this.__data__[U];\n    return this.size -= V ? 1 : 0, V;\n  }\n  function rt(U) {\n    var V = this.__data__;\n    if (ce) {\n      var Z = V[U];\n      return Z === i ? void 0 : Z;\n    }\n    return re.call(V, U) ? V[U] : void 0;\n  }\n  function qe(U) {\n    var V = this.__data__;\n    return ce ? V[U] !== void 0 : re.call(V, U);\n  }\n  function it(U, V) {\n    var Z = this.__data__;\n    return this.size += this.has(U) ? 0 : 1, Z[U] = ce && V === void 0 ? i : V, this;\n  }\n  Oe.prototype.clear = me, Oe.prototype.delete = je, Oe.prototype.get = rt, Oe.prototype.has = qe, Oe.prototype.set = it;\n  function Je(U) {\n    var V = -1, Z = U == null ? 0 : U.length;\n    for (this.clear(); ++V < Z; ) {\n      var be = U[V];\n      this.set(be[0], be[1]);\n    }\n  }\n  function tt() {\n    this.__data__ = [], this.size = 0;\n  }\n  function jt(U) {\n    var V = this.__data__, Z = ps(V, U);\n    if (Z < 0)\n      return !1;\n    var be = V.length - 1;\n    return Z == be ? V.pop() : Ye.call(V, Z, 1), --this.size, !0;\n  }\n  function Kt(U) {\n    var V = this.__data__, Z = ps(V, U);\n    return Z < 0 ? void 0 : V[Z][1];\n  }\n  function Ht(U) {\n    return ps(this.__data__, U) > -1;\n  }\n  function Vt(U, V) {\n    var Z = this.__data__, be = ps(Z, U);\n    return be < 0 ? (++this.size, Z.push([U, V])) : Z[be][1] = V, this;\n  }\n  Je.prototype.clear = tt, Je.prototype.delete = jt, Je.prototype.get = Kt, Je.prototype.has = Ht, Je.prototype.set = Vt;\n  function gt(U) {\n    var V = -1, Z = U == null ? 0 : U.length;\n    for (this.clear(); ++V < Z; ) {\n      var be = U[V];\n      this.set(be[0], be[1]);\n    }\n  }\n  function Vr() {\n    this.size = 0, this.__data__ = {\n      hash: new Oe(),\n      map: new (Te || Je)(),\n      string: new Oe()\n    };\n  }\n  function Wr(U) {\n    var V = vs(this, U).delete(U);\n    return this.size -= V ? 1 : 0, V;\n  }\n  function Gr(U) {\n    return vs(this, U).get(U);\n  }\n  function Jr(U) {\n    return vs(this, U).has(U);\n  }\n  function Yr(U, V) {\n    var Z = vs(this, U), be = Z.size;\n    return Z.set(U, V), this.size += Z.size == be ? 0 : 1, this;\n  }\n  gt.prototype.clear = Vr, gt.prototype.delete = Wr, gt.prototype.get = Gr, gt.prototype.has = Jr, gt.prototype.set = Yr;\n  function or(U) {\n    var V = -1, Z = U == null ? 0 : U.length;\n    for (this.__data__ = new gt(); ++V < Z; )\n      this.add(U[V]);\n  }\n  function Xr(U) {\n    return this.__data__.set(U, i), this;\n  }\n  function Zr(U) {\n    return this.__data__.has(U);\n  }\n  or.prototype.add = or.prototype.push = Xr, or.prototype.has = Zr;\n  function $t(U) {\n    var V = this.__data__ = new Je(U);\n    this.size = V.size;\n  }\n  function Qr() {\n    this.__data__ = new Je(), this.size = 0;\n  }\n  function ei(U) {\n    var V = this.__data__, Z = V.delete(U);\n    return this.size = V.size, Z;\n  }\n  function ti(U) {\n    return this.__data__.get(U);\n  }\n  function An(U) {\n    return this.__data__.has(U);\n  }\n  function Dn(U, V) {\n    var Z = this.__data__;\n    if (Z instanceof Je) {\n      var be = Z.__data__;\n      if (!Te || be.length < t - 1)\n        return be.push([U, V]), this.size = ++Z.size, this;\n      Z = this.__data__ = new gt(be);\n    }\n    return Z.set(U, V), this.size = Z.size, this;\n  }\n  $t.prototype.clear = Qr, $t.prototype.delete = ei, $t.prototype.get = ti, $t.prototype.has = An, $t.prototype.set = Dn;\n  function kd(U, V) {\n    var Z = bs(U), be = !Z && il(U), ct = !Z && !be && Ra(U), We = !Z && !be && !ct && yf(U), dt = Z || be || ct || We, wt = dt ? he(U.length, String) : [], Ot = wt.length;\n    for (var ut in U)\n      (V || re.call(U, ut)) && !(dt && // Safari 9 has enumerable `arguments.length` in strict mode.\n      (ut == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n      ct && (ut == \"offset\" || ut == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n      We && (ut == \"buffer\" || ut == \"byteLength\" || ut == \"byteOffset\") || // Skip index properties.\n      Zd(ut, Ot))) && wt.push(ut);\n    return wt;\n  }\n  function ps(U, V) {\n    for (var Z = U.length; Z--; )\n      if (pf(U[Z][0], V))\n        return Z;\n    return -1;\n  }\n  function jd(U, V, Z) {\n    var be = V(U);\n    return bs(U) ? be : we(be, Z(U));\n  }\n  function Pn(U) {\n    return U == null ? U === void 0 ? J : j : Ae && Ae in Object(U) ? Yd(U) : rl(U);\n  }\n  function hf(U) {\n    return On(U) && Pn(U) == f;\n  }\n  function uf(U, V, Z, be, ct) {\n    return U === V ? !0 : U == null || V == null || !On(U) && !On(V) ? U !== U && V !== V : Kd(U, V, Z, be, uf, ct);\n  }\n  function Kd(U, V, Z, be, ct, We) {\n    var dt = bs(U), wt = bs(V), Ot = dt ? h : pi(U), ut = wt ? h : pi(V);\n    Ot = Ot == f ? T : Ot, ut = ut == f ? T : ut;\n    var Qt = Ot == T, mr = ut == T, Lt = Ot == ut;\n    if (Lt && Ra(U)) {\n      if (!Ra(V))\n        return !1;\n      dt = !0, Qt = !1;\n    }\n    if (Lt && !Qt)\n      return We || (We = new $t()), dt || yf(U) ? df(U, V, Z, be, ct, We) : Gd(U, V, Ot, Z, be, ct, We);\n    if (!(Z & n)) {\n      var fr = Qt && re.call(U, \"__wrapped__\"), cr = mr && re.call(V, \"__wrapped__\");\n      if (fr || cr) {\n        var vi = fr ? U.value() : U, ri = cr ? V.value() : V;\n        return We || (We = new $t()), ct(vi, ri, Z, be, We);\n      }\n    }\n    return Lt ? (We || (We = new $t()), Jd(U, V, Z, be, ct, We)) : !1;\n  }\n  function Hd(U) {\n    if (!gf(U) || el(U))\n      return !1;\n    var V = vf(U) ? oe : P;\n    return V.test(Di(U));\n  }\n  function Vd(U) {\n    return On(U) && bf(U.length) && !!M[Pn(U)];\n  }\n  function Wd(U) {\n    if (!tl(U))\n      return Ne(U);\n    var V = [];\n    for (var Z in Object(U))\n      re.call(U, Z) && Z != \"constructor\" && V.push(Z);\n    return V;\n  }\n  function df(U, V, Z, be, ct, We) {\n    var dt = Z & n, wt = U.length, Ot = V.length;\n    if (wt != Ot && !(dt && Ot > wt))\n      return !1;\n    var ut = We.get(U);\n    if (ut && We.get(V))\n      return ut == V;\n    var Qt = -1, mr = !0, Lt = Z & s ? new or() : void 0;\n    for (We.set(U, V), We.set(V, U); ++Qt < wt; ) {\n      var fr = U[Qt], cr = V[Qt];\n      if (be)\n        var vi = dt ? be(cr, fr, Qt, V, U, We) : be(fr, cr, Qt, U, V, We);\n      if (vi !== void 0) {\n        if (vi)\n          continue;\n        mr = !1;\n        break;\n      }\n      if (Lt) {\n        if (!Me(V, function(ri, Pi) {\n          if (!xe(Lt, Pi) && (fr === ri || ct(fr, ri, Z, be, We)))\n            return Lt.push(Pi);\n        })) {\n          mr = !1;\n          break;\n        }\n      } else if (!(fr === cr || ct(fr, cr, Z, be, We))) {\n        mr = !1;\n        break;\n      }\n    }\n    return We.delete(U), We.delete(V), mr;\n  }\n  function Gd(U, V, Z, be, ct, We, dt) {\n    switch (Z) {\n      case p:\n        if (U.byteLength != V.byteLength || U.byteOffset != V.byteOffset)\n          return !1;\n        U = U.buffer, V = V.buffer;\n      case O:\n        return !(U.byteLength != V.byteLength || !We(new Pe(U), new Pe(V)));\n      case v:\n      case w:\n      case k:\n        return pf(+U, +V);\n      case A:\n        return U.name == V.name && U.message == V.message;\n      case z:\n      case _:\n        return U == V + \"\";\n      case N:\n        var wt = ge;\n      case B:\n        var Ot = be & n;\n        if (wt || (wt = ne), U.size != V.size && !Ot)\n          return !1;\n        var ut = dt.get(U);\n        if (ut)\n          return ut == V;\n        be |= s, dt.set(U, V);\n        var Qt = df(wt(U), wt(V), be, ct, We, dt);\n        return dt.delete(U), Qt;\n      case R:\n        if (Fe)\n          return Fe.call(U) == Fe.call(V);\n    }\n    return !1;\n  }\n  function Jd(U, V, Z, be, ct, We) {\n    var dt = Z & n, wt = lf(U), Ot = wt.length, ut = lf(V), Qt = ut.length;\n    if (Ot != Qt && !dt)\n      return !1;\n    for (var mr = Ot; mr--; ) {\n      var Lt = wt[mr];\n      if (!(dt ? Lt in V : re.call(V, Lt)))\n        return !1;\n    }\n    var fr = We.get(U);\n    if (fr && We.get(V))\n      return fr == V;\n    var cr = !0;\n    We.set(U, V), We.set(V, U);\n    for (var vi = dt; ++mr < Ot; ) {\n      Lt = wt[mr];\n      var ri = U[Lt], Pi = V[Lt];\n      if (be)\n        var mf = dt ? be(Pi, ri, Lt, V, U, We) : be(ri, Pi, Lt, U, V, We);\n      if (!(mf === void 0 ? ri === Pi || ct(ri, Pi, Z, be, We) : mf)) {\n        cr = !1;\n        break;\n      }\n      vi || (vi = Lt == \"constructor\");\n    }\n    if (cr && !vi) {\n      var gs = U.constructor, ys = V.constructor;\n      gs != ys && \"constructor\" in U && \"constructor\" in V && !(typeof gs == \"function\" && gs instanceof gs && typeof ys == \"function\" && ys instanceof ys) && (cr = !1);\n    }\n    return We.delete(U), We.delete(V), cr;\n  }\n  function lf(U) {\n    return jd(U, al, Xd);\n  }\n  function vs(U, V) {\n    var Z = U.__data__;\n    return Qd(V) ? Z[typeof V == \"string\" ? \"string\" : \"hash\"] : Z.map;\n  }\n  function en(U, V) {\n    var Z = se(U, V);\n    return Hd(Z) ? Z : void 0;\n  }\n  function Yd(U) {\n    var V = re.call(U, Ae), Z = U[Ae];\n    try {\n      U[Ae] = void 0;\n      var be = !0;\n    } catch {\n    }\n    var ct = Se.call(U);\n    return be && (V ? U[Ae] = Z : delete U[Ae]), ct;\n  }\n  var Xd = Ze ? function(U) {\n    return U == null ? [] : (U = Object(U), ee(Ze(U), function(V) {\n      return Ge.call(U, V);\n    }));\n  } : ol, pi = Pn;\n  (Ce && pi(new Ce(new ArrayBuffer(1))) != p || Te && pi(new Te()) != N || de && pi(de.resolve()) != K || $e && pi(new $e()) != B || Le && pi(new Le()) != Q) && (pi = function(U) {\n    var V = Pn(U), Z = V == T ? U.constructor : void 0, be = Z ? Di(Z) : \"\";\n    if (be)\n      switch (be) {\n        case Ue:\n          return p;\n        case ze:\n          return N;\n        case ye:\n          return K;\n        case Be:\n          return B;\n        case ke:\n          return Q;\n      }\n    return V;\n  });\n  function Zd(U, V) {\n    return V = V ?? o, !!V && (typeof U == \"number\" || G.test(U)) && U > -1 && U % 1 == 0 && U < V;\n  }\n  function Qd(U) {\n    var V = typeof U;\n    return V == \"string\" || V == \"number\" || V == \"symbol\" || V == \"boolean\" ? U !== \"__proto__\" : U === null;\n  }\n  function el(U) {\n    return !!Ee && Ee in U;\n  }\n  function tl(U) {\n    var V = U && U.constructor, Z = typeof V == \"function\" && V.prototype || te;\n    return U === Z;\n  }\n  function rl(U) {\n    return Se.call(U);\n  }\n  function Di(U) {\n    if (U != null) {\n      try {\n        return _e.call(U);\n      } catch {\n      }\n      try {\n        return U + \"\";\n      } catch {\n      }\n    }\n    return \"\";\n  }\n  function pf(U, V) {\n    return U === V || U !== U && V !== V;\n  }\n  var il = hf(function() {\n    return arguments;\n  }()) ? hf : function(U) {\n    return On(U) && re.call(U, \"callee\") && !Ge.call(U, \"callee\");\n  }, bs = Array.isArray;\n  function nl(U) {\n    return U != null && bf(U.length) && !vf(U);\n  }\n  var Ra = et || fl;\n  function sl(U, V) {\n    return uf(U, V);\n  }\n  function vf(U) {\n    if (!gf(U))\n      return !1;\n    var V = Pn(U);\n    return V == I || V == D || V == d || V == $;\n  }\n  function bf(U) {\n    return typeof U == \"number\" && U > -1 && U % 1 == 0 && U <= o;\n  }\n  function gf(U) {\n    var V = typeof U;\n    return U != null && (V == \"object\" || V == \"function\");\n  }\n  function On(U) {\n    return U != null && typeof U == \"object\";\n  }\n  var yf = X ? Re(X) : Vd;\n  function al(U) {\n    return nl(U) ? kd(U) : Wd(U);\n  }\n  function ol() {\n    return [];\n  }\n  function fl() {\n    return !1;\n  }\n  r.exports = sl;\n})(Qs, Qs.exports);\nvar o3 = Qs.exports;\nconst f3 = /* @__PURE__ */ (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_0__.d)(o3), Ed = \"wc\", Sd = 2, ea = \"core\", jr = `${Ed}@2:${ea}:`, c3 = { name: ea, logger: \"error\" }, h3 = { database: \":memory:\" }, u3 = \"crypto\", eh = \"client_ed25519_seed\", d3 = ie.ONE_DAY, l3 = \"keychain\", p3 = \"0.3\", v3 = \"messages\", b3 = \"0.3\", th = ie.SIX_HOURS, g3 = \"publisher\", Md = \"irn\", y3 = \"error\", Id = \"wss://relay.walletconnect.org\", m3 = \"relayer\", Et = { message: \"relayer_message\", message_ack: \"relayer_message_ack\", connect: \"relayer_connect\", disconnect: \"relayer_disconnect\", error: \"relayer_error\", connection_stalled: \"relayer_connection_stalled\", transport_closed: \"relayer_transport_closed\", publish: \"relayer_publish\" }, w3 = \"_subscription\", hr = { payload: \"payload\", connect: \"connect\", disconnect: \"disconnect\", error: \"error\" }, _3 = 0.1, Do = \"2.17.3\", at = { link_mode: \"link_mode\", relay: \"relay\" }, x3 = \"0.3\", E3 = \"WALLETCONNECT_CLIENT_ID\", rh = \"WALLETCONNECT_LINK_MODE_APPS\", er = { created: \"subscription_created\", deleted: \"subscription_deleted\", expired: \"subscription_expired\", disabled: \"subscription_disabled\", sync: \"subscription_sync\", resubscribed: \"subscription_resubscribed\" }, S3 = \"subscription\", M3 = \"0.3\", I3 = ie.FIVE_SECONDS * 1e3, A3 = \"pairing\", D3 = \"0.3\", qn = { wc_pairingDelete: { req: { ttl: ie.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: ie.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: ie.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: ie.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: ie.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: ie.ONE_DAY, prompt: !1, tag: 0 } } }, qi = { create: \"pairing_create\", expire: \"pairing_expire\", delete: \"pairing_delete\", ping: \"pairing_ping\" }, _r = { created: \"history_created\", updated: \"history_updated\", deleted: \"history_deleted\", sync: \"history_sync\" }, P3 = \"history\", O3 = \"0.3\", R3 = \"expirer\", ur = { created: \"expirer_created\", deleted: \"expirer_deleted\", expired: \"expirer_expired\", sync: \"expirer_sync\" }, N3 = \"0.3\", T3 = \"verify-api\", C3 = \"https://verify.walletconnect.com\", Ad = \"https://verify.walletconnect.org\", Vn = Ad, $3 = `${Vn}/v3`, L3 = [C3, Ad], F3 = \"echo\", q3 = \"https://echo.walletconnect.com\", Or = { pairing_started: \"pairing_started\", pairing_uri_validation_success: \"pairing_uri_validation_success\", pairing_uri_not_expired: \"pairing_uri_not_expired\", store_new_pairing: \"store_new_pairing\", subscribing_pairing_topic: \"subscribing_pairing_topic\", subscribe_pairing_topic_success: \"subscribe_pairing_topic_success\", existing_pairing: \"existing_pairing\", pairing_not_expired: \"pairing_not_expired\", emit_inactive_pairing: \"emit_inactive_pairing\", emit_session_proposal: \"emit_session_proposal\", subscribing_to_pairing_topic: \"subscribing_to_pairing_topic\" }, ai = { no_wss_connection: \"no_wss_connection\", no_internet_connection: \"no_internet_connection\", malformed_pairing_uri: \"malformed_pairing_uri\", active_pairing_already_exists: \"active_pairing_already_exists\", subscribe_pairing_topic_failure: \"subscribe_pairing_topic_failure\", pairing_expired: \"pairing_expired\", proposal_expired: \"proposal_expired\", proposal_listener_not_found: \"proposal_listener_not_found\" }, xr = { session_approve_started: \"session_approve_started\", proposal_not_expired: \"proposal_not_expired\", session_namespaces_validation_success: \"session_namespaces_validation_success\", create_session_topic: \"create_session_topic\", subscribing_session_topic: \"subscribing_session_topic\", subscribe_session_topic_success: \"subscribe_session_topic_success\", publishing_session_approve: \"publishing_session_approve\", session_approve_publish_success: \"session_approve_publish_success\", store_session: \"store_session\", publishing_session_settle: \"publishing_session_settle\", session_settle_publish_success: \"session_settle_publish_success\" }, Ti = { no_internet_connection: \"no_internet_connection\", no_wss_connection: \"no_wss_connection\", proposal_expired: \"proposal_expired\", subscribe_session_topic_failure: \"subscribe_session_topic_failure\", session_approve_publish_failure: \"session_approve_publish_failure\", session_settle_publish_failure: \"session_settle_publish_failure\", session_approve_namespace_validation_failure: \"session_approve_namespace_validation_failure\", proposal_not_found: \"proposal_not_found\" }, Ci = { authenticated_session_approve_started: \"authenticated_session_approve_started\", authenticated_session_not_expired: \"authenticated_session_not_expired\", chains_caip2_compliant: \"chains_caip2_compliant\", chains_evm_compliant: \"chains_evm_compliant\", create_authenticated_session_topic: \"create_authenticated_session_topic\", cacaos_verified: \"cacaos_verified\", store_authenticated_session: \"store_authenticated_session\", subscribing_authenticated_session_topic: \"subscribing_authenticated_session_topic\", subscribe_authenticated_session_topic_success: \"subscribe_authenticated_session_topic_success\", publishing_authenticated_session_approve: \"publishing_authenticated_session_approve\", authenticated_session_approve_publish_success: \"authenticated_session_approve_publish_success\" }, Un = { no_internet_connection: \"no_internet_connection\", no_wss_connection: \"no_wss_connection\", missing_session_authenticate_request: \"missing_session_authenticate_request\", session_authenticate_request_expired: \"session_authenticate_request_expired\", chains_caip2_compliant_failure: \"chains_caip2_compliant_failure\", chains_evm_compliant_failure: \"chains_evm_compliant_failure\", invalid_cacao: \"invalid_cacao\", subscribe_authenticated_session_topic_failure: \"subscribe_authenticated_session_topic_failure\", authenticated_session_approve_publish_failure: \"authenticated_session_approve_publish_failure\", authenticated_session_pending_request_not_found: \"authenticated_session_pending_request_not_found\" }, U3 = 0.1, z3 = \"event-client\", B3 = 86400, k3 = \"https://pulse.walletconnect.org/batch\";\nfunction j3(r, e) {\n  if (r.length >= 255)\n    throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), i = 0; i < t.length; i++)\n    t[i] = 255;\n  for (var n = 0; n < r.length; n++) {\n    var s = r.charAt(n), o = s.charCodeAt(0);\n    if (t[o] !== 255)\n      throw new TypeError(s + \" is ambiguous\");\n    t[o] = n;\n  }\n  var f = r.length, h = r.charAt(0), d = Math.log(f) / Math.log(256), v = Math.log(256) / Math.log(f);\n  function w(D) {\n    if (D instanceof Uint8Array || (ArrayBuffer.isView(D) ? D = new Uint8Array(D.buffer, D.byteOffset, D.byteLength) : Array.isArray(D) && (D = Uint8Array.from(D))), !(D instanceof Uint8Array))\n      throw new TypeError(\"Expected Uint8Array\");\n    if (D.length === 0)\n      return \"\";\n    for (var N = 0, k = 0, j = 0, T = D.length; j !== T && D[j] === 0; )\n      j++, N++;\n    for (var K = (T - j) * v + 1 >>> 0, $ = new Uint8Array(K); j !== T; ) {\n      for (var z = D[j], B = 0, _ = K - 1; (z !== 0 || B < k) && _ !== -1; _--, B++)\n        z += 256 * $[_] >>> 0, $[_] = z % f >>> 0, z = z / f >>> 0;\n      if (z !== 0)\n        throw new Error(\"Non-zero carry\");\n      k = B, j++;\n    }\n    for (var R = K - k; R !== K && $[R] === 0; )\n      R++;\n    for (var J = h.repeat(N); R < K; ++R)\n      J += r.charAt($[R]);\n    return J;\n  }\n  function A(D) {\n    if (typeof D != \"string\")\n      throw new TypeError(\"Expected String\");\n    if (D.length === 0)\n      return new Uint8Array();\n    var N = 0;\n    if (D[N] !== \" \") {\n      for (var k = 0, j = 0; D[N] === h; )\n        k++, N++;\n      for (var T = (D.length - N) * d + 1 >>> 0, K = new Uint8Array(T); D[N]; ) {\n        var $ = t[D.charCodeAt(N)];\n        if ($ === 255)\n          return;\n        for (var z = 0, B = T - 1; ($ !== 0 || z < j) && B !== -1; B--, z++)\n          $ += f * K[B] >>> 0, K[B] = $ % 256 >>> 0, $ = $ / 256 >>> 0;\n        if ($ !== 0)\n          throw new Error(\"Non-zero carry\");\n        j = z, N++;\n      }\n      if (D[N] !== \" \") {\n        for (var _ = T - j; _ !== T && K[_] === 0; )\n          _++;\n        for (var R = new Uint8Array(k + (T - _)), J = k; _ !== T; )\n          R[J++] = K[_++];\n        return R;\n      }\n    }\n  }\n  function I(D) {\n    var N = A(D);\n    if (N)\n      return N;\n    throw new Error(`Non-${e} character`);\n  }\n  return { encode: w, decodeUnsafe: A, decode: I };\n}\nvar K3 = j3, H3 = K3;\nconst Dd = (r) => {\n  if (r instanceof Uint8Array && r.constructor.name === \"Uint8Array\")\n    return r;\n  if (r instanceof ArrayBuffer)\n    return new Uint8Array(r);\n  if (ArrayBuffer.isView(r))\n    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);\n  throw new Error(\"Unknown type, must be binary type\");\n}, V3 = (r) => new TextEncoder().encode(r), W3 = (r) => new TextDecoder().decode(r);\nclass G3 {\n  constructor(e, t, i) {\n    this.name = e, this.prefix = t, this.baseEncode = i;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array)\n      return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass J3 {\n  constructor(e, t, i) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)\n      throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint)\n        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else\n      throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return Pd(this, e);\n  }\n}\nclass Y3 {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return Pd(this, e);\n  }\n  decode(e) {\n    const t = e[0], i = this.decoders[t];\n    if (i)\n      return i.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst Pd = (r, e) => new Y3({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } });\nclass X3 {\n  constructor(e, t, i, n) {\n    this.name = e, this.prefix = t, this.baseEncode = i, this.baseDecode = n, this.encoder = new G3(e, t, i), this.decoder = new J3(e, t, n);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst Da = ({ name: r, prefix: e, encode: t, decode: i }) => new X3(r, e, t, i), ls = ({ prefix: r, name: e, alphabet: t }) => {\n  const { encode: i, decode: n } = H3(t, e);\n  return Da({ prefix: r, name: e, encode: i, decode: (s) => Dd(n(s)) });\n}, Z3 = (r, e, t, i) => {\n  const n = {};\n  for (let v = 0; v < e.length; ++v)\n    n[e[v]] = v;\n  let s = r.length;\n  for (; r[s - 1] === \"=\"; )\n    --s;\n  const o = new Uint8Array(s * t / 8 | 0);\n  let f = 0, h = 0, d = 0;\n  for (let v = 0; v < s; ++v) {\n    const w = n[r[v]];\n    if (w === void 0)\n      throw new SyntaxError(`Non-${i} character`);\n    h = h << t | w, f += t, f >= 8 && (f -= 8, o[d++] = 255 & h >> f);\n  }\n  if (f >= t || 255 & h << 8 - f)\n    throw new SyntaxError(\"Unexpected end of data\");\n  return o;\n}, Q3 = (r, e, t) => {\n  const i = e[e.length - 1] === \"=\", n = (1 << t) - 1;\n  let s = \"\", o = 0, f = 0;\n  for (let h = 0; h < r.length; ++h)\n    for (f = f << 8 | r[h], o += 8; o > t; )\n      o -= t, s += e[n & f >> o];\n  if (o && (s += e[n & f << t - o]), i)\n    for (; s.length * t & 7; )\n      s += \"=\";\n  return s;\n}, Ct = ({ name: r, prefix: e, bitsPerChar: t, alphabet: i }) => Da({ prefix: e, name: r, encode(n) {\n  return Q3(n, i, t);\n}, decode(n) {\n  return Z3(n, i, t, r);\n} }), e6 = Da({ prefix: \"\\0\", name: \"identity\", encode: (r) => W3(r), decode: (r) => V3(r) });\nvar t6 = Object.freeze({ __proto__: null, identity: e6 });\nconst r6 = Ct({ prefix: \"0\", name: \"base2\", alphabet: \"01\", bitsPerChar: 1 });\nvar i6 = Object.freeze({ __proto__: null, base2: r6 });\nconst n6 = Ct({ prefix: \"7\", name: \"base8\", alphabet: \"01234567\", bitsPerChar: 3 });\nvar s6 = Object.freeze({ __proto__: null, base8: n6 });\nconst a6 = ls({ prefix: \"9\", name: \"base10\", alphabet: \"0123456789\" });\nvar o6 = Object.freeze({ __proto__: null, base10: a6 });\nconst f6 = Ct({ prefix: \"f\", name: \"base16\", alphabet: \"0123456789abcdef\", bitsPerChar: 4 }), c6 = Ct({ prefix: \"F\", name: \"base16upper\", alphabet: \"0123456789ABCDEF\", bitsPerChar: 4 });\nvar h6 = Object.freeze({ __proto__: null, base16: f6, base16upper: c6 });\nconst u6 = Ct({ prefix: \"b\", name: \"base32\", alphabet: \"abcdefghijklmnopqrstuvwxyz234567\", bitsPerChar: 5 }), d6 = Ct({ prefix: \"B\", name: \"base32upper\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\", bitsPerChar: 5 }), l6 = Ct({ prefix: \"c\", name: \"base32pad\", alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\", bitsPerChar: 5 }), p6 = Ct({ prefix: \"C\", name: \"base32padupper\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\", bitsPerChar: 5 }), v6 = Ct({ prefix: \"v\", name: \"base32hex\", alphabet: \"0123456789abcdefghijklmnopqrstuv\", bitsPerChar: 5 }), b6 = Ct({ prefix: \"V\", name: \"base32hexupper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\", bitsPerChar: 5 }), g6 = Ct({ prefix: \"t\", name: \"base32hexpad\", alphabet: \"0123456789abcdefghijklmnopqrstuv=\", bitsPerChar: 5 }), y6 = Ct({ prefix: \"T\", name: \"base32hexpadupper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\", bitsPerChar: 5 }), m6 = Ct({ prefix: \"h\", name: \"base32z\", alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\", bitsPerChar: 5 });\nvar w6 = Object.freeze({ __proto__: null, base32: u6, base32upper: d6, base32pad: l6, base32padupper: p6, base32hex: v6, base32hexupper: b6, base32hexpad: g6, base32hexpadupper: y6, base32z: m6 });\nconst _6 = ls({ prefix: \"k\", name: \"base36\", alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\" }), x6 = ls({ prefix: \"K\", name: \"base36upper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" });\nvar E6 = Object.freeze({ __proto__: null, base36: _6, base36upper: x6 });\nconst S6 = ls({ name: \"base58btc\", prefix: \"z\", alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\" }), M6 = ls({ name: \"base58flickr\", prefix: \"Z\", alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\" });\nvar I6 = Object.freeze({ __proto__: null, base58btc: S6, base58flickr: M6 });\nconst A6 = Ct({ prefix: \"m\", name: \"base64\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", bitsPerChar: 6 }), D6 = Ct({ prefix: \"M\", name: \"base64pad\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", bitsPerChar: 6 }), P6 = Ct({ prefix: \"u\", name: \"base64url\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\", bitsPerChar: 6 }), O6 = Ct({ prefix: \"U\", name: \"base64urlpad\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\", bitsPerChar: 6 });\nvar R6 = Object.freeze({ __proto__: null, base64: A6, base64pad: D6, base64url: P6, base64urlpad: O6 });\nconst Od = Array.from(\"\"), N6 = Od.reduce((r, e, t) => (r[t] = e, r), []), T6 = Od.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);\nfunction C6(r) {\n  return r.reduce((e, t) => (e += N6[t], e), \"\");\n}\nfunction $6(r) {\n  const e = [];\n  for (const t of r) {\n    const i = T6[t.codePointAt(0)];\n    if (i === void 0)\n      throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(i);\n  }\n  return new Uint8Array(e);\n}\nconst L6 = Da({ prefix: \"\", name: \"base256emoji\", encode: C6, decode: $6 });\nvar F6 = Object.freeze({ __proto__: null, base256emoji: L6 }), q6 = Rd, ih = 128, U6 = 127, z6 = ~U6, B6 = Math.pow(2, 31);\nfunction Rd(r, e, t) {\n  e = e || [], t = t || 0;\n  for (var i = t; r >= B6; )\n    e[t++] = r & 255 | ih, r /= 128;\n  for (; r & z6; )\n    e[t++] = r & 255 | ih, r >>>= 7;\n  return e[t] = r | 0, Rd.bytes = t - i + 1, e;\n}\nvar k6 = Po, j6 = 128, nh = 127;\nfunction Po(r, i) {\n  var t = 0, i = i || 0, n = 0, s = i, o, f = r.length;\n  do {\n    if (s >= f)\n      throw Po.bytes = 0, new RangeError(\"Could not decode varint\");\n    o = r[s++], t += n < 28 ? (o & nh) << n : (o & nh) * Math.pow(2, n), n += 7;\n  } while (o >= j6);\n  return Po.bytes = s - i, t;\n}\nvar K6 = Math.pow(2, 7), H6 = Math.pow(2, 14), V6 = Math.pow(2, 21), W6 = Math.pow(2, 28), G6 = Math.pow(2, 35), J6 = Math.pow(2, 42), Y6 = Math.pow(2, 49), X6 = Math.pow(2, 56), Z6 = Math.pow(2, 63), Q6 = function(r) {\n  return r < K6 ? 1 : r < H6 ? 2 : r < V6 ? 3 : r < W6 ? 4 : r < G6 ? 5 : r < J6 ? 6 : r < Y6 ? 7 : r < X6 ? 8 : r < Z6 ? 9 : 10;\n}, ew = { encode: q6, decode: k6, encodingLength: Q6 }, Nd = ew;\nconst sh = (r, e, t = 0) => (Nd.encode(r, e, t), e), ah = (r) => Nd.encodingLength(r), Oo = (r, e) => {\n  const t = e.byteLength, i = ah(r), n = i + ah(t), s = new Uint8Array(n + t);\n  return sh(r, s, 0), sh(t, s, i), s.set(e, n), new tw(r, t, e, s);\n};\nclass tw {\n  constructor(e, t, i, n) {\n    this.code = e, this.size = t, this.digest = i, this.bytes = n;\n  }\n}\nconst Td = ({ name: r, code: e, encode: t }) => new rw(r, e, t);\nclass rw {\n  constructor(e, t, i) {\n    this.name = e, this.code = t, this.encode = i;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? Oo(this.code, t) : t.then((i) => Oo(this.code, i));\n    } else\n      throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst Cd = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e)), iw = Td({ name: \"sha2-256\", code: 18, encode: Cd(\"SHA-256\") }), nw = Td({ name: \"sha2-512\", code: 19, encode: Cd(\"SHA-512\") });\nvar sw = Object.freeze({ __proto__: null, sha256: iw, sha512: nw });\nconst $d = 0, aw = \"identity\", Ld = Dd, ow = (r) => Oo($d, Ld(r)), fw = { code: $d, name: aw, encode: Ld, digest: ow };\nvar cw = Object.freeze({ __proto__: null, identity: fw });\nnew TextEncoder(), new TextDecoder();\nconst oh = { ...t6, ...i6, ...s6, ...o6, ...h6, ...w6, ...E6, ...I6, ...R6, ...F6 };\n({ ...sw, ...cw });\nfunction hw(r = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r);\n}\nfunction Fd(r, e, t, i) {\n  return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: i } };\n}\nconst fh = Fd(\"utf8\", \"u\", (r) => \"u\" + new TextDecoder(\"utf8\").decode(r), (r) => new TextEncoder().encode(r.substring(1))), ro = Fd(\"ascii\", \"a\", (r) => {\n  let e = \"a\";\n  for (let t = 0; t < r.length; t++)\n    e += String.fromCharCode(r[t]);\n  return e;\n}, (r) => {\n  r = r.substring(1);\n  const e = hw(r.length);\n  for (let t = 0; t < r.length; t++)\n    e[t] = r.charCodeAt(t);\n  return e;\n}), uw = { utf8: fh, \"utf-8\": fh, hex: oh.base16, latin1: ro, ascii: ro, binary: ro, ...oh };\nfunction dw(r, e = \"utf8\") {\n  const t = uw[e];\n  if (!t)\n    throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, \"utf8\") : t.decoder.decode(`${t.prefix}${r}`);\n}\nclass lw {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = l3, this.version = p3, this.initialized = !1, this.storagePrefix = jr, this.init = async () => {\n      if (!this.initialized) {\n        const i = await this.getKeyChain();\n        typeof i < \"u\" && (this.keychain = i), this.initialized = !0;\n      }\n    }, this.has = (i) => (this.isInitialized(), this.keychain.has(i)), this.set = async (i, n) => {\n      this.isInitialized(), this.keychain.set(i, n), await this.persist();\n    }, this.get = (i) => {\n      this.isInitialized();\n      const n = this.keychain.get(i);\n      if (typeof n > \"u\") {\n        const { message: s } = ae(\"NO_MATCHING_KEY\", `${this.name}: ${i}`);\n        throw new Error(s);\n      }\n      return n;\n    }, this.del = async (i) => {\n      this.isInitialized(), this.keychain.delete(i), await this.persist();\n    }, this.core = e, this.logger = kt(t, this.name);\n  }\n  get context() {\n    return Zt(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  async setKeyChain(e) {\n    await this.core.storage.setItem(this.storageKey, id(e));\n  }\n  async getKeyChain() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? nd(e) : void 0;\n  }\n  async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = ae(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass pw {\n  constructor(e, t, i) {\n    this.core = e, this.logger = t, this.name = u3, this.randomSessionIdentifier = Ao(), this.initialized = !1, this.init = async () => {\n      this.initialized || (await this.keychain.init(), this.initialized = !0);\n    }, this.hasKeys = (n) => (this.isInitialized(), this.keychain.has(n)), this.getClientId = async () => {\n      this.isInitialized();\n      const n = await this.getClientSeed(), s = Hf(n);\n      return fu(s.publicKey);\n    }, this.generateKeyPair = () => {\n      this.isInitialized();\n      const n = Fy();\n      return this.setPrivateKey(n.publicKey, n.privateKey);\n    }, this.signJWT = async (n) => {\n      this.isInitialized();\n      const s = await this.getClientSeed(), o = Hf(s), f = this.randomSessionIdentifier;\n      return await ev(f, n, d3, o);\n    }, this.generateSharedKey = (n, s, o) => {\n      this.isInitialized();\n      const f = this.getPrivateKey(n), h = qy(f, s);\n      return this.setSymKey(h, o);\n    }, this.setSymKey = async (n, s) => {\n      this.isInitialized();\n      const o = s || Cs(n);\n      return await this.keychain.set(o, n), o;\n    }, this.deleteKeyPair = async (n) => {\n      this.isInitialized(), await this.keychain.del(n);\n    }, this.deleteSymKey = async (n) => {\n      this.isInitialized(), await this.keychain.del(n);\n    }, this.encode = async (n, s, o) => {\n      this.isInitialized();\n      const f = pd(o), h = ji(s);\n      if (Lc(f))\n        return zy(h, o?.encoding);\n      if ($c(f)) {\n        const A = f.senderPublicKey, I = f.receiverPublicKey;\n        n = await this.generateSharedKey(A, I);\n      }\n      const d = this.getSymKey(n), { type: v, senderPublicKey: w } = f;\n      return Uy({ type: v, symKey: d, message: h, senderPublicKey: w, encoding: o?.encoding });\n    }, this.decode = async (n, s, o) => {\n      this.isInitialized();\n      const f = jy(s, o);\n      if (Lc(f)) {\n        const h = ky(s, o?.encoding);\n        return un(h);\n      }\n      if ($c(f)) {\n        const h = f.receiverPublicKey, d = f.senderPublicKey;\n        n = await this.generateSharedKey(h, d);\n      }\n      try {\n        const h = this.getSymKey(n), d = By({ symKey: h, encoded: s, encoding: o?.encoding });\n        return un(d);\n      } catch (h) {\n        this.logger.error(`Failed to decode message from topic: '${n}', clientId: '${await this.getClientId()}'`), this.logger.error(h);\n      }\n    }, this.getPayloadType = (n, s = wi) => {\n      const o = Zn({ encoded: n, encoding: s });\n      return Vi(o.type);\n    }, this.getPayloadSenderPublicKey = (n, s = wi) => {\n      const o = Zn({ encoded: n, encoding: s });\n      return o.senderPublicKey ? Mt(o.senderPublicKey, Bt) : void 0;\n    }, this.core = e, this.logger = kt(t, this.name), this.keychain = i || new lw(this.core, this.logger);\n  }\n  get context() {\n    return Zt(this.logger);\n  }\n  async setPrivateKey(e, t) {\n    return await this.keychain.set(e, t), e;\n  }\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n  async getClientSeed() {\n    let e = \"\";\n    try {\n      e = this.keychain.get(eh);\n    } catch {\n      e = Ao(), await this.keychain.set(eh, e);\n    }\n    return dw(e, \"base16\");\n  }\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = ae(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass vw extends sp {\n  constructor(e, t) {\n    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = v3, this.version = b3, this.initialized = !1, this.storagePrefix = jr, this.init = async () => {\n      if (!this.initialized) {\n        this.logger.trace(\"Initialized\");\n        try {\n          const i = await this.getRelayerMessages();\n          typeof i < \"u\" && (this.messages = i), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", size: this.messages.size });\n        } catch (i) {\n          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i);\n        } finally {\n          this.initialized = !0;\n        }\n      }\n    }, this.set = async (i, n) => {\n      this.isInitialized();\n      const s = fi(n);\n      let o = this.messages.get(i);\n      return typeof o > \"u\" && (o = {}), typeof o[s] < \"u\" || (o[s] = n, this.messages.set(i, o), await this.persist()), s;\n    }, this.get = (i) => {\n      this.isInitialized();\n      let n = this.messages.get(i);\n      return typeof n > \"u\" && (n = {}), n;\n    }, this.has = (i, n) => {\n      this.isInitialized();\n      const s = this.get(i), o = fi(n);\n      return typeof s[o] < \"u\";\n    }, this.del = async (i) => {\n      this.isInitialized(), this.messages.delete(i), await this.persist();\n    }, this.logger = kt(e, this.name), this.core = t;\n  }\n  get context() {\n    return Zt(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  async setRelayerMessages(e) {\n    await this.core.storage.setItem(this.storageKey, id(e));\n  }\n  async getRelayerMessages() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? nd(e) : void 0;\n  }\n  async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = ae(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar bw = Object.defineProperty, gw = Object.defineProperties, yw = Object.getOwnPropertyDescriptors, ch = Object.getOwnPropertySymbols, mw = Object.prototype.hasOwnProperty, ww = Object.prototype.propertyIsEnumerable, hh = (r, e, t) => e in r ? bw(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, uh = (r, e) => {\n  for (var t in e || (e = {}))\n    mw.call(e, t) && hh(r, t, e[t]);\n  if (ch)\n    for (var t of ch(e))\n      ww.call(e, t) && hh(r, t, e[t]);\n  return r;\n}, dh = (r, e) => gw(r, yw(e));\nclass _w extends ap {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.events = new ir.EventEmitter(), this.name = g3, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = ie.toMiliseconds(ie.ONE_MINUTE), this.initialPublishTimeout = ie.toMiliseconds(ie.ONE_SECOND * 15), this.needsTransportRestart = !1, this.publish = async (i, n, s) => {\n      var o;\n      this.logger.debug(\"Publishing Payload\"), this.logger.trace({ type: \"method\", method: \"publish\", params: { topic: i, message: n, opts: s } });\n      const f = s?.ttl || th, h = Ys(s), d = s?.prompt || !1, v = s?.tag || 0, w = s?.id || zi().toString(), A = { topic: i, message: n, opts: { ttl: f, relay: h, prompt: d, tag: v, id: w, attestation: s?.attestation } }, I = `Failed to publish payload, please try again. id:${w} tag:${v}`;\n      try {\n        const D = new Promise(async (N) => {\n          const k = ({ id: T }) => {\n            A.opts.id === T && (this.removeRequestFromQueue(T), this.relayer.events.removeListener(Et.publish, k), N(A));\n          };\n          this.relayer.events.on(Et.publish, k);\n          const j = mi(new Promise((T, K) => {\n            this.rpcPublish({ topic: i, message: n, ttl: f, prompt: d, tag: v, id: w, attestation: s?.attestation }).then(T).catch(($) => {\n              this.logger.warn($, $?.message), K($);\n            });\n          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${w} tag:${v}`);\n          try {\n            await j, this.events.removeListener(Et.publish, k);\n          } catch (T) {\n            this.queue.set(w, dh(uh({}, A), { attempt: 1 })), this.logger.warn(T, T?.message);\n          }\n        });\n        this.logger.trace({ type: \"method\", method: \"publish\", params: { id: w, topic: i, message: n, opts: s } }), await mi(D, this.publishTimeout, I);\n      } catch (D) {\n        if (this.logger.debug(\"Failed to Publish Payload\"), this.logger.error(D), (o = s?.internal) != null && o.throwOnFailedPublish)\n          throw D;\n      } finally {\n        this.queue.delete(w);\n      }\n    }, this.on = (i, n) => {\n      this.events.on(i, n);\n    }, this.once = (i, n) => {\n      this.events.once(i, n);\n    }, this.off = (i, n) => {\n      this.events.off(i, n);\n    }, this.removeListener = (i, n) => {\n      this.events.removeListener(i, n);\n    }, this.relayer = e, this.logger = kt(t, this.name), this.registerEventListeners();\n  }\n  get context() {\n    return Zt(this.logger);\n  }\n  async rpcPublish(e) {\n    var t, i, n, s;\n    const { topic: o, message: f, ttl: h = th, prompt: d, tag: v, id: w, attestation: A } = e, I = { method: jn(Ys().protocol).publish, params: { topic: o, message: f, ttl: h, prompt: d, tag: v, attestation: A }, id: w };\n    zt((t = I.params) == null ? void 0 : t.prompt) && ((i = I.params) == null || delete i.prompt), zt((n = I.params) == null ? void 0 : n.tag) && ((s = I.params) == null || delete s.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"message\", direction: \"outgoing\", request: I });\n    const D = await this.relayer.request(I);\n    return this.relayer.events.emit(Et.publish, e), this.logger.debug(\"Successfully Published Payload\"), D;\n  }\n  removeRequestFromQueue(e) {\n    this.queue.delete(e);\n  }\n  checkQueue() {\n    this.queue.forEach(async (e, t) => {\n      const i = e.attempt + 1;\n      this.queue.set(t, dh(uh({}, e), { attempt: i }));\n      const { topic: n, message: s, opts: o, attestation: f } = e;\n      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${i}`), await this.rpcPublish({ topic: n, message: s, ttl: o.ttl, prompt: o.prompt, tag: o.tag, id: o.id, attestation: f }), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);\n    });\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(gn.pulse, () => {\n      if (this.needsTransportRestart) {\n        this.needsTransportRestart = !1, this.relayer.events.emit(Et.connection_stalled);\n        return;\n      }\n      this.checkQueue();\n    }), this.relayer.on(Et.message_ack, (e) => {\n      this.removeRequestFromQueue(e.id.toString());\n    });\n  }\n}\nclass xw {\n  constructor() {\n    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {\n      const i = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...i, t]);\n    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n      if (!this.map.has(e))\n        return;\n      const i = this.get(e);\n      if (!this.exists(e, t))\n        return;\n      const n = i.filter((s) => s !== t);\n      if (!n.length) {\n        this.map.delete(e);\n        return;\n      }\n      this.map.set(e, n);\n    }, this.clear = () => {\n      this.map.clear();\n    };\n  }\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n}\nvar Ew = Object.defineProperty, Sw = Object.defineProperties, Mw = Object.getOwnPropertyDescriptors, lh = Object.getOwnPropertySymbols, Iw = Object.prototype.hasOwnProperty, Aw = Object.prototype.propertyIsEnumerable, ph = (r, e, t) => e in r ? Ew(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, zn = (r, e) => {\n  for (var t in e || (e = {}))\n    Iw.call(e, t) && ph(r, t, e[t]);\n  if (lh)\n    for (var t of lh(e))\n      Aw.call(e, t) && ph(r, t, e[t]);\n  return r;\n}, io = (r, e) => Sw(r, Mw(e));\nclass Dw extends cp {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new xw(), this.events = new ir.EventEmitter(), this.name = S3, this.version = M3, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = \"pending_sub_watch_label\", this.pollingInterval = 20, this.storagePrefix = jr, this.subscribeTimeout = ie.toMiliseconds(ie.ONE_MINUTE), this.initialSubscribeTimeout = ie.toMiliseconds(ie.ONE_SECOND * 15), this.batchSubscribeTopicsLimit = 500, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = !0;\n    }, this.subscribe = async (i, n) => {\n      this.isInitialized(), this.logger.debug(\"Subscribing Topic\"), this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic: i, opts: n } });\n      try {\n        const s = Ys(n), o = { topic: i, relay: s, transportType: n?.transportType };\n        this.pending.set(i, o);\n        const f = await this.rpcSubscribe(i, s, n);\n        return typeof f == \"string\" && (this.onSubscribe(f, o), this.logger.debug(\"Successfully Subscribed Topic\"), this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic: i, opts: n } })), f;\n      } catch (s) {\n        throw this.logger.debug(\"Failed to Subscribe Topic\"), this.logger.error(s), s;\n      }\n    }, this.unsubscribe = async (i, n) => {\n      await this.restartToComplete(), this.isInitialized(), typeof n?.id < \"u\" ? await this.unsubscribeById(i, n.id, n) : await this.unsubscribeByTopic(i, n);\n    }, this.isSubscribed = async (i) => {\n      if (this.topics.includes(i))\n        return !0;\n      const n = `${this.pendingSubscriptionWatchLabel}_${i}`;\n      return await new Promise((s, o) => {\n        const f = new ie.Watch();\n        f.start(n);\n        const h = setInterval(() => {\n          (!this.pending.has(i) && this.topics.includes(i) || this.cached.some((d) => d.topic === i)) && (clearInterval(h), f.stop(n), s(!0)), f.elapsed(n) >= I3 && (clearInterval(h), f.stop(n), o(new Error(\"Subscription resolution timeout\")));\n        }, this.pollingInterval);\n      }).catch(() => !1);\n    }, this.on = (i, n) => {\n      this.events.on(i, n);\n    }, this.once = (i, n) => {\n      this.events.once(i, n);\n    }, this.off = (i, n) => {\n      this.events.off(i, n);\n    }, this.removeListener = (i, n) => {\n      this.events.removeListener(i, n);\n    }, this.start = async () => {\n      await this.onConnect();\n    }, this.stop = async () => {\n      await this.onDisconnect();\n    }, this.restart = async () => {\n      await this.restore(), await this.onRestart();\n    }, this.checkPending = async () => {\n      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected))\n        return;\n      const i = [];\n      this.pending.forEach((n) => {\n        i.push(n);\n      }), await this.batchSubscribe(i);\n    }, this.registerEventListeners = () => {\n      this.relayer.core.heartbeat.on(gn.pulse, async () => {\n        await this.checkPending();\n      }), this.events.on(er.created, async (i) => {\n        const n = er.created;\n        this.logger.info(`Emitting ${n}`), this.logger.debug({ type: \"event\", event: n, data: i }), await this.persist();\n      }), this.events.on(er.deleted, async (i) => {\n        const n = er.deleted;\n        this.logger.info(`Emitting ${n}`), this.logger.debug({ type: \"event\", event: n, data: i }), await this.persist();\n      });\n    }, this.relayer = e, this.logger = kt(t, this.name), this.clientId = \"\";\n  }\n  get context() {\n    return Zt(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.subscriptions.size;\n  }\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n  get topics() {\n    return this.topicMap.topics;\n  }\n  hasSubscription(e, t) {\n    let i = !1;\n    try {\n      i = this.getSubscription(e).topic === t;\n    } catch {\n    }\n    return i;\n  }\n  reset() {\n    this.cached = [], this.initialized = !0;\n  }\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();\n  }\n  async unsubscribeByTopic(e, t) {\n    const i = this.topicMap.get(e);\n    await Promise.all(i.map(async (n) => await this.unsubscribeById(e, n, t)));\n  }\n  async unsubscribeById(e, t, i) {\n    this.logger.debug(\"Unsubscribing Topic\"), this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic: e, id: t, opts: i } });\n    try {\n      const n = Ys(i);\n      await this.rpcUnsubscribe(e, t, n);\n      const s = st(\"USER_DISCONNECTED\", `${this.name}, ${e}`);\n      await this.onUnsubscribe(e, t, s), this.logger.debug(\"Successfully Unsubscribed Topic\"), this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic: e, id: t, opts: i } });\n    } catch (n) {\n      throw this.logger.debug(\"Failed to Unsubscribe Topic\"), this.logger.error(n), n;\n    }\n  }\n  async rpcSubscribe(e, t, i) {\n    var n;\n    i?.transportType === at.relay && await this.restartToComplete();\n    const s = { method: jn(t.protocol).subscribe, params: { topic: e } };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: s });\n    const o = (n = i?.internal) == null ? void 0 : n.throwOnFailedPublish;\n    try {\n      const f = this.getSubscriptionId(e);\n      if (i?.transportType === at.link_mode)\n        return setTimeout(() => {\n          (this.relayer.connected || this.relayer.connecting) && this.relayer.request(s).catch((v) => this.logger.warn(v));\n        }, ie.toMiliseconds(ie.ONE_SECOND)), f;\n      const h = new Promise(async (v) => {\n        const w = (A) => {\n          A.topic === e && (this.events.removeListener(er.created, w), v(A.id));\n        };\n        this.events.on(er.created, w);\n        try {\n          const A = await mi(new Promise((I, D) => {\n            this.relayer.request(s).catch((N) => {\n              this.logger.warn(N, N?.message), D(N);\n            }).then(I);\n          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);\n          this.events.removeListener(er.created, w), v(A);\n        } catch {\n        }\n      }), d = await mi(h, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);\n      if (!d && o)\n        throw new Error(`Subscribing to ${e} failed, please try again`);\n      return d ? f : null;\n    } catch (f) {\n      if (this.logger.debug(\"Outgoing Relay Subscribe Payload stalled\"), this.relayer.events.emit(Et.connection_stalled), o)\n        throw f;\n    }\n    return null;\n  }\n  async rpcBatchSubscribe(e) {\n    if (!e.length)\n      return;\n    const t = e[0].relay, i = { method: jn(t.protocol).batchSubscribe, params: { topics: e.map((n) => n.topic) } };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: i });\n    try {\n      await await mi(new Promise((n) => {\n        this.relayer.request(i).catch((s) => this.logger.warn(s)).then(n);\n      }), this.subscribeTimeout, \"rpcBatchSubscribe failed, please try again\");\n    } catch {\n      this.relayer.events.emit(Et.connection_stalled);\n    }\n  }\n  async rpcBatchFetchMessages(e) {\n    if (!e.length)\n      return;\n    const t = e[0].relay, i = { method: jn(t.protocol).batchFetchMessages, params: { topics: e.map((s) => s.topic) } };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: i });\n    let n;\n    try {\n      n = await await mi(new Promise((s, o) => {\n        this.relayer.request(i).catch((f) => {\n          this.logger.warn(f), o(f);\n        }).then(s);\n      }), this.subscribeTimeout, \"rpcBatchFetchMessages failed, please try again\");\n    } catch {\n      this.relayer.events.emit(Et.connection_stalled);\n    }\n    return n;\n  }\n  rpcUnsubscribe(e, t, i) {\n    const n = { method: jn(i.protocol).unsubscribe, params: { topic: e, id: t } };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: n }), this.relayer.request(n);\n  }\n  onSubscribe(e, t) {\n    this.setSubscription(e, io(zn({}, t), { id: e })), this.pending.delete(t.topic);\n  }\n  onBatchSubscribe(e) {\n    e.length && e.forEach((t) => {\n      this.setSubscription(t.id, zn({}, t)), this.pending.delete(t.topic);\n    });\n  }\n  async onUnsubscribe(e, t, i) {\n    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i), await this.relayer.messages.del(e);\n  }\n  async setRelayerSubscriptions(e) {\n    await this.relayer.core.storage.setItem(this.storageKey, e);\n  }\n  async getRelayerSubscriptions() {\n    return await this.relayer.core.storage.getItem(this.storageKey);\n  }\n  setSubscription(e, t) {\n    this.logger.debug(\"Setting subscription\"), this.logger.trace({ type: \"method\", method: \"setSubscription\", id: e, subscription: t }), this.addSubscription(e, t);\n  }\n  addSubscription(e, t) {\n    this.subscriptions.set(e, zn({}, t)), this.topicMap.set(t.topic, e), this.events.emit(er.created, t);\n  }\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({ type: \"method\", method: \"getSubscription\", id: e });\n    const t = this.subscriptions.get(e);\n    if (!t) {\n      const { message: i } = ae(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(i);\n    }\n    return t;\n  }\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({ type: \"method\", method: \"deleteSubscription\", id: e, reason: t });\n    const i = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(i.topic, e), this.events.emit(er.deleted, io(zn({}, i), { reason: t }));\n  }\n  async persist() {\n    await this.setRelayerSubscriptions(this.values), this.events.emit(er.sync);\n  }\n  async onRestart() {\n    if (this.cached.length) {\n      const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);\n      for (let i = 0; i < t; i++) {\n        const n = e.splice(0, this.batchSubscribeTopicsLimit);\n        await this.batchSubscribe(n);\n      }\n    }\n    this.events.emit(er.resubscribed);\n  }\n  async restore() {\n    try {\n      const e = await this.getRelayerSubscriptions();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.subscriptions.size) {\n        const { message: t } = ae(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", subscriptions: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);\n    }\n  }\n  async batchSubscribe(e) {\n    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(e.map((t) => io(zn({}, t), { id: this.getSubscriptionId(t.topic) }))));\n  }\n  async batchFetchMessages(e) {\n    if (!e.length)\n      return;\n    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);\n    const t = await this.rpcBatchFetchMessages(e);\n    t && t.messages && (await dy(ie.toMiliseconds(ie.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));\n  }\n  async onConnect() {\n    await this.restart(), this.reset();\n  }\n  onDisconnect() {\n    this.onDisable();\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = ae(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async restartToComplete() {\n    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen();\n  }\n  getSubscriptionId(e) {\n    return fi(e + this.clientId);\n  }\n}\nvar Pw = Object.defineProperty, vh = Object.getOwnPropertySymbols, Ow = Object.prototype.hasOwnProperty, Rw = Object.prototype.propertyIsEnumerable, bh = (r, e, t) => e in r ? Pw(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, gh = (r, e) => {\n  for (var t in e || (e = {}))\n    Ow.call(e, t) && bh(r, t, e[t]);\n  if (vh)\n    for (var t of vh(e))\n      Rw.call(e, t) && bh(r, t, e[t]);\n  return r;\n};\nclass Nw extends op {\n  constructor(e) {\n    super(e), this.protocol = \"wc\", this.version = 2, this.events = new ir.EventEmitter(), this.name = m3, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1, this.heartBeatTimeout = ie.toMiliseconds(ie.THIRTY_SECONDS + ie.FIVE_SECONDS), this.requestsInFlight = [], this.connectTimeout = ie.toMiliseconds(ie.ONE_SECOND * 15), this.request = async (t) => {\n      var i, n;\n      this.logger.debug(\"Publishing Request Payload\");\n      const s = t.id || zi().toString();\n      await this.toEstablishConnection();\n      try {\n        this.logger.trace({ id: s, method: t.method, topic: (i = t.params) == null ? void 0 : i.topic }, \"relayer.request - publishing...\");\n        const o = `${s}:${((n = t.params) == null ? void 0 : n.tag) || \"\"}`;\n        this.requestsInFlight.push(o);\n        const f = await this.provider.request(t);\n        return this.requestsInFlight = this.requestsInFlight.filter((h) => h !== o), f;\n      } catch (o) {\n        throw this.logger.debug(`Failed to Publish Request: ${s}`), o;\n      }\n    }, this.resetPingTimeout = () => {\n      if (Gs())\n        try {\n          clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {\n            var t, i, n;\n            this.logger.debug({}, \"pingTimeout: Connection stalled, terminating...\"), (n = (i = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : i.socket) == null || n.terminate();\n          }, this.heartBeatTimeout);\n        } catch (t) {\n          this.logger.warn(t, t?.message);\n        }\n    }, this.onPayloadHandler = (t) => {\n      this.onProviderPayload(t), this.resetPingTimeout();\n    }, this.onConnectHandler = () => {\n      this.logger.warn({}, \"Relayer connected \"), this.startPingTimeout(), this.events.emit(Et.connect);\n    }, this.onDisconnectHandler = () => {\n      this.logger.warn({}, \"Relayer disconnected \"), this.requestsInFlight = [], this.onProviderDisconnect();\n    }, this.onProviderErrorHandler = (t) => {\n      this.logger.fatal(t, `Fatal socket error: ${t?.message}`), this.events.emit(Et.error, t), this.logger.fatal(\"Fatal socket error received, closing transport\"), this.transportClose();\n    }, this.registerProviderListeners = () => {\n      this.provider.on(hr.payload, this.onPayloadHandler), this.provider.on(hr.connect, this.onConnectHandler), this.provider.on(hr.disconnect, this.onDisconnectHandler), this.provider.on(hr.error, this.onProviderErrorHandler);\n    }, this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? kt(e.logger, this.name) : na(To({ level: e.logger || y3 })), this.messages = new vw(this.logger, e.core), this.subscriber = new Dw(this, this.logger), this.publisher = new _w(this, this.logger), this.relayUrl = e?.relayUrl || Id, this.projectId = e.projectId, Z2() ? this.packageName = Ic() : Q2() && (this.bundleId = Ic()), this.provider = {};\n  }\n  async init() {\n    if (this.logger.trace(\"Initialized\"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.cached.length > 0)\n      try {\n        await this.transportOpen();\n      } catch (e) {\n        this.logger.warn(e, e?.message);\n      }\n  }\n  get context() {\n    return Zt(this.logger);\n  }\n  get connected() {\n    var e, t, i;\n    return ((i = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i.readyState) === 1;\n  }\n  get connecting() {\n    var e, t, i;\n    return ((i = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i.readyState) === 0;\n  }\n  async publish(e, t, i) {\n    this.isInitialized(), await this.publisher.publish(e, t, i), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: at.relay });\n  }\n  async subscribe(e, t) {\n    var i, n, s;\n    this.isInitialized(), (!(t != null && t.transportType) || t?.transportType === \"relay\") && await this.toEstablishConnection();\n    const o = typeof ((i = t?.internal) == null ? void 0 : i.throwOnFailedPublish) > \"u\" ? !0 : (n = t?.internal) == null ? void 0 : n.throwOnFailedPublish;\n    let f = ((s = this.subscriber.topicMap.get(e)) == null ? void 0 : s[0]) || \"\", h;\n    const d = (v) => {\n      v.topic === e && (this.subscriber.off(er.created, d), h());\n    };\n    return await Promise.all([new Promise((v) => {\n      h = v, this.subscriber.on(er.created, d);\n    }), new Promise(async (v, w) => {\n      f = await this.subscriber.subscribe(e, gh({ internal: { throwOnFailedPublish: o } }, t)).catch((A) => {\n        o && w(A);\n      }) || f, v();\n    })]), f;\n  }\n  async unsubscribe(e, t) {\n    this.isInitialized(), await this.subscriber.unsubscribe(e, t);\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async transportDisconnect() {\n    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await mi(this.provider.disconnect(), 2e3, \"provider.disconnect()\").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();\n  }\n  async transportClose() {\n    this.transportExplicitlyClosed = !0, await this.transportDisconnect();\n  }\n  async transportOpen(e) {\n    if (this.connectPromise ? (this.logger.debug({}, \"Waiting for existing connection attempt to resolve...\"), await this.connectPromise, this.logger.debug({}, \"Existing connection attempt resolved\")) : (this.connectPromise = new Promise(async (t, i) => {\n      await this.connect(e).then(t).catch(i).finally(() => {\n        this.connectPromise = void 0;\n      });\n    }), await this.connectPromise), !this.connected)\n      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);\n  }\n  async restartTransport(e) {\n    this.logger.debug({}, \"Restarting transport...\"), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());\n  }\n  async confirmOnlineStateOrThrow() {\n    if (!await Wc())\n      throw new Error(\"No internet connection detected. Please restart your network and try again.\");\n  }\n  async handleBatchMessageEvents(e) {\n    if (e?.length === 0) {\n      this.logger.trace(\"Batch message events is empty. Ignoring...\");\n      return;\n    }\n    const t = e.sort((i, n) => i.publishedAt - n.publishedAt);\n    this.logger.debug(`Batch of ${t.length} message events sorted`);\n    for (const i of t)\n      try {\n        await this.onMessageEvent(i);\n      } catch (n) {\n        this.logger.warn(n, \"Error while processing batch message event: \" + n?.message);\n      }\n    this.logger.trace(`Batch of ${t.length} message events processed`);\n  }\n  async onLinkMessageEvent(e, t) {\n    const { topic: i } = e;\n    if (!t.sessionExists) {\n      const n = mt(ie.FIVE_MINUTES), s = { topic: i, expiry: n, relay: { protocol: \"irn\" }, active: !1 };\n      await this.core.pairing.pairings.set(i, s);\n    }\n    this.events.emit(Et.message, e), await this.recordMessageEvent(e);\n  }\n  async connect(e) {\n    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;\n    let t = 1;\n    for (; t < 6; ) {\n      try {\n        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (i, n) => {\n          const s = () => {\n            n(new Error(\"Connection interrupted while trying to subscribe\"));\n          };\n          this.provider.once(hr.disconnect, s), await mi(new Promise((o, f) => {\n            this.provider.connect().then(o).catch(f);\n          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o) => {\n            n(o);\n          }).finally(() => {\n            this.provider.off(hr.disconnect, s), clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;\n          }), await new Promise(async (o, f) => {\n            const h = () => {\n              f(new Error(\"Connection interrupted while trying to subscribe\"));\n            };\n            this.provider.once(hr.disconnect, h), await this.subscriber.start().then(o).catch(f).finally(() => {\n              this.provider.off(hr.disconnect, h);\n            });\n          }), this.hasExperiencedNetworkDisruption = !1, i();\n        });\n      } catch (i) {\n        await this.subscriber.stop();\n        const n = i;\n        this.logger.warn({}, n.message), this.hasExperiencedNetworkDisruption = !0;\n      } finally {\n        this.connectionAttemptInProgress = !1;\n      }\n      if (this.connected) {\n        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);\n        break;\n      }\n      await new Promise((i) => setTimeout(i, ie.toMiliseconds(t * 1))), t++;\n    }\n  }\n  startPingTimeout() {\n    var e, t, i, n, s;\n    if (Gs())\n      try {\n        (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((s = (n = (i = this.provider) == null ? void 0 : i.connection) == null ? void 0 : n.socket) == null || s.on(\"ping\", () => {\n          this.resetPingTimeout();\n        })), this.resetPingTimeout();\n      } catch (o) {\n        this.logger.warn(o, o?.message);\n      }\n  }\n  async createProvider() {\n    this.provider.connection && this.unregisterProviderListeners();\n    const e = await this.core.crypto.signJWT(this.relayUrl);\n    this.provider = new xd(new a3(iy({ sdkVersion: Do, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();\n  }\n  async recordMessageEvent(e) {\n    const { topic: t, message: i } = e;\n    await this.messages.set(t, i);\n  }\n  async shouldIgnoreMessageEvent(e) {\n    const { topic: t, message: i } = e;\n    if (!i || i.length === 0)\n      return this.logger.warn(`Ignoring invalid/empty message: ${i}`), !0;\n    if (!await this.subscriber.isSubscribed(t))\n      return this.logger.warn(`Ignoring message for non-subscribed topic ${t}`), !0;\n    const n = this.messages.has(t, i);\n    return n && this.logger.warn(`Ignoring duplicate message: ${i}`), n;\n  }\n  async onProviderPayload(e) {\n    if (this.logger.debug(\"Incoming Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"incoming\", payload: e }), ff(e)) {\n      if (!e.method.endsWith(w3))\n        return;\n      const t = e.params, { topic: i, message: n, publishedAt: s, attestation: o } = t.data, f = { topic: i, message: n, publishedAt: s, transportType: at.relay, attestation: o };\n      this.logger.debug(\"Emitting Relayer Payload\"), this.logger.trace(gh({ type: \"event\", event: t.id }, f)), this.events.emit(t.id, f), await this.acknowledgePayload(e), await this.onMessageEvent(f);\n    } else\n      Aa(e) && this.events.emit(Et.message_ack, e);\n  }\n  async onMessageEvent(e) {\n    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(Et.message, e), await this.recordMessageEvent(e));\n  }\n  async acknowledgePayload(e) {\n    const t = Ma(e.id, !0);\n    await this.provider.connection.send(t);\n  }\n  unregisterProviderListeners() {\n    this.provider.off(hr.payload, this.onPayloadHandler), this.provider.off(hr.connect, this.onConnectHandler), this.provider.off(hr.disconnect, this.onDisconnectHandler), this.provider.off(hr.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);\n  }\n  async registerEventListeners() {\n    let e = await Wc();\n    Lm(async (t) => {\n      e !== t && (e = t, t ? await this.transportOpen().catch((i) => this.logger.error(i, i?.message)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));\n    });\n  }\n  async onProviderDisconnect() {\n    await this.subscriber.stop(), clearTimeout(this.pingTimeout), this.events.emit(Et.disconnect), this.connectionAttemptInProgress = !1, !this.transportExplicitlyClosed && (this.reconnectTimeout || this.connectPromise || (this.reconnectTimeout = setTimeout(async () => {\n      clearTimeout(this.reconnectTimeout), await this.transportOpen().catch((e) => this.logger.error(e, e?.message));\n    }, ie.toMiliseconds(_3))));\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = ae(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async toEstablishConnection() {\n    await this.confirmOnlineStateOrThrow(), !this.connected && await this.transportOpen();\n  }\n}\nvar Tw = Object.defineProperty, yh = Object.getOwnPropertySymbols, Cw = Object.prototype.hasOwnProperty, $w = Object.prototype.propertyIsEnumerable, mh = (r, e, t) => e in r ? Tw(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, wh = (r, e) => {\n  for (var t in e || (e = {}))\n    Cw.call(e, t) && mh(r, t, e[t]);\n  if (yh)\n    for (var t of yh(e))\n      $w.call(e, t) && mh(r, t, e[t]);\n  return r;\n};\nclass Qi extends fp {\n  constructor(e, t, i, n = jr, s = void 0) {\n    super(e, t, i, n), this.core = e, this.logger = t, this.name = i, this.map = /* @__PURE__ */ new Map(), this.version = x3, this.cached = [], this.initialized = !1, this.storagePrefix = jr, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((o) => {\n        this.getKey && o !== null && !zt(o) ? this.map.set(this.getKey(o), o) : lm(o) ? this.map.set(o.id, o) : pm(o) && this.map.set(o.topic, o);\n      }), this.cached = [], this.initialized = !0);\n    }, this.set = async (o, f) => {\n      this.isInitialized(), this.map.has(o) ? await this.update(o, f) : (this.logger.debug(\"Setting value\"), this.logger.trace({ type: \"method\", method: \"set\", key: o, value: f }), this.map.set(o, f), await this.persist());\n    }, this.get = (o) => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({ type: \"method\", method: \"get\", key: o }), this.getData(o)), this.getAll = (o) => (this.isInitialized(), o ? this.values.filter((f) => Object.keys(o).every((h) => f3(f[h], o[h]))) : this.values), this.update = async (o, f) => {\n      this.isInitialized(), this.logger.debug(\"Updating value\"), this.logger.trace({ type: \"method\", method: \"update\", key: o, update: f });\n      const h = wh(wh({}, this.getData(o)), f);\n      this.map.set(o, h), await this.persist();\n    }, this.delete = async (o, f) => {\n      this.isInitialized(), this.map.has(o) && (this.logger.debug(\"Deleting value\"), this.logger.trace({ type: \"method\", method: \"delete\", key: o, reason: f }), this.map.delete(o), this.addToRecentlyDeleted(o), await this.persist());\n    }, this.logger = kt(t, this.name), this.storagePrefix = n, this.getKey = s;\n  }\n  get context() {\n    return Zt(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.map.size;\n  }\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n  get values() {\n    return Array.from(this.map.values());\n  }\n  addToRecentlyDeleted(e) {\n    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);\n  }\n  async setDataStore(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getDataStore() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getData(e) {\n    const t = this.map.get(e);\n    if (!t) {\n      if (this.recentlyDeleted.includes(e)) {\n        const { message: n } = ae(\"MISSING_OR_INVALID\", `Record was recently deleted - ${this.name}: ${e}`);\n        throw this.logger.error(n), new Error(n);\n      }\n      const { message: i } = ae(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(i), new Error(i);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setDataStore(this.values);\n  }\n  async restore() {\n    try {\n      const e = await this.getDataStore();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.map.size) {\n        const { message: t } = ae(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", value: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = ae(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Lw {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.name = A3, this.version = D3, this.events = new zh(), this.initialized = !1, this.storagePrefix = jr, this.ignoredPayloadTypes = [hi], this.registeredMethods = [], this.init = async () => {\n      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace(\"Initialized\"));\n    }, this.register = ({ methods: i }) => {\n      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i])];\n    }, this.create = async (i) => {\n      this.isInitialized();\n      const n = Ao(), s = await this.core.crypto.setSymKey(n), o = mt(ie.FIVE_MINUTES), f = { protocol: Md }, h = { topic: s, expiry: o, relay: f, active: !1, methods: i?.methods }, d = Bc({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: n, relay: f, expiryTimestamp: o, methods: i?.methods });\n      return this.events.emit(qi.create, h), this.core.expirer.set(s, o), await this.pairings.set(s, h), await this.core.relayer.subscribe(s, { transportType: i?.transportType }), { topic: s, uri: d };\n    }, this.pair = async (i) => {\n      this.isInitialized();\n      const n = this.core.eventClient.createEvent({ properties: { topic: i?.uri, trace: [Or.pairing_started] } });\n      this.isValidPair(i, n);\n      const { topic: s, symKey: o, relay: f, expiryTimestamp: h, methods: d } = zc(i.uri);\n      n.props.properties.topic = s, n.addTrace(Or.pairing_uri_validation_success), n.addTrace(Or.pairing_uri_not_expired);\n      let v;\n      if (this.pairings.keys.includes(s)) {\n        if (v = this.pairings.get(s), n.addTrace(Or.existing_pairing), v.active)\n          throw n.setError(ai.active_pairing_already_exists), new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);\n        n.addTrace(Or.pairing_not_expired);\n      }\n      const w = h || mt(ie.FIVE_MINUTES), A = { topic: s, relay: f, expiry: w, active: !1, methods: d };\n      this.core.expirer.set(s, w), await this.pairings.set(s, A), n.addTrace(Or.store_new_pairing), i.activatePairing && await this.activate({ topic: s }), this.events.emit(qi.create, A), n.addTrace(Or.emit_inactive_pairing), this.core.crypto.keychain.has(s) || await this.core.crypto.setSymKey(o, s), n.addTrace(Or.subscribing_pairing_topic);\n      try {\n        await this.core.relayer.confirmOnlineStateOrThrow();\n      } catch {\n        n.setError(ai.no_internet_connection);\n      }\n      try {\n        await this.core.relayer.subscribe(s, { relay: f });\n      } catch (I) {\n        throw n.setError(ai.subscribe_pairing_topic_failure), I;\n      }\n      return n.addTrace(Or.subscribe_pairing_topic_success), A;\n    }, this.activate = async ({ topic: i }) => {\n      this.isInitialized();\n      const n = mt(ie.THIRTY_DAYS);\n      this.core.expirer.set(i, n), await this.pairings.update(i, { active: !0, expiry: n });\n    }, this.ping = async (i) => {\n      this.isInitialized(), await this.isValidPing(i);\n      const { topic: n } = i;\n      if (this.pairings.keys.includes(n)) {\n        const s = await this.sendRequest(n, \"wc_pairingPing\", {}), { done: o, resolve: f, reject: h } = Li();\n        this.events.once(Xe(\"pairing_ping\", s), ({ error: d }) => {\n          d ? h(d) : f();\n        }), await o();\n      }\n    }, this.updateExpiry = async ({ topic: i, expiry: n }) => {\n      this.isInitialized(), await this.pairings.update(i, { expiry: n });\n    }, this.updateMetadata = async ({ topic: i, metadata: n }) => {\n      this.isInitialized(), await this.pairings.update(i, { peerMetadata: n });\n    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i) => {\n      this.isInitialized(), await this.isValidDisconnect(i);\n      const { topic: n } = i;\n      this.pairings.keys.includes(n) && (await this.sendRequest(n, \"wc_pairingDelete\", st(\"USER_DISCONNECTED\")), await this.deletePairing(n));\n    }, this.formatUriFromPairing = (i) => {\n      this.isInitialized();\n      const { topic: n, relay: s, expiry: o, methods: f } = i, h = this.core.crypto.keychain.get(n);\n      return Bc({ protocol: this.core.protocol, version: this.core.version, topic: n, symKey: h, relay: s, expiryTimestamp: o, methods: f });\n    }, this.sendRequest = async (i, n, s) => {\n      const o = Bi(n, s), f = await this.core.crypto.encode(i, o), h = qn[n].req;\n      return this.core.history.set(i, o), this.core.relayer.publish(i, f, h), o.id;\n    }, this.sendResult = async (i, n, s) => {\n      const o = Ma(i, s), f = await this.core.crypto.encode(n, o), h = await this.core.history.get(n, i), d = qn[h.request.method].res;\n      await this.core.relayer.publish(n, f, d), await this.core.history.resolve(o);\n    }, this.sendError = async (i, n, s) => {\n      const o = Ia(i, s), f = await this.core.crypto.encode(n, o), h = await this.core.history.get(n, i), d = qn[h.request.method] ? qn[h.request.method].res : qn.unregistered_method.res;\n      await this.core.relayer.publish(n, f, d), await this.core.history.resolve(o);\n    }, this.deletePairing = async (i, n) => {\n      await this.core.relayer.unsubscribe(i), await Promise.all([this.pairings.delete(i, st(\"USER_DISCONNECTED\")), this.core.crypto.deleteSymKey(i), n ? Promise.resolve() : this.core.expirer.del(i)]);\n    }, this.cleanup = async () => {\n      const i = this.pairings.getAll().filter((n) => gi(n.expiry));\n      await Promise.all(i.map((n) => this.deletePairing(n.topic)));\n    }, this.onRelayEventRequest = (i) => {\n      const { topic: n, payload: s } = i;\n      switch (s.method) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingRequest(n, s);\n        case \"wc_pairingDelete\":\n          return this.onPairingDeleteRequest(n, s);\n        default:\n          return this.onUnknownRpcMethodRequest(n, s);\n      }\n    }, this.onRelayEventResponse = async (i) => {\n      const { topic: n, payload: s } = i, o = (await this.core.history.get(n, s.id)).request.method;\n      switch (o) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingResponse(n, s);\n        default:\n          return this.onUnknownRpcMethodResponse(o);\n      }\n    }, this.onPairingPingRequest = async (i, n) => {\n      const { id: s } = n;\n      try {\n        this.isValidPing({ topic: i }), await this.sendResult(s, i, !0), this.events.emit(qi.ping, { id: s, topic: i });\n      } catch (o) {\n        await this.sendError(s, i, o), this.logger.error(o);\n      }\n    }, this.onPairingPingResponse = (i, n) => {\n      const { id: s } = n;\n      setTimeout(() => {\n        Rr(n) ? this.events.emit(Xe(\"pairing_ping\", s), {}) : dr(n) && this.events.emit(Xe(\"pairing_ping\", s), { error: n.error });\n      }, 500);\n    }, this.onPairingDeleteRequest = async (i, n) => {\n      const { id: s } = n;\n      try {\n        this.isValidDisconnect({ topic: i }), await this.deletePairing(i), this.events.emit(qi.delete, { id: s, topic: i });\n      } catch (o) {\n        await this.sendError(s, i, o), this.logger.error(o);\n      }\n    }, this.onUnknownRpcMethodRequest = async (i, n) => {\n      const { id: s, method: o } = n;\n      try {\n        if (this.registeredMethods.includes(o))\n          return;\n        const f = st(\"WC_METHOD_UNSUPPORTED\", o);\n        await this.sendError(s, i, f), this.logger.error(f);\n      } catch (f) {\n        await this.sendError(s, i, f), this.logger.error(f);\n      }\n    }, this.onUnknownRpcMethodResponse = (i) => {\n      this.registeredMethods.includes(i) || this.logger.error(st(\"WC_METHOD_UNSUPPORTED\", i));\n    }, this.isValidPair = (i, n) => {\n      var s;\n      if (!Gt(i)) {\n        const { message: f } = ae(\"MISSING_OR_INVALID\", `pair() params: ${i}`);\n        throw n.setError(ai.malformed_pairing_uri), new Error(f);\n      }\n      if (!dm(i.uri)) {\n        const { message: f } = ae(\"MISSING_OR_INVALID\", `pair() uri: ${i.uri}`);\n        throw n.setError(ai.malformed_pairing_uri), new Error(f);\n      }\n      const o = zc(i?.uri);\n      if (!((s = o?.relay) != null && s.protocol)) {\n        const { message: f } = ae(\"MISSING_OR_INVALID\", \"pair() uri#relay-protocol\");\n        throw n.setError(ai.malformed_pairing_uri), new Error(f);\n      }\n      if (!(o != null && o.symKey)) {\n        const { message: f } = ae(\"MISSING_OR_INVALID\", \"pair() uri#symKey\");\n        throw n.setError(ai.malformed_pairing_uri), new Error(f);\n      }\n      if (o != null && o.expiryTimestamp && ie.toMiliseconds(o?.expiryTimestamp) < Date.now()) {\n        n.setError(ai.pairing_expired);\n        const { message: f } = ae(\"EXPIRED\", \"pair() URI has expired. Please try again with a new connection URI.\");\n        throw new Error(f);\n      }\n    }, this.isValidPing = async (i) => {\n      if (!Gt(i)) {\n        const { message: s } = ae(\"MISSING_OR_INVALID\", `ping() params: ${i}`);\n        throw new Error(s);\n      }\n      const { topic: n } = i;\n      await this.isValidPairingTopic(n);\n    }, this.isValidDisconnect = async (i) => {\n      if (!Gt(i)) {\n        const { message: s } = ae(\"MISSING_OR_INVALID\", `disconnect() params: ${i}`);\n        throw new Error(s);\n      }\n      const { topic: n } = i;\n      await this.isValidPairingTopic(n);\n    }, this.isValidPairingTopic = async (i) => {\n      if (!bt(i, !1)) {\n        const { message: n } = ae(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${i}`);\n        throw new Error(n);\n      }\n      if (!this.pairings.keys.includes(i)) {\n        const { message: n } = ae(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${i}`);\n        throw new Error(n);\n      }\n      if (gi(this.pairings.get(i).expiry)) {\n        await this.deletePairing(i);\n        const { message: n } = ae(\"EXPIRED\", `pairing topic: ${i}`);\n        throw new Error(n);\n      }\n    }, this.core = e, this.logger = kt(t, this.name), this.pairings = new Qi(this.core, this.logger, this.name, this.storagePrefix);\n  }\n  get context() {\n    return Zt(this.logger);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = ae(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    this.core.relayer.on(Et.message, async (e) => {\n      const { topic: t, message: i, transportType: n } = e;\n      if (!this.pairings.keys.includes(t) || n === at.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))\n        return;\n      const s = await this.core.crypto.decode(t, i);\n      try {\n        ff(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({ topic: t, payload: s })) : Aa(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: t, payload: s }), this.core.history.delete(t, s.id));\n      } catch (o) {\n        this.logger.error(o);\n      }\n    });\n  }\n  registerExpirerEvents() {\n    this.core.expirer.on(ur.expired, async (e) => {\n      const { topic: t } = ad(e.target);\n      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(qi.expire, { topic: t }));\n    });\n  }\n}\nclass Fw extends np {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new ir.EventEmitter(), this.name = P3, this.version = O3, this.cached = [], this.initialized = !1, this.storagePrefix = jr, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((i) => this.records.set(i.id, i)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.set = (i, n, s) => {\n      if (this.isInitialized(), this.logger.debug(\"Setting JSON-RPC request history record\"), this.logger.trace({ type: \"method\", method: \"set\", topic: i, request: n, chainId: s }), this.records.has(n.id))\n        return;\n      const o = { id: n.id, topic: i, request: { method: n.method, params: n.params || null }, chainId: s, expiry: mt(ie.THIRTY_DAYS) };\n      this.records.set(o.id, o), this.persist(), this.events.emit(_r.created, o);\n    }, this.resolve = async (i) => {\n      if (this.isInitialized(), this.logger.debug(\"Updating JSON-RPC response history record\"), this.logger.trace({ type: \"method\", method: \"update\", response: i }), !this.records.has(i.id))\n        return;\n      const n = await this.getRecord(i.id);\n      typeof n.response > \"u\" && (n.response = dr(i) ? { error: i.error } : { result: i.result }, this.records.set(n.id, n), this.persist(), this.events.emit(_r.updated, n));\n    }, this.get = async (i, n) => (this.isInitialized(), this.logger.debug(\"Getting record\"), this.logger.trace({ type: \"method\", method: \"get\", topic: i, id: n }), await this.getRecord(n)), this.delete = (i, n) => {\n      this.isInitialized(), this.logger.debug(\"Deleting record\"), this.logger.trace({ type: \"method\", method: \"delete\", id: n }), this.values.forEach((s) => {\n        if (s.topic === i) {\n          if (typeof n < \"u\" && s.id !== n)\n            return;\n          this.records.delete(s.id), this.events.emit(_r.deleted, s);\n        }\n      }), this.persist();\n    }, this.exists = async (i, n) => (this.isInitialized(), this.records.has(n) ? (await this.getRecord(n)).topic === i : !1), this.on = (i, n) => {\n      this.events.on(i, n);\n    }, this.once = (i, n) => {\n      this.events.once(i, n);\n    }, this.off = (i, n) => {\n      this.events.off(i, n);\n    }, this.removeListener = (i, n) => {\n      this.events.removeListener(i, n);\n    }, this.logger = kt(t, this.name);\n  }\n  get context() {\n    return Zt(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get size() {\n    return this.records.size;\n  }\n  get keys() {\n    return Array.from(this.records.keys());\n  }\n  get values() {\n    return Array.from(this.records.values());\n  }\n  get pending() {\n    const e = [];\n    return this.values.forEach((t) => {\n      if (typeof t.response < \"u\")\n        return;\n      const i = { topic: t.topic, request: Bi(t.request.method, t.request.params, t.id), chainId: t.chainId };\n      return e.push(i);\n    }), e;\n  }\n  async setJsonRpcRecords(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getJsonRpcRecords() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getRecord(e) {\n    this.isInitialized();\n    const t = this.records.get(e);\n    if (!t) {\n      const { message: i } = ae(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(i);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setJsonRpcRecords(this.values), this.events.emit(_r.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getJsonRpcRecords();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.records.size) {\n        const { message: t } = ae(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", records: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);\n    }\n  }\n  registerEventListeners() {\n    this.events.on(_r.created, (e) => {\n      const t = _r.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e });\n    }), this.events.on(_r.updated, (e) => {\n      const t = _r.updated;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e });\n    }), this.events.on(_r.deleted, (e) => {\n      const t = _r.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e });\n    }), this.core.heartbeat.on(gn.pulse, () => {\n      this.cleanup();\n    });\n  }\n  cleanup() {\n    try {\n      this.isInitialized();\n      let e = !1;\n      this.records.forEach((t) => {\n        ie.toMiliseconds(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(_r.deleted, t, !1), e = !0);\n      }), e && this.persist();\n    } catch (e) {\n      this.logger.warn(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = ae(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass qw extends hp {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new ir.EventEmitter(), this.name = R3, this.version = N3, this.cached = [], this.initialized = !1, this.storagePrefix = jr, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((i) => this.expirations.set(i.target, i)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.has = (i) => {\n      try {\n        const n = this.formatTarget(i);\n        return typeof this.getExpiration(n) < \"u\";\n      } catch {\n        return !1;\n      }\n    }, this.set = (i, n) => {\n      this.isInitialized();\n      const s = this.formatTarget(i), o = { target: s, expiry: n };\n      this.expirations.set(s, o), this.checkExpiry(s, o), this.events.emit(ur.created, { target: s, expiration: o });\n    }, this.get = (i) => {\n      this.isInitialized();\n      const n = this.formatTarget(i);\n      return this.getExpiration(n);\n    }, this.del = (i) => {\n      if (this.isInitialized(), this.has(i)) {\n        const n = this.formatTarget(i), s = this.getExpiration(n);\n        this.expirations.delete(n), this.events.emit(ur.deleted, { target: n, expiration: s });\n      }\n    }, this.on = (i, n) => {\n      this.events.on(i, n);\n    }, this.once = (i, n) => {\n      this.events.once(i, n);\n    }, this.off = (i, n) => {\n      this.events.off(i, n);\n    }, this.removeListener = (i, n) => {\n      this.events.removeListener(i, n);\n    }, this.logger = kt(t, this.name);\n  }\n  get context() {\n    return Zt(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.expirations.size;\n  }\n  get keys() {\n    return Array.from(this.expirations.keys());\n  }\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n  formatTarget(e) {\n    if (typeof e == \"string\")\n      return ny(e);\n    if (typeof e == \"number\")\n      return sy(e);\n    const { message: t } = ae(\"UNKNOWN_TYPE\", `Target type: ${typeof e}`);\n    throw new Error(t);\n  }\n  async setExpirations(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getExpirations() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  async persist() {\n    await this.setExpirations(this.values), this.events.emit(ur.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getExpirations();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.expirations.size) {\n        const { message: t } = ae(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", expirations: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);\n    }\n  }\n  getExpiration(e) {\n    const t = this.expirations.get(e);\n    if (!t) {\n      const { message: i } = ae(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.warn(i), new Error(i);\n    }\n    return t;\n  }\n  checkExpiry(e, t) {\n    const { expiry: i } = t;\n    ie.toMiliseconds(i) - Date.now() <= 0 && this.expire(e, t);\n  }\n  expire(e, t) {\n    this.expirations.delete(e), this.events.emit(ur.expired, { target: e, expiration: t });\n  }\n  checkExpirations() {\n    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));\n  }\n  registerEventListeners() {\n    this.core.heartbeat.on(gn.pulse, () => this.checkExpirations()), this.events.on(ur.created, (e) => {\n      const t = ur.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    }), this.events.on(ur.expired, (e) => {\n      const t = ur.expired;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    }), this.events.on(ur.deleted, (e) => {\n      const t = ur.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = ae(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Uw extends up {\n  constructor(e, t, i) {\n    super(e, t, i), this.core = e, this.logger = t, this.store = i, this.name = T3, this.verifyUrlV3 = $3, this.storagePrefix = jr, this.version = Sd, this.init = async () => {\n      var n;\n      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && ie.toMiliseconds((n = this.publicKey) == null ? void 0 : n.expiresAt) < Date.now() && (this.logger.debug(\"verify v2 public key expired\"), await this.removePublicKey()));\n    }, this.register = async (n) => {\n      if (!cs() || this.isDevEnv)\n        return;\n      const s = window.location.origin, { id: o, decryptedId: f } = n, h = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${s}&id=${o}&decryptedId=${f}`;\n      try {\n        const d = is(), v = this.startAbortTimer(ie.ONE_SECOND * 5), w = await new Promise((A, I) => {\n          const D = () => {\n            window.removeEventListener(\"message\", k), d.body.removeChild(N), I(\"attestation aborted\");\n          };\n          this.abortController.signal.addEventListener(\"abort\", D);\n          const N = d.createElement(\"iframe\");\n          N.src = h, N.style.display = \"none\", N.addEventListener(\"error\", D, { signal: this.abortController.signal });\n          const k = (j) => {\n            if (j.data && typeof j.data == \"string\")\n              try {\n                const T = JSON.parse(j.data);\n                if (T.type === \"verify_attestation\") {\n                  if (bo(T.attestation).payload.id !== o)\n                    return;\n                  clearInterval(v), d.body.removeChild(N), this.abortController.signal.removeEventListener(\"abort\", D), window.removeEventListener(\"message\", k), A(T.attestation === null ? \"\" : T.attestation);\n                }\n              } catch (T) {\n                this.logger.warn(T);\n              }\n          };\n          d.body.appendChild(N), window.addEventListener(\"message\", k, { signal: this.abortController.signal });\n        });\n        return this.logger.debug(\"jwt attestation\", w), w;\n      } catch (d) {\n        this.logger.warn(d);\n      }\n      return \"\";\n    }, this.resolve = async (n) => {\n      if (this.isDevEnv)\n        return \"\";\n      const { attestationId: s, hash: o, encryptedId: f } = n;\n      if (s === \"\") {\n        this.logger.debug(\"resolve: attestationId is empty, skipping\");\n        return;\n      }\n      if (s) {\n        if (bo(s).payload.id !== f)\n          return;\n        const d = await this.isValidJwtAttestation(s);\n        if (d) {\n          if (!d.isVerified) {\n            this.logger.warn(\"resolve: jwt attestation: origin url not verified\");\n            return;\n          }\n          return d;\n        }\n      }\n      if (!o)\n        return;\n      const h = this.getVerifyUrl(n?.verifyUrl);\n      return this.fetchAttestation(o, h);\n    }, this.fetchAttestation = async (n, s) => {\n      this.logger.debug(`resolving attestation: ${n} from url: ${s}`);\n      const o = this.startAbortTimer(ie.ONE_SECOND * 5), f = await fetch(`${s}/attestation/${n}?v2Supported=true`, { signal: this.abortController.signal });\n      return clearTimeout(o), f.status === 200 ? await f.json() : void 0;\n    }, this.getVerifyUrl = (n) => {\n      let s = n || Vn;\n      return L3.includes(s) || (this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${Vn}`), s = Vn), s;\n    }, this.fetchPublicKey = async () => {\n      try {\n        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);\n        const n = this.startAbortTimer(ie.FIVE_SECONDS), s = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });\n        return clearTimeout(n), await s.json();\n      } catch (n) {\n        this.logger.warn(n);\n      }\n    }, this.persistPublicKey = async (n) => {\n      this.logger.debug(\"persisting public key to local storage\", n), await this.store.setItem(this.storeKey, n), this.publicKey = n;\n    }, this.removePublicKey = async () => {\n      this.logger.debug(\"removing verify v2 public key from storage\"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;\n    }, this.isValidJwtAttestation = async (n) => {\n      const s = await this.getPublicKey();\n      try {\n        if (s)\n          return this.validateAttestation(n, s);\n      } catch (f) {\n        this.logger.error(f), this.logger.warn(\"error validating attestation\");\n      }\n      const o = await this.fetchAndPersistPublicKey();\n      try {\n        if (o)\n          return this.validateAttestation(n, o);\n      } catch (f) {\n        this.logger.error(f), this.logger.warn(\"error validating attestation\");\n      }\n    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {\n      if (this.fetchPromise)\n        return await this.fetchPromise, this.publicKey;\n      this.fetchPromise = new Promise(async (s) => {\n        const o = await this.fetchPublicKey();\n        o && (await this.persistPublicKey(o), s(o));\n      });\n      const n = await this.fetchPromise;\n      return this.fetchPromise = void 0, n;\n    }, this.validateAttestation = (n, s) => {\n      const o = Wy(n, s.publicKey), f = { hasExpired: ie.toMiliseconds(o.exp) < Date.now(), payload: o };\n      if (f.hasExpired)\n        throw this.logger.warn(\"resolve: jwt attestation expired\"), new Error(\"JWT attestation expired\");\n      return { origin: f.payload.origin, isScam: f.payload.isScam, isVerified: f.payload.isVerified };\n    }, this.logger = kt(t, this.name), this.abortController = new AbortController(), this.isDevEnv = rf(), this.init();\n  }\n  get storeKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//verify:public:key\";\n  }\n  get context() {\n    return Zt(this.logger);\n  }\n  startAbortTimer(e) {\n    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), ie.toMiliseconds(e));\n  }\n}\nclass zw extends dp {\n  constructor(e, t) {\n    super(e, t), this.projectId = e, this.logger = t, this.context = F3, this.registerDeviceToken = async (i) => {\n      const { clientId: n, token: s, notificationType: o, enableEncrypted: f = !1 } = i, h = `${q3}/${this.projectId}/clients`;\n      await fetch(h, { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ client_id: n, type: o, token: s, always_raw: f }) });\n    }, this.logger = kt(t, this.context);\n  }\n}\nvar Bw = Object.defineProperty, _h = Object.getOwnPropertySymbols, kw = Object.prototype.hasOwnProperty, jw = Object.prototype.propertyIsEnumerable, xh = (r, e, t) => e in r ? Bw(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Bn = (r, e) => {\n  for (var t in e || (e = {}))\n    kw.call(e, t) && xh(r, t, e[t]);\n  if (_h)\n    for (var t of _h(e))\n      jw.call(e, t) && xh(r, t, e[t]);\n  return r;\n};\nclass Kw extends lp {\n  constructor(e, t, i = !0) {\n    super(e, t, i), this.core = e, this.logger = t, this.context = z3, this.storagePrefix = jr, this.storageVersion = U3, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = !1, this.init = async () => {\n      if (!rf())\n        try {\n          const n = { eventId: Dc(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: \"INIT\", type: \"\", properties: { client_id: await this.core.crypto.getClientId(), user_agent: rd(this.core.relayer.protocol, this.core.relayer.version, Do) } } };\n          await this.sendEvent([n]);\n        } catch (n) {\n          this.logger.warn(n);\n        }\n    }, this.createEvent = (n) => {\n      const { event: s = \"ERROR\", type: o = \"\", properties: { topic: f, trace: h } } = n, d = Dc(), v = this.core.projectId || \"\", w = Date.now(), A = Bn({ eventId: d, timestamp: w, props: { event: s, type: o, properties: { topic: f, trace: h } }, bundleId: v, domain: this.getAppDomain() }, this.setMethods(d));\n      return this.telemetryEnabled && (this.events.set(d, A), this.shouldPersist = !0), A;\n    }, this.getEvent = (n) => {\n      const { eventId: s, topic: o } = n;\n      if (s)\n        return this.events.get(s);\n      const f = Array.from(this.events.values()).find((h) => h.props.properties.topic === o);\n      if (f)\n        return Bn(Bn({}, f), this.setMethods(f.eventId));\n    }, this.deleteEvent = (n) => {\n      const { eventId: s } = n;\n      this.events.delete(s), this.shouldPersist = !0;\n    }, this.setEventListeners = () => {\n      this.core.heartbeat.on(gn.pulse, async () => {\n        this.shouldPersist && await this.persist(), this.events.forEach((n) => {\n          ie.fromMiliseconds(Date.now()) - ie.fromMiliseconds(n.timestamp) > B3 && (this.events.delete(n.eventId), this.shouldPersist = !0);\n        });\n      });\n    }, this.setMethods = (n) => ({ addTrace: (s) => this.addTrace(n, s), setError: (s) => this.setError(n, s) }), this.addTrace = (n, s) => {\n      const o = this.events.get(n);\n      o && (o.props.properties.trace.push(s), this.events.set(n, o), this.shouldPersist = !0);\n    }, this.setError = (n, s) => {\n      const o = this.events.get(n);\n      o && (o.props.type = s, o.timestamp = Date.now(), this.events.set(n, o), this.shouldPersist = !0);\n    }, this.persist = async () => {\n      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;\n    }, this.restore = async () => {\n      try {\n        const n = await this.core.storage.getItem(this.storageKey) || [];\n        if (!n.length)\n          return;\n        n.forEach((s) => {\n          this.events.set(s.eventId, Bn(Bn({}, s), this.setMethods(s.eventId)));\n        });\n      } catch (n) {\n        this.logger.warn(n);\n      }\n    }, this.submit = async () => {\n      if (!this.telemetryEnabled || this.events.size === 0)\n        return;\n      const n = [];\n      for (const [s, o] of this.events)\n        o.props.type && n.push(o);\n      if (n.length !== 0)\n        try {\n          if ((await this.sendEvent(n)).ok)\n            for (const s of n)\n              this.events.delete(s.eventId), this.shouldPersist = !0;\n        } catch (s) {\n          this.logger.warn(s);\n        }\n    }, this.sendEvent = async (n) => {\n      const s = this.getAppDomain() ? \"\" : \"&sp=desktop\";\n      return await fetch(`${k3}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${Do}${s}`, { method: \"POST\", body: JSON.stringify(n) });\n    }, this.getAppDomain = () => td().url, this.logger = kt(t, this.context), this.telemetryEnabled = i, i ? this.restore().then(async () => {\n      await this.submit(), this.setEventListeners();\n    }) : this.persist();\n  }\n  get storageKey() {\n    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + \"//\" + this.context;\n  }\n}\nvar Hw = Object.defineProperty, Eh = Object.getOwnPropertySymbols, Vw = Object.prototype.hasOwnProperty, Ww = Object.prototype.propertyIsEnumerable, Sh = (r, e, t) => e in r ? Hw(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Mh = (r, e) => {\n  for (var t in e || (e = {}))\n    Vw.call(e, t) && Sh(r, t, e[t]);\n  if (Eh)\n    for (var t of Eh(e))\n      Ww.call(e, t) && Sh(r, t, e[t]);\n  return r;\n};\nlet Gw = class qd extends ip {\n  constructor(e) {\n    var t;\n    super(e), this.protocol = Ed, this.version = Sd, this.name = ea, this.events = new ir.EventEmitter(), this.initialized = !1, this.on = (o, f) => this.events.on(o, f), this.once = (o, f) => this.events.once(o, f), this.off = (o, f) => this.events.off(o, f), this.removeListener = (o, f) => this.events.removeListener(o, f), this.dispatchEnvelope = ({ topic: o, message: f, sessionExists: h }) => {\n      if (!o || !f)\n        return;\n      const d = { topic: o, message: f, publishedAt: Date.now(), transportType: at.link_mode };\n      this.relayer.onLinkMessageEvent(d, { sessionExists: h });\n    }, this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || Id, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : \"\";\n    const i = To({ level: typeof e?.logger == \"string\" && e.logger ? e.logger : c3.logger, name: ea }), { logger: n, chunkLoggerController: s } = rp({ opts: i, maxSizeInBytes: e?.maxLogBlobSizeInBytes, loggerOverride: e?.logger });\n    this.logChunkController = s, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {\n      var o, f;\n      (o = this.logChunkController) != null && o.downloadLogsBlobInBrowser && ((f = this.logChunkController) == null || f.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));\n    }), this.logger = kt(n, this.name), this.heartbeat = new Gl(), this.crypto = new pw(this, this.logger, e?.keychain), this.history = new Fw(this, this.logger), this.expirer = new qw(this, this.logger), this.storage = e != null && e.storage ? e.storage : new D0(Mh(Mh({}, h3), e?.storageOptions)), this.relayer = new Nw({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Lw(this, this.logger), this.verify = new Uw(this, this.logger, this.storage), this.echoClient = new zw(this.projectId || \"\", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Kw(this, this.logger, e?.telemetryEnabled);\n  }\n  static async init(e) {\n    const t = new qd(e);\n    await t.initialize();\n    const i = await t.crypto.getClientId();\n    return await t.storage.setItem(E3, i), t;\n  }\n  get context() {\n    return Zt(this.logger);\n  }\n  async start() {\n    this.initialized || await this.initialize();\n  }\n  async getLogsBlob() {\n    var e;\n    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });\n  }\n  async addLinkModeSupportedApp(e) {\n    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(rh, this.linkModeSupportedApps));\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(rh) || [], this.initialized = !0, this.logger.info(\"Core Initialization Success\");\n    } catch (e) {\n      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;\n    }\n  }\n};\nconst Jw = Gw, Ud = \"wc\", zd = 2, Bd = \"client\", cf = `${Ud}@${zd}:${Bd}:`, no = { name: Bd, logger: \"error\", controller: !1, relayUrl: \"wss://relay.walletconnect.org\" }, Ih = \"WALLETCONNECT_DEEPLINK_CHOICE\", Yw = \"proposal\", Xw = \"Proposal expired\", Zw = \"session\", sn = ie.SEVEN_DAYS, Qw = \"engine\", _t = { wc_sessionPropose: { req: { ttl: ie.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: ie.FIVE_MINUTES, prompt: !1, tag: 1101 }, reject: { ttl: ie.FIVE_MINUTES, prompt: !1, tag: 1120 }, autoReject: { ttl: ie.FIVE_MINUTES, prompt: !1, tag: 1121 } }, wc_sessionSettle: { req: { ttl: ie.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: ie.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: ie.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: ie.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: ie.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: ie.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: ie.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: ie.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: ie.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: ie.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: ie.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: ie.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: ie.ONE_DAY, prompt: !1, tag: 1114 }, res: { ttl: ie.ONE_DAY, prompt: !1, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: ie.ONE_HOUR, prompt: !0, tag: 1116 }, res: { ttl: ie.ONE_HOUR, prompt: !1, tag: 1117 }, reject: { ttl: ie.FIVE_MINUTES, prompt: !1, tag: 1118 }, autoReject: { ttl: ie.FIVE_MINUTES, prompt: !1, tag: 1119 } } }, so = { min: ie.FIVE_MINUTES, max: ie.SEVEN_DAYS }, Pr = { idle: \"IDLE\", active: \"ACTIVE\" }, e5 = \"request\", t5 = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\", \"wc_sessionAuthenticate\"], r5 = \"wc\", i5 = \"auth\", n5 = \"authKeys\", s5 = \"pairingTopics\", a5 = \"requests\", Pa = `${r5}@${1.5}:${i5}:`, $s = `${Pa}:PUB_KEY`;\nvar o5 = Object.defineProperty, f5 = Object.defineProperties, c5 = Object.getOwnPropertyDescriptors, Ah = Object.getOwnPropertySymbols, h5 = Object.prototype.hasOwnProperty, u5 = Object.prototype.propertyIsEnumerable, Dh = (r, e, t) => e in r ? o5(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, lt = (r, e) => {\n  for (var t in e || (e = {}))\n    h5.call(e, t) && Dh(r, t, e[t]);\n  if (Ah)\n    for (var t of Ah(e))\n      u5.call(e, t) && Dh(r, t, e[t]);\n  return r;\n}, Er = (r, e) => f5(r, c5(e));\nclass d5 extends vp {\n  constructor(e) {\n    super(e), this.name = Qw, this.events = new zh(), this.initialized = !1, this.requestQueue = { state: Pr.idle, queue: [] }, this.sessionRequestQueue = { state: Pr.idle, queue: [] }, this.requestQueueDelay = ie.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(_t) }), this.initialized = !0, setTimeout(() => {\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();\n      }, ie.toMiliseconds(this.requestQueueDelay)));\n    }, this.connect = async (t) => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      const i = Er(lt({}, t), { requiredNamespaces: t.requiredNamespaces || {}, optionalNamespaces: t.optionalNamespaces || {} });\n      await this.isValidConnect(i);\n      const { pairingTopic: n, requiredNamespaces: s, optionalNamespaces: o, sessionProperties: f, relays: h } = i;\n      let d = n, v, w = !1;\n      try {\n        d && (w = this.client.core.pairing.pairings.get(d).active);\n      } catch ($) {\n        throw this.client.logger.error(`connect() -> pairing.get(${d}) failed`), $;\n      }\n      if (!d || !w) {\n        const { topic: $, uri: z } = await this.client.core.pairing.create();\n        d = $, v = z;\n      }\n      if (!d) {\n        const { message: $ } = ae(\"NO_MATCHING_KEY\", `connect() pairing topic: ${d}`);\n        throw new Error($);\n      }\n      const A = await this.client.core.crypto.generateKeyPair(), I = _t.wc_sessionPropose.req.ttl || ie.FIVE_MINUTES, D = mt(I), N = lt({ requiredNamespaces: s, optionalNamespaces: o, relays: h ?? [{ protocol: Md }], proposer: { publicKey: A, metadata: this.client.metadata }, expiryTimestamp: D, pairingTopic: d }, f && { sessionProperties: f }), { reject: k, resolve: j, done: T } = Li(I, Xw);\n      this.events.once(Xe(\"session_connect\"), async ({ error: $, session: z }) => {\n        if ($)\n          k($);\n        else if (z) {\n          z.self.publicKey = A;\n          const B = Er(lt({}, z), { pairingTopic: N.pairingTopic, requiredNamespaces: N.requiredNamespaces, optionalNamespaces: N.optionalNamespaces, transportType: at.relay });\n          await this.client.session.set(z.topic, B), await this.setExpiry(z.topic, z.expiry), d && await this.client.core.pairing.updateMetadata({ topic: d, metadata: z.peer.metadata }), this.cleanupDuplicatePairings(B), j(B);\n        }\n      });\n      const K = await this.sendRequest({ topic: d, method: \"wc_sessionPropose\", params: N, throwOnFailedPublish: !0 });\n      return await this.setProposal(K, lt({ id: K }, N)), { uri: v, approval: T };\n    }, this.pair = async (t) => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        return await this.client.core.pairing.pair(t);\n      } catch (i) {\n        throw this.client.logger.error(\"pair() failed\"), i;\n      }\n    }, this.approve = async (t) => {\n      var i, n, s;\n      const o = this.client.core.eventClient.createEvent({ properties: { topic: (i = t?.id) == null ? void 0 : i.toString(), trace: [xr.session_approve_started] } });\n      try {\n        this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      } catch (R) {\n        throw o.setError(Ti.no_internet_connection), R;\n      }\n      try {\n        await this.isValidProposalId(t?.id);\n      } catch (R) {\n        throw this.client.logger.error(`approve() -> proposal.get(${t?.id}) failed`), o.setError(Ti.proposal_not_found), R;\n      }\n      try {\n        await this.isValidApprove(t);\n      } catch (R) {\n        throw this.client.logger.error(\"approve() -> isValidApprove() failed\"), o.setError(Ti.session_approve_namespace_validation_failure), R;\n      }\n      const { id: f, relayProtocol: h, namespaces: d, sessionProperties: v, sessionConfig: w } = t, A = this.client.proposal.get(f);\n      this.client.core.eventClient.deleteEvent({ eventId: o.eventId });\n      const { pairingTopic: I, proposer: D, requiredNamespaces: N, optionalNamespaces: k } = A;\n      let j = (n = this.client.core.eventClient) == null ? void 0 : n.getEvent({ topic: I });\n      j || (j = (s = this.client.core.eventClient) == null ? void 0 : s.createEvent({ type: xr.session_approve_started, properties: { topic: I, trace: [xr.session_approve_started, xr.session_namespaces_validation_success] } }));\n      const T = await this.client.core.crypto.generateKeyPair(), K = D.publicKey, $ = await this.client.core.crypto.generateSharedKey(T, K), z = lt(lt({ relay: { protocol: h ?? \"irn\" }, namespaces: d, controller: { publicKey: T, metadata: this.client.metadata }, expiry: mt(sn) }, v && { sessionProperties: v }), w && { sessionConfig: w }), B = at.relay;\n      j.addTrace(xr.subscribing_session_topic);\n      try {\n        await this.client.core.relayer.subscribe($, { transportType: B });\n      } catch (R) {\n        throw j.setError(Ti.subscribe_session_topic_failure), R;\n      }\n      j.addTrace(xr.subscribe_session_topic_success);\n      const _ = Er(lt({}, z), { topic: $, requiredNamespaces: N, optionalNamespaces: k, pairingTopic: I, acknowledged: !1, self: z.controller, peer: { publicKey: D.publicKey, metadata: D.metadata }, controller: T, transportType: at.relay });\n      await this.client.session.set($, _), j.addTrace(xr.store_session);\n      try {\n        j.addTrace(xr.publishing_session_settle), await this.sendRequest({ topic: $, method: \"wc_sessionSettle\", params: z, throwOnFailedPublish: !0 }).catch((R) => {\n          throw j?.setError(Ti.session_settle_publish_failure), R;\n        }), j.addTrace(xr.session_settle_publish_success), j.addTrace(xr.publishing_session_approve), await this.sendResult({ id: f, topic: I, result: { relay: { protocol: h ?? \"irn\" }, responderPublicKey: T }, throwOnFailedPublish: !0 }).catch((R) => {\n          throw j?.setError(Ti.session_approve_publish_failure), R;\n        }), j.addTrace(xr.session_approve_publish_success);\n      } catch (R) {\n        throw this.client.logger.error(R), this.client.session.delete($, st(\"USER_DISCONNECTED\")), await this.client.core.relayer.unsubscribe($), R;\n      }\n      return this.client.core.eventClient.deleteEvent({ eventId: j.eventId }), await this.client.core.pairing.updateMetadata({ topic: I, metadata: D.metadata }), await this.client.proposal.delete(f, st(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({ topic: I }), await this.setExpiry($, mt(sn)), { topic: $, acknowledged: () => Promise.resolve(this.client.session.get($)) };\n    }, this.reject = async (t) => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidReject(t);\n      } catch (o) {\n        throw this.client.logger.error(\"reject() -> isValidReject() failed\"), o;\n      }\n      const { id: i, reason: n } = t;\n      let s;\n      try {\n        s = this.client.proposal.get(i).pairingTopic;\n      } catch (o) {\n        throw this.client.logger.error(`reject() -> proposal.get(${i}) failed`), o;\n      }\n      s && (await this.sendError({ id: i, topic: s, error: n, rpcOpts: _t.wc_sessionPropose.reject }), await this.client.proposal.delete(i, st(\"USER_DISCONNECTED\")));\n    }, this.update = async (t) => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidUpdate(t);\n      } catch (w) {\n        throw this.client.logger.error(\"update() -> isValidUpdate() failed\"), w;\n      }\n      const { topic: i, namespaces: n } = t, { done: s, resolve: o, reject: f } = Li(), h = oi(), d = zi().toString(), v = this.client.session.get(i).namespaces;\n      return this.events.once(Xe(\"session_update\", h), ({ error: w }) => {\n        w ? f(w) : o();\n      }), await this.client.session.update(i, { namespaces: n }), await this.sendRequest({ topic: i, method: \"wc_sessionUpdate\", params: { namespaces: n }, throwOnFailedPublish: !0, clientRpcId: h, relayRpcId: d }).catch((w) => {\n        this.client.logger.error(w), this.client.session.update(i, { namespaces: v }), f(w);\n      }), { acknowledged: s };\n    }, this.extend = async (t) => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidExtend(t);\n      } catch (h) {\n        throw this.client.logger.error(\"extend() -> isValidExtend() failed\"), h;\n      }\n      const { topic: i } = t, n = oi(), { done: s, resolve: o, reject: f } = Li();\n      return this.events.once(Xe(\"session_extend\", n), ({ error: h }) => {\n        h ? f(h) : o();\n      }), await this.setExpiry(i, mt(sn)), this.sendRequest({ topic: i, method: \"wc_sessionExtend\", params: {}, clientRpcId: n, throwOnFailedPublish: !0 }).catch((h) => {\n        f(h);\n      }), { acknowledged: s };\n    }, this.request = async (t) => {\n      this.isInitialized();\n      try {\n        await this.isValidRequest(t);\n      } catch (D) {\n        throw this.client.logger.error(\"request() -> isValidRequest() failed\"), D;\n      }\n      const { chainId: i, request: n, topic: s, expiry: o = _t.wc_sessionRequest.req.ttl } = t, f = this.client.session.get(s);\n      f?.transportType === at.relay && await this.confirmOnlineStateOrThrow();\n      const h = oi(), d = zi().toString(), { done: v, resolve: w, reject: A } = Li(o, \"Request expired. Please try again.\");\n      this.events.once(Xe(\"session_request\", h), ({ error: D, result: N }) => {\n        D ? A(D) : w(N);\n      });\n      const I = this.getAppLinkIfEnabled(f.peer.metadata, f.transportType);\n      return I ? (await this.sendRequest({ clientRpcId: h, relayRpcId: d, topic: s, method: \"wc_sessionRequest\", params: { request: Er(lt({}, n), { expiryTimestamp: mt(o) }), chainId: i }, expiry: o, throwOnFailedPublish: !0, appLink: I }).catch((D) => A(D)), this.client.events.emit(\"session_request_sent\", { topic: s, request: n, chainId: i, id: h }), await v()) : await Promise.all([new Promise(async (D) => {\n        await this.sendRequest({ clientRpcId: h, relayRpcId: d, topic: s, method: \"wc_sessionRequest\", params: { request: Er(lt({}, n), { expiryTimestamp: mt(o) }), chainId: i }, expiry: o, throwOnFailedPublish: !0 }).catch((N) => A(N)), this.client.events.emit(\"session_request_sent\", { topic: s, request: n, chainId: i, id: h }), D();\n      }), new Promise(async (D) => {\n        var N;\n        if (!((N = f.sessionConfig) != null && N.disableDeepLink)) {\n          const k = await cy(this.client.core.storage, Ih);\n          await oy({ id: h, topic: s, wcDeepLink: k });\n        }\n        D();\n      }), v()]).then((D) => D[2]);\n    }, this.respond = async (t) => {\n      this.isInitialized(), await this.isValidRespond(t);\n      const { topic: i, response: n } = t, { id: s } = n, o = this.client.session.get(i);\n      o.transportType === at.relay && await this.confirmOnlineStateOrThrow();\n      const f = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);\n      Rr(n) ? await this.sendResult({ id: s, topic: i, result: n.result, throwOnFailedPublish: !0, appLink: f }) : dr(n) && await this.sendError({ id: s, topic: i, error: n.error, appLink: f }), this.cleanupAfterResponse(t);\n    }, this.ping = async (t) => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidPing(t);\n      } catch (n) {\n        throw this.client.logger.error(\"ping() -> isValidPing() failed\"), n;\n      }\n      const { topic: i } = t;\n      if (this.client.session.keys.includes(i)) {\n        const n = oi(), s = zi().toString(), { done: o, resolve: f, reject: h } = Li();\n        this.events.once(Xe(\"session_ping\", n), ({ error: d }) => {\n          d ? h(d) : f();\n        }), await Promise.all([this.sendRequest({ topic: i, method: \"wc_sessionPing\", params: {}, throwOnFailedPublish: !0, clientRpcId: n, relayRpcId: s }), o()]);\n      } else\n        this.client.core.pairing.pairings.keys.includes(i) && await this.client.core.pairing.ping({ topic: i });\n    }, this.emit = async (t) => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(t);\n      const { topic: i, event: n, chainId: s } = t, o = zi().toString(), f = oi();\n      await this.sendRequest({ topic: i, method: \"wc_sessionEvent\", params: { event: n, chainId: s }, throwOnFailedPublish: !0, relayRpcId: o, clientRpcId: f });\n    }, this.disconnect = async (t) => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(t);\n      const { topic: i } = t;\n      if (this.client.session.keys.includes(i))\n        await this.sendRequest({ topic: i, method: \"wc_sessionDelete\", params: st(\"USER_DISCONNECTED\"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: i, emitEvent: !1 });\n      else if (this.client.core.pairing.pairings.keys.includes(i))\n        await this.client.core.pairing.disconnect({ topic: i });\n      else {\n        const { message: n } = ae(\"MISMATCHED_TOPIC\", `Session or pairing topic not found: ${i}`);\n        throw new Error(n);\n      }\n    }, this.find = (t) => (this.isInitialized(), this.client.session.getAll().filter((i) => hm(i, t))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (t, i) => {\n      var n;\n      this.isInitialized(), this.isValidAuthenticate(t);\n      const s = i && this.client.core.linkModeSupportedApps.includes(i) && ((n = this.client.metadata.redirect) == null ? void 0 : n.linkMode), o = s ? at.link_mode : at.relay;\n      o === at.relay && await this.confirmOnlineStateOrThrow();\n      const { chains: f, statement: h = \"\", uri: d, domain: v, nonce: w, type: A, exp: I, nbf: D, methods: N = [], expiry: k } = t, j = [...t.resources || []], { topic: T, uri: K } = await this.client.core.pairing.create({ methods: [\"wc_sessionAuthenticate\"], transportType: o });\n      this.client.logger.info({ message: \"Generated new pairing\", pairing: { topic: T, uri: K } });\n      const $ = await this.client.core.crypto.generateKeyPair(), z = Cs($);\n      if (await Promise.all([this.client.auth.authKeys.set($s, { responseTopic: z, publicKey: $ }), this.client.auth.pairingTopics.set(z, { topic: z, pairingTopic: T })]), await this.client.core.relayer.subscribe(z, { transportType: o }), this.client.logger.info(`sending request to new pairing topic: ${T}`), N.length > 0) {\n        const { namespace: S } = Ns(f[0]);\n        let x = Ry(S, \"request\", N);\n        Ts(j) && (x = Ty(x, j.pop())), j.push(x);\n      }\n      const B = k && k > _t.wc_sessionAuthenticate.req.ttl ? k : _t.wc_sessionAuthenticate.req.ttl, _ = { authPayload: { type: A ?? \"caip122\", chains: f, statement: h, aud: d, domain: v, version: \"1\", nonce: w, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: I, nbf: D, resources: j }, requester: { publicKey: $, metadata: this.client.metadata }, expiryTimestamp: mt(B) }, R = { eip155: { chains: f, methods: [.../* @__PURE__ */ new Set([\"personal_sign\", ...N])], events: [\"chainChanged\", \"accountsChanged\"] } }, J = { requiredNamespaces: {}, optionalNamespaces: R, relays: [{ protocol: \"irn\" }], pairingTopic: T, proposer: { publicKey: $, metadata: this.client.metadata }, expiryTimestamp: mt(_t.wc_sessionPropose.req.ttl) }, { done: Q, resolve: O, reject: p } = Li(B, \"Request expired\"), l = async ({ error: S, session: x }) => {\n        if (this.events.off(Xe(\"session_request\", c), a), S)\n          p(S);\n        else if (x) {\n          x.self.publicKey = $, await this.client.session.set(x.topic, x), await this.setExpiry(x.topic, x.expiry), T && await this.client.core.pairing.updateMetadata({ topic: T, metadata: x.peer.metadata });\n          const u = this.client.session.get(x.topic);\n          await this.deleteProposal(b), O({ session: u });\n        }\n      }, a = async (S) => {\n        var x, u, m;\n        if (await this.deletePendingAuthRequest(c, { message: \"fulfilled\", code: 0 }), S.error) {\n          const q = st(\"WC_METHOD_UNSUPPORTED\", \"wc_sessionAuthenticate\");\n          return S.error.code === q.code ? void 0 : (this.events.off(Xe(\"session_connect\"), l), p(S.error.message));\n        }\n        await this.deleteProposal(b), this.events.off(Xe(\"session_connect\"), l);\n        const { cacaos: g, responder: P } = S.result, G = [], M = [];\n        for (const q of g) {\n          await Rc({ cacao: q, projectId: this.client.core.projectId }) || (this.client.logger.error(q, \"Signature verification failed\"), p(st(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\")));\n          const { p: L } = q, y = Ts(L.resources), F = [Io(L.iss)], W = Js(L.iss);\n          if (y) {\n            const Y = Nc(y), X = Tc(y);\n            G.push(...Y), F.push(...X);\n          }\n          for (const Y of F)\n            M.push(`${Y}:${W}`);\n        }\n        const H = await this.client.core.crypto.generateSharedKey($, P.publicKey);\n        let C;\n        G.length > 0 && (C = { topic: H, acknowledged: !0, self: { publicKey: $, metadata: this.client.metadata }, peer: P, controller: P.publicKey, expiry: mt(sn), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: \"irn\" }, pairingTopic: T, namespaces: kc([...new Set(G)], [...new Set(M)]), transportType: o }, await this.client.core.relayer.subscribe(H, { transportType: o }), await this.client.session.set(H, C), T && await this.client.core.pairing.updateMetadata({ topic: T, metadata: P.metadata }), C = this.client.session.get(H)), (x = this.client.metadata.redirect) != null && x.linkMode && (u = P.metadata.redirect) != null && u.linkMode && (m = P.metadata.redirect) != null && m.universal && i && (this.client.core.addLinkModeSupportedApp(P.metadata.redirect.universal), this.client.session.update(H, { transportType: at.link_mode })), O({ auths: g, session: C });\n      }, c = oi(), b = oi();\n      this.events.once(Xe(\"session_connect\"), l), this.events.once(Xe(\"session_request\", c), a);\n      let E;\n      try {\n        if (s) {\n          const S = Bi(\"wc_sessionAuthenticate\", _, c);\n          this.client.core.history.set(T, S);\n          const x = await this.client.core.crypto.encode(\"\", S, { type: ds, encoding: Ln });\n          E = Es(i, T, x);\n        } else\n          await Promise.all([this.sendRequest({ topic: T, method: \"wc_sessionAuthenticate\", params: _, expiry: t.expiry, throwOnFailedPublish: !0, clientRpcId: c }), this.sendRequest({ topic: T, method: \"wc_sessionPropose\", params: J, expiry: _t.wc_sessionPropose.req.ttl, throwOnFailedPublish: !0, clientRpcId: b })]);\n      } catch (S) {\n        throw this.events.off(Xe(\"session_connect\"), l), this.events.off(Xe(\"session_request\", c), a), S;\n      }\n      return await this.setProposal(b, lt({ id: b }, J)), await this.setAuthRequest(c, { request: Er(lt({}, _), { verifyContext: {} }), pairingTopic: T, transportType: o }), { uri: E ?? K, response: Q };\n    }, this.approveSessionAuthenticate = async (t) => {\n      const { id: i, auths: n } = t, s = this.client.core.eventClient.createEvent({ properties: { topic: i.toString(), trace: [Ci.authenticated_session_approve_started] } });\n      try {\n        this.isInitialized();\n      } catch (k) {\n        throw s.setError(Un.no_internet_connection), k;\n      }\n      const o = this.getPendingAuthRequest(i);\n      if (!o)\n        throw s.setError(Un.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${i}`);\n      const f = o.transportType || at.relay;\n      f === at.relay && await this.confirmOnlineStateOrThrow();\n      const h = o.requester.publicKey, d = await this.client.core.crypto.generateKeyPair(), v = Cs(h), w = { type: hi, receiverPublicKey: h, senderPublicKey: d }, A = [], I = [];\n      for (const k of n) {\n        if (!await Rc({ cacao: k, projectId: this.client.core.projectId })) {\n          s.setError(Un.invalid_cacao);\n          const z = st(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\");\n          throw await this.sendError({ id: i, topic: v, error: z, encodeOpts: w }), new Error(z.message);\n        }\n        s.addTrace(Ci.cacaos_verified);\n        const { p: j } = k, T = Ts(j.resources), K = [Io(j.iss)], $ = Js(j.iss);\n        if (T) {\n          const z = Nc(T), B = Tc(T);\n          A.push(...z), K.push(...B);\n        }\n        for (const z of K)\n          I.push(`${z}:${$}`);\n      }\n      const D = await this.client.core.crypto.generateSharedKey(d, h);\n      s.addTrace(Ci.create_authenticated_session_topic);\n      let N;\n      if (A?.length > 0) {\n        N = { topic: D, acknowledged: !0, self: { publicKey: d, metadata: this.client.metadata }, peer: { publicKey: h, metadata: o.requester.metadata }, controller: h, expiry: mt(sn), authentication: n, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: \"irn\" }, pairingTopic: o.pairingTopic, namespaces: kc([...new Set(A)], [...new Set(I)]), transportType: f }, s.addTrace(Ci.subscribing_authenticated_session_topic);\n        try {\n          await this.client.core.relayer.subscribe(D, { transportType: f });\n        } catch (k) {\n          throw s.setError(Un.subscribe_authenticated_session_topic_failure), k;\n        }\n        s.addTrace(Ci.subscribe_authenticated_session_topic_success), await this.client.session.set(D, N), s.addTrace(Ci.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: o.pairingTopic, metadata: o.requester.metadata });\n      }\n      s.addTrace(Ci.publishing_authenticated_session_approve);\n      try {\n        await this.sendResult({ topic: v, id: i, result: { cacaos: n, responder: { publicKey: d, metadata: this.client.metadata } }, encodeOpts: w, throwOnFailedPublish: !0, appLink: this.getAppLinkIfEnabled(o.requester.metadata, f) });\n      } catch (k) {\n        throw s.setError(Un.authenticated_session_approve_publish_failure), k;\n      }\n      return await this.client.auth.requests.delete(i, { message: \"fulfilled\", code: 0 }), await this.client.core.pairing.activate({ topic: o.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: s.eventId }), { session: N };\n    }, this.rejectSessionAuthenticate = async (t) => {\n      this.isInitialized();\n      const { id: i, reason: n } = t, s = this.getPendingAuthRequest(i);\n      if (!s)\n        throw new Error(`Could not find pending auth request with id ${i}`);\n      s.transportType === at.relay && await this.confirmOnlineStateOrThrow();\n      const o = s.requester.publicKey, f = await this.client.core.crypto.generateKeyPair(), h = Cs(o), d = { type: hi, receiverPublicKey: o, senderPublicKey: f };\n      await this.sendError({ id: i, topic: h, error: n, encodeOpts: d, rpcOpts: _t.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(s.requester.metadata, s.transportType) }), await this.client.auth.requests.delete(i, { message: \"rejected\", code: 0 }), await this.client.proposal.delete(i, st(\"USER_DISCONNECTED\"));\n    }, this.formatAuthMessage = (t) => {\n      this.isInitialized();\n      const { request: i, iss: n } = t;\n      return fd(i, n);\n    }, this.processRelayMessageCache = () => {\n      setTimeout(async () => {\n        if (this.relayMessageCache.length !== 0)\n          for (; this.relayMessageCache.length > 0; )\n            try {\n              const t = this.relayMessageCache.shift();\n              t && await this.onRelayMessage(t);\n            } catch (t) {\n              this.client.logger.error(t);\n            }\n      }, 50);\n    }, this.cleanupDuplicatePairings = async (t) => {\n      if (t.pairingTopic)\n        try {\n          const i = this.client.core.pairing.pairings.get(t.pairingTopic), n = this.client.core.pairing.pairings.getAll().filter((s) => {\n            var o, f;\n            return ((o = s.peerMetadata) == null ? void 0 : o.url) && ((f = s.peerMetadata) == null ? void 0 : f.url) === t.peer.metadata.url && s.topic && s.topic !== i.topic;\n          });\n          if (n.length === 0)\n            return;\n          this.client.logger.info(`Cleaning up ${n.length} duplicate pairing(s)`), await Promise.all(n.map((s) => this.client.core.pairing.disconnect({ topic: s.topic }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n        } catch (i) {\n          this.client.logger.error(i);\n        }\n    }, this.deleteSession = async (t) => {\n      var i;\n      const { topic: n, expirerHasDeleted: s = !1, emitEvent: o = !0, id: f = 0 } = t, { self: h } = this.client.session.get(n);\n      await this.client.core.relayer.unsubscribe(n), await this.client.session.delete(n, st(\"USER_DISCONNECTED\")), this.addToRecentlyDeleted(n, \"session\"), this.client.core.crypto.keychain.has(h.publicKey) && await this.client.core.crypto.deleteKeyPair(h.publicKey), this.client.core.crypto.keychain.has(n) && await this.client.core.crypto.deleteSymKey(n), s || this.client.core.expirer.del(n), this.client.core.storage.removeItem(Ih).catch((d) => this.client.logger.warn(d)), this.getPendingSessionRequests().forEach((d) => {\n        d.topic === n && this.deletePendingSessionRequest(d.id, st(\"USER_DISCONNECTED\"));\n      }), n === ((i = this.sessionRequestQueue.queue[0]) == null ? void 0 : i.topic) && (this.sessionRequestQueue.state = Pr.idle), o && this.client.events.emit(\"session_delete\", { id: f, topic: n });\n    }, this.deleteProposal = async (t, i) => {\n      if (i)\n        try {\n          const n = this.client.proposal.get(t);\n          this.client.core.eventClient.getEvent({ topic: n.pairingTopic })?.setError(Ti.proposal_expired);\n        } catch {\n        }\n      await Promise.all([this.client.proposal.delete(t, st(\"USER_DISCONNECTED\")), i ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, \"proposal\");\n    }, this.deletePendingSessionRequest = async (t, i, n = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(t, i), n ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, \"request\"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((s) => s.id !== t), n && (this.sessionRequestQueue.state = Pr.idle, this.client.events.emit(\"session_request_expire\", { id: t }));\n    }, this.deletePendingAuthRequest = async (t, i, n = !1) => {\n      await Promise.all([this.client.auth.requests.delete(t, i), n ? Promise.resolve() : this.client.core.expirer.del(t)]);\n    }, this.setExpiry = async (t, i) => {\n      this.client.session.keys.includes(t) && (this.client.core.expirer.set(t, i), await this.client.session.update(t, { expiry: i }));\n    }, this.setProposal = async (t, i) => {\n      this.client.core.expirer.set(t, mt(_t.wc_sessionPropose.req.ttl)), await this.client.proposal.set(t, i);\n    }, this.setAuthRequest = async (t, i) => {\n      const { request: n, pairingTopic: s, transportType: o = at.relay } = i;\n      this.client.core.expirer.set(t, n.expiryTimestamp), await this.client.auth.requests.set(t, { authPayload: n.authPayload, requester: n.requester, expiryTimestamp: n.expiryTimestamp, id: t, pairingTopic: s, verifyContext: n.verifyContext, transportType: o });\n    }, this.setPendingSessionRequest = async (t) => {\n      const { id: i, topic: n, params: s, verifyContext: o } = t, f = s.request.expiryTimestamp || mt(_t.wc_sessionRequest.req.ttl);\n      this.client.core.expirer.set(i, f), await this.client.pendingRequest.set(i, { id: i, topic: n, params: s, verifyContext: o });\n    }, this.sendRequest = async (t) => {\n      const { topic: i, method: n, params: s, expiry: o, relayRpcId: f, clientRpcId: h, throwOnFailedPublish: d, appLink: v } = t, w = Bi(n, s, h);\n      let A;\n      const I = !!v;\n      try {\n        const k = I ? Ln : wi;\n        A = await this.client.core.crypto.encode(i, w, { encoding: k });\n      } catch (k) {\n        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${i} failed`), k;\n      }\n      let D;\n      if (t5.includes(n)) {\n        const k = fi(JSON.stringify(w)), j = fi(A);\n        D = await this.client.core.verify.register({ id: j, decryptedId: k });\n      }\n      const N = _t[n].req;\n      if (N.attestation = D, o && (N.ttl = o), f && (N.id = f), this.client.core.history.set(i, w), I) {\n        const k = Es(v, i, A);\n        await global.Linking.openURL(k, this.client.name);\n      } else {\n        const k = _t[n].req;\n        o && (k.ttl = o), f && (k.id = f), d ? (k.internal = Er(lt({}, k.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(i, A, k)) : this.client.core.relayer.publish(i, A, k).catch((j) => this.client.logger.error(j));\n      }\n      return w.id;\n    }, this.sendResult = async (t) => {\n      const { id: i, topic: n, result: s, throwOnFailedPublish: o, encodeOpts: f, appLink: h } = t, d = Ma(i, s);\n      let v;\n      const w = h && typeof (global == null ? void 0 : global.Linking) < \"u\";\n      try {\n        const I = w ? Ln : wi;\n        v = await this.client.core.crypto.encode(n, d, Er(lt({}, f || {}), { encoding: I }));\n      } catch (I) {\n        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${n} failed`), I;\n      }\n      let A;\n      try {\n        A = await this.client.core.history.get(n, i);\n      } catch (I) {\n        throw this.client.logger.error(`sendResult() -> history.get(${n}, ${i}) failed`), I;\n      }\n      if (w) {\n        const I = Es(h, n, v);\n        await global.Linking.openURL(I, this.client.name);\n      } else {\n        const I = _t[A.request.method].res;\n        o ? (I.internal = Er(lt({}, I.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(n, v, I)) : this.client.core.relayer.publish(n, v, I).catch((D) => this.client.logger.error(D));\n      }\n      await this.client.core.history.resolve(d);\n    }, this.sendError = async (t) => {\n      const { id: i, topic: n, error: s, encodeOpts: o, rpcOpts: f, appLink: h } = t, d = Ia(i, s);\n      let v;\n      const w = h && typeof (global == null ? void 0 : global.Linking) < \"u\";\n      try {\n        const I = w ? Ln : wi;\n        v = await this.client.core.crypto.encode(n, d, Er(lt({}, o || {}), { encoding: I }));\n      } catch (I) {\n        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${n} failed`), I;\n      }\n      let A;\n      try {\n        A = await this.client.core.history.get(n, i);\n      } catch (I) {\n        throw this.client.logger.error(`sendError() -> history.get(${n}, ${i}) failed`), I;\n      }\n      if (w) {\n        const I = Es(h, n, v);\n        await global.Linking.openURL(I, this.client.name);\n      } else {\n        const I = f || _t[A.request.method].res;\n        this.client.core.relayer.publish(n, v, I);\n      }\n      await this.client.core.history.resolve(d);\n    }, this.cleanup = async () => {\n      const t = [], i = [];\n      this.client.session.getAll().forEach((n) => {\n        let s = !1;\n        gi(n.expiry) && (s = !0), this.client.core.crypto.keychain.has(n.topic) || (s = !0), s && t.push(n.topic);\n      }), this.client.proposal.getAll().forEach((n) => {\n        gi(n.expiryTimestamp) && i.push(n.id);\n      }), await Promise.all([...t.map((n) => this.deleteSession({ topic: n })), ...i.map((n) => this.deleteProposal(n))]);\n    }, this.onRelayEventRequest = async (t) => {\n      this.requestQueue.queue.push(t), await this.processRequestsQueue();\n    }, this.processRequestsQueue = async () => {\n      if (this.requestQueue.state === Pr.active) {\n        this.client.logger.info(\"Request queue already active, skipping...\");\n        return;\n      }\n      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {\n        this.requestQueue.state = Pr.active;\n        const t = this.requestQueue.queue.shift();\n        if (t)\n          try {\n            await this.processRequest(t);\n          } catch (i) {\n            this.client.logger.warn(i);\n          }\n      }\n      this.requestQueue.state = Pr.idle;\n    }, this.processRequest = async (t) => {\n      const { topic: i, payload: n, attestation: s, transportType: o, encryptedId: f } = t, h = n.method;\n      if (!this.shouldIgnorePairingRequest({ topic: i, requestMethod: h }))\n        switch (h) {\n          case \"wc_sessionPropose\":\n            return await this.onSessionProposeRequest({ topic: i, payload: n, attestation: s, encryptedId: f });\n          case \"wc_sessionSettle\":\n            return await this.onSessionSettleRequest(i, n);\n          case \"wc_sessionUpdate\":\n            return await this.onSessionUpdateRequest(i, n);\n          case \"wc_sessionExtend\":\n            return await this.onSessionExtendRequest(i, n);\n          case \"wc_sessionPing\":\n            return await this.onSessionPingRequest(i, n);\n          case \"wc_sessionDelete\":\n            return await this.onSessionDeleteRequest(i, n);\n          case \"wc_sessionRequest\":\n            return await this.onSessionRequest({ topic: i, payload: n, attestation: s, encryptedId: f, transportType: o });\n          case \"wc_sessionEvent\":\n            return await this.onSessionEventRequest(i, n);\n          case \"wc_sessionAuthenticate\":\n            return await this.onSessionAuthenticateRequest({ topic: i, payload: n, attestation: s, encryptedId: f, transportType: o });\n          default:\n            return this.client.logger.info(`Unsupported request method ${h}`);\n        }\n    }, this.onRelayEventResponse = async (t) => {\n      const { topic: i, payload: n, transportType: s } = t, o = (await this.client.core.history.get(i, n.id)).request.method;\n      switch (o) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(i, n, s);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(i, n);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(i, n);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(i, n);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(i, n);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(i, n);\n        case \"wc_sessionAuthenticate\":\n          return this.onSessionAuthenticateResponse(i, n);\n        default:\n          return this.client.logger.info(`Unsupported response method ${o}`);\n      }\n    }, this.onRelayEventUnknownPayload = (t) => {\n      const { topic: i } = t, { message: n } = ae(\"MISSING_OR_INVALID\", `Decoded payload on topic ${i} is not identifiable as a JSON-RPC request or a response.`);\n      throw new Error(n);\n    }, this.shouldIgnorePairingRequest = (t) => {\n      const { topic: i, requestMethod: n } = t, s = this.expectedPairingMethodMap.get(i);\n      return !s || s.includes(n) ? !1 : !!(s.includes(\"wc_sessionAuthenticate\") && this.client.events.listenerCount(\"session_authenticate\") > 0);\n    }, this.onSessionProposeRequest = async (t) => {\n      const { topic: i, payload: n, attestation: s, encryptedId: o } = t, { params: f, id: h } = n;\n      try {\n        const d = this.client.core.eventClient.getEvent({ topic: i });\n        this.client.events.listenerCount(\"session_proposal\") === 0 && (console.warn(\"No listener for session_proposal event\"), d?.setError(ai.proposal_listener_not_found)), this.isValidConnect(lt({}, n.params));\n        const v = f.expiryTimestamp || mt(_t.wc_sessionPropose.req.ttl), w = lt({ id: h, pairingTopic: i, expiryTimestamp: v }, f);\n        await this.setProposal(h, w);\n        const A = await this.getVerifyContext({ attestationId: s, hash: fi(JSON.stringify(n)), encryptedId: o, metadata: w.proposer.metadata });\n        d?.addTrace(Or.emit_session_proposal), this.client.events.emit(\"session_proposal\", { id: h, params: w, verifyContext: A });\n      } catch (d) {\n        await this.sendError({ id: h, topic: i, error: d, rpcOpts: _t.wc_sessionPropose.autoReject }), this.client.logger.error(d);\n      }\n    }, this.onSessionProposeResponse = async (t, i, n) => {\n      const { id: s } = i;\n      if (Rr(i)) {\n        const { result: o } = i;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result: o });\n        const f = this.client.proposal.get(s);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal: f });\n        const h = f.proposer.publicKey;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", selfPublicKey: h });\n        const d = o.responderPublicKey;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", peerPublicKey: d });\n        const v = await this.client.core.crypto.generateSharedKey(h, d);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", sessionTopic: v });\n        const w = await this.client.core.relayer.subscribe(v, { transportType: n });\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", subscriptionId: w }), await this.client.core.pairing.activate({ topic: t });\n      } else if (dr(i)) {\n        await this.client.proposal.delete(s, st(\"USER_DISCONNECTED\"));\n        const o = Xe(\"session_connect\");\n        if (this.events.listenerCount(o) === 0)\n          throw new Error(`emitting ${o} without any listeners, 954`);\n        this.events.emit(Xe(\"session_connect\"), { error: i.error });\n      }\n    }, this.onSessionSettleRequest = async (t, i) => {\n      const { id: n, params: s } = i;\n      try {\n        this.isValidSessionSettleRequest(s);\n        const { relay: o, controller: f, expiry: h, namespaces: d, sessionProperties: v, sessionConfig: w } = i.params, A = Er(lt(lt({ topic: t, relay: o, expiry: h, namespaces: d, acknowledged: !0, pairingTopic: \"\", requiredNamespaces: {}, optionalNamespaces: {}, controller: f.publicKey, self: { publicKey: \"\", metadata: this.client.metadata }, peer: { publicKey: f.publicKey, metadata: f.metadata } }, v && { sessionProperties: v }), w && { sessionConfig: w }), { transportType: at.relay }), I = Xe(\"session_connect\");\n        if (this.events.listenerCount(I) === 0)\n          throw new Error(`emitting ${I} without any listeners 997`);\n        this.events.emit(Xe(\"session_connect\"), { session: A }), await this.sendResult({ id: i.id, topic: t, result: !0, throwOnFailedPublish: !0 });\n      } catch (o) {\n        await this.sendError({ id: n, topic: t, error: o }), this.client.logger.error(o);\n      }\n    }, this.onSessionSettleResponse = async (t, i) => {\n      const { id: n } = i;\n      Rr(i) ? (await this.client.session.update(t, { acknowledged: !0 }), this.events.emit(Xe(\"session_approve\", n), {})) : dr(i) && (await this.client.session.delete(t, st(\"USER_DISCONNECTED\")), this.events.emit(Xe(\"session_approve\", n), { error: i.error }));\n    }, this.onSessionUpdateRequest = async (t, i) => {\n      const { params: n, id: s } = i;\n      try {\n        const o = `${t}_session_update`, f = Fn.get(o);\n        if (f && this.isRequestOutOfSync(f, s)) {\n          this.client.logger.warn(`Discarding out of sync request - ${s}`), this.sendError({ id: s, topic: t, error: st(\"INVALID_UPDATE_REQUEST\") });\n          return;\n        }\n        this.isValidUpdate(lt({ topic: t }, n));\n        try {\n          Fn.set(o, s), await this.client.session.update(t, { namespaces: n.namespaces }), await this.sendResult({ id: s, topic: t, result: !0, throwOnFailedPublish: !0 });\n        } catch (h) {\n          throw Fn.delete(o), h;\n        }\n        this.client.events.emit(\"session_update\", { id: s, topic: t, params: n });\n      } catch (o) {\n        await this.sendError({ id: s, topic: t, error: o }), this.client.logger.error(o);\n      }\n    }, this.isRequestOutOfSync = (t, i) => i.toString().slice(0, -3) < t.toString().slice(0, -3), this.onSessionUpdateResponse = (t, i) => {\n      const { id: n } = i, s = Xe(\"session_update\", n);\n      if (this.events.listenerCount(s) === 0)\n        throw new Error(`emitting ${s} without any listeners`);\n      Rr(i) ? this.events.emit(Xe(\"session_update\", n), {}) : dr(i) && this.events.emit(Xe(\"session_update\", n), { error: i.error });\n    }, this.onSessionExtendRequest = async (t, i) => {\n      const { id: n } = i;\n      try {\n        this.isValidExtend({ topic: t }), await this.setExpiry(t, mt(sn)), await this.sendResult({ id: n, topic: t, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit(\"session_extend\", { id: n, topic: t });\n      } catch (s) {\n        await this.sendError({ id: n, topic: t, error: s }), this.client.logger.error(s);\n      }\n    }, this.onSessionExtendResponse = (t, i) => {\n      const { id: n } = i, s = Xe(\"session_extend\", n);\n      if (this.events.listenerCount(s) === 0)\n        throw new Error(`emitting ${s} without any listeners`);\n      Rr(i) ? this.events.emit(Xe(\"session_extend\", n), {}) : dr(i) && this.events.emit(Xe(\"session_extend\", n), { error: i.error });\n    }, this.onSessionPingRequest = async (t, i) => {\n      const { id: n } = i;\n      try {\n        this.isValidPing({ topic: t }), await this.sendResult({ id: n, topic: t, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit(\"session_ping\", { id: n, topic: t });\n      } catch (s) {\n        await this.sendError({ id: n, topic: t, error: s }), this.client.logger.error(s);\n      }\n    }, this.onSessionPingResponse = (t, i) => {\n      const { id: n } = i, s = Xe(\"session_ping\", n);\n      if (this.events.listenerCount(s) === 0)\n        throw new Error(`emitting ${s} without any listeners`);\n      setTimeout(() => {\n        Rr(i) ? this.events.emit(Xe(\"session_ping\", n), {}) : dr(i) && this.events.emit(Xe(\"session_ping\", n), { error: i.error });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (t, i) => {\n      const { id: n } = i;\n      try {\n        this.isValidDisconnect({ topic: t, reason: i.params }), Promise.all([new Promise((s) => {\n          this.client.core.relayer.once(Et.publish, async () => {\n            s(await this.deleteSession({ topic: t, id: n }));\n          });\n        }), this.sendResult({ id: n, topic: t, result: !0, throwOnFailedPublish: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: t, error: st(\"USER_DISCONNECTED\") })]).catch((s) => this.client.logger.error(s));\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.onSessionRequest = async (t) => {\n      var i, n, s;\n      const { topic: o, payload: f, attestation: h, encryptedId: d, transportType: v } = t, { id: w, params: A } = f;\n      try {\n        await this.isValidRequest(lt({ topic: o }, A));\n        const I = this.client.session.get(o), D = await this.getVerifyContext({ attestationId: h, hash: fi(JSON.stringify(Bi(\"wc_sessionRequest\", A, w))), encryptedId: d, metadata: I.peer.metadata, transportType: v }), N = { id: w, topic: o, params: A, verifyContext: D };\n        await this.setPendingSessionRequest(N), v === at.link_mode && (i = I.peer.metadata.redirect) != null && i.universal && this.client.core.addLinkModeSupportedApp((n = I.peer.metadata.redirect) == null ? void 0 : n.universal), (s = this.client.signConfig) != null && s.disableRequestQueue ? this.emitSessionRequest(N) : (this.addSessionRequestToSessionRequestQueue(N), this.processSessionRequestQueue());\n      } catch (I) {\n        await this.sendError({ id: w, topic: o, error: I }), this.client.logger.error(I);\n      }\n    }, this.onSessionRequestResponse = (t, i) => {\n      const { id: n } = i, s = Xe(\"session_request\", n);\n      if (this.events.listenerCount(s) === 0)\n        throw new Error(`emitting ${s} without any listeners`);\n      Rr(i) ? this.events.emit(Xe(\"session_request\", n), { result: i.result }) : dr(i) && this.events.emit(Xe(\"session_request\", n), { error: i.error });\n    }, this.onSessionEventRequest = async (t, i) => {\n      const { id: n, params: s } = i;\n      try {\n        const o = `${t}_session_event_${s.event.name}`, f = Fn.get(o);\n        if (f && this.isRequestOutOfSync(f, n)) {\n          this.client.logger.info(`Discarding out of sync request - ${n}`);\n          return;\n        }\n        this.isValidEmit(lt({ topic: t }, s)), this.client.events.emit(\"session_event\", { id: n, topic: t, params: s }), Fn.set(o, n);\n      } catch (o) {\n        await this.sendError({ id: n, topic: t, error: o }), this.client.logger.error(o);\n      }\n    }, this.onSessionAuthenticateResponse = (t, i) => {\n      const { id: n } = i;\n      this.client.logger.trace({ type: \"method\", method: \"onSessionAuthenticateResponse\", topic: t, payload: i }), Rr(i) ? this.events.emit(Xe(\"session_request\", n), { result: i.result }) : dr(i) && this.events.emit(Xe(\"session_request\", n), { error: i.error });\n    }, this.onSessionAuthenticateRequest = async (t) => {\n      var i;\n      const { topic: n, payload: s, attestation: o, encryptedId: f, transportType: h } = t;\n      try {\n        const { requester: d, authPayload: v, expiryTimestamp: w } = s.params, A = await this.getVerifyContext({ attestationId: o, hash: fi(JSON.stringify(s)), encryptedId: f, metadata: d.metadata, transportType: h }), I = { requester: d, pairingTopic: n, id: s.id, authPayload: v, verifyContext: A, expiryTimestamp: w };\n        await this.setAuthRequest(s.id, { request: I, pairingTopic: n, transportType: h }), h === at.link_mode && (i = d.metadata.redirect) != null && i.universal && this.client.core.addLinkModeSupportedApp(d.metadata.redirect.universal), this.client.events.emit(\"session_authenticate\", { topic: n, params: s.params, id: s.id, verifyContext: A });\n      } catch (d) {\n        this.client.logger.error(d);\n        const v = s.params.requester.publicKey, w = await this.client.core.crypto.generateKeyPair(), A = this.getAppLinkIfEnabled(s.params.requester.metadata, h), I = { type: hi, receiverPublicKey: v, senderPublicKey: w };\n        await this.sendError({ id: s.id, topic: n, error: d, encodeOpts: I, rpcOpts: _t.wc_sessionAuthenticate.autoReject, appLink: A });\n      }\n    }, this.addSessionRequestToSessionRequestQueue = (t) => {\n      this.sessionRequestQueue.queue.push(t);\n    }, this.cleanupAfterResponse = (t) => {\n      this.deletePendingSessionRequest(t.response.id, { message: \"fulfilled\", code: 0 }), setTimeout(() => {\n        this.sessionRequestQueue.state = Pr.idle, this.processSessionRequestQueue();\n      }, ie.toMiliseconds(this.requestQueueDelay));\n    }, this.cleanupPendingSentRequestsForTopic = ({ topic: t, error: i }) => {\n      const n = this.client.core.history.pending;\n      n.length > 0 && n.filter((s) => s.topic === t && s.request.method === \"wc_sessionRequest\").forEach((s) => {\n        const o = s.request.id, f = Xe(\"session_request\", o);\n        if (this.events.listenerCount(f) === 0)\n          throw new Error(`emitting ${f} without any listeners`);\n        this.events.emit(Xe(\"session_request\", s.request.id), { error: i });\n      });\n    }, this.processSessionRequestQueue = () => {\n      if (this.sessionRequestQueue.state === Pr.active) {\n        this.client.logger.info(\"session request queue is already active.\");\n        return;\n      }\n      const t = this.sessionRequestQueue.queue[0];\n      if (!t) {\n        this.client.logger.info(\"session request queue is empty.\");\n        return;\n      }\n      try {\n        this.sessionRequestQueue.state = Pr.active, this.emitSessionRequest(t);\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n    }, this.emitSessionRequest = (t) => {\n      this.client.events.emit(\"session_request\", t);\n    }, this.onPairingCreated = (t) => {\n      if (t.methods && this.expectedPairingMethodMap.set(t.topic, t.methods), t.active)\n        return;\n      const i = this.client.proposal.getAll().find((n) => n.pairingTopic === t.topic);\n      i && this.onSessionProposeRequest({ topic: t.topic, payload: Bi(\"wc_sessionPropose\", { requiredNamespaces: i.requiredNamespaces, optionalNamespaces: i.optionalNamespaces, relays: i.relays, proposer: i.proposer, sessionProperties: i.sessionProperties }, i.id) });\n    }, this.isValidConnect = async (t) => {\n      if (!Gt(t)) {\n        const { message: h } = ae(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(t)}`);\n        throw new Error(h);\n      }\n      const { pairingTopic: i, requiredNamespaces: n, optionalNamespaces: s, sessionProperties: o, relays: f } = t;\n      if (zt(i) || await this.isValidPairingTopic(i), !xm(f, !0)) {\n        const { message: h } = ae(\"MISSING_OR_INVALID\", `connect() relays: ${f}`);\n        throw new Error(h);\n      }\n      !zt(n) && Xs(n) !== 0 && this.validateNamespaces(n, \"requiredNamespaces\"), !zt(s) && Xs(s) !== 0 && this.validateNamespaces(s, \"optionalNamespaces\"), zt(o) || this.validateSessionProps(o, \"sessionProperties\");\n    }, this.validateNamespaces = (t, i) => {\n      const n = _m(t, \"connect()\", i);\n      if (n)\n        throw new Error(n.message);\n    }, this.isValidApprove = async (t) => {\n      if (!Gt(t))\n        throw new Error(ae(\"MISSING_OR_INVALID\", `approve() params: ${t}`).message);\n      const { id: i, namespaces: n, relayProtocol: s, sessionProperties: o } = t;\n      this.checkRecentlyDeleted(i), await this.isValidProposalId(i);\n      const f = this.client.proposal.get(i), h = eo(n, \"approve()\");\n      if (h)\n        throw new Error(h.message);\n      const d = Hc(f.requiredNamespaces, n, \"approve()\");\n      if (d)\n        throw new Error(d.message);\n      if (!bt(s, !0)) {\n        const { message: v } = ae(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${s}`);\n        throw new Error(v);\n      }\n      zt(o) || this.validateSessionProps(o, \"sessionProperties\");\n    }, this.isValidReject = async (t) => {\n      if (!Gt(t)) {\n        const { message: s } = ae(\"MISSING_OR_INVALID\", `reject() params: ${t}`);\n        throw new Error(s);\n      }\n      const { id: i, reason: n } = t;\n      if (this.checkRecentlyDeleted(i), await this.isValidProposalId(i), !Sm(n)) {\n        const { message: s } = ae(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(n)}`);\n        throw new Error(s);\n      }\n    }, this.isValidSessionSettleRequest = (t) => {\n      if (!Gt(t)) {\n        const { message: d } = ae(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${t}`);\n        throw new Error(d);\n      }\n      const { relay: i, controller: n, namespaces: s, expiry: o } = t;\n      if (!bd(i)) {\n        const { message: d } = ae(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(d);\n      }\n      const f = vm(n, \"onSessionSettleRequest()\");\n      if (f)\n        throw new Error(f.message);\n      const h = eo(s, \"onSessionSettleRequest()\");\n      if (h)\n        throw new Error(h.message);\n      if (gi(o)) {\n        const { message: d } = ae(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(d);\n      }\n    }, this.isValidUpdate = async (t) => {\n      if (!Gt(t)) {\n        const { message: h } = ae(\"MISSING_OR_INVALID\", `update() params: ${t}`);\n        throw new Error(h);\n      }\n      const { topic: i, namespaces: n } = t;\n      this.checkRecentlyDeleted(i), await this.isValidSessionTopic(i);\n      const s = this.client.session.get(i), o = eo(n, \"update()\");\n      if (o)\n        throw new Error(o.message);\n      const f = Hc(s.requiredNamespaces, n, \"update()\");\n      if (f)\n        throw new Error(f.message);\n    }, this.isValidExtend = async (t) => {\n      if (!Gt(t)) {\n        const { message: n } = ae(\"MISSING_OR_INVALID\", `extend() params: ${t}`);\n        throw new Error(n);\n      }\n      const { topic: i } = t;\n      this.checkRecentlyDeleted(i), await this.isValidSessionTopic(i);\n    }, this.isValidRequest = async (t) => {\n      if (!Gt(t)) {\n        const { message: h } = ae(\"MISSING_OR_INVALID\", `request() params: ${t}`);\n        throw new Error(h);\n      }\n      const { topic: i, request: n, chainId: s, expiry: o } = t;\n      this.checkRecentlyDeleted(i), await this.isValidSessionTopic(i);\n      const { namespaces: f } = this.client.session.get(i);\n      if (!Kc(f, s)) {\n        const { message: h } = ae(\"MISSING_OR_INVALID\", `request() chainId: ${s}`);\n        throw new Error(h);\n      }\n      if (!Mm(n)) {\n        const { message: h } = ae(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(n)}`);\n        throw new Error(h);\n      }\n      if (!Dm(f, s, n.method)) {\n        const { message: h } = ae(\"MISSING_OR_INVALID\", `request() method: ${n.method}`);\n        throw new Error(h);\n      }\n      if (o && !Nm(o, so)) {\n        const { message: h } = ae(\"MISSING_OR_INVALID\", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${so.min} and ${so.max}`);\n        throw new Error(h);\n      }\n    }, this.isValidRespond = async (t) => {\n      var i;\n      if (!Gt(t)) {\n        const { message: o } = ae(\"MISSING_OR_INVALID\", `respond() params: ${t}`);\n        throw new Error(o);\n      }\n      const { topic: n, response: s } = t;\n      try {\n        await this.isValidSessionTopic(n);\n      } catch (o) {\n        throw (i = t?.response) != null && i.id && this.cleanupAfterResponse(t), o;\n      }\n      if (!Im(s)) {\n        const { message: o } = ae(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(s)}`);\n        throw new Error(o);\n      }\n    }, this.isValidPing = async (t) => {\n      if (!Gt(t)) {\n        const { message: n } = ae(\"MISSING_OR_INVALID\", `ping() params: ${t}`);\n        throw new Error(n);\n      }\n      const { topic: i } = t;\n      await this.isValidSessionOrPairingTopic(i);\n    }, this.isValidEmit = async (t) => {\n      if (!Gt(t)) {\n        const { message: f } = ae(\"MISSING_OR_INVALID\", `emit() params: ${t}`);\n        throw new Error(f);\n      }\n      const { topic: i, event: n, chainId: s } = t;\n      await this.isValidSessionTopic(i);\n      const { namespaces: o } = this.client.session.get(i);\n      if (!Kc(o, s)) {\n        const { message: f } = ae(\"MISSING_OR_INVALID\", `emit() chainId: ${s}`);\n        throw new Error(f);\n      }\n      if (!Am(n)) {\n        const { message: f } = ae(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(n)}`);\n        throw new Error(f);\n      }\n      if (!Pm(o, s, n.name)) {\n        const { message: f } = ae(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(n)}`);\n        throw new Error(f);\n      }\n    }, this.isValidDisconnect = async (t) => {\n      if (!Gt(t)) {\n        const { message: n } = ae(\"MISSING_OR_INVALID\", `disconnect() params: ${t}`);\n        throw new Error(n);\n      }\n      const { topic: i } = t;\n      await this.isValidSessionOrPairingTopic(i);\n    }, this.isValidAuthenticate = (t) => {\n      const { chains: i, uri: n, domain: s, nonce: o } = t;\n      if (!Array.isArray(i) || i.length === 0)\n        throw new Error(\"chains is required and must be a non-empty array\");\n      if (!bt(n, !1))\n        throw new Error(\"uri is required parameter\");\n      if (!bt(s, !1))\n        throw new Error(\"domain is required parameter\");\n      if (!bt(o, !1))\n        throw new Error(\"nonce is required parameter\");\n      if ([...new Set(i.map((h) => Ns(h).namespace))].length > 1)\n        throw new Error(\"Multi-namespace requests are not supported. Please request single namespace only.\");\n      const { namespace: f } = Ns(i[0]);\n      if (f !== \"eip155\")\n        throw new Error(\"Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.\");\n    }, this.getVerifyContext = async (t) => {\n      const { attestationId: i, hash: n, encryptedId: s, metadata: o, transportType: f } = t, h = { verified: { verifyUrl: o.verifyUrl || Vn, validation: \"UNKNOWN\", origin: o.url || \"\" } };\n      try {\n        if (f === at.link_mode) {\n          const v = this.getAppLinkIfEnabled(o, f);\n          return h.verified.validation = v && new URL(v).origin === new URL(o.url).origin ? \"VALID\" : \"INVALID\", h;\n        }\n        const d = await this.client.core.verify.resolve({ attestationId: i, hash: n, encryptedId: s, verifyUrl: o.verifyUrl });\n        d && (h.verified.origin = d.origin, h.verified.isScam = d.isScam, h.verified.validation = d.origin === new URL(o.url).origin ? \"VALID\" : \"INVALID\");\n      } catch (d) {\n        this.client.logger.warn(d);\n      }\n      return this.client.logger.debug(`Verify context: ${JSON.stringify(h)}`), h;\n    }, this.validateSessionProps = (t, i) => {\n      Object.values(t).forEach((n) => {\n        if (!bt(n, !1)) {\n          const { message: s } = ae(\"MISSING_OR_INVALID\", `${i} must be in Record<string, string> format. Received: ${JSON.stringify(n)}`);\n          throw new Error(s);\n        }\n      });\n    }, this.getPendingAuthRequest = (t) => {\n      const i = this.client.auth.requests.get(t);\n      return typeof i == \"object\" ? i : void 0;\n    }, this.addToRecentlyDeleted = (t, i) => {\n      if (this.recentlyDeletedMap.set(t, i), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {\n        let n = 0;\n        const s = this.recentlyDeletedLimit / 2;\n        for (const o of this.recentlyDeletedMap.keys()) {\n          if (n++ >= s)\n            break;\n          this.recentlyDeletedMap.delete(o);\n        }\n      }\n    }, this.checkRecentlyDeleted = (t) => {\n      const i = this.recentlyDeletedMap.get(t);\n      if (i) {\n        const { message: n } = ae(\"MISSING_OR_INVALID\", `Record was recently deleted - ${i}: ${t}`);\n        throw new Error(n);\n      }\n    }, this.isLinkModeEnabled = (t, i) => {\n      var n, s, o, f, h, d, v, w, A;\n      return !t || i !== at.link_mode ? !1 : ((s = (n = this.client.metadata) == null ? void 0 : n.redirect) == null ? void 0 : s.linkMode) === !0 && ((f = (o = this.client.metadata) == null ? void 0 : o.redirect) == null ? void 0 : f.universal) !== void 0 && ((d = (h = this.client.metadata) == null ? void 0 : h.redirect) == null ? void 0 : d.universal) !== \"\" && ((v = t?.redirect) == null ? void 0 : v.universal) !== void 0 && ((w = t?.redirect) == null ? void 0 : w.universal) !== \"\" && ((A = t?.redirect) == null ? void 0 : A.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(t.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < \"u\";\n    }, this.getAppLinkIfEnabled = (t, i) => {\n      var n;\n      return this.isLinkModeEnabled(t, i) ? (n = t?.redirect) == null ? void 0 : n.universal : void 0;\n    }, this.handleLinkModeMessage = ({ url: t }) => {\n      if (!t || !t.includes(\"wc_ev\") || !t.includes(\"topic\"))\n        return;\n      const i = Ac(t, \"topic\") || \"\", n = decodeURIComponent(Ac(t, \"wc_ev\") || \"\"), s = this.client.session.keys.includes(i);\n      s && this.client.session.update(i, { transportType: at.link_mode }), this.client.core.dispatchEnvelope({ topic: i, message: n, sessionExists: s });\n    }, this.registerLinkModeListeners = async () => {\n      var t;\n      if (rf() || Ai() && (t = this.client.metadata.redirect) != null && t.linkMode) {\n        const i = global == null ? void 0 : global.Linking;\n        if (typeof i < \"u\") {\n          i.addEventListener(\"url\", this.handleLinkModeMessage, this.client.name);\n          const n = await i.getInitialURL();\n          n && setTimeout(() => {\n            this.handleLinkModeMessage({ url: n });\n          }, 50);\n        }\n      }\n    };\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = ae(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async confirmOnlineStateOrThrow() {\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(Et.message, (e) => {\n      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : this.onRelayMessage(e);\n    });\n  }\n  async onRelayMessage(e) {\n    const { topic: t, message: i, attestation: n, transportType: s } = e, { publicKey: o } = this.client.auth.authKeys.keys.includes($s) ? this.client.auth.authKeys.get($s) : { responseTopic: void 0, publicKey: void 0 }, f = await this.client.core.crypto.decode(t, i, { receiverPublicKey: o, encoding: s === at.link_mode ? Ln : wi });\n    try {\n      ff(f) ? (this.client.core.history.set(t, f), this.onRelayEventRequest({ topic: t, payload: f, attestation: n, transportType: s, encryptedId: fi(i) })) : Aa(f) ? (await this.client.core.history.resolve(f), await this.onRelayEventResponse({ topic: t, payload: f, transportType: s }), this.client.core.history.delete(t, f.id)) : this.onRelayEventUnknownPayload({ topic: t, payload: f, transportType: s });\n    } catch (h) {\n      this.client.logger.error(h);\n    }\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(ur.expired, async (e) => {\n      const { topic: t, id: i } = ad(e.target);\n      if (i && this.client.pendingRequest.keys.includes(i))\n        return await this.deletePendingSessionRequest(i, ae(\"EXPIRED\"), !0);\n      if (i && this.client.auth.requests.keys.includes(i))\n        return await this.deletePendingAuthRequest(i, ae(\"EXPIRED\"), !0);\n      t ? this.client.session.keys.includes(t) && (await this.deleteSession({ topic: t, expirerHasDeleted: !0 }), this.client.events.emit(\"session_expire\", { topic: t })) : i && (await this.deleteProposal(i, !0), this.client.events.emit(\"proposal_expire\", { id: i }));\n    });\n  }\n  registerPairingEvents() {\n    this.client.core.pairing.events.on(qi.create, (e) => this.onPairingCreated(e)), this.client.core.pairing.events.on(qi.delete, (e) => {\n      this.addToRecentlyDeleted(e.topic, \"pairing\");\n    });\n  }\n  isValidPairingTopic(e) {\n    if (!bt(e, !1)) {\n      const { message: t } = ae(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(e)) {\n      const { message: t } = ae(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (gi(this.client.core.pairing.pairings.get(e).expiry)) {\n      const { message: t } = ae(\"EXPIRED\", `pairing topic: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidSessionTopic(e) {\n    if (!bt(e, !1)) {\n      const { message: t } = ae(\"MISSING_OR_INVALID\", `session topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n    if (this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e)) {\n      const { message: t } = ae(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (gi(this.client.session.get(e).expiry)) {\n      await this.deleteSession({ topic: e });\n      const { message: t } = ae(\"EXPIRED\", `session topic: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.core.crypto.keychain.has(e)) {\n      const { message: t } = ae(\"MISSING_OR_INVALID\", `session topic does not exist in keychain: ${e}`);\n      throw await this.deleteSession({ topic: e }), new Error(t);\n    }\n  }\n  async isValidSessionOrPairingTopic(e) {\n    if (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e))\n      await this.isValidSessionTopic(e);\n    else if (this.client.core.pairing.pairings.keys.includes(e))\n      this.isValidPairingTopic(e);\n    else if (bt(e, !1)) {\n      const { message: t } = ae(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${e}`);\n      throw new Error(t);\n    } else {\n      const { message: t } = ae(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidProposalId(e) {\n    if (!Em(e)) {\n      const { message: t } = ae(\"MISSING_OR_INVALID\", `proposal id should be a number: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.proposal.keys.includes(e)) {\n      const { message: t } = ae(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (gi(this.client.proposal.get(e).expiryTimestamp)) {\n      await this.deleteProposal(e);\n      const { message: t } = ae(\"EXPIRED\", `proposal id: ${e}`);\n      throw new Error(t);\n    }\n  }\n}\nclass l5 extends Qi {\n  constructor(e, t) {\n    super(e, t, Yw, cf), this.core = e, this.logger = t;\n  }\n}\nclass p5 extends Qi {\n  constructor(e, t) {\n    super(e, t, Zw, cf), this.core = e, this.logger = t;\n  }\n}\nclass v5 extends Qi {\n  constructor(e, t) {\n    super(e, t, e5, cf, (i) => i.id), this.core = e, this.logger = t;\n  }\n}\nclass b5 extends Qi {\n  constructor(e, t) {\n    super(e, t, n5, Pa, () => $s), this.core = e, this.logger = t;\n  }\n}\nclass g5 extends Qi {\n  constructor(e, t) {\n    super(e, t, s5, Pa), this.core = e, this.logger = t;\n  }\n}\nclass y5 extends Qi {\n  constructor(e, t) {\n    super(e, t, a5, Pa, (i) => i.id), this.core = e, this.logger = t;\n  }\n}\nclass m5 {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.authKeys = new b5(this.core, this.logger), this.pairingTopics = new g5(this.core, this.logger), this.requests = new y5(this.core, this.logger);\n  }\n  async init() {\n    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();\n  }\n}\nclass Oa extends pp {\n  constructor(e) {\n    super(e), this.protocol = Ud, this.version = zd, this.name = no.name, this.events = new ir.EventEmitter(), this.on = (i, n) => this.events.on(i, n), this.once = (i, n) => this.events.once(i, n), this.off = (i, n) => this.events.off(i, n), this.removeListener = (i, n) => this.events.removeListener(i, n), this.removeAllListeners = (i) => this.events.removeAllListeners(i), this.connect = async (i) => {\n      try {\n        return await this.engine.connect(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.pair = async (i) => {\n      try {\n        return await this.engine.pair(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.approve = async (i) => {\n      try {\n        return await this.engine.approve(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.reject = async (i) => {\n      try {\n        return await this.engine.reject(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.update = async (i) => {\n      try {\n        return await this.engine.update(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.extend = async (i) => {\n      try {\n        return await this.engine.extend(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.request = async (i) => {\n      try {\n        return await this.engine.request(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.respond = async (i) => {\n      try {\n        return await this.engine.respond(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.ping = async (i) => {\n      try {\n        return await this.engine.ping(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.emit = async (i) => {\n      try {\n        return await this.engine.emit(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.disconnect = async (i) => {\n      try {\n        return await this.engine.disconnect(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.find = (i) => {\n      try {\n        return this.engine.find(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (i) {\n        throw this.logger.error(i.message), i;\n      }\n    }, this.authenticate = async (i, n) => {\n      try {\n        return await this.engine.authenticate(i, n);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.formatAuthMessage = (i) => {\n      try {\n        return this.engine.formatAuthMessage(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.approveSessionAuthenticate = async (i) => {\n      try {\n        return await this.engine.approveSessionAuthenticate(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.rejectSessionAuthenticate = async (i) => {\n      try {\n        return await this.engine.rejectSessionAuthenticate(i);\n      } catch (n) {\n        throw this.logger.error(n.message), n;\n      }\n    }, this.name = e?.name || no.name, this.metadata = e?.metadata || td(), this.signConfig = e?.signConfig;\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : na(To({ level: e?.logger || no.logger }));\n    this.core = e?.core || new Jw(e), this.logger = kt(t, this.name), this.session = new p5(this.core, this.logger), this.proposal = new l5(this.core, this.logger), this.pendingRequest = new v5(this.core, this.logger), this.engine = new d5(this), this.auth = new m5(this.core, this.logger);\n  }\n  static async init(e) {\n    const t = new Oa(e);\n    return await t.initialize(), t;\n  }\n  get context() {\n    return Zt(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info(\"SignClient Initialization Success\"), setTimeout(() => {\n        this.engine.processRelayMessageCache();\n      }, ie.toMiliseconds(ie.ONE_SECOND));\n    } catch (e) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(e.message), e;\n    }\n  }\n}\nconst w5 = () => {\n  const e = cu()?.os?.toLowerCase();\n  return e?.includes(\"android\") ? \"android\" : e?.toLowerCase().includes(\"ios\") || e?.toLowerCase().includes(\"mac\") && navigator.maxTouchPoints > 1 ? \"ios\" : \"desktop\";\n}, Ss = w5(), _5 = {\n  position: \"fixed\",\n  top: \"0\",\n  left: \"0\",\n  right: \"0\",\n  bottom: \"0\",\n  backgroundColor: \"rgba(0,0,0,0.8)\",\n  backdropFilter: \"blur(10px)\",\n  zIndex: \"9999\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  flexDirection: \"column\",\n  color: \"white\",\n  fontWeight: \"500\",\n  fontFamily: \"'Barlow', sans-serif\"\n}, x5 = {\n  width: \"840px\",\n  height: \"540px\",\n  zIndex: \"99999\",\n  backgroundColor: \"white\",\n  border: \"none\",\n  outline: \"none\",\n  borderRadius: \"40px\",\n  boxShadow: \"0px 4px 40px 0px rgb(0 0 0), 0px 4px 8px 0px rgb(0 0 0 / 25%)\",\n  position: \"fixed\",\n  top: \"50%\",\n  left: \"50%\",\n  transform: \"translate(-50%,-50%)\"\n}, E5 = `\n  <div id=\"argent-mobile-modal-container\" style=\"position: relative\">\n    <iframe class=\"argent-iframe\" allow=\"clipboard-write\"></iframe>\n    <div class=\"argent-close-button\" style=\"position: absolute; top: 24px; right: 24px; cursor: pointer;\">\n      <svg width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <circle cx=\"16\" cy=\"16\" r=\"16\" fill=\"#F5F3F0\"/>\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M22.2462 9.75382C22.7018 10.2094 22.7018 10.9481 22.2462 11.4037L17.6499 16L22.2462 20.5963C22.7018 21.0519 22.7018 21.7906 22.2462 22.2462C21.7905 22.7018 21.0519 22.7018 20.5962 22.2462L16 17.6499L11.4039 22.246C10.9482 22.7017 10.2096 22.7017 9.75394 22.246C9.29833 21.7904 9.29833 21.0517 9.75394 20.5961L14.3501 16L9.75394 11.4039C9.29833 10.9483 9.29833 10.2096 9.75394 9.75396C10.2096 9.29835 10.9482 9.29835 11.4039 9.75396L16 14.3501L20.5962 9.75382C21.0519 9.29821 21.7905 9.29821 22.2462 9.75382Z\" fill=\"#333332\"/>\n      </svg>\n    </div>\n  </div>\n`;\nclass S5 {\n  constructor() {\n    He(this, \"bridgeUrl\", \"https://login.argent.xyz\");\n    He(this, \"mobileUrl\", \"argent://\");\n    He(this, \"type\", \"overlay\");\n    He(this, \"wcUri\");\n    He(this, \"overlay\");\n    He(this, \"popupWindow\");\n    He(this, \"closingTimeout\");\n    He(this, \"close\", () => {\n      this.overlay?.remove(), this.popupWindow?.close(), this.overlay = void 0, this.popupWindow = void 0;\n    });\n  }\n  showConnectionModal(e) {\n    const t = encodeURIComponent(e), i = encodeURIComponent(window.location.href);\n    this.showModal({\n      desktop: `${this.bridgeUrl}?wc=${t}&href=${i}&device=desktop`,\n      ios: `${this.mobileUrl}app/wc?uri=${t}&href=${i}&device=mobile`,\n      android: `${this.mobileUrl}app/wc?uri=${t}&href=${i}&device=mobile`\n    });\n  }\n  showApprovalModal(e) {\n    if (Ss === \"desktop\") {\n      this.showModal({\n        desktop: `${this.bridgeUrl}?action=sign`,\n        ios: \"\",\n        android: \"\"\n      });\n      return;\n    }\n    const t = encodeURIComponent(window.location.href);\n    this.showModal({\n      desktop: `${this.bridgeUrl}?action=sign&device=desktop&href=${t}`,\n      ios: `${this.mobileUrl}app/wc/request?href=${t}&device=mobile`,\n      android: `${this.mobileUrl}app/wc/request?href=${t}&device=mobile`\n    });\n  }\n  closeModal(e) {\n    e ? (this.overlay?.querySelector(\"iframe\")?.contentWindow?.postMessage(\"argent-login.success\", \"*\"), this.popupWindow?.postMessage(\"argent-login.success\", \"*\"), this.closingTimeout = setTimeout(this.close, 3400)) : this.close();\n  }\n  showModal(e) {\n    if (clearTimeout(this.closingTimeout), (this.overlay || this.popupWindow) && this.close(), Ss === \"android\" || Ss === \"ios\") {\n      const s = document.createElement(\"button\");\n      s.style.display = \"none\", s.addEventListener(\"click\", () => {\n        window.location.href = e[Ss];\n      }), s.click();\n      return;\n    }\n    if (this.type === \"window\") {\n      const s = \"menubar=no,location=no,resizable=no,scrollbars=no,status=no,width=840,height=540\";\n      this.popupWindow = window.open(e.desktop, \"_blank\", s) || void 0;\n      return;\n    }\n    const t = document.createElement(\"div\");\n    t.innerHTML = E5, t.id = \"argent-mobile-modal-overlay\";\n    for (const [s, o] of Object.entries(_5))\n      t.style[s] = o;\n    document.body.appendChild(t), t.addEventListener(\"click\", () => this.closeModal()), this.overlay = t;\n    const i = t.querySelector(\"iframe\");\n    i.setAttribute(\"src\", e.desktop);\n    for (const [s, o] of Object.entries(x5))\n      i.style[s] = o;\n    t.querySelector(\n      \".argent-close-button\"\n    ).addEventListener(\"click\", () => this.closeModal());\n  }\n}\nconst Nr = new S5(), ta = starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName, M5 = async ({\n  projectId: r,\n  chainId: e,\n  name: t,\n  description: i,\n  rpcUrl: n,\n  bridgeUrl: s = I5(e),\n  mobileUrl: o = A5(e),\n  modalType: f = \"overlay\",\n  url: h,\n  icons: d,\n  walletConnect: v\n}, w) => {\n  if (!s)\n    throw new Error(\"bridgeUrl is required\");\n  if (!o)\n    throw new Error(\"mobileUrl is required\");\n  Nr.bridgeUrl = s, Nr.mobileUrl = o, Nr.type = f;\n  const A = {\n    projectId: r,\n    metadata: {\n      name: t ?? \"Unknown dapp\",\n      description: i ?? \"Unknown dapp description\",\n      url: h ?? \"#\",\n      icons: d ?? [],\n      ...v?.metadata\n    }\n  }, I = await Oa.init(A), D = new starknet__WEBPACK_IMPORTED_MODULE_1__.RpcProvider({ nodeUrl: n }), N = new w({ client: I, chainId: e, rpcUrl: n, provider: D });\n  I.on(\"session_event\", (k) => {\n  }), I.on(\"session_update\", ({ topic: k, params: j }) => {\n    const { namespaces: T } = j, K = I.session.get(k);\n    N.updateSession({ ...K, namespaces: T });\n  }), I.on(\"session_delete\", () => {\n  });\n  try {\n    const k = I.session.getAll().find(N.isValidSession);\n    if (k)\n      return N.updateSession(k), N;\n    const j = { requiredNamespaces: N.getRequiredNamespaces() };\n    (0,_index_d4f30f2e_js__WEBPACK_IMPORTED_MODULE_2__.r)(), await new Promise(($) => setTimeout($, 200));\n    const { uri: T, approval: K } = await I.connect(j);\n    if (T) {\n      Nr.showConnectionModal(T), Nr.wcUri = T;\n      const $ = await K();\n      N.updateSession($), Nr.closeModal(\"animateSuccess\");\n    }\n    return N;\n  } catch {\n    return console.error(\"@argent/login::error\"), Nr.closeModal(), null;\n  }\n}, I5 = (r) => {\n  if (!r)\n    throw new Error(\n      `Unknown or unsupported chainId (${r}), either specify a supported chain or set bridgeUrl.`\n    );\n  const e = parseInt(`${r}`);\n  if (String(r).startsWith(ta.SN_SEPOLIA) || e === 11155111)\n    return \"https://mobile-login.hydrogen.argent47.net\";\n  if (String(r).startsWith(ta.SN_MAIN) || e === 1)\n    return \"https://login.argent.xyz\";\n}, A5 = (r) => {\n  if (!r)\n    throw new Error(\n      `Unknown or unsupported chainId (${r}), either specify a supported chain or set mobileUrl.`\n    );\n  const e = parseInt(`${r}`);\n  if (String(r).startsWith(ta.SN_SEPOLIA) || e === 11155111)\n    return \"argent-dev://\";\n  if (String(r).startsWith(ta.SN_MAIN) || e === 1)\n    return \"argent://\";\n};\nfunction D5(r) {\n  return typeof r < \"u\" && typeof r.context < \"u\";\n}\nconst Tr = { init: \"signer_init\", uri: \"signer_uri\", created: \"signer_created\", updated: \"signer_updated\", deleted: \"signer_deleted\", event: \"signer_event\" };\nclass P5 extends Ym {\n  constructor(e) {\n    super(), this.events = new ir.EventEmitter(), this.pending = !1, this.initializing = !1, this.requiredNamespaces = e?.requiredNamespaces || {}, this.opts = e?.client;\n  }\n  get connected() {\n    return typeof this.session < \"u\";\n  }\n  get connecting() {\n    return this.pending;\n  }\n  get chains() {\n    return this.session ? ed(this.session.namespaces) : V2(this.requiredNamespaces);\n  }\n  get accounts() {\n    return this.session ? Qu(this.session.namespaces) : [];\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async open() {\n    if (this.pending)\n      return new Promise((e, t) => {\n        this.events.once(\"open\", () => {\n          if (this.events.once(\"open_error\", (i) => {\n            t(i);\n          }), typeof this.client > \"u\")\n            return t(new Error(\"Sign Client not initialized\"));\n          e();\n        });\n      });\n    try {\n      this.pending = !0;\n      const e = await this.register(), t = e.find({ requiredNamespaces: this.requiredNamespaces });\n      if (t.length)\n        return this.onOpen(t[0]);\n      const { uri: i, approval: n } = await e.connect({ requiredNamespaces: this.requiredNamespaces });\n      this.events.emit(Tr.uri, { uri: i }), this.session = await n(), this.events.emit(Tr.created, this.session), this.onOpen();\n    } catch (e) {\n      throw this.events.emit(\"open_error\", e), e;\n    }\n  }\n  async close() {\n    typeof this.session > \"u\" || (await (await this.register()).disconnect({ topic: this.session.topic, reason: st(\"USER_DISCONNECTED\") }), this.onClose());\n  }\n  async send(e, t) {\n    if (typeof this.client > \"u\" && (this.client = await this.register(), this.connected || await this.open()), typeof this.session > \"u\")\n      throw new Error(\"Signer connection is missing session\");\n    this.client.request({ topic: this.session.topic, request: e, chainId: t?.chainId }).then((i) => this.events.emit(\"payload\", Ma(e.id, i))).catch((i) => this.events.emit(\"payload\", Ia(e.id, i.message)));\n  }\n  async register(e = this.opts) {\n    if (typeof this.client < \"u\")\n      return this.client;\n    if (this.initializing)\n      return new Promise((t, i) => {\n        this.events.once(\"register_error\", (n) => {\n          i(n);\n        }), this.events.once(Tr.init, () => {\n          if (typeof this.client > \"u\")\n            return i(new Error(\"Sign Client not initialized\"));\n          t(this.client);\n        });\n      });\n    if (D5(e))\n      return this.client = e, this.registerEventListeners(), this.client;\n    try {\n      return this.initializing = !0, this.client = await Oa.init(e), this.initializing = !1, this.registerEventListeners(), this.events.emit(Tr.init), this.client;\n    } catch (t) {\n      throw this.events.emit(\"register_error\", t), t;\n    }\n  }\n  onOpen(e) {\n    this.pending = !1, e && (this.session = e), this.events.emit(\"open\");\n  }\n  onClose() {\n    this.pending = !1, this.client && (this.client = void 0), this.events.emit(\"close\");\n  }\n  registerEventListeners() {\n    typeof this.client < \"u\" && (this.client.on(\"session_event\", (e) => {\n      var t;\n      this.session && ((t = this.session) == null ? void 0 : t.topic) !== e.topic || this.events.emit(Tr.event, e.params);\n    }), this.client.on(\"session_update\", (e) => {\n      var t;\n      typeof this.client < \"u\" && (this.session && ((t = this.session) == null ? void 0 : t.topic) !== e.topic || (this.session = this.client.session.get(e.topic), this.events.emit(Tr.updated, this.session)));\n    }), this.client.on(\"session_delete\", (e) => {\n      var t;\n      this.session && (this.session && ((t = this.session) == null ? void 0 : t.topic) !== e.topic || (this.onClose(), this.events.emit(Tr.deleted, this.session), this.session = void 0));\n    }));\n  }\n}\nclass O5 {\n  constructor() {\n    He(this, \"accounts\", []);\n    He(this, \"eventEmitter\", new ir.EventEmitter());\n    He(this, \"updateSession\", (e) => {\n      if (!this.isValidSession(e))\n        throw console.warn(\n          \"updateSession incompatible session\",\n          e,\n          \"for adapter\",\n          this.formatChainId(this.chainId)\n        ), new Error(\"Invalid session\");\n      this.session = e;\n      const t = ed(e.namespaces, [this.namespace]);\n      this.setChainIds(t);\n      const i = Qu(e.namespaces, [\n        this.namespace\n      ]);\n      this.setAccounts(i);\n    });\n    He(this, \"isValidSession\", ({\n      namespaces: e,\n      requiredNamespaces: t\n    }) => {\n      const i = this.formatChainId(this.chainId);\n      return t ? !!t[this.namespace]?.chains?.includes(i) : !!e?.[this.namespace]?.accounts.some(\n        (n) => n.startsWith(i)\n      );\n    });\n  }\n  getRequiredNamespaces() {\n    const e = [this.formatChainId(this.chainId)];\n    return {\n      [this.namespace]: { chains: e, methods: this.methods, events: this.events }\n    };\n  }\n  isCompatibleChainId(e) {\n    return typeof e == \"string\" ? e.startsWith(`${this.namespace}:`) : !1;\n  }\n  setChainIds(e) {\n    const i = e.filter((n) => this.isCompatibleChainId(n)).map((n) => this.parseChainId(n)).filter((n) => n !== this.chainId);\n    i.length && (this.chainId = i[0], this.eventEmitter.emit(\"chainChanged\", this.chainId));\n  }\n  setChainId(e) {\n    if (this.isCompatibleChainId(e)) {\n      const t = this.parseChainId(e);\n      this.chainId = t, this.eventEmitter.emit(\"chainChanged\", this.chainId);\n    }\n  }\n  parseAccountId(e) {\n    const [t, i, n] = e.split(\":\");\n    return { chainId: `${t}:${i}`, address: n };\n  }\n  getSignerConnection(e) {\n    return new P5({\n      requiredNamespaces: {\n        [this.namespace]: {\n          chains: this.rpc.chains,\n          methods: this.rpc.methods,\n          events: this.rpc.events\n        }\n      },\n      client: e\n    });\n  }\n  registerEventListeners() {\n    this.rpcProvider.on(\"connect\", () => {\n      const { chains: e, accounts: t } = this.signerConnection;\n      e?.length && this.setChainIds(e), t?.length && this.setAccounts(t);\n    }), this.signerConnection.on(Tr.created, this.updateSession), this.signerConnection.on(Tr.updated, this.updateSession), this.signerConnection.on(Tr.event, (e) => {\n      if (!this.rpc.chains.includes(e.chainId))\n        return;\n      const { event: t } = e;\n      t.name === \"accountsChanged\" ? (this.accounts = t.data, this.eventEmitter.emit(\"accountsChanged\", this.accounts)) : t.name === \"chainChanged\" ? this.setChainId(t.data) : this.eventEmitter.emit(t.name, t.data);\n    }), this.rpcProvider.on(\"disconnect\", () => {\n      this.eventEmitter.emit(\"disconnect\");\n    });\n  }\n}\nclass Ph extends starknet__WEBPACK_IMPORTED_MODULE_1__.Account {\n  constructor(e, t, i, n) {\n    super(e, t, i), this.wallet = n;\n  }\n  async execute(e, t, i = {}) {\n    const n = Array.isArray(e) ? e : [e], s = t === void 0 || Array.isArray(t) ? i : t;\n    return await this.wallet.wallet_requestAddInvokeTransaction({\n      accountAddress: this.address,\n      executionRequest: { calls: n, invocationDetails: s }\n    });\n  }\n  async declare(e, t) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n  async deployAccount(e, t) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n}\nclass R5 {\n  constructor(e) {\n    this.wallet = e;\n  }\n  async getPubKey() {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n  async signMessage(e, t) {\n    const { signature: i } = await this.wallet.wallet_signTypedData({\n      accountAddress: t,\n      typedData: e\n    });\n    return i;\n  }\n  async signTransaction(e, t, i) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n  async signDeployAccountTransaction(e) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n  async signDeclareTransaction(e) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n}\nconst N5 = (r) => r.replace(/^SN_/, \"SN\"), T5 = (r) => r.replace(/^SN/, \"SN_\");\nclass C5 extends O5 {\n  // TODO: improve typing\n  constructor({ client: t, chainId: i, rpcUrl: n, provider: s }) {\n    super();\n    He(this, \"id\", \"argentMobile\");\n    He(this, \"name\", \"Argent Mobile\");\n    He(this, \"version\", \"0.1.0\");\n    He(this, \"icon\", \"\");\n    He(this, \"provider\");\n    He(this, \"signer\");\n    He(this, \"account\");\n    He(this, \"selectedAddress\", \"\");\n    // NamespaceAdapter\n    He(this, \"namespace\", \"starknet\");\n    He(this, \"methods\", [\n      \"starknet_supportedSpecs\",\n      \"starknet_signTypedData\",\n      \"starknet_requestAddInvokeTransaction\",\n      \"wallet_supportedSpecs\",\n      \"wallet_signTypedData\",\n      \"wallet_addInvokeTransaction\"\n    ]);\n    He(this, \"events\", [\"chainChanged\", \"accountsChanged\"]);\n    He(this, \"remoteSigner\");\n    He(this, \"signerConnection\");\n    He(this, \"rpcProvider\");\n    He(this, \"chainId\");\n    He(this, \"client\");\n    He(this, \"session\");\n    He(this, \"rpc\");\n    He(this, \"walletRpc\");\n    He(this, \"handleRequest\");\n    // StarknetWindowObject\n    He(this, \"request\", async (t) => {\n      if (!this.session)\n        throw new Error(\"No session\");\n      let i = t.type;\n      (i === \"wallet_addInvokeTransaction\" || i === \"wallet_supportedSpecs\" || i === \"wallet_signTypedData\") && (i = i.replace(\"wallet_\", \"starknet_\"));\n      const n = this.handleRequest[i];\n      if (n)\n        return n(t.params);\n      throw new Error(`Not implemented: .request() for ${t.type}`);\n    });\n    He(this, \"on\", (t, i) => {\n      this.eventEmitter.on(t, i);\n    });\n    He(this, \"off\", (t, i) => {\n      this.eventEmitter.off(t, i);\n    });\n    He(this, \"handleRequestChainId\", () => this.chainId === starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName.SN_SEPOLIA ? starknet__WEBPACK_IMPORTED_MODULE_1__.constants.StarknetChainId.SN_SEPOLIA : starknet__WEBPACK_IMPORTED_MODULE_1__.constants.StarknetChainId.SN_MAIN);\n    He(this, \"handleRequestAccounts\", () => this.accounts);\n    He(this, \"handleGetPermissions\", async () => await this.isPreauthorized() ? [\"accounts\"] : []);\n    He(this, \"handleAddInvokeTransaction\", async (t) => {\n      const { calls: i } = t;\n      return await this.requestWallet({\n        method: \"starknet_requestAddInvokeTransaction\",\n        params: {\n          accountAddress: this.account.address,\n          executionRequest: {\n            // will be removed when argent mobile will support entry_point and contract_address\n            calls: i?.map(({ contract_address: n, entry_point: s, ...o }) => ({\n              ...o,\n              contractAddress: n,\n              entrypoint: s\n            }))\n          }\n        }\n      });\n    });\n    He(this, \"handleSignTypedData\", async (t) => {\n      const i = {\n        accountAddress: this.account.address,\n        typedData: t\n      }, n = await this.requestWallet({\n        method: \"starknet_signTypedData\",\n        params: i\n      });\n      return \"signature\" in n ? n.signature : n;\n    });\n    He(this, \"handleSupportedSpecs\", async () => await this.requestWallet({\n      method: \"starknet_supportedSpecs\",\n      params: {}\n    }));\n    this.chainId = String(i ?? starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName.SN_MAIN), this.rpc = {\n      chains: i ? [this.formatChainId(this.chainId)] : [],\n      methods: this.methods,\n      events: this.events\n    }, this.signerConnection = this.getSignerConnection(t), this.rpcProvider = new xd(this.signerConnection), this.client = t, this.registerEventListeners(), this.walletRpc = new Proxy({}, {\n      get: (o, f) => (h) => this.requestWallet({ method: f, params: h })\n    }), this.remoteSigner = new R5(this.walletRpc), this.provider = s || new starknet__WEBPACK_IMPORTED_MODULE_1__.RpcProvider({ nodeUrl: n }), this.account = new Ph(\n      this.provider,\n      \"\",\n      this.remoteSigner,\n      this.walletRpc\n    ), this.handleRequest = Object.freeze({\n      wallet_requestChainId: this.handleRequestChainId,\n      wallet_requestAccounts: this.handleRequestAccounts,\n      wallet_getPermissions: this.handleGetPermissions,\n      starknet_addInvokeTransaction: this.handleAddInvokeTransaction,\n      starknet_signTypedData: this.handleSignTypedData,\n      starknet_supportedSpecs: this.handleSupportedSpecs,\n      wallet_addInvokeTransaction: this.handleAddInvokeTransaction,\n      wallet_signTypedData: this.handleSignTypedData,\n      wallet_supportedSpecs: this.handleSupportedSpecs\n    });\n  }\n  getNetworkName(t) {\n    if (t === \"SN_SEPOLIA\")\n      return starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName.SN_SEPOLIA;\n    if (t === \"SN_MAIN\")\n      return starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName.SN_MAIN;\n    throw new Error(`Unknown starknet.js network name for chainId ${t}`);\n  }\n  async enable() {\n    return await this.rpcProvider.connect(), this.accounts;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  get isConnected() {\n    return !0;\n  }\n  async isPreauthorized() {\n    return !!this.client.session.getAll().find(this.isValidSession);\n  }\n  async requestWallet(t) {\n    if (!this.session)\n      throw new Error(\"No session\");\n    try {\n      const { topic: i } = this.session, n = this.formatChainId(this.chainId);\n      Nr.showApprovalModal(t);\n      const s = await this.client.request({ topic: i, chainId: n, request: t });\n      return Nr.closeModal(\"animateSuccess\"), s;\n    } catch (i) {\n      throw Nr.closeModal(), i instanceof Error || i && i.message !== void 0 ? new Error(i.message) : new Error(\"Unknown error on requestWallet\");\n    }\n  }\n  // NamespaceAdapter\n  get isConnecting() {\n    return this.signerConnection.connecting;\n  }\n  async disable() {\n    await this.rpcProvider.disconnect();\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  // NamespaceAdapter private methods\n  registerEventListeners() {\n    super.registerEventListeners(), this.eventEmitter.on(\"chainChanged\", (t) => {\n      throw new Error(\"Not implemented: chainChanged\");\n    });\n  }\n  formatChainId(t) {\n    return `${this.namespace}:${N5(t)}`;\n  }\n  parseChainId(t) {\n    return T5(t.split(\":\")[1]);\n  }\n  setAccounts(t) {\n    this.accounts = t.filter(\n      (s) => this.parseChainId(this.parseAccountId(s).chainId) === this.chainId\n    ).map((s) => this.parseAccountId(s).address);\n    const { address: i } = this.parseAccountId(t[0]), n = i.startsWith(\"0x\") ? i : `0x${i}`;\n    this.account = new Ph(\n      this.provider,\n      n,\n      this.remoteSigner,\n      this.walletRpc\n    ), this.eventEmitter.emit(\"accountsChanged\", this.accounts), this.selectedAddress = n;\n  }\n}\nconst o4 = async (r) => M5(r, C5);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9pbmRleC0xYzFkMmIxMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQSwwQ0FBMEMsMERBQTBEO0FBQ3BHO0FBQ3dFO0FBQ0s7QUFDL0I7QUFDbEI7QUFDYztBQUNiO0FBQzdCLFdBQVcsYUFBYTtBQUN4QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0REFB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNENBQTRDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHFJQUFxSSxPQUFPO0FBQzVJO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxTUFBcU0sVUFBVTtBQUMvTSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFv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QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUIsbURBQW1ELGNBQWM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztB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Q0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdJQUFnSSxRQUFRO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0Esc0RBQXNELGNBQWM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDJCQUEyQiw2REFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixPQUFPO0FBQy9GLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsUUFBUTtBQUNySCxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLE9BQU87QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0Msb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixPQUFPO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwTEFBMEwsaUJBQWlCO0FBQzNNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sWUFBWTtBQUNsQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsV0FBVztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRCQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsV0FBVztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLGlCQUFpQjtBQUN6RztBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtB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QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEZBQTBGLCtCQUErQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSw0Q0FBNEMsa0NBQWtDO0FBQzlFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsZUFBZSxHQUFHLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYSwrREFBK0QsRUFBRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0YXJrbmV0a2l0QDIuMTAuNF9idWZmZXJ1dGlsQDQuMC45X3N0YXJrbmV0QDYuMjQuMV9lbmNvZGluZ0AwLjEuMTNfX3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANi4wLjVfem9kQDMuMjUuNTAvbm9kZV9tb2R1bGVzL3N0YXJrbmV0a2l0L2Rpc3QvaW5kZXgtMWMxZDJiMTAuanM/MTE5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY2wgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgaGwgPSAociwgZSwgdCkgPT4gZSBpbiByID8gY2wociwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IHJbZV0gPSB0O1xudmFyIEhlID0gKHIsIGUsIHQpID0+IChobChyLCB0eXBlb2YgZSAhPSBcInN5bWJvbFwiID8gZSArIFwiXCIgOiBlLCB0KSwgdCk7XG5pbXBvcnQgeyBkIGFzIGJuLCBnIGFzIE9oLCBjIGFzIHRyIH0gZnJvbSBcIi4vbGFzdENvbm5lY3RlZC1lOTM1MTkxMi5qc1wiO1xuaW1wb3J0IHsgY29uc3RhbnRzIGFzICRpLCBScGNQcm92aWRlciBhcyBSaCwgQWNjb3VudCBhcyB1bCB9IGZyb20gXCJzdGFya25ldFwiO1xuaW1wb3J0IHsgciBhcyBkbCB9IGZyb20gXCIuL2luZGV4LWQ0ZjMwZjJlLmpzXCI7XG5pbXBvcnQgXCIuL2NvcmUtZDIxZDJlOTYuanNcIjtcbmltcG9ydCBcIi4vZ2V0U3RhcmtuZXRDaGFpbklkLTdjNGIzMTYzLmpzXCI7XG5pbXBvcnQgXCIuL2luZGV4LTliYjQ4ZjhhLmpzXCI7XG52YXIgUm8gPSB7IGV4cG9ydHM6IHt9IH0sIGZuID0gdHlwZW9mIFJlZmxlY3QgPT0gXCJvYmplY3RcIiA/IFJlZmxlY3QgOiBudWxsLCB3ZiA9IGZuICYmIHR5cGVvZiBmbi5hcHBseSA9PSBcImZ1bmN0aW9uXCIgPyBmbi5hcHBseSA6IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGUsIHQsIGkpO1xufSwgTXM7XG5mbiAmJiB0eXBlb2YgZm4ub3duS2V5cyA9PSBcImZ1bmN0aW9uXCIgPyBNcyA9IGZuLm93bktleXMgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gTXMgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKSk7XG59IDogTXMgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlKTtcbn07XG5mdW5jdGlvbiBsbChyKSB7XG4gIGNvbnNvbGUgJiYgY29uc29sZS53YXJuICYmIGNvbnNvbGUud2FybihyKTtcbn1cbnZhciBOaCA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlICE9PSBlO1xufTtcbmZ1bmN0aW9uIG50KCkge1xuICBudC5pbml0LmNhbGwodGhpcyk7XG59XG5Sby5leHBvcnRzID0gbnQ7XG5Sby5leHBvcnRzLm9uY2UgPSBnbDtcbm50LkV2ZW50RW1pdHRlciA9IG50O1xubnQucHJvdG90eXBlLl9ldmVudHMgPSB2b2lkIDA7XG5udC5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbm50LnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdm9pZCAwO1xudmFyIF9mID0gMTA7XG5mdW5jdGlvbiByYShyKSB7XG4gIGlmICh0eXBlb2YgciAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiByKTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShudCwgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF9mO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHIpIHtcbiAgICBpZiAodHlwZW9mIHIgIT0gXCJudW1iZXJcIiB8fCByIDwgMCB8fCBOaChyKSlcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIHIgKyBcIi5cIik7XG4gICAgX2YgPSByO1xuICB9XG59KTtcbm50LmluaXQgPSBmdW5jdGlvbigpIHtcbiAgKHRoaXMuX2V2ZW50cyA9PT0gdm9pZCAwIHx8IHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpICYmICh0aGlzLl9ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdGhpcy5fZXZlbnRzQ291bnQgPSAwKSwgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHZvaWQgMDtcbn07XG5udC5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24oZSkge1xuICBpZiAodHlwZW9mIGUgIT0gXCJudW1iZXJcIiB8fCBlIDwgMCB8fCBOaChlKSlcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBlICsgXCIuXCIpO1xuICByZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzID0gZSwgdGhpcztcbn07XG5mdW5jdGlvbiBUaChyKSB7XG4gIHJldHVybiByLl9tYXhMaXN0ZW5lcnMgPT09IHZvaWQgMCA/IG50LmRlZmF1bHRNYXhMaXN0ZW5lcnMgOiByLl9tYXhMaXN0ZW5lcnM7XG59XG5udC5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBUaCh0aGlzKTtcbn07XG5udC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGUpIHtcbiAgZm9yICh2YXIgdCA9IFtdLCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICB0LnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIG4gPSBlID09PSBcImVycm9yXCIsIHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChzICE9PSB2b2lkIDApXG4gICAgbiA9IG4gJiYgcy5lcnJvciA9PT0gdm9pZCAwO1xuICBlbHNlIGlmICghbilcbiAgICByZXR1cm4gITE7XG4gIGlmIChuKSB7XG4gICAgdmFyIG87XG4gICAgaWYgKHQubGVuZ3RoID4gMCAmJiAobyA9IHRbMF0pLCBvIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICB0aHJvdyBvO1xuICAgIHZhciBmID0gbmV3IEVycm9yKFwiVW5oYW5kbGVkIGVycm9yLlwiICsgKG8gPyBcIiAoXCIgKyBvLm1lc3NhZ2UgKyBcIilcIiA6IFwiXCIpKTtcbiAgICB0aHJvdyBmLmNvbnRleHQgPSBvLCBmO1xuICB9XG4gIHZhciBoID0gc1tlXTtcbiAgaWYgKGggPT09IHZvaWQgMClcbiAgICByZXR1cm4gITE7XG4gIGlmICh0eXBlb2YgaCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgd2YoaCwgdGhpcywgdCk7XG4gIGVsc2VcbiAgICBmb3IgKHZhciBkID0gaC5sZW5ndGgsIHYgPSBxaChoLCBkKSwgaSA9IDA7IGkgPCBkOyArK2kpXG4gICAgICB3Zih2W2ldLCB0aGlzLCB0KTtcbiAgcmV0dXJuICEwO1xufTtcbmZ1bmN0aW9uIENoKHIsIGUsIHQsIGkpIHtcbiAgdmFyIG4sIHMsIG87XG4gIGlmIChyYSh0KSwgcyA9IHIuX2V2ZW50cywgcyA9PT0gdm9pZCAwID8gKHMgPSByLl9ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgci5fZXZlbnRzQ291bnQgPSAwKSA6IChzLm5ld0xpc3RlbmVyICE9PSB2b2lkIDAgJiYgKHIuZW1pdChcbiAgICBcIm5ld0xpc3RlbmVyXCIsXG4gICAgZSxcbiAgICB0Lmxpc3RlbmVyID8gdC5saXN0ZW5lciA6IHRcbiAgKSwgcyA9IHIuX2V2ZW50cyksIG8gPSBzW2VdKSwgbyA9PT0gdm9pZCAwKVxuICAgIG8gPSBzW2VdID0gdCwgKytyLl9ldmVudHNDb3VudDtcbiAgZWxzZSBpZiAodHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiID8gbyA9IHNbZV0gPSBpID8gW3QsIG9dIDogW28sIHRdIDogaSA/IG8udW5zaGlmdCh0KSA6IG8ucHVzaCh0KSwgbiA9IFRoKHIpLCBuID4gMCAmJiBvLmxlbmd0aCA+IG4gJiYgIW8ud2FybmVkKSB7XG4gICAgby53YXJuZWQgPSAhMDtcbiAgICB2YXIgZiA9IG5ldyBFcnJvcihcIlBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gXCIgKyBvLmxlbmd0aCArIFwiIFwiICsgU3RyaW5nKGUpICsgXCIgbGlzdGVuZXJzIGFkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdFwiKTtcbiAgICBmLm5hbWUgPSBcIk1heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZ1wiLCBmLmVtaXR0ZXIgPSByLCBmLnR5cGUgPSBlLCBmLmNvdW50ID0gby5sZW5ndGgsIGxsKGYpO1xuICB9XG4gIHJldHVybiByO1xufVxubnQucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gQ2godGhpcywgZSwgdCwgITEpO1xufTtcbm50LnByb3RvdHlwZS5vbiA9IG50LnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcbm50LnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBDaCh0aGlzLCBlLCB0LCAhMCk7XG59O1xuZnVuY3Rpb24gcGwoKSB7XG4gIGlmICghdGhpcy5maXJlZClcbiAgICByZXR1cm4gdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbiksIHRoaXMuZmlyZWQgPSAhMCwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/IHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCkgOiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gJGgociwgZSwgdCkge1xuICB2YXIgaSA9IHsgZmlyZWQ6ICExLCB3cmFwRm46IHZvaWQgMCwgdGFyZ2V0OiByLCB0eXBlOiBlLCBsaXN0ZW5lcjogdCB9LCBuID0gcGwuYmluZChpKTtcbiAgcmV0dXJuIG4ubGlzdGVuZXIgPSB0LCBpLndyYXBGbiA9IG4sIG47XG59XG5udC5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIHJhKHQpLCB0aGlzLm9uKGUsICRoKHRoaXMsIGUsIHQpKSwgdGhpcztcbn07XG5udC5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIHJhKHQpLCB0aGlzLnByZXBlbmRMaXN0ZW5lcihlLCAkaCh0aGlzLCBlLCB0KSksIHRoaXM7XG59O1xubnQucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZSwgdCkge1xuICB2YXIgaSwgbiwgcywgbywgZjtcbiAgaWYgKHJhKHQpLCBuID0gdGhpcy5fZXZlbnRzLCBuID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmIChpID0gbltlXSwgaSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAoaSA9PT0gdCB8fCBpLmxpc3RlbmVyID09PSB0KVxuICAgIC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDAgPyB0aGlzLl9ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IChkZWxldGUgbltlXSwgbi5yZW1vdmVMaXN0ZW5lciAmJiB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLCBlLCBpLmxpc3RlbmVyIHx8IHQpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGkgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChzID0gLTEsIG8gPSBpLmxlbmd0aCAtIDE7IG8gPj0gMDsgby0tKVxuICAgICAgaWYgKGlbb10gPT09IHQgfHwgaVtvXS5saXN0ZW5lciA9PT0gdCkge1xuICAgICAgICBmID0gaVtvXS5saXN0ZW5lciwgcyA9IG87XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGlmIChzIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIHMgPT09IDAgPyBpLnNoaWZ0KCkgOiB2bChpLCBzKSwgaS5sZW5ndGggPT09IDEgJiYgKG5bZV0gPSBpWzBdKSwgbi5yZW1vdmVMaXN0ZW5lciAhPT0gdm9pZCAwICYmIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsIGUsIGYgfHwgdCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xubnQucHJvdG90eXBlLm9mZiA9IG50LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbm50LnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbihlKSB7XG4gIHZhciB0LCBpLCBuO1xuICBpZiAoaSA9IHRoaXMuX2V2ZW50cywgaSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAoaS5yZW1vdmVMaXN0ZW5lciA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAwID8gKHRoaXMuX2V2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0aGlzLl9ldmVudHNDb3VudCA9IDApIDogaVtlXSAhPT0gdm9pZCAwICYmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwID8gdGhpcy5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkgOiBkZWxldGUgaVtlXSksIHRoaXM7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIHMgPSBPYmplY3Qua2V5cyhpKSwgbztcbiAgICBmb3IgKG4gPSAwOyBuIDwgcy5sZW5ndGg7ICsrbilcbiAgICAgIG8gPSBzW25dLCBvICE9PSBcInJlbW92ZUxpc3RlbmVyXCIgJiYgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMobyk7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVtb3ZlTGlzdGVuZXJcIiksIHRoaXMuX2V2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0aGlzLl9ldmVudHNDb3VudCA9IDAsIHRoaXM7XG4gIH1cbiAgaWYgKHQgPSBpW2VdLCB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihlLCB0KTtcbiAgZWxzZSBpZiAodCAhPT0gdm9pZCAwKVxuICAgIGZvciAobiA9IHQubGVuZ3RoIC0gMTsgbiA+PSAwOyBuLS0pXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGUsIHRbbl0pO1xuICByZXR1cm4gdGhpcztcbn07XG5mdW5jdGlvbiBMaChyLCBlLCB0KSB7XG4gIHZhciBpID0gci5fZXZlbnRzO1xuICBpZiAoaSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIG4gPSBpW2VdO1xuICByZXR1cm4gbiA9PT0gdm9pZCAwID8gW10gOiB0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIgPyB0ID8gW24ubGlzdGVuZXIgfHwgbl0gOiBbbl0gOiB0ID8gYmwobikgOiBxaChuLCBuLmxlbmd0aCk7XG59XG5udC5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gTGgodGhpcywgZSwgITApO1xufTtcbm50LnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBMaCh0aGlzLCBlLCAhMSk7XG59O1xubnQubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHIsIGUpIHtcbiAgcmV0dXJuIHR5cGVvZiByLmxpc3RlbmVyQ291bnQgPT0gXCJmdW5jdGlvblwiID8gci5saXN0ZW5lckNvdW50KGUpIDogRmguY2FsbChyLCBlKTtcbn07XG5udC5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IEZoO1xuZnVuY3Rpb24gRmgocikge1xuICB2YXIgZSA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGUgIT09IHZvaWQgMCkge1xuICAgIHZhciB0ID0gZVtyXTtcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKHQgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0Lmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn1cbm50LnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBNcyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuZnVuY3Rpb24gcWgociwgZSkge1xuICBmb3IgKHZhciB0ID0gbmV3IEFycmF5KGUpLCBpID0gMDsgaSA8IGU7ICsraSlcbiAgICB0W2ldID0gcltpXTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiB2bChyLCBlKSB7XG4gIGZvciAoOyBlICsgMSA8IHIubGVuZ3RoOyBlKyspXG4gICAgcltlXSA9IHJbZSArIDFdO1xuICByLnBvcCgpO1xufVxuZnVuY3Rpb24gYmwocikge1xuICBmb3IgKHZhciBlID0gbmV3IEFycmF5KHIubGVuZ3RoKSwgdCA9IDA7IHQgPCBlLmxlbmd0aDsgKyt0KVxuICAgIGVbdF0gPSByW3RdLmxpc3RlbmVyIHx8IHJbdF07XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gZ2wociwgZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24odCwgaSkge1xuICAgIGZ1bmN0aW9uIG4obykge1xuICAgICAgci5yZW1vdmVMaXN0ZW5lcihlLCBzKSwgaShvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcygpIHtcbiAgICAgIHR5cGVvZiByLnJlbW92ZUxpc3RlbmVyID09IFwiZnVuY3Rpb25cIiAmJiByLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgbiksIHQoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9XG4gICAgVWgociwgZSwgcywgeyBvbmNlOiAhMCB9KSwgZSAhPT0gXCJlcnJvclwiICYmIHlsKHIsIG4sIHsgb25jZTogITAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24geWwociwgZSwgdCkge1xuICB0eXBlb2Ygci5vbiA9PSBcImZ1bmN0aW9uXCIgJiYgVWgociwgXCJlcnJvclwiLCBlLCB0KTtcbn1cbmZ1bmN0aW9uIFVoKHIsIGUsIHQsIGkpIHtcbiAgaWYgKHR5cGVvZiByLm9uID09IFwiZnVuY3Rpb25cIilcbiAgICBpLm9uY2UgPyByLm9uY2UoZSwgdCkgOiByLm9uKGUsIHQpO1xuICBlbHNlIGlmICh0eXBlb2Ygci5hZGRFdmVudExpc3RlbmVyID09IFwiZnVuY3Rpb25cIilcbiAgICByLmFkZEV2ZW50TGlzdGVuZXIoZSwgZnVuY3Rpb24gbihzKSB7XG4gICAgICBpLm9uY2UgJiYgci5yZW1vdmVFdmVudExpc3RlbmVyKGUsIG4pLCB0KHMpO1xuICAgIH0pO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiByKTtcbn1cbnZhciBpciA9IFJvLmV4cG9ydHM7XG5jb25zdCB6aCA9IC8qIEBfX1BVUkVfXyAqLyBibihpcik7XG52YXIgaWUgPSB7fTtcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xudmFyIGFvID0gZnVuY3Rpb24ociwgZSkge1xuICByZXR1cm4gYW8gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbih0LCBpKSB7XG4gICAgdC5fX3Byb3RvX18gPSBpO1xuICB9IHx8IGZ1bmN0aW9uKHQsIGkpIHtcbiAgICBmb3IgKHZhciBuIGluIGkpXG4gICAgICBpLmhhc093blByb3BlcnR5KG4pICYmICh0W25dID0gaVtuXSk7XG4gIH0sIGFvKHIsIGUpO1xufTtcbmZ1bmN0aW9uIG1sKHIsIGUpIHtcbiAgYW8ociwgZSk7XG4gIGZ1bmN0aW9uIHQoKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IHI7XG4gIH1cbiAgci5wcm90b3R5cGUgPSBlID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShlKSA6ICh0LnByb3RvdHlwZSA9IGUucHJvdG90eXBlLCBuZXcgdCgpKTtcbn1cbnZhciBvbyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gb28gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciB0LCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHQgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBzIGluIHQpXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCBzKSAmJiAoZVtzXSA9IHRbc10pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgb28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiB3bChyLCBlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIGkgaW4gcilcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwociwgaSkgJiYgZS5pbmRleE9mKGkpIDwgMCAmJiAodFtpXSA9IHJbaV0pO1xuICBpZiAociAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09IFwiZnVuY3Rpb25cIilcbiAgICBmb3IgKHZhciBuID0gMCwgaSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocik7IG4gPCBpLmxlbmd0aDsgbisrKVxuICAgICAgZS5pbmRleE9mKGlbbl0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwociwgaVtuXSkgJiYgKHRbaVtuXV0gPSByW2lbbl1dKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfbChyLCBlLCB0LCBpKSB7XG4gIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgcyA9IG4gPCAzID8gZSA6IGkgPT09IG51bGwgPyBpID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB0KSA6IGksIG87XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09IFwiZnVuY3Rpb25cIilcbiAgICBzID0gUmVmbGVjdC5kZWNvcmF0ZShyLCBlLCB0LCBpKTtcbiAgZWxzZVxuICAgIGZvciAodmFyIGYgPSByLmxlbmd0aCAtIDE7IGYgPj0gMDsgZi0tKVxuICAgICAgKG8gPSByW2ZdKSAmJiAocyA9IChuIDwgMyA/IG8ocykgOiBuID4gMyA/IG8oZSwgdCwgcykgOiBvKGUsIHQpKSB8fCBzKTtcbiAgcmV0dXJuIG4gPiAzICYmIHMgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHMpLCBzO1xufVxuZnVuY3Rpb24geGwociwgZSkge1xuICByZXR1cm4gZnVuY3Rpb24odCwgaSkge1xuICAgIGUodCwgaSwgcik7XG4gIH07XG59XG5mdW5jdGlvbiBFbChyLCBlKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShyLCBlKTtcbn1cbmZ1bmN0aW9uIFNsKHIsIGUsIHQsIGkpIHtcbiAgZnVuY3Rpb24gbihzKSB7XG4gICAgcmV0dXJuIHMgaW5zdGFuY2VvZiB0ID8gcyA6IG5ldyB0KGZ1bmN0aW9uKG8pIHtcbiAgICAgIG8ocyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyAodCB8fCAodCA9IFByb21pc2UpKShmdW5jdGlvbihzLCBvKSB7XG4gICAgZnVuY3Rpb24gZih2KSB7XG4gICAgICB0cnkge1xuICAgICAgICBkKGkubmV4dCh2KSk7XG4gICAgICB9IGNhdGNoICh3KSB7XG4gICAgICAgIG8odyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGgodikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZChpLnRocm93KHYpKTtcbiAgICAgIH0gY2F0Y2ggKHcpIHtcbiAgICAgICAgbyh3KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZCh2KSB7XG4gICAgICB2LmRvbmUgPyBzKHYudmFsdWUpIDogbih2LnZhbHVlKS50aGVuKGYsIGgpO1xuICAgIH1cbiAgICBkKChpID0gaS5hcHBseShyLCBlIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBNbChyLCBlKSB7XG4gIHZhciB0ID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNbMF0gJiAxKVxuICAgICAgdGhyb3cgc1sxXTtcbiAgICByZXR1cm4gc1sxXTtcbiAgfSwgdHJ5czogW10sIG9wczogW10gfSwgaSwgbiwgcywgbztcbiAgcmV0dXJuIG8gPSB7IG5leHQ6IGYoMCksIHRocm93OiBmKDEpLCByZXR1cm46IGYoMikgfSwgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgKG9bU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgbztcbiAgZnVuY3Rpb24gZihkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBoKFtkLCB2XSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBoKGQpIHtcbiAgICBpZiAoaSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgIGZvciAoOyB0OyApXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaSA9IDEsIG4gJiYgKHMgPSBkWzBdICYgMiA/IG4ucmV0dXJuIDogZFswXSA/IG4udGhyb3cgfHwgKChzID0gbi5yZXR1cm4pICYmIHMuY2FsbChuKSwgMCkgOiBuLm5leHQpICYmICEocyA9IHMuY2FsbChuLCBkWzFdKSkuZG9uZSlcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgc3dpdGNoIChuID0gMCwgcyAmJiAoZCA9IFtkWzBdICYgMiwgcy52YWx1ZV0pLCBkWzBdKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHMgPSBkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIHQubGFiZWwrKywgeyB2YWx1ZTogZFsxXSwgZG9uZTogITEgfTtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0LmxhYmVsKyssIG4gPSBkWzFdLCBkID0gWzBdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgZCA9IHQub3BzLnBvcCgpLCB0LnRyeXMucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHMgPSB0LnRyeXMsICEocyA9IHMubGVuZ3RoID4gMCAmJiBzW3MubGVuZ3RoIC0gMV0pICYmIChkWzBdID09PSA2IHx8IGRbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgIHQgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkWzBdID09PSAzICYmICghcyB8fCBkWzFdID4gc1swXSAmJiBkWzFdIDwgc1szXSkpIHtcbiAgICAgICAgICAgICAgdC5sYWJlbCA9IGRbMV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRbMF0gPT09IDYgJiYgdC5sYWJlbCA8IHNbMV0pIHtcbiAgICAgICAgICAgICAgdC5sYWJlbCA9IHNbMV0sIHMgPSBkO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzICYmIHQubGFiZWwgPCBzWzJdKSB7XG4gICAgICAgICAgICAgIHQubGFiZWwgPSBzWzJdLCB0Lm9wcy5wdXNoKGQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNbMl0gJiYgdC5vcHMucG9wKCksIHQudHJ5cy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGQgPSBlLmNhbGwociwgdCk7XG4gICAgICB9IGNhdGNoICh2KSB7XG4gICAgICAgIGQgPSBbNiwgdl0sIG4gPSAwO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaSA9IHMgPSAwO1xuICAgICAgfVxuICAgIGlmIChkWzBdICYgNSlcbiAgICAgIHRocm93IGRbMV07XG4gICAgcmV0dXJuIHsgdmFsdWU6IGRbMF0gPyBkWzFdIDogdm9pZCAwLCBkb25lOiAhMCB9O1xuICB9XG59XG5mdW5jdGlvbiBJbChyLCBlLCB0LCBpKSB7XG4gIGkgPT09IHZvaWQgMCAmJiAoaSA9IHQpLCByW2ldID0gZVt0XTtcbn1cbmZ1bmN0aW9uIEFsKHIsIGUpIHtcbiAgZm9yICh2YXIgdCBpbiByKVxuICAgIHQgIT09IFwiZGVmYXVsdFwiICYmICFlLmhhc093blByb3BlcnR5KHQpICYmIChlW3RdID0gclt0XSk7XG59XG5mdW5jdGlvbiBmbyhyKSB7XG4gIHZhciBlID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCB0ID0gZSAmJiByW2VdLCBpID0gMDtcbiAgaWYgKHQpXG4gICAgcmV0dXJuIHQuY2FsbChyKTtcbiAgaWYgKHIgJiYgdHlwZW9mIHIubGVuZ3RoID09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gciAmJiBpID49IHIubGVuZ3RoICYmIChyID0gdm9pZCAwKSwgeyB2YWx1ZTogciAmJiByW2krK10sIGRvbmU6ICFyIH07XG4gICAgICB9XG4gICAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihlID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxuZnVuY3Rpb24gQmgociwgZSkge1xuICB2YXIgdCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHJbU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCF0KVxuICAgIHJldHVybiByO1xuICB2YXIgaSA9IHQuY2FsbChyKSwgbiwgcyA9IFtdLCBvO1xuICB0cnkge1xuICAgIGZvciAoOyAoZSA9PT0gdm9pZCAwIHx8IGUtLSA+IDApICYmICEobiA9IGkubmV4dCgpKS5kb25lOyApXG4gICAgICBzLnB1c2gobi52YWx1ZSk7XG4gIH0gY2F0Y2ggKGYpIHtcbiAgICBvID0geyBlcnJvcjogZiB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBuICYmICFuLmRvbmUgJiYgKHQgPSBpLnJldHVybikgJiYgdC5jYWxsKGkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAobylcbiAgICAgICAgdGhyb3cgby5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBEbCgpIHtcbiAgZm9yICh2YXIgciA9IFtdLCBlID0gMDsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKylcbiAgICByID0gci5jb25jYXQoQmgoYXJndW1lbnRzW2VdKSk7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gUGwoKSB7XG4gIGZvciAodmFyIHIgPSAwLCBlID0gMCwgdCA9IGFyZ3VtZW50cy5sZW5ndGg7IGUgPCB0OyBlKyspXG4gICAgciArPSBhcmd1bWVudHNbZV0ubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gQXJyYXkociksIG4gPSAwLCBlID0gMDsgZSA8IHQ7IGUrKylcbiAgICBmb3IgKHZhciBzID0gYXJndW1lbnRzW2VdLCBvID0gMCwgZiA9IHMubGVuZ3RoOyBvIDwgZjsgbysrLCBuKyspXG4gICAgICBpW25dID0gc1tvXTtcbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBXbihyKSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgV24gPyAodGhpcy52ID0gciwgdGhpcykgOiBuZXcgV24ocik7XG59XG5mdW5jdGlvbiBPbChyLCBlLCB0KSB7XG4gIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIGkgPSB0LmFwcGx5KHIsIGUgfHwgW10pLCBuLCBzID0gW107XG4gIHJldHVybiBuID0ge30sIG8oXCJuZXh0XCIpLCBvKFwidGhyb3dcIiksIG8oXCJyZXR1cm5cIiksIG5bU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sIG47XG4gIGZ1bmN0aW9uIG8oQSkge1xuICAgIGlbQV0gJiYgKG5bQV0gPSBmdW5jdGlvbihJKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oRCwgTikge1xuICAgICAgICBzLnB1c2goW0EsIEksIEQsIE5dKSA+IDEgfHwgZihBLCBJKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGYoQSwgSSkge1xuICAgIHRyeSB7XG4gICAgICBoKGlbQV0oSSkpO1xuICAgIH0gY2F0Y2ggKEQpIHtcbiAgICAgIHcoc1swXVszXSwgRCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGgoQSkge1xuICAgIEEudmFsdWUgaW5zdGFuY2VvZiBXbiA/IFByb21pc2UucmVzb2x2ZShBLnZhbHVlLnYpLnRoZW4oZCwgdikgOiB3KHNbMF1bMl0sIEEpO1xuICB9XG4gIGZ1bmN0aW9uIGQoQSkge1xuICAgIGYoXCJuZXh0XCIsIEEpO1xuICB9XG4gIGZ1bmN0aW9uIHYoQSkge1xuICAgIGYoXCJ0aHJvd1wiLCBBKTtcbiAgfVxuICBmdW5jdGlvbiB3KEEsIEkpIHtcbiAgICBBKEkpLCBzLnNoaWZ0KCksIHMubGVuZ3RoICYmIGYoc1swXVswXSwgc1swXVsxXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIFJsKHIpIHtcbiAgdmFyIGUsIHQ7XG4gIHJldHVybiBlID0ge30sIGkoXCJuZXh0XCIpLCBpKFwidGhyb3dcIiwgZnVuY3Rpb24obikge1xuICAgIHRocm93IG47XG4gIH0pLCBpKFwicmV0dXJuXCIpLCBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSwgZTtcbiAgZnVuY3Rpb24gaShuLCBzKSB7XG4gICAgZVtuXSA9IHJbbl0gPyBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gKHQgPSAhdCkgPyB7IHZhbHVlOiBXbihyW25dKG8pKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogcyA/IHMobykgOiBvO1xuICAgIH0gOiBzO1xuICB9XG59XG5mdW5jdGlvbiBObChyKSB7XG4gIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIGUgPSByW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgdDtcbiAgcmV0dXJuIGUgPyBlLmNhbGwocikgOiAociA9IHR5cGVvZiBmbyA9PSBcImZ1bmN0aW9uXCIgPyBmbyhyKSA6IHJbU3ltYm9sLml0ZXJhdG9yXSgpLCB0ID0ge30sIGkoXCJuZXh0XCIpLCBpKFwidGhyb3dcIiksIGkoXCJyZXR1cm5cIiksIHRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sIHQpO1xuICBmdW5jdGlvbiBpKHMpIHtcbiAgICB0W3NdID0gcltzXSAmJiBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oZiwgaCkge1xuICAgICAgICBvID0gcltzXShvKSwgbihmLCBoLCBvLmRvbmUsIG8udmFsdWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBuKHMsIG8sIGYsIGgpIHtcbiAgICBQcm9taXNlLnJlc29sdmUoaCkudGhlbihmdW5jdGlvbihkKSB7XG4gICAgICBzKHsgdmFsdWU6IGQsIGRvbmU6IGYgfSk7XG4gICAgfSwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIFRsKHIsIGUpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCBcInJhd1wiLCB7IHZhbHVlOiBlIH0pIDogci5yYXcgPSBlLCByO1xufVxuZnVuY3Rpb24gQ2wocikge1xuICBpZiAociAmJiByLl9fZXNNb2R1bGUpXG4gICAgcmV0dXJuIHI7XG4gIHZhciBlID0ge307XG4gIGlmIChyICE9IG51bGwpXG4gICAgZm9yICh2YXIgdCBpbiByKVxuICAgICAgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwociwgdCkgJiYgKGVbdF0gPSByW3RdKTtcbiAgcmV0dXJuIGUuZGVmYXVsdCA9IHIsIGU7XG59XG5mdW5jdGlvbiAkbChyKSB7XG4gIHJldHVybiByICYmIHIuX19lc01vZHVsZSA/IHIgOiB7IGRlZmF1bHQ6IHIgfTtcbn1cbmZ1bmN0aW9uIExsKHIsIGUpIHtcbiAgaWYgKCFlLmhhcyhyKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcbiAgcmV0dXJuIGUuZ2V0KHIpO1xufVxuZnVuY3Rpb24gRmwociwgZSwgdCkge1xuICBpZiAoIWUuaGFzKHIpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xuICByZXR1cm4gZS5zZXQociwgdCksIHQ7XG59XG5jb25zdCBxbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdldCBfX2Fzc2lnbigpIHtcbiAgICByZXR1cm4gb287XG4gIH0sXG4gIF9fYXN5bmNEZWxlZ2F0b3I6IFJsLFxuICBfX2FzeW5jR2VuZXJhdG9yOiBPbCxcbiAgX19hc3luY1ZhbHVlczogTmwsXG4gIF9fYXdhaXQ6IFduLFxuICBfX2F3YWl0ZXI6IFNsLFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0OiBMbCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZFNldDogRmwsXG4gIF9fY3JlYXRlQmluZGluZzogSWwsXG4gIF9fZGVjb3JhdGU6IF9sLFxuICBfX2V4cG9ydFN0YXI6IEFsLFxuICBfX2V4dGVuZHM6IG1sLFxuICBfX2dlbmVyYXRvcjogTWwsXG4gIF9faW1wb3J0RGVmYXVsdDogJGwsXG4gIF9faW1wb3J0U3RhcjogQ2wsXG4gIF9fbWFrZVRlbXBsYXRlT2JqZWN0OiBUbCxcbiAgX19tZXRhZGF0YTogRWwsXG4gIF9fcGFyYW06IHhsLFxuICBfX3JlYWQ6IEJoLFxuICBfX3Jlc3Q6IHdsLFxuICBfX3NwcmVhZDogRGwsXG4gIF9fc3ByZWFkQXJyYXlzOiBQbCxcbiAgX192YWx1ZXM6IGZvXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBRbiA9IC8qIEBfX1BVUkVfXyAqLyBPaChxbCk7XG52YXIgTmEgPSB7fSwgUm4gPSB7fSwgeGY7XG5mdW5jdGlvbiBVbCgpIHtcbiAgaWYgKHhmKVxuICAgIHJldHVybiBSbjtcbiAgeGYgPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgUm4uZGVsYXkgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIHIoZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgodCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHQoITApO1xuICAgICAgfSwgZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFJuLmRlbGF5ID0gciwgUm47XG59XG52YXIgT2kgPSB7fSwgVGEgPSB7fSwgUmkgPSB7fSwgRWY7XG5mdW5jdGlvbiB6bCgpIHtcbiAgcmV0dXJuIEVmIHx8IChFZiA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBSaS5PTkVfVEhPVVNBTkQgPSBSaS5PTkVfSFVORFJFRCA9IHZvaWQgMCwgUmkuT05FX0hVTkRSRUQgPSAxMDAsIFJpLk9ORV9USE9VU0FORCA9IDFlMyksIFJpO1xufVxudmFyIENhID0ge30sIFNmO1xuZnVuY3Rpb24gQmwoKSB7XG4gIHJldHVybiBTZiB8fCAoU2YgPSAxLCBmdW5jdGlvbihyKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgci5PTkVfWUVBUiA9IHIuRk9VUl9XRUVLUyA9IHIuVEhSRUVfV0VFS1MgPSByLlRXT19XRUVLUyA9IHIuT05FX1dFRUsgPSByLlRISVJUWV9EQVlTID0gci5TRVZFTl9EQVlTID0gci5GSVZFX0RBWVMgPSByLlRIUkVFX0RBWVMgPSByLk9ORV9EQVkgPSByLlRXRU5UWV9GT1VSX0hPVVJTID0gci5UV0VMVkVfSE9VUlMgPSByLlNJWF9IT1VSUyA9IHIuVEhSRUVfSE9VUlMgPSByLk9ORV9IT1VSID0gci5TSVhUWV9NSU5VVEVTID0gci5USElSVFlfTUlOVVRFUyA9IHIuVEVOX01JTlVURVMgPSByLkZJVkVfTUlOVVRFUyA9IHIuT05FX01JTlVURSA9IHIuU0lYVFlfU0VDT05EUyA9IHIuVEhJUlRZX1NFQ09ORFMgPSByLlRFTl9TRUNPTkRTID0gci5GSVZFX1NFQ09ORFMgPSByLk9ORV9TRUNPTkQgPSB2b2lkIDAsIHIuT05FX1NFQ09ORCA9IDEsIHIuRklWRV9TRUNPTkRTID0gNSwgci5URU5fU0VDT05EUyA9IDEwLCByLlRISVJUWV9TRUNPTkRTID0gMzAsIHIuU0lYVFlfU0VDT05EUyA9IDYwLCByLk9ORV9NSU5VVEUgPSByLlNJWFRZX1NFQ09ORFMsIHIuRklWRV9NSU5VVEVTID0gci5PTkVfTUlOVVRFICogNSwgci5URU5fTUlOVVRFUyA9IHIuT05FX01JTlVURSAqIDEwLCByLlRISVJUWV9NSU5VVEVTID0gci5PTkVfTUlOVVRFICogMzAsIHIuU0lYVFlfTUlOVVRFUyA9IHIuT05FX01JTlVURSAqIDYwLCByLk9ORV9IT1VSID0gci5TSVhUWV9NSU5VVEVTLCByLlRIUkVFX0hPVVJTID0gci5PTkVfSE9VUiAqIDMsIHIuU0lYX0hPVVJTID0gci5PTkVfSE9VUiAqIDYsIHIuVFdFTFZFX0hPVVJTID0gci5PTkVfSE9VUiAqIDEyLCByLlRXRU5UWV9GT1VSX0hPVVJTID0gci5PTkVfSE9VUiAqIDI0LCByLk9ORV9EQVkgPSByLlRXRU5UWV9GT1VSX0hPVVJTLCByLlRIUkVFX0RBWVMgPSByLk9ORV9EQVkgKiAzLCByLkZJVkVfREFZUyA9IHIuT05FX0RBWSAqIDUsIHIuU0VWRU5fREFZUyA9IHIuT05FX0RBWSAqIDcsIHIuVEhJUlRZX0RBWVMgPSByLk9ORV9EQVkgKiAzMCwgci5PTkVfV0VFSyA9IHIuU0VWRU5fREFZUywgci5UV09fV0VFS1MgPSByLk9ORV9XRUVLICogMiwgci5USFJFRV9XRUVLUyA9IHIuT05FX1dFRUsgKiAzLCByLkZPVVJfV0VFS1MgPSByLk9ORV9XRUVLICogNCwgci5PTkVfWUVBUiA9IHIuT05FX0RBWSAqIDM2NTtcbiAgfShDYSkpLCBDYTtcbn1cbnZhciBNZjtcbmZ1bmN0aW9uIGtoKCkge1xuICByZXR1cm4gTWYgfHwgKE1mID0gMSwgZnVuY3Rpb24ocikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gICAgY29uc3QgZSA9IFFuO1xuICAgIGUuX19leHBvcnRTdGFyKHpsKCksIHIpLCBlLl9fZXhwb3J0U3RhcihCbCgpLCByKTtcbiAgfShUYSkpLCBUYTtcbn1cbnZhciBJZjtcbmZ1bmN0aW9uIGtsKCkge1xuICBpZiAoSWYpXG4gICAgcmV0dXJuIE9pO1xuICBJZiA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBPaS5mcm9tTWlsaXNlY29uZHMgPSBPaS50b01pbGlzZWNvbmRzID0gdm9pZCAwO1xuICBjb25zdCByID0ga2goKTtcbiAgZnVuY3Rpb24gZShpKSB7XG4gICAgcmV0dXJuIGkgKiByLk9ORV9USE9VU0FORDtcbiAgfVxuICBPaS50b01pbGlzZWNvbmRzID0gZTtcbiAgZnVuY3Rpb24gdChpKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaSAvIHIuT05FX1RIT1VTQU5EKTtcbiAgfVxuICByZXR1cm4gT2kuZnJvbU1pbGlzZWNvbmRzID0gdCwgT2k7XG59XG52YXIgQWY7XG5mdW5jdGlvbiBqbCgpIHtcbiAgcmV0dXJuIEFmIHx8IChBZiA9IDEsIGZ1bmN0aW9uKHIpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICAgIGNvbnN0IGUgPSBRbjtcbiAgICBlLl9fZXhwb3J0U3RhcihVbCgpLCByKSwgZS5fX2V4cG9ydFN0YXIoa2woKSwgcik7XG4gIH0oTmEpKSwgTmE7XG59XG52YXIgdG4gPSB7fSwgRGY7XG5mdW5jdGlvbiBLbCgpIHtcbiAgaWYgKERmKVxuICAgIHJldHVybiB0bjtcbiAgRGYgPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgdG4uV2F0Y2ggPSB2b2lkIDA7XG4gIGNsYXNzIHIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy50aW1lc3RhbXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgc3RhcnQodCkge1xuICAgICAgaWYgKHRoaXMudGltZXN0YW1wcy5oYXModCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV2F0Y2ggYWxyZWFkeSBzdGFydGVkIGZvciBsYWJlbDogJHt0fWApO1xuICAgICAgdGhpcy50aW1lc3RhbXBzLnNldCh0LCB7IHN0YXJ0ZWQ6IERhdGUubm93KCkgfSk7XG4gICAgfVxuICAgIHN0b3AodCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuZ2V0KHQpO1xuICAgICAgaWYgKHR5cGVvZiBpLmVsYXBzZWQgPCBcInVcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXYXRjaCBhbHJlYWR5IHN0b3BwZWQgZm9yIGxhYmVsOiAke3R9YCk7XG4gICAgICBjb25zdCBuID0gRGF0ZS5ub3coKSAtIGkuc3RhcnRlZDtcbiAgICAgIHRoaXMudGltZXN0YW1wcy5zZXQodCwgeyBzdGFydGVkOiBpLnN0YXJ0ZWQsIGVsYXBzZWQ6IG4gfSk7XG4gICAgfVxuICAgIGdldCh0KSB7XG4gICAgICBjb25zdCBpID0gdGhpcy50aW1lc3RhbXBzLmdldCh0KTtcbiAgICAgIGlmICh0eXBlb2YgaSA+IFwidVwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHRpbWVzdGFtcCBmb3VuZCBmb3IgbGFiZWw6ICR7dH1gKTtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBlbGFwc2VkKHQpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLmdldCh0KTtcbiAgICAgIHJldHVybiBpLmVsYXBzZWQgfHwgRGF0ZS5ub3coKSAtIGkuc3RhcnRlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRuLldhdGNoID0gciwgdG4uZGVmYXVsdCA9IHIsIHRuO1xufVxudmFyICRhID0ge30sIE5uID0ge30sIFBmO1xuZnVuY3Rpb24gSGwoKSB7XG4gIGlmIChQZilcbiAgICByZXR1cm4gTm47XG4gIFBmID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5uLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIE5uLklXYXRjaCA9IHZvaWQgMDtcbiAgY2xhc3MgciB7XG4gIH1cbiAgcmV0dXJuIE5uLklXYXRjaCA9IHIsIE5uO1xufVxudmFyIE9mO1xuZnVuY3Rpb24gVmwoKSB7XG4gIHJldHVybiBPZiB8fCAoT2YgPSAxLCBmdW5jdGlvbihyKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgUW4uX19leHBvcnRTdGFyKEhsKCksIHIpO1xuICB9KCRhKSksICRhO1xufVxuKGZ1bmN0aW9uKHIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgY29uc3QgZSA9IFFuO1xuICBlLl9fZXhwb3J0U3RhcihqbCgpLCByKSwgZS5fX2V4cG9ydFN0YXIoS2woKSwgciksIGUuX19leHBvcnRTdGFyKFZsKCksIHIpLCBlLl9fZXhwb3J0U3RhcihraCgpLCByKTtcbn0pKGllKTtcbmNsYXNzIFdpIHtcbn1cbmxldCBXbCA9IGNsYXNzIGV4dGVuZHMgV2kge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufTtcbmNvbnN0IFJmID0gaWUuRklWRV9TRUNPTkRTLCBnbiA9IHsgcHVsc2U6IFwiaGVhcnRiZWF0X3B1bHNlXCIgfTtcbmxldCBHbCA9IGNsYXNzIGpoIGV4dGVuZHMgV2wge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSksIHRoaXMuZXZlbnRzID0gbmV3IGlyLkV2ZW50RW1pdHRlcigpLCB0aGlzLmludGVydmFsID0gUmYsIHRoaXMuaW50ZXJ2YWwgPSBlPy5pbnRlcnZhbCB8fCBSZjtcbiAgfVxuICBzdGF0aWMgYXN5bmMgaW5pdChlKSB7XG4gICAgY29uc3QgdCA9IG5ldyBqaChlKTtcbiAgICByZXR1cm4gYXdhaXQgdC5pbml0KCksIHQ7XG4gIH1cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICBzdG9wKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbFJlZik7XG4gIH1cbiAgb24oZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uKGUsIHQpO1xuICB9XG4gIG9uY2UoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uY2UoZSwgdCk7XG4gIH1cbiAgb2ZmKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vZmYoZSwgdCk7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGUsIHQpO1xuICB9XG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5pbnRlcnZhbFJlZiA9IHNldEludGVydmFsKCgpID0+IHRoaXMucHVsc2UoKSwgaWUudG9NaWxpc2Vjb25kcyh0aGlzLmludGVydmFsKSk7XG4gIH1cbiAgcHVsc2UoKSB7XG4gICAgdGhpcy5ldmVudHMuZW1pdChnbi5wdWxzZSk7XG4gIH1cbn07XG5jb25zdCBKbCA9IC9cIig/Ol98XFxcXHUwezJ9NVtGZl0pezJ9KD86cHxcXFxcdTB7Mn03MCkoPzpyfFxcXFx1MHsyfTcyKSg/Om98XFxcXHUwezJ9NltGZl0pKD86dHxcXFxcdTB7Mn03NCkoPzpvfFxcXFx1MHsyfTZbRmZdKSg/Ol98XFxcXHUwezJ9NVtGZl0pezJ9XCJcXHMqOi8sIFlsID0gL1wiKD86Y3xcXFxcdTAwNjMpKD86b3xcXFxcdTAwNltGZl0pKD86bnxcXFxcdTAwNltFZV0pKD86c3xcXFxcdTAwNzMpKD86dHxcXFxcdTAwNzQpKD86cnxcXFxcdTAwNzIpKD86dXxcXFxcdTAwNzUpKD86Y3xcXFxcdTAwNjMpKD86dHxcXFxcdTAwNzQpKD86b3xcXFxcdTAwNltGZl0pKD86cnxcXFxcdTAwNzIpXCJcXHMqOi8sIFhsID0gL15cXHMqW1wiW3tdfF5cXHMqLT9cXGR7MSwxNn0oXFwuXFxkezEsMTd9KT8oW0VlXVsrLV0/XFxkKyk/XFxzKiQvO1xuZnVuY3Rpb24gWmwociwgZSkge1xuICBpZiAociA9PT0gXCJfX3Byb3RvX19cIiB8fCByID09PSBcImNvbnN0cnVjdG9yXCIgJiYgZSAmJiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIFwicHJvdG90eXBlXCIgaW4gZSkge1xuICAgIFFsKHIpO1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFFsKHIpIHtcbiAgY29uc29sZS53YXJuKGBbZGVzdHJdIERyb3BwaW5nIFwiJHtyfVwiIGtleSB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb24uYCk7XG59XG5mdW5jdGlvbiBtcyhyLCBlID0ge30pIHtcbiAgaWYgKHR5cGVvZiByICE9IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHI7XG4gIGNvbnN0IHQgPSByLnRyaW0oKTtcbiAgaWYgKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1hdFxuICAgIHJbMF0gPT09ICdcIicgJiYgci5lbmRzV2l0aCgnXCInKSAmJiAhci5pbmNsdWRlcyhcIlxcXFxcIilcbiAgKVxuICAgIHJldHVybiB0LnNsaWNlKDEsIC0xKTtcbiAgaWYgKHQubGVuZ3RoIDw9IDkpIHtcbiAgICBjb25zdCBpID0gdC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpID09PSBcInRydWVcIilcbiAgICAgIHJldHVybiAhMDtcbiAgICBpZiAoaSA9PT0gXCJmYWxzZVwiKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmIChpID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpID09PSBcIm51bGxcIilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpID09PSBcIm5hblwiKVxuICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgaWYgKGkgPT09IFwiaW5maW5pdHlcIilcbiAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKGkgPT09IFwiLWluZmluaXR5XCIpXG4gICAgICByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICB9XG4gIGlmICghWGwudGVzdChyKSkge1xuICAgIGlmIChlLnN0cmljdClcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIltkZXN0cl0gSW52YWxpZCBKU09OXCIpO1xuICAgIHJldHVybiByO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKEpsLnRlc3QocikgfHwgWWwudGVzdChyKSkge1xuICAgICAgaWYgKGUuc3RyaWN0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbZGVzdHJdIFBvc3NpYmxlIHByb3RvdHlwZSBwb2xsdXRpb25cIik7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyLCBabCk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnBhcnNlKHIpO1xuICB9IGNhdGNoIChpKSB7XG4gICAgaWYgKGUuc3RyaWN0KVxuICAgICAgdGhyb3cgaTtcbiAgICByZXR1cm4gcjtcbiAgfVxufVxuZnVuY3Rpb24gZTAocikge1xuICByZXR1cm4gIXIgfHwgdHlwZW9mIHIudGhlbiAhPSBcImZ1bmN0aW9uXCIgPyBQcm9taXNlLnJlc29sdmUocikgOiByO1xufVxuZnVuY3Rpb24geHQociwgLi4uZSkge1xuICB0cnkge1xuICAgIHJldHVybiBlMChyKC4uLmUpKTtcbiAgfSBjYXRjaCAodCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0KTtcbiAgfVxufVxuZnVuY3Rpb24gdDAocikge1xuICBjb25zdCBlID0gdHlwZW9mIHI7XG4gIHJldHVybiByID09PSBudWxsIHx8IGUgIT09IFwib2JqZWN0XCIgJiYgZSAhPT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gcjAocikge1xuICBjb25zdCBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHIpO1xuICByZXR1cm4gIWUgfHwgZS5pc1Byb3RvdHlwZU9mKE9iamVjdCk7XG59XG5mdW5jdGlvbiBJcyhyKSB7XG4gIGlmICh0MChyKSlcbiAgICByZXR1cm4gU3RyaW5nKHIpO1xuICBpZiAocjAocikgfHwgQXJyYXkuaXNBcnJheShyKSlcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocik7XG4gIGlmICh0eXBlb2Ygci50b0pTT04gPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBJcyhyLnRvSlNPTigpKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiW3Vuc3RvcmFnZV0gQ2Fubm90IHN0cmluZ2lmeSB2YWx1ZSFcIik7XG59XG5jb25zdCBjbyA9IFwiYmFzZTY0OlwiO1xuZnVuY3Rpb24gaTAocikge1xuICByZXR1cm4gdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiA/IHIgOiBjbyArIGEwKHIpO1xufVxuZnVuY3Rpb24gbjAocikge1xuICByZXR1cm4gdHlwZW9mIHIgIT0gXCJzdHJpbmdcIiB8fCAhci5zdGFydHNXaXRoKGNvKSA/IHIgOiBzMChyLnNsaWNlKGNvLmxlbmd0aCkpO1xufVxuZnVuY3Rpb24gczAocikge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIgPyBCdWZmZXIuZnJvbShyLCBcImJhc2U2NFwiKSA6IFVpbnQ4QXJyYXkuZnJvbShcbiAgICBnbG9iYWxUaGlzLmF0b2IociksXG4gICAgKGUpID0+IGUuY29kZVBvaW50QXQoMClcbiAgKTtcbn1cbmZ1bmN0aW9uIGEwKHIpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyID8gQnVmZmVyLmZyb20ocikudG9TdHJpbmcoXCJiYXNlNjRcIikgOiBnbG9iYWxUaGlzLmJ0b2EoU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4ucikpO1xufVxuZnVuY3Rpb24gV3Qocikge1xuICByZXR1cm4gciAmJiByLnNwbGl0KFwiP1wiKVswXT8ucmVwbGFjZSgvWy9cXFxcXS9nLCBcIjpcIikucmVwbGFjZSgvOisvZywgXCI6XCIpLnJlcGxhY2UoL146fDokL2csIFwiXCIpIHx8IFwiXCI7XG59XG5mdW5jdGlvbiBvMCguLi5yKSB7XG4gIHJldHVybiBXdChyLmpvaW4oXCI6XCIpKTtcbn1cbmZ1bmN0aW9uIHdzKHIpIHtcbiAgcmV0dXJuIHIgPSBXdChyKSwgciA/IHIgKyBcIjpcIiA6IFwiXCI7XG59XG5jb25zdCBmMCA9IFwibWVtb3J5XCIsIGMwID0gKCkgPT4ge1xuICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBmMCxcbiAgICBnZXRJbnN0YW5jZTogKCkgPT4gcixcbiAgICBoYXNJdGVtKGUpIHtcbiAgICAgIHJldHVybiByLmhhcyhlKTtcbiAgICB9LFxuICAgIGdldEl0ZW0oZSkge1xuICAgICAgcmV0dXJuIHIuZ2V0KGUpID8/IG51bGw7XG4gICAgfSxcbiAgICBnZXRJdGVtUmF3KGUpIHtcbiAgICAgIHJldHVybiByLmdldChlKSA/PyBudWxsO1xuICAgIH0sXG4gICAgc2V0SXRlbShlLCB0KSB7XG4gICAgICByLnNldChlLCB0KTtcbiAgICB9LFxuICAgIHNldEl0ZW1SYXcoZSwgdCkge1xuICAgICAgci5zZXQoZSwgdCk7XG4gICAgfSxcbiAgICByZW1vdmVJdGVtKGUpIHtcbiAgICAgIHIuZGVsZXRlKGUpO1xuICAgIH0sXG4gICAgZ2V0S2V5cygpIHtcbiAgICAgIHJldHVybiBbLi4uci5rZXlzKCldO1xuICAgIH0sXG4gICAgY2xlYXIoKSB7XG4gICAgICByLmNsZWFyKCk7XG4gICAgfSxcbiAgICBkaXNwb3NlKCkge1xuICAgICAgci5jbGVhcigpO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBoMChyID0ge30pIHtcbiAgY29uc3QgZSA9IHtcbiAgICBtb3VudHM6IHsgXCJcIjogci5kcml2ZXIgfHwgYzAoKSB9LFxuICAgIG1vdW50cG9pbnRzOiBbXCJcIl0sXG4gICAgd2F0Y2hpbmc6ICExLFxuICAgIHdhdGNoTGlzdGVuZXJzOiBbXSxcbiAgICB1bndhdGNoOiB7fVxuICB9LCB0ID0gKGQpID0+IHtcbiAgICBmb3IgKGNvbnN0IHYgb2YgZS5tb3VudHBvaW50cylcbiAgICAgIGlmIChkLnN0YXJ0c1dpdGgodikpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmFzZTogdixcbiAgICAgICAgICByZWxhdGl2ZUtleTogZC5zbGljZSh2Lmxlbmd0aCksXG4gICAgICAgICAgZHJpdmVyOiBlLm1vdW50c1t2XVxuICAgICAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBcIlwiLFxuICAgICAgcmVsYXRpdmVLZXk6IGQsXG4gICAgICBkcml2ZXI6IGUubW91bnRzW1wiXCJdXG4gICAgfTtcbiAgfSwgaSA9IChkLCB2KSA9PiBlLm1vdW50cG9pbnRzLmZpbHRlcihcbiAgICAodykgPT4gdy5zdGFydHNXaXRoKGQpIHx8IHYgJiYgZC5zdGFydHNXaXRoKHcpXG4gICkubWFwKCh3KSA9PiAoe1xuICAgIHJlbGF0aXZlQmFzZTogZC5sZW5ndGggPiB3Lmxlbmd0aCA/IGQuc2xpY2Uody5sZW5ndGgpIDogdm9pZCAwLFxuICAgIG1vdW50cG9pbnQ6IHcsXG4gICAgZHJpdmVyOiBlLm1vdW50c1t3XVxuICB9KSksIG4gPSAoZCwgdikgPT4ge1xuICAgIGlmIChlLndhdGNoaW5nKSB7XG4gICAgICB2ID0gV3Qodik7XG4gICAgICBmb3IgKGNvbnN0IHcgb2YgZS53YXRjaExpc3RlbmVycylcbiAgICAgICAgdyhkLCB2KTtcbiAgICB9XG4gIH0sIHMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFlLndhdGNoaW5nKSB7XG4gICAgICBlLndhdGNoaW5nID0gITA7XG4gICAgICBmb3IgKGNvbnN0IGQgaW4gZS5tb3VudHMpXG4gICAgICAgIGUudW53YXRjaFtkXSA9IGF3YWl0IE5mKFxuICAgICAgICAgIGUubW91bnRzW2RdLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgZFxuICAgICAgICApO1xuICAgIH1cbiAgfSwgbyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoZS53YXRjaGluZykge1xuICAgICAgZm9yIChjb25zdCBkIGluIGUudW53YXRjaClcbiAgICAgICAgYXdhaXQgZS51bndhdGNoW2RdKCk7XG4gICAgICBlLnVud2F0Y2ggPSB7fSwgZS53YXRjaGluZyA9ICExO1xuICAgIH1cbiAgfSwgZiA9IChkLCB2LCB3KSA9PiB7XG4gICAgY29uc3QgQSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIEkgPSAoRCkgPT4ge1xuICAgICAgbGV0IE4gPSBBLmdldChELmJhc2UpO1xuICAgICAgcmV0dXJuIE4gfHwgKE4gPSB7XG4gICAgICAgIGRyaXZlcjogRC5kcml2ZXIsXG4gICAgICAgIGJhc2U6IEQuYmFzZSxcbiAgICAgICAgaXRlbXM6IFtdXG4gICAgICB9LCBBLnNldChELmJhc2UsIE4pKSwgTjtcbiAgICB9O1xuICAgIGZvciAoY29uc3QgRCBvZiBkKSB7XG4gICAgICBjb25zdCBOID0gdHlwZW9mIEQgPT0gXCJzdHJpbmdcIiwgayA9IFd0KE4gPyBEIDogRC5rZXkpLCBqID0gTiA/IHZvaWQgMCA6IEQudmFsdWUsIFQgPSBOIHx8ICFELm9wdGlvbnMgPyB2IDogeyAuLi52LCAuLi5ELm9wdGlvbnMgfSwgSyA9IHQoayk7XG4gICAgICBJKEspLml0ZW1zLnB1c2goe1xuICAgICAgICBrZXk6IGssXG4gICAgICAgIHZhbHVlOiBqLFxuICAgICAgICByZWxhdGl2ZUtleTogSy5yZWxhdGl2ZUtleSxcbiAgICAgICAgb3B0aW9uczogVFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4uQS52YWx1ZXMoKV0ubWFwKChEKSA9PiB3KEQpKSkudGhlbihcbiAgICAgIChEKSA9PiBELmZsYXQoKVxuICAgICk7XG4gIH0sIGggPSB7XG4gICAgLy8gSXRlbVxuICAgIGhhc0l0ZW0oZCwgdiA9IHt9KSB7XG4gICAgICBkID0gV3QoZCk7XG4gICAgICBjb25zdCB7IHJlbGF0aXZlS2V5OiB3LCBkcml2ZXI6IEEgfSA9IHQoZCk7XG4gICAgICByZXR1cm4geHQoQS5oYXNJdGVtLCB3LCB2KTtcbiAgICB9LFxuICAgIGdldEl0ZW0oZCwgdiA9IHt9KSB7XG4gICAgICBkID0gV3QoZCk7XG4gICAgICBjb25zdCB7IHJlbGF0aXZlS2V5OiB3LCBkcml2ZXI6IEEgfSA9IHQoZCk7XG4gICAgICByZXR1cm4geHQoQS5nZXRJdGVtLCB3LCB2KS50aGVuKFxuICAgICAgICAoSSkgPT4gbXMoSSlcbiAgICAgICk7XG4gICAgfSxcbiAgICBnZXRJdGVtcyhkLCB2ID0ge30pIHtcbiAgICAgIHJldHVybiBmKGQsIHYsICh3KSA9PiB3LmRyaXZlci5nZXRJdGVtcyA/IHh0KFxuICAgICAgICB3LmRyaXZlci5nZXRJdGVtcyxcbiAgICAgICAgdy5pdGVtcy5tYXAoKEEpID0+ICh7XG4gICAgICAgICAga2V5OiBBLnJlbGF0aXZlS2V5LFxuICAgICAgICAgIG9wdGlvbnM6IEEub3B0aW9uc1xuICAgICAgICB9KSksXG4gICAgICAgIHZcbiAgICAgICkudGhlbihcbiAgICAgICAgKEEpID0+IEEubWFwKChJKSA9PiAoe1xuICAgICAgICAgIGtleTogbzAody5iYXNlLCBJLmtleSksXG4gICAgICAgICAgdmFsdWU6IG1zKEkudmFsdWUpXG4gICAgICAgIH0pKVxuICAgICAgKSA6IFByb21pc2UuYWxsKFxuICAgICAgICB3Lml0ZW1zLm1hcCgoQSkgPT4geHQoXG4gICAgICAgICAgdy5kcml2ZXIuZ2V0SXRlbSxcbiAgICAgICAgICBBLnJlbGF0aXZlS2V5LFxuICAgICAgICAgIEEub3B0aW9uc1xuICAgICAgICApLnRoZW4oKEkpID0+ICh7XG4gICAgICAgICAga2V5OiBBLmtleSxcbiAgICAgICAgICB2YWx1ZTogbXMoSSlcbiAgICAgICAgfSkpKVxuICAgICAgKSk7XG4gICAgfSxcbiAgICBnZXRJdGVtUmF3KGQsIHYgPSB7fSkge1xuICAgICAgZCA9IFd0KGQpO1xuICAgICAgY29uc3QgeyByZWxhdGl2ZUtleTogdywgZHJpdmVyOiBBIH0gPSB0KGQpO1xuICAgICAgcmV0dXJuIEEuZ2V0SXRlbVJhdyA/IHh0KEEuZ2V0SXRlbVJhdywgdywgdikgOiB4dChBLmdldEl0ZW0sIHcsIHYpLnRoZW4oXG4gICAgICAgIChJKSA9PiBuMChJKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGFzeW5jIHNldEl0ZW0oZCwgdiwgdyA9IHt9KSB7XG4gICAgICBpZiAodiA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gaC5yZW1vdmVJdGVtKGQpO1xuICAgICAgZCA9IFd0KGQpO1xuICAgICAgY29uc3QgeyByZWxhdGl2ZUtleTogQSwgZHJpdmVyOiBJIH0gPSB0KGQpO1xuICAgICAgSS5zZXRJdGVtICYmIChhd2FpdCB4dChJLnNldEl0ZW0sIEEsIElzKHYpLCB3KSwgSS53YXRjaCB8fCBuKFwidXBkYXRlXCIsIGQpKTtcbiAgICB9LFxuICAgIGFzeW5jIHNldEl0ZW1zKGQsIHYpIHtcbiAgICAgIGF3YWl0IGYoZCwgdiwgYXN5bmMgKHcpID0+IHtcbiAgICAgICAgaWYgKHcuZHJpdmVyLnNldEl0ZW1zKVxuICAgICAgICAgIHJldHVybiB4dChcbiAgICAgICAgICAgIHcuZHJpdmVyLnNldEl0ZW1zLFxuICAgICAgICAgICAgdy5pdGVtcy5tYXAoKEEpID0+ICh7XG4gICAgICAgICAgICAgIGtleTogQS5yZWxhdGl2ZUtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IElzKEEudmFsdWUpLFxuICAgICAgICAgICAgICBvcHRpb25zOiBBLm9wdGlvbnNcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIHZcbiAgICAgICAgICApO1xuICAgICAgICB3LmRyaXZlci5zZXRJdGVtICYmIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHcuaXRlbXMubWFwKChBKSA9PiB4dChcbiAgICAgICAgICAgIHcuZHJpdmVyLnNldEl0ZW0sXG4gICAgICAgICAgICBBLnJlbGF0aXZlS2V5LFxuICAgICAgICAgICAgSXMoQS52YWx1ZSksXG4gICAgICAgICAgICBBLm9wdGlvbnNcbiAgICAgICAgICApKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhc3luYyBzZXRJdGVtUmF3KGQsIHYsIHcgPSB7fSkge1xuICAgICAgaWYgKHYgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIGgucmVtb3ZlSXRlbShkLCB3KTtcbiAgICAgIGQgPSBXdChkKTtcbiAgICAgIGNvbnN0IHsgcmVsYXRpdmVLZXk6IEEsIGRyaXZlcjogSSB9ID0gdChkKTtcbiAgICAgIGlmIChJLnNldEl0ZW1SYXcpXG4gICAgICAgIGF3YWl0IHh0KEkuc2V0SXRlbVJhdywgQSwgdiwgdyk7XG4gICAgICBlbHNlIGlmIChJLnNldEl0ZW0pXG4gICAgICAgIGF3YWl0IHh0KEkuc2V0SXRlbSwgQSwgaTAodiksIHcpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm47XG4gICAgICBJLndhdGNoIHx8IG4oXCJ1cGRhdGVcIiwgZCk7XG4gICAgfSxcbiAgICBhc3luYyByZW1vdmVJdGVtKGQsIHYgPSB7fSkge1xuICAgICAgdHlwZW9mIHYgPT0gXCJib29sZWFuXCIgJiYgKHYgPSB7IHJlbW92ZU1ldGE6IHYgfSksIGQgPSBXdChkKTtcbiAgICAgIGNvbnN0IHsgcmVsYXRpdmVLZXk6IHcsIGRyaXZlcjogQSB9ID0gdChkKTtcbiAgICAgIEEucmVtb3ZlSXRlbSAmJiAoYXdhaXQgeHQoQS5yZW1vdmVJdGVtLCB3LCB2KSwgKHYucmVtb3ZlTWV0YSB8fCB2LnJlbW92ZU1hdGEpICYmIGF3YWl0IHh0KEEucmVtb3ZlSXRlbSwgdyArIFwiJFwiLCB2KSwgQS53YXRjaCB8fCBuKFwicmVtb3ZlXCIsIGQpKTtcbiAgICB9LFxuICAgIC8vIE1ldGFcbiAgICBhc3luYyBnZXRNZXRhKGQsIHYgPSB7fSkge1xuICAgICAgdHlwZW9mIHYgPT0gXCJib29sZWFuXCIgJiYgKHYgPSB7IG5hdGl2ZU9ubHk6IHYgfSksIGQgPSBXdChkKTtcbiAgICAgIGNvbnN0IHsgcmVsYXRpdmVLZXk6IHcsIGRyaXZlcjogQSB9ID0gdChkKSwgSSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgaWYgKEEuZ2V0TWV0YSAmJiBPYmplY3QuYXNzaWduKEksIGF3YWl0IHh0KEEuZ2V0TWV0YSwgdywgdikpLCAhdi5uYXRpdmVPbmx5KSB7XG4gICAgICAgIGNvbnN0IEQgPSBhd2FpdCB4dChcbiAgICAgICAgICBBLmdldEl0ZW0sXG4gICAgICAgICAgdyArIFwiJFwiLFxuICAgICAgICAgIHZcbiAgICAgICAgKS50aGVuKChOKSA9PiBtcyhOKSk7XG4gICAgICAgIEQgJiYgdHlwZW9mIEQgPT0gXCJvYmplY3RcIiAmJiAodHlwZW9mIEQuYXRpbWUgPT0gXCJzdHJpbmdcIiAmJiAoRC5hdGltZSA9IG5ldyBEYXRlKEQuYXRpbWUpKSwgdHlwZW9mIEQubXRpbWUgPT0gXCJzdHJpbmdcIiAmJiAoRC5tdGltZSA9IG5ldyBEYXRlKEQubXRpbWUpKSwgT2JqZWN0LmFzc2lnbihJLCBEKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gSTtcbiAgICB9LFxuICAgIHNldE1ldGEoZCwgdiwgdyA9IHt9KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRJdGVtKGQgKyBcIiRcIiwgdiwgdyk7XG4gICAgfSxcbiAgICByZW1vdmVNZXRhKGQsIHYgPSB7fSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSXRlbShkICsgXCIkXCIsIHYpO1xuICAgIH0sXG4gICAgLy8gS2V5c1xuICAgIGFzeW5jIGdldEtleXMoZCwgdiA9IHt9KSB7XG4gICAgICBkID0gd3MoZCk7XG4gICAgICBjb25zdCB3ID0gaShkLCAhMCk7XG4gICAgICBsZXQgQSA9IFtdO1xuICAgICAgY29uc3QgSSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBEIG9mIHcpIHtcbiAgICAgICAgY29uc3QgTiA9IGF3YWl0IHh0KFxuICAgICAgICAgIEQuZHJpdmVyLmdldEtleXMsXG4gICAgICAgICAgRC5yZWxhdGl2ZUJhc2UsXG4gICAgICAgICAgdlxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgTikge1xuICAgICAgICAgIGNvbnN0IGogPSBELm1vdW50cG9pbnQgKyBXdChrKTtcbiAgICAgICAgICBBLnNvbWUoKFQpID0+IGouc3RhcnRzV2l0aChUKSkgfHwgSS5wdXNoKGopO1xuICAgICAgICB9XG4gICAgICAgIEEgPSBbXG4gICAgICAgICAgRC5tb3VudHBvaW50LFxuICAgICAgICAgIC4uLkEuZmlsdGVyKChrKSA9PiAhay5zdGFydHNXaXRoKEQubW91bnRwb2ludCkpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZCA/IEkuZmlsdGVyKFxuICAgICAgICAoRCkgPT4gRC5zdGFydHNXaXRoKGQpICYmIERbRC5sZW5ndGggLSAxXSAhPT0gXCIkXCJcbiAgICAgICkgOiBJLmZpbHRlcigoRCkgPT4gRFtELmxlbmd0aCAtIDFdICE9PSBcIiRcIik7XG4gICAgfSxcbiAgICAvLyBVdGlsc1xuICAgIGFzeW5jIGNsZWFyKGQsIHYgPSB7fSkge1xuICAgICAgZCA9IHdzKGQpLCBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgaShkLCAhMSkubWFwKGFzeW5jICh3KSA9PiB7XG4gICAgICAgICAgaWYgKHcuZHJpdmVyLmNsZWFyKVxuICAgICAgICAgICAgcmV0dXJuIHh0KHcuZHJpdmVyLmNsZWFyLCB3LnJlbGF0aXZlQmFzZSwgdik7XG4gICAgICAgICAgaWYgKHcuZHJpdmVyLnJlbW92ZUl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IEEgPSBhd2FpdCB3LmRyaXZlci5nZXRLZXlzKHcucmVsYXRpdmVCYXNlIHx8IFwiXCIsIHYpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICBBLm1hcCgoSSkgPT4gdy5kcml2ZXIucmVtb3ZlSXRlbShJLCB2KSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9LFxuICAgIGFzeW5jIGRpc3Bvc2UoKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhlLm1vdW50cykubWFwKChkKSA9PiBUZihkKSlcbiAgICAgICk7XG4gICAgfSxcbiAgICBhc3luYyB3YXRjaChkKSB7XG4gICAgICByZXR1cm4gYXdhaXQgcygpLCBlLndhdGNoTGlzdGVuZXJzLnB1c2goZCksIGFzeW5jICgpID0+IHtcbiAgICAgICAgZS53YXRjaExpc3RlbmVycyA9IGUud2F0Y2hMaXN0ZW5lcnMuZmlsdGVyKFxuICAgICAgICAgICh2KSA9PiB2ICE9PSBkXG4gICAgICAgICksIGUud2F0Y2hMaXN0ZW5lcnMubGVuZ3RoID09PSAwICYmIGF3YWl0IG8oKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luYyB1bndhdGNoKCkge1xuICAgICAgZS53YXRjaExpc3RlbmVycyA9IFtdLCBhd2FpdCBvKCk7XG4gICAgfSxcbiAgICAvLyBNb3VudFxuICAgIG1vdW50KGQsIHYpIHtcbiAgICAgIGlmIChkID0gd3MoZCksIGQgJiYgZS5tb3VudHNbZF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxyZWFkeSBtb3VudGVkIGF0ICR7ZH1gKTtcbiAgICAgIHJldHVybiBkICYmIChlLm1vdW50cG9pbnRzLnB1c2goZCksIGUubW91bnRwb2ludHMuc29ydCgodywgQSkgPT4gQS5sZW5ndGggLSB3Lmxlbmd0aCkpLCBlLm1vdW50c1tkXSA9IHYsIGUud2F0Y2hpbmcgJiYgUHJvbWlzZS5yZXNvbHZlKE5mKHYsIG4sIGQpKS50aGVuKCh3KSA9PiB7XG4gICAgICAgIGUudW53YXRjaFtkXSA9IHc7XG4gICAgICB9KS5jYXRjaChjb25zb2xlLmVycm9yKSwgaDtcbiAgICB9LFxuICAgIGFzeW5jIHVubW91bnQoZCwgdiA9ICEwKSB7XG4gICAgICBkID0gd3MoZCksICEoIWQgfHwgIWUubW91bnRzW2RdKSAmJiAoZS53YXRjaGluZyAmJiBkIGluIGUudW53YXRjaCAmJiAoZS51bndhdGNoW2RdPy4oKSwgZGVsZXRlIGUudW53YXRjaFtkXSksIHYgJiYgYXdhaXQgVGYoZS5tb3VudHNbZF0pLCBlLm1vdW50cG9pbnRzID0gZS5tb3VudHBvaW50cy5maWx0ZXIoKHcpID0+IHcgIT09IGQpLCBkZWxldGUgZS5tb3VudHNbZF0pO1xuICAgIH0sXG4gICAgZ2V0TW91bnQoZCA9IFwiXCIpIHtcbiAgICAgIGQgPSBXdChkKSArIFwiOlwiO1xuICAgICAgY29uc3QgdiA9IHQoZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkcml2ZXI6IHYuZHJpdmVyLFxuICAgICAgICBiYXNlOiB2LmJhc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRNb3VudHMoZCA9IFwiXCIsIHYgPSB7fSkge1xuICAgICAgcmV0dXJuIGQgPSBXdChkKSwgaShkLCB2LnBhcmVudHMpLm1hcCgoQSkgPT4gKHtcbiAgICAgICAgZHJpdmVyOiBBLmRyaXZlcixcbiAgICAgICAgYmFzZTogQS5tb3VudHBvaW50XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICAvLyBBbGlhc2VzXG4gICAga2V5czogKGQsIHYgPSB7fSkgPT4gaC5nZXRLZXlzKGQsIHYpLFxuICAgIGdldDogKGQsIHYgPSB7fSkgPT4gaC5nZXRJdGVtKGQsIHYpLFxuICAgIHNldDogKGQsIHYsIHcgPSB7fSkgPT4gaC5zZXRJdGVtKGQsIHYsIHcpLFxuICAgIGhhczogKGQsIHYgPSB7fSkgPT4gaC5oYXNJdGVtKGQsIHYpLFxuICAgIGRlbDogKGQsIHYgPSB7fSkgPT4gaC5yZW1vdmVJdGVtKGQsIHYpLFxuICAgIHJlbW92ZTogKGQsIHYgPSB7fSkgPT4gaC5yZW1vdmVJdGVtKGQsIHYpXG4gIH07XG4gIHJldHVybiBoO1xufVxuZnVuY3Rpb24gTmYociwgZSwgdCkge1xuICByZXR1cm4gci53YXRjaCA/IHIud2F0Y2goKGksIG4pID0+IGUoaSwgdCArIG4pKSA6ICgpID0+IHtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIFRmKHIpIHtcbiAgdHlwZW9mIHIuZGlzcG9zZSA9PSBcImZ1bmN0aW9uXCIgJiYgYXdhaXQgeHQoci5kaXNwb3NlKTtcbn1cbmZ1bmN0aW9uIEdpKHIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChlLCB0KSA9PiB7XG4gICAgci5vbmNvbXBsZXRlID0gci5vbnN1Y2Nlc3MgPSAoKSA9PiBlKHIucmVzdWx0KSwgci5vbmFib3J0ID0gci5vbmVycm9yID0gKCkgPT4gdChyLmVycm9yKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBLaChyLCBlKSB7XG4gIGNvbnN0IHQgPSBpbmRleGVkREIub3BlbihyKTtcbiAgdC5vbnVwZ3JhZGVuZWVkZWQgPSAoKSA9PiB0LnJlc3VsdC5jcmVhdGVPYmplY3RTdG9yZShlKTtcbiAgY29uc3QgaSA9IEdpKHQpO1xuICByZXR1cm4gKG4sIHMpID0+IGkudGhlbigobykgPT4gcyhvLnRyYW5zYWN0aW9uKGUsIG4pLm9iamVjdFN0b3JlKGUpKSk7XG59XG5sZXQgTGE7XG5mdW5jdGlvbiBlcygpIHtcbiAgcmV0dXJuIExhIHx8IChMYSA9IEtoKFwia2V5dmFsLXN0b3JlXCIsIFwia2V5dmFsXCIpKSwgTGE7XG59XG5mdW5jdGlvbiBDZihyLCBlID0gZXMoKSkge1xuICByZXR1cm4gZShcInJlYWRvbmx5XCIsICh0KSA9PiBHaSh0LmdldChyKSkpO1xufVxuZnVuY3Rpb24gdTAociwgZSwgdCA9IGVzKCkpIHtcbiAgcmV0dXJuIHQoXCJyZWFkd3JpdGVcIiwgKGkpID0+IChpLnB1dChlLCByKSwgR2koaS50cmFuc2FjdGlvbikpKTtcbn1cbmZ1bmN0aW9uIGQwKHIsIGUgPSBlcygpKSB7XG4gIHJldHVybiBlKFwicmVhZHdyaXRlXCIsICh0KSA9PiAodC5kZWxldGUociksIEdpKHQudHJhbnNhY3Rpb24pKSk7XG59XG5mdW5jdGlvbiBsMChyID0gZXMoKSkge1xuICByZXR1cm4gcihcInJlYWR3cml0ZVwiLCAoZSkgPT4gKGUuY2xlYXIoKSwgR2koZS50cmFuc2FjdGlvbikpKTtcbn1cbmZ1bmN0aW9uIHAwKHIsIGUpIHtcbiAgcmV0dXJuIHIub3BlbkN1cnNvcigpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzdWx0ICYmIChlKHRoaXMucmVzdWx0KSwgdGhpcy5yZXN1bHQuY29udGludWUoKSk7XG4gIH0sIEdpKHIudHJhbnNhY3Rpb24pO1xufVxuZnVuY3Rpb24gdjAociA9IGVzKCkpIHtcbiAgcmV0dXJuIHIoXCJyZWFkb25seVwiLCAoZSkgPT4ge1xuICAgIGlmIChlLmdldEFsbEtleXMpXG4gICAgICByZXR1cm4gR2koZS5nZXRBbGxLZXlzKCkpO1xuICAgIGNvbnN0IHQgPSBbXTtcbiAgICByZXR1cm4gcDAoZSwgKGkpID0+IHQucHVzaChpLmtleSkpLnRoZW4oKCkgPT4gdCk7XG4gIH0pO1xufVxuY29uc3QgYjAgPSAocikgPT4gSlNPTi5zdHJpbmdpZnkociwgKGUsIHQpID0+IHR5cGVvZiB0ID09IFwiYmlnaW50XCIgPyB0LnRvU3RyaW5nKCkgKyBcIm5cIiA6IHQpLCBnMCA9IChyKSA9PiB7XG4gIGNvbnN0IGUgPSAvKFtcXFs6XSk/KFxcZHsxNyx9fCg/Ols5XSg/OlsxLTldMDcxOTkyNTQ3NDA5OTF8MFsxLTldNzE5OTI1NDc0MDk5MXwwMFs4LTldMTk5MjU0NzQwOTkxfDAwN1syLTldOTkyNTQ3NDA5OTF8MDA3MTk5WzMtOV01NDc0MDk5MXwwMDcxOTkyWzYtOV00NzQwOTkxfDAwNzE5OTI1WzUtOV03NDA5OTF8MDA3MTk5MjU0WzgtOV00MDk5MXwwMDcxOTkyNTQ3WzUtOV0wOTkxfDAwNzE5OTI1NDc0WzEtOV05OTF8MDA3MTk5MjU0NzQwOTlbMi05XSkpKShbLFxcfVxcXV0pL2csIHQgPSByLnJlcGxhY2UoZSwgJyQxXCIkMm5cIiQzJyk7XG4gIHJldHVybiBKU09OLnBhcnNlKHQsIChpLCBuKSA9PiB0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIG4ubWF0Y2goL15cXGQrbiQvKSA/IEJpZ0ludChuLnN1YnN0cmluZygwLCBuLmxlbmd0aCAtIDEpKSA6IG4pO1xufTtcbmZ1bmN0aW9uIHVuKHIpIHtcbiAgaWYgKHR5cGVvZiByICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2FmZSBqc29uIHBhcnNlIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2Ygcn1gKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZzAocik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiByO1xuICB9XG59XG5mdW5jdGlvbiBqaShyKSB7XG4gIHJldHVybiB0eXBlb2YgciA9PSBcInN0cmluZ1wiID8gciA6IGIwKHIpIHx8IFwiXCI7XG59XG5jb25zdCB5MCA9IFwiaWRiLWtleXZhbFwiO1xudmFyIG0wID0gKHIgPSB7fSkgPT4ge1xuICBjb25zdCBlID0gci5iYXNlICYmIHIuYmFzZS5sZW5ndGggPiAwID8gYCR7ci5iYXNlfTpgIDogXCJcIiwgdCA9IChuKSA9PiBlICsgbjtcbiAgbGV0IGk7XG4gIHJldHVybiByLmRiTmFtZSAmJiByLnN0b3JlTmFtZSAmJiAoaSA9IEtoKHIuZGJOYW1lLCByLnN0b3JlTmFtZSkpLCB7IG5hbWU6IHkwLCBvcHRpb25zOiByLCBhc3luYyBoYXNJdGVtKG4pIHtcbiAgICByZXR1cm4gISh0eXBlb2YgYXdhaXQgQ2YodChuKSwgaSkgPiBcInVcIik7XG4gIH0sIGFzeW5jIGdldEl0ZW0obikge1xuICAgIHJldHVybiBhd2FpdCBDZih0KG4pLCBpKSA/PyBudWxsO1xuICB9LCBzZXRJdGVtKG4sIHMpIHtcbiAgICByZXR1cm4gdTAodChuKSwgcywgaSk7XG4gIH0sIHJlbW92ZUl0ZW0obikge1xuICAgIHJldHVybiBkMCh0KG4pLCBpKTtcbiAgfSwgZ2V0S2V5cygpIHtcbiAgICByZXR1cm4gdjAoaSk7XG4gIH0sIGNsZWFyKCkge1xuICAgIHJldHVybiBsMChpKTtcbiAgfSB9O1xufTtcbmNvbnN0IHcwID0gXCJXQUxMRVRfQ09OTkVDVF9WMl9JTkRFWEVEX0RCXCIsIF8wID0gXCJrZXl2YWx1ZXN0b3JhZ2VcIjtcbmxldCB4MCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbmRleGVkRGIgPSBoMCh7IGRyaXZlcjogbTAoeyBkYk5hbWU6IHcwLCBzdG9yZU5hbWU6IF8wIH0pIH0pO1xuICB9XG4gIGFzeW5jIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhlZERiLmdldEtleXMoKTtcbiAgfVxuICBhc3luYyBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5pbmRleGVkRGIuZ2V0SXRlbXMoYXdhaXQgdGhpcy5pbmRleGVkRGIuZ2V0S2V5cygpKSkubWFwKChlKSA9PiBbZS5rZXksIGUudmFsdWVdKTtcbiAgfVxuICBhc3luYyBnZXRJdGVtKGUpIHtcbiAgICBjb25zdCB0ID0gYXdhaXQgdGhpcy5pbmRleGVkRGIuZ2V0SXRlbShlKTtcbiAgICBpZiAodCAhPT0gbnVsbClcbiAgICAgIHJldHVybiB0O1xuICB9XG4gIGFzeW5jIHNldEl0ZW0oZSwgdCkge1xuICAgIGF3YWl0IHRoaXMuaW5kZXhlZERiLnNldEl0ZW0oZSwgamkodCkpO1xuICB9XG4gIGFzeW5jIHJlbW92ZUl0ZW0oZSkge1xuICAgIGF3YWl0IHRoaXMuaW5kZXhlZERiLnJlbW92ZUl0ZW0oZSk7XG4gIH1cbn07XG52YXIgRmEgPSB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDoge30sIEFzID0geyBleHBvcnRzOiB7fSB9O1xuKGZ1bmN0aW9uKCkge1xuICBsZXQgcjtcbiAgZnVuY3Rpb24gZSgpIHtcbiAgfVxuICByID0gZSwgci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNPd25Qcm9wZXJ0eSh0KSA/IFN0cmluZyh0aGlzW3RdKSA6IG51bGw7XG4gIH0sIHIucHJvdG90eXBlLnNldEl0ZW0gPSBmdW5jdGlvbih0LCBpKSB7XG4gICAgdGhpc1t0XSA9IFN0cmluZyhpKTtcbiAgfSwgci5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKHQpIHtcbiAgICBkZWxldGUgdGhpc1t0XTtcbiAgfSwgci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHRbaV0gPSB2b2lkIDAsIGRlbGV0ZSB0W2ldO1xuICAgIH0pO1xuICB9LCByLnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQgPSB0IHx8IDAsIE9iamVjdC5rZXlzKHRoaXMpW3RdO1xuICB9LCByLnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKFwibGVuZ3RoXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzKS5sZW5ndGg7XG4gIH0pLCB0eXBlb2YgRmEgPCBcInVcIiAmJiBGYS5sb2NhbFN0b3JhZ2UgPyBBcy5leHBvcnRzID0gRmEubG9jYWxTdG9yYWdlIDogdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UgPyBBcy5leHBvcnRzID0gd2luZG93LmxvY2FsU3RvcmFnZSA6IEFzLmV4cG9ydHMgPSBuZXcgZSgpO1xufSkoKTtcbmZ1bmN0aW9uIEUwKHIpIHtcbiAgdmFyIGU7XG4gIHJldHVybiBbclswXSwgdW4oKGUgPSByWzFdKSAhPSBudWxsID8gZSA6IFwiXCIpXTtcbn1cbmxldCBTMCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBBcy5leHBvcnRzO1xuICB9XG4gIGFzeW5jIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubG9jYWxTdG9yYWdlKTtcbiAgfVxuICBhc3luYyBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLmxvY2FsU3RvcmFnZSkubWFwKEUwKTtcbiAgfVxuICBhc3luYyBnZXRJdGVtKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShlKTtcbiAgICBpZiAodCAhPT0gbnVsbClcbiAgICAgIHJldHVybiB1bih0KTtcbiAgfVxuICBhc3luYyBzZXRJdGVtKGUsIHQpIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKGUsIGppKHQpKTtcbiAgfVxuICBhc3luYyByZW1vdmVJdGVtKGUpIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGUpO1xuICB9XG59O1xuY29uc3QgTTAgPSBcIndjX3N0b3JhZ2VfdmVyc2lvblwiLCAkZiA9IDEsIEkwID0gYXN5bmMgKHIsIGUsIHQpID0+IHtcbiAgY29uc3QgaSA9IE0wLCBuID0gYXdhaXQgZS5nZXRJdGVtKGkpO1xuICBpZiAobiAmJiBuID49ICRmKSB7XG4gICAgdChlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcyA9IGF3YWl0IHIuZ2V0S2V5cygpO1xuICBpZiAoIXMubGVuZ3RoKSB7XG4gICAgdChlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbyA9IFtdO1xuICBmb3IgKDsgcy5sZW5ndGg7ICkge1xuICAgIGNvbnN0IGYgPSBzLnNoaWZ0KCk7XG4gICAgaWYgKCFmKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgaCA9IGYudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaC5pbmNsdWRlcyhcIndjQFwiKSB8fCBoLmluY2x1ZGVzKFwid2FsbGV0Y29ubmVjdFwiKSB8fCBoLmluY2x1ZGVzKFwid2NfXCIpIHx8IGguaW5jbHVkZXMoXCJ3YWxsZXRfY29ubmVjdFwiKSkge1xuICAgICAgY29uc3QgZCA9IGF3YWl0IHIuZ2V0SXRlbShmKTtcbiAgICAgIGF3YWl0IGUuc2V0SXRlbShmLCBkKSwgby5wdXNoKGYpO1xuICAgIH1cbiAgfVxuICBhd2FpdCBlLnNldEl0ZW0oaSwgJGYpLCB0KGUpLCBBMChyLCBvKTtcbn0sIEEwID0gYXN5bmMgKHIsIGUpID0+IHtcbiAgZS5sZW5ndGggJiYgZS5mb3JFYWNoKGFzeW5jICh0KSA9PiB7XG4gICAgYXdhaXQgci5yZW1vdmVJdGVtKHQpO1xuICB9KTtcbn07XG5sZXQgRDAgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5zZXRJbml0aWFsaXplZCA9ICh0KSA9PiB7XG4gICAgICB0aGlzLnN0b3JhZ2UgPSB0LCB0aGlzLmluaXRpYWxpemVkID0gITA7XG4gICAgfTtcbiAgICBjb25zdCBlID0gbmV3IFMwKCk7XG4gICAgdGhpcy5zdG9yYWdlID0gZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdCA9IG5ldyB4MCgpO1xuICAgICAgSTAoZSwgdCwgdGhpcy5zZXRJbml0aWFsaXplZCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gITA7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpLCB0aGlzLnN0b3JhZ2UuZ2V0S2V5cygpO1xuICB9XG4gIGFzeW5jIGdldEVudHJpZXMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpLCB0aGlzLnN0b3JhZ2UuZ2V0RW50cmllcygpO1xuICB9XG4gIGFzeW5jIGdldEl0ZW0oZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmluaXRpYWxpemUoKSwgdGhpcy5zdG9yYWdlLmdldEl0ZW0oZSk7XG4gIH1cbiAgYXN5bmMgc2V0SXRlbShlLCB0KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpLCB0aGlzLnN0b3JhZ2Uuc2V0SXRlbShlLCB0KTtcbiAgfVxuICBhc3luYyByZW1vdmVJdGVtKGUpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplKCksIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGUpO1xuICB9XG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5pbml0aWFsaXplZCB8fCBhd2FpdCBuZXcgUHJvbWlzZSgoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCAmJiAoY2xlYXJJbnRlcnZhbCh0KSwgZSgpKTtcbiAgICAgIH0sIDIwKTtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIFAwKHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAnXCJbQ2lyY3VsYXJdXCInO1xuICB9XG59XG52YXIgTzAgPSBSMDtcbmZ1bmN0aW9uIFIwKHIsIGUsIHQpIHtcbiAgdmFyIGkgPSB0ICYmIHQuc3RyaW5naWZ5IHx8IFAwLCBuID0gMTtcbiAgaWYgKHR5cGVvZiByID09IFwib2JqZWN0XCIgJiYgciAhPT0gbnVsbCkge1xuICAgIHZhciBzID0gZS5sZW5ndGggKyBuO1xuICAgIGlmIChzID09PSAxKVxuICAgICAgcmV0dXJuIHI7XG4gICAgdmFyIG8gPSBuZXcgQXJyYXkocyk7XG4gICAgb1swXSA9IGkocik7XG4gICAgZm9yICh2YXIgZiA9IDE7IGYgPCBzOyBmKyspXG4gICAgICBvW2ZdID0gaShlW2ZdKTtcbiAgICByZXR1cm4gby5qb2luKFwiIFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIHIgIT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gcjtcbiAgdmFyIGggPSBlLmxlbmd0aDtcbiAgaWYgKGggPT09IDApXG4gICAgcmV0dXJuIHI7XG4gIGZvciAodmFyIGQgPSBcIlwiLCB2ID0gMSAtIG4sIHcgPSAtMSwgQSA9IHIgJiYgci5sZW5ndGggfHwgMCwgSSA9IDA7IEkgPCBBOyApIHtcbiAgICBpZiAoci5jaGFyQ29kZUF0KEkpID09PSAzNyAmJiBJICsgMSA8IEEpIHtcbiAgICAgIHN3aXRjaCAodyA9IHcgPiAtMSA/IHcgOiAwLCByLmNoYXJDb2RlQXQoSSArIDEpKSB7XG4gICAgICAgIGNhc2UgMTAwOlxuICAgICAgICBjYXNlIDEwMjpcbiAgICAgICAgICBpZiAodiA+PSBoIHx8IGVbdl0gPT0gbnVsbClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHcgPCBJICYmIChkICs9IHIuc2xpY2UodywgSSkpLCBkICs9IE51bWJlcihlW3ZdKSwgdyA9IEkgKyAyLCBJKys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA1OlxuICAgICAgICAgIGlmICh2ID49IGggfHwgZVt2XSA9PSBudWxsKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgdyA8IEkgJiYgKGQgKz0gci5zbGljZSh3LCBJKSksIGQgKz0gTWF0aC5mbG9vcihOdW1iZXIoZVt2XSkpLCB3ID0gSSArIDIsIEkrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3OTpcbiAgICAgICAgY2FzZSAxMTE6XG4gICAgICAgIGNhc2UgMTA2OlxuICAgICAgICAgIGlmICh2ID49IGggfHwgZVt2XSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgdyA8IEkgJiYgKGQgKz0gci5zbGljZSh3LCBJKSk7XG4gICAgICAgICAgdmFyIEQgPSB0eXBlb2YgZVt2XTtcbiAgICAgICAgICBpZiAoRCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZCArPSBcIidcIiArIGVbdl0gKyBcIidcIiwgdyA9IEkgKyAyLCBJKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZCArPSBlW3ZdLm5hbWUgfHwgXCI8YW5vbnltb3VzPlwiLCB3ID0gSSArIDIsIEkrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkICs9IGkoZVt2XSksIHcgPSBJICsgMiwgSSsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICBpZiAodiA+PSBoKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgdyA8IEkgJiYgKGQgKz0gci5zbGljZSh3LCBJKSksIGQgKz0gU3RyaW5nKGVbdl0pLCB3ID0gSSArIDIsIEkrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICB3IDwgSSAmJiAoZCArPSByLnNsaWNlKHcsIEkpKSwgZCArPSBcIiVcIiwgdyA9IEkgKyAyLCBJKyssIHYtLTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgICsrdjtcbiAgICB9XG4gICAgKytJO1xuICB9XG4gIHJldHVybiB3ID09PSAtMSA/IHIgOiAodyA8IEEgJiYgKGQgKz0gci5zbGljZSh3KSksIGQpO1xufVxuY29uc3QgTGYgPSBPMDtcbnZhciBhbiA9ICRyO1xuY29uc3QgR24gPSBCMCgpLmNvbnNvbGUgfHwge30sIE4wID0ge1xuICBtYXBIdHRwUmVxdWVzdDogX3MsXG4gIG1hcEh0dHBSZXNwb25zZTogX3MsXG4gIHdyYXBSZXF1ZXN0U2VyaWFsaXplcjogcWEsXG4gIHdyYXBSZXNwb25zZVNlcmlhbGl6ZXI6IHFhLFxuICB3cmFwRXJyb3JTZXJpYWxpemVyOiBxYSxcbiAgcmVxOiBfcyxcbiAgcmVzOiBfcyxcbiAgZXJyOiBGMFxufTtcbmZ1bmN0aW9uIFQwKHIsIGUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocikgPyByLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIGkgIT09IFwiIXN0ZFNlcmlhbGl6ZXJzLmVyclwiO1xuICB9KSA6IHIgPT09ICEwID8gT2JqZWN0LmtleXMoZSkgOiAhMTtcbn1cbmZ1bmN0aW9uICRyKHIpIHtcbiAgciA9IHIgfHwge30sIHIuYnJvd3NlciA9IHIuYnJvd3NlciB8fCB7fTtcbiAgY29uc3QgZSA9IHIuYnJvd3Nlci50cmFuc21pdDtcbiAgaWYgKGUgJiYgdHlwZW9mIGUuc2VuZCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgRXJyb3IoXCJwaW5vOiB0cmFuc21pdCBvcHRpb24gbXVzdCBoYXZlIGEgc2VuZCBmdW5jdGlvblwiKTtcbiAgY29uc3QgdCA9IHIuYnJvd3Nlci53cml0ZSB8fCBHbjtcbiAgci5icm93c2VyLndyaXRlICYmIChyLmJyb3dzZXIuYXNPYmplY3QgPSAhMCk7XG4gIGNvbnN0IGkgPSByLnNlcmlhbGl6ZXJzIHx8IHt9LCBuID0gVDAoci5icm93c2VyLnNlcmlhbGl6ZSwgaSk7XG4gIGxldCBzID0gci5icm93c2VyLnNlcmlhbGl6ZTtcbiAgQXJyYXkuaXNBcnJheShyLmJyb3dzZXIuc2VyaWFsaXplKSAmJiByLmJyb3dzZXIuc2VyaWFsaXplLmluZGV4T2YoXCIhc3RkU2VyaWFsaXplcnMuZXJyXCIpID4gLTEgJiYgKHMgPSAhMSk7XG4gIGNvbnN0IG8gPSBbXCJlcnJvclwiLCBcImZhdGFsXCIsIFwid2FyblwiLCBcImluZm9cIiwgXCJkZWJ1Z1wiLCBcInRyYWNlXCJdO1xuICB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgJiYgKHQuZXJyb3IgPSB0LmZhdGFsID0gdC53YXJuID0gdC5pbmZvID0gdC5kZWJ1ZyA9IHQudHJhY2UgPSB0KSwgci5lbmFibGVkID09PSAhMSAmJiAoci5sZXZlbCA9IFwic2lsZW50XCIpO1xuICBjb25zdCBmID0gci5sZXZlbCB8fCBcImluZm9cIiwgaCA9IE9iamVjdC5jcmVhdGUodCk7XG4gIGgubG9nIHx8IChoLmxvZyA9IEpuKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGgsIFwibGV2ZWxWYWxcIiwge1xuICAgIGdldDogdlxuICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGgsIFwibGV2ZWxcIiwge1xuICAgIGdldDogdyxcbiAgICBzZXQ6IEFcbiAgfSk7XG4gIGNvbnN0IGQgPSB7XG4gICAgdHJhbnNtaXQ6IGUsXG4gICAgc2VyaWFsaXplOiBuLFxuICAgIGFzT2JqZWN0OiByLmJyb3dzZXIuYXNPYmplY3QsXG4gICAgbGV2ZWxzOiBvLFxuICAgIHRpbWVzdGFtcDogcTAocilcbiAgfTtcbiAgaC5sZXZlbHMgPSAkci5sZXZlbHMsIGgubGV2ZWwgPSBmLCBoLnNldE1heExpc3RlbmVycyA9IGguZ2V0TWF4TGlzdGVuZXJzID0gaC5lbWl0ID0gaC5hZGRMaXN0ZW5lciA9IGgub24gPSBoLnByZXBlbmRMaXN0ZW5lciA9IGgub25jZSA9IGgucHJlcGVuZE9uY2VMaXN0ZW5lciA9IGgucmVtb3ZlTGlzdGVuZXIgPSBoLnJlbW92ZUFsbExpc3RlbmVycyA9IGgubGlzdGVuZXJzID0gaC5saXN0ZW5lckNvdW50ID0gaC5ldmVudE5hbWVzID0gaC53cml0ZSA9IGguZmx1c2ggPSBKbiwgaC5zZXJpYWxpemVycyA9IGksIGguX3NlcmlhbGl6ZSA9IG4sIGguX3N0ZEVyclNlcmlhbGl6ZSA9IHMsIGguY2hpbGQgPSBJLCBlICYmIChoLl9sb2dFdmVudCA9IGhvKCkpO1xuICBmdW5jdGlvbiB2KCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsID09PSBcInNpbGVudFwiID8gMSAvIDAgOiB0aGlzLmxldmVscy52YWx1ZXNbdGhpcy5sZXZlbF07XG4gIH1cbiAgZnVuY3Rpb24gdygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGV2ZWw7XG4gIH1cbiAgZnVuY3Rpb24gQShEKSB7XG4gICAgaWYgKEQgIT09IFwic2lsZW50XCIgJiYgIXRoaXMubGV2ZWxzLnZhbHVlc1tEXSlcbiAgICAgIHRocm93IEVycm9yKFwidW5rbm93biBsZXZlbCBcIiArIEQpO1xuICAgIHRoaXMuX2xldmVsID0gRCwgcm4oZCwgaCwgXCJlcnJvclwiLCBcImxvZ1wiKSwgcm4oZCwgaCwgXCJmYXRhbFwiLCBcImVycm9yXCIpLCBybihkLCBoLCBcIndhcm5cIiwgXCJlcnJvclwiKSwgcm4oZCwgaCwgXCJpbmZvXCIsIFwibG9nXCIpLCBybihkLCBoLCBcImRlYnVnXCIsIFwibG9nXCIpLCBybihkLCBoLCBcInRyYWNlXCIsIFwibG9nXCIpO1xuICB9XG4gIGZ1bmN0aW9uIEkoRCwgTikge1xuICAgIGlmICghRClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgYmluZGluZ3MgZm9yIGNoaWxkIFBpbm9cIik7XG4gICAgTiA9IE4gfHwge30sIG4gJiYgRC5zZXJpYWxpemVycyAmJiAoTi5zZXJpYWxpemVycyA9IEQuc2VyaWFsaXplcnMpO1xuICAgIGNvbnN0IGsgPSBOLnNlcmlhbGl6ZXJzO1xuICAgIGlmIChuICYmIGspIHtcbiAgICAgIHZhciBqID0gT2JqZWN0LmFzc2lnbih7fSwgaSwgayksIFQgPSByLmJyb3dzZXIuc2VyaWFsaXplID09PSAhMCA/IE9iamVjdC5rZXlzKGopIDogbjtcbiAgICAgIGRlbGV0ZSBELnNlcmlhbGl6ZXJzLCBpYShbRF0sIFQsIGosIHRoaXMuX3N0ZEVyclNlcmlhbGl6ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEsoJCkge1xuICAgICAgdGhpcy5fY2hpbGRMZXZlbCA9ICgkLl9jaGlsZExldmVsIHwgMCkgKyAxLCB0aGlzLmVycm9yID0gbm4oJCwgRCwgXCJlcnJvclwiKSwgdGhpcy5mYXRhbCA9IG5uKCQsIEQsIFwiZmF0YWxcIiksIHRoaXMud2FybiA9IG5uKCQsIEQsIFwid2FyblwiKSwgdGhpcy5pbmZvID0gbm4oJCwgRCwgXCJpbmZvXCIpLCB0aGlzLmRlYnVnID0gbm4oJCwgRCwgXCJkZWJ1Z1wiKSwgdGhpcy50cmFjZSA9IG5uKCQsIEQsIFwidHJhY2VcIiksIGogJiYgKHRoaXMuc2VyaWFsaXplcnMgPSBqLCB0aGlzLl9zZXJpYWxpemUgPSBUKSwgZSAmJiAodGhpcy5fbG9nRXZlbnQgPSBobyhcbiAgICAgICAgW10uY29uY2F0KCQuX2xvZ0V2ZW50LmJpbmRpbmdzLCBEKVxuICAgICAgKSk7XG4gICAgfVxuICAgIHJldHVybiBLLnByb3RvdHlwZSA9IHRoaXMsIG5ldyBLKHRoaXMpO1xuICB9XG4gIHJldHVybiBoO1xufVxuJHIubGV2ZWxzID0ge1xuICB2YWx1ZXM6IHtcbiAgICBmYXRhbDogNjAsXG4gICAgZXJyb3I6IDUwLFxuICAgIHdhcm46IDQwLFxuICAgIGluZm86IDMwLFxuICAgIGRlYnVnOiAyMCxcbiAgICB0cmFjZTogMTBcbiAgfSxcbiAgbGFiZWxzOiB7XG4gICAgMTA6IFwidHJhY2VcIixcbiAgICAyMDogXCJkZWJ1Z1wiLFxuICAgIDMwOiBcImluZm9cIixcbiAgICA0MDogXCJ3YXJuXCIsXG4gICAgNTA6IFwiZXJyb3JcIixcbiAgICA2MDogXCJmYXRhbFwiXG4gIH1cbn07XG4kci5zdGRTZXJpYWxpemVycyA9IE4wO1xuJHIuc3RkVGltZUZ1bmN0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHsgbnVsbFRpbWU6IEhoLCBlcG9jaFRpbWU6IFZoLCB1bml4VGltZTogVTAsIGlzb1RpbWU6IHowIH0pO1xuZnVuY3Rpb24gcm4ociwgZSwgdCwgaSkge1xuICBjb25zdCBuID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpO1xuICBlW3RdID0gZS5sZXZlbFZhbCA+IGUubGV2ZWxzLnZhbHVlc1t0XSA/IEpuIDogblt0XSA/IG5bdF0gOiBHblt0XSB8fCBHbltpXSB8fCBKbiwgQzAociwgZSwgdCk7XG59XG5mdW5jdGlvbiBDMChyLCBlLCB0KSB7XG4gICFyLnRyYW5zbWl0ICYmIGVbdF0gPT09IEpuIHx8IChlW3RdID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHMgPSByLnRpbWVzdGFtcCgpLCBvID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpLCBmID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSA9PT0gR24gPyBHbiA6IHRoaXM7XG4gICAgICBmb3IgKHZhciBoID0gMDsgaCA8IG8ubGVuZ3RoOyBoKyspXG4gICAgICAgIG9baF0gPSBhcmd1bWVudHNbaF07XG4gICAgICBpZiAoci5zZXJpYWxpemUgJiYgIXIuYXNPYmplY3QgJiYgaWEobywgdGhpcy5fc2VyaWFsaXplLCB0aGlzLnNlcmlhbGl6ZXJzLCB0aGlzLl9zdGRFcnJTZXJpYWxpemUpLCByLmFzT2JqZWN0ID8gaS5jYWxsKGYsICQwKHRoaXMsIHQsIG8sIHMpKSA6IGkuYXBwbHkoZiwgbyksIHIudHJhbnNtaXQpIHtcbiAgICAgICAgY29uc3QgZCA9IHIudHJhbnNtaXQubGV2ZWwgfHwgZS5sZXZlbCwgdiA9ICRyLmxldmVscy52YWx1ZXNbZF0sIHcgPSAkci5sZXZlbHMudmFsdWVzW3RdO1xuICAgICAgICBpZiAodyA8IHYpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBMMCh0aGlzLCB7XG4gICAgICAgICAgdHM6IHMsXG4gICAgICAgICAgbWV0aG9kTGV2ZWw6IHQsXG4gICAgICAgICAgbWV0aG9kVmFsdWU6IHcsXG4gICAgICAgICAgdHJhbnNtaXRMZXZlbDogZCxcbiAgICAgICAgICB0cmFuc21pdFZhbHVlOiAkci5sZXZlbHMudmFsdWVzW3IudHJhbnNtaXQubGV2ZWwgfHwgZS5sZXZlbF0sXG4gICAgICAgICAgc2VuZDogci50cmFuc21pdC5zZW5kLFxuICAgICAgICAgIHZhbDogZS5sZXZlbFZhbFxuICAgICAgICB9LCBvKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KGVbdF0pKTtcbn1cbmZ1bmN0aW9uICQwKHIsIGUsIHQsIGkpIHtcbiAgci5fc2VyaWFsaXplICYmIGlhKHQsIHIuX3NlcmlhbGl6ZSwgci5zZXJpYWxpemVycywgci5fc3RkRXJyU2VyaWFsaXplKTtcbiAgY29uc3QgbiA9IHQuc2xpY2UoKTtcbiAgbGV0IHMgPSBuWzBdO1xuICBjb25zdCBvID0ge307XG4gIGkgJiYgKG8udGltZSA9IGkpLCBvLmxldmVsID0gJHIubGV2ZWxzLnZhbHVlc1tlXTtcbiAgbGV0IGYgPSAoci5fY2hpbGRMZXZlbCB8IDApICsgMTtcbiAgaWYgKGYgPCAxICYmIChmID0gMSksIHMgIT09IG51bGwgJiYgdHlwZW9mIHMgPT0gXCJvYmplY3RcIikge1xuICAgIGZvciAoOyBmLS0gJiYgdHlwZW9mIG5bMF0gPT0gXCJvYmplY3RcIjsgKVxuICAgICAgT2JqZWN0LmFzc2lnbihvLCBuLnNoaWZ0KCkpO1xuICAgIHMgPSBuLmxlbmd0aCA/IExmKG4uc2hpZnQoKSwgbikgOiB2b2lkIDA7XG4gIH0gZWxzZVxuICAgIHR5cGVvZiBzID09IFwic3RyaW5nXCIgJiYgKHMgPSBMZihuLnNoaWZ0KCksIG4pKTtcbiAgcmV0dXJuIHMgIT09IHZvaWQgMCAmJiAoby5tc2cgPSBzKSwgbztcbn1cbmZ1bmN0aW9uIGlhKHIsIGUsIHQsIGkpIHtcbiAgZm9yIChjb25zdCBuIGluIHIpXG4gICAgaWYgKGkgJiYgcltuXSBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgcltuXSA9ICRyLnN0ZFNlcmlhbGl6ZXJzLmVycihyW25dKTtcbiAgICBlbHNlIGlmICh0eXBlb2YgcltuXSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHJbbl0pKVxuICAgICAgZm9yIChjb25zdCBzIGluIHJbbl0pXG4gICAgICAgIGUgJiYgZS5pbmRleE9mKHMpID4gLTEgJiYgcyBpbiB0ICYmIChyW25dW3NdID0gdFtzXShyW25dW3NdKSk7XG59XG5mdW5jdGlvbiBubihyLCBlLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBpID0gbmV3IEFycmF5KDEgKyBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBpWzBdID0gZTtcbiAgICBmb3IgKHZhciBuID0gMTsgbiA8IGkubGVuZ3RoOyBuKyspXG4gICAgICBpW25dID0gYXJndW1lbnRzW24gLSAxXTtcbiAgICByZXR1cm4gclt0XS5hcHBseSh0aGlzLCBpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEwwKHIsIGUsIHQpIHtcbiAgY29uc3QgaSA9IGUuc2VuZCwgbiA9IGUudHMsIHMgPSBlLm1ldGhvZExldmVsLCBvID0gZS5tZXRob2RWYWx1ZSwgZiA9IGUudmFsLCBoID0gci5fbG9nRXZlbnQuYmluZGluZ3M7XG4gIGlhKFxuICAgIHQsXG4gICAgci5fc2VyaWFsaXplIHx8IE9iamVjdC5rZXlzKHIuc2VyaWFsaXplcnMpLFxuICAgIHIuc2VyaWFsaXplcnMsXG4gICAgci5fc3RkRXJyU2VyaWFsaXplID09PSB2b2lkIDAgPyAhMCA6IHIuX3N0ZEVyclNlcmlhbGl6ZVxuICApLCByLl9sb2dFdmVudC50cyA9IG4sIHIuX2xvZ0V2ZW50Lm1lc3NhZ2VzID0gdC5maWx0ZXIoZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBoLmluZGV4T2YoZCkgPT09IC0xO1xuICB9KSwgci5fbG9nRXZlbnQubGV2ZWwubGFiZWwgPSBzLCByLl9sb2dFdmVudC5sZXZlbC52YWx1ZSA9IG8sIGkocywgci5fbG9nRXZlbnQsIGYpLCByLl9sb2dFdmVudCA9IGhvKGgpO1xufVxuZnVuY3Rpb24gaG8ocikge1xuICByZXR1cm4ge1xuICAgIHRzOiAwLFxuICAgIG1lc3NhZ2VzOiBbXSxcbiAgICBiaW5kaW5nczogciB8fCBbXSxcbiAgICBsZXZlbDogeyBsYWJlbDogXCJcIiwgdmFsdWU6IDAgfVxuICB9O1xufVxuZnVuY3Rpb24gRjAocikge1xuICBjb25zdCBlID0ge1xuICAgIHR5cGU6IHIuY29uc3RydWN0b3IubmFtZSxcbiAgICBtc2c6IHIubWVzc2FnZSxcbiAgICBzdGFjazogci5zdGFja1xuICB9O1xuICBmb3IgKGNvbnN0IHQgaW4gcilcbiAgICBlW3RdID09PSB2b2lkIDAgJiYgKGVbdF0gPSByW3RdKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBxMChyKSB7XG4gIHJldHVybiB0eXBlb2Ygci50aW1lc3RhbXAgPT0gXCJmdW5jdGlvblwiID8gci50aW1lc3RhbXAgOiByLnRpbWVzdGFtcCA9PT0gITEgPyBIaCA6IFZoO1xufVxuZnVuY3Rpb24gX3MoKSB7XG4gIHJldHVybiB7fTtcbn1cbmZ1bmN0aW9uIHFhKHIpIHtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBKbigpIHtcbn1cbmZ1bmN0aW9uIEhoKCkge1xuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBWaCgpIHtcbiAgcmV0dXJuIERhdGUubm93KCk7XG59XG5mdW5jdGlvbiBVMCgpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDFlMyk7XG59XG5mdW5jdGlvbiB6MCgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKERhdGUubm93KCkpLnRvSVNPU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBCMCgpIHtcbiAgZnVuY3Rpb24gcihlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlIDwgXCJ1XCIgJiYgZTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCBcImdsb2JhbFRoaXNcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZSBPYmplY3QucHJvdG90eXBlLmdsb2JhbFRoaXMsIHRoaXMuZ2xvYmFsVGhpcyA9IHRoaXM7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH0pLCBnbG9iYWxUaGlzO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gcihzZWxmKSB8fCByKHdpbmRvdykgfHwgcih0aGlzKSB8fCB7fTtcbiAgfVxufVxuY29uc3QgbmEgPSAvKiBAX19QVVJFX18gKi8gYm4oYW4pLCBrMCA9IHsgbGV2ZWw6IFwiaW5mb1wiIH0sIHRzID0gXCJjdXN0b21fY29udGV4dFwiLCBObyA9IDFlMyAqIDEwMjQ7XG5sZXQgajAgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLm5vZGVWYWx1ZSA9IGUsIHRoaXMuc2l6ZUluQnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGhpcy5ub2RlVmFsdWUpLmxlbmd0aCwgdGhpcy5uZXh0ID0gbnVsbDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVZhbHVlO1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnNpemVJbkJ5dGVzO1xuICB9XG59LCBGZiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuaGVhZCA9IG51bGwsIHRoaXMudGFpbCA9IG51bGwsIHRoaXMubGVuZ3RoSW5Ob2RlcyA9IDAsIHRoaXMubWF4U2l6ZUluQnl0ZXMgPSBlLCB0aGlzLnNpemVJbkJ5dGVzID0gMDtcbiAgfVxuICBhcHBlbmQoZSkge1xuICAgIGNvbnN0IHQgPSBuZXcgajAoZSk7XG4gICAgaWYgKHQuc2l6ZSA+IHRoaXMubWF4U2l6ZUluQnl0ZXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFtMaW5rZWRMaXN0XSBWYWx1ZSB0b28gYmlnIHRvIGluc2VydCBpbnRvIGxpc3Q6ICR7ZX0gd2l0aCBzaXplICR7dC5zaXplfWApO1xuICAgIGZvciAoOyB0aGlzLnNpemUgKyB0LnNpemUgPiB0aGlzLm1heFNpemVJbkJ5dGVzOyApXG4gICAgICB0aGlzLnNoaWZ0KCk7XG4gICAgdGhpcy5oZWFkID8gKHRoaXMudGFpbCAmJiAodGhpcy50YWlsLm5leHQgPSB0KSwgdGhpcy50YWlsID0gdCkgOiAodGhpcy5oZWFkID0gdCwgdGhpcy50YWlsID0gdCksIHRoaXMubGVuZ3RoSW5Ob2RlcysrLCB0aGlzLnNpemVJbkJ5dGVzICs9IHQuc2l6ZTtcbiAgfVxuICBzaGlmdCgpIHtcbiAgICBpZiAoIXRoaXMuaGVhZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5oZWFkO1xuICAgIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0LCB0aGlzLmhlYWQgfHwgKHRoaXMudGFpbCA9IG51bGwpLCB0aGlzLmxlbmd0aEluTm9kZXMtLSwgdGhpcy5zaXplSW5CeXRlcyAtPSBlLnNpemU7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgbGV0IHQgPSB0aGlzLmhlYWQ7XG4gICAgZm9yICg7IHQgIT09IG51bGw7IClcbiAgICAgIGUucHVzaCh0LnZhbHVlKSwgdCA9IHQubmV4dDtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aEluTm9kZXM7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZUluQnl0ZXM7XG4gIH1cbiAgdG9PcmRlcmVkQXJyYXkoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcyk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgbGV0IGUgPSB0aGlzLmhlYWQ7XG4gICAgcmV0dXJuIHsgbmV4dDogKCkgPT4ge1xuICAgICAgaWYgKCFlKVxuICAgICAgICByZXR1cm4geyBkb25lOiAhMCwgdmFsdWU6IG51bGwgfTtcbiAgICAgIGNvbnN0IHQgPSBlLnZhbHVlO1xuICAgICAgcmV0dXJuIGUgPSBlLm5leHQsIHsgZG9uZTogITEsIHZhbHVlOiB0IH07XG4gICAgfSB9O1xuICB9XG59LCBXaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSwgdCA9IE5vKSB7XG4gICAgdGhpcy5sZXZlbCA9IGUgPz8gXCJlcnJvclwiLCB0aGlzLmxldmVsVmFsdWUgPSBhbi5sZXZlbHMudmFsdWVzW3RoaXMubGV2ZWxdLCB0aGlzLk1BWF9MT0dfU0laRV9JTl9CWVRFUyA9IHQsIHRoaXMubG9ncyA9IG5ldyBGZih0aGlzLk1BWF9MT0dfU0laRV9JTl9CWVRFUyk7XG4gIH1cbiAgZm9yd2FyZFRvQ29uc29sZShlLCB0KSB7XG4gICAgdCA9PT0gYW4ubGV2ZWxzLnZhbHVlcy5lcnJvciA/IGNvbnNvbGUuZXJyb3IoZSkgOiB0ID09PSBhbi5sZXZlbHMudmFsdWVzLndhcm4gPyBjb25zb2xlLndhcm4oZSkgOiB0ID09PSBhbi5sZXZlbHMudmFsdWVzLmRlYnVnID8gY29uc29sZS5kZWJ1ZyhlKSA6IHQgPT09IGFuLmxldmVscy52YWx1ZXMudHJhY2UgPyBjb25zb2xlLnRyYWNlKGUpIDogY29uc29sZS5sb2coZSk7XG4gIH1cbiAgYXBwZW5kVG9Mb2dzKGUpIHtcbiAgICB0aGlzLmxvZ3MuYXBwZW5kKGppKHsgdGltZXN0YW1wOiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCksIGxvZzogZSB9KSk7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKGUpLmxldmVsIDogZS5sZXZlbDtcbiAgICB0ID49IHRoaXMubGV2ZWxWYWx1ZSAmJiB0aGlzLmZvcndhcmRUb0NvbnNvbGUoZSwgdCk7XG4gIH1cbiAgZ2V0TG9ncygpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dzO1xuICB9XG4gIGNsZWFyTG9ncygpIHtcbiAgICB0aGlzLmxvZ3MgPSBuZXcgRmYodGhpcy5NQVhfTE9HX1NJWkVfSU5fQllURVMpO1xuICB9XG4gIGdldExvZ0FycmF5KCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubG9ncyk7XG4gIH1cbiAgbG9nc1RvQmxvYihlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0TG9nQXJyYXkoKTtcbiAgICByZXR1cm4gdC5wdXNoKGppKHsgZXh0cmFNZXRhZGF0YTogZSB9KSksIG5ldyBCbG9iKHQsIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSk7XG4gIH1cbn07XG5jbGFzcyBLMCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQgPSBObykge1xuICAgIHRoaXMuYmFzZUNodW5rTG9nZ2VyID0gbmV3IFdoKGUsIHQpO1xuICB9XG4gIHdyaXRlKGUpIHtcbiAgICB0aGlzLmJhc2VDaHVua0xvZ2dlci5hcHBlbmRUb0xvZ3MoZSk7XG4gIH1cbiAgZ2V0TG9ncygpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlQ2h1bmtMb2dnZXIuZ2V0TG9ncygpO1xuICB9XG4gIGNsZWFyTG9ncygpIHtcbiAgICB0aGlzLmJhc2VDaHVua0xvZ2dlci5jbGVhckxvZ3MoKTtcbiAgfVxuICBnZXRMb2dBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlQ2h1bmtMb2dnZXIuZ2V0TG9nQXJyYXkoKTtcbiAgfVxuICBsb2dzVG9CbG9iKGUpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlQ2h1bmtMb2dnZXIubG9nc1RvQmxvYihlKTtcbiAgfVxuICBkb3dubG9hZExvZ3NCbG9iSW5Ccm93c2VyKGUpIHtcbiAgICBjb25zdCB0ID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLmxvZ3NUb0Jsb2IoZSkpLCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgaS5ocmVmID0gdCwgaS5kb3dubG9hZCA9IGB3YWxsZXRjb25uZWN0LWxvZ3MtJHsoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCl9LnR4dGAsIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaSksIGkuY2xpY2soKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpKSwgVVJMLnJldm9rZU9iamVjdFVSTCh0KTtcbiAgfVxufVxuY2xhc3MgSDAge1xuICBjb25zdHJ1Y3RvcihlLCB0ID0gTm8pIHtcbiAgICB0aGlzLmJhc2VDaHVua0xvZ2dlciA9IG5ldyBXaChlLCB0KTtcbiAgfVxuICB3cml0ZShlKSB7XG4gICAgdGhpcy5iYXNlQ2h1bmtMb2dnZXIuYXBwZW5kVG9Mb2dzKGUpO1xuICB9XG4gIGdldExvZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZUNodW5rTG9nZ2VyLmdldExvZ3MoKTtcbiAgfVxuICBjbGVhckxvZ3MoKSB7XG4gICAgdGhpcy5iYXNlQ2h1bmtMb2dnZXIuY2xlYXJMb2dzKCk7XG4gIH1cbiAgZ2V0TG9nQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZUNodW5rTG9nZ2VyLmdldExvZ0FycmF5KCk7XG4gIH1cbiAgbG9nc1RvQmxvYihlKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZUNodW5rTG9nZ2VyLmxvZ3NUb0Jsb2IoZSk7XG4gIH1cbn1cbnZhciBWMCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgVzAgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgRzAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycywgcWYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBKMCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIFkwID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgVWYgPSAociwgZSwgdCkgPT4gZSBpbiByID8gVjAociwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IHJbZV0gPSB0LCBMcyA9IChyLCBlKSA9PiB7XG4gIGZvciAodmFyIHQgaW4gZSB8fCAoZSA9IHt9KSlcbiAgICBKMC5jYWxsKGUsIHQpICYmIFVmKHIsIHQsIGVbdF0pO1xuICBpZiAocWYpXG4gICAgZm9yICh2YXIgdCBvZiBxZihlKSlcbiAgICAgIFkwLmNhbGwoZSwgdCkgJiYgVWYociwgdCwgZVt0XSk7XG4gIHJldHVybiByO1xufSwgRnMgPSAociwgZSkgPT4gVzAociwgRzAoZSkpO1xuZnVuY3Rpb24gVG8ocikge1xuICByZXR1cm4gRnMoTHMoe30sIHIpLCB7IGxldmVsOiByPy5sZXZlbCB8fCBrMC5sZXZlbCB9KTtcbn1cbmZ1bmN0aW9uIFgwKHIsIGUgPSB0cykge1xuICByZXR1cm4gcltlXSB8fCBcIlwiO1xufVxuZnVuY3Rpb24gWjAociwgZSwgdCA9IHRzKSB7XG4gIHJldHVybiByW3RdID0gZSwgcjtcbn1cbmZ1bmN0aW9uIFp0KHIsIGUgPSB0cykge1xuICBsZXQgdCA9IFwiXCI7XG4gIHJldHVybiB0eXBlb2Ygci5iaW5kaW5ncyA+IFwidVwiID8gdCA9IFgwKHIsIGUpIDogdCA9IHIuYmluZGluZ3MoKS5jb250ZXh0IHx8IFwiXCIsIHQ7XG59XG5mdW5jdGlvbiBRMChyLCBlLCB0ID0gdHMpIHtcbiAgY29uc3QgaSA9IFp0KHIsIHQpO1xuICByZXR1cm4gaS50cmltKCkgPyBgJHtpfS8ke2V9YCA6IGU7XG59XG5mdW5jdGlvbiBrdChyLCBlLCB0ID0gdHMpIHtcbiAgY29uc3QgaSA9IFEwKHIsIGUsIHQpLCBuID0gci5jaGlsZCh7IGNvbnRleHQ6IGkgfSk7XG4gIHJldHVybiBaMChuLCBpLCB0KTtcbn1cbmZ1bmN0aW9uIGVwKHIpIHtcbiAgdmFyIGUsIHQ7XG4gIGNvbnN0IGkgPSBuZXcgSzAoKGUgPSByLm9wdHMpID09IG51bGwgPyB2b2lkIDAgOiBlLmxldmVsLCByLm1heFNpemVJbkJ5dGVzKTtcbiAgcmV0dXJuIHsgbG9nZ2VyOiBuYShGcyhMcyh7fSwgci5vcHRzKSwgeyBsZXZlbDogXCJ0cmFjZVwiLCBicm93c2VyOiBGcyhMcyh7fSwgKHQgPSByLm9wdHMpID09IG51bGwgPyB2b2lkIDAgOiB0LmJyb3dzZXIpLCB7IHdyaXRlOiAobikgPT4gaS53cml0ZShuKSB9KSB9KSksIGNodW5rTG9nZ2VyQ29udHJvbGxlcjogaSB9O1xufVxuZnVuY3Rpb24gdHAocikge1xuICB2YXIgZTtcbiAgY29uc3QgdCA9IG5ldyBIMCgoZSA9IHIub3B0cykgPT0gbnVsbCA/IHZvaWQgMCA6IGUubGV2ZWwsIHIubWF4U2l6ZUluQnl0ZXMpO1xuICByZXR1cm4geyBsb2dnZXI6IG5hKEZzKExzKHt9LCByLm9wdHMpLCB7IGxldmVsOiBcInRyYWNlXCIgfSksIHQpLCBjaHVua0xvZ2dlckNvbnRyb2xsZXI6IHQgfTtcbn1cbmZ1bmN0aW9uIHJwKHIpIHtcbiAgcmV0dXJuIHR5cGVvZiByLmxvZ2dlck92ZXJyaWRlIDwgXCJ1XCIgJiYgdHlwZW9mIHIubG9nZ2VyT3ZlcnJpZGUgIT0gXCJzdHJpbmdcIiA/IHsgbG9nZ2VyOiByLmxvZ2dlck92ZXJyaWRlLCBjaHVua0xvZ2dlckNvbnRyb2xsZXI6IG51bGwgfSA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IGVwKHIpIDogdHAocik7XG59XG5sZXQgaXAgPSBjbGFzcyBleHRlbmRzIFdpIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIHRoaXMub3B0cyA9IGUsIHRoaXMucHJvdG9jb2wgPSBcIndjXCIsIHRoaXMudmVyc2lvbiA9IDI7XG4gIH1cbn0sIG5wID0gY2xhc3MgZXh0ZW5kcyBXaSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMucmVjb3JkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbn07XG5jbGFzcyBzcCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLmxvZ2dlciA9IGUsIHRoaXMuY29yZSA9IHQ7XG4gIH1cbn1cbmxldCBhcCA9IGNsYXNzIGV4dGVuZHMgV2kge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5yZWxheWVyID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59O1xuY2xhc3Mgb3AgZXh0ZW5kcyBXaSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpO1xuICB9XG59XG5jbGFzcyBmcCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIGksIG4pIHtcbiAgICB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMubmFtZSA9IGk7XG4gIH1cbn1cbmxldCBjcCA9IGNsYXNzIGV4dGVuZHMgV2kge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5yZWxheWVyID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59LCBocCA9IGNsYXNzIGV4dGVuZHMgV2kge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59LCB1cCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgaSkge1xuICAgIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5zdG9yZSA9IGk7XG4gIH1cbn0sIGRwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy5wcm9qZWN0SWQgPSBlLCB0aGlzLmxvZ2dlciA9IHQ7XG4gIH1cbn0sIGxwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBpKSB7XG4gICAgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLnRlbGVtZXRyeUVuYWJsZWQgPSBpO1xuICB9XG59LCBwcCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMub3B0cyA9IGUsIHRoaXMucHJvdG9jb2wgPSBcIndjXCIsIHRoaXMudmVyc2lvbiA9IDI7XG4gIH1cbn0sIHZwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5jbGllbnQgPSBlO1xuICB9XG59O1xudmFyIENvID0ge30sIEVpID0ge30sIHNhID0ge30sIGFhID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoYWEsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmFhLkJyb3dzZXJSYW5kb21Tb3VyY2UgPSB2b2lkIDA7XG5jb25zdCB6ZiA9IDY1NTM2O1xuY2xhc3MgYnAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlzQXZhaWxhYmxlID0gITEsIHRoaXMuaXNJbnN0YW50aWF0ZWQgPSAhMTtcbiAgICBjb25zdCBlID0gdHlwZW9mIHNlbGYgPCBcInVcIiA/IHNlbGYuY3J5cHRvIHx8IHNlbGYubXNDcnlwdG8gOiBudWxsO1xuICAgIGUgJiYgZS5nZXRSYW5kb21WYWx1ZXMgIT09IHZvaWQgMCAmJiAodGhpcy5fY3J5cHRvID0gZSwgdGhpcy5pc0F2YWlsYWJsZSA9ICEwLCB0aGlzLmlzSW5zdGFudGlhdGVkID0gITApO1xuICB9XG4gIHJhbmRvbUJ5dGVzKGUpIHtcbiAgICBpZiAoIXRoaXMuaXNBdmFpbGFibGUgfHwgIXRoaXMuX2NyeXB0bylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJyb3dzZXIgcmFuZG9tIGJ5dGUgZ2VuZXJhdG9yIGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgIGNvbnN0IHQgPSBuZXcgVWludDhBcnJheShlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHQubGVuZ3RoOyBpICs9IHpmKVxuICAgICAgdGhpcy5fY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh0LnN1YmFycmF5KGksIGkgKyBNYXRoLm1pbih0Lmxlbmd0aCAtIGksIHpmKSkpO1xuICAgIHJldHVybiB0O1xuICB9XG59XG5hYS5Ccm93c2VyUmFuZG9tU291cmNlID0gYnA7XG5mdW5jdGlvbiBncChyKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGR5bmFtaWNhbGx5IHJlcXVpcmUgXCInICsgciArICdcIi4gUGxlYXNlIGNvbmZpZ3VyZSB0aGUgZHluYW1pY1JlcXVpcmVUYXJnZXRzIG9yL2FuZCBpZ25vcmVEeW5hbWljUmVxdWlyZXMgb3B0aW9uIG9mIEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzIGFwcHJvcHJpYXRlbHkgZm9yIHRoaXMgcmVxdWlyZSBjYWxsIHRvIHdvcmsuJyk7XG59XG52YXIgb2EgPSB7fSwgbnIgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShuciwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuZnVuY3Rpb24geXAocikge1xuICBmb3IgKHZhciBlID0gMDsgZSA8IHIubGVuZ3RoOyBlKyspXG4gICAgcltlXSA9IDA7XG4gIHJldHVybiByO1xufVxubnIud2lwZSA9IHlwO1xuY29uc3QgbXAgPSB7fSwgd3AgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBkZWZhdWx0OiBtcFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgZmEgPSAvKiBAX19QVVJFX18gKi8gT2god3ApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KG9hLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5vYS5Ob2RlUmFuZG9tU291cmNlID0gdm9pZCAwO1xuY29uc3QgX3AgPSBucjtcbmNsYXNzIHhwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHRoaXMuaXNBdmFpbGFibGUgPSAhMSwgdGhpcy5pc0luc3RhbnRpYXRlZCA9ICExLCB0eXBlb2YgZ3AgPCBcInVcIikge1xuICAgICAgY29uc3QgZSA9IGZhO1xuICAgICAgZSAmJiBlLnJhbmRvbUJ5dGVzICYmICh0aGlzLl9jcnlwdG8gPSBlLCB0aGlzLmlzQXZhaWxhYmxlID0gITAsIHRoaXMuaXNJbnN0YW50aWF0ZWQgPSAhMCk7XG4gICAgfVxuICB9XG4gIHJhbmRvbUJ5dGVzKGUpIHtcbiAgICBpZiAoIXRoaXMuaXNBdmFpbGFibGUgfHwgIXRoaXMuX2NyeXB0bylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGUuanMgcmFuZG9tIGJ5dGUgZ2VuZXJhdG9yIGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgIGxldCB0ID0gdGhpcy5fY3J5cHRvLnJhbmRvbUJ5dGVzKGUpO1xuICAgIGlmICh0Lmxlbmd0aCAhPT0gZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGVSYW5kb21Tb3VyY2U6IGdvdCBmZXdlciBieXRlcyB0aGFuIHJlcXVlc3RlZFwiKTtcbiAgICBjb25zdCBpID0gbmV3IFVpbnQ4QXJyYXkoZSk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBpLmxlbmd0aDsgbisrKVxuICAgICAgaVtuXSA9IHRbbl07XG4gICAgcmV0dXJuICgwLCBfcC53aXBlKSh0KSwgaTtcbiAgfVxufVxub2EuTm9kZVJhbmRvbVNvdXJjZSA9IHhwO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNhLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5zYS5TeXN0ZW1SYW5kb21Tb3VyY2UgPSB2b2lkIDA7XG5jb25zdCBFcCA9IGFhLCBTcCA9IG9hO1xuY2xhc3MgTXAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5pc0F2YWlsYWJsZSA9ICExLCB0aGlzLm5hbWUgPSBcIlwiLCB0aGlzLl9zb3VyY2UgPSBuZXcgRXAuQnJvd3NlclJhbmRvbVNvdXJjZSgpLCB0aGlzLl9zb3VyY2UuaXNBdmFpbGFibGUpIHtcbiAgICAgIHRoaXMuaXNBdmFpbGFibGUgPSAhMCwgdGhpcy5uYW1lID0gXCJCcm93c2VyXCI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2UgPSBuZXcgU3AuTm9kZVJhbmRvbVNvdXJjZSgpLCB0aGlzLl9zb3VyY2UuaXNBdmFpbGFibGUpIHtcbiAgICAgIHRoaXMuaXNBdmFpbGFibGUgPSAhMCwgdGhpcy5uYW1lID0gXCJOb2RlXCI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJhbmRvbUJ5dGVzKGUpIHtcbiAgICBpZiAoIXRoaXMuaXNBdmFpbGFibGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeXN0ZW0gcmFuZG9tIGJ5dGUgZ2VuZXJhdG9yIGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2UucmFuZG9tQnl0ZXMoZSk7XG4gIH1cbn1cbnNhLlN5c3RlbVJhbmRvbVNvdXJjZSA9IE1wO1xudmFyIFZlID0ge30sIEdoID0ge307XG4oZnVuY3Rpb24ocikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICBmdW5jdGlvbiBlKGYsIGgpIHtcbiAgICB2YXIgZCA9IGYgPj4+IDE2ICYgNjU1MzUsIHYgPSBmICYgNjU1MzUsIHcgPSBoID4+PiAxNiAmIDY1NTM1LCBBID0gaCAmIDY1NTM1O1xuICAgIHJldHVybiB2ICogQSArIChkICogQSArIHYgKiB3IDw8IDE2ID4+PiAwKSB8IDA7XG4gIH1cbiAgci5tdWwgPSBNYXRoLmltdWwgfHwgZTtcbiAgZnVuY3Rpb24gdChmLCBoKSB7XG4gICAgcmV0dXJuIGYgKyBoIHwgMDtcbiAgfVxuICByLmFkZCA9IHQ7XG4gIGZ1bmN0aW9uIGkoZiwgaCkge1xuICAgIHJldHVybiBmIC0gaCB8IDA7XG4gIH1cbiAgci5zdWIgPSBpO1xuICBmdW5jdGlvbiBuKGYsIGgpIHtcbiAgICByZXR1cm4gZiA8PCBoIHwgZiA+Pj4gMzIgLSBoO1xuICB9XG4gIHIucm90bCA9IG47XG4gIGZ1bmN0aW9uIHMoZiwgaCkge1xuICAgIHJldHVybiBmIDw8IDMyIC0gaCB8IGYgPj4+IGg7XG4gIH1cbiAgci5yb3RyID0gcztcbiAgZnVuY3Rpb24gbyhmKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBmID09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUoZikgJiYgTWF0aC5mbG9vcihmKSA9PT0gZjtcbiAgfVxuICByLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgbywgci5NQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MSwgci5pc1NhZmVJbnRlZ2VyID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiByLmlzSW50ZWdlcihmKSAmJiBmID49IC1yLk1BWF9TQUZFX0lOVEVHRVIgJiYgZiA8PSByLk1BWF9TQUZFX0lOVEVHRVI7XG4gIH07XG59KShHaCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnZhciBKaCA9IEdoO1xuZnVuY3Rpb24gSXAociwgZSkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gMCksIChyW2UgKyAwXSA8PCA4IHwgcltlICsgMV0pIDw8IDE2ID4+IDE2O1xufVxuVmUucmVhZEludDE2QkUgPSBJcDtcbmZ1bmN0aW9uIEFwKHIsIGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApLCAocltlICsgMF0gPDwgOCB8IHJbZSArIDFdKSA+Pj4gMDtcbn1cblZlLnJlYWRVaW50MTZCRSA9IEFwO1xuZnVuY3Rpb24gRHAociwgZSkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gMCksIChyW2UgKyAxXSA8PCA4IHwgcltlXSkgPDwgMTYgPj4gMTY7XG59XG5WZS5yZWFkSW50MTZMRSA9IERwO1xuZnVuY3Rpb24gUHAociwgZSkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gMCksIChyW2UgKyAxXSA8PCA4IHwgcltlXSkgPj4+IDA7XG59XG5WZS5yZWFkVWludDE2TEUgPSBQcDtcbmZ1bmN0aW9uIFloKHIsIGUsIHQpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBVaW50OEFycmF5KDIpKSwgdCA9PT0gdm9pZCAwICYmICh0ID0gMCksIGVbdCArIDBdID0gciA+Pj4gOCwgZVt0ICsgMV0gPSByID4+PiAwLCBlO1xufVxuVmUud3JpdGVVaW50MTZCRSA9IFloO1xuVmUud3JpdGVJbnQxNkJFID0gWWg7XG5mdW5jdGlvbiBYaChyLCBlLCB0KSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgVWludDhBcnJheSgyKSksIHQgPT09IHZvaWQgMCAmJiAodCA9IDApLCBlW3QgKyAwXSA9IHIgPj4+IDAsIGVbdCArIDFdID0gciA+Pj4gOCwgZTtcbn1cblZlLndyaXRlVWludDE2TEUgPSBYaDtcblZlLndyaXRlSW50MTZMRSA9IFhoO1xuZnVuY3Rpb24gdW8ociwgZSkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gMCksIHJbZV0gPDwgMjQgfCByW2UgKyAxXSA8PCAxNiB8IHJbZSArIDJdIDw8IDggfCByW2UgKyAzXTtcbn1cblZlLnJlYWRJbnQzMkJFID0gdW87XG5mdW5jdGlvbiBsbyhyLCBlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwgKHJbZV0gPDwgMjQgfCByW2UgKyAxXSA8PCAxNiB8IHJbZSArIDJdIDw8IDggfCByW2UgKyAzXSkgPj4+IDA7XG59XG5WZS5yZWFkVWludDMyQkUgPSBsbztcbmZ1bmN0aW9uIHBvKHIsIGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApLCByW2UgKyAzXSA8PCAyNCB8IHJbZSArIDJdIDw8IDE2IHwgcltlICsgMV0gPDwgOCB8IHJbZV07XG59XG5WZS5yZWFkSW50MzJMRSA9IHBvO1xuZnVuY3Rpb24gdm8ociwgZSkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gMCksIChyW2UgKyAzXSA8PCAyNCB8IHJbZSArIDJdIDw8IDE2IHwgcltlICsgMV0gPDwgOCB8IHJbZV0pID4+PiAwO1xufVxuVmUucmVhZFVpbnQzMkxFID0gdm87XG5mdW5jdGlvbiBxcyhyLCBlLCB0KSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgVWludDhBcnJheSg0KSksIHQgPT09IHZvaWQgMCAmJiAodCA9IDApLCBlW3QgKyAwXSA9IHIgPj4+IDI0LCBlW3QgKyAxXSA9IHIgPj4+IDE2LCBlW3QgKyAyXSA9IHIgPj4+IDgsIGVbdCArIDNdID0gciA+Pj4gMCwgZTtcbn1cblZlLndyaXRlVWludDMyQkUgPSBxcztcblZlLndyaXRlSW50MzJCRSA9IHFzO1xuZnVuY3Rpb24gVXMociwgZSwgdCkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gbmV3IFVpbnQ4QXJyYXkoNCkpLCB0ID09PSB2b2lkIDAgJiYgKHQgPSAwKSwgZVt0ICsgMF0gPSByID4+PiAwLCBlW3QgKyAxXSA9IHIgPj4+IDgsIGVbdCArIDJdID0gciA+Pj4gMTYsIGVbdCArIDNdID0gciA+Pj4gMjQsIGU7XG59XG5WZS53cml0ZVVpbnQzMkxFID0gVXM7XG5WZS53cml0ZUludDMyTEUgPSBVcztcbmZ1bmN0aW9uIE9wKHIsIGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gMCk7XG4gIHZhciB0ID0gdW8ociwgZSksIGkgPSB1byhyLCBlICsgNCk7XG4gIHJldHVybiB0ICogNDI5NDk2NzI5NiArIGkgLSAoaSA+PiAzMSkgKiA0Mjk0OTY3Mjk2O1xufVxuVmUucmVhZEludDY0QkUgPSBPcDtcbmZ1bmN0aW9uIFJwKHIsIGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gMCk7XG4gIHZhciB0ID0gbG8ociwgZSksIGkgPSBsbyhyLCBlICsgNCk7XG4gIHJldHVybiB0ICogNDI5NDk2NzI5NiArIGk7XG59XG5WZS5yZWFkVWludDY0QkUgPSBScDtcbmZ1bmN0aW9uIE5wKHIsIGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gMCk7XG4gIHZhciB0ID0gcG8ociwgZSksIGkgPSBwbyhyLCBlICsgNCk7XG4gIHJldHVybiBpICogNDI5NDk2NzI5NiArIHQgLSAodCA+PiAzMSkgKiA0Mjk0OTY3Mjk2O1xufVxuVmUucmVhZEludDY0TEUgPSBOcDtcbmZ1bmN0aW9uIFRwKHIsIGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gMCk7XG4gIHZhciB0ID0gdm8ociwgZSksIGkgPSB2byhyLCBlICsgNCk7XG4gIHJldHVybiBpICogNDI5NDk2NzI5NiArIHQ7XG59XG5WZS5yZWFkVWludDY0TEUgPSBUcDtcbmZ1bmN0aW9uIFpoKHIsIGUsIHQpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBVaW50OEFycmF5KDgpKSwgdCA9PT0gdm9pZCAwICYmICh0ID0gMCksIHFzKHIgLyA0Mjk0OTY3Mjk2ID4+PiAwLCBlLCB0KSwgcXMociA+Pj4gMCwgZSwgdCArIDQpLCBlO1xufVxuVmUud3JpdGVVaW50NjRCRSA9IFpoO1xuVmUud3JpdGVJbnQ2NEJFID0gWmg7XG5mdW5jdGlvbiBRaChyLCBlLCB0KSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgVWludDhBcnJheSg4KSksIHQgPT09IHZvaWQgMCAmJiAodCA9IDApLCBVcyhyID4+PiAwLCBlLCB0KSwgVXMociAvIDQyOTQ5NjcyOTYgPj4+IDAsIGUsIHQgKyA0KSwgZTtcbn1cblZlLndyaXRlVWludDY0TEUgPSBRaDtcblZlLndyaXRlSW50NjRMRSA9IFFoO1xuZnVuY3Rpb24gQ3AociwgZSwgdCkge1xuICBpZiAodCA9PT0gdm9pZCAwICYmICh0ID0gMCksIHIgJSA4ICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcInJlYWRVaW50QkUgc3VwcG9ydHMgb25seSBiaXRMZW5ndGhzIGRpdmlzaWJsZSBieSA4XCIpO1xuICBpZiAociAvIDggPiBlLmxlbmd0aCAtIHQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVhZFVpbnRCRTogYXJyYXkgaXMgdG9vIHNob3J0IGZvciB0aGUgZ2l2ZW4gYml0TGVuZ3RoXCIpO1xuICBmb3IgKHZhciBpID0gMCwgbiA9IDEsIHMgPSByIC8gOCArIHQgLSAxOyBzID49IHQ7IHMtLSlcbiAgICBpICs9IGVbc10gKiBuLCBuICo9IDI1NjtcbiAgcmV0dXJuIGk7XG59XG5WZS5yZWFkVWludEJFID0gQ3A7XG5mdW5jdGlvbiAkcChyLCBlLCB0KSB7XG4gIGlmICh0ID09PSB2b2lkIDAgJiYgKHQgPSAwKSwgciAlIDggIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVhZFVpbnRMRSBzdXBwb3J0cyBvbmx5IGJpdExlbmd0aHMgZGl2aXNpYmxlIGJ5IDhcIik7XG4gIGlmIChyIC8gOCA+IGUubGVuZ3RoIC0gdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWFkVWludExFOiBhcnJheSBpcyB0b28gc2hvcnQgZm9yIHRoZSBnaXZlbiBiaXRMZW5ndGhcIik7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gMSwgcyA9IHQ7IHMgPCB0ICsgciAvIDg7IHMrKylcbiAgICBpICs9IGVbc10gKiBuLCBuICo9IDI1NjtcbiAgcmV0dXJuIGk7XG59XG5WZS5yZWFkVWludExFID0gJHA7XG5mdW5jdGlvbiBMcChyLCBlLCB0LCBpKSB7XG4gIGlmICh0ID09PSB2b2lkIDAgJiYgKHQgPSBuZXcgVWludDhBcnJheShyIC8gOCkpLCBpID09PSB2b2lkIDAgJiYgKGkgPSAwKSwgciAlIDggIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwid3JpdGVVaW50QkUgc3VwcG9ydHMgb25seSBiaXRMZW5ndGhzIGRpdmlzaWJsZSBieSA4XCIpO1xuICBpZiAoIUpoLmlzU2FmZUludGVnZXIoZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwid3JpdGVVaW50QkUgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICBmb3IgKHZhciBuID0gMSwgcyA9IHIgLyA4ICsgaSAtIDE7IHMgPj0gaTsgcy0tKVxuICAgIHRbc10gPSBlIC8gbiAmIDI1NSwgbiAqPSAyNTY7XG4gIHJldHVybiB0O1xufVxuVmUud3JpdGVVaW50QkUgPSBMcDtcbmZ1bmN0aW9uIEZwKHIsIGUsIHQsIGkpIHtcbiAgaWYgKHQgPT09IHZvaWQgMCAmJiAodCA9IG5ldyBVaW50OEFycmF5KHIgLyA4KSksIGkgPT09IHZvaWQgMCAmJiAoaSA9IDApLCByICUgOCAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cml0ZVVpbnRMRSBzdXBwb3J0cyBvbmx5IGJpdExlbmd0aHMgZGl2aXNpYmxlIGJ5IDhcIik7XG4gIGlmICghSmguaXNTYWZlSW50ZWdlcihlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cml0ZVVpbnRMRSB2YWx1ZSBtdXN0IGJlIGFuIGludGVnZXJcIik7XG4gIGZvciAodmFyIG4gPSAxLCBzID0gaTsgcyA8IGkgKyByIC8gODsgcysrKVxuICAgIHRbc10gPSBlIC8gbiAmIDI1NSwgbiAqPSAyNTY7XG4gIHJldHVybiB0O1xufVxuVmUud3JpdGVVaW50TEUgPSBGcDtcbmZ1bmN0aW9uIHFwKHIsIGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gMCk7XG4gIHZhciB0ID0gbmV3IERhdGFWaWV3KHIuYnVmZmVyLCByLmJ5dGVPZmZzZXQsIHIuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB0LmdldEZsb2F0MzIoZSk7XG59XG5WZS5yZWFkRmxvYXQzMkJFID0gcXA7XG5mdW5jdGlvbiBVcChyLCBlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApO1xuICB2YXIgdCA9IG5ldyBEYXRhVmlldyhyLmJ1ZmZlciwgci5ieXRlT2Zmc2V0LCByLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gdC5nZXRGbG9hdDMyKGUsICEwKTtcbn1cblZlLnJlYWRGbG9hdDMyTEUgPSBVcDtcbmZ1bmN0aW9uIHpwKHIsIGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gMCk7XG4gIHZhciB0ID0gbmV3IERhdGFWaWV3KHIuYnVmZmVyLCByLmJ5dGVPZmZzZXQsIHIuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB0LmdldEZsb2F0NjQoZSk7XG59XG5WZS5yZWFkRmxvYXQ2NEJFID0genA7XG5mdW5jdGlvbiBCcChyLCBlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApO1xuICB2YXIgdCA9IG5ldyBEYXRhVmlldyhyLmJ1ZmZlciwgci5ieXRlT2Zmc2V0LCByLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gdC5nZXRGbG9hdDY0KGUsICEwKTtcbn1cblZlLnJlYWRGbG9hdDY0TEUgPSBCcDtcbmZ1bmN0aW9uIGtwKHIsIGUsIHQpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gbmV3IFVpbnQ4QXJyYXkoNCkpLCB0ID09PSB2b2lkIDAgJiYgKHQgPSAwKTtcbiAgdmFyIGkgPSBuZXcgRGF0YVZpZXcoZS5idWZmZXIsIGUuYnl0ZU9mZnNldCwgZS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIGkuc2V0RmxvYXQzMih0LCByKSwgZTtcbn1cblZlLndyaXRlRmxvYXQzMkJFID0ga3A7XG5mdW5jdGlvbiBqcChyLCBlLCB0KSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBVaW50OEFycmF5KDQpKSwgdCA9PT0gdm9pZCAwICYmICh0ID0gMCk7XG4gIHZhciBpID0gbmV3IERhdGFWaWV3KGUuYnVmZmVyLCBlLmJ5dGVPZmZzZXQsIGUuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiBpLnNldEZsb2F0MzIodCwgciwgITApLCBlO1xufVxuVmUud3JpdGVGbG9hdDMyTEUgPSBqcDtcbmZ1bmN0aW9uIEtwKHIsIGUsIHQpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gbmV3IFVpbnQ4QXJyYXkoOCkpLCB0ID09PSB2b2lkIDAgJiYgKHQgPSAwKTtcbiAgdmFyIGkgPSBuZXcgRGF0YVZpZXcoZS5idWZmZXIsIGUuYnl0ZU9mZnNldCwgZS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIGkuc2V0RmxvYXQ2NCh0LCByKSwgZTtcbn1cblZlLndyaXRlRmxvYXQ2NEJFID0gS3A7XG5mdW5jdGlvbiBIcChyLCBlLCB0KSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBVaW50OEFycmF5KDgpKSwgdCA9PT0gdm9pZCAwICYmICh0ID0gMCk7XG4gIHZhciBpID0gbmV3IERhdGFWaWV3KGUuYnVmZmVyLCBlLmJ5dGVPZmZzZXQsIGUuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiBpLnNldEZsb2F0NjQodCwgciwgITApLCBlO1xufVxuVmUud3JpdGVGbG9hdDY0TEUgPSBIcDtcbihmdW5jdGlvbihyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHIucmFuZG9tU3RyaW5nRm9yRW50cm9weSA9IHIucmFuZG9tU3RyaW5nID0gci5yYW5kb21VaW50MzIgPSByLnJhbmRvbUJ5dGVzID0gci5kZWZhdWx0UmFuZG9tU291cmNlID0gdm9pZCAwO1xuICBjb25zdCBlID0gc2EsIHQgPSBWZSwgaSA9IG5yO1xuICByLmRlZmF1bHRSYW5kb21Tb3VyY2UgPSBuZXcgZS5TeXN0ZW1SYW5kb21Tb3VyY2UoKTtcbiAgZnVuY3Rpb24gbihkLCB2ID0gci5kZWZhdWx0UmFuZG9tU291cmNlKSB7XG4gICAgcmV0dXJuIHYucmFuZG9tQnl0ZXMoZCk7XG4gIH1cbiAgci5yYW5kb21CeXRlcyA9IG47XG4gIGZ1bmN0aW9uIHMoZCA9IHIuZGVmYXVsdFJhbmRvbVNvdXJjZSkge1xuICAgIGNvbnN0IHYgPSBuKDQsIGQpLCB3ID0gKDAsIHQucmVhZFVpbnQzMkxFKSh2KTtcbiAgICByZXR1cm4gKDAsIGkud2lwZSkodiksIHc7XG4gIH1cbiAgci5yYW5kb21VaW50MzIgPSBzO1xuICBjb25zdCBvID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuICBmdW5jdGlvbiBmKGQsIHYgPSBvLCB3ID0gci5kZWZhdWx0UmFuZG9tU291cmNlKSB7XG4gICAgaWYgKHYubGVuZ3RoIDwgMilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJhbmRvbVN0cmluZyBjaGFyc2V0IGlzIHRvbyBzaG9ydFwiKTtcbiAgICBpZiAodi5sZW5ndGggPiAyNTYpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5kb21TdHJpbmcgY2hhcnNldCBpcyB0b28gbG9uZ1wiKTtcbiAgICBsZXQgQSA9IFwiXCI7XG4gICAgY29uc3QgSSA9IHYubGVuZ3RoLCBEID0gMjU2IC0gMjU2ICUgSTtcbiAgICBmb3IgKDsgZCA+IDA7ICkge1xuICAgICAgY29uc3QgTiA9IG4oTWF0aC5jZWlsKGQgKiAyNTYgLyBEKSwgdyk7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IE4ubGVuZ3RoICYmIGQgPiAwOyBrKyspIHtcbiAgICAgICAgY29uc3QgaiA9IE5ba107XG4gICAgICAgIGogPCBEICYmIChBICs9IHYuY2hhckF0KGogJSBJKSwgZC0tKTtcbiAgICAgIH1cbiAgICAgICgwLCBpLndpcGUpKE4pO1xuICAgIH1cbiAgICByZXR1cm4gQTtcbiAgfVxuICByLnJhbmRvbVN0cmluZyA9IGY7XG4gIGZ1bmN0aW9uIGgoZCwgdiA9IG8sIHcgPSByLmRlZmF1bHRSYW5kb21Tb3VyY2UpIHtcbiAgICBjb25zdCBBID0gTWF0aC5jZWlsKGQgLyAoTWF0aC5sb2codi5sZW5ndGgpIC8gTWF0aC5MTjIpKTtcbiAgICByZXR1cm4gZihBLCB2LCB3KTtcbiAgfVxuICByLnJhbmRvbVN0cmluZ0ZvckVudHJvcHkgPSBoO1xufSkoRWkpO1xudmFyIGV1ID0ge307XG4oZnVuY3Rpb24ocikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICB2YXIgZSA9IFZlLCB0ID0gbnI7XG4gIHIuRElHRVNUX0xFTkdUSCA9IDY0LCByLkJMT0NLX1NJWkUgPSAxMjg7XG4gIHZhciBpID0gKFxuICAgIC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICAgIHRoaXMuZGlnZXN0TGVuZ3RoID0gci5ESUdFU1RfTEVOR1RILCB0aGlzLmJsb2NrU2l6ZSA9IHIuQkxPQ0tfU0laRSwgdGhpcy5fc3RhdGVIaSA9IG5ldyBJbnQzMkFycmF5KDgpLCB0aGlzLl9zdGF0ZUxvID0gbmV3IEludDMyQXJyYXkoOCksIHRoaXMuX3RlbXBIaSA9IG5ldyBJbnQzMkFycmF5KDE2KSwgdGhpcy5fdGVtcExvID0gbmV3IEludDMyQXJyYXkoMTYpLCB0aGlzLl9idWZmZXIgPSBuZXcgVWludDhBcnJheSgyNTYpLCB0aGlzLl9idWZmZXJMZW5ndGggPSAwLCB0aGlzLl9ieXRlc0hhc2hlZCA9IDAsIHRoaXMuX2ZpbmlzaGVkID0gITEsIHRoaXMucmVzZXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmLnByb3RvdHlwZS5faW5pdFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlSGlbMF0gPSAxNzc5MDMzNzAzLCB0aGlzLl9zdGF0ZUhpWzFdID0gMzE0NDEzNDI3NywgdGhpcy5fc3RhdGVIaVsyXSA9IDEwMTM5MDQyNDIsIHRoaXMuX3N0YXRlSGlbM10gPSAyNzczNDgwNzYyLCB0aGlzLl9zdGF0ZUhpWzRdID0gMTM1OTg5MzExOSwgdGhpcy5fc3RhdGVIaVs1XSA9IDI2MDA4MjI5MjQsIHRoaXMuX3N0YXRlSGlbNl0gPSA1Mjg3MzQ2MzUsIHRoaXMuX3N0YXRlSGlbN10gPSAxNTQxNDU5MjI1LCB0aGlzLl9zdGF0ZUxvWzBdID0gNDA4OTIzNTcyMCwgdGhpcy5fc3RhdGVMb1sxXSA9IDIyMjc4NzM1OTUsIHRoaXMuX3N0YXRlTG9bMl0gPSA0MjcxMTc1NzIzLCB0aGlzLl9zdGF0ZUxvWzNdID0gMTU5NTc1MDEyOSwgdGhpcy5fc3RhdGVMb1s0XSA9IDI5MTc1NjUxMzcsIHRoaXMuX3N0YXRlTG9bNV0gPSA3MjU1MTExOTksIHRoaXMuX3N0YXRlTG9bNl0gPSA0MjE1Mzg5NTQ3LCB0aGlzLl9zdGF0ZUxvWzddID0gMzI3MDMzMjA5O1xuICAgICAgfSwgZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRTdGF0ZSgpLCB0aGlzLl9idWZmZXJMZW5ndGggPSAwLCB0aGlzLl9ieXRlc0hhc2hlZCA9IDAsIHRoaXMuX2ZpbmlzaGVkID0gITEsIHRoaXM7XG4gICAgICB9LCBmLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0LndpcGUodGhpcy5fYnVmZmVyKSwgdC53aXBlKHRoaXMuX3RlbXBIaSksIHQud2lwZSh0aGlzLl90ZW1wTG8pLCB0aGlzLnJlc2V0KCk7XG4gICAgICB9LCBmLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihoLCBkKSB7XG4gICAgICAgIGlmIChkID09PSB2b2lkIDAgJiYgKGQgPSBoLmxlbmd0aCksIHRoaXMuX2ZpbmlzaGVkKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNIQTUxMjogY2FuJ3QgdXBkYXRlIGJlY2F1c2UgaGFzaCB3YXMgZmluaXNoZWQuXCIpO1xuICAgICAgICB2YXIgdiA9IDA7XG4gICAgICAgIGlmICh0aGlzLl9ieXRlc0hhc2hlZCArPSBkLCB0aGlzLl9idWZmZXJMZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yICg7IHRoaXMuX2J1ZmZlckxlbmd0aCA8IHIuQkxPQ0tfU0laRSAmJiBkID4gMDsgKVxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyW3RoaXMuX2J1ZmZlckxlbmd0aCsrXSA9IGhbdisrXSwgZC0tO1xuICAgICAgICAgIHRoaXMuX2J1ZmZlckxlbmd0aCA9PT0gdGhpcy5ibG9ja1NpemUgJiYgKHModGhpcy5fdGVtcEhpLCB0aGlzLl90ZW1wTG8sIHRoaXMuX3N0YXRlSGksIHRoaXMuX3N0YXRlTG8sIHRoaXMuX2J1ZmZlciwgMCwgdGhpcy5ibG9ja1NpemUpLCB0aGlzLl9idWZmZXJMZW5ndGggPSAwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGQgPj0gdGhpcy5ibG9ja1NpemUgJiYgKHYgPSBzKHRoaXMuX3RlbXBIaSwgdGhpcy5fdGVtcExvLCB0aGlzLl9zdGF0ZUhpLCB0aGlzLl9zdGF0ZUxvLCBoLCB2LCBkKSwgZCAlPSB0aGlzLmJsb2NrU2l6ZSk7IGQgPiAwOyApXG4gICAgICAgICAgdGhpcy5fYnVmZmVyW3RoaXMuX2J1ZmZlckxlbmd0aCsrXSA9IGhbdisrXSwgZC0tO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIGYucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgIHZhciBkID0gdGhpcy5fYnl0ZXNIYXNoZWQsIHYgPSB0aGlzLl9idWZmZXJMZW5ndGgsIHcgPSBkIC8gNTM2ODcwOTEyIHwgMCwgQSA9IGQgPDwgMywgSSA9IGQgJSAxMjggPCAxMTIgPyAxMjggOiAyNTY7XG4gICAgICAgICAgdGhpcy5fYnVmZmVyW3ZdID0gMTI4O1xuICAgICAgICAgIGZvciAodmFyIEQgPSB2ICsgMTsgRCA8IEkgLSA4OyBEKyspXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJbRF0gPSAwO1xuICAgICAgICAgIGUud3JpdGVVaW50MzJCRSh3LCB0aGlzLl9idWZmZXIsIEkgLSA4KSwgZS53cml0ZVVpbnQzMkJFKEEsIHRoaXMuX2J1ZmZlciwgSSAtIDQpLCBzKHRoaXMuX3RlbXBIaSwgdGhpcy5fdGVtcExvLCB0aGlzLl9zdGF0ZUhpLCB0aGlzLl9zdGF0ZUxvLCB0aGlzLl9idWZmZXIsIDAsIEkpLCB0aGlzLl9maW5pc2hlZCA9ICEwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIEQgPSAwOyBEIDwgdGhpcy5kaWdlc3RMZW5ndGggLyA4OyBEKyspXG4gICAgICAgICAgZS53cml0ZVVpbnQzMkJFKHRoaXMuX3N0YXRlSGlbRF0sIGgsIEQgKiA4KSwgZS53cml0ZVVpbnQzMkJFKHRoaXMuX3N0YXRlTG9bRF0sIGgsIEQgKiA4ICsgNCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgZi5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kaWdlc3RMZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goaCksIGg7XG4gICAgICB9LCBmLnByb3RvdHlwZS5zYXZlU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpbmlzaGVkKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNIQTI1NjogY2Fubm90IHNhdmUgZmluaXNoZWQgc3RhdGVcIik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdGVIaTogbmV3IEludDMyQXJyYXkodGhpcy5fc3RhdGVIaSksXG4gICAgICAgICAgc3RhdGVMbzogbmV3IEludDMyQXJyYXkodGhpcy5fc3RhdGVMbyksXG4gICAgICAgICAgYnVmZmVyOiB0aGlzLl9idWZmZXJMZW5ndGggPiAwID8gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmZmVyKSA6IHZvaWQgMCxcbiAgICAgICAgICBidWZmZXJMZW5ndGg6IHRoaXMuX2J1ZmZlckxlbmd0aCxcbiAgICAgICAgICBieXRlc0hhc2hlZDogdGhpcy5fYnl0ZXNIYXNoZWRcbiAgICAgICAgfTtcbiAgICAgIH0sIGYucHJvdG90eXBlLnJlc3RvcmVTdGF0ZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlSGkuc2V0KGguc3RhdGVIaSksIHRoaXMuX3N0YXRlTG8uc2V0KGguc3RhdGVMbyksIHRoaXMuX2J1ZmZlckxlbmd0aCA9IGguYnVmZmVyTGVuZ3RoLCBoLmJ1ZmZlciAmJiB0aGlzLl9idWZmZXIuc2V0KGguYnVmZmVyKSwgdGhpcy5fYnl0ZXNIYXNoZWQgPSBoLmJ5dGVzSGFzaGVkLCB0aGlzLl9maW5pc2hlZCA9ICExLCB0aGlzO1xuICAgICAgfSwgZi5wcm90b3R5cGUuY2xlYW5TYXZlZFN0YXRlID0gZnVuY3Rpb24oaCkge1xuICAgICAgICB0LndpcGUoaC5zdGF0ZUhpKSwgdC53aXBlKGguc3RhdGVMbyksIGguYnVmZmVyICYmIHQud2lwZShoLmJ1ZmZlciksIGguYnVmZmVyTGVuZ3RoID0gMCwgaC5ieXRlc0hhc2hlZCA9IDA7XG4gICAgICB9LCBmO1xuICAgIH0oKVxuICApO1xuICByLlNIQTUxMiA9IGk7XG4gIHZhciBuID0gbmV3IEludDMyQXJyYXkoW1xuICAgIDExMTYzNTI0MDgsXG4gICAgMzYwOTc2NzQ1OCxcbiAgICAxODk5NDQ3NDQxLFxuICAgIDYwMjg5MTcyNSxcbiAgICAzMDQ5MzIzNDcxLFxuICAgIDM5NjQ0ODQzOTksXG4gICAgMzkyMTAwOTU3MyxcbiAgICAyMTczMjk1NTQ4LFxuICAgIDk2MTk4NzE2MyxcbiAgICA0MDgxNjI4NDcyLFxuICAgIDE1MDg5NzA5OTMsXG4gICAgMzA1MzgzNDI2NSxcbiAgICAyNDUzNjM1NzQ4LFxuICAgIDI5Mzc2NzE1NzksXG4gICAgMjg3MDc2MzIyMSxcbiAgICAzNjY0NjA5NTYwLFxuICAgIDM2MjQzODEwODAsXG4gICAgMjczNDg4MzM5NCxcbiAgICAzMTA1OTg0MDEsXG4gICAgMTE2NDk5NjU0MixcbiAgICA2MDcyMjUyNzgsXG4gICAgMTMyMzYxMDc2NCxcbiAgICAxNDI2ODgxOTg3LFxuICAgIDM1OTAzMDQ5OTQsXG4gICAgMTkyNTA3ODM4OCxcbiAgICA0MDY4MTgyMzgzLFxuICAgIDIxNjIwNzgyMDYsXG4gICAgOTkxMzM2MTEzLFxuICAgIDI2MTQ4ODgxMDMsXG4gICAgNjMzODAzMzE3LFxuICAgIDMyNDgyMjI1ODAsXG4gICAgMzQ3OTc3NDg2OCxcbiAgICAzODM1MzkwNDAxLFxuICAgIDI2NjY2MTM0NTgsXG4gICAgNDAyMjIyNDc3NCxcbiAgICA5NDQ3MTExMzksXG4gICAgMjY0MzQ3MDc4LFxuICAgIDIzNDEyNjI3NzMsXG4gICAgNjA0ODA3NjI4LFxuICAgIDIwMDc4MDA5MzMsXG4gICAgNzcwMjU1OTgzLFxuICAgIDE0OTU5OTA5MDEsXG4gICAgMTI0OTE1MDEyMixcbiAgICAxODU2NDMxMjM1LFxuICAgIDE1NTUwODE2OTIsXG4gICAgMzE3NTIxODEzMixcbiAgICAxOTk2MDY0OTg2LFxuICAgIDIxOTg5NTA4MzcsXG4gICAgMjU1NDIyMDg4MixcbiAgICAzOTk5NzE5MzM5LFxuICAgIDI4MjE4MzQzNDksXG4gICAgNzY2Nzg0MDE2LFxuICAgIDI5NTI5OTY4MDgsXG4gICAgMjU2NjU5NDg3OSxcbiAgICAzMjEwMzEzNjcxLFxuICAgIDMyMDMzMzc5NTYsXG4gICAgMzMzNjU3MTg5MSxcbiAgICAxMDM0NDU3MDI2LFxuICAgIDM1ODQ1Mjg3MTEsXG4gICAgMjQ2Njk0ODkwMSxcbiAgICAxMTM5MjY5OTMsXG4gICAgMzc1ODMyNjM4MyxcbiAgICAzMzgyNDE4OTUsXG4gICAgMTY4NzE3OTM2LFxuICAgIDY2NjMwNzIwNSxcbiAgICAxMTg4MTc5OTY0LFxuICAgIDc3MzUyOTkxMixcbiAgICAxNTQ2MDQ1NzM0LFxuICAgIDEyOTQ3NTczNzIsXG4gICAgMTUyMjgwNTQ4NSxcbiAgICAxMzk2MTgyMjkxLFxuICAgIDI2NDM4MzM4MjMsXG4gICAgMTY5NTE4MzcwMCxcbiAgICAyMzQzNTI3MzkwLFxuICAgIDE5ODY2NjEwNTEsXG4gICAgMTAxNDQ3NzQ4MCxcbiAgICAyMTc3MDI2MzUwLFxuICAgIDEyMDY3NTkxNDIsXG4gICAgMjQ1Njk1NjAzNyxcbiAgICAzNDQwNzc2MjcsXG4gICAgMjczMDQ4NTkyMSxcbiAgICAxMjkwODYzNDYwLFxuICAgIDI4MjAzMDI0MTEsXG4gICAgMzE1ODQ1NDI3MyxcbiAgICAzMjU5NzMwODAwLFxuICAgIDM1MDU5NTI2NTcsXG4gICAgMzM0NTc2NDc3MSxcbiAgICAxMDYyMTcwMDgsXG4gICAgMzUxNjA2NTgxNyxcbiAgICAzNjA2MDA4MzQ0LFxuICAgIDM2MDAzNTI4MDQsXG4gICAgMTQzMjcyNTc3NixcbiAgICA0MDk0NTcxOTA5LFxuICAgIDE0NjcwMzE1OTQsXG4gICAgMjc1NDIzMzQ0LFxuICAgIDg1MTE2OTcyMCxcbiAgICA0MzAyMjc3MzQsXG4gICAgMzEwMDgyMzc1MixcbiAgICA1MDY5NDg2MTYsXG4gICAgMTM2MzI1ODE5NSxcbiAgICA2NTkwNjA1NTYsXG4gICAgMzc1MDY4NTU5MyxcbiAgICA4ODM5OTc4NzcsXG4gICAgMzc4NTA1MDI4MCxcbiAgICA5NTgxMzk1NzEsXG4gICAgMzMxODMwNzQyNyxcbiAgICAxMzIyODIyMjE4LFxuICAgIDM4MTI3MjM0MDMsXG4gICAgMTUzNzAwMjA2MyxcbiAgICAyMDAzMDM0OTk1LFxuICAgIDE3NDc4NzM3NzksXG4gICAgMzYwMjAzNjg5OSxcbiAgICAxOTU1NTYyMjIyLFxuICAgIDE1NzU5OTAwMTIsXG4gICAgMjAyNDEwNDgxNSxcbiAgICAxMTI1NTkyOTI4LFxuICAgIDIyMjc3MzA0NTIsXG4gICAgMjcxNjkwNDMwNixcbiAgICAyMzYxODUyNDI0LFxuICAgIDQ0Mjc3NjA0NCxcbiAgICAyNDI4NDM2NDc0LFxuICAgIDU5MzY5ODM0NCxcbiAgICAyNzU2NzM0MTg3LFxuICAgIDM3MzMxMTAyNDksXG4gICAgMzIwNDAzMTQ3OSxcbiAgICAyOTk5MzUxNTczLFxuICAgIDMzMjkzMjUyOTgsXG4gICAgMzgxNTkyMDQyNyxcbiAgICAzMzkxNTY5NjE0LFxuICAgIDM5MjgzODM5MDAsXG4gICAgMzUxNTI2NzI3MSxcbiAgICA1NjYyODA3MTEsXG4gICAgMzk0MDE4NzYwNixcbiAgICAzNDU0MDY5NTM0LFxuICAgIDQxMTg2MzAyNzEsXG4gICAgNDAwMDIzOTk5MixcbiAgICAxMTY0MTg0NzQsXG4gICAgMTkxNDEzODU1NCxcbiAgICAxNzQyOTI0MjEsXG4gICAgMjczMTA1NTI3MCxcbiAgICAyODkzODAzNTYsXG4gICAgMzIwMzk5MzAwNixcbiAgICA0NjAzOTMyNjksXG4gICAgMzIwNjIwMzE1LFxuICAgIDY4NTQ3MTczMyxcbiAgICA1ODc0OTY4MzYsXG4gICAgODUyMTQyOTcxLFxuICAgIDEwODY3OTI4NTEsXG4gICAgMTAxNzAzNjI5OCxcbiAgICAzNjU1NDMxMDAsXG4gICAgMTEyNjAwMDU4MCxcbiAgICAyNjE4Mjk3Njc2LFxuICAgIDEyODgwMzM0NzAsXG4gICAgMzQwOTg1NTE1OCxcbiAgICAxNTAxNTA1OTQ4LFxuICAgIDQyMzQ1MDk4NjYsXG4gICAgMTYwNzE2NzkxNSxcbiAgICA5ODcxNjc0NjgsXG4gICAgMTgxNjQwMjMxNixcbiAgICAxMjQ2MTg5NTkxXG4gIF0pO1xuICBmdW5jdGlvbiBzKGYsIGgsIGQsIHYsIHcsIEEsIEkpIHtcbiAgICBmb3IgKHZhciBEID0gZFswXSwgTiA9IGRbMV0sIGsgPSBkWzJdLCBqID0gZFszXSwgVCA9IGRbNF0sIEsgPSBkWzVdLCAkID0gZFs2XSwgeiA9IGRbN10sIEIgPSB2WzBdLCBfID0gdlsxXSwgUiA9IHZbMl0sIEogPSB2WzNdLCBRID0gdls0XSwgTyA9IHZbNV0sIHAgPSB2WzZdLCBsID0gdls3XSwgYSwgYywgYiwgRSwgUywgeCwgdSwgbTsgSSA+PSAxMjg7ICkge1xuICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCAxNjsgZysrKSB7XG4gICAgICAgIHZhciBQID0gOCAqIGcgKyBBO1xuICAgICAgICBmW2ddID0gZS5yZWFkVWludDMyQkUodywgUCksIGhbZ10gPSBlLnJlYWRVaW50MzJCRSh3LCBQICsgNCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBnID0gMDsgZyA8IDgwOyBnKyspIHtcbiAgICAgICAgdmFyIEcgPSBELCBNID0gTiwgSCA9IGssIEMgPSBqLCBxID0gVCwgTCA9IEssIHkgPSAkLCBGID0geiwgVyA9IEIsIFkgPSBfLCBYID0gUiwgZWUgPSBKLCB3ZSA9IFEsIE1lID0gTywgaGUgPSBwLCBSZSA9IGw7XG4gICAgICAgIGlmIChhID0geiwgYyA9IGwsIFMgPSBjICYgNjU1MzUsIHggPSBjID4+PiAxNiwgdSA9IGEgJiA2NTUzNSwgbSA9IGEgPj4+IDE2LCBhID0gKFQgPj4+IDE0IHwgUSA8PCAzMiAtIDE0KSBeIChUID4+PiAxOCB8IFEgPDwgMzIgLSAxOCkgXiAoUSA+Pj4gNDEgLSAzMiB8IFQgPDwgMzIgLSAoNDEgLSAzMikpLCBjID0gKFEgPj4+IDE0IHwgVCA8PCAzMiAtIDE0KSBeIChRID4+PiAxOCB8IFQgPDwgMzIgLSAxOCkgXiAoVCA+Pj4gNDEgLSAzMiB8IFEgPDwgMzIgLSAoNDEgLSAzMikpLCBTICs9IGMgJiA2NTUzNSwgeCArPSBjID4+PiAxNiwgdSArPSBhICYgNjU1MzUsIG0gKz0gYSA+Pj4gMTYsIGEgPSBUICYgSyBeIH5UICYgJCwgYyA9IFEgJiBPIF4gflEgJiBwLCBTICs9IGMgJiA2NTUzNSwgeCArPSBjID4+PiAxNiwgdSArPSBhICYgNjU1MzUsIG0gKz0gYSA+Pj4gMTYsIGEgPSBuW2cgKiAyXSwgYyA9IG5bZyAqIDIgKyAxXSwgUyArPSBjICYgNjU1MzUsIHggKz0gYyA+Pj4gMTYsIHUgKz0gYSAmIDY1NTM1LCBtICs9IGEgPj4+IDE2LCBhID0gZltnICUgMTZdLCBjID0gaFtnICUgMTZdLCBTICs9IGMgJiA2NTUzNSwgeCArPSBjID4+PiAxNiwgdSArPSBhICYgNjU1MzUsIG0gKz0gYSA+Pj4gMTYsIHggKz0gUyA+Pj4gMTYsIHUgKz0geCA+Pj4gMTYsIG0gKz0gdSA+Pj4gMTYsIGIgPSB1ICYgNjU1MzUgfCBtIDw8IDE2LCBFID0gUyAmIDY1NTM1IHwgeCA8PCAxNiwgYSA9IGIsIGMgPSBFLCBTID0gYyAmIDY1NTM1LCB4ID0gYyA+Pj4gMTYsIHUgPSBhICYgNjU1MzUsIG0gPSBhID4+PiAxNiwgYSA9IChEID4+PiAyOCB8IEIgPDwgMzIgLSAyOCkgXiAoQiA+Pj4gMzQgLSAzMiB8IEQgPDwgMzIgLSAoMzQgLSAzMikpIF4gKEIgPj4+IDM5IC0gMzIgfCBEIDw8IDMyIC0gKDM5IC0gMzIpKSwgYyA9IChCID4+PiAyOCB8IEQgPDwgMzIgLSAyOCkgXiAoRCA+Pj4gMzQgLSAzMiB8IEIgPDwgMzIgLSAoMzQgLSAzMikpIF4gKEQgPj4+IDM5IC0gMzIgfCBCIDw8IDMyIC0gKDM5IC0gMzIpKSwgUyArPSBjICYgNjU1MzUsIHggKz0gYyA+Pj4gMTYsIHUgKz0gYSAmIDY1NTM1LCBtICs9IGEgPj4+IDE2LCBhID0gRCAmIE4gXiBEICYgayBeIE4gJiBrLCBjID0gQiAmIF8gXiBCICYgUiBeIF8gJiBSLCBTICs9IGMgJiA2NTUzNSwgeCArPSBjID4+PiAxNiwgdSArPSBhICYgNjU1MzUsIG0gKz0gYSA+Pj4gMTYsIHggKz0gUyA+Pj4gMTYsIHUgKz0geCA+Pj4gMTYsIG0gKz0gdSA+Pj4gMTYsIEYgPSB1ICYgNjU1MzUgfCBtIDw8IDE2LCBSZSA9IFMgJiA2NTUzNSB8IHggPDwgMTYsIGEgPSBDLCBjID0gZWUsIFMgPSBjICYgNjU1MzUsIHggPSBjID4+PiAxNiwgdSA9IGEgJiA2NTUzNSwgbSA9IGEgPj4+IDE2LCBhID0gYiwgYyA9IEUsIFMgKz0gYyAmIDY1NTM1LCB4ICs9IGMgPj4+IDE2LCB1ICs9IGEgJiA2NTUzNSwgbSArPSBhID4+PiAxNiwgeCArPSBTID4+PiAxNiwgdSArPSB4ID4+PiAxNiwgbSArPSB1ID4+PiAxNiwgQyA9IHUgJiA2NTUzNSB8IG0gPDwgMTYsIGVlID0gUyAmIDY1NTM1IHwgeCA8PCAxNiwgTiA9IEcsIGsgPSBNLCBqID0gSCwgVCA9IEMsIEsgPSBxLCAkID0gTCwgeiA9IHksIEQgPSBGLCBfID0gVywgUiA9IFksIEogPSBYLCBRID0gZWUsIE8gPSB3ZSwgcCA9IE1lLCBsID0gaGUsIEIgPSBSZSwgZyAlIDE2ID09PSAxNSlcbiAgICAgICAgICBmb3IgKHZhciBQID0gMDsgUCA8IDE2OyBQKyspXG4gICAgICAgICAgICBhID0gZltQXSwgYyA9IGhbUF0sIFMgPSBjICYgNjU1MzUsIHggPSBjID4+PiAxNiwgdSA9IGEgJiA2NTUzNSwgbSA9IGEgPj4+IDE2LCBhID0gZlsoUCArIDkpICUgMTZdLCBjID0gaFsoUCArIDkpICUgMTZdLCBTICs9IGMgJiA2NTUzNSwgeCArPSBjID4+PiAxNiwgdSArPSBhICYgNjU1MzUsIG0gKz0gYSA+Pj4gMTYsIGIgPSBmWyhQICsgMSkgJSAxNl0sIEUgPSBoWyhQICsgMSkgJSAxNl0sIGEgPSAoYiA+Pj4gMSB8IEUgPDwgMzIgLSAxKSBeIChiID4+PiA4IHwgRSA8PCAzMiAtIDgpIF4gYiA+Pj4gNywgYyA9IChFID4+PiAxIHwgYiA8PCAzMiAtIDEpIF4gKEUgPj4+IDggfCBiIDw8IDMyIC0gOCkgXiAoRSA+Pj4gNyB8IGIgPDwgMzIgLSA3KSwgUyArPSBjICYgNjU1MzUsIHggKz0gYyA+Pj4gMTYsIHUgKz0gYSAmIDY1NTM1LCBtICs9IGEgPj4+IDE2LCBiID0gZlsoUCArIDE0KSAlIDE2XSwgRSA9IGhbKFAgKyAxNCkgJSAxNl0sIGEgPSAoYiA+Pj4gMTkgfCBFIDw8IDMyIC0gMTkpIF4gKEUgPj4+IDYxIC0gMzIgfCBiIDw8IDMyIC0gKDYxIC0gMzIpKSBeIGIgPj4+IDYsIGMgPSAoRSA+Pj4gMTkgfCBiIDw8IDMyIC0gMTkpIF4gKGIgPj4+IDYxIC0gMzIgfCBFIDw8IDMyIC0gKDYxIC0gMzIpKSBeIChFID4+PiA2IHwgYiA8PCAzMiAtIDYpLCBTICs9IGMgJiA2NTUzNSwgeCArPSBjID4+PiAxNiwgdSArPSBhICYgNjU1MzUsIG0gKz0gYSA+Pj4gMTYsIHggKz0gUyA+Pj4gMTYsIHUgKz0geCA+Pj4gMTYsIG0gKz0gdSA+Pj4gMTYsIGZbUF0gPSB1ICYgNjU1MzUgfCBtIDw8IDE2LCBoW1BdID0gUyAmIDY1NTM1IHwgeCA8PCAxNjtcbiAgICAgIH1cbiAgICAgIGEgPSBELCBjID0gQiwgUyA9IGMgJiA2NTUzNSwgeCA9IGMgPj4+IDE2LCB1ID0gYSAmIDY1NTM1LCBtID0gYSA+Pj4gMTYsIGEgPSBkWzBdLCBjID0gdlswXSwgUyArPSBjICYgNjU1MzUsIHggKz0gYyA+Pj4gMTYsIHUgKz0gYSAmIDY1NTM1LCBtICs9IGEgPj4+IDE2LCB4ICs9IFMgPj4+IDE2LCB1ICs9IHggPj4+IDE2LCBtICs9IHUgPj4+IDE2LCBkWzBdID0gRCA9IHUgJiA2NTUzNSB8IG0gPDwgMTYsIHZbMF0gPSBCID0gUyAmIDY1NTM1IHwgeCA8PCAxNiwgYSA9IE4sIGMgPSBfLCBTID0gYyAmIDY1NTM1LCB4ID0gYyA+Pj4gMTYsIHUgPSBhICYgNjU1MzUsIG0gPSBhID4+PiAxNiwgYSA9IGRbMV0sIGMgPSB2WzFdLCBTICs9IGMgJiA2NTUzNSwgeCArPSBjID4+PiAxNiwgdSArPSBhICYgNjU1MzUsIG0gKz0gYSA+Pj4gMTYsIHggKz0gUyA+Pj4gMTYsIHUgKz0geCA+Pj4gMTYsIG0gKz0gdSA+Pj4gMTYsIGRbMV0gPSBOID0gdSAmIDY1NTM1IHwgbSA8PCAxNiwgdlsxXSA9IF8gPSBTICYgNjU1MzUgfCB4IDw8IDE2LCBhID0gaywgYyA9IFIsIFMgPSBjICYgNjU1MzUsIHggPSBjID4+PiAxNiwgdSA9IGEgJiA2NTUzNSwgbSA9IGEgPj4+IDE2LCBhID0gZFsyXSwgYyA9IHZbMl0sIFMgKz0gYyAmIDY1NTM1LCB4ICs9IGMgPj4+IDE2LCB1ICs9IGEgJiA2NTUzNSwgbSArPSBhID4+PiAxNiwgeCArPSBTID4+PiAxNiwgdSArPSB4ID4+PiAxNiwgbSArPSB1ID4+PiAxNiwgZFsyXSA9IGsgPSB1ICYgNjU1MzUgfCBtIDw8IDE2LCB2WzJdID0gUiA9IFMgJiA2NTUzNSB8IHggPDwgMTYsIGEgPSBqLCBjID0gSiwgUyA9IGMgJiA2NTUzNSwgeCA9IGMgPj4+IDE2LCB1ID0gYSAmIDY1NTM1LCBtID0gYSA+Pj4gMTYsIGEgPSBkWzNdLCBjID0gdlszXSwgUyArPSBjICYgNjU1MzUsIHggKz0gYyA+Pj4gMTYsIHUgKz0gYSAmIDY1NTM1LCBtICs9IGEgPj4+IDE2LCB4ICs9IFMgPj4+IDE2LCB1ICs9IHggPj4+IDE2LCBtICs9IHUgPj4+IDE2LCBkWzNdID0gaiA9IHUgJiA2NTUzNSB8IG0gPDwgMTYsIHZbM10gPSBKID0gUyAmIDY1NTM1IHwgeCA8PCAxNiwgYSA9IFQsIGMgPSBRLCBTID0gYyAmIDY1NTM1LCB4ID0gYyA+Pj4gMTYsIHUgPSBhICYgNjU1MzUsIG0gPSBhID4+PiAxNiwgYSA9IGRbNF0sIGMgPSB2WzRdLCBTICs9IGMgJiA2NTUzNSwgeCArPSBjID4+PiAxNiwgdSArPSBhICYgNjU1MzUsIG0gKz0gYSA+Pj4gMTYsIHggKz0gUyA+Pj4gMTYsIHUgKz0geCA+Pj4gMTYsIG0gKz0gdSA+Pj4gMTYsIGRbNF0gPSBUID0gdSAmIDY1NTM1IHwgbSA8PCAxNiwgdls0XSA9IFEgPSBTICYgNjU1MzUgfCB4IDw8IDE2LCBhID0gSywgYyA9IE8sIFMgPSBjICYgNjU1MzUsIHggPSBjID4+PiAxNiwgdSA9IGEgJiA2NTUzNSwgbSA9IGEgPj4+IDE2LCBhID0gZFs1XSwgYyA9IHZbNV0sIFMgKz0gYyAmIDY1NTM1LCB4ICs9IGMgPj4+IDE2LCB1ICs9IGEgJiA2NTUzNSwgbSArPSBhID4+PiAxNiwgeCArPSBTID4+PiAxNiwgdSArPSB4ID4+PiAxNiwgbSArPSB1ID4+PiAxNiwgZFs1XSA9IEsgPSB1ICYgNjU1MzUgfCBtIDw8IDE2LCB2WzVdID0gTyA9IFMgJiA2NTUzNSB8IHggPDwgMTYsIGEgPSAkLCBjID0gcCwgUyA9IGMgJiA2NTUzNSwgeCA9IGMgPj4+IDE2LCB1ID0gYSAmIDY1NTM1LCBtID0gYSA+Pj4gMTYsIGEgPSBkWzZdLCBjID0gdls2XSwgUyArPSBjICYgNjU1MzUsIHggKz0gYyA+Pj4gMTYsIHUgKz0gYSAmIDY1NTM1LCBtICs9IGEgPj4+IDE2LCB4ICs9IFMgPj4+IDE2LCB1ICs9IHggPj4+IDE2LCBtICs9IHUgPj4+IDE2LCBkWzZdID0gJCA9IHUgJiA2NTUzNSB8IG0gPDwgMTYsIHZbNl0gPSBwID0gUyAmIDY1NTM1IHwgeCA8PCAxNiwgYSA9IHosIGMgPSBsLCBTID0gYyAmIDY1NTM1LCB4ID0gYyA+Pj4gMTYsIHUgPSBhICYgNjU1MzUsIG0gPSBhID4+PiAxNiwgYSA9IGRbN10sIGMgPSB2WzddLCBTICs9IGMgJiA2NTUzNSwgeCArPSBjID4+PiAxNiwgdSArPSBhICYgNjU1MzUsIG0gKz0gYSA+Pj4gMTYsIHggKz0gUyA+Pj4gMTYsIHUgKz0geCA+Pj4gMTYsIG0gKz0gdSA+Pj4gMTYsIGRbN10gPSB6ID0gdSAmIDY1NTM1IHwgbSA8PCAxNiwgdls3XSA9IGwgPSBTICYgNjU1MzUgfCB4IDw8IDE2LCBBICs9IDEyOCwgSSAtPSAxMjg7XG4gICAgfVxuICAgIHJldHVybiBBO1xuICB9XG4gIGZ1bmN0aW9uIG8oZikge1xuICAgIHZhciBoID0gbmV3IGkoKTtcbiAgICBoLnVwZGF0ZShmKTtcbiAgICB2YXIgZCA9IGguZGlnZXN0KCk7XG4gICAgcmV0dXJuIGguY2xlYW4oKSwgZDtcbiAgfVxuICByLmhhc2ggPSBvO1xufSkoZXUpO1xuKGZ1bmN0aW9uKHIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgci5jb252ZXJ0U2VjcmV0S2V5VG9YMjU1MTkgPSByLmNvbnZlcnRQdWJsaWNLZXlUb1gyNTUxOSA9IHIudmVyaWZ5ID0gci5zaWduID0gci5leHRyYWN0UHVibGljS2V5RnJvbVNlY3JldEtleSA9IHIuZ2VuZXJhdGVLZXlQYWlyID0gci5nZW5lcmF0ZUtleVBhaXJGcm9tU2VlZCA9IHIuU0VFRF9MRU5HVEggPSByLlNFQ1JFVF9LRVlfTEVOR1RIID0gci5QVUJMSUNfS0VZX0xFTkdUSCA9IHIuU0lHTkFUVVJFX0xFTkdUSCA9IHZvaWQgMDtcbiAgY29uc3QgZSA9IEVpLCB0ID0gZXUsIGkgPSBucjtcbiAgci5TSUdOQVRVUkVfTEVOR1RIID0gNjQsIHIuUFVCTElDX0tFWV9MRU5HVEggPSAzMiwgci5TRUNSRVRfS0VZX0xFTkdUSCA9IDY0LCByLlNFRURfTEVOR1RIID0gMzI7XG4gIGZ1bmN0aW9uIG4oQykge1xuICAgIGNvbnN0IHEgPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcbiAgICBpZiAoQylcbiAgICAgIGZvciAobGV0IEwgPSAwOyBMIDwgQy5sZW5ndGg7IEwrKylcbiAgICAgICAgcVtMXSA9IENbTF07XG4gICAgcmV0dXJuIHE7XG4gIH1cbiAgY29uc3QgcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgc1swXSA9IDk7XG4gIGNvbnN0IG8gPSBuKCksIGYgPSBuKFsxXSksIGggPSBuKFtcbiAgICAzMDg4MyxcbiAgICA0OTUzLFxuICAgIDE5OTE0LFxuICAgIDMwMTg3LFxuICAgIDU1NDY3LFxuICAgIDE2NzA1LFxuICAgIDI2MzcsXG4gICAgMTEyLFxuICAgIDU5NTQ0LFxuICAgIDMwNTg1LFxuICAgIDE2NTA1LFxuICAgIDM2MDM5LFxuICAgIDY1MTM5LFxuICAgIDExMTE5LFxuICAgIDI3ODg2LFxuICAgIDIwOTk1XG4gIF0pLCBkID0gbihbXG4gICAgNjE3ODUsXG4gICAgOTkwNixcbiAgICAzOTgyOCxcbiAgICA2MDM3NCxcbiAgICA0NTM5OCxcbiAgICAzMzQxMSxcbiAgICA1Mjc0LFxuICAgIDIyNCxcbiAgICA1MzU1MixcbiAgICA2MTE3MSxcbiAgICAzMzAxMCxcbiAgICA2NTQyLFxuICAgIDY0NzQzLFxuICAgIDIyMjM5LFxuICAgIDU1NzcyLFxuICAgIDkyMjJcbiAgXSksIHYgPSBuKFtcbiAgICA1NDU1NCxcbiAgICAzNjY0NSxcbiAgICAxMTYxNixcbiAgICA1MTU0MixcbiAgICA0MjkzMCxcbiAgICAzODE4MSxcbiAgICA1MTA0MCxcbiAgICAyNjkyNCxcbiAgICA1NjQxMixcbiAgICA2NDk4MixcbiAgICA1NzkwNSxcbiAgICA0OTMxNixcbiAgICAyMTUwMixcbiAgICA1MjU5MCxcbiAgICAxNDAzNSxcbiAgICA4NTUzXG4gIF0pLCB3ID0gbihbXG4gICAgMjYyMDAsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTRcbiAgXSksIEEgPSBuKFtcbiAgICA0MTEzNixcbiAgICAxODk1OCxcbiAgICA2OTUxLFxuICAgIDUwNDE0LFxuICAgIDU4NDg4LFxuICAgIDQ0MzM1LFxuICAgIDYxNTAsXG4gICAgMTIwOTksXG4gICAgNTUyMDcsXG4gICAgMTU4NjcsXG4gICAgMTUzLFxuICAgIDExMDg1LFxuICAgIDU3MDk5LFxuICAgIDIwNDE3LFxuICAgIDkzNDQsXG4gICAgMTExMzlcbiAgXSk7XG4gIGZ1bmN0aW9uIEkoQywgcSkge1xuICAgIGZvciAobGV0IEwgPSAwOyBMIDwgMTY7IEwrKylcbiAgICAgIENbTF0gPSBxW0xdIHwgMDtcbiAgfVxuICBmdW5jdGlvbiBEKEMpIHtcbiAgICBsZXQgcSA9IDE7XG4gICAgZm9yIChsZXQgTCA9IDA7IEwgPCAxNjsgTCsrKSB7XG4gICAgICBsZXQgeSA9IENbTF0gKyBxICsgNjU1MzU7XG4gICAgICBxID0gTWF0aC5mbG9vcih5IC8gNjU1MzYpLCBDW0xdID0geSAtIHEgKiA2NTUzNjtcbiAgICB9XG4gICAgQ1swXSArPSBxIC0gMSArIDM3ICogKHEgLSAxKTtcbiAgfVxuICBmdW5jdGlvbiBOKEMsIHEsIEwpIHtcbiAgICBjb25zdCB5ID0gfihMIC0gMSk7XG4gICAgZm9yIChsZXQgRiA9IDA7IEYgPCAxNjsgRisrKSB7XG4gICAgICBjb25zdCBXID0geSAmIChDW0ZdIF4gcVtGXSk7XG4gICAgICBDW0ZdIF49IFcsIHFbRl0gXj0gVztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gayhDLCBxKSB7XG4gICAgY29uc3QgTCA9IG4oKSwgeSA9IG4oKTtcbiAgICBmb3IgKGxldCBGID0gMDsgRiA8IDE2OyBGKyspXG4gICAgICB5W0ZdID0gcVtGXTtcbiAgICBEKHkpLCBEKHkpLCBEKHkpO1xuICAgIGZvciAobGV0IEYgPSAwOyBGIDwgMjsgRisrKSB7XG4gICAgICBMWzBdID0geVswXSAtIDY1NTE3O1xuICAgICAgZm9yIChsZXQgWSA9IDE7IFkgPCAxNTsgWSsrKVxuICAgICAgICBMW1ldID0geVtZXSAtIDY1NTM1IC0gKExbWSAtIDFdID4+IDE2ICYgMSksIExbWSAtIDFdICY9IDY1NTM1O1xuICAgICAgTFsxNV0gPSB5WzE1XSAtIDMyNzY3IC0gKExbMTRdID4+IDE2ICYgMSk7XG4gICAgICBjb25zdCBXID0gTFsxNV0gPj4gMTYgJiAxO1xuICAgICAgTFsxNF0gJj0gNjU1MzUsIE4oeSwgTCwgMSAtIFcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBGID0gMDsgRiA8IDE2OyBGKyspXG4gICAgICBDWzIgKiBGXSA9IHlbRl0gJiAyNTUsIENbMiAqIEYgKyAxXSA9IHlbRl0gPj4gODtcbiAgfVxuICBmdW5jdGlvbiBqKEMsIHEpIHtcbiAgICBsZXQgTCA9IDA7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCAzMjsgeSsrKVxuICAgICAgTCB8PSBDW3ldIF4gcVt5XTtcbiAgICByZXR1cm4gKDEgJiBMIC0gMSA+Pj4gOCkgLSAxO1xuICB9XG4gIGZ1bmN0aW9uIFQoQywgcSkge1xuICAgIGNvbnN0IEwgPSBuZXcgVWludDhBcnJheSgzMiksIHkgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcmV0dXJuIGsoTCwgQyksIGsoeSwgcSksIGooTCwgeSk7XG4gIH1cbiAgZnVuY3Rpb24gSyhDKSB7XG4gICAgY29uc3QgcSA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICByZXR1cm4gayhxLCBDKSwgcVswXSAmIDE7XG4gIH1cbiAgZnVuY3Rpb24gJChDLCBxKSB7XG4gICAgZm9yIChsZXQgTCA9IDA7IEwgPCAxNjsgTCsrKVxuICAgICAgQ1tMXSA9IHFbMiAqIExdICsgKHFbMiAqIEwgKyAxXSA8PCA4KTtcbiAgICBDWzE1XSAmPSAzMjc2NztcbiAgfVxuICBmdW5jdGlvbiB6KEMsIHEsIEwpIHtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDE2OyB5KyspXG4gICAgICBDW3ldID0gcVt5XSArIExbeV07XG4gIH1cbiAgZnVuY3Rpb24gQihDLCBxLCBMKSB7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCAxNjsgeSsrKVxuICAgICAgQ1t5XSA9IHFbeV0gLSBMW3ldO1xuICB9XG4gIGZ1bmN0aW9uIF8oQywgcSwgTCkge1xuICAgIGxldCB5LCBGLCBXID0gMCwgWSA9IDAsIFggPSAwLCBlZSA9IDAsIHdlID0gMCwgTWUgPSAwLCBoZSA9IDAsIFJlID0gMCwgeGUgPSAwLCBzZSA9IDAsIGdlID0gMCwgbGUgPSAwLCBuZSA9IDAsIHVlID0gMCwgZmUgPSAwLCB0ZSA9IDAsIHBlID0gMCwgX2UgPSAwLCByZSA9IDAsIEVlID0gMCwgU2UgPSAwLCBvZSA9IDAsIERlID0gMCwgSWUgPSAwLCBQZSA9IDAsIEdlID0gMCwgWWUgPSAwLCBBZSA9IDAsIFplID0gMCwgZXQgPSAwLCBOZSA9IDAsIENlID0gTFswXSwgVGUgPSBMWzFdLCBkZSA9IExbMl0sICRlID0gTFszXSwgTGUgPSBMWzRdLCBjZSA9IExbNV0sIFVlID0gTFs2XSwgemUgPSBMWzddLCB5ZSA9IExbOF0sIEJlID0gTFs5XSwga2UgPSBMWzEwXSwgdmUgPSBMWzExXSwgRmUgPSBMWzEyXSwgT2UgPSBMWzEzXSwgbWUgPSBMWzE0XSwgamUgPSBMWzE1XTtcbiAgICB5ID0gcVswXSwgVyArPSB5ICogQ2UsIFkgKz0geSAqIFRlLCBYICs9IHkgKiBkZSwgZWUgKz0geSAqICRlLCB3ZSArPSB5ICogTGUsIE1lICs9IHkgKiBjZSwgaGUgKz0geSAqIFVlLCBSZSArPSB5ICogemUsIHhlICs9IHkgKiB5ZSwgc2UgKz0geSAqIEJlLCBnZSArPSB5ICoga2UsIGxlICs9IHkgKiB2ZSwgbmUgKz0geSAqIEZlLCB1ZSArPSB5ICogT2UsIGZlICs9IHkgKiBtZSwgdGUgKz0geSAqIGplLCB5ID0gcVsxXSwgWSArPSB5ICogQ2UsIFggKz0geSAqIFRlLCBlZSArPSB5ICogZGUsIHdlICs9IHkgKiAkZSwgTWUgKz0geSAqIExlLCBoZSArPSB5ICogY2UsIFJlICs9IHkgKiBVZSwgeGUgKz0geSAqIHplLCBzZSArPSB5ICogeWUsIGdlICs9IHkgKiBCZSwgbGUgKz0geSAqIGtlLCBuZSArPSB5ICogdmUsIHVlICs9IHkgKiBGZSwgZmUgKz0geSAqIE9lLCB0ZSArPSB5ICogbWUsIHBlICs9IHkgKiBqZSwgeSA9IHFbMl0sIFggKz0geSAqIENlLCBlZSArPSB5ICogVGUsIHdlICs9IHkgKiBkZSwgTWUgKz0geSAqICRlLCBoZSArPSB5ICogTGUsIFJlICs9IHkgKiBjZSwgeGUgKz0geSAqIFVlLCBzZSArPSB5ICogemUsIGdlICs9IHkgKiB5ZSwgbGUgKz0geSAqIEJlLCBuZSArPSB5ICoga2UsIHVlICs9IHkgKiB2ZSwgZmUgKz0geSAqIEZlLCB0ZSArPSB5ICogT2UsIHBlICs9IHkgKiBtZSwgX2UgKz0geSAqIGplLCB5ID0gcVszXSwgZWUgKz0geSAqIENlLCB3ZSArPSB5ICogVGUsIE1lICs9IHkgKiBkZSwgaGUgKz0geSAqICRlLCBSZSArPSB5ICogTGUsIHhlICs9IHkgKiBjZSwgc2UgKz0geSAqIFVlLCBnZSArPSB5ICogemUsIGxlICs9IHkgKiB5ZSwgbmUgKz0geSAqIEJlLCB1ZSArPSB5ICoga2UsIGZlICs9IHkgKiB2ZSwgdGUgKz0geSAqIEZlLCBwZSArPSB5ICogT2UsIF9lICs9IHkgKiBtZSwgcmUgKz0geSAqIGplLCB5ID0gcVs0XSwgd2UgKz0geSAqIENlLCBNZSArPSB5ICogVGUsIGhlICs9IHkgKiBkZSwgUmUgKz0geSAqICRlLCB4ZSArPSB5ICogTGUsIHNlICs9IHkgKiBjZSwgZ2UgKz0geSAqIFVlLCBsZSArPSB5ICogemUsIG5lICs9IHkgKiB5ZSwgdWUgKz0geSAqIEJlLCBmZSArPSB5ICoga2UsIHRlICs9IHkgKiB2ZSwgcGUgKz0geSAqIEZlLCBfZSArPSB5ICogT2UsIHJlICs9IHkgKiBtZSwgRWUgKz0geSAqIGplLCB5ID0gcVs1XSwgTWUgKz0geSAqIENlLCBoZSArPSB5ICogVGUsIFJlICs9IHkgKiBkZSwgeGUgKz0geSAqICRlLCBzZSArPSB5ICogTGUsIGdlICs9IHkgKiBjZSwgbGUgKz0geSAqIFVlLCBuZSArPSB5ICogemUsIHVlICs9IHkgKiB5ZSwgZmUgKz0geSAqIEJlLCB0ZSArPSB5ICoga2UsIHBlICs9IHkgKiB2ZSwgX2UgKz0geSAqIEZlLCByZSArPSB5ICogT2UsIEVlICs9IHkgKiBtZSwgU2UgKz0geSAqIGplLCB5ID0gcVs2XSwgaGUgKz0geSAqIENlLCBSZSArPSB5ICogVGUsIHhlICs9IHkgKiBkZSwgc2UgKz0geSAqICRlLCBnZSArPSB5ICogTGUsIGxlICs9IHkgKiBjZSwgbmUgKz0geSAqIFVlLCB1ZSArPSB5ICogemUsIGZlICs9IHkgKiB5ZSwgdGUgKz0geSAqIEJlLCBwZSArPSB5ICoga2UsIF9lICs9IHkgKiB2ZSwgcmUgKz0geSAqIEZlLCBFZSArPSB5ICogT2UsIFNlICs9IHkgKiBtZSwgb2UgKz0geSAqIGplLCB5ID0gcVs3XSwgUmUgKz0geSAqIENlLCB4ZSArPSB5ICogVGUsIHNlICs9IHkgKiBkZSwgZ2UgKz0geSAqICRlLCBsZSArPSB5ICogTGUsIG5lICs9IHkgKiBjZSwgdWUgKz0geSAqIFVlLCBmZSArPSB5ICogemUsIHRlICs9IHkgKiB5ZSwgcGUgKz0geSAqIEJlLCBfZSArPSB5ICoga2UsIHJlICs9IHkgKiB2ZSwgRWUgKz0geSAqIEZlLCBTZSArPSB5ICogT2UsIG9lICs9IHkgKiBtZSwgRGUgKz0geSAqIGplLCB5ID0gcVs4XSwgeGUgKz0geSAqIENlLCBzZSArPSB5ICogVGUsIGdlICs9IHkgKiBkZSwgbGUgKz0geSAqICRlLCBuZSArPSB5ICogTGUsIHVlICs9IHkgKiBjZSwgZmUgKz0geSAqIFVlLCB0ZSArPSB5ICogemUsIHBlICs9IHkgKiB5ZSwgX2UgKz0geSAqIEJlLCByZSArPSB5ICoga2UsIEVlICs9IHkgKiB2ZSwgU2UgKz0geSAqIEZlLCBvZSArPSB5ICogT2UsIERlICs9IHkgKiBtZSwgSWUgKz0geSAqIGplLCB5ID0gcVs5XSwgc2UgKz0geSAqIENlLCBnZSArPSB5ICogVGUsIGxlICs9IHkgKiBkZSwgbmUgKz0geSAqICRlLCB1ZSArPSB5ICogTGUsIGZlICs9IHkgKiBjZSwgdGUgKz0geSAqIFVlLCBwZSArPSB5ICogemUsIF9lICs9IHkgKiB5ZSwgcmUgKz0geSAqIEJlLCBFZSArPSB5ICoga2UsIFNlICs9IHkgKiB2ZSwgb2UgKz0geSAqIEZlLCBEZSArPSB5ICogT2UsIEllICs9IHkgKiBtZSwgUGUgKz0geSAqIGplLCB5ID0gcVsxMF0sIGdlICs9IHkgKiBDZSwgbGUgKz0geSAqIFRlLCBuZSArPSB5ICogZGUsIHVlICs9IHkgKiAkZSwgZmUgKz0geSAqIExlLCB0ZSArPSB5ICogY2UsIHBlICs9IHkgKiBVZSwgX2UgKz0geSAqIHplLCByZSArPSB5ICogeWUsIEVlICs9IHkgKiBCZSwgU2UgKz0geSAqIGtlLCBvZSArPSB5ICogdmUsIERlICs9IHkgKiBGZSwgSWUgKz0geSAqIE9lLCBQZSArPSB5ICogbWUsIEdlICs9IHkgKiBqZSwgeSA9IHFbMTFdLCBsZSArPSB5ICogQ2UsIG5lICs9IHkgKiBUZSwgdWUgKz0geSAqIGRlLCBmZSArPSB5ICogJGUsIHRlICs9IHkgKiBMZSwgcGUgKz0geSAqIGNlLCBfZSArPSB5ICogVWUsIHJlICs9IHkgKiB6ZSwgRWUgKz0geSAqIHllLCBTZSArPSB5ICogQmUsIG9lICs9IHkgKiBrZSwgRGUgKz0geSAqIHZlLCBJZSArPSB5ICogRmUsIFBlICs9IHkgKiBPZSwgR2UgKz0geSAqIG1lLCBZZSArPSB5ICogamUsIHkgPSBxWzEyXSwgbmUgKz0geSAqIENlLCB1ZSArPSB5ICogVGUsIGZlICs9IHkgKiBkZSwgdGUgKz0geSAqICRlLCBwZSArPSB5ICogTGUsIF9lICs9IHkgKiBjZSwgcmUgKz0geSAqIFVlLCBFZSArPSB5ICogemUsIFNlICs9IHkgKiB5ZSwgb2UgKz0geSAqIEJlLCBEZSArPSB5ICoga2UsIEllICs9IHkgKiB2ZSwgUGUgKz0geSAqIEZlLCBHZSArPSB5ICogT2UsIFllICs9IHkgKiBtZSwgQWUgKz0geSAqIGplLCB5ID0gcVsxM10sIHVlICs9IHkgKiBDZSwgZmUgKz0geSAqIFRlLCB0ZSArPSB5ICogZGUsIHBlICs9IHkgKiAkZSwgX2UgKz0geSAqIExlLCByZSArPSB5ICogY2UsIEVlICs9IHkgKiBVZSwgU2UgKz0geSAqIHplLCBvZSArPSB5ICogeWUsIERlICs9IHkgKiBCZSwgSWUgKz0geSAqIGtlLCBQZSArPSB5ICogdmUsIEdlICs9IHkgKiBGZSwgWWUgKz0geSAqIE9lLCBBZSArPSB5ICogbWUsIFplICs9IHkgKiBqZSwgeSA9IHFbMTRdLCBmZSArPSB5ICogQ2UsIHRlICs9IHkgKiBUZSwgcGUgKz0geSAqIGRlLCBfZSArPSB5ICogJGUsIHJlICs9IHkgKiBMZSwgRWUgKz0geSAqIGNlLCBTZSArPSB5ICogVWUsIG9lICs9IHkgKiB6ZSwgRGUgKz0geSAqIHllLCBJZSArPSB5ICogQmUsIFBlICs9IHkgKiBrZSwgR2UgKz0geSAqIHZlLCBZZSArPSB5ICogRmUsIEFlICs9IHkgKiBPZSwgWmUgKz0geSAqIG1lLCBldCArPSB5ICogamUsIHkgPSBxWzE1XSwgdGUgKz0geSAqIENlLCBwZSArPSB5ICogVGUsIF9lICs9IHkgKiBkZSwgcmUgKz0geSAqICRlLCBFZSArPSB5ICogTGUsIFNlICs9IHkgKiBjZSwgb2UgKz0geSAqIFVlLCBEZSArPSB5ICogemUsIEllICs9IHkgKiB5ZSwgUGUgKz0geSAqIEJlLCBHZSArPSB5ICoga2UsIFllICs9IHkgKiB2ZSwgQWUgKz0geSAqIEZlLCBaZSArPSB5ICogT2UsIGV0ICs9IHkgKiBtZSwgTmUgKz0geSAqIGplLCBXICs9IDM4ICogcGUsIFkgKz0gMzggKiBfZSwgWCArPSAzOCAqIHJlLCBlZSArPSAzOCAqIEVlLCB3ZSArPSAzOCAqIFNlLCBNZSArPSAzOCAqIG9lLCBoZSArPSAzOCAqIERlLCBSZSArPSAzOCAqIEllLCB4ZSArPSAzOCAqIFBlLCBzZSArPSAzOCAqIEdlLCBnZSArPSAzOCAqIFllLCBsZSArPSAzOCAqIEFlLCBuZSArPSAzOCAqIFplLCB1ZSArPSAzOCAqIGV0LCBmZSArPSAzOCAqIE5lLCBGID0gMSwgeSA9IFcgKyBGICsgNjU1MzUsIEYgPSBNYXRoLmZsb29yKHkgLyA2NTUzNiksIFcgPSB5IC0gRiAqIDY1NTM2LCB5ID0gWSArIEYgKyA2NTUzNSwgRiA9IE1hdGguZmxvb3IoeSAvIDY1NTM2KSwgWSA9IHkgLSBGICogNjU1MzYsIHkgPSBYICsgRiArIDY1NTM1LCBGID0gTWF0aC5mbG9vcih5IC8gNjU1MzYpLCBYID0geSAtIEYgKiA2NTUzNiwgeSA9IGVlICsgRiArIDY1NTM1LCBGID0gTWF0aC5mbG9vcih5IC8gNjU1MzYpLCBlZSA9IHkgLSBGICogNjU1MzYsIHkgPSB3ZSArIEYgKyA2NTUzNSwgRiA9IE1hdGguZmxvb3IoeSAvIDY1NTM2KSwgd2UgPSB5IC0gRiAqIDY1NTM2LCB5ID0gTWUgKyBGICsgNjU1MzUsIEYgPSBNYXRoLmZsb29yKHkgLyA2NTUzNiksIE1lID0geSAtIEYgKiA2NTUzNiwgeSA9IGhlICsgRiArIDY1NTM1LCBGID0gTWF0aC5mbG9vcih5IC8gNjU1MzYpLCBoZSA9IHkgLSBGICogNjU1MzYsIHkgPSBSZSArIEYgKyA2NTUzNSwgRiA9IE1hdGguZmxvb3IoeSAvIDY1NTM2KSwgUmUgPSB5IC0gRiAqIDY1NTM2LCB5ID0geGUgKyBGICsgNjU1MzUsIEYgPSBNYXRoLmZsb29yKHkgLyA2NTUzNiksIHhlID0geSAtIEYgKiA2NTUzNiwgeSA9IHNlICsgRiArIDY1NTM1LCBGID0gTWF0aC5mbG9vcih5IC8gNjU1MzYpLCBzZSA9IHkgLSBGICogNjU1MzYsIHkgPSBnZSArIEYgKyA2NTUzNSwgRiA9IE1hdGguZmxvb3IoeSAvIDY1NTM2KSwgZ2UgPSB5IC0gRiAqIDY1NTM2LCB5ID0gbGUgKyBGICsgNjU1MzUsIEYgPSBNYXRoLmZsb29yKHkgLyA2NTUzNiksIGxlID0geSAtIEYgKiA2NTUzNiwgeSA9IG5lICsgRiArIDY1NTM1LCBGID0gTWF0aC5mbG9vcih5IC8gNjU1MzYpLCBuZSA9IHkgLSBGICogNjU1MzYsIHkgPSB1ZSArIEYgKyA2NTUzNSwgRiA9IE1hdGguZmxvb3IoeSAvIDY1NTM2KSwgdWUgPSB5IC0gRiAqIDY1NTM2LCB5ID0gZmUgKyBGICsgNjU1MzUsIEYgPSBNYXRoLmZsb29yKHkgLyA2NTUzNiksIGZlID0geSAtIEYgKiA2NTUzNiwgeSA9IHRlICsgRiArIDY1NTM1LCBGID0gTWF0aC5mbG9vcih5IC8gNjU1MzYpLCB0ZSA9IHkgLSBGICogNjU1MzYsIFcgKz0gRiAtIDEgKyAzNyAqIChGIC0gMSksIEYgPSAxLCB5ID0gVyArIEYgKyA2NTUzNSwgRiA9IE1hdGguZmxvb3IoeSAvIDY1NTM2KSwgVyA9IHkgLSBGICogNjU1MzYsIHkgPSBZICsgRiArIDY1NTM1LCBGID0gTWF0aC5mbG9vcih5IC8gNjU1MzYpLCBZID0geSAtIEYgKiA2NTUzNiwgeSA9IFggKyBGICsgNjU1MzUsIEYgPSBNYXRoLmZsb29yKHkgLyA2NTUzNiksIFggPSB5IC0gRiAqIDY1NTM2LCB5ID0gZWUgKyBGICsgNjU1MzUsIEYgPSBNYXRoLmZsb29yKHkgLyA2NTUzNiksIGVlID0geSAtIEYgKiA2NTUzNiwgeSA9IHdlICsgRiArIDY1NTM1LCBGID0gTWF0aC5mbG9vcih5IC8gNjU1MzYpLCB3ZSA9IHkgLSBGICogNjU1MzYsIHkgPSBNZSArIEYgKyA2NTUzNSwgRiA9IE1hdGguZmxvb3IoeSAvIDY1NTM2KSwgTWUgPSB5IC0gRiAqIDY1NTM2LCB5ID0gaGUgKyBGICsgNjU1MzUsIEYgPSBNYXRoLmZsb29yKHkgLyA2NTUzNiksIGhlID0geSAtIEYgKiA2NTUzNiwgeSA9IFJlICsgRiArIDY1NTM1LCBGID0gTWF0aC5mbG9vcih5IC8gNjU1MzYpLCBSZSA9IHkgLSBGICogNjU1MzYsIHkgPSB4ZSArIEYgKyA2NTUzNSwgRiA9IE1hdGguZmxvb3IoeSAvIDY1NTM2KSwgeGUgPSB5IC0gRiAqIDY1NTM2LCB5ID0gc2UgKyBGICsgNjU1MzUsIEYgPSBNYXRoLmZsb29yKHkgLyA2NTUzNiksIHNlID0geSAtIEYgKiA2NTUzNiwgeSA9IGdlICsgRiArIDY1NTM1LCBGID0gTWF0aC5mbG9vcih5IC8gNjU1MzYpLCBnZSA9IHkgLSBGICogNjU1MzYsIHkgPSBsZSArIEYgKyA2NTUzNSwgRiA9IE1hdGguZmxvb3IoeSAvIDY1NTM2KSwgbGUgPSB5IC0gRiAqIDY1NTM2LCB5ID0gbmUgKyBGICsgNjU1MzUsIEYgPSBNYXRoLmZsb29yKHkgLyA2NTUzNiksIG5lID0geSAtIEYgKiA2NTUzNiwgeSA9IHVlICsgRiArIDY1NTM1LCBGID0gTWF0aC5mbG9vcih5IC8gNjU1MzYpLCB1ZSA9IHkgLSBGICogNjU1MzYsIHkgPSBmZSArIEYgKyA2NTUzNSwgRiA9IE1hdGguZmxvb3IoeSAvIDY1NTM2KSwgZmUgPSB5IC0gRiAqIDY1NTM2LCB5ID0gdGUgKyBGICsgNjU1MzUsIEYgPSBNYXRoLmZsb29yKHkgLyA2NTUzNiksIHRlID0geSAtIEYgKiA2NTUzNiwgVyArPSBGIC0gMSArIDM3ICogKEYgLSAxKSwgQ1swXSA9IFcsIENbMV0gPSBZLCBDWzJdID0gWCwgQ1szXSA9IGVlLCBDWzRdID0gd2UsIENbNV0gPSBNZSwgQ1s2XSA9IGhlLCBDWzddID0gUmUsIENbOF0gPSB4ZSwgQ1s5XSA9IHNlLCBDWzEwXSA9IGdlLCBDWzExXSA9IGxlLCBDWzEyXSA9IG5lLCBDWzEzXSA9IHVlLCBDWzE0XSA9IGZlLCBDWzE1XSA9IHRlO1xuICB9XG4gIGZ1bmN0aW9uIFIoQywgcSkge1xuICAgIF8oQywgcSwgcSk7XG4gIH1cbiAgZnVuY3Rpb24gSihDLCBxKSB7XG4gICAgY29uc3QgTCA9IG4oKTtcbiAgICBsZXQgeTtcbiAgICBmb3IgKHkgPSAwOyB5IDwgMTY7IHkrKylcbiAgICAgIExbeV0gPSBxW3ldO1xuICAgIGZvciAoeSA9IDI1MzsgeSA+PSAwOyB5LS0pXG4gICAgICBSKEwsIEwpLCB5ICE9PSAyICYmIHkgIT09IDQgJiYgXyhMLCBMLCBxKTtcbiAgICBmb3IgKHkgPSAwOyB5IDwgMTY7IHkrKylcbiAgICAgIENbeV0gPSBMW3ldO1xuICB9XG4gIGZ1bmN0aW9uIFEoQywgcSkge1xuICAgIGNvbnN0IEwgPSBuKCk7XG4gICAgbGV0IHk7XG4gICAgZm9yICh5ID0gMDsgeSA8IDE2OyB5KyspXG4gICAgICBMW3ldID0gcVt5XTtcbiAgICBmb3IgKHkgPSAyNTA7IHkgPj0gMDsgeS0tKVxuICAgICAgUihMLCBMKSwgeSAhPT0gMSAmJiBfKEwsIEwsIHEpO1xuICAgIGZvciAoeSA9IDA7IHkgPCAxNjsgeSsrKVxuICAgICAgQ1t5XSA9IExbeV07XG4gIH1cbiAgZnVuY3Rpb24gTyhDLCBxKSB7XG4gICAgY29uc3QgTCA9IG4oKSwgeSA9IG4oKSwgRiA9IG4oKSwgVyA9IG4oKSwgWSA9IG4oKSwgWCA9IG4oKSwgZWUgPSBuKCksIHdlID0gbigpLCBNZSA9IG4oKTtcbiAgICBCKEwsIENbMV0sIENbMF0pLCBCKE1lLCBxWzFdLCBxWzBdKSwgXyhMLCBMLCBNZSksIHooeSwgQ1swXSwgQ1sxXSksIHooTWUsIHFbMF0sIHFbMV0pLCBfKHksIHksIE1lKSwgXyhGLCBDWzNdLCBxWzNdKSwgXyhGLCBGLCBkKSwgXyhXLCBDWzJdLCBxWzJdKSwgeihXLCBXLCBXKSwgQihZLCB5LCBMKSwgQihYLCBXLCBGKSwgeihlZSwgVywgRiksIHood2UsIHksIEwpLCBfKENbMF0sIFksIFgpLCBfKENbMV0sIHdlLCBlZSksIF8oQ1syXSwgZWUsIFgpLCBfKENbM10sIFksIHdlKTtcbiAgfVxuICBmdW5jdGlvbiBwKEMsIHEsIEwpIHtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDQ7IHkrKylcbiAgICAgIE4oQ1t5XSwgcVt5XSwgTCk7XG4gIH1cbiAgZnVuY3Rpb24gbChDLCBxKSB7XG4gICAgY29uc3QgTCA9IG4oKSwgeSA9IG4oKSwgRiA9IG4oKTtcbiAgICBKKEYsIHFbMl0pLCBfKEwsIHFbMF0sIEYpLCBfKHksIHFbMV0sIEYpLCBrKEMsIHkpLCBDWzMxXSBePSBLKEwpIDw8IDc7XG4gIH1cbiAgZnVuY3Rpb24gYShDLCBxLCBMKSB7XG4gICAgSShDWzBdLCBvKSwgSShDWzFdLCBmKSwgSShDWzJdLCBmKSwgSShDWzNdLCBvKTtcbiAgICBmb3IgKGxldCB5ID0gMjU1OyB5ID49IDA7IC0teSkge1xuICAgICAgY29uc3QgRiA9IExbeSAvIDggfCAwXSA+PiAoeSAmIDcpICYgMTtcbiAgICAgIHAoQywgcSwgRiksIE8ocSwgQyksIE8oQywgQyksIHAoQywgcSwgRik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGMoQywgcSkge1xuICAgIGNvbnN0IEwgPSBbbigpLCBuKCksIG4oKSwgbigpXTtcbiAgICBJKExbMF0sIHYpLCBJKExbMV0sIHcpLCBJKExbMl0sIGYpLCBfKExbM10sIHYsIHcpLCBhKEMsIEwsIHEpO1xuICB9XG4gIGZ1bmN0aW9uIGIoQykge1xuICAgIGlmIChDLmxlbmd0aCAhPT0gci5TRUVEX0xFTkdUSClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZWQyNTUxOTogc2VlZCBtdXN0IGJlICR7ci5TRUVEX0xFTkdUSH0gYnl0ZXNgKTtcbiAgICBjb25zdCBxID0gKDAsIHQuaGFzaCkoQyk7XG4gICAgcVswXSAmPSAyNDgsIHFbMzFdICY9IDEyNywgcVszMV0gfD0gNjQ7XG4gICAgY29uc3QgTCA9IG5ldyBVaW50OEFycmF5KDMyKSwgeSA9IFtuKCksIG4oKSwgbigpLCBuKCldO1xuICAgIGMoeSwgcSksIGwoTCwgeSk7XG4gICAgY29uc3QgRiA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICByZXR1cm4gRi5zZXQoQyksIEYuc2V0KEwsIDMyKSwge1xuICAgICAgcHVibGljS2V5OiBMLFxuICAgICAgc2VjcmV0S2V5OiBGXG4gICAgfTtcbiAgfVxuICByLmdlbmVyYXRlS2V5UGFpckZyb21TZWVkID0gYjtcbiAgZnVuY3Rpb24gRShDKSB7XG4gICAgY29uc3QgcSA9ICgwLCBlLnJhbmRvbUJ5dGVzKSgzMiwgQyksIEwgPSBiKHEpO1xuICAgIHJldHVybiAoMCwgaS53aXBlKShxKSwgTDtcbiAgfVxuICByLmdlbmVyYXRlS2V5UGFpciA9IEU7XG4gIGZ1bmN0aW9uIFMoQykge1xuICAgIGlmIChDLmxlbmd0aCAhPT0gci5TRUNSRVRfS0VZX0xFTkdUSClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZWQyNTUxOTogc2VjcmV0IGtleSBtdXN0IGJlICR7ci5TRUNSRVRfS0VZX0xFTkdUSH0gYnl0ZXNgKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQy5zdWJhcnJheSgzMikpO1xuICB9XG4gIHIuZXh0cmFjdFB1YmxpY0tleUZyb21TZWNyZXRLZXkgPSBTO1xuICBjb25zdCB4ID0gbmV3IEZsb2F0NjRBcnJheShbXG4gICAgMjM3LFxuICAgIDIxMSxcbiAgICAyNDUsXG4gICAgOTIsXG4gICAgMjYsXG4gICAgOTksXG4gICAgMTgsXG4gICAgODgsXG4gICAgMjE0LFxuICAgIDE1NixcbiAgICAyNDcsXG4gICAgMTYyLFxuICAgIDIyMixcbiAgICAyNDksXG4gICAgMjIyLFxuICAgIDIwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDE2XG4gIF0pO1xuICBmdW5jdGlvbiB1KEMsIHEpIHtcbiAgICBsZXQgTCwgeSwgRiwgVztcbiAgICBmb3IgKHkgPSA2MzsgeSA+PSAzMjsgLS15KSB7XG4gICAgICBmb3IgKEwgPSAwLCBGID0geSAtIDMyLCBXID0geSAtIDEyOyBGIDwgVzsgKytGKVxuICAgICAgICBxW0ZdICs9IEwgLSAxNiAqIHFbeV0gKiB4W0YgLSAoeSAtIDMyKV0sIEwgPSBNYXRoLmZsb29yKChxW0ZdICsgMTI4KSAvIDI1NiksIHFbRl0gLT0gTCAqIDI1NjtcbiAgICAgIHFbRl0gKz0gTCwgcVt5XSA9IDA7XG4gICAgfVxuICAgIGZvciAoTCA9IDAsIEYgPSAwOyBGIDwgMzI7IEYrKylcbiAgICAgIHFbRl0gKz0gTCAtIChxWzMxXSA+PiA0KSAqIHhbRl0sIEwgPSBxW0ZdID4+IDgsIHFbRl0gJj0gMjU1O1xuICAgIGZvciAoRiA9IDA7IEYgPCAzMjsgRisrKVxuICAgICAgcVtGXSAtPSBMICogeFtGXTtcbiAgICBmb3IgKHkgPSAwOyB5IDwgMzI7IHkrKylcbiAgICAgIHFbeSArIDFdICs9IHFbeV0gPj4gOCwgQ1t5XSA9IHFbeV0gJiAyNTU7XG4gIH1cbiAgZnVuY3Rpb24gbShDKSB7XG4gICAgY29uc3QgcSA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpO1xuICAgIGZvciAobGV0IEwgPSAwOyBMIDwgNjQ7IEwrKylcbiAgICAgIHFbTF0gPSBDW0xdO1xuICAgIGZvciAobGV0IEwgPSAwOyBMIDwgNjQ7IEwrKylcbiAgICAgIENbTF0gPSAwO1xuICAgIHUoQywgcSk7XG4gIH1cbiAgZnVuY3Rpb24gZyhDLCBxKSB7XG4gICAgY29uc3QgTCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpLCB5ID0gW24oKSwgbigpLCBuKCksIG4oKV0sIEYgPSAoMCwgdC5oYXNoKShDLnN1YmFycmF5KDAsIDMyKSk7XG4gICAgRlswXSAmPSAyNDgsIEZbMzFdICY9IDEyNywgRlszMV0gfD0gNjQ7XG4gICAgY29uc3QgVyA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICBXLnNldChGLnN1YmFycmF5KDMyKSwgMzIpO1xuICAgIGNvbnN0IFkgPSBuZXcgdC5TSEE1MTIoKTtcbiAgICBZLnVwZGF0ZShXLnN1YmFycmF5KDMyKSksIFkudXBkYXRlKHEpO1xuICAgIGNvbnN0IFggPSBZLmRpZ2VzdCgpO1xuICAgIFkuY2xlYW4oKSwgbShYKSwgYyh5LCBYKSwgbChXLCB5KSwgWS5yZXNldCgpLCBZLnVwZGF0ZShXLnN1YmFycmF5KDAsIDMyKSksIFkudXBkYXRlKEMuc3ViYXJyYXkoMzIpKSwgWS51cGRhdGUocSk7XG4gICAgY29uc3QgZWUgPSBZLmRpZ2VzdCgpO1xuICAgIG0oZWUpO1xuICAgIGZvciAobGV0IHdlID0gMDsgd2UgPCAzMjsgd2UrKylcbiAgICAgIExbd2VdID0gWFt3ZV07XG4gICAgZm9yIChsZXQgd2UgPSAwOyB3ZSA8IDMyOyB3ZSsrKVxuICAgICAgZm9yIChsZXQgTWUgPSAwOyBNZSA8IDMyOyBNZSsrKVxuICAgICAgICBMW3dlICsgTWVdICs9IGVlW3dlXSAqIEZbTWVdO1xuICAgIHJldHVybiB1KFcuc3ViYXJyYXkoMzIpLCBMKSwgVztcbiAgfVxuICByLnNpZ24gPSBnO1xuICBmdW5jdGlvbiBQKEMsIHEpIHtcbiAgICBjb25zdCBMID0gbigpLCB5ID0gbigpLCBGID0gbigpLCBXID0gbigpLCBZID0gbigpLCBYID0gbigpLCBlZSA9IG4oKTtcbiAgICByZXR1cm4gSShDWzJdLCBmKSwgJChDWzFdLCBxKSwgUihGLCBDWzFdKSwgXyhXLCBGLCBoKSwgQihGLCBGLCBDWzJdKSwgeihXLCBDWzJdLCBXKSwgUihZLCBXKSwgUihYLCBZKSwgXyhlZSwgWCwgWSksIF8oTCwgZWUsIEYpLCBfKEwsIEwsIFcpLCBRKEwsIEwpLCBfKEwsIEwsIEYpLCBfKEwsIEwsIFcpLCBfKEwsIEwsIFcpLCBfKENbMF0sIEwsIFcpLCBSKHksIENbMF0pLCBfKHksIHksIFcpLCBUKHksIEYpICYmIF8oQ1swXSwgQ1swXSwgQSksIFIoeSwgQ1swXSksIF8oeSwgeSwgVyksIFQoeSwgRikgPyAtMSA6IChLKENbMF0pID09PSBxWzMxXSA+PiA3ICYmIEIoQ1swXSwgbywgQ1swXSksIF8oQ1szXSwgQ1swXSwgQ1sxXSksIDApO1xuICB9XG4gIGZ1bmN0aW9uIEcoQywgcSwgTCkge1xuICAgIGNvbnN0IHkgPSBuZXcgVWludDhBcnJheSgzMiksIEYgPSBbbigpLCBuKCksIG4oKSwgbigpXSwgVyA9IFtuKCksIG4oKSwgbigpLCBuKCldO1xuICAgIGlmIChMLmxlbmd0aCAhPT0gci5TSUdOQVRVUkVfTEVOR1RIKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBlZDI1NTE5OiBzaWduYXR1cmUgbXVzdCBiZSAke3IuU0lHTkFUVVJFX0xFTkdUSH0gYnl0ZXNgKTtcbiAgICBpZiAoUChXLCBDKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBZID0gbmV3IHQuU0hBNTEyKCk7XG4gICAgWS51cGRhdGUoTC5zdWJhcnJheSgwLCAzMikpLCBZLnVwZGF0ZShDKSwgWS51cGRhdGUocSk7XG4gICAgY29uc3QgWCA9IFkuZGlnZXN0KCk7XG4gICAgcmV0dXJuIG0oWCksIGEoRiwgVywgWCksIGMoVywgTC5zdWJhcnJheSgzMikpLCBPKEYsIFcpLCBsKHksIEYpLCAhaihMLCB5KTtcbiAgfVxuICByLnZlcmlmeSA9IEc7XG4gIGZ1bmN0aW9uIE0oQykge1xuICAgIGxldCBxID0gW24oKSwgbigpLCBuKCksIG4oKV07XG4gICAgaWYgKFAocSwgQykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFZDI1NTE5OiBpbnZhbGlkIHB1YmxpYyBrZXlcIik7XG4gICAgbGV0IEwgPSBuKCksIHkgPSBuKCksIEYgPSBxWzFdO1xuICAgIHooTCwgZiwgRiksIEIoeSwgZiwgRiksIEooeSwgeSksIF8oTCwgTCwgeSk7XG4gICAgbGV0IFcgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcmV0dXJuIGsoVywgTCksIFc7XG4gIH1cbiAgci5jb252ZXJ0UHVibGljS2V5VG9YMjU1MTkgPSBNO1xuICBmdW5jdGlvbiBIKEMpIHtcbiAgICBjb25zdCBxID0gKDAsIHQuaGFzaCkoQy5zdWJhcnJheSgwLCAzMikpO1xuICAgIHFbMF0gJj0gMjQ4LCBxWzMxXSAmPSAxMjcsIHFbMzFdIHw9IDY0O1xuICAgIGNvbnN0IEwgPSBuZXcgVWludDhBcnJheShxLnN1YmFycmF5KDAsIDMyKSk7XG4gICAgcmV0dXJuICgwLCBpLndpcGUpKHEpLCBMO1xuICB9XG4gIHIuY29udmVydFNlY3JldEtleVRvWDI1NTE5ID0gSDtcbn0pKENvKTtcbmNvbnN0IFZwID0gXCJFZERTQVwiLCBXcCA9IFwiSldUXCIsIHpzID0gXCIuXCIsIGNhID0gXCJiYXNlNjR1cmxcIiwgdHUgPSBcInV0ZjhcIiwgcnUgPSBcInV0ZjhcIiwgR3AgPSBcIjpcIiwgSnAgPSBcImRpZFwiLCBZcCA9IFwia2V5XCIsIEJmID0gXCJiYXNlNThidGNcIiwgWHAgPSBcInpcIiwgWnAgPSBcIkszNlwiLCBRcCA9IDMyO1xuZnVuY3Rpb24gaXUociA9IDApIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2NVbnNhZmUgIT0gbnVsbCA/IGdsb2JhbFRoaXMuQnVmZmVyLmFsbG9jVW5zYWZlKHIpIDogbmV3IFVpbnQ4QXJyYXkocik7XG59XG5mdW5jdGlvbiBEcyhyLCBlKSB7XG4gIGUgfHwgKGUgPSByLnJlZHVjZSgobiwgcykgPT4gbiArIHMubGVuZ3RoLCAwKSk7XG4gIGNvbnN0IHQgPSBpdShlKTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGNvbnN0IG4gb2YgcilcbiAgICB0LnNldChuLCBpKSwgaSArPSBuLmxlbmd0aDtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBlMShyLCBlKSB7XG4gIGlmIChyLmxlbmd0aCA+PSAyNTUpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFscGhhYmV0IHRvbyBsb25nXCIpO1xuICBmb3IgKHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KSwgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKVxuICAgIHRbaV0gPSAyNTU7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgci5sZW5ndGg7IG4rKykge1xuICAgIHZhciBzID0gci5jaGFyQXQobiksIG8gPSBzLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKHRbb10gIT09IDI1NSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyArIFwiIGlzIGFtYmlndW91c1wiKTtcbiAgICB0W29dID0gbjtcbiAgfVxuICB2YXIgZiA9IHIubGVuZ3RoLCBoID0gci5jaGFyQXQoMCksIGQgPSBNYXRoLmxvZyhmKSAvIE1hdGgubG9nKDI1NiksIHYgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coZik7XG4gIGZ1bmN0aW9uIHcoRCkge1xuICAgIGlmIChEIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KEQpID8gRCA9IG5ldyBVaW50OEFycmF5KEQuYnVmZmVyLCBELmJ5dGVPZmZzZXQsIEQuYnl0ZUxlbmd0aCkgOiBBcnJheS5pc0FycmF5KEQpICYmIChEID0gVWludDhBcnJheS5mcm9tKEQpKSksICEoRCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFVpbnQ4QXJyYXlcIik7XG4gICAgaWYgKEQubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgZm9yICh2YXIgTiA9IDAsIGsgPSAwLCBqID0gMCwgVCA9IEQubGVuZ3RoOyBqICE9PSBUICYmIERbal0gPT09IDA7IClcbiAgICAgIGorKywgTisrO1xuICAgIGZvciAodmFyIEsgPSAoVCAtIGopICogdiArIDEgPj4+IDAsICQgPSBuZXcgVWludDhBcnJheShLKTsgaiAhPT0gVDsgKSB7XG4gICAgICBmb3IgKHZhciB6ID0gRFtqXSwgQiA9IDAsIF8gPSBLIC0gMTsgKHogIT09IDAgfHwgQiA8IGspICYmIF8gIT09IC0xOyBfLS0sIEIrKylcbiAgICAgICAgeiArPSAyNTYgKiAkW19dID4+PiAwLCAkW19dID0geiAlIGYgPj4+IDAsIHogPSB6IC8gZiA+Pj4gMDtcbiAgICAgIGlmICh6ICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24temVybyBjYXJyeVwiKTtcbiAgICAgIGsgPSBCLCBqKys7XG4gICAgfVxuICAgIGZvciAodmFyIFIgPSBLIC0gazsgUiAhPT0gSyAmJiAkW1JdID09PSAwOyApXG4gICAgICBSKys7XG4gICAgZm9yICh2YXIgSiA9IGgucmVwZWF0KE4pOyBSIDwgSzsgKytSKVxuICAgICAgSiArPSByLmNoYXJBdCgkW1JdKTtcbiAgICByZXR1cm4gSjtcbiAgfVxuICBmdW5jdGlvbiBBKEQpIHtcbiAgICBpZiAodHlwZW9mIEQgIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBTdHJpbmdcIik7XG4gICAgaWYgKEQubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgdmFyIE4gPSAwO1xuICAgIGlmIChEW05dICE9PSBcIiBcIikge1xuICAgICAgZm9yICh2YXIgayA9IDAsIGogPSAwOyBEW05dID09PSBoOyApXG4gICAgICAgIGsrKywgTisrO1xuICAgICAgZm9yICh2YXIgVCA9IChELmxlbmd0aCAtIE4pICogZCArIDEgPj4+IDAsIEsgPSBuZXcgVWludDhBcnJheShUKTsgRFtOXTsgKSB7XG4gICAgICAgIHZhciAkID0gdFtELmNoYXJDb2RlQXQoTildO1xuICAgICAgICBpZiAoJCA9PT0gMjU1KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgeiA9IDAsIEIgPSBUIC0gMTsgKCQgIT09IDAgfHwgeiA8IGopICYmIEIgIT09IC0xOyBCLS0sIHorKylcbiAgICAgICAgICAkICs9IGYgKiBLW0JdID4+PiAwLCBLW0JdID0gJCAlIDI1NiA+Pj4gMCwgJCA9ICQgLyAyNTYgPj4+IDA7XG4gICAgICAgIGlmICgkICE9PSAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi16ZXJvIGNhcnJ5XCIpO1xuICAgICAgICBqID0geiwgTisrO1xuICAgICAgfVxuICAgICAgaWYgKERbTl0gIT09IFwiIFwiKSB7XG4gICAgICAgIGZvciAodmFyIF8gPSBUIC0gajsgXyAhPT0gVCAmJiBLW19dID09PSAwOyApXG4gICAgICAgICAgXysrO1xuICAgICAgICBmb3IgKHZhciBSID0gbmV3IFVpbnQ4QXJyYXkoayArIChUIC0gXykpLCBKID0gazsgXyAhPT0gVDsgKVxuICAgICAgICAgIFJbSisrXSA9IEtbXysrXTtcbiAgICAgICAgcmV0dXJuIFI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIEkoRCkge1xuICAgIHZhciBOID0gQShEKTtcbiAgICBpZiAoTilcbiAgICAgIHJldHVybiBOO1xuICAgIHRocm93IG5ldyBFcnJvcihgTm9uLSR7ZX0gY2hhcmFjdGVyYCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IHcsXG4gICAgZGVjb2RlVW5zYWZlOiBBLFxuICAgIGRlY29kZTogSVxuICB9O1xufVxudmFyIHQxID0gZTEsIHIxID0gdDE7XG5jb25zdCBpMSA9IChyKSA9PiB7XG4gIGlmIChyIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiByLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiVWludDhBcnJheVwiKVxuICAgIHJldHVybiByO1xuICBpZiAociBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyKTtcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhyKSlcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoci5idWZmZXIsIHIuYnl0ZU9mZnNldCwgci5ieXRlTGVuZ3RoKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlXCIpO1xufSwgbjEgPSAocikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHIpLCBzMSA9IChyKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUocik7XG5jbGFzcyBhMSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIGkpIHtcbiAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLnByZWZpeCA9IHQsIHRoaXMuYmFzZUVuY29kZSA9IGk7XG4gIH1cbiAgZW5jb2RlKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICByZXR1cm4gYCR7dGhpcy5wcmVmaXh9JHt0aGlzLmJhc2VFbmNvZGUoZSl9YDtcbiAgICB0aHJvdyBFcnJvcihcIlVua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZVwiKTtcbiAgfVxufVxuY2xhc3MgbzEge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBpKSB7XG4gICAgaWYgKHRoaXMubmFtZSA9IGUsIHRoaXMucHJlZml4ID0gdCwgdC5jb2RlUG9pbnRBdCgwKSA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcmVmaXggY2hhcmFjdGVyXCIpO1xuICAgIHRoaXMucHJlZml4Q29kZVBvaW50ID0gdC5jb2RlUG9pbnRBdCgwKSwgdGhpcy5iYXNlRGVjb2RlID0gaTtcbiAgfVxuICBkZWNvZGUoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoZS5jb2RlUG9pbnRBdCgwKSAhPT0gdGhpcy5wcmVmaXhDb2RlUG9pbnQpXG4gICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZGVjb2RlIG11bHRpYmFzZSBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShlKX0sICR7dGhpcy5uYW1lfSBkZWNvZGVyIG9ubHkgc3VwcG9ydHMgaW5wdXRzIHByZWZpeGVkIHdpdGggJHt0aGlzLnByZWZpeH1gKTtcbiAgICAgIHJldHVybiB0aGlzLmJhc2VEZWNvZGUoZS5zbGljZSh0aGlzLnByZWZpeC5sZW5ndGgpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IEVycm9yKFwiQ2FuIG9ubHkgbXVsdGliYXNlIGRlY29kZSBzdHJpbmdzXCIpO1xuICB9XG4gIG9yKGUpIHtcbiAgICByZXR1cm4gbnUodGhpcywgZSk7XG4gIH1cbn1cbmNsYXNzIGYxIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuZGVjb2RlcnMgPSBlO1xuICB9XG4gIG9yKGUpIHtcbiAgICByZXR1cm4gbnUodGhpcywgZSk7XG4gIH1cbiAgZGVjb2RlKGUpIHtcbiAgICBjb25zdCB0ID0gZVswXSwgaSA9IHRoaXMuZGVjb2RlcnNbdF07XG4gICAgaWYgKGkpXG4gICAgICByZXR1cm4gaS5kZWNvZGUoZSk7XG4gICAgdGhyb3cgUmFuZ2VFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkoZSl9LCBvbmx5IGlucHV0cyBwcmVmaXhlZCB3aXRoICR7T2JqZWN0LmtleXModGhpcy5kZWNvZGVycyl9IGFyZSBzdXBwb3J0ZWRgKTtcbiAgfVxufVxuY29uc3QgbnUgPSAociwgZSkgPT4gbmV3IGYxKHtcbiAgLi4uci5kZWNvZGVycyB8fCB7IFtyLnByZWZpeF06IHIgfSxcbiAgLi4uZS5kZWNvZGVycyB8fCB7IFtlLnByZWZpeF06IGUgfVxufSk7XG5jbGFzcyBjMSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIGksIG4pIHtcbiAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLnByZWZpeCA9IHQsIHRoaXMuYmFzZUVuY29kZSA9IGksIHRoaXMuYmFzZURlY29kZSA9IG4sIHRoaXMuZW5jb2RlciA9IG5ldyBhMShlLCB0LCBpKSwgdGhpcy5kZWNvZGVyID0gbmV3IG8xKGUsIHQsIG4pO1xuICB9XG4gIGVuY29kZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmNvZGUoZSk7XG4gIH1cbiAgZGVjb2RlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVyLmRlY29kZShlKTtcbiAgfVxufVxuY29uc3QgaGEgPSAoeyBuYW1lOiByLCBwcmVmaXg6IGUsIGVuY29kZTogdCwgZGVjb2RlOiBpIH0pID0+IG5ldyBjMShyLCBlLCB0LCBpKSwgcnMgPSAoeyBwcmVmaXg6IHIsIG5hbWU6IGUsIGFscGhhYmV0OiB0IH0pID0+IHtcbiAgY29uc3QgeyBlbmNvZGU6IGksIGRlY29kZTogbiB9ID0gcjEodCwgZSk7XG4gIHJldHVybiBoYSh7XG4gICAgcHJlZml4OiByLFxuICAgIG5hbWU6IGUsXG4gICAgZW5jb2RlOiBpLFxuICAgIGRlY29kZTogKHMpID0+IGkxKG4ocykpXG4gIH0pO1xufSwgaDEgPSAociwgZSwgdCwgaSkgPT4ge1xuICBjb25zdCBuID0ge307XG4gIGZvciAobGV0IHYgPSAwOyB2IDwgZS5sZW5ndGg7ICsrdilcbiAgICBuW2Vbdl1dID0gdjtcbiAgbGV0IHMgPSByLmxlbmd0aDtcbiAgZm9yICg7IHJbcyAtIDFdID09PSBcIj1cIjsgKVxuICAgIC0tcztcbiAgY29uc3QgbyA9IG5ldyBVaW50OEFycmF5KHMgKiB0IC8gOCB8IDApO1xuICBsZXQgZiA9IDAsIGggPSAwLCBkID0gMDtcbiAgZm9yIChsZXQgdiA9IDA7IHYgPCBzOyArK3YpIHtcbiAgICBjb25zdCB3ID0gbltyW3ZdXTtcbiAgICBpZiAodyA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBOb24tJHtpfSBjaGFyYWN0ZXJgKTtcbiAgICBoID0gaCA8PCB0IHwgdywgZiArPSB0LCBmID49IDggJiYgKGYgLT0gOCwgb1tkKytdID0gMjU1ICYgaCA+PiBmKTtcbiAgfVxuICBpZiAoZiA+PSB0IHx8IDI1NSAmIGggPDwgOCAtIGYpXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgZGF0YVwiKTtcbiAgcmV0dXJuIG87XG59LCB1MSA9IChyLCBlLCB0KSA9PiB7XG4gIGNvbnN0IGkgPSBlW2UubGVuZ3RoIC0gMV0gPT09IFwiPVwiLCBuID0gKDEgPDwgdCkgLSAxO1xuICBsZXQgcyA9IFwiXCIsIG8gPSAwLCBmID0gMDtcbiAgZm9yIChsZXQgaCA9IDA7IGggPCByLmxlbmd0aDsgKytoKVxuICAgIGZvciAoZiA9IGYgPDwgOCB8IHJbaF0sIG8gKz0gODsgbyA+IHQ7IClcbiAgICAgIG8gLT0gdCwgcyArPSBlW24gJiBmID4+IG9dO1xuICBpZiAobyAmJiAocyArPSBlW24gJiBmIDw8IHQgLSBvXSksIGkpXG4gICAgZm9yICg7IHMubGVuZ3RoICogdCAmIDc7IClcbiAgICAgIHMgKz0gXCI9XCI7XG4gIHJldHVybiBzO1xufSwgUnQgPSAoeyBuYW1lOiByLCBwcmVmaXg6IGUsIGJpdHNQZXJDaGFyOiB0LCBhbHBoYWJldDogaSB9KSA9PiBoYSh7XG4gIHByZWZpeDogZSxcbiAgbmFtZTogcixcbiAgZW5jb2RlKG4pIHtcbiAgICByZXR1cm4gdTEobiwgaSwgdCk7XG4gIH0sXG4gIGRlY29kZShuKSB7XG4gICAgcmV0dXJuIGgxKG4sIGksIHQsIHIpO1xuICB9XG59KSwgZDEgPSBoYSh7XG4gIHByZWZpeDogXCJcXDBcIixcbiAgbmFtZTogXCJpZGVudGl0eVwiLFxuICBlbmNvZGU6IChyKSA9PiBzMShyKSxcbiAgZGVjb2RlOiAocikgPT4gbjEocilcbn0pLCBsMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGlkZW50aXR5OiBkMVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgcDEgPSBSdCh7XG4gIHByZWZpeDogXCIwXCIsXG4gIG5hbWU6IFwiYmFzZTJcIixcbiAgYWxwaGFiZXQ6IFwiMDFcIixcbiAgYml0c1BlckNoYXI6IDFcbn0pLCB2MSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJhc2UyOiBwMVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgYjEgPSBSdCh7XG4gIHByZWZpeDogXCI3XCIsXG4gIG5hbWU6IFwiYmFzZThcIixcbiAgYWxwaGFiZXQ6IFwiMDEyMzQ1NjdcIixcbiAgYml0c1BlckNoYXI6IDNcbn0pLCBnMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJhc2U4OiBiMVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgeTEgPSBycyh7XG4gIHByZWZpeDogXCI5XCIsXG4gIG5hbWU6IFwiYmFzZTEwXCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlcIlxufSksIG0xID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYmFzZTEwOiB5MVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgdzEgPSBSdCh7XG4gIHByZWZpeDogXCJmXCIsXG4gIG5hbWU6IFwiYmFzZTE2XCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlhYmNkZWZcIixcbiAgYml0c1BlckNoYXI6IDRcbn0pLCBfMSA9IFJ0KHtcbiAgcHJlZml4OiBcIkZcIixcbiAgbmFtZTogXCJiYXNlMTZ1cHBlclwiLFxuICBhbHBoYWJldDogXCIwMTIzNDU2Nzg5QUJDREVGXCIsXG4gIGJpdHNQZXJDaGFyOiA0XG59KSwgeDEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBiYXNlMTY6IHcxLFxuICBiYXNlMTZ1cHBlcjogXzFcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIEUxID0gUnQoe1xuICBwcmVmaXg6IFwiYlwiLFxuICBuYW1lOiBcImJhc2UzMlwiLFxuICBhbHBoYWJldDogXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2N1wiLFxuICBiaXRzUGVyQ2hhcjogNVxufSksIFMxID0gUnQoe1xuICBwcmVmaXg6IFwiQlwiLFxuICBuYW1lOiBcImJhc2UzMnVwcGVyXCIsXG4gIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3XCIsXG4gIGJpdHNQZXJDaGFyOiA1XG59KSwgTTEgPSBSdCh7XG4gIHByZWZpeDogXCJjXCIsXG4gIG5hbWU6IFwiYmFzZTMycGFkXCIsXG4gIGFscGhhYmV0OiBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PVwiLFxuICBiaXRzUGVyQ2hhcjogNVxufSksIEkxID0gUnQoe1xuICBwcmVmaXg6IFwiQ1wiLFxuICBuYW1lOiBcImJhc2UzMnBhZHVwcGVyXCIsXG4gIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3PVwiLFxuICBiaXRzUGVyQ2hhcjogNVxufSksIEExID0gUnQoe1xuICBwcmVmaXg6IFwidlwiLFxuICBuYW1lOiBcImJhc2UzMmhleFwiLFxuICBhbHBoYWJldDogXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dlwiLFxuICBiaXRzUGVyQ2hhcjogNVxufSksIEQxID0gUnQoe1xuICBwcmVmaXg6IFwiVlwiLFxuICBuYW1lOiBcImJhc2UzMmhleHVwcGVyXCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWXCIsXG4gIGJpdHNQZXJDaGFyOiA1XG59KSwgUDEgPSBSdCh7XG4gIHByZWZpeDogXCJ0XCIsXG4gIG5hbWU6IFwiYmFzZTMyaGV4cGFkXCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2PVwiLFxuICBiaXRzUGVyQ2hhcjogNVxufSksIE8xID0gUnQoe1xuICBwcmVmaXg6IFwiVFwiLFxuICBuYW1lOiBcImJhc2UzMmhleHBhZHVwcGVyXCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWPVwiLFxuICBiaXRzUGVyQ2hhcjogNVxufSksIFIxID0gUnQoe1xuICBwcmVmaXg6IFwiaFwiLFxuICBuYW1lOiBcImJhc2UzMnpcIixcbiAgYWxwaGFiZXQ6IFwieWJuZHJmZzhlamttY3BxeG90MXV3aXN6YTM0NWg3NjlcIixcbiAgYml0c1BlckNoYXI6IDVcbn0pLCBOMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJhc2UzMjogRTEsXG4gIGJhc2UzMmhleDogQTEsXG4gIGJhc2UzMmhleHBhZDogUDEsXG4gIGJhc2UzMmhleHBhZHVwcGVyOiBPMSxcbiAgYmFzZTMyaGV4dXBwZXI6IEQxLFxuICBiYXNlMzJwYWQ6IE0xLFxuICBiYXNlMzJwYWR1cHBlcjogSTEsXG4gIGJhc2UzMnVwcGVyOiBTMSxcbiAgYmFzZTMyejogUjFcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIFQxID0gcnMoe1xuICBwcmVmaXg6IFwia1wiLFxuICBuYW1lOiBcImJhc2UzNlwiLFxuICBhbHBoYWJldDogXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIlxufSksIEMxID0gcnMoe1xuICBwcmVmaXg6IFwiS1wiLFxuICBuYW1lOiBcImJhc2UzNnVwcGVyXCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiXG59KSwgJDEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBiYXNlMzY6IFQxLFxuICBiYXNlMzZ1cHBlcjogQzFcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIEwxID0gcnMoe1xuICBuYW1lOiBcImJhc2U1OGJ0Y1wiLFxuICBwcmVmaXg6IFwielwiLFxuICBhbHBoYWJldDogXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCJcbn0pLCBGMSA9IHJzKHtcbiAgbmFtZTogXCJiYXNlNThmbGlja3JcIixcbiAgcHJlZml4OiBcIlpcIixcbiAgYWxwaGFiZXQ6IFwiMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWlwiXG59KSwgcTEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBiYXNlNThidGM6IEwxLFxuICBiYXNlNThmbGlja3I6IEYxXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBVMSA9IFJ0KHtcbiAgcHJlZml4OiBcIm1cIixcbiAgbmFtZTogXCJiYXNlNjRcIixcbiAgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLFxuICBiaXRzUGVyQ2hhcjogNlxufSksIHoxID0gUnQoe1xuICBwcmVmaXg6IFwiTVwiLFxuICBuYW1lOiBcImJhc2U2NHBhZFwiLFxuICBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLFxuICBiaXRzUGVyQ2hhcjogNlxufSksIEIxID0gUnQoe1xuICBwcmVmaXg6IFwidVwiLFxuICBuYW1lOiBcImJhc2U2NHVybFwiLFxuICBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fXCIsXG4gIGJpdHNQZXJDaGFyOiA2XG59KSwgazEgPSBSdCh7XG4gIHByZWZpeDogXCJVXCIsXG4gIG5hbWU6IFwiYmFzZTY0dXJscGFkXCIsXG4gIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV89XCIsXG4gIGJpdHNQZXJDaGFyOiA2XG59KSwgajEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBiYXNlNjQ6IFUxLFxuICBiYXNlNjRwYWQ6IHoxLFxuICBiYXNlNjR1cmw6IEIxLFxuICBiYXNlNjR1cmxwYWQ6IGsxXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBzdSA9IEFycmF5LmZyb20oXCLwn5qA8J+qkOKYhPCfm7Dwn4yM8J+MkfCfjJLwn4yT8J+MlPCfjJXwn4yW8J+Ml/CfjJjwn4yN8J+Mj/CfjI7wn5CJ4piA8J+Su/CflqXwn5K+8J+Sv/CfmILinaTwn5iN8J+ko/CfmIrwn5mP8J+SlfCfmK3wn5iY8J+RjfCfmIXwn5GP8J+YgfCflKXwn6Ww8J+SlPCfkpbwn5KZ8J+YovCfpJTwn5iG8J+ZhPCfkqrwn5iJ4pi68J+RjPCfpJfwn5Kc8J+YlPCfmI7wn5iH8J+MufCfpKbwn46J8J+SnuKcjOKcqPCfpLfwn5ix8J+YjPCfjLjwn5mM8J+Yi/Cfkpfwn5Ka8J+Yj/Cfkpvwn5mC8J+Sk/CfpKnwn5iE8J+YgPCflqTwn5iD8J+Sr/CfmYjwn5GH8J+OtvCfmJLwn6St4p2j8J+YnPCfkovwn5GA8J+YqvCfmJHwn5Kl8J+Zi/CfmJ7wn5ip8J+YofCfpKrwn5GK8J+ls/CfmKXwn6Sk8J+RifCfkoPwn5iz4pyL8J+YmvCfmJ3wn5i08J+Mn/CfmKzwn5mD8J+NgPCfjLfwn5i78J+Yk+KtkOKchfCfpbrwn4yI8J+YiPCfpJjwn5Km4pyU8J+Yo/Cfj4Pwn5KQ4pi58J+OivCfkpjwn5ig4pid8J+YlfCfjLrwn46C8J+Mu/CfmJDwn5aV8J+SnfCfmYrwn5i58J+Xo/Cfkqvwn5KA8J+RkfCfjrXwn6Se8J+Ym/CflLTwn5ik8J+MvPCfmKvimr3wn6SZ4piV8J+PhvCfpKvwn5GI8J+YrvCfmYbwn4278J+Ng/CfkLbwn5KB8J+YsvCfjL/wn6eh8J+OgeKaofCfjJ7wn46I4p2M4pyK8J+Ri/CfmLDwn6So8J+YtvCfpJ3wn5q28J+SsPCfjZPwn5Ki8J+kn/CfmYHwn5qo8J+SqPCfpKzinIjwn46A8J+NuvCfpJPwn5iZ8J+Sn/CfjLHwn5iW8J+RtvCfpbTilrbinqHinZPwn5KO8J+SuOKsh/CfmKjwn4ya8J+mi/CfmLfwn5W64pqg8J+ZhfCfmJ/wn5i18J+RjvCfpLLwn6Sg8J+kp/Cfk4zwn5S18J+ShfCfp5Dwn5C+8J+NkvCfmJfwn6SR8J+MivCfpK/wn5C34piO8J+Sp/CfmK/wn5KG8J+RhvCfjqTwn5mH8J+NkeKdhPCfjLTwn5Kj8J+QuPCfkozwn5ON8J+lgPCfpKLwn5GF8J+SofCfkqnwn5GQ8J+TuPCfkbvwn6SQ8J+krvCfjrzwn6W18J+aqfCfjY7wn42K8J+RvPCfko3wn5Oj8J+lglwiKSwgSzEgPSBzdS5yZWR1Y2UoKHIsIGUsIHQpID0+IChyW3RdID0gZSwgciksIFtdKSwgSDEgPSBzdS5yZWR1Y2UoKHIsIGUsIHQpID0+IChyW2UuY29kZVBvaW50QXQoMCldID0gdCwgciksIFtdKTtcbmZ1bmN0aW9uIFYxKHIpIHtcbiAgcmV0dXJuIHIucmVkdWNlKChlLCB0KSA9PiAoZSArPSBLMVt0XSwgZSksIFwiXCIpO1xufVxuZnVuY3Rpb24gVzEocikge1xuICBjb25zdCBlID0gW107XG4gIGZvciAoY29uc3QgdCBvZiByKSB7XG4gICAgY29uc3QgaSA9IEgxW3QuY29kZVBvaW50QXQoMCldO1xuICAgIGlmIChpID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi1iYXNlMjU2ZW1vamkgY2hhcmFjdGVyOiAke3R9YCk7XG4gICAgZS5wdXNoKGkpO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShlKTtcbn1cbmNvbnN0IEcxID0gaGEoe1xuICBwcmVmaXg6IFwi8J+agFwiLFxuICBuYW1lOiBcImJhc2UyNTZlbW9qaVwiLFxuICBlbmNvZGU6IFYxLFxuICBkZWNvZGU6IFcxXG59KSwgSjEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBiYXNlMjU2ZW1vamk6IEcxXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xubmV3IFRleHRFbmNvZGVyKCk7XG5uZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IGtmID0ge1xuICAuLi5sMSxcbiAgLi4udjEsXG4gIC4uLmcxLFxuICAuLi5tMSxcbiAgLi4ueDEsXG4gIC4uLk4xLFxuICAuLi4kMSxcbiAgLi4ucTEsXG4gIC4uLmoxLFxuICAuLi5KMVxufTtcbmZ1bmN0aW9uIGF1KHIsIGUsIHQsIGkpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiByLFxuICAgIHByZWZpeDogZSxcbiAgICBlbmNvZGVyOiB7XG4gICAgICBuYW1lOiByLFxuICAgICAgcHJlZml4OiBlLFxuICAgICAgZW5jb2RlOiB0XG4gICAgfSxcbiAgICBkZWNvZGVyOiB7IGRlY29kZTogaSB9XG4gIH07XG59XG5jb25zdCBqZiA9IGF1KFwidXRmOFwiLCBcInVcIiwgKHIpID0+IFwidVwiICsgbmV3IFRleHREZWNvZGVyKFwidXRmOFwiKS5kZWNvZGUociksIChyKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoci5zdWJzdHJpbmcoMSkpKSwgVWEgPSBhdShcImFzY2lpXCIsIFwiYVwiLCAocikgPT4ge1xuICBsZXQgZSA9IFwiYVwiO1xuICBmb3IgKGxldCB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspXG4gICAgZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJbdF0pO1xuICByZXR1cm4gZTtcbn0sIChyKSA9PiB7XG4gIHIgPSByLnN1YnN0cmluZygxKTtcbiAgY29uc3QgZSA9IGl1KHIubGVuZ3RoKTtcbiAgZm9yIChsZXQgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKVxuICAgIGVbdF0gPSByLmNoYXJDb2RlQXQodCk7XG4gIHJldHVybiBlO1xufSksIG91ID0ge1xuICB1dGY4OiBqZixcbiAgXCJ1dGYtOFwiOiBqZixcbiAgaGV4OiBrZi5iYXNlMTYsXG4gIGxhdGluMTogVWEsXG4gIGFzY2lpOiBVYSxcbiAgYmluYXJ5OiBVYSxcbiAgLi4ua2Zcbn07XG5mdW5jdGlvbiBNdChyLCBlID0gXCJ1dGY4XCIpIHtcbiAgY29uc3QgdCA9IG91W2VdO1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7ZX1cImApO1xuICByZXR1cm4gKGUgPT09IFwidXRmOFwiIHx8IGUgPT09IFwidXRmLThcIikgJiYgZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tICE9IG51bGwgPyBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKHIuYnVmZmVyLCByLmJ5dGVPZmZzZXQsIHIuYnl0ZUxlbmd0aCkudG9TdHJpbmcoXCJ1dGY4XCIpIDogdC5lbmNvZGVyLmVuY29kZShyKS5zdWJzdHJpbmcoMSk7XG59XG5mdW5jdGlvbiBTdChyLCBlID0gXCJ1dGY4XCIpIHtcbiAgY29uc3QgdCA9IG91W2VdO1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7ZX1cImApO1xuICByZXR1cm4gKGUgPT09IFwidXRmOFwiIHx8IGUgPT09IFwidXRmLThcIikgJiYgZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tICE9IG51bGwgPyBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKHIsIFwidXRmOFwiKSA6IHQuZGVjb2Rlci5kZWNvZGUoYCR7dC5wcmVmaXh9JHtyfWApO1xufVxuZnVuY3Rpb24gS2Yocikge1xuICByZXR1cm4gdW4oTXQoU3QociwgY2EpLCB0dSkpO1xufVxuZnVuY3Rpb24gQnMocikge1xuICByZXR1cm4gTXQoU3QoamkociksIHR1KSwgY2EpO1xufVxuZnVuY3Rpb24gZnUocikge1xuICBjb25zdCBlID0gU3QoWnAsIEJmKSwgdCA9IFhwICsgTXQoRHMoW2UsIHJdKSwgQmYpO1xuICByZXR1cm4gW0pwLCBZcCwgdF0uam9pbihHcCk7XG59XG5mdW5jdGlvbiBZMShyKSB7XG4gIHJldHVybiBNdChyLCBjYSk7XG59XG5mdW5jdGlvbiBYMShyKSB7XG4gIHJldHVybiBTdChyLCBjYSk7XG59XG5mdW5jdGlvbiBaMShyKSB7XG4gIHJldHVybiBTdChbQnMoci5oZWFkZXIpLCBCcyhyLnBheWxvYWQpXS5qb2luKHpzKSwgcnUpO1xufVxuZnVuY3Rpb24gUTEocikge1xuICByZXR1cm4gW1xuICAgIEJzKHIuaGVhZGVyKSxcbiAgICBCcyhyLnBheWxvYWQpLFxuICAgIFkxKHIuc2lnbmF0dXJlKVxuICBdLmpvaW4oenMpO1xufVxuZnVuY3Rpb24gYm8ocikge1xuICBjb25zdCBlID0gci5zcGxpdCh6cyksIHQgPSBLZihlWzBdKSwgaSA9IEtmKGVbMV0pLCBuID0gWDEoZVsyXSksIHMgPSBTdChlLnNsaWNlKDAsIDIpLmpvaW4oenMpLCBydSk7XG4gIHJldHVybiB7IGhlYWRlcjogdCwgcGF5bG9hZDogaSwgc2lnbmF0dXJlOiBuLCBkYXRhOiBzIH07XG59XG5mdW5jdGlvbiBIZihyID0gRWkucmFuZG9tQnl0ZXMoUXApKSB7XG4gIHJldHVybiBDby5nZW5lcmF0ZUtleVBhaXJGcm9tU2VlZChyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGV2KHIsIGUsIHQsIGksIG4gPSBpZS5mcm9tTWlsaXNlY29uZHMoRGF0ZS5ub3coKSkpIHtcbiAgY29uc3QgcyA9IHsgYWxnOiBWcCwgdHlwOiBXcCB9LCBvID0gZnUoaS5wdWJsaWNLZXkpLCBmID0gbiArIHQsIGggPSB7IGlzczogbywgc3ViOiByLCBhdWQ6IGUsIGlhdDogbiwgZXhwOiBmIH0sIGQgPSBaMSh7IGhlYWRlcjogcywgcGF5bG9hZDogaCB9KSwgdiA9IENvLnNpZ24oaS5zZWNyZXRLZXksIGQpO1xuICByZXR1cm4gUTEoeyBoZWFkZXI6IHMsIHBheWxvYWQ6IGgsIHNpZ25hdHVyZTogdiB9KTtcbn1cbnZhciBWZiA9IGdsb2JhbFRoaXMgJiYgZ2xvYmFsVGhpcy5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uKHIsIGUsIHQpIHtcbiAgaWYgKHQgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGUubGVuZ3RoLCBzOyBpIDwgbjsgaSsrKVxuICAgICAgKHMgfHwgIShpIGluIGUpKSAmJiAocyB8fCAocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUsIDAsIGkpKSwgc1tpXSA9IGVbaV0pO1xuICByZXR1cm4gci5jb25jYXQocyB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlKSk7XG59LCB0diA9IChcbiAgLyoqIEBjbGFzcyAqL1xuICBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiByKGUsIHQsIGkpIHtcbiAgICAgIHRoaXMubmFtZSA9IGUsIHRoaXMudmVyc2lvbiA9IHQsIHRoaXMub3MgPSBpLCB0aGlzLnR5cGUgPSBcImJyb3dzZXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH0oKVxuKSwgcnYgPSAoXG4gIC8qKiBAY2xhc3MgKi9cbiAgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gcihlKSB7XG4gICAgICB0aGlzLnZlcnNpb24gPSBlLCB0aGlzLnR5cGUgPSBcIm5vZGVcIiwgdGhpcy5uYW1lID0gXCJub2RlXCIsIHRoaXMub3MgPSBwcm9jZXNzLnBsYXRmb3JtO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfSgpXG4pLCBpdiA9IChcbiAgLyoqIEBjbGFzcyAqL1xuICBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiByKGUsIHQsIGksIG4pIHtcbiAgICAgIHRoaXMubmFtZSA9IGUsIHRoaXMudmVyc2lvbiA9IHQsIHRoaXMub3MgPSBpLCB0aGlzLmJvdCA9IG4sIHRoaXMudHlwZSA9IFwiYm90LWRldmljZVwiO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfSgpXG4pLCBudiA9IChcbiAgLyoqIEBjbGFzcyAqL1xuICBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiByKCkge1xuICAgICAgdGhpcy50eXBlID0gXCJib3RcIiwgdGhpcy5ib3QgPSAhMCwgdGhpcy5uYW1lID0gXCJib3RcIiwgdGhpcy52ZXJzaW9uID0gbnVsbCwgdGhpcy5vcyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9KClcbiksIHN2ID0gKFxuICAvKiogQGNsYXNzICovXG4gIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHIoKSB7XG4gICAgICB0aGlzLnR5cGUgPSBcInJlYWN0LW5hdGl2ZVwiLCB0aGlzLm5hbWUgPSBcInJlYWN0LW5hdGl2ZVwiLCB0aGlzLnZlcnNpb24gPSBudWxsLCB0aGlzLm9zID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH0oKVxuKSwgYXYgPSAvYWxleGF8Ym90fGNyYXdsKGVyfGluZyl8ZmFjZWJvb2tleHRlcm5hbGhpdHxmZWVkYnVybmVyfGdvb2dsZSB3ZWIgcHJldmlld3xuYWdpb3N8cG9zdHJhbmt8cGluZ2RvbXxzbHVycHxzcGlkZXJ8eWFob28hfHlhbmRleC8sIG92ID0gLyhudWhrfGN1cmx8R29vZ2xlYm90fFlhbW15Ym90fE9wZW5ib3R8U2x1cnB8TVNOQm90fEFza1xcIEplZXZlc1xcL1Rlb21hfGlhX2FyY2hpdmVyKS8sIFdmID0gMywgZnYgPSBbXG4gIFtcImFvbFwiLCAvQU9MU2hpZWxkXFwvKFswLTlcXC5fXSspL10sXG4gIFtcImVkZ2VcIiwgL0VkZ2VcXC8oWzAtOVxcLl9dKykvXSxcbiAgW1wiZWRnZS1pb3NcIiwgL0VkZ2lPU1xcLyhbMC05XFwuX10rKS9dLFxuICBbXCJ5YW5kZXhicm93c2VyXCIsIC9ZYUJyb3dzZXJcXC8oWzAtOVxcLl9dKykvXSxcbiAgW1wia2FrYW90YWxrXCIsIC9LQUtBT1RBTEtcXHMoWzAtOVxcLl0rKS9dLFxuICBbXCJzYW1zdW5nXCIsIC9TYW1zdW5nQnJvd3NlclxcLyhbMC05XFwuXSspL10sXG4gIFtcInNpbGtcIiwgL1xcYlNpbGtcXC8oWzAtOS5fLV0rKVxcYi9dLFxuICBbXCJtaXVpXCIsIC9NaXVpQnJvd3NlclxcLyhbMC05XFwuXSspJC9dLFxuICBbXCJiZWFrZXJcIiwgL0JlYWtlckJyb3dzZXJcXC8oWzAtOVxcLl0rKS9dLFxuICBbXCJlZGdlLWNocm9taXVtXCIsIC9FZGdBP1xcLyhbMC05XFwuXSspL10sXG4gIFtcbiAgICBcImNocm9taXVtLXdlYnZpZXdcIixcbiAgICAvKD8hQ2hyb20uKk9QUil3dlxcKS4qQ2hyb20oPzplfGl1bSlcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9cbiAgXSxcbiAgW1wiY2hyb21lXCIsIC8oPyFDaHJvbS4qT1BSKUNocm9tKD86ZXxpdW0pXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgW1wicGhhbnRvbWpzXCIsIC9QaGFudG9tSlNcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICBbXCJjcmlvc1wiLCAvQ3JpT1NcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICBbXCJmaXJlZm94XCIsIC9GaXJlZm94XFwvKFswLTlcXC5dKykoPzpcXHN8JCkvXSxcbiAgW1wiZnhpb3NcIiwgL0Z4aU9TXFwvKFswLTlcXC5dKykvXSxcbiAgW1wib3BlcmEtbWluaVwiLCAvT3BlcmEgTWluaS4qVmVyc2lvblxcLyhbMC05XFwuXSspL10sXG4gIFtcIm9wZXJhXCIsIC9PcGVyYVxcLyhbMC05XFwuXSspKD86XFxzfCQpL10sXG4gIFtcIm9wZXJhXCIsIC9PUFJcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICBbXCJwaWVcIiwgL15NaWNyb3NvZnQgUG9ja2V0IEludGVybmV0IEV4cGxvcmVyXFwvKFxcZCtcXC5cXGQrKSQvXSxcbiAgW1wicGllXCIsIC9eTW96aWxsYVxcL1xcZFxcLlxcZCtcXHNcXChjb21wYXRpYmxlO1xccyg/Ok1TUD9JRXxNU0ludGVybmV0IEV4cGxvcmVyKSAoXFxkK1xcLlxcZCspOy4qV2luZG93cyBDRS4qXFwpJC9dLFxuICBbXCJuZXRmcm9udFwiLCAvXk1vemlsbGFcXC9cXGRcXC5cXGQrLipOZXRGcm9udFxcLyhcXGQuXFxkKS9dLFxuICBbXCJpZVwiLCAvVHJpZGVudFxcLzdcXC4wLipydlxcOihbMC05XFwuXSspLipcXCkuKkdlY2tvJC9dLFxuICBbXCJpZVwiLCAvTVNJRVxccyhbMC05XFwuXSspOy4qVHJpZGVudFxcL1s0LTddLjAvXSxcbiAgW1wiaWVcIiwgL01TSUVcXHMoN1xcLjApL10sXG4gIFtcImJiMTBcIiwgL0JCMTA7XFxzVG91Y2guKlZlcnNpb25cXC8oWzAtOVxcLl0rKS9dLFxuICBbXCJhbmRyb2lkXCIsIC9BbmRyb2lkXFxzKFswLTlcXC5dKykvXSxcbiAgW1wiaW9zXCIsIC9WZXJzaW9uXFwvKFswLTlcXC5fXSspLipNb2JpbGUuKlNhZmFyaS4qL10sXG4gIFtcInNhZmFyaVwiLCAvVmVyc2lvblxcLyhbMC05XFwuX10rKS4qU2FmYXJpL10sXG4gIFtcImZhY2Vib29rXCIsIC9GQltBU11WXFwvKFswLTlcXC5dKykvXSxcbiAgW1wiaW5zdGFncmFtXCIsIC9JbnN0YWdyYW1cXHMoWzAtOVxcLl0rKS9dLFxuICBbXCJpb3Mtd2Vidmlld1wiLCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS4qTW9iaWxlL10sXG4gIFtcImlvcy13ZWJ2aWV3XCIsIC9BcHBsZVdlYktpdFxcLyhbMC05XFwuXSspLipHZWNrb1xcKSQvXSxcbiAgW1wiY3VybFwiLCAvXmN1cmxcXC8oWzAtOVxcLl0rKSQvXSxcbiAgW1wic2VhcmNoYm90XCIsIGF2XVxuXSwgR2YgPSBbXG4gIFtcImlPU1wiLCAvaVAoaG9uZXxvZHxhZCkvXSxcbiAgW1wiQW5kcm9pZCBPU1wiLCAvQW5kcm9pZC9dLFxuICBbXCJCbGFja0JlcnJ5IE9TXCIsIC9CbGFja0JlcnJ5fEJCMTAvXSxcbiAgW1wiV2luZG93cyBNb2JpbGVcIiwgL0lFTW9iaWxlL10sXG4gIFtcIkFtYXpvbiBPU1wiLCAvS2luZGxlL10sXG4gIFtcIldpbmRvd3MgMy4xMVwiLCAvV2luMTYvXSxcbiAgW1wiV2luZG93cyA5NVwiLCAvKFdpbmRvd3MgOTUpfChXaW45NSl8KFdpbmRvd3NfOTUpL10sXG4gIFtcIldpbmRvd3MgOThcIiwgLyhXaW5kb3dzIDk4KXwoV2luOTgpL10sXG4gIFtcIldpbmRvd3MgMjAwMFwiLCAvKFdpbmRvd3MgTlQgNS4wKXwoV2luZG93cyAyMDAwKS9dLFxuICBbXCJXaW5kb3dzIFhQXCIsIC8oV2luZG93cyBOVCA1LjEpfChXaW5kb3dzIFhQKS9dLFxuICBbXCJXaW5kb3dzIFNlcnZlciAyMDAzXCIsIC8oV2luZG93cyBOVCA1LjIpL10sXG4gIFtcIldpbmRvd3MgVmlzdGFcIiwgLyhXaW5kb3dzIE5UIDYuMCkvXSxcbiAgW1wiV2luZG93cyA3XCIsIC8oV2luZG93cyBOVCA2LjEpL10sXG4gIFtcIldpbmRvd3MgOFwiLCAvKFdpbmRvd3MgTlQgNi4yKS9dLFxuICBbXCJXaW5kb3dzIDguMVwiLCAvKFdpbmRvd3MgTlQgNi4zKS9dLFxuICBbXCJXaW5kb3dzIDEwXCIsIC8oV2luZG93cyBOVCAxMC4wKS9dLFxuICBbXCJXaW5kb3dzIE1FXCIsIC9XaW5kb3dzIE1FL10sXG4gIFtcIldpbmRvd3MgQ0VcIiwgL1dpbmRvd3MgQ0V8V2luQ0V8TWljcm9zb2Z0IFBvY2tldCBJbnRlcm5ldCBFeHBsb3Jlci9dLFxuICBbXCJPcGVuIEJTRFwiLCAvT3BlbkJTRC9dLFxuICBbXCJTdW4gT1NcIiwgL1N1bk9TL10sXG4gIFtcIkNocm9tZSBPU1wiLCAvQ3JPUy9dLFxuICBbXCJMaW51eFwiLCAvKExpbnV4KXwoWDExKS9dLFxuICBbXCJNYWMgT1NcIiwgLyhNYWNfUG93ZXJQQyl8KE1hY2ludG9zaCkvXSxcbiAgW1wiUU5YXCIsIC9RTlgvXSxcbiAgW1wiQmVPU1wiLCAvQmVPUy9dLFxuICBbXCJPUy8yXCIsIC9PU1xcLzIvXVxuXTtcbmZ1bmN0aW9uIGN1KHIpIHtcbiAgcmV0dXJuIHIgPyBKZihyKSA6IHR5cGVvZiBkb2N1bWVudCA+IFwidVwiICYmIHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiID8gbmV3IHN2KCkgOiB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgPyBKZihuYXZpZ2F0b3IudXNlckFnZW50KSA6IHV2KCk7XG59XG5mdW5jdGlvbiBjdihyKSB7XG4gIHJldHVybiByICE9PSBcIlwiICYmIGZ2LnJlZHVjZShmdW5jdGlvbihlLCB0KSB7XG4gICAgdmFyIGkgPSB0WzBdLCBuID0gdFsxXTtcbiAgICBpZiAoZSlcbiAgICAgIHJldHVybiBlO1xuICAgIHZhciBzID0gbi5leGVjKHIpO1xuICAgIHJldHVybiAhIXMgJiYgW2ksIHNdO1xuICB9LCAhMSk7XG59XG5mdW5jdGlvbiBKZihyKSB7XG4gIHZhciBlID0gY3Yocik7XG4gIGlmICghZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgdmFyIHQgPSBlWzBdLCBpID0gZVsxXTtcbiAgaWYgKHQgPT09IFwic2VhcmNoYm90XCIpXG4gICAgcmV0dXJuIG5ldyBudigpO1xuICB2YXIgbiA9IGlbMV0gJiYgaVsxXS5zcGxpdChcIi5cIikuam9pbihcIl9cIikuc3BsaXQoXCJfXCIpLnNsaWNlKDAsIDMpO1xuICBuID8gbi5sZW5ndGggPCBXZiAmJiAobiA9IFZmKFZmKFtdLCBuLCAhMCksIGR2KFdmIC0gbi5sZW5ndGgpLCAhMCkpIDogbiA9IFtdO1xuICB2YXIgcyA9IG4uam9pbihcIi5cIiksIG8gPSBodihyKSwgZiA9IG92LmV4ZWMocik7XG4gIHJldHVybiBmICYmIGZbMV0gPyBuZXcgaXYodCwgcywgbywgZlsxXSkgOiBuZXcgdHYodCwgcywgbyk7XG59XG5mdW5jdGlvbiBodihyKSB7XG4gIGZvciAodmFyIGUgPSAwLCB0ID0gR2YubGVuZ3RoOyBlIDwgdDsgZSsrKSB7XG4gICAgdmFyIGkgPSBHZltlXSwgbiA9IGlbMF0sIHMgPSBpWzFdLCBvID0gcy5leGVjKHIpO1xuICAgIGlmIChvKVxuICAgICAgcmV0dXJuIG47XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1digpIHtcbiAgdmFyIHIgPSB0eXBlb2YgcHJvY2VzcyA8IFwidVwiICYmIHByb2Nlc3MudmVyc2lvbjtcbiAgcmV0dXJuIHIgPyBuZXcgcnYocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDEpKSA6IG51bGw7XG59XG5mdW5jdGlvbiBkdihyKSB7XG4gIGZvciAodmFyIGUgPSBbXSwgdCA9IDA7IHQgPCByOyB0KyspXG4gICAgZS5wdXNoKFwiMFwiKTtcbiAgcmV0dXJuIGU7XG59XG52YXIgb3QgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShvdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xub3QuZ2V0TG9jYWxTdG9yYWdlID0gb3QuZ2V0TG9jYWxTdG9yYWdlT3JUaHJvdyA9IG90LmdldENyeXB0byA9IG90LmdldENyeXB0b09yVGhyb3cgPSBodSA9IG90LmdldExvY2F0aW9uID0gb3QuZ2V0TG9jYXRpb25PclRocm93ID0gJG8gPSBvdC5nZXROYXZpZ2F0b3IgPSBvdC5nZXROYXZpZ2F0b3JPclRocm93ID0gaXMgPSBvdC5nZXREb2N1bWVudCA9IG90LmdldERvY3VtZW50T3JUaHJvdyA9IG90LmdldEZyb21XaW5kb3dPclRocm93ID0gb3QuZ2V0RnJvbVdpbmRvdyA9IHZvaWQgMDtcbmZ1bmN0aW9uIEppKHIpIHtcbiAgbGV0IGU7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgdHlwZW9mIHdpbmRvd1tyXSA8IFwidVwiICYmIChlID0gd2luZG93W3JdKSwgZTtcbn1cbm90LmdldEZyb21XaW5kb3cgPSBKaTtcbmZ1bmN0aW9uIHluKHIpIHtcbiAgY29uc3QgZSA9IEppKHIpO1xuICBpZiAoIWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3J9IGlzIG5vdCBkZWZpbmVkIGluIFdpbmRvd2ApO1xuICByZXR1cm4gZTtcbn1cbm90LmdldEZyb21XaW5kb3dPclRocm93ID0geW47XG5mdW5jdGlvbiBsdigpIHtcbiAgcmV0dXJuIHluKFwiZG9jdW1lbnRcIik7XG59XG5vdC5nZXREb2N1bWVudE9yVGhyb3cgPSBsdjtcbmZ1bmN0aW9uIHB2KCkge1xuICByZXR1cm4gSmkoXCJkb2N1bWVudFwiKTtcbn1cbnZhciBpcyA9IG90LmdldERvY3VtZW50ID0gcHY7XG5mdW5jdGlvbiB2digpIHtcbiAgcmV0dXJuIHluKFwibmF2aWdhdG9yXCIpO1xufVxub3QuZ2V0TmF2aWdhdG9yT3JUaHJvdyA9IHZ2O1xuZnVuY3Rpb24gYnYoKSB7XG4gIHJldHVybiBKaShcIm5hdmlnYXRvclwiKTtcbn1cbnZhciAkbyA9IG90LmdldE5hdmlnYXRvciA9IGJ2O1xuZnVuY3Rpb24gZ3YoKSB7XG4gIHJldHVybiB5bihcImxvY2F0aW9uXCIpO1xufVxub3QuZ2V0TG9jYXRpb25PclRocm93ID0gZ3Y7XG5mdW5jdGlvbiB5digpIHtcbiAgcmV0dXJuIEppKFwibG9jYXRpb25cIik7XG59XG52YXIgaHUgPSBvdC5nZXRMb2NhdGlvbiA9IHl2O1xuZnVuY3Rpb24gbXYoKSB7XG4gIHJldHVybiB5bihcImNyeXB0b1wiKTtcbn1cbm90LmdldENyeXB0b09yVGhyb3cgPSBtdjtcbmZ1bmN0aW9uIHd2KCkge1xuICByZXR1cm4gSmkoXCJjcnlwdG9cIik7XG59XG5vdC5nZXRDcnlwdG8gPSB3djtcbmZ1bmN0aW9uIF92KCkge1xuICByZXR1cm4geW4oXCJsb2NhbFN0b3JhZ2VcIik7XG59XG5vdC5nZXRMb2NhbFN0b3JhZ2VPclRocm93ID0gX3Y7XG5mdW5jdGlvbiB4digpIHtcbiAgcmV0dXJuIEppKFwibG9jYWxTdG9yYWdlXCIpO1xufVxub3QuZ2V0TG9jYWxTdG9yYWdlID0geHY7XG52YXIgTG8gPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMbywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIHV1ID0gTG8uZ2V0V2luZG93TWV0YWRhdGEgPSB2b2lkIDA7XG5jb25zdCBZZiA9IG90O1xuZnVuY3Rpb24gRXYoKSB7XG4gIGxldCByLCBlO1xuICB0cnkge1xuICAgIHIgPSBZZi5nZXREb2N1bWVudE9yVGhyb3coKSwgZSA9IFlmLmdldExvY2F0aW9uT3JUaHJvdygpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiB0KCkge1xuICAgIGNvbnN0IHcgPSByLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGlua1wiKSwgQSA9IFtdO1xuICAgIGZvciAobGV0IEkgPSAwOyBJIDwgdy5sZW5ndGg7IEkrKykge1xuICAgICAgY29uc3QgRCA9IHdbSV0sIE4gPSBELmdldEF0dHJpYnV0ZShcInJlbFwiKTtcbiAgICAgIGlmIChOICYmIE4udG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiaWNvblwiKSA+IC0xKSB7XG4gICAgICAgIGNvbnN0IGsgPSBELmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICAgIGlmIChrKVxuICAgICAgICAgIGlmIChrLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImh0dHBzOlwiKSA9PT0gLTEgJiYgay50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJodHRwOlwiKSA9PT0gLTEgJiYgay5pbmRleE9mKFwiLy9cIikgIT09IDApIHtcbiAgICAgICAgICAgIGxldCBqID0gZS5wcm90b2NvbCArIFwiLy9cIiArIGUuaG9zdDtcbiAgICAgICAgICAgIGlmIChrLmluZGV4T2YoXCIvXCIpID09PSAwKVxuICAgICAgICAgICAgICBqICs9IGs7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgVCA9IGUucGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICBULnBvcCgpO1xuICAgICAgICAgICAgICBjb25zdCBLID0gVC5qb2luKFwiL1wiKTtcbiAgICAgICAgICAgICAgaiArPSBLICsgXCIvXCIgKyBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQS5wdXNoKGopO1xuICAgICAgICAgIH0gZWxzZSBpZiAoay5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBlLnByb3RvY29sICsgaztcbiAgICAgICAgICAgIEEucHVzaChqKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIEEucHVzaChrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEE7XG4gIH1cbiAgZnVuY3Rpb24gaSguLi53KSB7XG4gICAgY29uc3QgQSA9IHIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJtZXRhXCIpO1xuICAgIGZvciAobGV0IEkgPSAwOyBJIDwgQS5sZW5ndGg7IEkrKykge1xuICAgICAgY29uc3QgRCA9IEFbSV0sIE4gPSBbXCJpdGVtcHJvcFwiLCBcInByb3BlcnR5XCIsIFwibmFtZVwiXS5tYXAoKGspID0+IEQuZ2V0QXR0cmlidXRlKGspKS5maWx0ZXIoKGspID0+IGsgPyB3LmluY2x1ZGVzKGspIDogITEpO1xuICAgICAgaWYgKE4ubGVuZ3RoICYmIE4pIHtcbiAgICAgICAgY29uc3QgayA9IEQuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKTtcbiAgICAgICAgaWYgKGspXG4gICAgICAgICAgcmV0dXJuIGs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIG4oKSB7XG4gICAgbGV0IHcgPSBpKFwibmFtZVwiLCBcIm9nOnNpdGVfbmFtZVwiLCBcIm9nOnRpdGxlXCIsIFwidHdpdHRlcjp0aXRsZVwiKTtcbiAgICByZXR1cm4gdyB8fCAodyA9IHIudGl0bGUpLCB3O1xuICB9XG4gIGZ1bmN0aW9uIHMoKSB7XG4gICAgcmV0dXJuIGkoXCJkZXNjcmlwdGlvblwiLCBcIm9nOmRlc2NyaXB0aW9uXCIsIFwidHdpdHRlcjpkZXNjcmlwdGlvblwiLCBcImtleXdvcmRzXCIpO1xuICB9XG4gIGNvbnN0IG8gPSBuKCksIGYgPSBzKCksIGggPSBlLm9yaWdpbiwgZCA9IHQoKTtcbiAgcmV0dXJuIHtcbiAgICBkZXNjcmlwdGlvbjogZixcbiAgICB1cmw6IGgsXG4gICAgaWNvbnM6IGQsXG4gICAgbmFtZTogb1xuICB9O1xufVxudXUgPSBMby5nZXRXaW5kb3dNZXRhZGF0YSA9IEV2O1xudmFyIFluID0ge30sIFN2ID0gKHIpID0+IGVuY29kZVVSSUNvbXBvbmVudChyKS5yZXBsYWNlKC9bIScoKSpdL2csIChlKSA9PiBgJSR7ZS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfWApLCBkdSA9IFwiJVthLWYwLTldezJ9XCIsIFhmID0gbmV3IFJlZ0V4cChcIihcIiArIGR1ICsgXCIpfChbXiVdKz8pXCIsIFwiZ2lcIiksIFpmID0gbmV3IFJlZ0V4cChcIihcIiArIGR1ICsgXCIpK1wiLCBcImdpXCIpO1xuZnVuY3Rpb24gZ28ociwgZSkge1xuICB0cnkge1xuICAgIHJldHVybiBbZGVjb2RlVVJJQ29tcG9uZW50KHIuam9pbihcIlwiKSldO1xuICB9IGNhdGNoIHtcbiAgfVxuICBpZiAoci5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuIHI7XG4gIGUgPSBlIHx8IDE7XG4gIHZhciB0ID0gci5zbGljZSgwLCBlKSwgaSA9IHIuc2xpY2UoZSk7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmNhbGwoW10sIGdvKHQpLCBnbyhpKSk7XG59XG5mdW5jdGlvbiBNdihyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChyKTtcbiAgfSBjYXRjaCB7XG4gICAgZm9yICh2YXIgZSA9IHIubWF0Y2goWGYpIHx8IFtdLCB0ID0gMTsgdCA8IGUubGVuZ3RoOyB0KyspXG4gICAgICByID0gZ28oZSwgdCkuam9pbihcIlwiKSwgZSA9IHIubWF0Y2goWGYpIHx8IFtdO1xuICAgIHJldHVybiByO1xuICB9XG59XG5mdW5jdGlvbiBJdihyKSB7XG4gIGZvciAodmFyIGUgPSB7XG4gICAgXCIlRkUlRkZcIjogXCLvv73vv71cIixcbiAgICBcIiVGRiVGRVwiOiBcIu+/ve+/vVwiXG4gIH0sIHQgPSBaZi5leGVjKHIpOyB0OyApIHtcbiAgICB0cnkge1xuICAgICAgZVt0WzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudCh0WzBdKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHZhciBpID0gTXYodFswXSk7XG4gICAgICBpICE9PSB0WzBdICYmIChlW3RbMF1dID0gaSk7XG4gICAgfVxuICAgIHQgPSBaZi5leGVjKHIpO1xuICB9XG4gIGVbXCIlQzJcIl0gPSBcIu+/vVwiO1xuICBmb3IgKHZhciBuID0gT2JqZWN0LmtleXMoZSksIHMgPSAwOyBzIDwgbi5sZW5ndGg7IHMrKykge1xuICAgIHZhciBvID0gbltzXTtcbiAgICByID0gci5yZXBsYWNlKG5ldyBSZWdFeHAobywgXCJnXCIpLCBlW29dKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbnZhciBBdiA9IGZ1bmN0aW9uKHIpIHtcbiAgaWYgKHR5cGVvZiByICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGBlbmNvZGVkVVJJYCB0byBiZSBvZiB0eXBlIGBzdHJpbmdgLCBnb3QgYFwiICsgdHlwZW9mIHIgKyBcImBcIik7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHIgPSByLnJlcGxhY2UoL1xcKy9nLCBcIiBcIiksIGRlY29kZVVSSUNvbXBvbmVudChyKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIEl2KHIpO1xuICB9XG59LCBEdiA9IChyLCBlKSA9PiB7XG4gIGlmICghKHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHRoZSBhcmd1bWVudHMgdG8gYmUgb2YgdHlwZSBgc3RyaW5nYFwiKTtcbiAgaWYgKGUgPT09IFwiXCIpXG4gICAgcmV0dXJuIFtyXTtcbiAgY29uc3QgdCA9IHIuaW5kZXhPZihlKTtcbiAgcmV0dXJuIHQgPT09IC0xID8gW3JdIDogW1xuICAgIHIuc2xpY2UoMCwgdCksXG4gICAgci5zbGljZSh0ICsgZS5sZW5ndGgpXG4gIF07XG59LCBQdiA9IGZ1bmN0aW9uKHIsIGUpIHtcbiAgZm9yICh2YXIgdCA9IHt9LCBpID0gT2JqZWN0LmtleXMociksIG4gPSBBcnJheS5pc0FycmF5KGUpLCBzID0gMDsgcyA8IGkubGVuZ3RoOyBzKyspIHtcbiAgICB2YXIgbyA9IGlbc10sIGYgPSByW29dO1xuICAgIChuID8gZS5pbmRleE9mKG8pICE9PSAtMSA6IGUobywgZiwgcikpICYmICh0W29dID0gZik7XG4gIH1cbiAgcmV0dXJuIHQ7XG59O1xuKGZ1bmN0aW9uKHIpIHtcbiAgY29uc3QgZSA9IFN2LCB0ID0gQXYsIGkgPSBEdiwgbiA9IFB2LCBzID0gKFQpID0+IFQgPT0gbnVsbCwgbyA9IFN5bWJvbChcImVuY29kZUZyYWdtZW50SWRlbnRpZmllclwiKTtcbiAgZnVuY3Rpb24gZihUKSB7XG4gICAgc3dpdGNoIChULmFycmF5Rm9ybWF0KSB7XG4gICAgICBjYXNlIFwiaW5kZXhcIjpcbiAgICAgICAgcmV0dXJuIChLKSA9PiAoJCwgeikgPT4ge1xuICAgICAgICAgIGNvbnN0IEIgPSAkLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4geiA9PT0gdm9pZCAwIHx8IFQuc2tpcE51bGwgJiYgeiA9PT0gbnVsbCB8fCBULnNraXBFbXB0eVN0cmluZyAmJiB6ID09PSBcIlwiID8gJCA6IHogPT09IG51bGwgPyBbLi4uJCwgW3YoSywgVCksIFwiW1wiLCBCLCBcIl1cIl0uam9pbihcIlwiKV0gOiBbXG4gICAgICAgICAgICAuLi4kLFxuICAgICAgICAgICAgW3YoSywgVCksIFwiW1wiLCB2KEIsIFQpLCBcIl09XCIsIHYoeiwgVCldLmpvaW4oXCJcIilcbiAgICAgICAgICBdO1xuICAgICAgICB9O1xuICAgICAgY2FzZSBcImJyYWNrZXRcIjpcbiAgICAgICAgcmV0dXJuIChLKSA9PiAoJCwgeikgPT4geiA9PT0gdm9pZCAwIHx8IFQuc2tpcE51bGwgJiYgeiA9PT0gbnVsbCB8fCBULnNraXBFbXB0eVN0cmluZyAmJiB6ID09PSBcIlwiID8gJCA6IHogPT09IG51bGwgPyBbLi4uJCwgW3YoSywgVCksIFwiW11cIl0uam9pbihcIlwiKV0gOiBbLi4uJCwgW3YoSywgVCksIFwiW109XCIsIHYoeiwgVCldLmpvaW4oXCJcIildO1xuICAgICAgY2FzZSBcImNvbG9uLWxpc3Qtc2VwYXJhdG9yXCI6XG4gICAgICAgIHJldHVybiAoSykgPT4gKCQsIHopID0+IHogPT09IHZvaWQgMCB8fCBULnNraXBOdWxsICYmIHogPT09IG51bGwgfHwgVC5za2lwRW1wdHlTdHJpbmcgJiYgeiA9PT0gXCJcIiA/ICQgOiB6ID09PSBudWxsID8gWy4uLiQsIFt2KEssIFQpLCBcIjpsaXN0PVwiXS5qb2luKFwiXCIpXSA6IFsuLi4kLCBbdihLLCBUKSwgXCI6bGlzdD1cIiwgdih6LCBUKV0uam9pbihcIlwiKV07XG4gICAgICBjYXNlIFwiY29tbWFcIjpcbiAgICAgIGNhc2UgXCJzZXBhcmF0b3JcIjpcbiAgICAgIGNhc2UgXCJicmFja2V0LXNlcGFyYXRvclwiOiB7XG4gICAgICAgIGNvbnN0IEsgPSBULmFycmF5Rm9ybWF0ID09PSBcImJyYWNrZXQtc2VwYXJhdG9yXCIgPyBcIltdPVwiIDogXCI9XCI7XG4gICAgICAgIHJldHVybiAoJCkgPT4gKHosIEIpID0+IEIgPT09IHZvaWQgMCB8fCBULnNraXBOdWxsICYmIEIgPT09IG51bGwgfHwgVC5za2lwRW1wdHlTdHJpbmcgJiYgQiA9PT0gXCJcIiA/IHogOiAoQiA9IEIgPT09IG51bGwgPyBcIlwiIDogQiwgei5sZW5ndGggPT09IDAgPyBbW3YoJCwgVCksIEssIHYoQiwgVCldLmpvaW4oXCJcIildIDogW1t6LCB2KEIsIFQpXS5qb2luKFQuYXJyYXlGb3JtYXRTZXBhcmF0b3IpXSk7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKEspID0+ICgkLCB6KSA9PiB6ID09PSB2b2lkIDAgfHwgVC5za2lwTnVsbCAmJiB6ID09PSBudWxsIHx8IFQuc2tpcEVtcHR5U3RyaW5nICYmIHogPT09IFwiXCIgPyAkIDogeiA9PT0gbnVsbCA/IFsuLi4kLCB2KEssIFQpXSA6IFsuLi4kLCBbdihLLCBUKSwgXCI9XCIsIHYoeiwgVCldLmpvaW4oXCJcIildO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoKFQpIHtcbiAgICBsZXQgSztcbiAgICBzd2l0Y2ggKFQuYXJyYXlGb3JtYXQpIHtcbiAgICAgIGNhc2UgXCJpbmRleFwiOlxuICAgICAgICByZXR1cm4gKCQsIHosIEIpID0+IHtcbiAgICAgICAgICBpZiAoSyA9IC9cXFsoXFxkKilcXF0kLy5leGVjKCQpLCAkID0gJC5yZXBsYWNlKC9cXFtcXGQqXFxdJC8sIFwiXCIpLCAhSykge1xuICAgICAgICAgICAgQlskXSA9IHo7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIEJbJF0gPT09IHZvaWQgMCAmJiAoQlskXSA9IHt9KSwgQlskXVtLWzFdXSA9IHo7XG4gICAgICAgIH07XG4gICAgICBjYXNlIFwiYnJhY2tldFwiOlxuICAgICAgICByZXR1cm4gKCQsIHosIEIpID0+IHtcbiAgICAgICAgICBpZiAoSyA9IC8oXFxbXFxdKSQvLmV4ZWMoJCksICQgPSAkLnJlcGxhY2UoL1xcW1xcXSQvLCBcIlwiKSwgIUspIHtcbiAgICAgICAgICAgIEJbJF0gPSB6O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQlskXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBCWyRdID0gW3pdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBCWyRdID0gW10uY29uY2F0KEJbJF0sIHopO1xuICAgICAgICB9O1xuICAgICAgY2FzZSBcImNvbG9uLWxpc3Qtc2VwYXJhdG9yXCI6XG4gICAgICAgIHJldHVybiAoJCwgeiwgQikgPT4ge1xuICAgICAgICAgIGlmIChLID0gLyg6bGlzdCkkLy5leGVjKCQpLCAkID0gJC5yZXBsYWNlKC86bGlzdCQvLCBcIlwiKSwgIUspIHtcbiAgICAgICAgICAgIEJbJF0gPSB6O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQlskXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBCWyRdID0gW3pdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBCWyRdID0gW10uY29uY2F0KEJbJF0sIHopO1xuICAgICAgICB9O1xuICAgICAgY2FzZSBcImNvbW1hXCI6XG4gICAgICBjYXNlIFwic2VwYXJhdG9yXCI6XG4gICAgICAgIHJldHVybiAoJCwgeiwgQikgPT4ge1xuICAgICAgICAgIGNvbnN0IF8gPSB0eXBlb2YgeiA9PSBcInN0cmluZ1wiICYmIHouaW5jbHVkZXMoVC5hcnJheUZvcm1hdFNlcGFyYXRvciksIFIgPSB0eXBlb2YgeiA9PSBcInN0cmluZ1wiICYmICFfICYmIHcoeiwgVCkuaW5jbHVkZXMoVC5hcnJheUZvcm1hdFNlcGFyYXRvcik7XG4gICAgICAgICAgeiA9IFIgPyB3KHosIFQpIDogejtcbiAgICAgICAgICBjb25zdCBKID0gXyB8fCBSID8gei5zcGxpdChULmFycmF5Rm9ybWF0U2VwYXJhdG9yKS5tYXAoKFEpID0+IHcoUSwgVCkpIDogeiA9PT0gbnVsbCA/IHogOiB3KHosIFQpO1xuICAgICAgICAgIEJbJF0gPSBKO1xuICAgICAgICB9O1xuICAgICAgY2FzZSBcImJyYWNrZXQtc2VwYXJhdG9yXCI6XG4gICAgICAgIHJldHVybiAoJCwgeiwgQikgPT4ge1xuICAgICAgICAgIGNvbnN0IF8gPSAvKFxcW1xcXSkkLy50ZXN0KCQpO1xuICAgICAgICAgIGlmICgkID0gJC5yZXBsYWNlKC9cXFtcXF0kLywgXCJcIiksICFfKSB7XG4gICAgICAgICAgICBCWyRdID0geiAmJiB3KHosIFQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBSID0geiA9PT0gbnVsbCA/IFtdIDogei5zcGxpdChULmFycmF5Rm9ybWF0U2VwYXJhdG9yKS5tYXAoKEopID0+IHcoSiwgVCkpO1xuICAgICAgICAgIGlmIChCWyRdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIEJbJF0gPSBSO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBCWyRdID0gW10uY29uY2F0KEJbJF0sIFIpO1xuICAgICAgICB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICgkLCB6LCBCKSA9PiB7XG4gICAgICAgICAgaWYgKEJbJF0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgQlskXSA9IHo7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIEJbJF0gPSBbXS5jb25jYXQoQlskXSwgeik7XG4gICAgICAgIH07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQoVCkge1xuICAgIGlmICh0eXBlb2YgVCAhPSBcInN0cmluZ1wiIHx8IFQubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFycmF5Rm9ybWF0U2VwYXJhdG9yIG11c3QgYmUgc2luZ2xlIGNoYXJhY3RlciBzdHJpbmdcIik7XG4gIH1cbiAgZnVuY3Rpb24gdihULCBLKSB7XG4gICAgcmV0dXJuIEsuZW5jb2RlID8gSy5zdHJpY3QgPyBlKFQpIDogZW5jb2RlVVJJQ29tcG9uZW50KFQpIDogVDtcbiAgfVxuICBmdW5jdGlvbiB3KFQsIEspIHtcbiAgICByZXR1cm4gSy5kZWNvZGUgPyB0KFQpIDogVDtcbiAgfVxuICBmdW5jdGlvbiBBKFQpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShUKSA/IFQuc29ydCgpIDogdHlwZW9mIFQgPT0gXCJvYmplY3RcIiA/IEEoT2JqZWN0LmtleXMoVCkpLnNvcnQoKEssICQpID0+IE51bWJlcihLKSAtIE51bWJlcigkKSkubWFwKChLKSA9PiBUW0tdKSA6IFQ7XG4gIH1cbiAgZnVuY3Rpb24gSShUKSB7XG4gICAgY29uc3QgSyA9IFQuaW5kZXhPZihcIiNcIik7XG4gICAgcmV0dXJuIEsgIT09IC0xICYmIChUID0gVC5zbGljZSgwLCBLKSksIFQ7XG4gIH1cbiAgZnVuY3Rpb24gRChUKSB7XG4gICAgbGV0IEsgPSBcIlwiO1xuICAgIGNvbnN0ICQgPSBULmluZGV4T2YoXCIjXCIpO1xuICAgIHJldHVybiAkICE9PSAtMSAmJiAoSyA9IFQuc2xpY2UoJCkpLCBLO1xuICB9XG4gIGZ1bmN0aW9uIE4oVCkge1xuICAgIFQgPSBJKFQpO1xuICAgIGNvbnN0IEsgPSBULmluZGV4T2YoXCI/XCIpO1xuICAgIHJldHVybiBLID09PSAtMSA/IFwiXCIgOiBULnNsaWNlKEsgKyAxKTtcbiAgfVxuICBmdW5jdGlvbiBrKFQsIEspIHtcbiAgICByZXR1cm4gSy5wYXJzZU51bWJlcnMgJiYgIU51bWJlci5pc05hTihOdW1iZXIoVCkpICYmIHR5cGVvZiBUID09IFwic3RyaW5nXCIgJiYgVC50cmltKCkgIT09IFwiXCIgPyBUID0gTnVtYmVyKFQpIDogSy5wYXJzZUJvb2xlYW5zICYmIFQgIT09IG51bGwgJiYgKFQudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCIgfHwgVC50b0xvd2VyQ2FzZSgpID09PSBcImZhbHNlXCIpICYmIChUID0gVC50b0xvd2VyQ2FzZSgpID09PSBcInRydWVcIiksIFQ7XG4gIH1cbiAgZnVuY3Rpb24gaihULCBLKSB7XG4gICAgSyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZGVjb2RlOiAhMCxcbiAgICAgIHNvcnQ6ICEwLFxuICAgICAgYXJyYXlGb3JtYXQ6IFwibm9uZVwiLFxuICAgICAgYXJyYXlGb3JtYXRTZXBhcmF0b3I6IFwiLFwiLFxuICAgICAgcGFyc2VOdW1iZXJzOiAhMSxcbiAgICAgIHBhcnNlQm9vbGVhbnM6ICExXG4gICAgfSwgSyksIGQoSy5hcnJheUZvcm1hdFNlcGFyYXRvcik7XG4gICAgY29uc3QgJCA9IGgoSyksIHogPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAodHlwZW9mIFQgIT0gXCJzdHJpbmdcIiB8fCAoVCA9IFQudHJpbSgpLnJlcGxhY2UoL15bPyMmXS8sIFwiXCIpLCAhVCkpXG4gICAgICByZXR1cm4gejtcbiAgICBmb3IgKGNvbnN0IEIgb2YgVC5zcGxpdChcIiZcIikpIHtcbiAgICAgIGlmIChCID09PSBcIlwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGxldCBbXywgUl0gPSBpKEsuZGVjb2RlID8gQi5yZXBsYWNlKC9cXCsvZywgXCIgXCIpIDogQiwgXCI9XCIpO1xuICAgICAgUiA9IFIgPT09IHZvaWQgMCA/IG51bGwgOiBbXCJjb21tYVwiLCBcInNlcGFyYXRvclwiLCBcImJyYWNrZXQtc2VwYXJhdG9yXCJdLmluY2x1ZGVzKEsuYXJyYXlGb3JtYXQpID8gUiA6IHcoUiwgSyksICQodyhfLCBLKSwgUiwgeik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgQiBvZiBPYmplY3Qua2V5cyh6KSkge1xuICAgICAgY29uc3QgXyA9IHpbQl07XG4gICAgICBpZiAodHlwZW9mIF8gPT0gXCJvYmplY3RcIiAmJiBfICE9PSBudWxsKVxuICAgICAgICBmb3IgKGNvbnN0IFIgb2YgT2JqZWN0LmtleXMoXykpXG4gICAgICAgICAgX1tSXSA9IGsoX1tSXSwgSyk7XG4gICAgICBlbHNlXG4gICAgICAgIHpbQl0gPSBrKF8sIEspO1xuICAgIH1cbiAgICByZXR1cm4gSy5zb3J0ID09PSAhMSA/IHogOiAoSy5zb3J0ID09PSAhMCA/IE9iamVjdC5rZXlzKHopLnNvcnQoKSA6IE9iamVjdC5rZXlzKHopLnNvcnQoSy5zb3J0KSkucmVkdWNlKChCLCBfKSA9PiB7XG4gICAgICBjb25zdCBSID0geltfXTtcbiAgICAgIHJldHVybiBSICYmIHR5cGVvZiBSID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoUikgPyBCW19dID0gQShSKSA6IEJbX10gPSBSLCBCO1xuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgfVxuICByLmV4dHJhY3QgPSBOLCByLnBhcnNlID0gaiwgci5zdHJpbmdpZnkgPSAoVCwgSykgPT4ge1xuICAgIGlmICghVClcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIEsgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGVuY29kZTogITAsXG4gICAgICBzdHJpY3Q6ICEwLFxuICAgICAgYXJyYXlGb3JtYXQ6IFwibm9uZVwiLFxuICAgICAgYXJyYXlGb3JtYXRTZXBhcmF0b3I6IFwiLFwiXG4gICAgfSwgSyksIGQoSy5hcnJheUZvcm1hdFNlcGFyYXRvcik7XG4gICAgY29uc3QgJCA9IChSKSA9PiBLLnNraXBOdWxsICYmIHMoVFtSXSkgfHwgSy5za2lwRW1wdHlTdHJpbmcgJiYgVFtSXSA9PT0gXCJcIiwgeiA9IGYoSyksIEIgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFIgb2YgT2JqZWN0LmtleXMoVCkpXG4gICAgICAkKFIpIHx8IChCW1JdID0gVFtSXSk7XG4gICAgY29uc3QgXyA9IE9iamVjdC5rZXlzKEIpO1xuICAgIHJldHVybiBLLnNvcnQgIT09ICExICYmIF8uc29ydChLLnNvcnQpLCBfLm1hcCgoUikgPT4ge1xuICAgICAgY29uc3QgSiA9IFRbUl07XG4gICAgICByZXR1cm4gSiA9PT0gdm9pZCAwID8gXCJcIiA6IEogPT09IG51bGwgPyB2KFIsIEspIDogQXJyYXkuaXNBcnJheShKKSA/IEoubGVuZ3RoID09PSAwICYmIEsuYXJyYXlGb3JtYXQgPT09IFwiYnJhY2tldC1zZXBhcmF0b3JcIiA/IHYoUiwgSykgKyBcIltdXCIgOiBKLnJlZHVjZSh6KFIpLCBbXSkuam9pbihcIiZcIikgOiB2KFIsIEspICsgXCI9XCIgKyB2KEosIEspO1xuICAgIH0pLmZpbHRlcigoUikgPT4gUi5sZW5ndGggPiAwKS5qb2luKFwiJlwiKTtcbiAgfSwgci5wYXJzZVVybCA9IChULCBLKSA9PiB7XG4gICAgSyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZGVjb2RlOiAhMFxuICAgIH0sIEspO1xuICAgIGNvbnN0IFskLCB6XSA9IGkoVCwgXCIjXCIpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICB1cmw6ICQuc3BsaXQoXCI/XCIpWzBdIHx8IFwiXCIsXG4gICAgICAgIHF1ZXJ5OiBqKE4oVCksIEspXG4gICAgICB9LFxuICAgICAgSyAmJiBLLnBhcnNlRnJhZ21lbnRJZGVudGlmaWVyICYmIHogPyB7IGZyYWdtZW50SWRlbnRpZmllcjogdyh6LCBLKSB9IDoge31cbiAgICApO1xuICB9LCByLnN0cmluZ2lmeVVybCA9IChULCBLKSA9PiB7XG4gICAgSyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZW5jb2RlOiAhMCxcbiAgICAgIHN0cmljdDogITAsXG4gICAgICBbb106ICEwXG4gICAgfSwgSyk7XG4gICAgY29uc3QgJCA9IEkoVC51cmwpLnNwbGl0KFwiP1wiKVswXSB8fCBcIlwiLCB6ID0gci5leHRyYWN0KFQudXJsKSwgQiA9IHIucGFyc2UoeiwgeyBzb3J0OiAhMSB9KSwgXyA9IE9iamVjdC5hc3NpZ24oQiwgVC5xdWVyeSk7XG4gICAgbGV0IFIgPSByLnN0cmluZ2lmeShfLCBLKTtcbiAgICBSICYmIChSID0gYD8ke1J9YCk7XG4gICAgbGV0IEogPSBEKFQudXJsKTtcbiAgICByZXR1cm4gVC5mcmFnbWVudElkZW50aWZpZXIgJiYgKEogPSBgIyR7S1tvXSA/IHYoVC5mcmFnbWVudElkZW50aWZpZXIsIEspIDogVC5mcmFnbWVudElkZW50aWZpZXJ9YCksIGAkeyR9JHtSfSR7Sn1gO1xuICB9LCByLnBpY2sgPSAoVCwgSywgJCkgPT4ge1xuICAgICQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHBhcnNlRnJhZ21lbnRJZGVudGlmaWVyOiAhMCxcbiAgICAgIFtvXTogITFcbiAgICB9LCAkKTtcbiAgICBjb25zdCB7IHVybDogeiwgcXVlcnk6IEIsIGZyYWdtZW50SWRlbnRpZmllcjogXyB9ID0gci5wYXJzZVVybChULCAkKTtcbiAgICByZXR1cm4gci5zdHJpbmdpZnlVcmwoe1xuICAgICAgdXJsOiB6LFxuICAgICAgcXVlcnk6IG4oQiwgSyksXG4gICAgICBmcmFnbWVudElkZW50aWZpZXI6IF9cbiAgICB9LCAkKTtcbiAgfSwgci5leGNsdWRlID0gKFQsIEssICQpID0+IHtcbiAgICBjb25zdCB6ID0gQXJyYXkuaXNBcnJheShLKSA/IChCKSA9PiAhSy5pbmNsdWRlcyhCKSA6IChCLCBfKSA9PiAhSyhCLCBfKTtcbiAgICByZXR1cm4gci5waWNrKFQsIHosICQpO1xuICB9O1xufSkoWW4pO1xudmFyIGx1ID0geyBleHBvcnRzOiB7fSB9O1xuLyoqXG4gKiBbanMtc2hhM117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEzfVxuICpcbiAqIEB2ZXJzaW9uIDAuOC4wXG4gKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxuICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE1LTIwMThcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4oZnVuY3Rpb24ocikge1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSBcImlucHV0IGlzIGludmFsaWQgdHlwZVwiLCB0ID0gXCJmaW5hbGl6ZSBhbHJlYWR5IGNhbGxlZFwiLCBpID0gdHlwZW9mIHdpbmRvdyA9PSBcIm9iamVjdFwiLCBuID0gaSA/IHdpbmRvdyA6IHt9O1xuICAgIG4uSlNfU0hBM19OT19XSU5ET1cgJiYgKGkgPSAhMSk7XG4gICAgdmFyIHMgPSAhaSAmJiB0eXBlb2Ygc2VsZiA9PSBcIm9iamVjdFwiLCBvID0gIW4uSlNfU0hBM19OT19OT0RFX0pTICYmIHR5cGVvZiBwcm9jZXNzID09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gICAgbyA/IG4gPSB0ciA6IHMgJiYgKG4gPSBzZWxmKTtcbiAgICB2YXIgZiA9ICFuLkpTX1NIQTNfTk9fQ09NTU9OX0pTICYmICEwICYmIHIuZXhwb3J0cywgaCA9ICFuLkpTX1NIQTNfTk9fQVJSQVlfQlVGRkVSICYmIHR5cGVvZiBBcnJheUJ1ZmZlciA8IFwidVwiLCBkID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCIuc3BsaXQoXCJcIiksIHYgPSBbMzEsIDc5MzYsIDIwMzE2MTYsIDUyMDA5MzY5Nl0sIHcgPSBbNCwgMTAyNCwgMjYyMTQ0LCA2NzEwODg2NF0sIEEgPSBbMSwgMjU2LCA2NTUzNiwgMTY3NzcyMTZdLCBJID0gWzYsIDE1MzYsIDM5MzIxNiwgMTAwNjYzMjk2XSwgRCA9IFswLCA4LCAxNiwgMjRdLCBOID0gW1xuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAzMjg5OCxcbiAgICAgIDAsXG4gICAgICAzMjkwNixcbiAgICAgIDIxNDc0ODM2NDgsXG4gICAgICAyMTQ3NTE2NDE2LFxuICAgICAgMjE0NzQ4MzY0OCxcbiAgICAgIDMyOTA3LFxuICAgICAgMCxcbiAgICAgIDIxNDc0ODM2NDksXG4gICAgICAwLFxuICAgICAgMjE0NzUxNjU0NSxcbiAgICAgIDIxNDc0ODM2NDgsXG4gICAgICAzMjc3NyxcbiAgICAgIDIxNDc0ODM2NDgsXG4gICAgICAxMzgsXG4gICAgICAwLFxuICAgICAgMTM2LFxuICAgICAgMCxcbiAgICAgIDIxNDc1MTY0MjUsXG4gICAgICAwLFxuICAgICAgMjE0NzQ4MzY1OCxcbiAgICAgIDAsXG4gICAgICAyMTQ3NTE2NTU1LFxuICAgICAgMCxcbiAgICAgIDEzOSxcbiAgICAgIDIxNDc0ODM2NDgsXG4gICAgICAzMjkwNSxcbiAgICAgIDIxNDc0ODM2NDgsXG4gICAgICAzMjc3MSxcbiAgICAgIDIxNDc0ODM2NDgsXG4gICAgICAzMjc3MCxcbiAgICAgIDIxNDc0ODM2NDgsXG4gICAgICAxMjgsXG4gICAgICAyMTQ3NDgzNjQ4LFxuICAgICAgMzI3NzgsXG4gICAgICAwLFxuICAgICAgMjE0NzQ4MzY1OCxcbiAgICAgIDIxNDc0ODM2NDgsXG4gICAgICAyMTQ3NTE2NTQ1LFxuICAgICAgMjE0NzQ4MzY0OCxcbiAgICAgIDMyODk2LFxuICAgICAgMjE0NzQ4MzY0OCxcbiAgICAgIDIxNDc0ODM2NDksXG4gICAgICAwLFxuICAgICAgMjE0NzUxNjQyNCxcbiAgICAgIDIxNDc0ODM2NDhcbiAgICBdLCBrID0gWzIyNCwgMjU2LCAzODQsIDUxMl0sIGogPSBbMTI4LCAyNTZdLCBUID0gW1wiaGV4XCIsIFwiYnVmZmVyXCIsIFwiYXJyYXlCdWZmZXJcIiwgXCJhcnJheVwiLCBcImRpZ2VzdFwiXSwgSyA9IHtcbiAgICAgIDEyODogMTY4LFxuICAgICAgMjU2OiAxMzZcbiAgICB9O1xuICAgIChuLkpTX1NIQTNfTk9fTk9ERV9KUyB8fCAhQXJyYXkuaXNBcnJheSkgJiYgKEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbihNKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKE0pID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfSksIGggJiYgKG4uSlNfU0hBM19OT19BUlJBWV9CVUZGRVJfSVNfVklFVyB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3ID0gZnVuY3Rpb24oTSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBNID09IFwib2JqZWN0XCIgJiYgTS5idWZmZXIgJiYgTS5idWZmZXIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyO1xuICAgIH0pO1xuICAgIGZvciAodmFyICQgPSBmdW5jdGlvbihNLCBILCBDKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocSkge1xuICAgICAgICByZXR1cm4gbmV3IGcoTSwgSCwgTSkudXBkYXRlKHEpW0NdKCk7XG4gICAgICB9O1xuICAgIH0sIHogPSBmdW5jdGlvbihNLCBILCBDKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocSwgTCkge1xuICAgICAgICByZXR1cm4gbmV3IGcoTSwgSCwgTCkudXBkYXRlKHEpW0NdKCk7XG4gICAgICB9O1xuICAgIH0sIEIgPSBmdW5jdGlvbihNLCBILCBDKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocSwgTCwgeSwgRikge1xuICAgICAgICByZXR1cm4gYVtcImNzaGFrZVwiICsgTV0udXBkYXRlKHEsIEwsIHksIEYpW0NdKCk7XG4gICAgICB9O1xuICAgIH0sIF8gPSBmdW5jdGlvbihNLCBILCBDKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocSwgTCwgeSwgRikge1xuICAgICAgICByZXR1cm4gYVtcImttYWNcIiArIE1dLnVwZGF0ZShxLCBMLCB5LCBGKVtDXSgpO1xuICAgICAgfTtcbiAgICB9LCBSID0gZnVuY3Rpb24oTSwgSCwgQywgcSkge1xuICAgICAgZm9yICh2YXIgTCA9IDA7IEwgPCBULmxlbmd0aDsgKytMKSB7XG4gICAgICAgIHZhciB5ID0gVFtMXTtcbiAgICAgICAgTVt5XSA9IEgoQywgcSwgeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTTtcbiAgICB9LCBKID0gZnVuY3Rpb24oTSwgSCkge1xuICAgICAgdmFyIEMgPSAkKE0sIEgsIFwiaGV4XCIpO1xuICAgICAgcmV0dXJuIEMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgZyhNLCBILCBNKTtcbiAgICAgIH0sIEMudXBkYXRlID0gZnVuY3Rpb24ocSkge1xuICAgICAgICByZXR1cm4gQy5jcmVhdGUoKS51cGRhdGUocSk7XG4gICAgICB9LCBSKEMsICQsIE0sIEgpO1xuICAgIH0sIFEgPSBmdW5jdGlvbihNLCBIKSB7XG4gICAgICB2YXIgQyA9IHooTSwgSCwgXCJoZXhcIik7XG4gICAgICByZXR1cm4gQy5jcmVhdGUgPSBmdW5jdGlvbihxKSB7XG4gICAgICAgIHJldHVybiBuZXcgZyhNLCBILCBxKTtcbiAgICAgIH0sIEMudXBkYXRlID0gZnVuY3Rpb24ocSwgTCkge1xuICAgICAgICByZXR1cm4gQy5jcmVhdGUoTCkudXBkYXRlKHEpO1xuICAgICAgfSwgUihDLCB6LCBNLCBIKTtcbiAgICB9LCBPID0gZnVuY3Rpb24oTSwgSCkge1xuICAgICAgdmFyIEMgPSBLW01dLCBxID0gQihNLCBILCBcImhleFwiKTtcbiAgICAgIHJldHVybiBxLmNyZWF0ZSA9IGZ1bmN0aW9uKEwsIHksIEYpIHtcbiAgICAgICAgcmV0dXJuICF5ICYmICFGID8gYVtcInNoYWtlXCIgKyBNXS5jcmVhdGUoTCkgOiBuZXcgZyhNLCBILCBMKS5ieXRlcGFkKFt5LCBGXSwgQyk7XG4gICAgICB9LCBxLnVwZGF0ZSA9IGZ1bmN0aW9uKEwsIHksIEYsIFcpIHtcbiAgICAgICAgcmV0dXJuIHEuY3JlYXRlKHksIEYsIFcpLnVwZGF0ZShMKTtcbiAgICAgIH0sIFIocSwgQiwgTSwgSCk7XG4gICAgfSwgcCA9IGZ1bmN0aW9uKE0sIEgpIHtcbiAgICAgIHZhciBDID0gS1tNXSwgcSA9IF8oTSwgSCwgXCJoZXhcIik7XG4gICAgICByZXR1cm4gcS5jcmVhdGUgPSBmdW5jdGlvbihMLCB5LCBGKSB7XG4gICAgICAgIHJldHVybiBuZXcgUChNLCBILCB5KS5ieXRlcGFkKFtcIktNQUNcIiwgRl0sIEMpLmJ5dGVwYWQoW0xdLCBDKTtcbiAgICAgIH0sIHEudXBkYXRlID0gZnVuY3Rpb24oTCwgeSwgRiwgVykge1xuICAgICAgICByZXR1cm4gcS5jcmVhdGUoTCwgRiwgVykudXBkYXRlKHkpO1xuICAgICAgfSwgUihxLCBfLCBNLCBIKTtcbiAgICB9LCBsID0gW1xuICAgICAgeyBuYW1lOiBcImtlY2Nha1wiLCBwYWRkaW5nOiBBLCBiaXRzOiBrLCBjcmVhdGVNZXRob2Q6IEogfSxcbiAgICAgIHsgbmFtZTogXCJzaGEzXCIsIHBhZGRpbmc6IEksIGJpdHM6IGssIGNyZWF0ZU1ldGhvZDogSiB9LFxuICAgICAgeyBuYW1lOiBcInNoYWtlXCIsIHBhZGRpbmc6IHYsIGJpdHM6IGosIGNyZWF0ZU1ldGhvZDogUSB9LFxuICAgICAgeyBuYW1lOiBcImNzaGFrZVwiLCBwYWRkaW5nOiB3LCBiaXRzOiBqLCBjcmVhdGVNZXRob2Q6IE8gfSxcbiAgICAgIHsgbmFtZTogXCJrbWFjXCIsIHBhZGRpbmc6IHcsIGJpdHM6IGosIGNyZWF0ZU1ldGhvZDogcCB9XG4gICAgXSwgYSA9IHt9LCBjID0gW10sIGIgPSAwOyBiIDwgbC5sZW5ndGg7ICsrYilcbiAgICAgIGZvciAodmFyIEUgPSBsW2JdLCBTID0gRS5iaXRzLCB4ID0gMDsgeCA8IFMubGVuZ3RoOyArK3gpIHtcbiAgICAgICAgdmFyIHUgPSBFLm5hbWUgKyBcIl9cIiArIFNbeF07XG4gICAgICAgIGlmIChjLnB1c2godSksIGFbdV0gPSBFLmNyZWF0ZU1ldGhvZChTW3hdLCBFLnBhZGRpbmcpLCBFLm5hbWUgIT09IFwic2hhM1wiKSB7XG4gICAgICAgICAgdmFyIG0gPSBFLm5hbWUgKyBTW3hdO1xuICAgICAgICAgIGMucHVzaChtKSwgYVttXSA9IGFbdV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBmdW5jdGlvbiBnKE0sIEgsIEMpIHtcbiAgICAgIHRoaXMuYmxvY2tzID0gW10sIHRoaXMucyA9IFtdLCB0aGlzLnBhZGRpbmcgPSBILCB0aGlzLm91dHB1dEJpdHMgPSBDLCB0aGlzLnJlc2V0ID0gITAsIHRoaXMuZmluYWxpemVkID0gITEsIHRoaXMuYmxvY2sgPSAwLCB0aGlzLnN0YXJ0ID0gMCwgdGhpcy5ibG9ja0NvdW50ID0gMTYwMCAtIChNIDw8IDEpID4+IDUsIHRoaXMuYnl0ZUNvdW50ID0gdGhpcy5ibG9ja0NvdW50IDw8IDIsIHRoaXMub3V0cHV0QmxvY2tzID0gQyA+PiA1LCB0aGlzLmV4dHJhQnl0ZXMgPSAoQyAmIDMxKSA+PiAzO1xuICAgICAgZm9yICh2YXIgcSA9IDA7IHEgPCA1MDsgKytxKVxuICAgICAgICB0aGlzLnNbcV0gPSAwO1xuICAgIH1cbiAgICBnLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihNKSB7XG4gICAgICBpZiAodGhpcy5maW5hbGl6ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICAgIHZhciBILCBDID0gdHlwZW9mIE07XG4gICAgICBpZiAoQyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoQyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmIChNID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgICAgICAgIGlmIChoICYmIE0uY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKVxuICAgICAgICAgICAgTSA9IG5ldyBVaW50OEFycmF5KE0pO1xuICAgICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KE0pICYmICghaCB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KE0pKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgICAgICBIID0gITA7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBxID0gdGhpcy5ibG9ja3MsIEwgPSB0aGlzLmJ5dGVDb3VudCwgeSA9IE0ubGVuZ3RoLCBGID0gdGhpcy5ibG9ja0NvdW50LCBXID0gMCwgWSA9IHRoaXMucywgWCwgZWU7IFcgPCB5OyApIHtcbiAgICAgICAgaWYgKHRoaXMucmVzZXQpXG4gICAgICAgICAgZm9yICh0aGlzLnJlc2V0ID0gITEsIHFbMF0gPSB0aGlzLmJsb2NrLCBYID0gMTsgWCA8IEYgKyAxOyArK1gpXG4gICAgICAgICAgICBxW1hdID0gMDtcbiAgICAgICAgaWYgKEgpXG4gICAgICAgICAgZm9yIChYID0gdGhpcy5zdGFydDsgVyA8IHkgJiYgWCA8IEw7ICsrVylcbiAgICAgICAgICAgIHFbWCA+PiAyXSB8PSBNW1ddIDw8IERbWCsrICYgM107XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKFggPSB0aGlzLnN0YXJ0OyBXIDwgeSAmJiBYIDwgTDsgKytXKVxuICAgICAgICAgICAgZWUgPSBNLmNoYXJDb2RlQXQoVyksIGVlIDwgMTI4ID8gcVtYID4+IDJdIHw9IGVlIDw8IERbWCsrICYgM10gOiBlZSA8IDIwNDggPyAocVtYID4+IDJdIHw9ICgxOTIgfCBlZSA+PiA2KSA8PCBEW1grKyAmIDNdLCBxW1ggPj4gMl0gfD0gKDEyOCB8IGVlICYgNjMpIDw8IERbWCsrICYgM10pIDogZWUgPCA1NTI5NiB8fCBlZSA+PSA1NzM0NCA/IChxW1ggPj4gMl0gfD0gKDIyNCB8IGVlID4+IDEyKSA8PCBEW1grKyAmIDNdLCBxW1ggPj4gMl0gfD0gKDEyOCB8IGVlID4+IDYgJiA2MykgPDwgRFtYKysgJiAzXSwgcVtYID4+IDJdIHw9ICgxMjggfCBlZSAmIDYzKSA8PCBEW1grKyAmIDNdKSA6IChlZSA9IDY1NTM2ICsgKChlZSAmIDEwMjMpIDw8IDEwIHwgTS5jaGFyQ29kZUF0KCsrVykgJiAxMDIzKSwgcVtYID4+IDJdIHw9ICgyNDAgfCBlZSA+PiAxOCkgPDwgRFtYKysgJiAzXSwgcVtYID4+IDJdIHw9ICgxMjggfCBlZSA+PiAxMiAmIDYzKSA8PCBEW1grKyAmIDNdLCBxW1ggPj4gMl0gfD0gKDEyOCB8IGVlID4+IDYgJiA2MykgPDwgRFtYKysgJiAzXSwgcVtYID4+IDJdIHw9ICgxMjggfCBlZSAmIDYzKSA8PCBEW1grKyAmIDNdKTtcbiAgICAgICAgaWYgKHRoaXMubGFzdEJ5dGVJbmRleCA9IFgsIFggPj0gTCkge1xuICAgICAgICAgIGZvciAodGhpcy5zdGFydCA9IFggLSBMLCB0aGlzLmJsb2NrID0gcVtGXSwgWCA9IDA7IFggPCBGOyArK1gpXG4gICAgICAgICAgICBZW1hdIF49IHFbWF07XG4gICAgICAgICAgRyhZKSwgdGhpcy5yZXNldCA9ICEwO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0gWDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGcucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKE0sIEgpIHtcbiAgICAgIHZhciBDID0gTSAmIDI1NSwgcSA9IDEsIEwgPSBbQ107XG4gICAgICBmb3IgKE0gPSBNID4+IDgsIEMgPSBNICYgMjU1OyBDID4gMDsgKVxuICAgICAgICBMLnVuc2hpZnQoQyksIE0gPSBNID4+IDgsIEMgPSBNICYgMjU1LCArK3E7XG4gICAgICByZXR1cm4gSCA/IEwucHVzaChxKSA6IEwudW5zaGlmdChxKSwgdGhpcy51cGRhdGUoTCksIEwubGVuZ3RoO1xuICAgIH0sIGcucHJvdG90eXBlLmVuY29kZVN0cmluZyA9IGZ1bmN0aW9uKE0pIHtcbiAgICAgIHZhciBILCBDID0gdHlwZW9mIE07XG4gICAgICBpZiAoQyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoQyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmIChNID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgICAgICAgIGlmIChoICYmIE0uY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKVxuICAgICAgICAgICAgTSA9IG5ldyBVaW50OEFycmF5KE0pO1xuICAgICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KE0pICYmICghaCB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KE0pKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgICAgICBIID0gITA7XG4gICAgICB9XG4gICAgICB2YXIgcSA9IDAsIEwgPSBNLmxlbmd0aDtcbiAgICAgIGlmIChIKVxuICAgICAgICBxID0gTDtcbiAgICAgIGVsc2VcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBNLmxlbmd0aDsgKyt5KSB7XG4gICAgICAgICAgdmFyIEYgPSBNLmNoYXJDb2RlQXQoeSk7XG4gICAgICAgICAgRiA8IDEyOCA/IHEgKz0gMSA6IEYgPCAyMDQ4ID8gcSArPSAyIDogRiA8IDU1Mjk2IHx8IEYgPj0gNTczNDQgPyBxICs9IDMgOiAoRiA9IDY1NTM2ICsgKChGICYgMTAyMykgPDwgMTAgfCBNLmNoYXJDb2RlQXQoKyt5KSAmIDEwMjMpLCBxICs9IDQpO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gcSArPSB0aGlzLmVuY29kZShxICogOCksIHRoaXMudXBkYXRlKE0pLCBxO1xuICAgIH0sIGcucHJvdG90eXBlLmJ5dGVwYWQgPSBmdW5jdGlvbihNLCBIKSB7XG4gICAgICBmb3IgKHZhciBDID0gdGhpcy5lbmNvZGUoSCksIHEgPSAwOyBxIDwgTS5sZW5ndGg7ICsrcSlcbiAgICAgICAgQyArPSB0aGlzLmVuY29kZVN0cmluZyhNW3FdKTtcbiAgICAgIHZhciBMID0gSCAtIEMgJSBILCB5ID0gW107XG4gICAgICByZXR1cm4geS5sZW5ndGggPSBMLCB0aGlzLnVwZGF0ZSh5KSwgdGhpcztcbiAgICB9LCBnLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICB0aGlzLmZpbmFsaXplZCA9ICEwO1xuICAgICAgICB2YXIgTSA9IHRoaXMuYmxvY2tzLCBIID0gdGhpcy5sYXN0Qnl0ZUluZGV4LCBDID0gdGhpcy5ibG9ja0NvdW50LCBxID0gdGhpcy5zO1xuICAgICAgICBpZiAoTVtIID4+IDJdIHw9IHRoaXMucGFkZGluZ1tIICYgM10sIHRoaXMubGFzdEJ5dGVJbmRleCA9PT0gdGhpcy5ieXRlQ291bnQpXG4gICAgICAgICAgZm9yIChNWzBdID0gTVtDXSwgSCA9IDE7IEggPCBDICsgMTsgKytIKVxuICAgICAgICAgICAgTVtIXSA9IDA7XG4gICAgICAgIGZvciAoTVtDIC0gMV0gfD0gMjE0NzQ4MzY0OCwgSCA9IDA7IEggPCBDOyArK0gpXG4gICAgICAgICAgcVtIXSBePSBNW0hdO1xuICAgICAgICBHKHEpO1xuICAgICAgfVxuICAgIH0sIGcucHJvdG90eXBlLnRvU3RyaW5nID0gZy5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICBmb3IgKHZhciBNID0gdGhpcy5ibG9ja0NvdW50LCBIID0gdGhpcy5zLCBDID0gdGhpcy5vdXRwdXRCbG9ja3MsIHEgPSB0aGlzLmV4dHJhQnl0ZXMsIEwgPSAwLCB5ID0gMCwgRiA9IFwiXCIsIFc7IHkgPCBDOyApIHtcbiAgICAgICAgZm9yIChMID0gMDsgTCA8IE0gJiYgeSA8IEM7ICsrTCwgKyt5KVxuICAgICAgICAgIFcgPSBIW0xdLCBGICs9IGRbVyA+PiA0ICYgMTVdICsgZFtXICYgMTVdICsgZFtXID4+IDEyICYgMTVdICsgZFtXID4+IDggJiAxNV0gKyBkW1cgPj4gMjAgJiAxNV0gKyBkW1cgPj4gMTYgJiAxNV0gKyBkW1cgPj4gMjggJiAxNV0gKyBkW1cgPj4gMjQgJiAxNV07XG4gICAgICAgIHkgJSBNID09PSAwICYmIChHKEgpLCBMID0gMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcSAmJiAoVyA9IEhbTF0sIEYgKz0gZFtXID4+IDQgJiAxNV0gKyBkW1cgJiAxNV0sIHEgPiAxICYmIChGICs9IGRbVyA+PiAxMiAmIDE1XSArIGRbVyA+PiA4ICYgMTVdKSwgcSA+IDIgJiYgKEYgKz0gZFtXID4+IDIwICYgMTVdICsgZFtXID4+IDE2ICYgMTVdKSksIEY7XG4gICAgfSwgZy5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICAgIHZhciBNID0gdGhpcy5ibG9ja0NvdW50LCBIID0gdGhpcy5zLCBDID0gdGhpcy5vdXRwdXRCbG9ja3MsIHEgPSB0aGlzLmV4dHJhQnl0ZXMsIEwgPSAwLCB5ID0gMCwgRiA9IHRoaXMub3V0cHV0Qml0cyA+PiAzLCBXO1xuICAgICAgcSA/IFcgPSBuZXcgQXJyYXlCdWZmZXIoQyArIDEgPDwgMikgOiBXID0gbmV3IEFycmF5QnVmZmVyKEYpO1xuICAgICAgZm9yICh2YXIgWSA9IG5ldyBVaW50MzJBcnJheShXKTsgeSA8IEM7ICkge1xuICAgICAgICBmb3IgKEwgPSAwOyBMIDwgTSAmJiB5IDwgQzsgKytMLCArK3kpXG4gICAgICAgICAgWVt5XSA9IEhbTF07XG4gICAgICAgIHkgJSBNID09PSAwICYmIEcoSCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcSAmJiAoWVtMXSA9IEhbTF0sIFcgPSBXLnNsaWNlKDAsIEYpKSwgVztcbiAgICB9LCBnLnByb3RvdHlwZS5idWZmZXIgPSBnLnByb3RvdHlwZS5hcnJheUJ1ZmZlciwgZy5wcm90b3R5cGUuZGlnZXN0ID0gZy5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICAgIGZvciAodmFyIE0gPSB0aGlzLmJsb2NrQ291bnQsIEggPSB0aGlzLnMsIEMgPSB0aGlzLm91dHB1dEJsb2NrcywgcSA9IHRoaXMuZXh0cmFCeXRlcywgTCA9IDAsIHkgPSAwLCBGID0gW10sIFcsIFk7IHkgPCBDOyApIHtcbiAgICAgICAgZm9yIChMID0gMDsgTCA8IE0gJiYgeSA8IEM7ICsrTCwgKyt5KVxuICAgICAgICAgIFcgPSB5IDw8IDIsIFkgPSBIW0xdLCBGW1ddID0gWSAmIDI1NSwgRltXICsgMV0gPSBZID4+IDggJiAyNTUsIEZbVyArIDJdID0gWSA+PiAxNiAmIDI1NSwgRltXICsgM10gPSBZID4+IDI0ICYgMjU1O1xuICAgICAgICB5ICUgTSA9PT0gMCAmJiBHKEgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHEgJiYgKFcgPSB5IDw8IDIsIFkgPSBIW0xdLCBGW1ddID0gWSAmIDI1NSwgcSA+IDEgJiYgKEZbVyArIDFdID0gWSA+PiA4ICYgMjU1KSwgcSA+IDIgJiYgKEZbVyArIDJdID0gWSA+PiAxNiAmIDI1NSkpLCBGO1xuICAgIH07XG4gICAgZnVuY3Rpb24gUChNLCBILCBDKSB7XG4gICAgICBnLmNhbGwodGhpcywgTSwgSCwgQyk7XG4gICAgfVxuICAgIFAucHJvdG90eXBlID0gbmV3IGcoKSwgUC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuY29kZSh0aGlzLm91dHB1dEJpdHMsICEwKSwgZy5wcm90b3R5cGUuZmluYWxpemUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHZhciBHID0gZnVuY3Rpb24oTSkge1xuICAgICAgdmFyIEgsIEMsIHEsIEwsIHksIEYsIFcsIFksIFgsIGVlLCB3ZSwgTWUsIGhlLCBSZSwgeGUsIHNlLCBnZSwgbGUsIG5lLCB1ZSwgZmUsIHRlLCBwZSwgX2UsIHJlLCBFZSwgU2UsIG9lLCBEZSwgSWUsIFBlLCBHZSwgWWUsIEFlLCBaZSwgZXQsIE5lLCBDZSwgVGUsIGRlLCAkZSwgTGUsIGNlLCBVZSwgemUsIHllLCBCZSwga2UsIHZlLCBGZSwgT2UsIG1lLCBqZSwgcnQsIHFlLCBpdCwgSmUsIHR0LCBqdCwgS3QsIEh0LCBWdCwgZ3Q7XG4gICAgICBmb3IgKHEgPSAwOyBxIDwgNDg7IHEgKz0gMilcbiAgICAgICAgTCA9IE1bMF0gXiBNWzEwXSBeIE1bMjBdIF4gTVszMF0gXiBNWzQwXSwgeSA9IE1bMV0gXiBNWzExXSBeIE1bMjFdIF4gTVszMV0gXiBNWzQxXSwgRiA9IE1bMl0gXiBNWzEyXSBeIE1bMjJdIF4gTVszMl0gXiBNWzQyXSwgVyA9IE1bM10gXiBNWzEzXSBeIE1bMjNdIF4gTVszM10gXiBNWzQzXSwgWSA9IE1bNF0gXiBNWzE0XSBeIE1bMjRdIF4gTVszNF0gXiBNWzQ0XSwgWCA9IE1bNV0gXiBNWzE1XSBeIE1bMjVdIF4gTVszNV0gXiBNWzQ1XSwgZWUgPSBNWzZdIF4gTVsxNl0gXiBNWzI2XSBeIE1bMzZdIF4gTVs0Nl0sIHdlID0gTVs3XSBeIE1bMTddIF4gTVsyN10gXiBNWzM3XSBeIE1bNDddLCBNZSA9IE1bOF0gXiBNWzE4XSBeIE1bMjhdIF4gTVszOF0gXiBNWzQ4XSwgaGUgPSBNWzldIF4gTVsxOV0gXiBNWzI5XSBeIE1bMzldIF4gTVs0OV0sIEggPSBNZSBeIChGIDw8IDEgfCBXID4+PiAzMSksIEMgPSBoZSBeIChXIDw8IDEgfCBGID4+PiAzMSksIE1bMF0gXj0gSCwgTVsxXSBePSBDLCBNWzEwXSBePSBILCBNWzExXSBePSBDLCBNWzIwXSBePSBILCBNWzIxXSBePSBDLCBNWzMwXSBePSBILCBNWzMxXSBePSBDLCBNWzQwXSBePSBILCBNWzQxXSBePSBDLCBIID0gTCBeIChZIDw8IDEgfCBYID4+PiAzMSksIEMgPSB5IF4gKFggPDwgMSB8IFkgPj4+IDMxKSwgTVsyXSBePSBILCBNWzNdIF49IEMsIE1bMTJdIF49IEgsIE1bMTNdIF49IEMsIE1bMjJdIF49IEgsIE1bMjNdIF49IEMsIE1bMzJdIF49IEgsIE1bMzNdIF49IEMsIE1bNDJdIF49IEgsIE1bNDNdIF49IEMsIEggPSBGIF4gKGVlIDw8IDEgfCB3ZSA+Pj4gMzEpLCBDID0gVyBeICh3ZSA8PCAxIHwgZWUgPj4+IDMxKSwgTVs0XSBePSBILCBNWzVdIF49IEMsIE1bMTRdIF49IEgsIE1bMTVdIF49IEMsIE1bMjRdIF49IEgsIE1bMjVdIF49IEMsIE1bMzRdIF49IEgsIE1bMzVdIF49IEMsIE1bNDRdIF49IEgsIE1bNDVdIF49IEMsIEggPSBZIF4gKE1lIDw8IDEgfCBoZSA+Pj4gMzEpLCBDID0gWCBeIChoZSA8PCAxIHwgTWUgPj4+IDMxKSwgTVs2XSBePSBILCBNWzddIF49IEMsIE1bMTZdIF49IEgsIE1bMTddIF49IEMsIE1bMjZdIF49IEgsIE1bMjddIF49IEMsIE1bMzZdIF49IEgsIE1bMzddIF49IEMsIE1bNDZdIF49IEgsIE1bNDddIF49IEMsIEggPSBlZSBeIChMIDw8IDEgfCB5ID4+PiAzMSksIEMgPSB3ZSBeICh5IDw8IDEgfCBMID4+PiAzMSksIE1bOF0gXj0gSCwgTVs5XSBePSBDLCBNWzE4XSBePSBILCBNWzE5XSBePSBDLCBNWzI4XSBePSBILCBNWzI5XSBePSBDLCBNWzM4XSBePSBILCBNWzM5XSBePSBDLCBNWzQ4XSBePSBILCBNWzQ5XSBePSBDLCBSZSA9IE1bMF0sIHhlID0gTVsxXSwgeWUgPSBNWzExXSA8PCA0IHwgTVsxMF0gPj4+IDI4LCBCZSA9IE1bMTBdIDw8IDQgfCBNWzExXSA+Pj4gMjgsIG9lID0gTVsyMF0gPDwgMyB8IE1bMjFdID4+PiAyOSwgRGUgPSBNWzIxXSA8PCAzIHwgTVsyMF0gPj4+IDI5LCBLdCA9IE1bMzFdIDw8IDkgfCBNWzMwXSA+Pj4gMjMsIEh0ID0gTVszMF0gPDwgOSB8IE1bMzFdID4+PiAyMywgTGUgPSBNWzQwXSA8PCAxOCB8IE1bNDFdID4+PiAxNCwgY2UgPSBNWzQxXSA8PCAxOCB8IE1bNDBdID4+PiAxNCwgQWUgPSBNWzJdIDw8IDEgfCBNWzNdID4+PiAzMSwgWmUgPSBNWzNdIDw8IDEgfCBNWzJdID4+PiAzMSwgc2UgPSBNWzEzXSA8PCAxMiB8IE1bMTJdID4+PiAyMCwgZ2UgPSBNWzEyXSA8PCAxMiB8IE1bMTNdID4+PiAyMCwga2UgPSBNWzIyXSA8PCAxMCB8IE1bMjNdID4+PiAyMiwgdmUgPSBNWzIzXSA8PCAxMCB8IE1bMjJdID4+PiAyMiwgSWUgPSBNWzMzXSA8PCAxMyB8IE1bMzJdID4+PiAxOSwgUGUgPSBNWzMyXSA8PCAxMyB8IE1bMzNdID4+PiAxOSwgVnQgPSBNWzQyXSA8PCAyIHwgTVs0M10gPj4+IDMwLCBndCA9IE1bNDNdIDw8IDIgfCBNWzQyXSA+Pj4gMzAsIHJ0ID0gTVs1XSA8PCAzMCB8IE1bNF0gPj4+IDIsIHFlID0gTVs0XSA8PCAzMCB8IE1bNV0gPj4+IDIsIGV0ID0gTVsxNF0gPDwgNiB8IE1bMTVdID4+PiAyNiwgTmUgPSBNWzE1XSA8PCA2IHwgTVsxNF0gPj4+IDI2LCBsZSA9IE1bMjVdIDw8IDExIHwgTVsyNF0gPj4+IDIxLCBuZSA9IE1bMjRdIDw8IDExIHwgTVsyNV0gPj4+IDIxLCBGZSA9IE1bMzRdIDw8IDE1IHwgTVszNV0gPj4+IDE3LCBPZSA9IE1bMzVdIDw8IDE1IHwgTVszNF0gPj4+IDE3LCBHZSA9IE1bNDVdIDw8IDI5IHwgTVs0NF0gPj4+IDMsIFllID0gTVs0NF0gPDwgMjkgfCBNWzQ1XSA+Pj4gMywgX2UgPSBNWzZdIDw8IDI4IHwgTVs3XSA+Pj4gNCwgcmUgPSBNWzddIDw8IDI4IHwgTVs2XSA+Pj4gNCwgaXQgPSBNWzE3XSA8PCAyMyB8IE1bMTZdID4+PiA5LCBKZSA9IE1bMTZdIDw8IDIzIHwgTVsxN10gPj4+IDksIENlID0gTVsyNl0gPDwgMjUgfCBNWzI3XSA+Pj4gNywgVGUgPSBNWzI3XSA8PCAyNSB8IE1bMjZdID4+PiA3LCB1ZSA9IE1bMzZdIDw8IDIxIHwgTVszN10gPj4+IDExLCBmZSA9IE1bMzddIDw8IDIxIHwgTVszNl0gPj4+IDExLCBtZSA9IE1bNDddIDw8IDI0IHwgTVs0Nl0gPj4+IDgsIGplID0gTVs0Nl0gPDwgMjQgfCBNWzQ3XSA+Pj4gOCwgVWUgPSBNWzhdIDw8IDI3IHwgTVs5XSA+Pj4gNSwgemUgPSBNWzldIDw8IDI3IHwgTVs4XSA+Pj4gNSwgRWUgPSBNWzE4XSA8PCAyMCB8IE1bMTldID4+PiAxMiwgU2UgPSBNWzE5XSA8PCAyMCB8IE1bMThdID4+PiAxMiwgdHQgPSBNWzI5XSA8PCA3IHwgTVsyOF0gPj4+IDI1LCBqdCA9IE1bMjhdIDw8IDcgfCBNWzI5XSA+Pj4gMjUsIGRlID0gTVszOF0gPDwgOCB8IE1bMzldID4+PiAyNCwgJGUgPSBNWzM5XSA8PCA4IHwgTVszOF0gPj4+IDI0LCB0ZSA9IE1bNDhdIDw8IDE0IHwgTVs0OV0gPj4+IDE4LCBwZSA9IE1bNDldIDw8IDE0IHwgTVs0OF0gPj4+IDE4LCBNWzBdID0gUmUgXiB+c2UgJiBsZSwgTVsxXSA9IHhlIF4gfmdlICYgbmUsIE1bMTBdID0gX2UgXiB+RWUgJiBvZSwgTVsxMV0gPSByZSBeIH5TZSAmIERlLCBNWzIwXSA9IEFlIF4gfmV0ICYgQ2UsIE1bMjFdID0gWmUgXiB+TmUgJiBUZSwgTVszMF0gPSBVZSBeIH55ZSAmIGtlLCBNWzMxXSA9IHplIF4gfkJlICYgdmUsIE1bNDBdID0gcnQgXiB+aXQgJiB0dCwgTVs0MV0gPSBxZSBeIH5KZSAmIGp0LCBNWzJdID0gc2UgXiB+bGUgJiB1ZSwgTVszXSA9IGdlIF4gfm5lICYgZmUsIE1bMTJdID0gRWUgXiB+b2UgJiBJZSwgTVsxM10gPSBTZSBeIH5EZSAmIFBlLCBNWzIyXSA9IGV0IF4gfkNlICYgZGUsIE1bMjNdID0gTmUgXiB+VGUgJiAkZSwgTVszMl0gPSB5ZSBeIH5rZSAmIEZlLCBNWzMzXSA9IEJlIF4gfnZlICYgT2UsIE1bNDJdID0gaXQgXiB+dHQgJiBLdCwgTVs0M10gPSBKZSBeIH5qdCAmIEh0LCBNWzRdID0gbGUgXiB+dWUgJiB0ZSwgTVs1XSA9IG5lIF4gfmZlICYgcGUsIE1bMTRdID0gb2UgXiB+SWUgJiBHZSwgTVsxNV0gPSBEZSBeIH5QZSAmIFllLCBNWzI0XSA9IENlIF4gfmRlICYgTGUsIE1bMjVdID0gVGUgXiB+JGUgJiBjZSwgTVszNF0gPSBrZSBeIH5GZSAmIG1lLCBNWzM1XSA9IHZlIF4gfk9lICYgamUsIE1bNDRdID0gdHQgXiB+S3QgJiBWdCwgTVs0NV0gPSBqdCBeIH5IdCAmIGd0LCBNWzZdID0gdWUgXiB+dGUgJiBSZSwgTVs3XSA9IGZlIF4gfnBlICYgeGUsIE1bMTZdID0gSWUgXiB+R2UgJiBfZSwgTVsxN10gPSBQZSBeIH5ZZSAmIHJlLCBNWzI2XSA9IGRlIF4gfkxlICYgQWUsIE1bMjddID0gJGUgXiB+Y2UgJiBaZSwgTVszNl0gPSBGZSBeIH5tZSAmIFVlLCBNWzM3XSA9IE9lIF4gfmplICYgemUsIE1bNDZdID0gS3QgXiB+VnQgJiBydCwgTVs0N10gPSBIdCBeIH5ndCAmIHFlLCBNWzhdID0gdGUgXiB+UmUgJiBzZSwgTVs5XSA9IHBlIF4gfnhlICYgZ2UsIE1bMThdID0gR2UgXiB+X2UgJiBFZSwgTVsxOV0gPSBZZSBeIH5yZSAmIFNlLCBNWzI4XSA9IExlIF4gfkFlICYgZXQsIE1bMjldID0gY2UgXiB+WmUgJiBOZSwgTVszOF0gPSBtZSBeIH5VZSAmIHllLCBNWzM5XSA9IGplIF4gfnplICYgQmUsIE1bNDhdID0gVnQgXiB+cnQgJiBpdCwgTVs0OV0gPSBndCBeIH5xZSAmIEplLCBNWzBdIF49IE5bcV0sIE1bMV0gXj0gTltxICsgMV07XG4gICAgfTtcbiAgICBpZiAoZilcbiAgICAgIHIuZXhwb3J0cyA9IGE7XG4gICAgZWxzZVxuICAgICAgZm9yIChiID0gMDsgYiA8IGMubGVuZ3RoOyArK2IpXG4gICAgICAgIG5bY1tiXV0gPSBhW2NbYl1dO1xuICB9KSgpO1xufSkobHUpO1xudmFyIE92ID0gbHUuZXhwb3J0cztcbmNvbnN0IFJ2ID0gLyogQF9fUFVSRV9fICovIGJuKE92KSwgTnYgPSBcImxvZ2dlci81LjcuMFwiO1xubGV0IFFmID0gITEsIGVjID0gITE7XG5jb25zdCBQcyA9IHsgZGVidWc6IDEsIGRlZmF1bHQ6IDIsIGluZm86IDIsIHdhcm5pbmc6IDMsIGVycm9yOiA0LCBvZmY6IDUgfTtcbmxldCB0YyA9IFBzLmRlZmF1bHQsIHphID0gbnVsbDtcbmZ1bmN0aW9uIFR2KCkge1xuICB0cnkge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBpZiAoW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKFwidGVzdFwiLm5vcm1hbGl6ZShlKSAhPT0gXCJ0ZXN0XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIG5vcm1hbGl6ZVwiKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByLnB1c2goZSk7XG4gICAgICB9XG4gICAgfSksIHIubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBcIiArIHIuam9pbihcIiwgXCIpKTtcbiAgICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZSgyMzMpLm5vcm1hbGl6ZShcIk5GRFwiKSAhPT0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMDEsIDc2OSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW4gaW1wbGVtZW50YXRpb25cIik7XG4gIH0gY2F0Y2ggKHIpIHtcbiAgICByZXR1cm4gci5tZXNzYWdlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuY29uc3QgcmMgPSBUdigpO1xudmFyIHlvO1xuKGZ1bmN0aW9uKHIpIHtcbiAgci5ERUJVRyA9IFwiREVCVUdcIiwgci5JTkZPID0gXCJJTkZPXCIsIHIuV0FSTklORyA9IFwiV0FSTklOR1wiLCByLkVSUk9SID0gXCJFUlJPUlwiLCByLk9GRiA9IFwiT0ZGXCI7XG59KSh5byB8fCAoeW8gPSB7fSkpO1xudmFyIFNyO1xuKGZ1bmN0aW9uKHIpIHtcbiAgci5VTktOT1dOX0VSUk9SID0gXCJVTktOT1dOX0VSUk9SXCIsIHIuTk9UX0lNUExFTUVOVEVEID0gXCJOT1RfSU1QTEVNRU5URURcIiwgci5VTlNVUFBPUlRFRF9PUEVSQVRJT04gPSBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCByLk5FVFdPUktfRVJST1IgPSBcIk5FVFdPUktfRVJST1JcIiwgci5TRVJWRVJfRVJST1IgPSBcIlNFUlZFUl9FUlJPUlwiLCByLlRJTUVPVVQgPSBcIlRJTUVPVVRcIiwgci5CVUZGRVJfT1ZFUlJVTiA9IFwiQlVGRkVSX09WRVJSVU5cIiwgci5OVU1FUklDX0ZBVUxUID0gXCJOVU1FUklDX0ZBVUxUXCIsIHIuTUlTU0lOR19ORVcgPSBcIk1JU1NJTkdfTkVXXCIsIHIuSU5WQUxJRF9BUkdVTUVOVCA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiLCByLk1JU1NJTkdfQVJHVU1FTlQgPSBcIk1JU1NJTkdfQVJHVU1FTlRcIiwgci5VTkVYUEVDVEVEX0FSR1VNRU5UID0gXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHIuQ0FMTF9FWENFUFRJT04gPSBcIkNBTExfRVhDRVBUSU9OXCIsIHIuSU5TVUZGSUNJRU5UX0ZVTkRTID0gXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwgci5OT05DRV9FWFBJUkVEID0gXCJOT05DRV9FWFBJUkVEXCIsIHIuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQgPSBcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCIsIHIuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQgPSBcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCIsIHIuVFJBTlNBQ1RJT05fUkVQTEFDRUQgPSBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIsIHIuQUNUSU9OX1JFSkVDVEVEID0gXCJBQ1RJT05fUkVKRUNURURcIjtcbn0pKFNyIHx8IChTciA9IHt9KSk7XG5jb25zdCBpYyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuY2xhc3MgaHQge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBlLFxuICAgICAgd3JpdGFibGU6ICExXG4gICAgfSk7XG4gIH1cbiAgX2xvZyhlLCB0KSB7XG4gICAgY29uc3QgaSA9IGUudG9Mb3dlckNhc2UoKTtcbiAgICBQc1tpXSA9PSBudWxsICYmIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsb2cgbGV2ZWwgbmFtZVwiLCBcImxvZ0xldmVsXCIsIGUpLCAhKHRjID4gUHNbaV0pICYmIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIHQpO1xuICB9XG4gIGRlYnVnKC4uLmUpIHtcbiAgICB0aGlzLl9sb2coaHQubGV2ZWxzLkRFQlVHLCBlKTtcbiAgfVxuICBpbmZvKC4uLmUpIHtcbiAgICB0aGlzLl9sb2coaHQubGV2ZWxzLklORk8sIGUpO1xuICB9XG4gIHdhcm4oLi4uZSkge1xuICAgIHRoaXMuX2xvZyhodC5sZXZlbHMuV0FSTklORywgZSk7XG4gIH1cbiAgbWFrZUVycm9yKGUsIHQsIGkpIHtcbiAgICBpZiAoZWMpXG4gICAgICByZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJjZW5zb3JlZCBlcnJvclwiLCB0LCB7fSk7XG4gICAgdCB8fCAodCA9IGh0LmVycm9ycy5VTktOT1dOX0VSUk9SKSwgaSB8fCAoaSA9IHt9KTtcbiAgICBjb25zdCBuID0gW107XG4gICAgT2JqZWN0LmtleXMoaSkuZm9yRWFjaCgoaCkgPT4ge1xuICAgICAgY29uc3QgZCA9IGlbaF07XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICBsZXQgdiA9IFwiXCI7XG4gICAgICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCBkLmxlbmd0aDsgdysrKVxuICAgICAgICAgICAgdiArPSBpY1tkW3ddID4+IDRdLCB2ICs9IGljW2Rbd10gJiAxNV07XG4gICAgICAgICAgbi5wdXNoKGggKyBcIj1VaW50OEFycmF5KDB4XCIgKyB2ICsgXCIpXCIpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBuLnB1c2goaCArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkoZCkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIG4ucHVzaChoICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeShpW2hdLnRvU3RyaW5nKCkpKTtcbiAgICAgIH1cbiAgICB9KSwgbi5wdXNoKGBjb2RlPSR7dH1gKSwgbi5wdXNoKGB2ZXJzaW9uPSR7dGhpcy52ZXJzaW9ufWApO1xuICAgIGNvbnN0IHMgPSBlO1xuICAgIGxldCBvID0gXCJcIjtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgU3IuTlVNRVJJQ19GQVVMVDoge1xuICAgICAgICBvID0gXCJOVU1FUklDX0ZBVUxUXCI7XG4gICAgICAgIGNvbnN0IGggPSBlO1xuICAgICAgICBzd2l0Y2ggKGgpIHtcbiAgICAgICAgICBjYXNlIFwib3ZlcmZsb3dcIjpcbiAgICAgICAgICBjYXNlIFwidW5kZXJmbG93XCI6XG4gICAgICAgICAgY2FzZSBcImRpdmlzaW9uLWJ5LXplcm9cIjpcbiAgICAgICAgICAgIG8gKz0gXCItXCIgKyBoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm5lZ2F0aXZlLXBvd2VyXCI6XG4gICAgICAgICAgY2FzZSBcIm5lZ2F0aXZlLXdpZHRoXCI6XG4gICAgICAgICAgICBvICs9IFwiLXVuc3VwcG9ydGVkXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidW5ib3VuZC1iaXR3aXNlLXJlc3VsdFwiOlxuICAgICAgICAgICAgbyArPSBcIi11bmJvdW5kLXJlc3VsdFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFNyLkNBTExfRVhDRVBUSU9OOlxuICAgICAgY2FzZSBTci5JTlNVRkZJQ0lFTlRfRlVORFM6XG4gICAgICBjYXNlIFNyLk1JU1NJTkdfTkVXOlxuICAgICAgY2FzZSBTci5OT05DRV9FWFBJUkVEOlxuICAgICAgY2FzZSBTci5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRDpcbiAgICAgIGNhc2UgU3IuVFJBTlNBQ1RJT05fUkVQTEFDRUQ6XG4gICAgICBjYXNlIFNyLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUOlxuICAgICAgICBvID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG8gJiYgKGUgKz0gXCIgWyBTZWU6IGh0dHBzOi8vbGlua3MuZXRoZXJzLm9yZy92NS1lcnJvcnMtXCIgKyBvICsgXCIgXVwiKSwgbi5sZW5ndGggJiYgKGUgKz0gXCIgKFwiICsgbi5qb2luKFwiLCBcIikgKyBcIilcIik7XG4gICAgY29uc3QgZiA9IG5ldyBFcnJvcihlKTtcbiAgICByZXR1cm4gZi5yZWFzb24gPSBzLCBmLmNvZGUgPSB0LCBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgIGZbaF0gPSBpW2hdO1xuICAgIH0pLCBmO1xuICB9XG4gIHRocm93RXJyb3IoZSwgdCwgaSkge1xuICAgIHRocm93IHRoaXMubWFrZUVycm9yKGUsIHQsIGkpO1xuICB9XG4gIHRocm93QXJndW1lbnRFcnJvcihlLCB0LCBpKSB7XG4gICAgcmV0dXJuIHRoaXMudGhyb3dFcnJvcihlLCBodC5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgYXJndW1lbnQ6IHQsXG4gICAgICB2YWx1ZTogaVxuICAgIH0pO1xuICB9XG4gIGFzc2VydChlLCB0LCBpLCBuKSB7XG4gICAgZSB8fCB0aGlzLnRocm93RXJyb3IodCwgaSwgbik7XG4gIH1cbiAgYXNzZXJ0QXJndW1lbnQoZSwgdCwgaSwgbikge1xuICAgIGUgfHwgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IodCwgaSwgbik7XG4gIH1cbiAgY2hlY2tOb3JtYWxpemUoZSkge1xuICAgIHJjICYmIHRoaXMudGhyb3dFcnJvcihcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgaHQuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsXG4gICAgICBmb3JtOiByY1xuICAgIH0pO1xuICB9XG4gIGNoZWNrU2FmZVVpbnQ1MyhlLCB0KSB7XG4gICAgdHlwZW9mIGUgPT0gXCJudW1iZXJcIiAmJiAodCA9PSBudWxsICYmICh0ID0gXCJ2YWx1ZSBub3Qgc2FmZVwiKSwgKGUgPCAwIHx8IGUgPj0gOTAwNzE5OTI1NDc0MDk5MSkgJiYgdGhpcy50aHJvd0Vycm9yKHQsIGh0LmVycm9ycy5OVU1FUklDX0ZBVUxULCB7XG4gICAgICBvcGVyYXRpb246IFwiY2hlY2tTYWZlSW50ZWdlclwiLFxuICAgICAgZmF1bHQ6IFwib3V0LW9mLXNhZmUtcmFuZ2VcIixcbiAgICAgIHZhbHVlOiBlXG4gICAgfSksIGUgJSAxICYmIHRoaXMudGhyb3dFcnJvcih0LCBodC5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcbiAgICAgIGZhdWx0OiBcIm5vbi1pbnRlZ2VyXCIsXG4gICAgICB2YWx1ZTogZVxuICAgIH0pKTtcbiAgfVxuICBjaGVja0FyZ3VtZW50Q291bnQoZSwgdCwgaSkge1xuICAgIGkgPyBpID0gXCI6IFwiICsgaSA6IGkgPSBcIlwiLCBlIDwgdCAmJiB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBpLCBodC5lcnJvcnMuTUlTU0lOR19BUkdVTUVOVCwge1xuICAgICAgY291bnQ6IGUsXG4gICAgICBleHBlY3RlZENvdW50OiB0XG4gICAgfSksIGUgPiB0ICYmIHRoaXMudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgaSwgaHQuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcbiAgICAgIGNvdW50OiBlLFxuICAgICAgZXhwZWN0ZWRDb3VudDogdFxuICAgIH0pO1xuICB9XG4gIGNoZWNrTmV3KGUsIHQpIHtcbiAgICAoZSA9PT0gT2JqZWN0IHx8IGUgPT0gbnVsbCkgJiYgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgaHQuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IHQubmFtZSB9KTtcbiAgfVxuICBjaGVja0Fic3RyYWN0KGUsIHQpIHtcbiAgICBlID09PSB0ID8gdGhpcy50aHJvd0Vycm9yKFwiY2Fubm90IGluc3RhbnRpYXRlIGFic3RyYWN0IGNsYXNzIFwiICsgSlNPTi5zdHJpbmdpZnkodC5uYW1lKSArIFwiIGRpcmVjdGx5OyB1c2UgYSBzdWItY2xhc3NcIiwgaHQuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBuYW1lOiBlLm5hbWUsIG9wZXJhdGlvbjogXCJuZXdcIiB9KSA6IChlID09PSBPYmplY3QgfHwgZSA9PSBudWxsKSAmJiB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLCBodC5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZTogdC5uYW1lIH0pO1xuICB9XG4gIHN0YXRpYyBnbG9iYWxMb2dnZXIoKSB7XG4gICAgcmV0dXJuIHphIHx8ICh6YSA9IG5ldyBodChOdikpLCB6YTtcbiAgfVxuICBzdGF0aWMgc2V0Q2Vuc29yc2hpcChlLCB0KSB7XG4gICAgaWYgKCFlICYmIHQgJiYgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiY2Fubm90IHBlcm1hbmVudGx5IGRpc2FibGUgY2Vuc29yc2hpcFwiLCBodC5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG4gICAgfSksIFFmKSB7XG4gICAgICBpZiAoIWUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImVycm9yIGNlbnNvcnNoaXAgcGVybWFuZW50XCIsIGh0LmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGVjID0gISFlLCBRZiA9ICEhdDtcbiAgfVxuICBzdGF0aWMgc2V0TG9nTGV2ZWwoZSkge1xuICAgIGNvbnN0IHQgPSBQc1tlLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgIGh0Lmdsb2JhbExvZ2dlcigpLndhcm4oXCJpbnZhbGlkIGxvZyBsZXZlbCAtIFwiICsgZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRjID0gdDtcbiAgfVxuICBzdGF0aWMgZnJvbShlKSB7XG4gICAgcmV0dXJuIG5ldyBodChlKTtcbiAgfVxufVxuaHQuZXJyb3JzID0gU3I7XG5odC5sZXZlbHMgPSB5bztcbmNvbnN0IEN2ID0gXCJieXRlcy81LjcuMFwiLCB2dCA9IG5ldyBodChDdik7XG5mdW5jdGlvbiBwdShyKSB7XG4gIHJldHVybiAhIXIudG9IZXhTdHJpbmc7XG59XG5mdW5jdGlvbiBjbihyKSB7XG4gIHJldHVybiByLnNsaWNlIHx8IChyLnNsaWNlID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGNuKG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShyLCBlKSkpO1xuICB9KSwgcjtcbn1cbmZ1bmN0aW9uICR2KHIpIHtcbiAgcmV0dXJuIExyKHIpICYmICEoci5sZW5ndGggJSAyKSB8fCBGbyhyKTtcbn1cbmZ1bmN0aW9uIG5jKHIpIHtcbiAgcmV0dXJuIHR5cGVvZiByID09IFwibnVtYmVyXCIgJiYgciA9PSByICYmIHIgJSAxID09PSAwO1xufVxuZnVuY3Rpb24gRm8ocikge1xuICBpZiAociA9PSBudWxsKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHIuY29uc3RydWN0b3IgPT09IFVpbnQ4QXJyYXkpXG4gICAgcmV0dXJuICEwO1xuICBpZiAodHlwZW9mIHIgPT0gXCJzdHJpbmdcIiB8fCAhbmMoci5sZW5ndGgpIHx8IHIubGVuZ3RoIDwgMClcbiAgICByZXR1cm4gITE7XG4gIGZvciAobGV0IGUgPSAwOyBlIDwgci5sZW5ndGg7IGUrKykge1xuICAgIGNvbnN0IHQgPSByW2VdO1xuICAgIGlmICghbmModCkgfHwgdCA8IDAgfHwgdCA+PSAyNTYpXG4gICAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24geXQociwgZSkge1xuICBpZiAoZSB8fCAoZSA9IHt9KSwgdHlwZW9mIHIgPT0gXCJudW1iZXJcIikge1xuICAgIHZ0LmNoZWNrU2FmZVVpbnQ1MyhyLCBcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIik7XG4gICAgY29uc3QgdCA9IFtdO1xuICAgIGZvciAoOyByOyApXG4gICAgICB0LnVuc2hpZnQociAmIDI1NSksIHIgPSBwYXJzZUludChTdHJpbmcociAvIDI1NikpO1xuICAgIHJldHVybiB0Lmxlbmd0aCA9PT0gMCAmJiB0LnB1c2goMCksIGNuKG5ldyBVaW50OEFycmF5KHQpKTtcbiAgfVxuICBpZiAoZS5hbGxvd01pc3NpbmdQcmVmaXggJiYgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiAmJiByLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiICYmIChyID0gXCIweFwiICsgciksIHB1KHIpICYmIChyID0gci50b0hleFN0cmluZygpKSwgTHIocikpIHtcbiAgICBsZXQgdCA9IHIuc3Vic3RyaW5nKDIpO1xuICAgIHQubGVuZ3RoICUgMiAmJiAoZS5oZXhQYWQgPT09IFwibGVmdFwiID8gdCA9IFwiMFwiICsgdCA6IGUuaGV4UGFkID09PSBcInJpZ2h0XCIgPyB0ICs9IFwiMFwiIDogdnQudGhyb3dBcmd1bWVudEVycm9yKFwiaGV4IGRhdGEgaXMgb2RkLWxlbmd0aFwiLCBcInZhbHVlXCIsIHIpKTtcbiAgICBjb25zdCBpID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbiArPSAyKVxuICAgICAgaS5wdXNoKHBhcnNlSW50KHQuc3Vic3RyaW5nKG4sIG4gKyAyKSwgMTYpKTtcbiAgICByZXR1cm4gY24obmV3IFVpbnQ4QXJyYXkoaSkpO1xuICB9XG4gIHJldHVybiBGbyhyKSA/IGNuKG5ldyBVaW50OEFycmF5KHIpKSA6IHZ0LnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIiwgXCJ2YWx1ZVwiLCByKTtcbn1cbmZ1bmN0aW9uIEx2KHIpIHtcbiAgY29uc3QgZSA9IHIubWFwKChuKSA9PiB5dChuKSksIHQgPSBlLnJlZHVjZSgobiwgcykgPT4gbiArIHMubGVuZ3RoLCAwKSwgaSA9IG5ldyBVaW50OEFycmF5KHQpO1xuICByZXR1cm4gZS5yZWR1Y2UoKG4sIHMpID0+IChpLnNldChzLCBuKSwgbiArIHMubGVuZ3RoKSwgMCksIGNuKGkpO1xufVxuZnVuY3Rpb24gRnYociwgZSkge1xuICByID0geXQociksIHIubGVuZ3RoID4gZSAmJiB2dC50aHJvd0FyZ3VtZW50RXJyb3IoXCJ2YWx1ZSBvdXQgb2YgcmFuZ2VcIiwgXCJ2YWx1ZVwiLCBhcmd1bWVudHNbMF0pO1xuICBjb25zdCB0ID0gbmV3IFVpbnQ4QXJyYXkoZSk7XG4gIHJldHVybiB0LnNldChyLCBlIC0gci5sZW5ndGgpLCBjbih0KTtcbn1cbmZ1bmN0aW9uIExyKHIsIGUpIHtcbiAgcmV0dXJuICEodHlwZW9mIHIgIT0gXCJzdHJpbmdcIiB8fCAhci5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pIHx8IGUgJiYgci5sZW5ndGggIT09IDIgKyAyICogZSk7XG59XG5jb25zdCBCYSA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuZnVuY3Rpb24gSnQociwgZSkge1xuICBpZiAoZSB8fCAoZSA9IHt9KSwgdHlwZW9mIHIgPT0gXCJudW1iZXJcIikge1xuICAgIHZ0LmNoZWNrU2FmZVVpbnQ1MyhyLCBcImludmFsaWQgaGV4bGlmeSB2YWx1ZVwiKTtcbiAgICBsZXQgdCA9IFwiXCI7XG4gICAgZm9yICg7IHI7IClcbiAgICAgIHQgPSBCYVtyICYgMTVdICsgdCwgciA9IE1hdGguZmxvb3IociAvIDE2KTtcbiAgICByZXR1cm4gdC5sZW5ndGggPyAodC5sZW5ndGggJSAyICYmICh0ID0gXCIwXCIgKyB0KSwgXCIweFwiICsgdCkgOiBcIjB4MDBcIjtcbiAgfVxuICBpZiAodHlwZW9mIHIgPT0gXCJiaWdpbnRcIilcbiAgICByZXR1cm4gciA9IHIudG9TdHJpbmcoMTYpLCByLmxlbmd0aCAlIDIgPyBcIjB4MFwiICsgciA6IFwiMHhcIiArIHI7XG4gIGlmIChlLmFsbG93TWlzc2luZ1ByZWZpeCAmJiB0eXBlb2YgciA9PSBcInN0cmluZ1wiICYmIHIuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIgJiYgKHIgPSBcIjB4XCIgKyByKSwgcHUocikpXG4gICAgcmV0dXJuIHIudG9IZXhTdHJpbmcoKTtcbiAgaWYgKExyKHIpKVxuICAgIHJldHVybiByLmxlbmd0aCAlIDIgJiYgKGUuaGV4UGFkID09PSBcImxlZnRcIiA/IHIgPSBcIjB4MFwiICsgci5zdWJzdHJpbmcoMikgOiBlLmhleFBhZCA9PT0gXCJyaWdodFwiID8gciArPSBcIjBcIiA6IHZ0LnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCByKSksIHIudG9Mb3dlckNhc2UoKTtcbiAgaWYgKEZvKHIpKSB7XG4gICAgbGV0IHQgPSBcIjB4XCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbiA9IHJbaV07XG4gICAgICB0ICs9IEJhWyhuICYgMjQwKSA+PiA0XSArIEJhW24gJiAxNV07XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiB2dC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleGxpZnkgdmFsdWVcIiwgXCJ2YWx1ZVwiLCByKTtcbn1cbmZ1bmN0aW9uIHF2KHIpIHtcbiAgaWYgKHR5cGVvZiByICE9IFwic3RyaW5nXCIpXG4gICAgciA9IEp0KHIpO1xuICBlbHNlIGlmICghTHIocikgfHwgci5sZW5ndGggJSAyKVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4gKHIubGVuZ3RoIC0gMikgLyAyO1xufVxuZnVuY3Rpb24gc2MociwgZSwgdCkge1xuICByZXR1cm4gdHlwZW9mIHIgIT0gXCJzdHJpbmdcIiA/IHIgPSBKdChyKSA6ICghTHIocikgfHwgci5sZW5ndGggJSAyKSAmJiB2dC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleERhdGFcIiwgXCJ2YWx1ZVwiLCByKSwgZSA9IDIgKyAyICogZSwgdCAhPSBudWxsID8gXCIweFwiICsgci5zdWJzdHJpbmcoZSwgMiArIDIgKiB0KSA6IFwiMHhcIiArIHIuc3Vic3RyaW5nKGUpO1xufVxuZnVuY3Rpb24gaG4ociwgZSkge1xuICBmb3IgKHR5cGVvZiByICE9IFwic3RyaW5nXCIgPyByID0gSnQocikgOiBMcihyKSB8fCB2dC50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCByKSwgci5sZW5ndGggPiAyICogZSArIDIgJiYgdnQudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzFdKTsgci5sZW5ndGggPCAyICogZSArIDI7IClcbiAgICByID0gXCIweDBcIiArIHIuc3Vic3RyaW5nKDIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHZ1KHIpIHtcbiAgY29uc3QgZSA9IHtcbiAgICByOiBcIjB4XCIsXG4gICAgczogXCIweFwiLFxuICAgIF92czogXCIweFwiLFxuICAgIHJlY292ZXJ5UGFyYW06IDAsXG4gICAgdjogMCxcbiAgICB5UGFyaXR5QW5kUzogXCIweFwiLFxuICAgIGNvbXBhY3Q6IFwiMHhcIlxuICB9O1xuICBpZiAoJHYocikpIHtcbiAgICBsZXQgdCA9IHl0KHIpO1xuICAgIHQubGVuZ3RoID09PSA2NCA/IChlLnYgPSAyNyArICh0WzMyXSA+PiA3KSwgdFszMl0gJj0gMTI3LCBlLnIgPSBKdCh0LnNsaWNlKDAsIDMyKSksIGUucyA9IEp0KHQuc2xpY2UoMzIsIDY0KSkpIDogdC5sZW5ndGggPT09IDY1ID8gKGUuciA9IEp0KHQuc2xpY2UoMCwgMzIpKSwgZS5zID0gSnQodC5zbGljZSgzMiwgNjQpKSwgZS52ID0gdFs2NF0pIDogdnQudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmUgc3RyaW5nXCIsIFwic2lnbmF0dXJlXCIsIHIpLCBlLnYgPCAyNyAmJiAoZS52ID09PSAwIHx8IGUudiA9PT0gMSA/IGUudiArPSAyNyA6IHZ0LnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBpbnZhbGlkIHYgYnl0ZVwiLCBcInNpZ25hdHVyZVwiLCByKSksIGUucmVjb3ZlcnlQYXJhbSA9IDEgLSBlLnYgJSAyLCBlLnJlY292ZXJ5UGFyYW0gJiYgKHRbMzJdIHw9IDEyOCksIGUuX3ZzID0gSnQodC5zbGljZSgzMiwgNjQpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZS5yID0gci5yLCBlLnMgPSByLnMsIGUudiA9IHIudiwgZS5yZWNvdmVyeVBhcmFtID0gci5yZWNvdmVyeVBhcmFtLCBlLl92cyA9IHIuX3ZzLCBlLl92cyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBuID0gRnYoeXQoZS5fdnMpLCAzMik7XG4gICAgICBlLl92cyA9IEp0KG4pO1xuICAgICAgY29uc3QgcyA9IG5bMF0gPj0gMTI4ID8gMSA6IDA7XG4gICAgICBlLnJlY292ZXJ5UGFyYW0gPT0gbnVsbCA/IGUucmVjb3ZlcnlQYXJhbSA9IHMgOiBlLnJlY292ZXJ5UGFyYW0gIT09IHMgJiYgdnQudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHJlY292ZXJ5UGFyYW0gbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHIpLCBuWzBdICY9IDEyNztcbiAgICAgIGNvbnN0IG8gPSBKdChuKTtcbiAgICAgIGUucyA9PSBudWxsID8gZS5zID0gbyA6IGUucyAhPT0gbyAmJiB2dC50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgdiBtaXNtYXRjaCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgcik7XG4gICAgfVxuICAgIGlmIChlLnJlY292ZXJ5UGFyYW0gPT0gbnVsbClcbiAgICAgIGUudiA9PSBudWxsID8gdnQudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIG1pc3NpbmcgdiBhbmQgcmVjb3ZlcnlQYXJhbVwiLCBcInNpZ25hdHVyZVwiLCByKSA6IGUudiA9PT0gMCB8fCBlLnYgPT09IDEgPyBlLnJlY292ZXJ5UGFyYW0gPSBlLnYgOiBlLnJlY292ZXJ5UGFyYW0gPSAxIC0gZS52ICUgMjtcbiAgICBlbHNlIGlmIChlLnYgPT0gbnVsbClcbiAgICAgIGUudiA9IDI3ICsgZS5yZWNvdmVyeVBhcmFtO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbiA9IGUudiA9PT0gMCB8fCBlLnYgPT09IDEgPyBlLnYgOiAxIC0gZS52ICUgMjtcbiAgICAgIGUucmVjb3ZlcnlQYXJhbSAhPT0gbiAmJiB2dC50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCB2XCIsIFwic2lnbmF0dXJlXCIsIHIpO1xuICAgIH1cbiAgICBlLnIgPT0gbnVsbCB8fCAhTHIoZS5yKSA/IHZ0LnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgclwiLCBcInNpZ25hdHVyZVwiLCByKSA6IGUuciA9IGhuKGUuciwgMzIpLCBlLnMgPT0gbnVsbCB8fCAhTHIoZS5zKSA/IHZ0LnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgc1wiLCBcInNpZ25hdHVyZVwiLCByKSA6IGUucyA9IGhuKGUucywgMzIpO1xuICAgIGNvbnN0IHQgPSB5dChlLnMpO1xuICAgIHRbMF0gPj0gMTI4ICYmIHZ0LnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBzIG91dCBvZiByYW5nZVwiLCBcInNpZ25hdHVyZVwiLCByKSwgZS5yZWNvdmVyeVBhcmFtICYmICh0WzBdIHw9IDEyOCk7XG4gICAgY29uc3QgaSA9IEp0KHQpO1xuICAgIGUuX3ZzICYmIChMcihlLl92cykgfHwgdnQudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIGludmFsaWQgX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHIpLCBlLl92cyA9IGhuKGUuX3ZzLCAzMikpLCBlLl92cyA9PSBudWxsID8gZS5fdnMgPSBpIDogZS5fdnMgIT09IGkgJiYgdnQudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIF92cyBtaXNtYXRjaCB2IGFuZCBzXCIsIFwic2lnbmF0dXJlXCIsIHIpO1xuICB9XG4gIHJldHVybiBlLnlQYXJpdHlBbmRTID0gZS5fdnMsIGUuY29tcGFjdCA9IGUuciArIGUueVBhcml0eUFuZFMuc3Vic3RyaW5nKDIpLCBlO1xufVxuZnVuY3Rpb24gcW8ocikge1xuICByZXR1cm4gXCIweFwiICsgUnYua2VjY2FrXzI1Nih5dChyKSk7XG59XG52YXIgVW8gPSB7IGV4cG9ydHM6IHt9IH07XG5Vby5leHBvcnRzO1xuKGZ1bmN0aW9uKHIpIHtcbiAgKGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBmdW5jdGlvbiBpKGwsIGEpIHtcbiAgICAgIGlmICghbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGEgfHwgXCJBc3NlcnRpb24gZmFpbGVkXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuKGwsIGEpIHtcbiAgICAgIGwuc3VwZXJfID0gYTtcbiAgICAgIHZhciBjID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgYy5wcm90b3R5cGUgPSBhLnByb3RvdHlwZSwgbC5wcm90b3R5cGUgPSBuZXcgYygpLCBsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHMobCwgYSwgYykge1xuICAgICAgaWYgKHMuaXNCTihsKSlcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMCwgdGhpcy53b3JkcyA9IG51bGwsIHRoaXMubGVuZ3RoID0gMCwgdGhpcy5yZWQgPSBudWxsLCBsICE9PSBudWxsICYmICgoYSA9PT0gXCJsZVwiIHx8IGEgPT09IFwiYmVcIikgJiYgKGMgPSBhLCBhID0gMTApLCB0aGlzLl9pbml0KGwgfHwgMCwgYSB8fCAxMCwgYyB8fCBcImJlXCIpKTtcbiAgICB9XG4gICAgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUuZXhwb3J0cyA9IHMgOiB0LkJOID0gcywgcy5CTiA9IHMsIHMud29yZFNpemUgPSAyNjtcbiAgICB2YXIgbztcbiAgICB0cnkge1xuICAgICAgdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHR5cGVvZiB3aW5kb3cuQnVmZmVyIDwgXCJ1XCIgPyBvID0gd2luZG93LkJ1ZmZlciA6IG8gPSBmYS5CdWZmZXI7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHMuaXNCTiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBhIGluc3RhbmNlb2YgcyA/ICEwIDogYSAhPT0gbnVsbCAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIGEuY29uc3RydWN0b3Iud29yZFNpemUgPT09IHMud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShhLndvcmRzKTtcbiAgICB9LCBzLm1heCA9IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIHJldHVybiBhLmNtcChjKSA+IDAgPyBhIDogYztcbiAgICB9LCBzLm1pbiA9IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIHJldHVybiBhLmNtcChjKSA8IDAgPyBhIDogYztcbiAgICB9LCBzLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKGEsIGMsIGIpIHtcbiAgICAgIGlmICh0eXBlb2YgYSA9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihhLCBjLCBiKTtcbiAgICAgIGlmICh0eXBlb2YgYSA9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KGEsIGMsIGIpO1xuICAgICAgYyA9PT0gXCJoZXhcIiAmJiAoYyA9IDE2KSwgaShjID09PSAoYyB8IDApICYmIGMgPj0gMiAmJiBjIDw9IDM2KSwgYSA9IGEudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csIFwiXCIpO1xuICAgICAgdmFyIEUgPSAwO1xuICAgICAgYVswXSA9PT0gXCItXCIgJiYgKEUrKywgdGhpcy5uZWdhdGl2ZSA9IDEpLCBFIDwgYS5sZW5ndGggJiYgKGMgPT09IDE2ID8gdGhpcy5fcGFyc2VIZXgoYSwgRSwgYikgOiAodGhpcy5fcGFyc2VCYXNlKGEsIGMsIEUpLCBiID09PSBcImxlXCIgJiYgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBjLCBiKSkpO1xuICAgIH0sIHMucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24oYSwgYywgYikge1xuICAgICAgYSA8IDAgJiYgKHRoaXMubmVnYXRpdmUgPSAxLCBhID0gLWEpLCBhIDwgNjcxMDg4NjQgPyAodGhpcy53b3JkcyA9IFthICYgNjcxMDg4NjNdLCB0aGlzLmxlbmd0aCA9IDEpIDogYSA8IDQ1MDM1OTk2MjczNzA0OTYgPyAodGhpcy53b3JkcyA9IFtcbiAgICAgICAgYSAmIDY3MTA4ODYzLFxuICAgICAgICBhIC8gNjcxMDg4NjQgJiA2NzEwODg2M1xuICAgICAgXSwgdGhpcy5sZW5ndGggPSAyKSA6IChpKGEgPCA5MDA3MTk5MjU0NzQwOTkyKSwgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgYSAmIDY3MTA4ODYzLFxuICAgICAgICBhIC8gNjcxMDg4NjQgJiA2NzEwODg2MyxcbiAgICAgICAgMVxuICAgICAgXSwgdGhpcy5sZW5ndGggPSAzKSwgYiA9PT0gXCJsZVwiICYmIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYywgYik7XG4gICAgfSwgcy5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uKGEsIGMsIGIpIHtcbiAgICAgIGlmIChpKHR5cGVvZiBhLmxlbmd0aCA9PSBcIm51bWJlclwiKSwgYS5sZW5ndGggPD0gMClcbiAgICAgICAgcmV0dXJuIHRoaXMud29yZHMgPSBbMF0sIHRoaXMubGVuZ3RoID0gMSwgdGhpcztcbiAgICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKGEubGVuZ3RoIC8gMyksIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgRSA9IDA7IEUgPCB0aGlzLmxlbmd0aDsgRSsrKVxuICAgICAgICB0aGlzLndvcmRzW0VdID0gMDtcbiAgICAgIHZhciBTLCB4LCB1ID0gMDtcbiAgICAgIGlmIChiID09PSBcImJlXCIpXG4gICAgICAgIGZvciAoRSA9IGEubGVuZ3RoIC0gMSwgUyA9IDA7IEUgPj0gMDsgRSAtPSAzKVxuICAgICAgICAgIHggPSBhW0VdIHwgYVtFIC0gMV0gPDwgOCB8IGFbRSAtIDJdIDw8IDE2LCB0aGlzLndvcmRzW1NdIHw9IHggPDwgdSAmIDY3MTA4ODYzLCB0aGlzLndvcmRzW1MgKyAxXSA9IHggPj4+IDI2IC0gdSAmIDY3MTA4ODYzLCB1ICs9IDI0LCB1ID49IDI2ICYmICh1IC09IDI2LCBTKyspO1xuICAgICAgZWxzZSBpZiAoYiA9PT0gXCJsZVwiKVxuICAgICAgICBmb3IgKEUgPSAwLCBTID0gMDsgRSA8IGEubGVuZ3RoOyBFICs9IDMpXG4gICAgICAgICAgeCA9IGFbRV0gfCBhW0UgKyAxXSA8PCA4IHwgYVtFICsgMl0gPDwgMTYsIHRoaXMud29yZHNbU10gfD0geCA8PCB1ICYgNjcxMDg4NjMsIHRoaXMud29yZHNbUyArIDFdID0geCA+Pj4gMjYgLSB1ICYgNjcxMDg4NjMsIHUgKz0gMjQsIHUgPj0gMjYgJiYgKHUgLT0gMjYsIFMrKyk7XG4gICAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGYobCwgYSkge1xuICAgICAgdmFyIGMgPSBsLmNoYXJDb2RlQXQoYSk7XG4gICAgICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KVxuICAgICAgICByZXR1cm4gYyAtIDQ4O1xuICAgICAgaWYgKGMgPj0gNjUgJiYgYyA8PSA3MClcbiAgICAgICAgcmV0dXJuIGMgLSA1NTtcbiAgICAgIGlmIChjID49IDk3ICYmIGMgPD0gMTAyKVxuICAgICAgICByZXR1cm4gYyAtIDg3O1xuICAgICAgaSghMSwgXCJJbnZhbGlkIGNoYXJhY3RlciBpbiBcIiArIGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoKGwsIGEsIGMpIHtcbiAgICAgIHZhciBiID0gZihsLCBjKTtcbiAgICAgIHJldHVybiBjIC0gMSA+PSBhICYmIChiIHw9IGYobCwgYyAtIDEpIDw8IDQpLCBiO1xuICAgIH1cbiAgICBzLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbihhLCBjLCBiKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgoYS5sZW5ndGggLSBjKSAvIDYpLCB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIEUgPSAwOyBFIDwgdGhpcy5sZW5ndGg7IEUrKylcbiAgICAgICAgdGhpcy53b3Jkc1tFXSA9IDA7XG4gICAgICB2YXIgUyA9IDAsIHggPSAwLCB1O1xuICAgICAgaWYgKGIgPT09IFwiYmVcIilcbiAgICAgICAgZm9yIChFID0gYS5sZW5ndGggLSAxOyBFID49IGM7IEUgLT0gMilcbiAgICAgICAgICB1ID0gaChhLCBjLCBFKSA8PCBTLCB0aGlzLndvcmRzW3hdIHw9IHUgJiA2NzEwODg2MywgUyA+PSAxOCA/IChTIC09IDE4LCB4ICs9IDEsIHRoaXMud29yZHNbeF0gfD0gdSA+Pj4gMjYpIDogUyArPSA4O1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBtID0gYS5sZW5ndGggLSBjO1xuICAgICAgICBmb3IgKEUgPSBtICUgMiA9PT0gMCA/IGMgKyAxIDogYzsgRSA8IGEubGVuZ3RoOyBFICs9IDIpXG4gICAgICAgICAgdSA9IGgoYSwgYywgRSkgPDwgUywgdGhpcy53b3Jkc1t4XSB8PSB1ICYgNjcxMDg4NjMsIFMgPj0gMTggPyAoUyAtPSAxOCwgeCArPSAxLCB0aGlzLndvcmRzW3hdIHw9IHUgPj4+IDI2KSA6IFMgKz0gODtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0cmlwKCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkKGwsIGEsIGMsIGIpIHtcbiAgICAgIGZvciAodmFyIEUgPSAwLCBTID0gMCwgeCA9IE1hdGgubWluKGwubGVuZ3RoLCBjKSwgdSA9IGE7IHUgPCB4OyB1KyspIHtcbiAgICAgICAgdmFyIG0gPSBsLmNoYXJDb2RlQXQodSkgLSA0ODtcbiAgICAgICAgRSAqPSBiLCBtID49IDQ5ID8gUyA9IG0gLSA0OSArIDEwIDogbSA+PSAxNyA/IFMgPSBtIC0gMTcgKyAxMCA6IFMgPSBtLCBpKG0gPj0gMCAmJiBTIDwgYiwgXCJJbnZhbGlkIGNoYXJhY3RlclwiKSwgRSArPSBTO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEU7XG4gICAgfVxuICAgIHMucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbihhLCBjLCBiKSB7XG4gICAgICB0aGlzLndvcmRzID0gWzBdLCB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICBmb3IgKHZhciBFID0gMCwgUyA9IDE7IFMgPD0gNjcxMDg4NjM7IFMgKj0gYylcbiAgICAgICAgRSsrO1xuICAgICAgRS0tLCBTID0gUyAvIGMgfCAwO1xuICAgICAgZm9yICh2YXIgeCA9IGEubGVuZ3RoIC0gYiwgdSA9IHggJSBFLCBtID0gTWF0aC5taW4oeCwgeCAtIHUpICsgYiwgZyA9IDAsIFAgPSBiOyBQIDwgbTsgUCArPSBFKVxuICAgICAgICBnID0gZChhLCBQLCBQICsgRSwgYyksIHRoaXMuaW11bG4oUyksIHRoaXMud29yZHNbMF0gKyBnIDwgNjcxMDg4NjQgPyB0aGlzLndvcmRzWzBdICs9IGcgOiB0aGlzLl9pYWRkbihnKTtcbiAgICAgIGlmICh1ICE9PSAwKSB7XG4gICAgICAgIHZhciBHID0gMTtcbiAgICAgICAgZm9yIChnID0gZChhLCBQLCBhLmxlbmd0aCwgYyksIFAgPSAwOyBQIDwgdTsgUCsrKVxuICAgICAgICAgIEcgKj0gYztcbiAgICAgICAgdGhpcy5pbXVsbihHKSwgdGhpcy53b3Jkc1swXSArIGcgPCA2NzEwODg2NCA/IHRoaXMud29yZHNbMF0gKz0gZyA6IHRoaXMuX2lhZGRuKGcpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RyaXAoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oYSkge1xuICAgICAgYS53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRoaXMubGVuZ3RoOyBjKyspXG4gICAgICAgIGEud29yZHNbY10gPSB0aGlzLndvcmRzW2NdO1xuICAgICAgYS5sZW5ndGggPSB0aGlzLmxlbmd0aCwgYS5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmUsIGEucmVkID0gdGhpcy5yZWQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB2KGwsIGEpIHtcbiAgICAgIGwud29yZHMgPSBhLndvcmRzLCBsLmxlbmd0aCA9IGEubGVuZ3RoLCBsLm5lZ2F0aXZlID0gYS5uZWdhdGl2ZSwgbC5yZWQgPSBhLnJlZDtcbiAgICB9XG4gICAgaWYgKHMucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24oYSkge1xuICAgICAgdihhLCB0aGlzKTtcbiAgICB9LCBzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBuZXcgcyhudWxsKTtcbiAgICAgIHJldHVybiB0aGlzLmNvcHkoYSksIGE7XG4gICAgfSwgcy5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIGZvciAoOyB0aGlzLmxlbmd0aCA8IGE7IClcbiAgICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBzLnByb3RvdHlwZS5fc3RyaXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAoOyB0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwOyApXG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICB9LCBzLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwICYmICh0aGlzLm5lZ2F0aXZlID0gMCksIHRoaXM7XG4gICAgfSwgdHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIHR5cGVvZiBTeW1ib2wuZm9yID09IFwiZnVuY3Rpb25cIilcbiAgICAgIHRyeSB7XG4gICAgICAgIHMucHJvdG90eXBlW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0gPSB3O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHMucHJvdG90eXBlLmluc3BlY3QgPSB3O1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHMucHJvdG90eXBlLmluc3BlY3QgPSB3O1xuICAgIGZ1bmN0aW9uIHcoKSB7XG4gICAgICByZXR1cm4gKHRoaXMucmVkID8gXCI8Qk4tUjogXCIgOiBcIjxCTjogXCIpICsgdGhpcy50b1N0cmluZygxNikgKyBcIj5cIjtcbiAgICB9XG4gICAgdmFyIEEgPSBbXG4gICAgICBcIlwiLFxuICAgICAgXCIwXCIsXG4gICAgICBcIjAwXCIsXG4gICAgICBcIjAwMFwiLFxuICAgICAgXCIwMDAwXCIsXG4gICAgICBcIjAwMDAwXCIsXG4gICAgICBcIjAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwXCIsXG4gICAgICBcIjAwMDAwMDAwXCIsXG4gICAgICBcIjAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwXCIsXG4gICAgICBcIjAwMDAwMDAwMDAwXCIsXG4gICAgICBcIjAwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDAwXCIsXG4gICAgICBcIjAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICBcIjAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJcbiAgICBdLCBJID0gW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAyNSxcbiAgICAgIDE2LFxuICAgICAgMTIsXG4gICAgICAxMSxcbiAgICAgIDEwLFxuICAgICAgOSxcbiAgICAgIDgsXG4gICAgICA4LFxuICAgICAgNyxcbiAgICAgIDcsXG4gICAgICA3LFxuICAgICAgNyxcbiAgICAgIDYsXG4gICAgICA2LFxuICAgICAgNixcbiAgICAgIDYsXG4gICAgICA2LFxuICAgICAgNixcbiAgICAgIDYsXG4gICAgICA1LFxuICAgICAgNSxcbiAgICAgIDUsXG4gICAgICA1LFxuICAgICAgNSxcbiAgICAgIDUsXG4gICAgICA1LFxuICAgICAgNSxcbiAgICAgIDUsXG4gICAgICA1LFxuICAgICAgNSxcbiAgICAgIDUsXG4gICAgICA1LFxuICAgICAgNSxcbiAgICAgIDUsXG4gICAgICA1XG4gICAgXSwgRCA9IFtcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMzM1NTQ0MzIsXG4gICAgICA0MzA0NjcyMSxcbiAgICAgIDE2Nzc3MjE2LFxuICAgICAgNDg4MjgxMjUsXG4gICAgICA2MDQ2NjE3NixcbiAgICAgIDQwMzUzNjA3LFxuICAgICAgMTY3NzcyMTYsXG4gICAgICA0MzA0NjcyMSxcbiAgICAgIDFlNyxcbiAgICAgIDE5NDg3MTcxLFxuICAgICAgMzU4MzE4MDgsXG4gICAgICA2Mjc0ODUxNyxcbiAgICAgIDc1Mjk1MzYsXG4gICAgICAxMTM5MDYyNSxcbiAgICAgIDE2Nzc3MjE2LFxuICAgICAgMjQxMzc1NjksXG4gICAgICAzNDAxMjIyNCxcbiAgICAgIDQ3MDQ1ODgxLFxuICAgICAgNjRlNixcbiAgICAgIDQwODQxMDEsXG4gICAgICA1MTUzNjMyLFxuICAgICAgNjQzNjM0MyxcbiAgICAgIDc5NjI2MjQsXG4gICAgICA5NzY1NjI1LFxuICAgICAgMTE4ODEzNzYsXG4gICAgICAxNDM0ODkwNyxcbiAgICAgIDE3MjEwMzY4LFxuICAgICAgMjA1MTExNDksXG4gICAgICAyNDNlNSxcbiAgICAgIDI4NjI5MTUxLFxuICAgICAgMzM1NTQ0MzIsXG4gICAgICAzOTEzNTM5MyxcbiAgICAgIDQ1NDM1NDI0LFxuICAgICAgNTI1MjE4NzUsXG4gICAgICA2MDQ2NjE3NlxuICAgIF07XG4gICAgcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihhLCBjKSB7XG4gICAgICBhID0gYSB8fCAxMCwgYyA9IGMgfCAwIHx8IDE7XG4gICAgICB2YXIgYjtcbiAgICAgIGlmIChhID09PSAxNiB8fCBhID09PSBcImhleFwiKSB7XG4gICAgICAgIGIgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBFID0gMCwgUyA9IDAsIHggPSAwOyB4IDwgdGhpcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgIHZhciB1ID0gdGhpcy53b3Jkc1t4XSwgbSA9ICgodSA8PCBFIHwgUykgJiAxNjc3NzIxNSkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgIFMgPSB1ID4+PiAyNCAtIEUgJiAxNjc3NzIxNSwgRSArPSAyLCBFID49IDI2ICYmIChFIC09IDI2LCB4LS0pLCBTICE9PSAwIHx8IHggIT09IHRoaXMubGVuZ3RoIC0gMSA/IGIgPSBBWzYgLSBtLmxlbmd0aF0gKyBtICsgYiA6IGIgPSBtICsgYjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKFMgIT09IDAgJiYgKGIgPSBTLnRvU3RyaW5nKDE2KSArIGIpOyBiLmxlbmd0aCAlIGMgIT09IDA7IClcbiAgICAgICAgICBiID0gXCIwXCIgKyBiO1xuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAoYiA9IFwiLVwiICsgYiksIGI7XG4gICAgICB9XG4gICAgICBpZiAoYSA9PT0gKGEgfCAwKSAmJiBhID49IDIgJiYgYSA8PSAzNikge1xuICAgICAgICB2YXIgZyA9IElbYV0sIFAgPSBEW2FdO1xuICAgICAgICBiID0gXCJcIjtcbiAgICAgICAgdmFyIEcgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGZvciAoRy5uZWdhdGl2ZSA9IDA7ICFHLmlzWmVybygpOyApIHtcbiAgICAgICAgICB2YXIgTSA9IEcubW9kcm4oUCkudG9TdHJpbmcoYSk7XG4gICAgICAgICAgRyA9IEcuaWRpdm4oUCksIEcuaXNaZXJvKCkgPyBiID0gTSArIGIgOiBiID0gQVtnIC0gTS5sZW5ndGhdICsgTSArIGI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh0aGlzLmlzWmVybygpICYmIChiID0gXCIwXCIgKyBiKTsgYi5sZW5ndGggJSBjICE9PSAwOyApXG4gICAgICAgICAgYiA9IFwiMFwiICsgYjtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDAgJiYgKGIgPSBcIi1cIiArIGIpLCBiO1xuICAgICAgfVxuICAgICAgaSghMSwgXCJCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2XCIpO1xuICAgIH0sIHMucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDIgPyBhICs9IHRoaXMud29yZHNbMV0gKiA2NzEwODg2NCA6IHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDEgPyBhICs9IDQ1MDM1OTk2MjczNzA0OTYgKyB0aGlzLndvcmRzWzFdICogNjcxMDg4NjQgOiB0aGlzLmxlbmd0aCA+IDIgJiYgaSghMSwgXCJOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHNcIiksIHRoaXMubmVnYXRpdmUgIT09IDAgPyAtYSA6IGE7XG4gICAgfSwgcy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNiwgMik7XG4gICAgfSwgbyAmJiAocy5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbihhLCBjKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShvLCBhLCBjKTtcbiAgICB9KSwgcy5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LCBhLCBjKTtcbiAgICB9O1xuICAgIHZhciBOID0gZnVuY3Rpb24oYSwgYykge1xuICAgICAgcmV0dXJuIGEuYWxsb2NVbnNhZmUgPyBhLmFsbG9jVW5zYWZlKGMpIDogbmV3IGEoYyk7XG4gICAgfTtcbiAgICBzLnByb3RvdHlwZS50b0FycmF5TGlrZSA9IGZ1bmN0aW9uKGEsIGMsIGIpIHtcbiAgICAgIHRoaXMuX3N0cmlwKCk7XG4gICAgICB2YXIgRSA9IHRoaXMuYnl0ZUxlbmd0aCgpLCBTID0gYiB8fCBNYXRoLm1heCgxLCBFKTtcbiAgICAgIGkoRSA8PSBTLCBcImJ5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGhcIiksIGkoUyA+IDAsIFwiUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwXCIpO1xuICAgICAgdmFyIHggPSBOKGEsIFMpLCB1ID0gYyA9PT0gXCJsZVwiID8gXCJMRVwiIDogXCJCRVwiO1xuICAgICAgcmV0dXJuIHRoaXNbXCJfdG9BcnJheUxpa2VcIiArIHVdKHgsIEUpLCB4O1xuICAgIH0sIHMucHJvdG90eXBlLl90b0FycmF5TGlrZUxFID0gZnVuY3Rpb24oYSwgYykge1xuICAgICAgZm9yICh2YXIgYiA9IDAsIEUgPSAwLCBTID0gMCwgeCA9IDA7IFMgPCB0aGlzLmxlbmd0aDsgUysrKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy53b3Jkc1tTXSA8PCB4IHwgRTtcbiAgICAgICAgYVtiKytdID0gdSAmIDI1NSwgYiA8IGEubGVuZ3RoICYmIChhW2IrK10gPSB1ID4+IDggJiAyNTUpLCBiIDwgYS5sZW5ndGggJiYgKGFbYisrXSA9IHUgPj4gMTYgJiAyNTUpLCB4ID09PSA2ID8gKGIgPCBhLmxlbmd0aCAmJiAoYVtiKytdID0gdSA+PiAyNCAmIDI1NSksIEUgPSAwLCB4ID0gMCkgOiAoRSA9IHUgPj4+IDI0LCB4ICs9IDIpO1xuICAgICAgfVxuICAgICAgaWYgKGIgPCBhLmxlbmd0aClcbiAgICAgICAgZm9yIChhW2IrK10gPSBFOyBiIDwgYS5sZW5ndGg7IClcbiAgICAgICAgICBhW2IrK10gPSAwO1xuICAgIH0sIHMucHJvdG90eXBlLl90b0FycmF5TGlrZUJFID0gZnVuY3Rpb24oYSwgYykge1xuICAgICAgZm9yICh2YXIgYiA9IGEubGVuZ3RoIC0gMSwgRSA9IDAsIFMgPSAwLCB4ID0gMDsgUyA8IHRoaXMubGVuZ3RoOyBTKyspIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLndvcmRzW1NdIDw8IHggfCBFO1xuICAgICAgICBhW2ItLV0gPSB1ICYgMjU1LCBiID49IDAgJiYgKGFbYi0tXSA9IHUgPj4gOCAmIDI1NSksIGIgPj0gMCAmJiAoYVtiLS1dID0gdSA+PiAxNiAmIDI1NSksIHggPT09IDYgPyAoYiA+PSAwICYmIChhW2ItLV0gPSB1ID4+IDI0ICYgMjU1KSwgRSA9IDAsIHggPSAwKSA6IChFID0gdSA+Pj4gMjQsIHggKz0gMik7XG4gICAgICB9XG4gICAgICBpZiAoYiA+PSAwKVxuICAgICAgICBmb3IgKGFbYi0tXSA9IEU7IGIgPj0gMDsgKVxuICAgICAgICAgIGFbYi0tXSA9IDA7XG4gICAgfSwgTWF0aC5jbHozMiA/IHMucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKGEpO1xuICAgIH0gOiBzLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIGMgPSBhLCBiID0gMDtcbiAgICAgIHJldHVybiBjID49IDQwOTYgJiYgKGIgKz0gMTMsIGMgPj4+PSAxMyksIGMgPj0gNjQgJiYgKGIgKz0gNywgYyA+Pj49IDcpLCBjID49IDggJiYgKGIgKz0gNCwgYyA+Pj49IDQpLCBjID49IDIgJiYgKGIgKz0gMiwgYyA+Pj49IDIpLCBiICsgYztcbiAgICB9LCBzLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbihhKSB7XG4gICAgICBpZiAoYSA9PT0gMClcbiAgICAgICAgcmV0dXJuIDI2O1xuICAgICAgdmFyIGMgPSBhLCBiID0gMDtcbiAgICAgIHJldHVybiBjICYgODE5MSB8fCAoYiArPSAxMywgYyA+Pj49IDEzKSwgYyAmIDEyNyB8fCAoYiArPSA3LCBjID4+Pj0gNyksIGMgJiAxNSB8fCAoYiArPSA0LCBjID4+Pj0gNCksIGMgJiAzIHx8IChiICs9IDIsIGMgPj4+PSAyKSwgYyAmIDEgfHwgYisrLCBiO1xuICAgIH0sIHMucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0sIGMgPSB0aGlzLl9jb3VudEJpdHMoYSk7XG4gICAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGM7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBrKGwpIHtcbiAgICAgIGZvciAodmFyIGEgPSBuZXcgQXJyYXkobC5iaXRMZW5ndGgoKSksIGMgPSAwOyBjIDwgYS5sZW5ndGg7IGMrKykge1xuICAgICAgICB2YXIgYiA9IGMgLyAyNiB8IDAsIEUgPSBjICUgMjY7XG4gICAgICAgIGFbY10gPSBsLndvcmRzW2JdID4+PiBFICYgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBzLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgZm9yICh2YXIgYSA9IDAsIGMgPSAwOyBjIDwgdGhpcy5sZW5ndGg7IGMrKykge1xuICAgICAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbY10pO1xuICAgICAgICBpZiAoYSArPSBiLCBiICE9PSAyNilcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhO1xuICAgIH0sIHMucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICAgIH0sIHMucHJvdG90eXBlLnRvVHdvcyA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwID8gdGhpcy5hYnMoKS5pbm90bihhKS5pYWRkbigxKSA6IHRoaXMuY2xvbmUoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlc3RuKGEgLSAxKSA/IHRoaXMubm90bihhKS5pYWRkbigxKS5pbmVnKCkgOiB0aGlzLmNsb25lKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICAgIH0sIHMucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNaZXJvKCkgfHwgKHRoaXMubmVnYXRpdmUgXj0gMSksIHRoaXM7XG4gICAgfSwgcy5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIGZvciAoOyB0aGlzLmxlbmd0aCA8IGEubGVuZ3RoOyApXG4gICAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBhLmxlbmd0aDsgYysrKVxuICAgICAgICB0aGlzLndvcmRzW2NdID0gdGhpcy53b3Jkc1tjXSB8IGEud29yZHNbY107XG4gICAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gaSgodGhpcy5uZWdhdGl2ZSB8IGEubmVnYXRpdmUpID09PSAwKSwgdGhpcy5pdW9yKGEpO1xuICAgIH0sIHMucHJvdG90eXBlLm9yID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gYS5sZW5ndGggPyB0aGlzLmNsb25lKCkuaW9yKGEpIDogYS5jbG9uZSgpLmlvcih0aGlzKTtcbiAgICB9LCBzLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPiBhLmxlbmd0aCA/IHRoaXMuY2xvbmUoKS5pdW9yKGEpIDogYS5jbG9uZSgpLml1b3IodGhpcyk7XG4gICAgfSwgcy5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYztcbiAgICAgIHRoaXMubGVuZ3RoID4gYS5sZW5ndGggPyBjID0gYSA6IGMgPSB0aGlzO1xuICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjLmxlbmd0aDsgYisrKVxuICAgICAgICB0aGlzLndvcmRzW2JdID0gdGhpcy53b3Jkc1tiXSAmIGEud29yZHNbYl07XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPSBjLmxlbmd0aCwgdGhpcy5fc3RyaXAoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGkoKHRoaXMubmVnYXRpdmUgfCBhLm5lZ2F0aXZlKSA9PT0gMCksIHRoaXMuaXVhbmQoYSk7XG4gICAgfSwgcy5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gYS5sZW5ndGggPyB0aGlzLmNsb25lKCkuaWFuZChhKSA6IGEuY2xvbmUoKS5pYW5kKHRoaXMpO1xuICAgIH0sIHMucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPiBhLmxlbmd0aCA/IHRoaXMuY2xvbmUoKS5pdWFuZChhKSA6IGEuY2xvbmUoKS5pdWFuZCh0aGlzKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBjLCBiO1xuICAgICAgdGhpcy5sZW5ndGggPiBhLmxlbmd0aCA/IChjID0gdGhpcywgYiA9IGEpIDogKGMgPSBhLCBiID0gdGhpcyk7XG4gICAgICBmb3IgKHZhciBFID0gMDsgRSA8IGIubGVuZ3RoOyBFKyspXG4gICAgICAgIHRoaXMud29yZHNbRV0gPSBjLndvcmRzW0VdIF4gYi53b3Jkc1tFXTtcbiAgICAgIGlmICh0aGlzICE9PSBjKVxuICAgICAgICBmb3IgKDsgRSA8IGMubGVuZ3RoOyBFKyspXG4gICAgICAgICAgdGhpcy53b3Jkc1tFXSA9IGMud29yZHNbRV07XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPSBjLmxlbmd0aCwgdGhpcy5fc3RyaXAoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGkoKHRoaXMubmVnYXRpdmUgfCBhLm5lZ2F0aXZlKSA9PT0gMCksIHRoaXMuaXV4b3IoYSk7XG4gICAgfSwgcy5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gYS5sZW5ndGggPyB0aGlzLmNsb25lKCkuaXhvcihhKSA6IGEuY2xvbmUoKS5peG9yKHRoaXMpO1xuICAgIH0sIHMucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPiBhLmxlbmd0aCA/IHRoaXMuY2xvbmUoKS5pdXhvcihhKSA6IGEuY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIGkodHlwZW9mIGEgPT0gXCJudW1iZXJcIiAmJiBhID49IDApO1xuICAgICAgdmFyIGMgPSBNYXRoLmNlaWwoYSAvIDI2KSB8IDAsIGIgPSBhICUgMjY7XG4gICAgICB0aGlzLl9leHBhbmQoYyksIGIgPiAwICYmIGMtLTtcbiAgICAgIGZvciAodmFyIEUgPSAwOyBFIDwgYzsgRSsrKVxuICAgICAgICB0aGlzLndvcmRzW0VdID0gfnRoaXMud29yZHNbRV0gJiA2NzEwODg2MztcbiAgICAgIHJldHVybiBiID4gMCAmJiAodGhpcy53b3Jkc1tFXSA9IH50aGlzLndvcmRzW0VdICYgNjcxMDg4NjMgPj4gMjYgLSBiKSwgdGhpcy5fc3RyaXAoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bihhKTtcbiAgICB9LCBzLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24oYSwgYykge1xuICAgICAgaSh0eXBlb2YgYSA9PSBcIm51bWJlclwiICYmIGEgPj0gMCk7XG4gICAgICB2YXIgYiA9IGEgLyAyNiB8IDAsIEUgPSBhICUgMjY7XG4gICAgICByZXR1cm4gdGhpcy5fZXhwYW5kKGIgKyAxKSwgYyA/IHRoaXMud29yZHNbYl0gPSB0aGlzLndvcmRzW2JdIHwgMSA8PCBFIDogdGhpcy53b3Jkc1tiXSA9IHRoaXMud29yZHNbYl0gJiB+KDEgPDwgRSksIHRoaXMuX3N0cmlwKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBjO1xuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgYS5uZWdhdGl2ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgPSAwLCBjID0gdGhpcy5pc3ViKGEpLCB0aGlzLm5lZ2F0aXZlIF49IDEsIHRoaXMuX25vcm1TaWduKCk7XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBhLm5lZ2F0aXZlICE9PSAwKVxuICAgICAgICByZXR1cm4gYS5uZWdhdGl2ZSA9IDAsIGMgPSB0aGlzLmlzdWIoYSksIGEubmVnYXRpdmUgPSAxLCBjLl9ub3JtU2lnbigpO1xuICAgICAgdmFyIGIsIEU7XG4gICAgICB0aGlzLmxlbmd0aCA+IGEubGVuZ3RoID8gKGIgPSB0aGlzLCBFID0gYSkgOiAoYiA9IGEsIEUgPSB0aGlzKTtcbiAgICAgIGZvciAodmFyIFMgPSAwLCB4ID0gMDsgeCA8IEUubGVuZ3RoOyB4KyspXG4gICAgICAgIGMgPSAoYi53b3Jkc1t4XSB8IDApICsgKEUud29yZHNbeF0gfCAwKSArIFMsIHRoaXMud29yZHNbeF0gPSBjICYgNjcxMDg4NjMsIFMgPSBjID4+PiAyNjtcbiAgICAgIGZvciAoOyBTICE9PSAwICYmIHggPCBiLmxlbmd0aDsgeCsrKVxuICAgICAgICBjID0gKGIud29yZHNbeF0gfCAwKSArIFMsIHRoaXMud29yZHNbeF0gPSBjICYgNjcxMDg4NjMsIFMgPSBjID4+PiAyNjtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9IGIubGVuZ3RoLCBTICE9PSAwKVxuICAgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IFMsIHRoaXMubGVuZ3RoKys7XG4gICAgICBlbHNlIGlmIChiICE9PSB0aGlzKVxuICAgICAgICBmb3IgKDsgeCA8IGIubGVuZ3RoOyB4KyspXG4gICAgICAgICAgdGhpcy53b3Jkc1t4XSA9IGIud29yZHNbeF07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYztcbiAgICAgIHJldHVybiBhLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDAgPyAoYS5uZWdhdGl2ZSA9IDAsIGMgPSB0aGlzLnN1YihhKSwgYS5uZWdhdGl2ZSBePSAxLCBjKSA6IGEubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCA/ICh0aGlzLm5lZ2F0aXZlID0gMCwgYyA9IGEuc3ViKHRoaXMpLCB0aGlzLm5lZ2F0aXZlID0gMSwgYykgOiB0aGlzLmxlbmd0aCA+IGEubGVuZ3RoID8gdGhpcy5jbG9uZSgpLmlhZGQoYSkgOiBhLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24oYSkge1xuICAgICAgaWYgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHZhciBjID0gdGhpcy5pYWRkKGEpO1xuICAgICAgICByZXR1cm4gYS5uZWdhdGl2ZSA9IDEsIGMuX25vcm1TaWduKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApXG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlID0gMCwgdGhpcy5pYWRkKGEpLCB0aGlzLm5lZ2F0aXZlID0gMSwgdGhpcy5fbm9ybVNpZ24oKTtcbiAgICAgIHZhciBiID0gdGhpcy5jbXAoYSk7XG4gICAgICBpZiAoYiA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgPSAwLCB0aGlzLmxlbmd0aCA9IDEsIHRoaXMud29yZHNbMF0gPSAwLCB0aGlzO1xuICAgICAgdmFyIEUsIFM7XG4gICAgICBiID4gMCA/IChFID0gdGhpcywgUyA9IGEpIDogKEUgPSBhLCBTID0gdGhpcyk7XG4gICAgICBmb3IgKHZhciB4ID0gMCwgdSA9IDA7IHUgPCBTLmxlbmd0aDsgdSsrKVxuICAgICAgICBjID0gKEUud29yZHNbdV0gfCAwKSAtIChTLndvcmRzW3VdIHwgMCkgKyB4LCB4ID0gYyA+PiAyNiwgdGhpcy53b3Jkc1t1XSA9IGMgJiA2NzEwODg2MztcbiAgICAgIGZvciAoOyB4ICE9PSAwICYmIHUgPCBFLmxlbmd0aDsgdSsrKVxuICAgICAgICBjID0gKEUud29yZHNbdV0gfCAwKSArIHgsIHggPSBjID4+IDI2LCB0aGlzLndvcmRzW3VdID0gYyAmIDY3MTA4ODYzO1xuICAgICAgaWYgKHggPT09IDAgJiYgdSA8IEUubGVuZ3RoICYmIEUgIT09IHRoaXMpXG4gICAgICAgIGZvciAoOyB1IDwgRS5sZW5ndGg7IHUrKylcbiAgICAgICAgICB0aGlzLndvcmRzW3VdID0gRS53b3Jkc1t1XTtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCB1KSwgRSAhPT0gdGhpcyAmJiAodGhpcy5uZWdhdGl2ZSA9IDEpLCB0aGlzLl9zdHJpcCgpO1xuICAgIH0sIHMucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihhKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGoobCwgYSwgYykge1xuICAgICAgYy5uZWdhdGl2ZSA9IGEubmVnYXRpdmUgXiBsLm5lZ2F0aXZlO1xuICAgICAgdmFyIGIgPSBsLmxlbmd0aCArIGEubGVuZ3RoIHwgMDtcbiAgICAgIGMubGVuZ3RoID0gYiwgYiA9IGIgLSAxIHwgMDtcbiAgICAgIHZhciBFID0gbC53b3Jkc1swXSB8IDAsIFMgPSBhLndvcmRzWzBdIHwgMCwgeCA9IEUgKiBTLCB1ID0geCAmIDY3MTA4ODYzLCBtID0geCAvIDY3MTA4ODY0IHwgMDtcbiAgICAgIGMud29yZHNbMF0gPSB1O1xuICAgICAgZm9yICh2YXIgZyA9IDE7IGcgPCBiOyBnKyspIHtcbiAgICAgICAgZm9yICh2YXIgUCA9IG0gPj4+IDI2LCBHID0gbSAmIDY3MTA4ODYzLCBNID0gTWF0aC5taW4oZywgYS5sZW5ndGggLSAxKSwgSCA9IE1hdGgubWF4KDAsIGcgLSBsLmxlbmd0aCArIDEpOyBIIDw9IE07IEgrKykge1xuICAgICAgICAgIHZhciBDID0gZyAtIEggfCAwO1xuICAgICAgICAgIEUgPSBsLndvcmRzW0NdIHwgMCwgUyA9IGEud29yZHNbSF0gfCAwLCB4ID0gRSAqIFMgKyBHLCBQICs9IHggLyA2NzEwODg2NCB8IDAsIEcgPSB4ICYgNjcxMDg4NjM7XG4gICAgICAgIH1cbiAgICAgICAgYy53b3Jkc1tnXSA9IEcgfCAwLCBtID0gUCB8IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbSAhPT0gMCA/IGMud29yZHNbZ10gPSBtIHwgMCA6IGMubGVuZ3RoLS0sIGMuX3N0cmlwKCk7XG4gICAgfVxuICAgIHZhciBUID0gZnVuY3Rpb24oYSwgYywgYikge1xuICAgICAgdmFyIEUgPSBhLndvcmRzLCBTID0gYy53b3JkcywgeCA9IGIud29yZHMsIHUgPSAwLCBtLCBnLCBQLCBHID0gRVswXSB8IDAsIE0gPSBHICYgODE5MSwgSCA9IEcgPj4+IDEzLCBDID0gRVsxXSB8IDAsIHEgPSBDICYgODE5MSwgTCA9IEMgPj4+IDEzLCB5ID0gRVsyXSB8IDAsIEYgPSB5ICYgODE5MSwgVyA9IHkgPj4+IDEzLCBZID0gRVszXSB8IDAsIFggPSBZICYgODE5MSwgZWUgPSBZID4+PiAxMywgd2UgPSBFWzRdIHwgMCwgTWUgPSB3ZSAmIDgxOTEsIGhlID0gd2UgPj4+IDEzLCBSZSA9IEVbNV0gfCAwLCB4ZSA9IFJlICYgODE5MSwgc2UgPSBSZSA+Pj4gMTMsIGdlID0gRVs2XSB8IDAsIGxlID0gZ2UgJiA4MTkxLCBuZSA9IGdlID4+PiAxMywgdWUgPSBFWzddIHwgMCwgZmUgPSB1ZSAmIDgxOTEsIHRlID0gdWUgPj4+IDEzLCBwZSA9IEVbOF0gfCAwLCBfZSA9IHBlICYgODE5MSwgcmUgPSBwZSA+Pj4gMTMsIEVlID0gRVs5XSB8IDAsIFNlID0gRWUgJiA4MTkxLCBvZSA9IEVlID4+PiAxMywgRGUgPSBTWzBdIHwgMCwgSWUgPSBEZSAmIDgxOTEsIFBlID0gRGUgPj4+IDEzLCBHZSA9IFNbMV0gfCAwLCBZZSA9IEdlICYgODE5MSwgQWUgPSBHZSA+Pj4gMTMsIFplID0gU1syXSB8IDAsIGV0ID0gWmUgJiA4MTkxLCBOZSA9IFplID4+PiAxMywgQ2UgPSBTWzNdIHwgMCwgVGUgPSBDZSAmIDgxOTEsIGRlID0gQ2UgPj4+IDEzLCAkZSA9IFNbNF0gfCAwLCBMZSA9ICRlICYgODE5MSwgY2UgPSAkZSA+Pj4gMTMsIFVlID0gU1s1XSB8IDAsIHplID0gVWUgJiA4MTkxLCB5ZSA9IFVlID4+PiAxMywgQmUgPSBTWzZdIHwgMCwga2UgPSBCZSAmIDgxOTEsIHZlID0gQmUgPj4+IDEzLCBGZSA9IFNbN10gfCAwLCBPZSA9IEZlICYgODE5MSwgbWUgPSBGZSA+Pj4gMTMsIGplID0gU1s4XSB8IDAsIHJ0ID0gamUgJiA4MTkxLCBxZSA9IGplID4+PiAxMywgaXQgPSBTWzldIHwgMCwgSmUgPSBpdCAmIDgxOTEsIHR0ID0gaXQgPj4+IDEzO1xuICAgICAgYi5uZWdhdGl2ZSA9IGEubmVnYXRpdmUgXiBjLm5lZ2F0aXZlLCBiLmxlbmd0aCA9IDE5LCBtID0gTWF0aC5pbXVsKE0sIEllKSwgZyA9IE1hdGguaW11bChNLCBQZSksIGcgPSBnICsgTWF0aC5pbXVsKEgsIEllKSB8IDAsIFAgPSBNYXRoLmltdWwoSCwgUGUpO1xuICAgICAgdmFyIGp0ID0gKHUgKyBtIHwgMCkgKyAoKGcgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgdSA9IChQICsgKGcgPj4+IDEzKSB8IDApICsgKGp0ID4+PiAyNikgfCAwLCBqdCAmPSA2NzEwODg2MywgbSA9IE1hdGguaW11bChxLCBJZSksIGcgPSBNYXRoLmltdWwocSwgUGUpLCBnID0gZyArIE1hdGguaW11bChMLCBJZSkgfCAwLCBQID0gTWF0aC5pbXVsKEwsIFBlKSwgbSA9IG0gKyBNYXRoLmltdWwoTSwgWWUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoTSwgQWUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoSCwgWWUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoSCwgQWUpIHwgMDtcbiAgICAgIHZhciBLdCA9ICh1ICsgbSB8IDApICsgKChnICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgIHUgPSAoUCArIChnID4+PiAxMykgfCAwKSArIChLdCA+Pj4gMjYpIHwgMCwgS3QgJj0gNjcxMDg4NjMsIG0gPSBNYXRoLmltdWwoRiwgSWUpLCBnID0gTWF0aC5pbXVsKEYsIFBlKSwgZyA9IGcgKyBNYXRoLmltdWwoVywgSWUpIHwgMCwgUCA9IE1hdGguaW11bChXLCBQZSksIG0gPSBtICsgTWF0aC5pbXVsKHEsIFllKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHEsIEFlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEwsIFllKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKEwsIEFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE0sIGV0KSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKE0sIE5lKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEgsIGV0KSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKEgsIE5lKSB8IDA7XG4gICAgICB2YXIgSHQgPSAodSArIG0gfCAwKSArICgoZyAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICB1ID0gKFAgKyAoZyA+Pj4gMTMpIHwgMCkgKyAoSHQgPj4+IDI2KSB8IDAsIEh0ICY9IDY3MTA4ODYzLCBtID0gTWF0aC5pbXVsKFgsIEllKSwgZyA9IE1hdGguaW11bChYLCBQZSksIGcgPSBnICsgTWF0aC5pbXVsKGVlLCBJZSkgfCAwLCBQID0gTWF0aC5pbXVsKGVlLCBQZSksIG0gPSBtICsgTWF0aC5pbXVsKEYsIFllKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEYsIEFlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKFcsIFllKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKFcsIEFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHEsIGV0KSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHEsIE5lKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEwsIGV0KSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKEwsIE5lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE0sIFRlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKE0sIGRlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEgsIFRlKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKEgsIGRlKSB8IDA7XG4gICAgICB2YXIgVnQgPSAodSArIG0gfCAwKSArICgoZyAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICB1ID0gKFAgKyAoZyA+Pj4gMTMpIHwgMCkgKyAoVnQgPj4+IDI2KSB8IDAsIFZ0ICY9IDY3MTA4ODYzLCBtID0gTWF0aC5pbXVsKE1lLCBJZSksIGcgPSBNYXRoLmltdWwoTWUsIFBlKSwgZyA9IGcgKyBNYXRoLmltdWwoaGUsIEllKSB8IDAsIFAgPSBNYXRoLmltdWwoaGUsIFBlKSwgbSA9IG0gKyBNYXRoLmltdWwoWCwgWWUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoWCwgQWUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoZWUsIFllKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKGVlLCBBZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChGLCBldCkgfCAwLCBnID0gZyArIE1hdGguaW11bChGLCBOZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChXLCBldCkgfCAwLCBQID0gUCArIE1hdGguaW11bChXLCBOZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChxLCBUZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChxLCBkZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChMLCBUZSkgfCAwLCBQID0gUCArIE1hdGguaW11bChMLCBkZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChNLCBMZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChNLCBjZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChILCBMZSkgfCAwLCBQID0gUCArIE1hdGguaW11bChILCBjZSkgfCAwO1xuICAgICAgdmFyIGd0ID0gKHUgKyBtIHwgMCkgKyAoKGcgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgdSA9IChQICsgKGcgPj4+IDEzKSB8IDApICsgKGd0ID4+PiAyNikgfCAwLCBndCAmPSA2NzEwODg2MywgbSA9IE1hdGguaW11bCh4ZSwgSWUpLCBnID0gTWF0aC5pbXVsKHhlLCBQZSksIGcgPSBnICsgTWF0aC5pbXVsKHNlLCBJZSkgfCAwLCBQID0gTWF0aC5pbXVsKHNlLCBQZSksIG0gPSBtICsgTWF0aC5pbXVsKE1lLCBZZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChNZSwgQWUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoaGUsIFllKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKGhlLCBBZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChYLCBldCkgfCAwLCBnID0gZyArIE1hdGguaW11bChYLCBOZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChlZSwgZXQpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoZWUsIE5lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEYsIFRlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEYsIGRlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKFcsIFRlKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKFcsIGRlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHEsIExlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHEsIGNlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEwsIExlKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKEwsIGNlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE0sIHplKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKE0sIHllKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEgsIHplKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKEgsIHllKSB8IDA7XG4gICAgICB2YXIgVnIgPSAodSArIG0gfCAwKSArICgoZyAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICB1ID0gKFAgKyAoZyA+Pj4gMTMpIHwgMCkgKyAoVnIgPj4+IDI2KSB8IDAsIFZyICY9IDY3MTA4ODYzLCBtID0gTWF0aC5pbXVsKGxlLCBJZSksIGcgPSBNYXRoLmltdWwobGUsIFBlKSwgZyA9IGcgKyBNYXRoLmltdWwobmUsIEllKSB8IDAsIFAgPSBNYXRoLmltdWwobmUsIFBlKSwgbSA9IG0gKyBNYXRoLmltdWwoeGUsIFllKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHhlLCBBZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChzZSwgWWUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoc2UsIEFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE1lLCBldCkgfCAwLCBnID0gZyArIE1hdGguaW11bChNZSwgTmUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoaGUsIGV0KSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKGhlLCBOZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChYLCBUZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChYLCBkZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChlZSwgVGUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoZWUsIGRlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEYsIExlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEYsIGNlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKFcsIExlKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKFcsIGNlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHEsIHplKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHEsIHllKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEwsIHplKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKEwsIHllKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE0sIGtlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKE0sIHZlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEgsIGtlKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKEgsIHZlKSB8IDA7XG4gICAgICB2YXIgV3IgPSAodSArIG0gfCAwKSArICgoZyAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICB1ID0gKFAgKyAoZyA+Pj4gMTMpIHwgMCkgKyAoV3IgPj4+IDI2KSB8IDAsIFdyICY9IDY3MTA4ODYzLCBtID0gTWF0aC5pbXVsKGZlLCBJZSksIGcgPSBNYXRoLmltdWwoZmUsIFBlKSwgZyA9IGcgKyBNYXRoLmltdWwodGUsIEllKSB8IDAsIFAgPSBNYXRoLmltdWwodGUsIFBlKSwgbSA9IG0gKyBNYXRoLmltdWwobGUsIFllKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKGxlLCBBZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChuZSwgWWUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwobmUsIEFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHhlLCBldCkgfCAwLCBnID0gZyArIE1hdGguaW11bCh4ZSwgTmUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoc2UsIGV0KSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKHNlLCBOZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChNZSwgVGUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoTWUsIGRlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKGhlLCBUZSkgfCAwLCBQID0gUCArIE1hdGguaW11bChoZSwgZGUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoWCwgTGUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoWCwgY2UpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoZWUsIExlKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKGVlLCBjZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChGLCB6ZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChGLCB5ZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChXLCB6ZSkgfCAwLCBQID0gUCArIE1hdGguaW11bChXLCB5ZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChxLCBrZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChxLCB2ZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChMLCBrZSkgfCAwLCBQID0gUCArIE1hdGguaW11bChMLCB2ZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChNLCBPZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChNLCBtZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChILCBPZSkgfCAwLCBQID0gUCArIE1hdGguaW11bChILCBtZSkgfCAwO1xuICAgICAgdmFyIEdyID0gKHUgKyBtIHwgMCkgKyAoKGcgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgdSA9IChQICsgKGcgPj4+IDEzKSB8IDApICsgKEdyID4+PiAyNikgfCAwLCBHciAmPSA2NzEwODg2MywgbSA9IE1hdGguaW11bChfZSwgSWUpLCBnID0gTWF0aC5pbXVsKF9lLCBQZSksIGcgPSBnICsgTWF0aC5pbXVsKHJlLCBJZSkgfCAwLCBQID0gTWF0aC5pbXVsKHJlLCBQZSksIG0gPSBtICsgTWF0aC5pbXVsKGZlLCBZZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChmZSwgQWUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwodGUsIFllKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKHRlLCBBZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChsZSwgZXQpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwobGUsIE5lKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKG5lLCBldCkgfCAwLCBQID0gUCArIE1hdGguaW11bChuZSwgTmUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeGUsIFRlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHhlLCBkZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChzZSwgVGUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoc2UsIGRlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE1lLCBMZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChNZSwgY2UpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoaGUsIExlKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKGhlLCBjZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChYLCB6ZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChYLCB5ZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChlZSwgemUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoZWUsIHllKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEYsIGtlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEYsIHZlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKFcsIGtlKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKFcsIHZlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHEsIE9lKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHEsIG1lKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEwsIE9lKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKEwsIG1lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE0sIHJ0KSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKE0sIHFlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEgsIHJ0KSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKEgsIHFlKSB8IDA7XG4gICAgICB2YXIgSnIgPSAodSArIG0gfCAwKSArICgoZyAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICB1ID0gKFAgKyAoZyA+Pj4gMTMpIHwgMCkgKyAoSnIgPj4+IDI2KSB8IDAsIEpyICY9IDY3MTA4ODYzLCBtID0gTWF0aC5pbXVsKFNlLCBJZSksIGcgPSBNYXRoLmltdWwoU2UsIFBlKSwgZyA9IGcgKyBNYXRoLmltdWwob2UsIEllKSB8IDAsIFAgPSBNYXRoLmltdWwob2UsIFBlKSwgbSA9IG0gKyBNYXRoLmltdWwoX2UsIFllKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKF9lLCBBZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChyZSwgWWUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwocmUsIEFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGZlLCBldCkgfCAwLCBnID0gZyArIE1hdGguaW11bChmZSwgTmUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwodGUsIGV0KSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKHRlLCBOZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChsZSwgVGUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwobGUsIGRlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKG5lLCBUZSkgfCAwLCBQID0gUCArIE1hdGguaW11bChuZSwgZGUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeGUsIExlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHhlLCBjZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChzZSwgTGUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoc2UsIGNlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE1lLCB6ZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChNZSwgeWUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoaGUsIHplKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKGhlLCB5ZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChYLCBrZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChYLCB2ZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChlZSwga2UpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoZWUsIHZlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEYsIE9lKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEYsIG1lKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKFcsIE9lKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKFcsIG1lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHEsIHJ0KSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHEsIHFlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEwsIHJ0KSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKEwsIHFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE0sIEplKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKE0sIHR0KSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEgsIEplKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKEgsIHR0KSB8IDA7XG4gICAgICB2YXIgWXIgPSAodSArIG0gfCAwKSArICgoZyAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICB1ID0gKFAgKyAoZyA+Pj4gMTMpIHwgMCkgKyAoWXIgPj4+IDI2KSB8IDAsIFlyICY9IDY3MTA4ODYzLCBtID0gTWF0aC5pbXVsKFNlLCBZZSksIGcgPSBNYXRoLmltdWwoU2UsIEFlKSwgZyA9IGcgKyBNYXRoLmltdWwob2UsIFllKSB8IDAsIFAgPSBNYXRoLmltdWwob2UsIEFlKSwgbSA9IG0gKyBNYXRoLmltdWwoX2UsIGV0KSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKF9lLCBOZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChyZSwgZXQpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwocmUsIE5lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGZlLCBUZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChmZSwgZGUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwodGUsIFRlKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKHRlLCBkZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChsZSwgTGUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwobGUsIGNlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKG5lLCBMZSkgfCAwLCBQID0gUCArIE1hdGguaW11bChuZSwgY2UpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeGUsIHplKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHhlLCB5ZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChzZSwgemUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoc2UsIHllKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE1lLCBrZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChNZSwgdmUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoaGUsIGtlKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKGhlLCB2ZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChYLCBPZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChYLCBtZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChlZSwgT2UpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoZWUsIG1lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEYsIHJ0KSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEYsIHFlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKFcsIHJ0KSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKFcsIHFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHEsIEplKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHEsIHR0KSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEwsIEplKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKEwsIHR0KSB8IDA7XG4gICAgICB2YXIgb3IgPSAodSArIG0gfCAwKSArICgoZyAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICB1ID0gKFAgKyAoZyA+Pj4gMTMpIHwgMCkgKyAob3IgPj4+IDI2KSB8IDAsIG9yICY9IDY3MTA4ODYzLCBtID0gTWF0aC5pbXVsKFNlLCBldCksIGcgPSBNYXRoLmltdWwoU2UsIE5lKSwgZyA9IGcgKyBNYXRoLmltdWwob2UsIGV0KSB8IDAsIFAgPSBNYXRoLmltdWwob2UsIE5lKSwgbSA9IG0gKyBNYXRoLmltdWwoX2UsIFRlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKF9lLCBkZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChyZSwgVGUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwocmUsIGRlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGZlLCBMZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChmZSwgY2UpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwodGUsIExlKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKHRlLCBjZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChsZSwgemUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwobGUsIHllKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKG5lLCB6ZSkgfCAwLCBQID0gUCArIE1hdGguaW11bChuZSwgeWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeGUsIGtlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHhlLCB2ZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChzZSwga2UpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoc2UsIHZlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE1lLCBPZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChNZSwgbWUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoaGUsIE9lKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKGhlLCBtZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChYLCBydCkgfCAwLCBnID0gZyArIE1hdGguaW11bChYLCBxZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChlZSwgcnQpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoZWUsIHFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEYsIEplKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKEYsIHR0KSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKFcsIEplKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKFcsIHR0KSB8IDA7XG4gICAgICB2YXIgWHIgPSAodSArIG0gfCAwKSArICgoZyAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICB1ID0gKFAgKyAoZyA+Pj4gMTMpIHwgMCkgKyAoWHIgPj4+IDI2KSB8IDAsIFhyICY9IDY3MTA4ODYzLCBtID0gTWF0aC5pbXVsKFNlLCBUZSksIGcgPSBNYXRoLmltdWwoU2UsIGRlKSwgZyA9IGcgKyBNYXRoLmltdWwob2UsIFRlKSB8IDAsIFAgPSBNYXRoLmltdWwob2UsIGRlKSwgbSA9IG0gKyBNYXRoLmltdWwoX2UsIExlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKF9lLCBjZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChyZSwgTGUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwocmUsIGNlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGZlLCB6ZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChmZSwgeWUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwodGUsIHplKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKHRlLCB5ZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChsZSwga2UpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwobGUsIHZlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKG5lLCBrZSkgfCAwLCBQID0gUCArIE1hdGguaW11bChuZSwgdmUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeGUsIE9lKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHhlLCBtZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChzZSwgT2UpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoc2UsIG1lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE1lLCBydCkgfCAwLCBnID0gZyArIE1hdGguaW11bChNZSwgcWUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoaGUsIHJ0KSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKGhlLCBxZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChYLCBKZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChYLCB0dCkgfCAwLCBnID0gZyArIE1hdGguaW11bChlZSwgSmUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoZWUsIHR0KSB8IDA7XG4gICAgICB2YXIgWnIgPSAodSArIG0gfCAwKSArICgoZyAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICB1ID0gKFAgKyAoZyA+Pj4gMTMpIHwgMCkgKyAoWnIgPj4+IDI2KSB8IDAsIFpyICY9IDY3MTA4ODYzLCBtID0gTWF0aC5pbXVsKFNlLCBMZSksIGcgPSBNYXRoLmltdWwoU2UsIGNlKSwgZyA9IGcgKyBNYXRoLmltdWwob2UsIExlKSB8IDAsIFAgPSBNYXRoLmltdWwob2UsIGNlKSwgbSA9IG0gKyBNYXRoLmltdWwoX2UsIHplKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKF9lLCB5ZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChyZSwgemUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwocmUsIHllKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGZlLCBrZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChmZSwgdmUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwodGUsIGtlKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKHRlLCB2ZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChsZSwgT2UpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwobGUsIG1lKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKG5lLCBPZSkgfCAwLCBQID0gUCArIE1hdGguaW11bChuZSwgbWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeGUsIHJ0KSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHhlLCBxZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChzZSwgcnQpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwoc2UsIHFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE1lLCBKZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChNZSwgdHQpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoaGUsIEplKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKGhlLCB0dCkgfCAwO1xuICAgICAgdmFyICR0ID0gKHUgKyBtIHwgMCkgKyAoKGcgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgdSA9IChQICsgKGcgPj4+IDEzKSB8IDApICsgKCR0ID4+PiAyNikgfCAwLCAkdCAmPSA2NzEwODg2MywgbSA9IE1hdGguaW11bChTZSwgemUpLCBnID0gTWF0aC5pbXVsKFNlLCB5ZSksIGcgPSBnICsgTWF0aC5pbXVsKG9lLCB6ZSkgfCAwLCBQID0gTWF0aC5pbXVsKG9lLCB5ZSksIG0gPSBtICsgTWF0aC5pbXVsKF9lLCBrZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChfZSwgdmUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwocmUsIGtlKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKHJlLCB2ZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChmZSwgT2UpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoZmUsIG1lKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHRlLCBPZSkgfCAwLCBQID0gUCArIE1hdGguaW11bCh0ZSwgbWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwobGUsIHJ0KSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKGxlLCBxZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChuZSwgcnQpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwobmUsIHFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHhlLCBKZSkgfCAwLCBnID0gZyArIE1hdGguaW11bCh4ZSwgdHQpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoc2UsIEplKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKHNlLCB0dCkgfCAwO1xuICAgICAgdmFyIFFyID0gKHUgKyBtIHwgMCkgKyAoKGcgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgdSA9IChQICsgKGcgPj4+IDEzKSB8IDApICsgKFFyID4+PiAyNikgfCAwLCBRciAmPSA2NzEwODg2MywgbSA9IE1hdGguaW11bChTZSwga2UpLCBnID0gTWF0aC5pbXVsKFNlLCB2ZSksIGcgPSBnICsgTWF0aC5pbXVsKG9lLCBrZSkgfCAwLCBQID0gTWF0aC5pbXVsKG9lLCB2ZSksIG0gPSBtICsgTWF0aC5pbXVsKF9lLCBPZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChfZSwgbWUpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwocmUsIE9lKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKHJlLCBtZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChmZSwgcnQpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwoZmUsIHFlKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKHRlLCBydCkgfCAwLCBQID0gUCArIE1hdGguaW11bCh0ZSwgcWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwobGUsIEplKSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKGxlLCB0dCkgfCAwLCBnID0gZyArIE1hdGguaW11bChuZSwgSmUpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwobmUsIHR0KSB8IDA7XG4gICAgICB2YXIgZWkgPSAodSArIG0gfCAwKSArICgoZyAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICB1ID0gKFAgKyAoZyA+Pj4gMTMpIHwgMCkgKyAoZWkgPj4+IDI2KSB8IDAsIGVpICY9IDY3MTA4ODYzLCBtID0gTWF0aC5pbXVsKFNlLCBPZSksIGcgPSBNYXRoLmltdWwoU2UsIG1lKSwgZyA9IGcgKyBNYXRoLmltdWwob2UsIE9lKSB8IDAsIFAgPSBNYXRoLmltdWwob2UsIG1lKSwgbSA9IG0gKyBNYXRoLmltdWwoX2UsIHJ0KSB8IDAsIGcgPSBnICsgTWF0aC5pbXVsKF9lLCBxZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChyZSwgcnQpIHwgMCwgUCA9IFAgKyBNYXRoLmltdWwocmUsIHFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGZlLCBKZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChmZSwgdHQpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwodGUsIEplKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKHRlLCB0dCkgfCAwO1xuICAgICAgdmFyIHRpID0gKHUgKyBtIHwgMCkgKyAoKGcgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgdSA9IChQICsgKGcgPj4+IDEzKSB8IDApICsgKHRpID4+PiAyNikgfCAwLCB0aSAmPSA2NzEwODg2MywgbSA9IE1hdGguaW11bChTZSwgcnQpLCBnID0gTWF0aC5pbXVsKFNlLCBxZSksIGcgPSBnICsgTWF0aC5pbXVsKG9lLCBydCkgfCAwLCBQID0gTWF0aC5pbXVsKG9lLCBxZSksIG0gPSBtICsgTWF0aC5pbXVsKF9lLCBKZSkgfCAwLCBnID0gZyArIE1hdGguaW11bChfZSwgdHQpIHwgMCwgZyA9IGcgKyBNYXRoLmltdWwocmUsIEplKSB8IDAsIFAgPSBQICsgTWF0aC5pbXVsKHJlLCB0dCkgfCAwO1xuICAgICAgdmFyIEFuID0gKHUgKyBtIHwgMCkgKyAoKGcgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgdSA9IChQICsgKGcgPj4+IDEzKSB8IDApICsgKEFuID4+PiAyNikgfCAwLCBBbiAmPSA2NzEwODg2MywgbSA9IE1hdGguaW11bChTZSwgSmUpLCBnID0gTWF0aC5pbXVsKFNlLCB0dCksIGcgPSBnICsgTWF0aC5pbXVsKG9lLCBKZSkgfCAwLCBQID0gTWF0aC5pbXVsKG9lLCB0dCk7XG4gICAgICB2YXIgRG4gPSAodSArIG0gfCAwKSArICgoZyAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICByZXR1cm4gdSA9IChQICsgKGcgPj4+IDEzKSB8IDApICsgKERuID4+PiAyNikgfCAwLCBEbiAmPSA2NzEwODg2MywgeFswXSA9IGp0LCB4WzFdID0gS3QsIHhbMl0gPSBIdCwgeFszXSA9IFZ0LCB4WzRdID0gZ3QsIHhbNV0gPSBWciwgeFs2XSA9IFdyLCB4WzddID0gR3IsIHhbOF0gPSBKciwgeFs5XSA9IFlyLCB4WzEwXSA9IG9yLCB4WzExXSA9IFhyLCB4WzEyXSA9IFpyLCB4WzEzXSA9ICR0LCB4WzE0XSA9IFFyLCB4WzE1XSA9IGVpLCB4WzE2XSA9IHRpLCB4WzE3XSA9IEFuLCB4WzE4XSA9IERuLCB1ICE9PSAwICYmICh4WzE5XSA9IHUsIGIubGVuZ3RoKyspLCBiO1xuICAgIH07XG4gICAgTWF0aC5pbXVsIHx8IChUID0gaik7XG4gICAgZnVuY3Rpb24gSyhsLCBhLCBjKSB7XG4gICAgICBjLm5lZ2F0aXZlID0gYS5uZWdhdGl2ZSBeIGwubmVnYXRpdmUsIGMubGVuZ3RoID0gbC5sZW5ndGggKyBhLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGIgPSAwLCBFID0gMCwgUyA9IDA7IFMgPCBjLmxlbmd0aCAtIDE7IFMrKykge1xuICAgICAgICB2YXIgeCA9IEU7XG4gICAgICAgIEUgPSAwO1xuICAgICAgICBmb3IgKHZhciB1ID0gYiAmIDY3MTA4ODYzLCBtID0gTWF0aC5taW4oUywgYS5sZW5ndGggLSAxKSwgZyA9IE1hdGgubWF4KDAsIFMgLSBsLmxlbmd0aCArIDEpOyBnIDw9IG07IGcrKykge1xuICAgICAgICAgIHZhciBQID0gUyAtIGcsIEcgPSBsLndvcmRzW1BdIHwgMCwgTSA9IGEud29yZHNbZ10gfCAwLCBIID0gRyAqIE0sIEMgPSBIICYgNjcxMDg4NjM7XG4gICAgICAgICAgeCA9IHggKyAoSCAvIDY3MTA4ODY0IHwgMCkgfCAwLCBDID0gQyArIHUgfCAwLCB1ID0gQyAmIDY3MTA4ODYzLCB4ID0geCArIChDID4+PiAyNikgfCAwLCBFICs9IHggPj4+IDI2LCB4ICY9IDY3MTA4ODYzO1xuICAgICAgICB9XG4gICAgICAgIGMud29yZHNbU10gPSB1LCBiID0geCwgeCA9IEU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYiAhPT0gMCA/IGMud29yZHNbU10gPSBiIDogYy5sZW5ndGgtLSwgYy5fc3RyaXAoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gJChsLCBhLCBjKSB7XG4gICAgICByZXR1cm4gSyhsLCBhLCBjKTtcbiAgICB9XG4gICAgcy5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbihhLCBjKSB7XG4gICAgICB2YXIgYiwgRSA9IHRoaXMubGVuZ3RoICsgYS5sZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEwICYmIGEubGVuZ3RoID09PSAxMCA/IGIgPSBUKHRoaXMsIGEsIGMpIDogRSA8IDYzID8gYiA9IGoodGhpcywgYSwgYykgOiBFIDwgMTAyNCA/IGIgPSBLKHRoaXMsIGEsIGMpIDogYiA9ICQodGhpcywgYSwgYyksIGI7XG4gICAgfSwgcy5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIGMgPSBuZXcgcyhudWxsKTtcbiAgICAgIHJldHVybiBjLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgYS5sZW5ndGgpLCB0aGlzLm11bFRvKGEsIGMpO1xuICAgIH0sIHMucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYyA9IG5ldyBzKG51bGwpO1xuICAgICAgcmV0dXJuIGMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBhLmxlbmd0aCksICQodGhpcywgYSwgYyk7XG4gICAgfSwgcy5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8oYSwgdGhpcyk7XG4gICAgfSwgcy5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYyA9IGEgPCAwO1xuICAgICAgYyAmJiAoYSA9IC1hKSwgaSh0eXBlb2YgYSA9PSBcIm51bWJlclwiKSwgaShhIDwgNjcxMDg4NjQpO1xuICAgICAgZm9yICh2YXIgYiA9IDAsIEUgPSAwOyBFIDwgdGhpcy5sZW5ndGg7IEUrKykge1xuICAgICAgICB2YXIgUyA9ICh0aGlzLndvcmRzW0VdIHwgMCkgKiBhLCB4ID0gKFMgJiA2NzEwODg2MykgKyAoYiAmIDY3MTA4ODYzKTtcbiAgICAgICAgYiA+Pj0gMjYsIGIgKz0gUyAvIDY3MTA4ODY0IHwgMCwgYiArPSB4ID4+PiAyNiwgdGhpcy53b3Jkc1tFXSA9IHggJiA2NzEwODg2MztcbiAgICAgIH1cbiAgICAgIHJldHVybiBiICE9PSAwICYmICh0aGlzLndvcmRzW0VdID0gYiwgdGhpcy5sZW5ndGgrKyksIGMgPyB0aGlzLmluZWcoKSA6IHRoaXM7XG4gICAgfSwgcy5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4oYSk7XG4gICAgfSwgcy5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gICAgfSwgcy5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICAgIH0sIHMucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBjID0gayhhKTtcbiAgICAgIGlmIChjLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG5ldyBzKDEpO1xuICAgICAgZm9yICh2YXIgYiA9IHRoaXMsIEUgPSAwOyBFIDwgYy5sZW5ndGggJiYgY1tFXSA9PT0gMDsgRSsrLCBiID0gYi5zcXIoKSlcbiAgICAgICAgO1xuICAgICAgaWYgKCsrRSA8IGMubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBTID0gYi5zcXIoKTsgRSA8IGMubGVuZ3RoOyBFKyssIFMgPSBTLnNxcigpKVxuICAgICAgICAgIGNbRV0gIT09IDAgJiYgKGIgPSBiLm11bChTKSk7XG4gICAgICByZXR1cm4gYjtcbiAgICB9LCBzLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbihhKSB7XG4gICAgICBpKHR5cGVvZiBhID09IFwibnVtYmVyXCIgJiYgYSA+PSAwKTtcbiAgICAgIHZhciBjID0gYSAlIDI2LCBiID0gKGEgLSBjKSAvIDI2LCBFID0gNjcxMDg4NjMgPj4+IDI2IC0gYyA8PCAyNiAtIGMsIFM7XG4gICAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIGZvciAoUyA9IDA7IFMgPCB0aGlzLmxlbmd0aDsgUysrKSB7XG4gICAgICAgICAgdmFyIHUgPSB0aGlzLndvcmRzW1NdICYgRSwgbSA9ICh0aGlzLndvcmRzW1NdIHwgMCkgLSB1IDw8IGM7XG4gICAgICAgICAgdGhpcy53b3Jkc1tTXSA9IG0gfCB4LCB4ID0gdSA+Pj4gMjYgLSBjO1xuICAgICAgICB9XG4gICAgICAgIHggJiYgKHRoaXMud29yZHNbU10gPSB4LCB0aGlzLmxlbmd0aCsrKTtcbiAgICAgIH1cbiAgICAgIGlmIChiICE9PSAwKSB7XG4gICAgICAgIGZvciAoUyA9IHRoaXMubGVuZ3RoIC0gMTsgUyA+PSAwOyBTLS0pXG4gICAgICAgICAgdGhpcy53b3Jkc1tTICsgYl0gPSB0aGlzLndvcmRzW1NdO1xuICAgICAgICBmb3IgKFMgPSAwOyBTIDwgYjsgUysrKVxuICAgICAgICAgIHRoaXMud29yZHNbU10gPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSBiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLm5lZ2F0aXZlID09PSAwKSwgdGhpcy5pdXNobG4oYSk7XG4gICAgfSwgcy5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24oYSwgYywgYikge1xuICAgICAgaSh0eXBlb2YgYSA9PSBcIm51bWJlclwiICYmIGEgPj0gMCk7XG4gICAgICB2YXIgRTtcbiAgICAgIGMgPyBFID0gKGMgLSBjICUgMjYpIC8gMjYgOiBFID0gMDtcbiAgICAgIHZhciBTID0gYSAlIDI2LCB4ID0gTWF0aC5taW4oKGEgLSBTKSAvIDI2LCB0aGlzLmxlbmd0aCksIHUgPSA2NzEwODg2MyBeIDY3MTA4ODYzID4+PiBTIDw8IFMsIG0gPSBiO1xuICAgICAgaWYgKEUgLT0geCwgRSA9IE1hdGgubWF4KDAsIEUpLCBtKSB7XG4gICAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgeDsgZysrKVxuICAgICAgICAgIG0ud29yZHNbZ10gPSB0aGlzLndvcmRzW2ddO1xuICAgICAgICBtLmxlbmd0aCA9IHg7XG4gICAgICB9XG4gICAgICBpZiAoeCAhPT0gMClcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4geClcbiAgICAgICAgICBmb3IgKHRoaXMubGVuZ3RoIC09IHgsIGcgPSAwOyBnIDwgdGhpcy5sZW5ndGg7IGcrKylcbiAgICAgICAgICAgIHRoaXMud29yZHNbZ10gPSB0aGlzLndvcmRzW2cgKyB4XTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMud29yZHNbMF0gPSAwLCB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICB2YXIgUCA9IDA7XG4gICAgICBmb3IgKGcgPSB0aGlzLmxlbmd0aCAtIDE7IGcgPj0gMCAmJiAoUCAhPT0gMCB8fCBnID49IEUpOyBnLS0pIHtcbiAgICAgICAgdmFyIEcgPSB0aGlzLndvcmRzW2ddIHwgMDtcbiAgICAgICAgdGhpcy53b3Jkc1tnXSA9IFAgPDwgMjYgLSBTIHwgRyA+Pj4gUywgUCA9IEcgJiB1O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG0gJiYgUCAhPT0gMCAmJiAobS53b3Jkc1ttLmxlbmd0aCsrXSA9IFApLCB0aGlzLmxlbmd0aCA9PT0gMCAmJiAodGhpcy53b3Jkc1swXSA9IDAsIHRoaXMubGVuZ3RoID0gMSksIHRoaXMuX3N0cmlwKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbihhLCBjLCBiKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLm5lZ2F0aXZlID09PSAwKSwgdGhpcy5pdXNocm4oYSwgYywgYik7XG4gICAgfSwgcy5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYSk7XG4gICAgfSwgcy5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihhKTtcbiAgICB9LCBzLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihhKTtcbiAgICB9LCBzLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGEpO1xuICAgIH0sIHMucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24oYSkge1xuICAgICAgaSh0eXBlb2YgYSA9PSBcIm51bWJlclwiICYmIGEgPj0gMCk7XG4gICAgICB2YXIgYyA9IGEgJSAyNiwgYiA9IChhIC0gYykgLyAyNiwgRSA9IDEgPDwgYztcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA8PSBiKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB2YXIgUyA9IHRoaXMud29yZHNbYl07XG4gICAgICByZXR1cm4gISEoUyAmIEUpO1xuICAgIH0sIHMucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIGkodHlwZW9mIGEgPT0gXCJudW1iZXJcIiAmJiBhID49IDApO1xuICAgICAgdmFyIGMgPSBhICUgMjYsIGIgPSAoYSAtIGMpIC8gMjY7XG4gICAgICBpZiAoaSh0aGlzLm5lZ2F0aXZlID09PSAwLCBcImltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVyc1wiKSwgdGhpcy5sZW5ndGggPD0gYilcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAoYyAhPT0gMCAmJiBiKyssIHRoaXMubGVuZ3RoID0gTWF0aC5taW4oYiwgdGhpcy5sZW5ndGgpLCBjICE9PSAwKSB7XG4gICAgICAgIHZhciBFID0gNjcxMDg4NjMgXiA2NzEwODg2MyA+Pj4gYyA8PCBjO1xuICAgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICAgIH0sIHMucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYSk7XG4gICAgfSwgcy5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gaSh0eXBlb2YgYSA9PSBcIm51bWJlclwiKSwgaShhIDwgNjcxMDg4NjQpLCBhIDwgMCA/IHRoaXMuaXN1Ym4oLWEpIDogdGhpcy5uZWdhdGl2ZSAhPT0gMCA/IHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPD0gYSA/ICh0aGlzLndvcmRzWzBdID0gYSAtICh0aGlzLndvcmRzWzBdIHwgMCksIHRoaXMubmVnYXRpdmUgPSAwLCB0aGlzKSA6ICh0aGlzLm5lZ2F0aXZlID0gMCwgdGhpcy5pc3VibihhKSwgdGhpcy5uZWdhdGl2ZSA9IDEsIHRoaXMpIDogdGhpcy5faWFkZG4oYSk7XG4gICAgfSwgcy5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24oYSkge1xuICAgICAgdGhpcy53b3Jkc1swXSArPSBhO1xuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2NdID49IDY3MTA4ODY0OyBjKyspXG4gICAgICAgIHRoaXMud29yZHNbY10gLT0gNjcxMDg4NjQsIGMgPT09IHRoaXMubGVuZ3RoIC0gMSA/IHRoaXMud29yZHNbYyArIDFdID0gMSA6IHRoaXMud29yZHNbYyArIDFdKys7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgYyArIDEpLCB0aGlzO1xuICAgIH0sIHMucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24oYSkge1xuICAgICAgaWYgKGkodHlwZW9mIGEgPT0gXCJudW1iZXJcIiksIGkoYSA8IDY3MTA4ODY0KSwgYSA8IDApXG4gICAgICAgIHJldHVybiB0aGlzLmlhZGRuKC1hKTtcbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKVxuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSA9IDAsIHRoaXMuaWFkZG4oYSksIHRoaXMubmVnYXRpdmUgPSAxLCB0aGlzO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gLT0gYSwgdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IDApXG4gICAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXSwgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICBlbHNlXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tjXSA8IDA7IGMrKylcbiAgICAgICAgICB0aGlzLndvcmRzW2NdICs9IDY3MTA4ODY0LCB0aGlzLndvcmRzW2MgKyAxXSAtPSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4oYSk7XG4gICAgfSwgcy5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4oYSk7XG4gICAgfSwgcy5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgPSAwLCB0aGlzO1xuICAgIH0sIHMucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24oYSwgYywgYikge1xuICAgICAgdmFyIEUgPSBhLmxlbmd0aCArIGIsIFM7XG4gICAgICB0aGlzLl9leHBhbmQoRSk7XG4gICAgICB2YXIgeCwgdSA9IDA7XG4gICAgICBmb3IgKFMgPSAwOyBTIDwgYS5sZW5ndGg7IFMrKykge1xuICAgICAgICB4ID0gKHRoaXMud29yZHNbUyArIGJdIHwgMCkgKyB1O1xuICAgICAgICB2YXIgbSA9IChhLndvcmRzW1NdIHwgMCkgKiBjO1xuICAgICAgICB4IC09IG0gJiA2NzEwODg2MywgdSA9ICh4ID4+IDI2KSAtIChtIC8gNjcxMDg4NjQgfCAwKSwgdGhpcy53b3Jkc1tTICsgYl0gPSB4ICYgNjcxMDg4NjM7XG4gICAgICB9XG4gICAgICBmb3IgKDsgUyA8IHRoaXMubGVuZ3RoIC0gYjsgUysrKVxuICAgICAgICB4ID0gKHRoaXMud29yZHNbUyArIGJdIHwgMCkgKyB1LCB1ID0geCA+PiAyNiwgdGhpcy53b3Jkc1tTICsgYl0gPSB4ICYgNjcxMDg4NjM7XG4gICAgICBpZiAodSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICBmb3IgKGkodSA9PT0gLTEpLCB1ID0gMCwgUyA9IDA7IFMgPCB0aGlzLmxlbmd0aDsgUysrKVxuICAgICAgICB4ID0gLSh0aGlzLndvcmRzW1NdIHwgMCkgKyB1LCB1ID0geCA+PiAyNiwgdGhpcy53b3Jkc1tTXSA9IHggJiA2NzEwODg2MztcbiAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlID0gMSwgdGhpcy5fc3RyaXAoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIHZhciBiID0gdGhpcy5sZW5ndGggLSBhLmxlbmd0aCwgRSA9IHRoaXMuY2xvbmUoKSwgUyA9IGEsIHggPSBTLndvcmRzW1MubGVuZ3RoIC0gMV0gfCAwLCB1ID0gdGhpcy5fY291bnRCaXRzKHgpO1xuICAgICAgYiA9IDI2IC0gdSwgYiAhPT0gMCAmJiAoUyA9IFMudXNobG4oYiksIEUuaXVzaGxuKGIpLCB4ID0gUy53b3Jkc1tTLmxlbmd0aCAtIDFdIHwgMCk7XG4gICAgICB2YXIgbSA9IEUubGVuZ3RoIC0gUy5sZW5ndGgsIGc7XG4gICAgICBpZiAoYyAhPT0gXCJtb2RcIikge1xuICAgICAgICBnID0gbmV3IHMobnVsbCksIGcubGVuZ3RoID0gbSArIDEsIGcud29yZHMgPSBuZXcgQXJyYXkoZy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBQID0gMDsgUCA8IGcubGVuZ3RoOyBQKyspXG4gICAgICAgICAgZy53b3Jkc1tQXSA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgRyA9IEUuY2xvbmUoKS5faXNobG5zdWJtdWwoUywgMSwgbSk7XG4gICAgICBHLm5lZ2F0aXZlID09PSAwICYmIChFID0gRywgZyAmJiAoZy53b3Jkc1ttXSA9IDEpKTtcbiAgICAgIGZvciAodmFyIE0gPSBtIC0gMTsgTSA+PSAwOyBNLS0pIHtcbiAgICAgICAgdmFyIEggPSAoRS53b3Jkc1tTLmxlbmd0aCArIE1dIHwgMCkgKiA2NzEwODg2NCArIChFLndvcmRzW1MubGVuZ3RoICsgTSAtIDFdIHwgMCk7XG4gICAgICAgIGZvciAoSCA9IE1hdGgubWluKEggLyB4IHwgMCwgNjcxMDg4NjMpLCBFLl9pc2hsbnN1Ym11bChTLCBILCBNKTsgRS5uZWdhdGl2ZSAhPT0gMDsgKVxuICAgICAgICAgIEgtLSwgRS5uZWdhdGl2ZSA9IDAsIEUuX2lzaGxuc3VibXVsKFMsIDEsIE0pLCBFLmlzWmVybygpIHx8IChFLm5lZ2F0aXZlIF49IDEpO1xuICAgICAgICBnICYmIChnLndvcmRzW01dID0gSCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZyAmJiBnLl9zdHJpcCgpLCBFLl9zdHJpcCgpLCBjICE9PSBcImRpdlwiICYmIGIgIT09IDAgJiYgRS5pdXNocm4oYiksIHtcbiAgICAgICAgZGl2OiBnIHx8IG51bGwsXG4gICAgICAgIG1vZDogRVxuICAgICAgfTtcbiAgICB9LCBzLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbihhLCBjLCBiKSB7XG4gICAgICBpZiAoaSghYS5pc1plcm8oKSksIHRoaXMuaXNaZXJvKCkpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBuZXcgcygwKSxcbiAgICAgICAgICBtb2Q6IG5ldyBzKDApXG4gICAgICAgIH07XG4gICAgICB2YXIgRSwgUywgeDtcbiAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwICYmIGEubmVnYXRpdmUgPT09IDAgPyAoeCA9IHRoaXMubmVnKCkuZGl2bW9kKGEsIGMpLCBjICE9PSBcIm1vZFwiICYmIChFID0geC5kaXYubmVnKCkpLCBjICE9PSBcImRpdlwiICYmIChTID0geC5tb2QubmVnKCksIGIgJiYgUy5uZWdhdGl2ZSAhPT0gMCAmJiBTLmlhZGQoYSkpLCB7XG4gICAgICAgIGRpdjogRSxcbiAgICAgICAgbW9kOiBTXG4gICAgICB9KSA6IHRoaXMubmVnYXRpdmUgPT09IDAgJiYgYS5uZWdhdGl2ZSAhPT0gMCA/ICh4ID0gdGhpcy5kaXZtb2QoYS5uZWcoKSwgYyksIGMgIT09IFwibW9kXCIgJiYgKEUgPSB4LmRpdi5uZWcoKSksIHtcbiAgICAgICAgZGl2OiBFLFxuICAgICAgICBtb2Q6IHgubW9kXG4gICAgICB9KSA6IHRoaXMubmVnYXRpdmUgJiBhLm5lZ2F0aXZlID8gKHggPSB0aGlzLm5lZygpLmRpdm1vZChhLm5lZygpLCBjKSwgYyAhPT0gXCJkaXZcIiAmJiAoUyA9IHgubW9kLm5lZygpLCBiICYmIFMubmVnYXRpdmUgIT09IDAgJiYgUy5pc3ViKGEpKSwge1xuICAgICAgICBkaXY6IHguZGl2LFxuICAgICAgICBtb2Q6IFNcbiAgICAgIH0pIDogYS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChhKSA8IDAgPyB7XG4gICAgICAgIGRpdjogbmV3IHMoMCksXG4gICAgICAgIG1vZDogdGhpc1xuICAgICAgfSA6IGEubGVuZ3RoID09PSAxID8gYyA9PT0gXCJkaXZcIiA/IHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4oYS53b3Jkc1swXSksXG4gICAgICAgIG1vZDogbnVsbFxuICAgICAgfSA6IGMgPT09IFwibW9kXCIgPyB7XG4gICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgbW9kOiBuZXcgcyh0aGlzLm1vZHJuKGEud29yZHNbMF0pKVxuICAgICAgfSA6IHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4oYS53b3Jkc1swXSksXG4gICAgICAgIG1vZDogbmV3IHModGhpcy5tb2RybihhLndvcmRzWzBdKSlcbiAgICAgIH0gOiB0aGlzLl93b3JkRGl2KGEsIGMpO1xuICAgIH0sIHMucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdm1vZChhLCBcImRpdlwiLCAhMSkuZGl2O1xuICAgIH0sIHMucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdm1vZChhLCBcIm1vZFwiLCAhMSkubW9kO1xuICAgIH0sIHMucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXZtb2QoYSwgXCJtb2RcIiwgITApLm1vZDtcbiAgICB9LCBzLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBjID0gdGhpcy5kaXZtb2QoYSk7XG4gICAgICBpZiAoYy5tb2QuaXNaZXJvKCkpXG4gICAgICAgIHJldHVybiBjLmRpdjtcbiAgICAgIHZhciBiID0gYy5kaXYubmVnYXRpdmUgIT09IDAgPyBjLm1vZC5pc3ViKGEpIDogYy5tb2QsIEUgPSBhLnVzaHJuKDEpLCBTID0gYS5hbmRsbigxKSwgeCA9IGIuY21wKEUpO1xuICAgICAgcmV0dXJuIHggPCAwIHx8IFMgPT09IDEgJiYgeCA9PT0gMCA/IGMuZGl2IDogYy5kaXYubmVnYXRpdmUgIT09IDAgPyBjLmRpdi5pc3VibigxKSA6IGMuZGl2LmlhZGRuKDEpO1xuICAgIH0sIHMucHJvdG90eXBlLm1vZHJuID0gZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIGMgPSBhIDwgMDtcbiAgICAgIGMgJiYgKGEgPSAtYSksIGkoYSA8PSA2NzEwODg2Myk7XG4gICAgICBmb3IgKHZhciBiID0gKDEgPDwgMjYpICUgYSwgRSA9IDAsIFMgPSB0aGlzLmxlbmd0aCAtIDE7IFMgPj0gMDsgUy0tKVxuICAgICAgICBFID0gKGIgKiBFICsgKHRoaXMud29yZHNbU10gfCAwKSkgJSBhO1xuICAgICAgcmV0dXJuIGMgPyAtRSA6IEU7XG4gICAgfSwgcy5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZHJuKGEpO1xuICAgIH0sIHMucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIGMgPSBhIDwgMDtcbiAgICAgIGMgJiYgKGEgPSAtYSksIGkoYSA8PSA2NzEwODg2Myk7XG4gICAgICBmb3IgKHZhciBiID0gMCwgRSA9IHRoaXMubGVuZ3RoIC0gMTsgRSA+PSAwOyBFLS0pIHtcbiAgICAgICAgdmFyIFMgPSAodGhpcy53b3Jkc1tFXSB8IDApICsgYiAqIDY3MTA4ODY0O1xuICAgICAgICB0aGlzLndvcmRzW0VdID0gUyAvIGEgfCAwLCBiID0gUyAlIGE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc3RyaXAoKSwgYyA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgICB9LCBzLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihhKTtcbiAgICB9LCBzLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24oYSkge1xuICAgICAgaShhLm5lZ2F0aXZlID09PSAwKSwgaSghYS5pc1plcm8oKSk7XG4gICAgICB2YXIgYyA9IHRoaXMsIGIgPSBhLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlICE9PSAwID8gYyA9IGMudW1vZChhKSA6IGMgPSBjLmNsb25lKCk7XG4gICAgICBmb3IgKHZhciBFID0gbmV3IHMoMSksIFMgPSBuZXcgcygwKSwgeCA9IG5ldyBzKDApLCB1ID0gbmV3IHMoMSksIG0gPSAwOyBjLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IClcbiAgICAgICAgYy5pdXNocm4oMSksIGIuaXVzaHJuKDEpLCArK207XG4gICAgICBmb3IgKHZhciBnID0gYi5jbG9uZSgpLCBQID0gYy5jbG9uZSgpOyAhYy5pc1plcm8oKTsgKSB7XG4gICAgICAgIGZvciAodmFyIEcgPSAwLCBNID0gMTsgIShjLndvcmRzWzBdICYgTSkgJiYgRyA8IDI2OyArK0csIE0gPDw9IDEpXG4gICAgICAgICAgO1xuICAgICAgICBpZiAoRyA+IDApXG4gICAgICAgICAgZm9yIChjLml1c2hybihHKTsgRy0tID4gMDsgKVxuICAgICAgICAgICAgKEUuaXNPZGQoKSB8fCBTLmlzT2RkKCkpICYmIChFLmlhZGQoZyksIFMuaXN1YihQKSksIEUuaXVzaHJuKDEpLCBTLml1c2hybigxKTtcbiAgICAgICAgZm9yICh2YXIgSCA9IDAsIEMgPSAxOyAhKGIud29yZHNbMF0gJiBDKSAmJiBIIDwgMjY7ICsrSCwgQyA8PD0gMSlcbiAgICAgICAgICA7XG4gICAgICAgIGlmIChIID4gMClcbiAgICAgICAgICBmb3IgKGIuaXVzaHJuKEgpOyBILS0gPiAwOyApXG4gICAgICAgICAgICAoeC5pc09kZCgpIHx8IHUuaXNPZGQoKSkgJiYgKHguaWFkZChnKSwgdS5pc3ViKFApKSwgeC5pdXNocm4oMSksIHUuaXVzaHJuKDEpO1xuICAgICAgICBjLmNtcChiKSA+PSAwID8gKGMuaXN1YihiKSwgRS5pc3ViKHgpLCBTLmlzdWIodSkpIDogKGIuaXN1YihjKSwgeC5pc3ViKEUpLCB1LmlzdWIoUykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYTogeCxcbiAgICAgICAgYjogdSxcbiAgICAgICAgZ2NkOiBiLml1c2hsbihtKVxuICAgICAgfTtcbiAgICB9LCBzLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbihhKSB7XG4gICAgICBpKGEubmVnYXRpdmUgPT09IDApLCBpKCFhLmlzWmVybygpKTtcbiAgICAgIHZhciBjID0gdGhpcywgYiA9IGEuY2xvbmUoKTtcbiAgICAgIGMubmVnYXRpdmUgIT09IDAgPyBjID0gYy51bW9kKGEpIDogYyA9IGMuY2xvbmUoKTtcbiAgICAgIGZvciAodmFyIEUgPSBuZXcgcygxKSwgUyA9IG5ldyBzKDApLCB4ID0gYi5jbG9uZSgpOyBjLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDA7ICkge1xuICAgICAgICBmb3IgKHZhciB1ID0gMCwgbSA9IDE7ICEoYy53b3Jkc1swXSAmIG0pICYmIHUgPCAyNjsgKyt1LCBtIDw8PSAxKVxuICAgICAgICAgIDtcbiAgICAgICAgaWYgKHUgPiAwKVxuICAgICAgICAgIGZvciAoYy5pdXNocm4odSk7IHUtLSA+IDA7IClcbiAgICAgICAgICAgIEUuaXNPZGQoKSAmJiBFLmlhZGQoeCksIEUuaXVzaHJuKDEpO1xuICAgICAgICBmb3IgKHZhciBnID0gMCwgUCA9IDE7ICEoYi53b3Jkc1swXSAmIFApICYmIGcgPCAyNjsgKytnLCBQIDw8PSAxKVxuICAgICAgICAgIDtcbiAgICAgICAgaWYgKGcgPiAwKVxuICAgICAgICAgIGZvciAoYi5pdXNocm4oZyk7IGctLSA+IDA7IClcbiAgICAgICAgICAgIFMuaXNPZGQoKSAmJiBTLmlhZGQoeCksIFMuaXVzaHJuKDEpO1xuICAgICAgICBjLmNtcChiKSA+PSAwID8gKGMuaXN1YihiKSwgRS5pc3ViKFMpKSA6IChiLmlzdWIoYyksIFMuaXN1YihFKSk7XG4gICAgICB9XG4gICAgICB2YXIgRztcbiAgICAgIHJldHVybiBjLmNtcG4oMSkgPT09IDAgPyBHID0gRSA6IEcgPSBTLCBHLmNtcG4oMCkgPCAwICYmIEcuaWFkZChhKSwgRztcbiAgICB9LCBzLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbihhKSB7XG4gICAgICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICAgICAgcmV0dXJuIGEuYWJzKCk7XG4gICAgICBpZiAoYS5pc1plcm8oKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuYWJzKCk7XG4gICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKSwgYiA9IGEuY2xvbmUoKTtcbiAgICAgIGMubmVnYXRpdmUgPSAwLCBiLm5lZ2F0aXZlID0gMDtcbiAgICAgIGZvciAodmFyIEUgPSAwOyBjLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IEUrKylcbiAgICAgICAgYy5pdXNocm4oMSksIGIuaXVzaHJuKDEpO1xuICAgICAgZG8ge1xuICAgICAgICBmb3IgKDsgYy5pc0V2ZW4oKTsgKVxuICAgICAgICAgIGMuaXVzaHJuKDEpO1xuICAgICAgICBmb3IgKDsgYi5pc0V2ZW4oKTsgKVxuICAgICAgICAgIGIuaXVzaHJuKDEpO1xuICAgICAgICB2YXIgUyA9IGMuY21wKGIpO1xuICAgICAgICBpZiAoUyA8IDApIHtcbiAgICAgICAgICB2YXIgeCA9IGM7XG4gICAgICAgICAgYyA9IGIsIGIgPSB4O1xuICAgICAgICB9IGVsc2UgaWYgKFMgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjLmlzdWIoYik7XG4gICAgICB9IHdoaWxlICghMCk7XG4gICAgICByZXR1cm4gYi5pdXNobG4oRSk7XG4gICAgfSwgcy5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmVnY2QoYSkuYS51bW9kKGEpO1xuICAgIH0sIHMucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gICAgfSwgcy5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICAgIH0sIHMucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBhO1xuICAgIH0sIHMucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24oYSkge1xuICAgICAgaSh0eXBlb2YgYSA9PSBcIm51bWJlclwiKTtcbiAgICAgIHZhciBjID0gYSAlIDI2LCBiID0gKGEgLSBjKSAvIDI2LCBFID0gMSA8PCBjO1xuICAgICAgaWYgKHRoaXMubGVuZ3RoIDw9IGIpXG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbmQoYiArIDEpLCB0aGlzLndvcmRzW2JdIHw9IEUsIHRoaXM7XG4gICAgICBmb3IgKHZhciBTID0gRSwgeCA9IGI7IFMgIT09IDAgJiYgeCA8IHRoaXMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLndvcmRzW3hdIHwgMDtcbiAgICAgICAgdSArPSBTLCBTID0gdSA+Pj4gMjYsIHUgJj0gNjcxMDg4NjMsIHRoaXMud29yZHNbeF0gPSB1O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFMgIT09IDAgJiYgKHRoaXMud29yZHNbeF0gPSBTLCB0aGlzLmxlbmd0aCsrKSwgdGhpcztcbiAgICB9LCBzLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuICAgIH0sIHMucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYyA9IGEgPCAwO1xuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIWMpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIGMpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgdGhpcy5fc3RyaXAoKTtcbiAgICAgIHZhciBiO1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMSlcbiAgICAgICAgYiA9IDE7XG4gICAgICBlbHNlIHtcbiAgICAgICAgYyAmJiAoYSA9IC1hKSwgaShhIDw9IDY3MTA4ODYzLCBcIk51bWJlciBpcyB0b28gYmlnXCIpO1xuICAgICAgICB2YXIgRSA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgICBiID0gRSA9PT0gYSA/IDAgOiBFIDwgYSA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwID8gLWIgfCAwIDogYjtcbiAgICB9LCBzLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbihhKSB7XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBhLm5lZ2F0aXZlID09PSAwKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBhLm5lZ2F0aXZlICE9PSAwKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIHZhciBjID0gdGhpcy51Y21wKGEpO1xuICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDAgPyAtYyB8IDAgOiBjO1xuICAgIH0sIHMucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbihhKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiBhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPCBhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgZm9yICh2YXIgYyA9IDAsIGIgPSB0aGlzLmxlbmd0aCAtIDE7IGIgPj0gMDsgYi0tKSB7XG4gICAgICAgIHZhciBFID0gdGhpcy53b3Jkc1tiXSB8IDAsIFMgPSBhLndvcmRzW2JdIHwgMDtcbiAgICAgICAgaWYgKEUgIT09IFMpIHtcbiAgICAgICAgICBFIDwgUyA/IGMgPSAtMSA6IEUgPiBTICYmIChjID0gMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sIHMucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNtcG4oYSkgPT09IDE7XG4gICAgfSwgcy5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbXAoYSkgPT09IDE7XG4gICAgfSwgcy5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNtcG4oYSkgPj0gMDtcbiAgICB9LCBzLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbXAoYSkgPj0gMDtcbiAgICB9LCBzLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbXBuKGEpID09PSAtMTtcbiAgICB9LCBzLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNtcChhKSA9PT0gLTE7XG4gICAgfSwgcy5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNtcG4oYSkgPD0gMDtcbiAgICB9LCBzLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbXAoYSkgPD0gMDtcbiAgICB9LCBzLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbXBuKGEpID09PSAwO1xuICAgIH0sIHMucHJvdG90eXBlLmVxID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHRoaXMuY21wKGEpID09PSAwO1xuICAgIH0sIHMucmVkID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIG5ldyBPKGEpO1xuICAgIH0sIHMucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGkoIXRoaXMucmVkLCBcIkFscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHRcIiksIGkodGhpcy5uZWdhdGl2ZSA9PT0gMCwgXCJyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlc1wiKSwgYS5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGEpO1xuICAgIH0sIHMucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpKHRoaXMucmVkLCBcImZyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHRcIiksIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICAgIH0sIHMucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZCA9IGEsIHRoaXM7XG4gICAgfSwgcy5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gaSghdGhpcy5yZWQsIFwiQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dFwiKSwgdGhpcy5fZm9yY2VSZWQoYSk7XG4gICAgfSwgcy5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGkodGhpcy5yZWQsIFwicmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuYWRkKHRoaXMsIGEpO1xuICAgIH0sIHMucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLnJlZCwgXCJyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuaWFkZCh0aGlzLCBhKTtcbiAgICB9LCBzLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLnJlZCwgXCJyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5zdWIodGhpcywgYSk7XG4gICAgfSwgcy5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBpKHRoaXMucmVkLCBcInJlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5pc3ViKHRoaXMsIGEpO1xuICAgIH0sIHMucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBpKHRoaXMucmVkLCBcInJlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLnNobCh0aGlzLCBhKTtcbiAgICB9LCBzLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLnJlZCwgXCJyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBhKSwgdGhpcy5yZWQubXVsKHRoaXMsIGEpO1xuICAgIH0sIHMucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLnJlZCwgXCJyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBhKSwgdGhpcy5yZWQuaW11bCh0aGlzLCBhKTtcbiAgICB9LCBzLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpKHRoaXMucmVkLCBcInJlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLCB0aGlzLnJlZC5zcXIodGhpcyk7XG4gICAgfSwgcy5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGkodGhpcy5yZWQsIFwicmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLCB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICAgIH0sIHMucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpKHRoaXMucmVkLCBcInJlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSwgdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgICB9LCBzLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLnJlZCwgXCJyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyksIHRoaXMucmVkLmludm0odGhpcyk7XG4gICAgfSwgcy5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLnJlZCwgXCJyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSwgdGhpcy5yZWQubmVnKHRoaXMpO1xuICAgIH0sIHMucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBpKHRoaXMucmVkICYmICFhLnJlZCwgXCJyZWRQb3cobm9ybWFsTnVtKVwiKSwgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyksIHRoaXMucmVkLnBvdyh0aGlzLCBhKTtcbiAgICB9O1xuICAgIHZhciB6ID0ge1xuICAgICAgazI1NjogbnVsbCxcbiAgICAgIHAyMjQ6IG51bGwsXG4gICAgICBwMTkyOiBudWxsLFxuICAgICAgcDI1NTE5OiBudWxsXG4gICAgfTtcbiAgICBmdW5jdGlvbiBCKGwsIGEpIHtcbiAgICAgIHRoaXMubmFtZSA9IGwsIHRoaXMucCA9IG5ldyBzKGEsIDE2KSwgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpLCB0aGlzLmsgPSBuZXcgcygxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCksIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gICAgfVxuICAgIEIucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gbmV3IHMobnVsbCk7XG4gICAgICByZXR1cm4gYS53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKSwgYTtcbiAgICB9LCBCLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIGMgPSBhLCBiO1xuICAgICAgZG9cbiAgICAgICAgdGhpcy5zcGxpdChjLCB0aGlzLnRtcCksIGMgPSB0aGlzLmltdWxLKGMpLCBjID0gYy5pYWRkKHRoaXMudG1wKSwgYiA9IGMuYml0TGVuZ3RoKCk7XG4gICAgICB3aGlsZSAoYiA+IHRoaXMubik7XG4gICAgICB2YXIgRSA9IGIgPCB0aGlzLm4gPyAtMSA6IGMudWNtcCh0aGlzLnApO1xuICAgICAgcmV0dXJuIEUgPT09IDAgPyAoYy53b3Jkc1swXSA9IDAsIGMubGVuZ3RoID0gMSkgOiBFID4gMCA/IGMuaXN1Yih0aGlzLnApIDogYy5zdHJpcCAhPT0gdm9pZCAwID8gYy5zdHJpcCgpIDogYy5fc3RyaXAoKSwgYztcbiAgICB9LCBCLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIGEuaXVzaHJuKHRoaXMubiwgMCwgYyk7XG4gICAgfSwgQi5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gYS5pbXVsKHRoaXMuayk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBfKCkge1xuICAgICAgQi5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICBcImsyNTZcIixcbiAgICAgICAgXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZlwiXG4gICAgICApO1xuICAgIH1cbiAgICBuKF8sIEIpLCBfLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIGZvciAodmFyIGIgPSA0MTk0MzAzLCBFID0gTWF0aC5taW4oYS5sZW5ndGgsIDkpLCBTID0gMDsgUyA8IEU7IFMrKylcbiAgICAgICAgYy53b3Jkc1tTXSA9IGEud29yZHNbU107XG4gICAgICBpZiAoYy5sZW5ndGggPSBFLCBhLmxlbmd0aCA8PSA5KSB7XG4gICAgICAgIGEud29yZHNbMF0gPSAwLCBhLmxlbmd0aCA9IDE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB4ID0gYS53b3Jkc1s5XTtcbiAgICAgIGZvciAoYy53b3Jkc1tjLmxlbmd0aCsrXSA9IHggJiBiLCBTID0gMTA7IFMgPCBhLmxlbmd0aDsgUysrKSB7XG4gICAgICAgIHZhciB1ID0gYS53b3Jkc1tTXSB8IDA7XG4gICAgICAgIGEud29yZHNbUyAtIDEwXSA9ICh1ICYgYikgPDwgNCB8IHggPj4+IDIyLCB4ID0gdTtcbiAgICAgIH1cbiAgICAgIHggPj4+PSAyMiwgYS53b3Jkc1tTIC0gMTBdID0geCwgeCA9PT0gMCAmJiBhLmxlbmd0aCA+IDEwID8gYS5sZW5ndGggLT0gMTAgOiBhLmxlbmd0aCAtPSA5O1xuICAgIH0sIF8ucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24oYSkge1xuICAgICAgYS53b3Jkc1thLmxlbmd0aF0gPSAwLCBhLndvcmRzW2EubGVuZ3RoICsgMV0gPSAwLCBhLmxlbmd0aCArPSAyO1xuICAgICAgZm9yICh2YXIgYyA9IDAsIGIgPSAwOyBiIDwgYS5sZW5ndGg7IGIrKykge1xuICAgICAgICB2YXIgRSA9IGEud29yZHNbYl0gfCAwO1xuICAgICAgICBjICs9IEUgKiA5NzcsIGEud29yZHNbYl0gPSBjICYgNjcxMDg4NjMsIGMgPSBFICogNjQgKyAoYyAvIDY3MTA4ODY0IHwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYS53b3Jkc1thLmxlbmd0aCAtIDFdID09PSAwICYmIChhLmxlbmd0aC0tLCBhLndvcmRzW2EubGVuZ3RoIC0gMV0gPT09IDAgJiYgYS5sZW5ndGgtLSksIGE7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBSKCkge1xuICAgICAgQi5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICBcInAyMjRcIixcbiAgICAgICAgXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMVwiXG4gICAgICApO1xuICAgIH1cbiAgICBuKFIsIEIpO1xuICAgIGZ1bmN0aW9uIEooKSB7XG4gICAgICBCLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIFwicDE5MlwiLFxuICAgICAgICBcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmXCJcbiAgICAgICk7XG4gICAgfVxuICAgIG4oSiwgQik7XG4gICAgZnVuY3Rpb24gUSgpIHtcbiAgICAgIEIuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgXCIyNTUxOVwiLFxuICAgICAgICBcIjdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgbihRLCBCKSwgUS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbihhKSB7XG4gICAgICBmb3IgKHZhciBjID0gMCwgYiA9IDA7IGIgPCBhLmxlbmd0aDsgYisrKSB7XG4gICAgICAgIHZhciBFID0gKGEud29yZHNbYl0gfCAwKSAqIDE5ICsgYywgUyA9IEUgJiA2NzEwODg2MztcbiAgICAgICAgRSA+Pj49IDI2LCBhLndvcmRzW2JdID0gUywgYyA9IEU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYyAhPT0gMCAmJiAoYS53b3Jkc1thLmxlbmd0aCsrXSA9IGMpLCBhO1xuICAgIH0sIHMuX3ByaW1lID0gZnVuY3Rpb24oYSkge1xuICAgICAgaWYgKHpbYV0pXG4gICAgICAgIHJldHVybiB6W2FdO1xuICAgICAgdmFyIGM7XG4gICAgICBpZiAoYSA9PT0gXCJrMjU2XCIpXG4gICAgICAgIGMgPSBuZXcgXygpO1xuICAgICAgZWxzZSBpZiAoYSA9PT0gXCJwMjI0XCIpXG4gICAgICAgIGMgPSBuZXcgUigpO1xuICAgICAgZWxzZSBpZiAoYSA9PT0gXCJwMTkyXCIpXG4gICAgICAgIGMgPSBuZXcgSigpO1xuICAgICAgZWxzZSBpZiAoYSA9PT0gXCJwMjU1MTlcIilcbiAgICAgICAgYyA9IG5ldyBRKCk7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcHJpbWUgXCIgKyBhKTtcbiAgICAgIHJldHVybiB6W2FdID0gYywgYztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIE8obCkge1xuICAgICAgaWYgKHR5cGVvZiBsID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIGEgPSBzLl9wcmltZShsKTtcbiAgICAgICAgdGhpcy5tID0gYS5wLCB0aGlzLnByaW1lID0gYTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBpKGwuZ3RuKDEpLCBcIm1vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMVwiKSwgdGhpcy5tID0gbCwgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgfVxuICAgIE8ucHJvdG90eXBlLl92ZXJpZnkxID0gZnVuY3Rpb24oYSkge1xuICAgICAgaShhLm5lZ2F0aXZlID09PSAwLCBcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpLCBpKGEucmVkLCBcInJlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7XG4gICAgfSwgTy5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbihhLCBjKSB7XG4gICAgICBpKChhLm5lZ2F0aXZlIHwgYy5uZWdhdGl2ZSkgPT09IDAsIFwicmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXNcIiksIGkoXG4gICAgICAgIGEucmVkICYmIGEucmVkID09PSBjLnJlZCxcbiAgICAgICAgXCJyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCJcbiAgICAgICk7XG4gICAgfSwgTy5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLnByaW1lID8gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKSA6ICh2KGEsIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKSksIGEpO1xuICAgIH0sIE8ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBhLmlzWmVybygpID8gYS5jbG9uZSgpIDogdGhpcy5tLnN1YihhKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgfSwgTy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oYSwgYykge1xuICAgICAgdGhpcy5fdmVyaWZ5MihhLCBjKTtcbiAgICAgIHZhciBiID0gYS5hZGQoYyk7XG4gICAgICByZXR1cm4gYi5jbXAodGhpcy5tKSA+PSAwICYmIGIuaXN1Yih0aGlzLm0pLCBiLl9mb3JjZVJlZCh0aGlzKTtcbiAgICB9LCBPLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24oYSwgYykge1xuICAgICAgdGhpcy5fdmVyaWZ5MihhLCBjKTtcbiAgICAgIHZhciBiID0gYS5pYWRkKGMpO1xuICAgICAgcmV0dXJuIGIuY21wKHRoaXMubSkgPj0gMCAmJiBiLmlzdWIodGhpcy5tKSwgYjtcbiAgICB9LCBPLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbihhLCBjKSB7XG4gICAgICB0aGlzLl92ZXJpZnkyKGEsIGMpO1xuICAgICAgdmFyIGIgPSBhLnN1YihjKTtcbiAgICAgIHJldHVybiBiLmNtcG4oMCkgPCAwICYmIGIuaWFkZCh0aGlzLm0pLCBiLl9mb3JjZVJlZCh0aGlzKTtcbiAgICB9LCBPLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24oYSwgYykge1xuICAgICAgdGhpcy5fdmVyaWZ5MihhLCBjKTtcbiAgICAgIHZhciBiID0gYS5pc3ViKGMpO1xuICAgICAgcmV0dXJuIGIuY21wbigwKSA8IDAgJiYgYi5pYWRkKHRoaXMubSksIGI7XG4gICAgfSwgTy5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24oYSwgYykge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeTEoYSksIHRoaXMuaW1vZChhLnVzaGxuKGMpKTtcbiAgICB9LCBPLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24oYSwgYykge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeTIoYSwgYyksIHRoaXMuaW1vZChhLmltdWwoYykpO1xuICAgIH0sIE8ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIHJldHVybiB0aGlzLl92ZXJpZnkyKGEsIGMpLCB0aGlzLmltb2QoYS5tdWwoYykpO1xuICAgIH0sIE8ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbXVsKGEsIGEuY2xvbmUoKSk7XG4gICAgfSwgTy5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICAgIH0sIE8ucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbihhKSB7XG4gICAgICBpZiAoYS5pc1plcm8oKSlcbiAgICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcbiAgICAgIHZhciBjID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgICAgaWYgKGkoYyAlIDIgPT09IDEpLCBjID09PSAzKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5tLmFkZChuZXcgcygxKSkuaXVzaHJuKDIpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3coYSwgYik7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBFID0gdGhpcy5tLnN1Ym4oMSksIFMgPSAwOyAhRS5pc1plcm8oKSAmJiBFLmFuZGxuKDEpID09PSAwOyApXG4gICAgICAgIFMrKywgRS5pdXNocm4oMSk7XG4gICAgICBpKCFFLmlzWmVybygpKTtcbiAgICAgIHZhciB4ID0gbmV3IHMoMSkudG9SZWQodGhpcyksIHUgPSB4LnJlZE5lZygpLCBtID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpLCBnID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgICAgZm9yIChnID0gbmV3IHMoMiAqIGcgKiBnKS50b1JlZCh0aGlzKTsgdGhpcy5wb3coZywgbSkuY21wKHUpICE9PSAwOyApXG4gICAgICAgIGcucmVkSUFkZCh1KTtcbiAgICAgIGZvciAodmFyIFAgPSB0aGlzLnBvdyhnLCBFKSwgRyA9IHRoaXMucG93KGEsIEUuYWRkbigxKS5pdXNocm4oMSkpLCBNID0gdGhpcy5wb3coYSwgRSksIEggPSBTOyBNLmNtcCh4KSAhPT0gMDsgKSB7XG4gICAgICAgIGZvciAodmFyIEMgPSBNLCBxID0gMDsgQy5jbXAoeCkgIT09IDA7IHErKylcbiAgICAgICAgICBDID0gQy5yZWRTcXIoKTtcbiAgICAgICAgaShxIDwgSCk7XG4gICAgICAgIHZhciBMID0gdGhpcy5wb3coUCwgbmV3IHMoMSkuaXVzaGxuKEggLSBxIC0gMSkpO1xuICAgICAgICBHID0gRy5yZWRNdWwoTCksIFAgPSBMLnJlZFNxcigpLCBNID0gTS5yZWRNdWwoUCksIEggPSBxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEc7XG4gICAgfSwgTy5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBjID0gYS5faW52bXAodGhpcy5tKTtcbiAgICAgIHJldHVybiBjLm5lZ2F0aXZlICE9PSAwID8gKGMubmVnYXRpdmUgPSAwLCB0aGlzLmltb2QoYykucmVkTmVnKCkpIDogdGhpcy5pbW9kKGMpO1xuICAgIH0sIE8ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIGlmIChjLmlzWmVybygpKVxuICAgICAgICByZXR1cm4gbmV3IHMoMSkudG9SZWQodGhpcyk7XG4gICAgICBpZiAoYy5jbXBuKDEpID09PSAwKVxuICAgICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgICAgdmFyIGIgPSA0LCBFID0gbmV3IEFycmF5KDEgPDwgYik7XG4gICAgICBFWzBdID0gbmV3IHMoMSkudG9SZWQodGhpcyksIEVbMV0gPSBhO1xuICAgICAgZm9yICh2YXIgUyA9IDI7IFMgPCBFLmxlbmd0aDsgUysrKVxuICAgICAgICBFW1NdID0gdGhpcy5tdWwoRVtTIC0gMV0sIGEpO1xuICAgICAgdmFyIHggPSBFWzBdLCB1ID0gMCwgbSA9IDAsIGcgPSBjLmJpdExlbmd0aCgpICUgMjY7XG4gICAgICBmb3IgKGcgPT09IDAgJiYgKGcgPSAyNiksIFMgPSBjLmxlbmd0aCAtIDE7IFMgPj0gMDsgUy0tKSB7XG4gICAgICAgIGZvciAodmFyIFAgPSBjLndvcmRzW1NdLCBHID0gZyAtIDE7IEcgPj0gMDsgRy0tKSB7XG4gICAgICAgICAgdmFyIE0gPSBQID4+IEcgJiAxO1xuICAgICAgICAgIGlmICh4ICE9PSBFWzBdICYmICh4ID0gdGhpcy5zcXIoeCkpLCBNID09PSAwICYmIHUgPT09IDApIHtcbiAgICAgICAgICAgIG0gPSAwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHUgPDw9IDEsIHUgfD0gTSwgbSsrLCAhKG0gIT09IGIgJiYgKFMgIT09IDAgfHwgRyAhPT0gMCkpICYmICh4ID0gdGhpcy5tdWwoeCwgRVt1XSksIG0gPSAwLCB1ID0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZyA9IDI2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfSwgTy5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIGMgPSBhLnVtb2QodGhpcy5tKTtcbiAgICAgIHJldHVybiBjID09PSBhID8gYy5jbG9uZSgpIDogYztcbiAgICB9LCBPLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBjID0gYS5jbG9uZSgpO1xuICAgICAgcmV0dXJuIGMucmVkID0gbnVsbCwgYztcbiAgICB9LCBzLm1vbnQgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gbmV3IHAoYSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwKGwpIHtcbiAgICAgIE8uY2FsbCh0aGlzLCBsKSwgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKSwgdGhpcy5zaGlmdCAlIDI2ICE9PSAwICYmICh0aGlzLnNoaWZ0ICs9IDI2IC0gdGhpcy5zaGlmdCAlIDI2KSwgdGhpcy5yID0gbmV3IHMoMSkuaXVzaGxuKHRoaXMuc2hpZnQpLCB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSksIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKSwgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pLCB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpLCB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gICAgfVxuICAgIG4ocCwgTyksIHAucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoYS51c2hsbih0aGlzLnNoaWZ0KSk7XG4gICAgfSwgcC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYyA9IHRoaXMuaW1vZChhLm11bCh0aGlzLnJpbnYpKTtcbiAgICAgIHJldHVybiBjLnJlZCA9IG51bGwsIGM7XG4gICAgfSwgcC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIGlmIChhLmlzWmVybygpIHx8IGMuaXNaZXJvKCkpXG4gICAgICAgIHJldHVybiBhLndvcmRzWzBdID0gMCwgYS5sZW5ndGggPSAxLCBhO1xuICAgICAgdmFyIGIgPSBhLmltdWwoYyksIEUgPSBiLm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKSwgUyA9IGIuaXN1YihFKS5pdXNocm4odGhpcy5zaGlmdCksIHggPSBTO1xuICAgICAgcmV0dXJuIFMuY21wKHRoaXMubSkgPj0gMCA/IHggPSBTLmlzdWIodGhpcy5tKSA6IFMuY21wbigwKSA8IDAgJiYgKHggPSBTLmlhZGQodGhpcy5tKSksIHguX2ZvcmNlUmVkKHRoaXMpO1xuICAgIH0sIHAucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIGlmIChhLmlzWmVybygpIHx8IGMuaXNaZXJvKCkpXG4gICAgICAgIHJldHVybiBuZXcgcygwKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgICB2YXIgYiA9IGEubXVsKGMpLCBFID0gYi5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSksIFMgPSBiLmlzdWIoRSkuaXVzaHJuKHRoaXMuc2hpZnQpLCB4ID0gUztcbiAgICAgIHJldHVybiBTLmNtcCh0aGlzLm0pID49IDAgPyB4ID0gUy5pc3ViKHRoaXMubSkgOiBTLmNtcG4oMCkgPCAwICYmICh4ID0gUy5pYWRkKHRoaXMubSkpLCB4Ll9mb3JjZVJlZCh0aGlzKTtcbiAgICB9LCBwLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIGMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgICAgcmV0dXJuIGMuX2ZvcmNlUmVkKHRoaXMpO1xuICAgIH07XG4gIH0pKHIsIHRyKTtcbn0pKFVvKTtcbnZhciBVdiA9IFVvLmV4cG9ydHM7XG5jb25zdCBLZSA9IC8qIEBfX1BVUkVfXyAqLyBibihVdik7XG52YXIgenYgPSBLZS5CTjtcbmZ1bmN0aW9uIEJ2KHIpIHtcbiAgcmV0dXJuIG5ldyB6dihyLCAzNikudG9TdHJpbmcoMTYpO1xufVxuY29uc3Qga3YgPSBcInN0cmluZ3MvNS43LjBcIiwganYgPSBuZXcgaHQoa3YpO1xudmFyIGtzO1xuKGZ1bmN0aW9uKHIpIHtcbiAgci5jdXJyZW50ID0gXCJcIiwgci5ORkMgPSBcIk5GQ1wiLCByLk5GRCA9IFwiTkZEXCIsIHIuTkZLQyA9IFwiTkZLQ1wiLCByLk5GS0QgPSBcIk5GS0RcIjtcbn0pKGtzIHx8IChrcyA9IHt9KSk7XG52YXIgYWM7XG4oZnVuY3Rpb24ocikge1xuICByLlVORVhQRUNURURfQ09OVElOVUUgPSBcInVuZXhwZWN0ZWQgY29udGludWF0aW9uIGJ5dGVcIiwgci5CQURfUFJFRklYID0gXCJiYWQgY29kZXBvaW50IHByZWZpeFwiLCByLk9WRVJSVU4gPSBcInN0cmluZyBvdmVycnVuXCIsIHIuTUlTU0lOR19DT05USU5VRSA9IFwibWlzc2luZyBjb250aW51YXRpb24gYnl0ZVwiLCByLk9VVF9PRl9SQU5HRSA9IFwib3V0IG9mIFVURi04IHJhbmdlXCIsIHIuVVRGMTZfU1VSUk9HQVRFID0gXCJVVEYtMTYgc3Vycm9nYXRlXCIsIHIuT1ZFUkxPTkcgPSBcIm92ZXJsb25nIHJlcHJlc2VudGF0aW9uXCI7XG59KShhYyB8fCAoYWMgPSB7fSkpO1xuZnVuY3Rpb24ga2EociwgZSA9IGtzLmN1cnJlbnQpIHtcbiAgZSAhPSBrcy5jdXJyZW50ICYmIChqdi5jaGVja05vcm1hbGl6ZSgpLCByID0gci5ub3JtYWxpemUoZSkpO1xuICBsZXQgdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBuID0gci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChuIDwgMTI4KVxuICAgICAgdC5wdXNoKG4pO1xuICAgIGVsc2UgaWYgKG4gPCAyMDQ4KVxuICAgICAgdC5wdXNoKG4gPj4gNiB8IDE5MiksIHQucHVzaChuICYgNjMgfCAxMjgpO1xuICAgIGVsc2UgaWYgKChuICYgNjQ1MTIpID09IDU1Mjk2KSB7XG4gICAgICBpKys7XG4gICAgICBjb25zdCBzID0gci5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGkgPj0gci5sZW5ndGggfHwgKHMgJiA2NDUxMikgIT09IDU2MzIwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0Zi04IHN0cmluZ1wiKTtcbiAgICAgIGNvbnN0IG8gPSA2NTUzNiArICgobiAmIDEwMjMpIDw8IDEwKSArIChzICYgMTAyMyk7XG4gICAgICB0LnB1c2gobyA+PiAxOCB8IDI0MCksIHQucHVzaChvID4+IDEyICYgNjMgfCAxMjgpLCB0LnB1c2gobyA+PiA2ICYgNjMgfCAxMjgpLCB0LnB1c2gobyAmIDYzIHwgMTI4KTtcbiAgICB9IGVsc2VcbiAgICAgIHQucHVzaChuID4+IDEyIHwgMjI0KSwgdC5wdXNoKG4gPj4gNiAmIDYzIHwgMTI4KSwgdC5wdXNoKG4gJiA2MyB8IDEyOCk7XG4gIH1cbiAgcmV0dXJuIHl0KHQpO1xufVxuY29uc3QgS3YgPSBgXHUwMDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XG5gO1xuZnVuY3Rpb24gYnUocikge1xuICByZXR1cm4gdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiAmJiAociA9IGthKHIpKSwgcW8oTHYoW1xuICAgIGthKEt2KSxcbiAgICBrYShTdHJpbmcoci5sZW5ndGgpKSxcbiAgICByXG4gIF0pKTtcbn1cbmNvbnN0IEh2ID0gXCJhZGRyZXNzLzUuNy4wXCIsIGtuID0gbmV3IGh0KEh2KTtcbmZ1bmN0aW9uIG9jKHIpIHtcbiAgTHIociwgMjApIHx8IGtuLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgciksIHIgPSByLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGUgPSByLnN1YnN0cmluZygyKS5zcGxpdChcIlwiKSwgdCA9IG5ldyBVaW50OEFycmF5KDQwKTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCA0MDsgbisrKVxuICAgIHRbbl0gPSBlW25dLmNoYXJDb2RlQXQoMCk7XG4gIGNvbnN0IGkgPSB5dChxbyh0KSk7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgNDA7IG4gKz0gMilcbiAgICBpW24gPj4gMV0gPj4gNCA+PSA4ICYmIChlW25dID0gZVtuXS50b1VwcGVyQ2FzZSgpKSwgKGlbbiA+PiAxXSAmIDE1KSA+PSA4ICYmIChlW24gKyAxXSA9IGVbbiArIDFdLnRvVXBwZXJDYXNlKCkpO1xuICByZXR1cm4gXCIweFwiICsgZS5qb2luKFwiXCIpO1xufVxuY29uc3QgVnYgPSA5MDA3MTk5MjU0NzQwOTkxO1xuZnVuY3Rpb24gV3Yocikge1xuICByZXR1cm4gTWF0aC5sb2cxMCA/IE1hdGgubG9nMTAocikgOiBNYXRoLmxvZyhyKSAvIE1hdGguTE4xMDtcbn1cbmNvbnN0IHpvID0ge307XG5mb3IgKGxldCByID0gMDsgciA8IDEwOyByKyspXG4gIHpvW1N0cmluZyhyKV0gPSBTdHJpbmcocik7XG5mb3IgKGxldCByID0gMDsgciA8IDI2OyByKyspXG4gIHpvW1N0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyByKV0gPSBTdHJpbmcoMTAgKyByKTtcbmNvbnN0IGZjID0gTWF0aC5mbG9vcihXdihWdikpO1xuZnVuY3Rpb24gR3Yocikge1xuICByID0gci50b1VwcGVyQ2FzZSgpLCByID0gci5zdWJzdHJpbmcoNCkgKyByLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcbiAgbGV0IGUgPSByLnNwbGl0KFwiXCIpLm1hcCgoaSkgPT4gem9baV0pLmpvaW4oXCJcIik7XG4gIGZvciAoOyBlLmxlbmd0aCA+PSBmYzsgKSB7XG4gICAgbGV0IGkgPSBlLnN1YnN0cmluZygwLCBmYyk7XG4gICAgZSA9IHBhcnNlSW50KGksIDEwKSAlIDk3ICsgZS5zdWJzdHJpbmcoaS5sZW5ndGgpO1xuICB9XG4gIGxldCB0ID0gU3RyaW5nKDk4IC0gcGFyc2VJbnQoZSwgMTApICUgOTcpO1xuICBmb3IgKDsgdC5sZW5ndGggPCAyOyApXG4gICAgdCA9IFwiMFwiICsgdDtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBKdihyKSB7XG4gIGxldCBlID0gbnVsbDtcbiAgaWYgKHR5cGVvZiByICE9IFwic3RyaW5nXCIgJiYga24udGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCByKSwgci5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NDB9JC8pKVxuICAgIHIuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIgJiYgKHIgPSBcIjB4XCIgKyByKSwgZSA9IG9jKHIpLCByLm1hdGNoKC8oW0EtRl0uKlthLWZdKXwoW2EtZl0uKltBLUZdKS8pICYmIGUgIT09IHIgJiYga24udGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGFkZHJlc3MgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIHIpO1xuICBlbHNlIGlmIChyLm1hdGNoKC9eWEVbMC05XXsyfVswLTlBLVphLXpdezMwLDMxfSQvKSkge1xuICAgIGZvciAoci5zdWJzdHJpbmcoMiwgNCkgIT09IEd2KHIpICYmIGtuLnRocm93QXJndW1lbnRFcnJvcihcImJhZCBpY2FwIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCByKSwgZSA9IEJ2KHIuc3Vic3RyaW5nKDQpKTsgZS5sZW5ndGggPCA0MDsgKVxuICAgICAgZSA9IFwiMFwiICsgZTtcbiAgICBlID0gb2MoXCIweFwiICsgZSk7XG4gIH0gZWxzZVxuICAgIGtuLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgcik7XG4gIHJldHVybiBlO1xufVxuZ2xvYmFsVGhpcyAmJiBnbG9iYWxUaGlzLl9fYXdhaXRlcjtcbmZ1bmN0aW9uIFRuKHIsIGUsIHQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIGUsIHtcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICB2YWx1ZTogdCxcbiAgICB3cml0YWJsZTogITFcbiAgfSk7XG59XG52YXIgbnMgPSB7fSwgUWUgPSB7fSwgWWkgPSBndTtcbmZ1bmN0aW9uIGd1KHIsIGUpIHtcbiAgaWYgKCFyKVxuICAgIHRocm93IG5ldyBFcnJvcihlIHx8IFwiQXNzZXJ0aW9uIGZhaWxlZFwiKTtcbn1cbmd1LmVxdWFsID0gZnVuY3Rpb24oZSwgdCwgaSkge1xuICBpZiAoZSAhPSB0KVxuICAgIHRocm93IG5ldyBFcnJvcihpIHx8IFwiQXNzZXJ0aW9uIGZhaWxlZDogXCIgKyBlICsgXCIgIT0gXCIgKyB0KTtcbn07XG52YXIgbW8gPSB7IGV4cG9ydHM6IHt9IH07XG50eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PSBcImZ1bmN0aW9uXCIgPyBtby5leHBvcnRzID0gZnVuY3Rpb24oZSwgdCkge1xuICB0ICYmIChlLnN1cGVyXyA9IHQsIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogZSxcbiAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH1cbiAgfSkpO1xufSA6IG1vLmV4cG9ydHMgPSBmdW5jdGlvbihlLCB0KSB7XG4gIGlmICh0KSB7XG4gICAgZS5zdXBlcl8gPSB0O1xuICAgIHZhciBpID0gZnVuY3Rpb24oKSB7XG4gICAgfTtcbiAgICBpLnByb3RvdHlwZSA9IHQucHJvdG90eXBlLCBlLnByb3RvdHlwZSA9IG5ldyBpKCksIGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZTtcbiAgfVxufTtcbnZhciB1YSA9IG1vLmV4cG9ydHMsIFl2ID0gWWksIFh2ID0gdWE7XG5RZS5pbmhlcml0cyA9IFh2O1xuZnVuY3Rpb24gWnYociwgZSkge1xuICByZXR1cm4gKHIuY2hhckNvZGVBdChlKSAmIDY0NTEyKSAhPT0gNTUyOTYgfHwgZSA8IDAgfHwgZSArIDEgPj0gci5sZW5ndGggPyAhMSA6IChyLmNoYXJDb2RlQXQoZSArIDEpICYgNjQ1MTIpID09PSA1NjMyMDtcbn1cbmZ1bmN0aW9uIFF2KHIsIGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpXG4gICAgcmV0dXJuIHIuc2xpY2UoKTtcbiAgaWYgKCFyKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHQgPSBbXTtcbiAgaWYgKHR5cGVvZiByID09IFwic3RyaW5nXCIpXG4gICAgaWYgKGUpIHtcbiAgICAgIGlmIChlID09PSBcImhleFwiKVxuICAgICAgICBmb3IgKHIgPSByLnJlcGxhY2UoL1teYS16MC05XSsvaWcsIFwiXCIpLCByLmxlbmd0aCAlIDIgIT09IDAgJiYgKHIgPSBcIjBcIiArIHIpLCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuICs9IDIpXG4gICAgICAgICAgdC5wdXNoKHBhcnNlSW50KHJbbl0gKyByW24gKyAxXSwgMTYpKTtcbiAgICB9IGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIHMgPSByLmNoYXJDb2RlQXQobik7XG4gICAgICAgIHMgPCAxMjggPyB0W2krK10gPSBzIDogcyA8IDIwNDggPyAodFtpKytdID0gcyA+PiA2IHwgMTkyLCB0W2krK10gPSBzICYgNjMgfCAxMjgpIDogWnYociwgbikgPyAocyA9IDY1NTM2ICsgKChzICYgMTAyMykgPDwgMTApICsgKHIuY2hhckNvZGVBdCgrK24pICYgMTAyMyksIHRbaSsrXSA9IHMgPj4gMTggfCAyNDAsIHRbaSsrXSA9IHMgPj4gMTIgJiA2MyB8IDEyOCwgdFtpKytdID0gcyA+PiA2ICYgNjMgfCAxMjgsIHRbaSsrXSA9IHMgJiA2MyB8IDEyOCkgOiAodFtpKytdID0gcyA+PiAxMiB8IDIyNCwgdFtpKytdID0gcyA+PiA2ICYgNjMgfCAxMjgsIHRbaSsrXSA9IHMgJiA2MyB8IDEyOCk7XG4gICAgICB9XG4gIGVsc2VcbiAgICBmb3IgKG4gPSAwOyBuIDwgci5sZW5ndGg7IG4rKylcbiAgICAgIHRbbl0gPSByW25dIHwgMDtcbiAgcmV0dXJuIHQ7XG59XG5RZS50b0FycmF5ID0gUXY7XG5mdW5jdGlvbiBlYihyKSB7XG4gIGZvciAodmFyIGUgPSBcIlwiLCB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspXG4gICAgZSArPSBtdShyW3RdLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiBlO1xufVxuUWUudG9IZXggPSBlYjtcbmZ1bmN0aW9uIHl1KHIpIHtcbiAgdmFyIGUgPSByID4+PiAyNCB8IHIgPj4+IDggJiA2NTI4MCB8IHIgPDwgOCAmIDE2NzExNjgwIHwgKHIgJiAyNTUpIDw8IDI0O1xuICByZXR1cm4gZSA+Pj4gMDtcbn1cblFlLmh0b25sID0geXU7XG5mdW5jdGlvbiB0YihyLCBlKSB7XG4gIGZvciAodmFyIHQgPSBcIlwiLCBpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbiA9IHJbaV07XG4gICAgZSA9PT0gXCJsaXR0bGVcIiAmJiAobiA9IHl1KG4pKSwgdCArPSB3dShuLnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5RZS50b0hleDMyID0gdGI7XG5mdW5jdGlvbiBtdShyKSB7XG4gIHJldHVybiByLmxlbmd0aCA9PT0gMSA/IFwiMFwiICsgciA6IHI7XG59XG5RZS56ZXJvMiA9IG11O1xuZnVuY3Rpb24gd3Uocikge1xuICByZXR1cm4gci5sZW5ndGggPT09IDcgPyBcIjBcIiArIHIgOiByLmxlbmd0aCA9PT0gNiA/IFwiMDBcIiArIHIgOiByLmxlbmd0aCA9PT0gNSA/IFwiMDAwXCIgKyByIDogci5sZW5ndGggPT09IDQgPyBcIjAwMDBcIiArIHIgOiByLmxlbmd0aCA9PT0gMyA/IFwiMDAwMDBcIiArIHIgOiByLmxlbmd0aCA9PT0gMiA/IFwiMDAwMDAwXCIgKyByIDogci5sZW5ndGggPT09IDEgPyBcIjAwMDAwMDBcIiArIHIgOiByO1xufVxuUWUuemVybzggPSB3dTtcbmZ1bmN0aW9uIHJiKHIsIGUsIHQsIGkpIHtcbiAgdmFyIG4gPSB0IC0gZTtcbiAgWXYobiAlIDQgPT09IDApO1xuICBmb3IgKHZhciBzID0gbmV3IEFycmF5KG4gLyA0KSwgbyA9IDAsIGYgPSBlOyBvIDwgcy5sZW5ndGg7IG8rKywgZiArPSA0KSB7XG4gICAgdmFyIGg7XG4gICAgaSA9PT0gXCJiaWdcIiA/IGggPSByW2ZdIDw8IDI0IHwgcltmICsgMV0gPDwgMTYgfCByW2YgKyAyXSA8PCA4IHwgcltmICsgM10gOiBoID0gcltmICsgM10gPDwgMjQgfCByW2YgKyAyXSA8PCAxNiB8IHJbZiArIDFdIDw8IDggfCByW2ZdLCBzW29dID0gaCA+Pj4gMDtcbiAgfVxuICByZXR1cm4gcztcbn1cblFlLmpvaW4zMiA9IHJiO1xuZnVuY3Rpb24gaWIociwgZSkge1xuICBmb3IgKHZhciB0ID0gbmV3IEFycmF5KHIubGVuZ3RoICogNCksIGkgPSAwLCBuID0gMDsgaSA8IHIubGVuZ3RoOyBpKyssIG4gKz0gNCkge1xuICAgIHZhciBzID0gcltpXTtcbiAgICBlID09PSBcImJpZ1wiID8gKHRbbl0gPSBzID4+PiAyNCwgdFtuICsgMV0gPSBzID4+PiAxNiAmIDI1NSwgdFtuICsgMl0gPSBzID4+PiA4ICYgMjU1LCB0W24gKyAzXSA9IHMgJiAyNTUpIDogKHRbbiArIDNdID0gcyA+Pj4gMjQsIHRbbiArIDJdID0gcyA+Pj4gMTYgJiAyNTUsIHRbbiArIDFdID0gcyA+Pj4gOCAmIDI1NSwgdFtuXSA9IHMgJiAyNTUpO1xuICB9XG4gIHJldHVybiB0O1xufVxuUWUuc3BsaXQzMiA9IGliO1xuZnVuY3Rpb24gbmIociwgZSkge1xuICByZXR1cm4gciA+Pj4gZSB8IHIgPDwgMzIgLSBlO1xufVxuUWUucm90cjMyID0gbmI7XG5mdW5jdGlvbiBzYihyLCBlKSB7XG4gIHJldHVybiByIDw8IGUgfCByID4+PiAzMiAtIGU7XG59XG5RZS5yb3RsMzIgPSBzYjtcbmZ1bmN0aW9uIGFiKHIsIGUpIHtcbiAgcmV0dXJuIHIgKyBlID4+PiAwO1xufVxuUWUuc3VtMzIgPSBhYjtcbmZ1bmN0aW9uIG9iKHIsIGUsIHQpIHtcbiAgcmV0dXJuIHIgKyBlICsgdCA+Pj4gMDtcbn1cblFlLnN1bTMyXzMgPSBvYjtcbmZ1bmN0aW9uIGZiKHIsIGUsIHQsIGkpIHtcbiAgcmV0dXJuIHIgKyBlICsgdCArIGkgPj4+IDA7XG59XG5RZS5zdW0zMl80ID0gZmI7XG5mdW5jdGlvbiBjYihyLCBlLCB0LCBpLCBuKSB7XG4gIHJldHVybiByICsgZSArIHQgKyBpICsgbiA+Pj4gMDtcbn1cblFlLnN1bTMyXzUgPSBjYjtcbmZ1bmN0aW9uIGhiKHIsIGUsIHQsIGkpIHtcbiAgdmFyIG4gPSByW2VdLCBzID0gcltlICsgMV0sIG8gPSBpICsgcyA+Pj4gMCwgZiA9IChvIDwgaSA/IDEgOiAwKSArIHQgKyBuO1xuICByW2VdID0gZiA+Pj4gMCwgcltlICsgMV0gPSBvO1xufVxuUWUuc3VtNjQgPSBoYjtcbmZ1bmN0aW9uIHViKHIsIGUsIHQsIGkpIHtcbiAgdmFyIG4gPSBlICsgaSA+Pj4gMCwgcyA9IChuIDwgZSA/IDEgOiAwKSArIHIgKyB0O1xuICByZXR1cm4gcyA+Pj4gMDtcbn1cblFlLnN1bTY0X2hpID0gdWI7XG5mdW5jdGlvbiBkYihyLCBlLCB0LCBpKSB7XG4gIHZhciBuID0gZSArIGk7XG4gIHJldHVybiBuID4+PiAwO1xufVxuUWUuc3VtNjRfbG8gPSBkYjtcbmZ1bmN0aW9uIGxiKHIsIGUsIHQsIGksIG4sIHMsIG8sIGYpIHtcbiAgdmFyIGggPSAwLCBkID0gZTtcbiAgZCA9IGQgKyBpID4+PiAwLCBoICs9IGQgPCBlID8gMSA6IDAsIGQgPSBkICsgcyA+Pj4gMCwgaCArPSBkIDwgcyA/IDEgOiAwLCBkID0gZCArIGYgPj4+IDAsIGggKz0gZCA8IGYgPyAxIDogMDtcbiAgdmFyIHYgPSByICsgdCArIG4gKyBvICsgaDtcbiAgcmV0dXJuIHYgPj4+IDA7XG59XG5RZS5zdW02NF80X2hpID0gbGI7XG5mdW5jdGlvbiBwYihyLCBlLCB0LCBpLCBuLCBzLCBvLCBmKSB7XG4gIHZhciBoID0gZSArIGkgKyBzICsgZjtcbiAgcmV0dXJuIGggPj4+IDA7XG59XG5RZS5zdW02NF80X2xvID0gcGI7XG5mdW5jdGlvbiB2YihyLCBlLCB0LCBpLCBuLCBzLCBvLCBmLCBoLCBkKSB7XG4gIHZhciB2ID0gMCwgdyA9IGU7XG4gIHcgPSB3ICsgaSA+Pj4gMCwgdiArPSB3IDwgZSA/IDEgOiAwLCB3ID0gdyArIHMgPj4+IDAsIHYgKz0gdyA8IHMgPyAxIDogMCwgdyA9IHcgKyBmID4+PiAwLCB2ICs9IHcgPCBmID8gMSA6IDAsIHcgPSB3ICsgZCA+Pj4gMCwgdiArPSB3IDwgZCA/IDEgOiAwO1xuICB2YXIgQSA9IHIgKyB0ICsgbiArIG8gKyBoICsgdjtcbiAgcmV0dXJuIEEgPj4+IDA7XG59XG5RZS5zdW02NF81X2hpID0gdmI7XG5mdW5jdGlvbiBiYihyLCBlLCB0LCBpLCBuLCBzLCBvLCBmLCBoLCBkKSB7XG4gIHZhciB2ID0gZSArIGkgKyBzICsgZiArIGQ7XG4gIHJldHVybiB2ID4+PiAwO1xufVxuUWUuc3VtNjRfNV9sbyA9IGJiO1xuZnVuY3Rpb24gZ2IociwgZSwgdCkge1xuICB2YXIgaSA9IGUgPDwgMzIgLSB0IHwgciA+Pj4gdDtcbiAgcmV0dXJuIGkgPj4+IDA7XG59XG5RZS5yb3RyNjRfaGkgPSBnYjtcbmZ1bmN0aW9uIHliKHIsIGUsIHQpIHtcbiAgdmFyIGkgPSByIDw8IDMyIC0gdCB8IGUgPj4+IHQ7XG4gIHJldHVybiBpID4+PiAwO1xufVxuUWUucm90cjY0X2xvID0geWI7XG5mdW5jdGlvbiBtYihyLCBlLCB0KSB7XG4gIHJldHVybiByID4+PiB0O1xufVxuUWUuc2hyNjRfaGkgPSBtYjtcbmZ1bmN0aW9uIHdiKHIsIGUsIHQpIHtcbiAgdmFyIGkgPSByIDw8IDMyIC0gdCB8IGUgPj4+IHQ7XG4gIHJldHVybiBpID4+PiAwO1xufVxuUWUuc2hyNjRfbG8gPSB3YjtcbnZhciBtbiA9IHt9LCBjYyA9IFFlLCBfYiA9IFlpO1xuZnVuY3Rpb24gZGEoKSB7XG4gIHRoaXMucGVuZGluZyA9IG51bGwsIHRoaXMucGVuZGluZ1RvdGFsID0gMCwgdGhpcy5ibG9ja1NpemUgPSB0aGlzLmNvbnN0cnVjdG9yLmJsb2NrU2l6ZSwgdGhpcy5vdXRTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5vdXRTaXplLCB0aGlzLmhtYWNTdHJlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IuaG1hY1N0cmVuZ3RoLCB0aGlzLnBhZExlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IucGFkTGVuZ3RoIC8gOCwgdGhpcy5lbmRpYW4gPSBcImJpZ1wiLCB0aGlzLl9kZWx0YTggPSB0aGlzLmJsb2NrU2l6ZSAvIDgsIHRoaXMuX2RlbHRhMzIgPSB0aGlzLmJsb2NrU2l6ZSAvIDMyO1xufVxubW4uQmxvY2tIYXNoID0gZGE7XG5kYS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZSwgdCkge1xuICBpZiAoZSA9IGNjLnRvQXJyYXkoZSwgdCksIHRoaXMucGVuZGluZyA/IHRoaXMucGVuZGluZyA9IHRoaXMucGVuZGluZy5jb25jYXQoZSkgOiB0aGlzLnBlbmRpbmcgPSBlLCB0aGlzLnBlbmRpbmdUb3RhbCArPSBlLmxlbmd0aCwgdGhpcy5wZW5kaW5nLmxlbmd0aCA+PSB0aGlzLl9kZWx0YTgpIHtcbiAgICBlID0gdGhpcy5wZW5kaW5nO1xuICAgIHZhciBpID0gZS5sZW5ndGggJSB0aGlzLl9kZWx0YTg7XG4gICAgdGhpcy5wZW5kaW5nID0gZS5zbGljZShlLmxlbmd0aCAtIGksIGUubGVuZ3RoKSwgdGhpcy5wZW5kaW5nLmxlbmd0aCA9PT0gMCAmJiAodGhpcy5wZW5kaW5nID0gbnVsbCksIGUgPSBjYy5qb2luMzIoZSwgMCwgZS5sZW5ndGggLSBpLCB0aGlzLmVuZGlhbik7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbiArPSB0aGlzLl9kZWx0YTMyKVxuICAgICAgdGhpcy5fdXBkYXRlKGUsIG4sIG4gKyB0aGlzLl9kZWx0YTMyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5kYS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gdGhpcy51cGRhdGUodGhpcy5fcGFkKCkpLCBfYih0aGlzLnBlbmRpbmcgPT09IG51bGwpLCB0aGlzLl9kaWdlc3QoZSk7XG59O1xuZGEucHJvdG90eXBlLl9wYWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGUgPSB0aGlzLnBlbmRpbmdUb3RhbCwgdCA9IHRoaXMuX2RlbHRhOCwgaSA9IHQgLSAoZSArIHRoaXMucGFkTGVuZ3RoKSAlIHQsIG4gPSBuZXcgQXJyYXkoaSArIHRoaXMucGFkTGVuZ3RoKTtcbiAgblswXSA9IDEyODtcbiAgZm9yICh2YXIgcyA9IDE7IHMgPCBpOyBzKyspXG4gICAgbltzXSA9IDA7XG4gIGlmIChlIDw8PSAzLCB0aGlzLmVuZGlhbiA9PT0gXCJiaWdcIikge1xuICAgIGZvciAodmFyIG8gPSA4OyBvIDwgdGhpcy5wYWRMZW5ndGg7IG8rKylcbiAgICAgIG5bcysrXSA9IDA7XG4gICAgbltzKytdID0gMCwgbltzKytdID0gMCwgbltzKytdID0gMCwgbltzKytdID0gMCwgbltzKytdID0gZSA+Pj4gMjQgJiAyNTUsIG5bcysrXSA9IGUgPj4+IDE2ICYgMjU1LCBuW3MrK10gPSBlID4+PiA4ICYgMjU1LCBuW3MrK10gPSBlICYgMjU1O1xuICB9IGVsc2VcbiAgICBmb3IgKG5bcysrXSA9IGUgJiAyNTUsIG5bcysrXSA9IGUgPj4+IDggJiAyNTUsIG5bcysrXSA9IGUgPj4+IDE2ICYgMjU1LCBuW3MrK10gPSBlID4+PiAyNCAmIDI1NSwgbltzKytdID0gMCwgbltzKytdID0gMCwgbltzKytdID0gMCwgbltzKytdID0gMCwgbyA9IDg7IG8gPCB0aGlzLnBhZExlbmd0aDsgbysrKVxuICAgICAgbltzKytdID0gMDtcbiAgcmV0dXJuIG47XG59O1xudmFyIHduID0ge30sIEtyID0ge30sIHhiID0gUWUsIEZyID0geGIucm90cjMyO1xuZnVuY3Rpb24gRWIociwgZSwgdCwgaSkge1xuICBpZiAociA9PT0gMClcbiAgICByZXR1cm4gX3UoZSwgdCwgaSk7XG4gIGlmIChyID09PSAxIHx8IHIgPT09IDMpXG4gICAgcmV0dXJuIEV1KGUsIHQsIGkpO1xuICBpZiAociA9PT0gMilcbiAgICByZXR1cm4geHUoZSwgdCwgaSk7XG59XG5Lci5mdF8xID0gRWI7XG5mdW5jdGlvbiBfdShyLCBlLCB0KSB7XG4gIHJldHVybiByICYgZSBeIH5yICYgdDtcbn1cbktyLmNoMzIgPSBfdTtcbmZ1bmN0aW9uIHh1KHIsIGUsIHQpIHtcbiAgcmV0dXJuIHIgJiBlIF4gciAmIHQgXiBlICYgdDtcbn1cbktyLm1hajMyID0geHU7XG5mdW5jdGlvbiBFdShyLCBlLCB0KSB7XG4gIHJldHVybiByIF4gZSBeIHQ7XG59XG5Lci5wMzIgPSBFdTtcbmZ1bmN0aW9uIFNiKHIpIHtcbiAgcmV0dXJuIEZyKHIsIDIpIF4gRnIociwgMTMpIF4gRnIociwgMjIpO1xufVxuS3IuczBfMjU2ID0gU2I7XG5mdW5jdGlvbiBNYihyKSB7XG4gIHJldHVybiBGcihyLCA2KSBeIEZyKHIsIDExKSBeIEZyKHIsIDI1KTtcbn1cbktyLnMxXzI1NiA9IE1iO1xuZnVuY3Rpb24gSWIocikge1xuICByZXR1cm4gRnIociwgNykgXiBGcihyLCAxOCkgXiByID4+PiAzO1xufVxuS3IuZzBfMjU2ID0gSWI7XG5mdW5jdGlvbiBBYihyKSB7XG4gIHJldHVybiBGcihyLCAxNykgXiBGcihyLCAxOSkgXiByID4+PiAxMDtcbn1cbktyLmcxXzI1NiA9IEFiO1xudmFyIGRuID0gUWUsIERiID0gbW4sIFBiID0gS3IsIGphID0gZG4ucm90bDMyLCBDbiA9IGRuLnN1bTMyLCBPYiA9IGRuLnN1bTMyXzUsIFJiID0gUGIuZnRfMSwgU3UgPSBEYi5CbG9ja0hhc2gsIE5iID0gW1xuICAxNTE4NTAwMjQ5LFxuICAxODU5Nzc1MzkzLFxuICAyNDAwOTU5NzA4LFxuICAzMzk1NDY5NzgyXG5dO1xuZnVuY3Rpb24genIoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiB6cikpXG4gICAgcmV0dXJuIG5ldyB6cigpO1xuICBTdS5jYWxsKHRoaXMpLCB0aGlzLmggPSBbXG4gICAgMTczMjU4NDE5MyxcbiAgICA0MDIzMjMzNDE3LFxuICAgIDI1NjIzODMxMDIsXG4gICAgMjcxNzMzODc4LFxuICAgIDMyODUzNzc1MjBcbiAgXSwgdGhpcy5XID0gbmV3IEFycmF5KDgwKTtcbn1cbmRuLmluaGVyaXRzKHpyLCBTdSk7XG52YXIgVGIgPSB6cjtcbnpyLmJsb2NrU2l6ZSA9IDUxMjtcbnpyLm91dFNpemUgPSAxNjA7XG56ci5obWFjU3RyZW5ndGggPSA4MDtcbnpyLnBhZExlbmd0aCA9IDY0O1xuenIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbihlLCB0KSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLlcsIG4gPSAwOyBuIDwgMTY7IG4rKylcbiAgICBpW25dID0gZVt0ICsgbl07XG4gIGZvciAoOyBuIDwgaS5sZW5ndGg7IG4rKylcbiAgICBpW25dID0gamEoaVtuIC0gM10gXiBpW24gLSA4XSBeIGlbbiAtIDE0XSBeIGlbbiAtIDE2XSwgMSk7XG4gIHZhciBzID0gdGhpcy5oWzBdLCBvID0gdGhpcy5oWzFdLCBmID0gdGhpcy5oWzJdLCBoID0gdGhpcy5oWzNdLCBkID0gdGhpcy5oWzRdO1xuICBmb3IgKG4gPSAwOyBuIDwgaS5sZW5ndGg7IG4rKykge1xuICAgIHZhciB2ID0gfn4obiAvIDIwKSwgdyA9IE9iKGphKHMsIDUpLCBSYih2LCBvLCBmLCBoKSwgZCwgaVtuXSwgTmJbdl0pO1xuICAgIGQgPSBoLCBoID0gZiwgZiA9IGphKG8sIDMwKSwgbyA9IHMsIHMgPSB3O1xuICB9XG4gIHRoaXMuaFswXSA9IENuKHRoaXMuaFswXSwgcyksIHRoaXMuaFsxXSA9IENuKHRoaXMuaFsxXSwgbyksIHRoaXMuaFsyXSA9IENuKHRoaXMuaFsyXSwgZiksIHRoaXMuaFszXSA9IENuKHRoaXMuaFszXSwgaCksIHRoaXMuaFs0XSA9IENuKHRoaXMuaFs0XSwgZCk7XG59O1xuenIucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlID09PSBcImhleFwiID8gZG4udG9IZXgzMih0aGlzLmgsIFwiYmlnXCIpIDogZG4uc3BsaXQzMih0aGlzLmgsIFwiYmlnXCIpO1xufTtcbnZhciBsbiA9IFFlLCBDYiA9IG1uLCBfbiA9IEtyLCAkYiA9IFlpLCB3ciA9IGxuLnN1bTMyLCBMYiA9IGxuLnN1bTMyXzQsIEZiID0gbG4uc3VtMzJfNSwgcWIgPSBfbi5jaDMyLCBVYiA9IF9uLm1hajMyLCB6YiA9IF9uLnMwXzI1NiwgQmIgPSBfbi5zMV8yNTYsIGtiID0gX24uZzBfMjU2LCBqYiA9IF9uLmcxXzI1NiwgTXUgPSBDYi5CbG9ja0hhc2gsIEtiID0gW1xuICAxMTE2MzUyNDA4LFxuICAxODk5NDQ3NDQxLFxuICAzMDQ5MzIzNDcxLFxuICAzOTIxMDA5NTczLFxuICA5NjE5ODcxNjMsXG4gIDE1MDg5NzA5OTMsXG4gIDI0NTM2MzU3NDgsXG4gIDI4NzA3NjMyMjEsXG4gIDM2MjQzODEwODAsXG4gIDMxMDU5ODQwMSxcbiAgNjA3MjI1Mjc4LFxuICAxNDI2ODgxOTg3LFxuICAxOTI1MDc4Mzg4LFxuICAyMTYyMDc4MjA2LFxuICAyNjE0ODg4MTAzLFxuICAzMjQ4MjIyNTgwLFxuICAzODM1MzkwNDAxLFxuICA0MDIyMjI0Nzc0LFxuICAyNjQzNDcwNzgsXG4gIDYwNDgwNzYyOCxcbiAgNzcwMjU1OTgzLFxuICAxMjQ5MTUwMTIyLFxuICAxNTU1MDgxNjkyLFxuICAxOTk2MDY0OTg2LFxuICAyNTU0MjIwODgyLFxuICAyODIxODM0MzQ5LFxuICAyOTUyOTk2ODA4LFxuICAzMjEwMzEzNjcxLFxuICAzMzM2NTcxODkxLFxuICAzNTg0NTI4NzExLFxuICAxMTM5MjY5OTMsXG4gIDMzODI0MTg5NSxcbiAgNjY2MzA3MjA1LFxuICA3NzM1Mjk5MTIsXG4gIDEyOTQ3NTczNzIsXG4gIDEzOTYxODIyOTEsXG4gIDE2OTUxODM3MDAsXG4gIDE5ODY2NjEwNTEsXG4gIDIxNzcwMjYzNTAsXG4gIDI0NTY5NTYwMzcsXG4gIDI3MzA0ODU5MjEsXG4gIDI4MjAzMDI0MTEsXG4gIDMyNTk3MzA4MDAsXG4gIDMzNDU3NjQ3NzEsXG4gIDM1MTYwNjU4MTcsXG4gIDM2MDAzNTI4MDQsXG4gIDQwOTQ1NzE5MDksXG4gIDI3NTQyMzM0NCxcbiAgNDMwMjI3NzM0LFxuICA1MDY5NDg2MTYsXG4gIDY1OTA2MDU1NixcbiAgODgzOTk3ODc3LFxuICA5NTgxMzk1NzEsXG4gIDEzMjI4MjIyMTgsXG4gIDE1MzcwMDIwNjMsXG4gIDE3NDc4NzM3NzksXG4gIDE5NTU1NjIyMjIsXG4gIDIwMjQxMDQ4MTUsXG4gIDIyMjc3MzA0NTIsXG4gIDIzNjE4NTI0MjQsXG4gIDI0Mjg0MzY0NzQsXG4gIDI3NTY3MzQxODcsXG4gIDMyMDQwMzE0NzksXG4gIDMzMjkzMjUyOThcbl07XG5mdW5jdGlvbiBCcigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJyKSlcbiAgICByZXR1cm4gbmV3IEJyKCk7XG4gIE11LmNhbGwodGhpcyksIHRoaXMuaCA9IFtcbiAgICAxNzc5MDMzNzAzLFxuICAgIDMxNDQxMzQyNzcsXG4gICAgMTAxMzkwNDI0MixcbiAgICAyNzczNDgwNzYyLFxuICAgIDEzNTk4OTMxMTksXG4gICAgMjYwMDgyMjkyNCxcbiAgICA1Mjg3MzQ2MzUsXG4gICAgMTU0MTQ1OTIyNVxuICBdLCB0aGlzLmsgPSBLYiwgdGhpcy5XID0gbmV3IEFycmF5KDY0KTtcbn1cbmxuLmluaGVyaXRzKEJyLCBNdSk7XG52YXIgSXUgPSBCcjtcbkJyLmJsb2NrU2l6ZSA9IDUxMjtcbkJyLm91dFNpemUgPSAyNTY7XG5Cci5obWFjU3RyZW5ndGggPSAxOTI7XG5Cci5wYWRMZW5ndGggPSA2NDtcbkJyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oZSwgdCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5XLCBuID0gMDsgbiA8IDE2OyBuKyspXG4gICAgaVtuXSA9IGVbdCArIG5dO1xuICBmb3IgKDsgbiA8IGkubGVuZ3RoOyBuKyspXG4gICAgaVtuXSA9IExiKGpiKGlbbiAtIDJdKSwgaVtuIC0gN10sIGtiKGlbbiAtIDE1XSksIGlbbiAtIDE2XSk7XG4gIHZhciBzID0gdGhpcy5oWzBdLCBvID0gdGhpcy5oWzFdLCBmID0gdGhpcy5oWzJdLCBoID0gdGhpcy5oWzNdLCBkID0gdGhpcy5oWzRdLCB2ID0gdGhpcy5oWzVdLCB3ID0gdGhpcy5oWzZdLCBBID0gdGhpcy5oWzddO1xuICBmb3IgKCRiKHRoaXMuay5sZW5ndGggPT09IGkubGVuZ3RoKSwgbiA9IDA7IG4gPCBpLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIEkgPSBGYihBLCBCYihkKSwgcWIoZCwgdiwgdyksIHRoaXMua1tuXSwgaVtuXSksIEQgPSB3cih6YihzKSwgVWIocywgbywgZikpO1xuICAgIEEgPSB3LCB3ID0gdiwgdiA9IGQsIGQgPSB3cihoLCBJKSwgaCA9IGYsIGYgPSBvLCBvID0gcywgcyA9IHdyKEksIEQpO1xuICB9XG4gIHRoaXMuaFswXSA9IHdyKHRoaXMuaFswXSwgcyksIHRoaXMuaFsxXSA9IHdyKHRoaXMuaFsxXSwgbyksIHRoaXMuaFsyXSA9IHdyKHRoaXMuaFsyXSwgZiksIHRoaXMuaFszXSA9IHdyKHRoaXMuaFszXSwgaCksIHRoaXMuaFs0XSA9IHdyKHRoaXMuaFs0XSwgZCksIHRoaXMuaFs1XSA9IHdyKHRoaXMuaFs1XSwgdiksIHRoaXMuaFs2XSA9IHdyKHRoaXMuaFs2XSwgdyksIHRoaXMuaFs3XSA9IHdyKHRoaXMuaFs3XSwgQSk7XG59O1xuQnIucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlID09PSBcImhleFwiID8gbG4udG9IZXgzMih0aGlzLmgsIFwiYmlnXCIpIDogbG4uc3BsaXQzMih0aGlzLmgsIFwiYmlnXCIpO1xufTtcbnZhciB3byA9IFFlLCBBdSA9IEl1O1xuZnVuY3Rpb24gdWkoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiB1aSkpXG4gICAgcmV0dXJuIG5ldyB1aSgpO1xuICBBdS5jYWxsKHRoaXMpLCB0aGlzLmggPSBbXG4gICAgMzIzODM3MTAzMixcbiAgICA5MTQxNTA2NjMsXG4gICAgODEyNzAyOTk5LFxuICAgIDQxNDQ5MTI2OTcsXG4gICAgNDI5MDc3NTg1NyxcbiAgICAxNzUwNjAzMDI1LFxuICAgIDE2OTQwNzY4MzksXG4gICAgMzIwNDA3NTQyOFxuICBdO1xufVxud28uaW5oZXJpdHModWksIEF1KTtcbnZhciBIYiA9IHVpO1xudWkuYmxvY2tTaXplID0gNTEyO1xudWkub3V0U2l6ZSA9IDIyNDtcbnVpLmhtYWNTdHJlbmd0aCA9IDE5MjtcbnVpLnBhZExlbmd0aCA9IDY0O1xudWkucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlID09PSBcImhleFwiID8gd28udG9IZXgzMih0aGlzLmguc2xpY2UoMCwgNyksIFwiYmlnXCIpIDogd28uc3BsaXQzMih0aGlzLmguc2xpY2UoMCwgNyksIFwiYmlnXCIpO1xufTtcbnZhciBZdCA9IFFlLCBWYiA9IG1uLCBXYiA9IFlpLCBxciA9IFl0LnJvdHI2NF9oaSwgVXIgPSBZdC5yb3RyNjRfbG8sIER1ID0gWXQuc2hyNjRfaGksIFB1ID0gWXQuc2hyNjRfbG8sIGJpID0gWXQuc3VtNjQsIEthID0gWXQuc3VtNjRfaGksIEhhID0gWXQuc3VtNjRfbG8sIEdiID0gWXQuc3VtNjRfNF9oaSwgSmIgPSBZdC5zdW02NF80X2xvLCBZYiA9IFl0LnN1bTY0XzVfaGksIFhiID0gWXQuc3VtNjRfNV9sbywgT3UgPSBWYi5CbG9ja0hhc2gsIFpiID0gW1xuICAxMTE2MzUyNDA4LFxuICAzNjA5NzY3NDU4LFxuICAxODk5NDQ3NDQxLFxuICA2MDI4OTE3MjUsXG4gIDMwNDkzMjM0NzEsXG4gIDM5NjQ0ODQzOTksXG4gIDM5MjEwMDk1NzMsXG4gIDIxNzMyOTU1NDgsXG4gIDk2MTk4NzE2MyxcbiAgNDA4MTYyODQ3MixcbiAgMTUwODk3MDk5MyxcbiAgMzA1MzgzNDI2NSxcbiAgMjQ1MzYzNTc0OCxcbiAgMjkzNzY3MTU3OSxcbiAgMjg3MDc2MzIyMSxcbiAgMzY2NDYwOTU2MCxcbiAgMzYyNDM4MTA4MCxcbiAgMjczNDg4MzM5NCxcbiAgMzEwNTk4NDAxLFxuICAxMTY0OTk2NTQyLFxuICA2MDcyMjUyNzgsXG4gIDEzMjM2MTA3NjQsXG4gIDE0MjY4ODE5ODcsXG4gIDM1OTAzMDQ5OTQsXG4gIDE5MjUwNzgzODgsXG4gIDQwNjgxODIzODMsXG4gIDIxNjIwNzgyMDYsXG4gIDk5MTMzNjExMyxcbiAgMjYxNDg4ODEwMyxcbiAgNjMzODAzMzE3LFxuICAzMjQ4MjIyNTgwLFxuICAzNDc5Nzc0ODY4LFxuICAzODM1MzkwNDAxLFxuICAyNjY2NjEzNDU4LFxuICA0MDIyMjI0Nzc0LFxuICA5NDQ3MTExMzksXG4gIDI2NDM0NzA3OCxcbiAgMjM0MTI2Mjc3MyxcbiAgNjA0ODA3NjI4LFxuICAyMDA3ODAwOTMzLFxuICA3NzAyNTU5ODMsXG4gIDE0OTU5OTA5MDEsXG4gIDEyNDkxNTAxMjIsXG4gIDE4NTY0MzEyMzUsXG4gIDE1NTUwODE2OTIsXG4gIDMxNzUyMTgxMzIsXG4gIDE5OTYwNjQ5ODYsXG4gIDIxOTg5NTA4MzcsXG4gIDI1NTQyMjA4ODIsXG4gIDM5OTk3MTkzMzksXG4gIDI4MjE4MzQzNDksXG4gIDc2Njc4NDAxNixcbiAgMjk1Mjk5NjgwOCxcbiAgMjU2NjU5NDg3OSxcbiAgMzIxMDMxMzY3MSxcbiAgMzIwMzMzNzk1NixcbiAgMzMzNjU3MTg5MSxcbiAgMTAzNDQ1NzAyNixcbiAgMzU4NDUyODcxMSxcbiAgMjQ2Njk0ODkwMSxcbiAgMTEzOTI2OTkzLFxuICAzNzU4MzI2MzgzLFxuICAzMzgyNDE4OTUsXG4gIDE2ODcxNzkzNixcbiAgNjY2MzA3MjA1LFxuICAxMTg4MTc5OTY0LFxuICA3NzM1Mjk5MTIsXG4gIDE1NDYwNDU3MzQsXG4gIDEyOTQ3NTczNzIsXG4gIDE1MjI4MDU0ODUsXG4gIDEzOTYxODIyOTEsXG4gIDI2NDM4MzM4MjMsXG4gIDE2OTUxODM3MDAsXG4gIDIzNDM1MjczOTAsXG4gIDE5ODY2NjEwNTEsXG4gIDEwMTQ0Nzc0ODAsXG4gIDIxNzcwMjYzNTAsXG4gIDEyMDY3NTkxNDIsXG4gIDI0NTY5NTYwMzcsXG4gIDM0NDA3NzYyNyxcbiAgMjczMDQ4NTkyMSxcbiAgMTI5MDg2MzQ2MCxcbiAgMjgyMDMwMjQxMSxcbiAgMzE1ODQ1NDI3MyxcbiAgMzI1OTczMDgwMCxcbiAgMzUwNTk1MjY1NyxcbiAgMzM0NTc2NDc3MSxcbiAgMTA2MjE3MDA4LFxuICAzNTE2MDY1ODE3LFxuICAzNjA2MDA4MzQ0LFxuICAzNjAwMzUyODA0LFxuICAxNDMyNzI1Nzc2LFxuICA0MDk0NTcxOTA5LFxuICAxNDY3MDMxNTk0LFxuICAyNzU0MjMzNDQsXG4gIDg1MTE2OTcyMCxcbiAgNDMwMjI3NzM0LFxuICAzMTAwODIzNzUyLFxuICA1MDY5NDg2MTYsXG4gIDEzNjMyNTgxOTUsXG4gIDY1OTA2MDU1NixcbiAgMzc1MDY4NTU5MyxcbiAgODgzOTk3ODc3LFxuICAzNzg1MDUwMjgwLFxuICA5NTgxMzk1NzEsXG4gIDMzMTgzMDc0MjcsXG4gIDEzMjI4MjIyMTgsXG4gIDM4MTI3MjM0MDMsXG4gIDE1MzcwMDIwNjMsXG4gIDIwMDMwMzQ5OTUsXG4gIDE3NDc4NzM3NzksXG4gIDM2MDIwMzY4OTksXG4gIDE5NTU1NjIyMjIsXG4gIDE1NzU5OTAwMTIsXG4gIDIwMjQxMDQ4MTUsXG4gIDExMjU1OTI5MjgsXG4gIDIyMjc3MzA0NTIsXG4gIDI3MTY5MDQzMDYsXG4gIDIzNjE4NTI0MjQsXG4gIDQ0Mjc3NjA0NCxcbiAgMjQyODQzNjQ3NCxcbiAgNTkzNjk4MzQ0LFxuICAyNzU2NzM0MTg3LFxuICAzNzMzMTEwMjQ5LFxuICAzMjA0MDMxNDc5LFxuICAyOTk5MzUxNTczLFxuICAzMzI5MzI1Mjk4LFxuICAzODE1OTIwNDI3LFxuICAzMzkxNTY5NjE0LFxuICAzOTI4MzgzOTAwLFxuICAzNTE1MjY3MjcxLFxuICA1NjYyODA3MTEsXG4gIDM5NDAxODc2MDYsXG4gIDM0NTQwNjk1MzQsXG4gIDQxMTg2MzAyNzEsXG4gIDQwMDAyMzk5OTIsXG4gIDExNjQxODQ3NCxcbiAgMTkxNDEzODU1NCxcbiAgMTc0MjkyNDIxLFxuICAyNzMxMDU1MjcwLFxuICAyODkzODAzNTYsXG4gIDMyMDM5OTMwMDYsXG4gIDQ2MDM5MzI2OSxcbiAgMzIwNjIwMzE1LFxuICA2ODU0NzE3MzMsXG4gIDU4NzQ5NjgzNixcbiAgODUyMTQyOTcxLFxuICAxMDg2NzkyODUxLFxuICAxMDE3MDM2Mjk4LFxuICAzNjU1NDMxMDAsXG4gIDExMjYwMDA1ODAsXG4gIDI2MTgyOTc2NzYsXG4gIDEyODgwMzM0NzAsXG4gIDM0MDk4NTUxNTgsXG4gIDE1MDE1MDU5NDgsXG4gIDQyMzQ1MDk4NjYsXG4gIDE2MDcxNjc5MTUsXG4gIDk4NzE2NzQ2OCxcbiAgMTgxNjQwMjMxNixcbiAgMTI0NjE4OTU5MVxuXTtcbmZ1bmN0aW9uIEFyKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQXIpKVxuICAgIHJldHVybiBuZXcgQXIoKTtcbiAgT3UuY2FsbCh0aGlzKSwgdGhpcy5oID0gW1xuICAgIDE3NzkwMzM3MDMsXG4gICAgNDA4OTIzNTcyMCxcbiAgICAzMTQ0MTM0Mjc3LFxuICAgIDIyMjc4NzM1OTUsXG4gICAgMTAxMzkwNDI0MixcbiAgICA0MjcxMTc1NzIzLFxuICAgIDI3NzM0ODA3NjIsXG4gICAgMTU5NTc1MDEyOSxcbiAgICAxMzU5ODkzMTE5LFxuICAgIDI5MTc1NjUxMzcsXG4gICAgMjYwMDgyMjkyNCxcbiAgICA3MjU1MTExOTksXG4gICAgNTI4NzM0NjM1LFxuICAgIDQyMTUzODk1NDcsXG4gICAgMTU0MTQ1OTIyNSxcbiAgICAzMjcwMzMyMDlcbiAgXSwgdGhpcy5rID0gWmIsIHRoaXMuVyA9IG5ldyBBcnJheSgxNjApO1xufVxuWXQuaW5oZXJpdHMoQXIsIE91KTtcbnZhciBSdSA9IEFyO1xuQXIuYmxvY2tTaXplID0gMTAyNDtcbkFyLm91dFNpemUgPSA1MTI7XG5Bci5obWFjU3RyZW5ndGggPSAxOTI7XG5Bci5wYWRMZW5ndGggPSAxMjg7XG5Bci5wcm90b3R5cGUuX3ByZXBhcmVCbG9jayA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuVywgbiA9IDA7IG4gPCAzMjsgbisrKVxuICAgIGlbbl0gPSBlW3QgKyBuXTtcbiAgZm9yICg7IG4gPCBpLmxlbmd0aDsgbiArPSAyKSB7XG4gICAgdmFyIHMgPSBjZyhpW24gLSA0XSwgaVtuIC0gM10pLCBvID0gaGcoaVtuIC0gNF0sIGlbbiAtIDNdKSwgZiA9IGlbbiAtIDE0XSwgaCA9IGlbbiAtIDEzXSwgZCA9IG9nKGlbbiAtIDMwXSwgaVtuIC0gMjldKSwgdiA9IGZnKGlbbiAtIDMwXSwgaVtuIC0gMjldKSwgdyA9IGlbbiAtIDMyXSwgQSA9IGlbbiAtIDMxXTtcbiAgICBpW25dID0gR2IoXG4gICAgICBzLFxuICAgICAgbyxcbiAgICAgIGYsXG4gICAgICBoLFxuICAgICAgZCxcbiAgICAgIHYsXG4gICAgICB3LFxuICAgICAgQVxuICAgICksIGlbbiArIDFdID0gSmIoXG4gICAgICBzLFxuICAgICAgbyxcbiAgICAgIGYsXG4gICAgICBoLFxuICAgICAgZCxcbiAgICAgIHYsXG4gICAgICB3LFxuICAgICAgQVxuICAgICk7XG4gIH1cbn07XG5Bci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgdGhpcy5fcHJlcGFyZUJsb2NrKGUsIHQpO1xuICB2YXIgaSA9IHRoaXMuVywgbiA9IHRoaXMuaFswXSwgcyA9IHRoaXMuaFsxXSwgbyA9IHRoaXMuaFsyXSwgZiA9IHRoaXMuaFszXSwgaCA9IHRoaXMuaFs0XSwgZCA9IHRoaXMuaFs1XSwgdiA9IHRoaXMuaFs2XSwgdyA9IHRoaXMuaFs3XSwgQSA9IHRoaXMuaFs4XSwgSSA9IHRoaXMuaFs5XSwgRCA9IHRoaXMuaFsxMF0sIE4gPSB0aGlzLmhbMTFdLCBrID0gdGhpcy5oWzEyXSwgaiA9IHRoaXMuaFsxM10sIFQgPSB0aGlzLmhbMTRdLCBLID0gdGhpcy5oWzE1XTtcbiAgV2IodGhpcy5rLmxlbmd0aCA9PT0gaS5sZW5ndGgpO1xuICBmb3IgKHZhciAkID0gMDsgJCA8IGkubGVuZ3RoOyAkICs9IDIpIHtcbiAgICB2YXIgeiA9IFQsIEIgPSBLLCBfID0gc2coQSwgSSksIFIgPSBhZyhBLCBJKSwgSiA9IFFiKEEsIEksIEQsIE4sIGspLCBRID0gZWcoQSwgSSwgRCwgTiwgaywgaiksIE8gPSB0aGlzLmtbJF0sIHAgPSB0aGlzLmtbJCArIDFdLCBsID0gaVskXSwgYSA9IGlbJCArIDFdLCBjID0gWWIoXG4gICAgICB6LFxuICAgICAgQixcbiAgICAgIF8sXG4gICAgICBSLFxuICAgICAgSixcbiAgICAgIFEsXG4gICAgICBPLFxuICAgICAgcCxcbiAgICAgIGwsXG4gICAgICBhXG4gICAgKSwgYiA9IFhiKFxuICAgICAgeixcbiAgICAgIEIsXG4gICAgICBfLFxuICAgICAgUixcbiAgICAgIEosXG4gICAgICBRLFxuICAgICAgTyxcbiAgICAgIHAsXG4gICAgICBsLFxuICAgICAgYVxuICAgICk7XG4gICAgeiA9IGlnKG4sIHMpLCBCID0gbmcobiwgcyksIF8gPSB0ZyhuLCBzLCBvLCBmLCBoKSwgUiA9IHJnKG4sIHMsIG8sIGYsIGgsIGQpO1xuICAgIHZhciBFID0gS2EoeiwgQiwgXywgUiksIFMgPSBIYSh6LCBCLCBfLCBSKTtcbiAgICBUID0gaywgSyA9IGosIGsgPSBELCBqID0gTiwgRCA9IEEsIE4gPSBJLCBBID0gS2EodiwgdywgYywgYiksIEkgPSBIYSh3LCB3LCBjLCBiKSwgdiA9IGgsIHcgPSBkLCBoID0gbywgZCA9IGYsIG8gPSBuLCBmID0gcywgbiA9IEthKGMsIGIsIEUsIFMpLCBzID0gSGEoYywgYiwgRSwgUyk7XG4gIH1cbiAgYmkodGhpcy5oLCAwLCBuLCBzKSwgYmkodGhpcy5oLCAyLCBvLCBmKSwgYmkodGhpcy5oLCA0LCBoLCBkKSwgYmkodGhpcy5oLCA2LCB2LCB3KSwgYmkodGhpcy5oLCA4LCBBLCBJKSwgYmkodGhpcy5oLCAxMCwgRCwgTiksIGJpKHRoaXMuaCwgMTIsIGssIGopLCBiaSh0aGlzLmgsIDE0LCBULCBLKTtcbn07XG5Bci5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUgPT09IFwiaGV4XCIgPyBZdC50b0hleDMyKHRoaXMuaCwgXCJiaWdcIikgOiBZdC5zcGxpdDMyKHRoaXMuaCwgXCJiaWdcIik7XG59O1xuZnVuY3Rpb24gUWIociwgZSwgdCwgaSwgbikge1xuICB2YXIgcyA9IHIgJiB0IF4gfnIgJiBuO1xuICByZXR1cm4gcyA8IDAgJiYgKHMgKz0gNDI5NDk2NzI5NiksIHM7XG59XG5mdW5jdGlvbiBlZyhyLCBlLCB0LCBpLCBuLCBzKSB7XG4gIHZhciBvID0gZSAmIGkgXiB+ZSAmIHM7XG4gIHJldHVybiBvIDwgMCAmJiAobyArPSA0Mjk0OTY3Mjk2KSwgbztcbn1cbmZ1bmN0aW9uIHRnKHIsIGUsIHQsIGksIG4pIHtcbiAgdmFyIHMgPSByICYgdCBeIHIgJiBuIF4gdCAmIG47XG4gIHJldHVybiBzIDwgMCAmJiAocyArPSA0Mjk0OTY3Mjk2KSwgcztcbn1cbmZ1bmN0aW9uIHJnKHIsIGUsIHQsIGksIG4sIHMpIHtcbiAgdmFyIG8gPSBlICYgaSBeIGUgJiBzIF4gaSAmIHM7XG4gIHJldHVybiBvIDwgMCAmJiAobyArPSA0Mjk0OTY3Mjk2KSwgbztcbn1cbmZ1bmN0aW9uIGlnKHIsIGUpIHtcbiAgdmFyIHQgPSBxcihyLCBlLCAyOCksIGkgPSBxcihlLCByLCAyKSwgbiA9IHFyKGUsIHIsIDcpLCBzID0gdCBeIGkgXiBuO1xuICByZXR1cm4gcyA8IDAgJiYgKHMgKz0gNDI5NDk2NzI5NiksIHM7XG59XG5mdW5jdGlvbiBuZyhyLCBlKSB7XG4gIHZhciB0ID0gVXIociwgZSwgMjgpLCBpID0gVXIoZSwgciwgMiksIG4gPSBVcihlLCByLCA3KSwgcyA9IHQgXiBpIF4gbjtcbiAgcmV0dXJuIHMgPCAwICYmIChzICs9IDQyOTQ5NjcyOTYpLCBzO1xufVxuZnVuY3Rpb24gc2cociwgZSkge1xuICB2YXIgdCA9IHFyKHIsIGUsIDE0KSwgaSA9IHFyKHIsIGUsIDE4KSwgbiA9IHFyKGUsIHIsIDkpLCBzID0gdCBeIGkgXiBuO1xuICByZXR1cm4gcyA8IDAgJiYgKHMgKz0gNDI5NDk2NzI5NiksIHM7XG59XG5mdW5jdGlvbiBhZyhyLCBlKSB7XG4gIHZhciB0ID0gVXIociwgZSwgMTQpLCBpID0gVXIociwgZSwgMTgpLCBuID0gVXIoZSwgciwgOSksIHMgPSB0IF4gaSBeIG47XG4gIHJldHVybiBzIDwgMCAmJiAocyArPSA0Mjk0OTY3Mjk2KSwgcztcbn1cbmZ1bmN0aW9uIG9nKHIsIGUpIHtcbiAgdmFyIHQgPSBxcihyLCBlLCAxKSwgaSA9IHFyKHIsIGUsIDgpLCBuID0gRHUociwgZSwgNyksIHMgPSB0IF4gaSBeIG47XG4gIHJldHVybiBzIDwgMCAmJiAocyArPSA0Mjk0OTY3Mjk2KSwgcztcbn1cbmZ1bmN0aW9uIGZnKHIsIGUpIHtcbiAgdmFyIHQgPSBVcihyLCBlLCAxKSwgaSA9IFVyKHIsIGUsIDgpLCBuID0gUHUociwgZSwgNyksIHMgPSB0IF4gaSBeIG47XG4gIHJldHVybiBzIDwgMCAmJiAocyArPSA0Mjk0OTY3Mjk2KSwgcztcbn1cbmZ1bmN0aW9uIGNnKHIsIGUpIHtcbiAgdmFyIHQgPSBxcihyLCBlLCAxOSksIGkgPSBxcihlLCByLCAyOSksIG4gPSBEdShyLCBlLCA2KSwgcyA9IHQgXiBpIF4gbjtcbiAgcmV0dXJuIHMgPCAwICYmIChzICs9IDQyOTQ5NjcyOTYpLCBzO1xufVxuZnVuY3Rpb24gaGcociwgZSkge1xuICB2YXIgdCA9IFVyKHIsIGUsIDE5KSwgaSA9IFVyKGUsIHIsIDI5KSwgbiA9IFB1KHIsIGUsIDYpLCBzID0gdCBeIGkgXiBuO1xuICByZXR1cm4gcyA8IDAgJiYgKHMgKz0gNDI5NDk2NzI5NiksIHM7XG59XG52YXIgX28gPSBRZSwgTnUgPSBSdTtcbmZ1bmN0aW9uIGRpKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgZGkpKVxuICAgIHJldHVybiBuZXcgZGkoKTtcbiAgTnUuY2FsbCh0aGlzKSwgdGhpcy5oID0gW1xuICAgIDM0MTgwNzAzNjUsXG4gICAgMzIzODM3MTAzMixcbiAgICAxNjU0MjcwMjUwLFxuICAgIDkxNDE1MDY2MyxcbiAgICAyNDM4NTI5MzcwLFxuICAgIDgxMjcwMjk5OSxcbiAgICAzNTU0NjIzNjAsXG4gICAgNDE0NDkxMjY5NyxcbiAgICAxNzMxNDA1NDE1LFxuICAgIDQyOTA3NzU4NTcsXG4gICAgMjM5NDE4MDIzMSxcbiAgICAxNzUwNjAzMDI1LFxuICAgIDM2NzUwMDg1MjUsXG4gICAgMTY5NDA3NjgzOSxcbiAgICAxMjAzMDYyODEzLFxuICAgIDMyMDQwNzU0MjhcbiAgXTtcbn1cbl9vLmluaGVyaXRzKGRpLCBOdSk7XG52YXIgdWcgPSBkaTtcbmRpLmJsb2NrU2l6ZSA9IDEwMjQ7XG5kaS5vdXRTaXplID0gMzg0O1xuZGkuaG1hY1N0cmVuZ3RoID0gMTkyO1xuZGkucGFkTGVuZ3RoID0gMTI4O1xuZGkucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlID09PSBcImhleFwiID8gX28udG9IZXgzMih0aGlzLmguc2xpY2UoMCwgMTIpLCBcImJpZ1wiKSA6IF9vLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgXCJiaWdcIik7XG59O1xud24uc2hhMSA9IFRiO1xud24uc2hhMjI0ID0gSGI7XG53bi5zaGEyNTYgPSBJdTtcbnduLnNoYTM4NCA9IHVnO1xud24uc2hhNTEyID0gUnU7XG52YXIgVHUgPSB7fSwgS2kgPSBRZSwgZGcgPSBtbiwgeHMgPSBLaS5yb3RsMzIsIGhjID0gS2kuc3VtMzIsICRuID0gS2kuc3VtMzJfMywgdWMgPSBLaS5zdW0zMl80LCBDdSA9IGRnLkJsb2NrSGFzaDtcbmZ1bmN0aW9uIGtyKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2Yga3IpKVxuICAgIHJldHVybiBuZXcga3IoKTtcbiAgQ3UuY2FsbCh0aGlzKSwgdGhpcy5oID0gWzE3MzI1ODQxOTMsIDQwMjMyMzM0MTcsIDI1NjIzODMxMDIsIDI3MTczMzg3OCwgMzI4NTM3NzUyMF0sIHRoaXMuZW5kaWFuID0gXCJsaXR0bGVcIjtcbn1cbktpLmluaGVyaXRzKGtyLCBDdSk7XG5UdS5yaXBlbWQxNjAgPSBrcjtcbmtyLmJsb2NrU2l6ZSA9IDUxMjtcbmtyLm91dFNpemUgPSAxNjA7XG5rci5obWFjU3RyZW5ndGggPSAxOTI7XG5rci5wYWRMZW5ndGggPSA2NDtcbmtyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oZSwgdCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5oWzBdLCBuID0gdGhpcy5oWzFdLCBzID0gdGhpcy5oWzJdLCBvID0gdGhpcy5oWzNdLCBmID0gdGhpcy5oWzRdLCBoID0gaSwgZCA9IG4sIHYgPSBzLCB3ID0gbywgQSA9IGYsIEkgPSAwOyBJIDwgODA7IEkrKykge1xuICAgIHZhciBEID0gaGMoXG4gICAgICB4cyhcbiAgICAgICAgdWMoaSwgZGMoSSwgbiwgcywgbyksIGVbdmdbSV0gKyB0XSwgbGcoSSkpLFxuICAgICAgICBnZ1tJXVxuICAgICAgKSxcbiAgICAgIGZcbiAgICApO1xuICAgIGkgPSBmLCBmID0gbywgbyA9IHhzKHMsIDEwKSwgcyA9IG4sIG4gPSBELCBEID0gaGMoXG4gICAgICB4cyhcbiAgICAgICAgdWMoaCwgZGMoNzkgLSBJLCBkLCB2LCB3KSwgZVtiZ1tJXSArIHRdLCBwZyhJKSksXG4gICAgICAgIHlnW0ldXG4gICAgICApLFxuICAgICAgQVxuICAgICksIGggPSBBLCBBID0gdywgdyA9IHhzKHYsIDEwKSwgdiA9IGQsIGQgPSBEO1xuICB9XG4gIEQgPSAkbih0aGlzLmhbMV0sIHMsIHcpLCB0aGlzLmhbMV0gPSAkbih0aGlzLmhbMl0sIG8sIEEpLCB0aGlzLmhbMl0gPSAkbih0aGlzLmhbM10sIGYsIGgpLCB0aGlzLmhbM10gPSAkbih0aGlzLmhbNF0sIGksIGQpLCB0aGlzLmhbNF0gPSAkbih0aGlzLmhbMF0sIG4sIHYpLCB0aGlzLmhbMF0gPSBEO1xufTtcbmtyLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZSA9PT0gXCJoZXhcIiA/IEtpLnRvSGV4MzIodGhpcy5oLCBcImxpdHRsZVwiKSA6IEtpLnNwbGl0MzIodGhpcy5oLCBcImxpdHRsZVwiKTtcbn07XG5mdW5jdGlvbiBkYyhyLCBlLCB0LCBpKSB7XG4gIHJldHVybiByIDw9IDE1ID8gZSBeIHQgXiBpIDogciA8PSAzMSA/IGUgJiB0IHwgfmUgJiBpIDogciA8PSA0NyA/IChlIHwgfnQpIF4gaSA6IHIgPD0gNjMgPyBlICYgaSB8IHQgJiB+aSA6IGUgXiAodCB8IH5pKTtcbn1cbmZ1bmN0aW9uIGxnKHIpIHtcbiAgcmV0dXJuIHIgPD0gMTUgPyAwIDogciA8PSAzMSA/IDE1MTg1MDAyNDkgOiByIDw9IDQ3ID8gMTg1OTc3NTM5MyA6IHIgPD0gNjMgPyAyNDAwOTU5NzA4IDogMjg0MDg1MzgzODtcbn1cbmZ1bmN0aW9uIHBnKHIpIHtcbiAgcmV0dXJuIHIgPD0gMTUgPyAxMzUyODI5OTI2IDogciA8PSAzMSA/IDE1NDg2MDM2ODQgOiByIDw9IDQ3ID8gMTgzNjA3MjY5MSA6IHIgPD0gNjMgPyAyMDUzOTk0MjE3IDogMDtcbn1cbnZhciB2ZyA9IFtcbiAgMCxcbiAgMSxcbiAgMixcbiAgMyxcbiAgNCxcbiAgNSxcbiAgNixcbiAgNyxcbiAgOCxcbiAgOSxcbiAgMTAsXG4gIDExLFxuICAxMixcbiAgMTMsXG4gIDE0LFxuICAxNSxcbiAgNyxcbiAgNCxcbiAgMTMsXG4gIDEsXG4gIDEwLFxuICA2LFxuICAxNSxcbiAgMyxcbiAgMTIsXG4gIDAsXG4gIDksXG4gIDUsXG4gIDIsXG4gIDE0LFxuICAxMSxcbiAgOCxcbiAgMyxcbiAgMTAsXG4gIDE0LFxuICA0LFxuICA5LFxuICAxNSxcbiAgOCxcbiAgMSxcbiAgMixcbiAgNyxcbiAgMCxcbiAgNixcbiAgMTMsXG4gIDExLFxuICA1LFxuICAxMixcbiAgMSxcbiAgOSxcbiAgMTEsXG4gIDEwLFxuICAwLFxuICA4LFxuICAxMixcbiAgNCxcbiAgMTMsXG4gIDMsXG4gIDcsXG4gIDE1LFxuICAxNCxcbiAgNSxcbiAgNixcbiAgMixcbiAgNCxcbiAgMCxcbiAgNSxcbiAgOSxcbiAgNyxcbiAgMTIsXG4gIDIsXG4gIDEwLFxuICAxNCxcbiAgMSxcbiAgMyxcbiAgOCxcbiAgMTEsXG4gIDYsXG4gIDE1LFxuICAxM1xuXSwgYmcgPSBbXG4gIDUsXG4gIDE0LFxuICA3LFxuICAwLFxuICA5LFxuICAyLFxuICAxMSxcbiAgNCxcbiAgMTMsXG4gIDYsXG4gIDE1LFxuICA4LFxuICAxLFxuICAxMCxcbiAgMyxcbiAgMTIsXG4gIDYsXG4gIDExLFxuICAzLFxuICA3LFxuICAwLFxuICAxMyxcbiAgNSxcbiAgMTAsXG4gIDE0LFxuICAxNSxcbiAgOCxcbiAgMTIsXG4gIDQsXG4gIDksXG4gIDEsXG4gIDIsXG4gIDE1LFxuICA1LFxuICAxLFxuICAzLFxuICA3LFxuICAxNCxcbiAgNixcbiAgOSxcbiAgMTEsXG4gIDgsXG4gIDEyLFxuICAyLFxuICAxMCxcbiAgMCxcbiAgNCxcbiAgMTMsXG4gIDgsXG4gIDYsXG4gIDQsXG4gIDEsXG4gIDMsXG4gIDExLFxuICAxNSxcbiAgMCxcbiAgNSxcbiAgMTIsXG4gIDIsXG4gIDEzLFxuICA5LFxuICA3LFxuICAxMCxcbiAgMTQsXG4gIDEyLFxuICAxNSxcbiAgMTAsXG4gIDQsXG4gIDEsXG4gIDUsXG4gIDgsXG4gIDcsXG4gIDYsXG4gIDIsXG4gIDEzLFxuICAxNCxcbiAgMCxcbiAgMyxcbiAgOSxcbiAgMTFcbl0sIGdnID0gW1xuICAxMSxcbiAgMTQsXG4gIDE1LFxuICAxMixcbiAgNSxcbiAgOCxcbiAgNyxcbiAgOSxcbiAgMTEsXG4gIDEzLFxuICAxNCxcbiAgMTUsXG4gIDYsXG4gIDcsXG4gIDksXG4gIDgsXG4gIDcsXG4gIDYsXG4gIDgsXG4gIDEzLFxuICAxMSxcbiAgOSxcbiAgNyxcbiAgMTUsXG4gIDcsXG4gIDEyLFxuICAxNSxcbiAgOSxcbiAgMTEsXG4gIDcsXG4gIDEzLFxuICAxMixcbiAgMTEsXG4gIDEzLFxuICA2LFxuICA3LFxuICAxNCxcbiAgOSxcbiAgMTMsXG4gIDE1LFxuICAxNCxcbiAgOCxcbiAgMTMsXG4gIDYsXG4gIDUsXG4gIDEyLFxuICA3LFxuICA1LFxuICAxMSxcbiAgMTIsXG4gIDE0LFxuICAxNSxcbiAgMTQsXG4gIDE1LFxuICA5LFxuICA4LFxuICA5LFxuICAxNCxcbiAgNSxcbiAgNixcbiAgOCxcbiAgNixcbiAgNSxcbiAgMTIsXG4gIDksXG4gIDE1LFxuICA1LFxuICAxMSxcbiAgNixcbiAgOCxcbiAgMTMsXG4gIDEyLFxuICA1LFxuICAxMixcbiAgMTMsXG4gIDE0LFxuICAxMSxcbiAgOCxcbiAgNSxcbiAgNlxuXSwgeWcgPSBbXG4gIDgsXG4gIDksXG4gIDksXG4gIDExLFxuICAxMyxcbiAgMTUsXG4gIDE1LFxuICA1LFxuICA3LFxuICA3LFxuICA4LFxuICAxMSxcbiAgMTQsXG4gIDE0LFxuICAxMixcbiAgNixcbiAgOSxcbiAgMTMsXG4gIDE1LFxuICA3LFxuICAxMixcbiAgOCxcbiAgOSxcbiAgMTEsXG4gIDcsXG4gIDcsXG4gIDEyLFxuICA3LFxuICA2LFxuICAxNSxcbiAgMTMsXG4gIDExLFxuICA5LFxuICA3LFxuICAxNSxcbiAgMTEsXG4gIDgsXG4gIDYsXG4gIDYsXG4gIDE0LFxuICAxMixcbiAgMTMsXG4gIDUsXG4gIDE0LFxuICAxMyxcbiAgMTMsXG4gIDcsXG4gIDUsXG4gIDE1LFxuICA1LFxuICA4LFxuICAxMSxcbiAgMTQsXG4gIDE0LFxuICA2LFxuICAxNCxcbiAgNixcbiAgOSxcbiAgMTIsXG4gIDksXG4gIDEyLFxuICA1LFxuICAxNSxcbiAgOCxcbiAgOCxcbiAgNSxcbiAgMTIsXG4gIDksXG4gIDEyLFxuICA1LFxuICAxNCxcbiAgNixcbiAgOCxcbiAgMTMsXG4gIDYsXG4gIDUsXG4gIDE1LFxuICAxMyxcbiAgMTEsXG4gIDExXG5dLCBtZyA9IFFlLCB3ZyA9IFlpO1xuZnVuY3Rpb24gcG4ociwgZSwgdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgcG4pKVxuICAgIHJldHVybiBuZXcgcG4ociwgZSwgdCk7XG4gIHRoaXMuSGFzaCA9IHIsIHRoaXMuYmxvY2tTaXplID0gci5ibG9ja1NpemUgLyA4LCB0aGlzLm91dFNpemUgPSByLm91dFNpemUgLyA4LCB0aGlzLmlubmVyID0gbnVsbCwgdGhpcy5vdXRlciA9IG51bGwsIHRoaXMuX2luaXQobWcudG9BcnJheShlLCB0KSk7XG59XG52YXIgX2cgPSBwbjtcbnBuLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKGUpIHtcbiAgZS5sZW5ndGggPiB0aGlzLmJsb2NrU2l6ZSAmJiAoZSA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoZSkuZGlnZXN0KCkpLCB3ZyhlLmxlbmd0aCA8PSB0aGlzLmJsb2NrU2l6ZSk7XG4gIGZvciAodmFyIHQgPSBlLmxlbmd0aDsgdCA8IHRoaXMuYmxvY2tTaXplOyB0KyspXG4gICAgZS5wdXNoKDApO1xuICBmb3IgKHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQrKylcbiAgICBlW3RdIF49IDU0O1xuICBmb3IgKHRoaXMuaW5uZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGUpLCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspXG4gICAgZVt0XSBePSAxMDY7XG4gIHRoaXMub3V0ZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGUpO1xufTtcbnBuLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiB0aGlzLmlubmVyLnVwZGF0ZShlLCB0KSwgdGhpcztcbn07XG5wbi5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gdGhpcy5vdXRlci51cGRhdGUodGhpcy5pbm5lci5kaWdlc3QoKSksIHRoaXMub3V0ZXIuZGlnZXN0KGUpO1xufTtcbihmdW5jdGlvbihyKSB7XG4gIHZhciBlID0gcjtcbiAgZS51dGlscyA9IFFlLCBlLmNvbW1vbiA9IG1uLCBlLnNoYSA9IHduLCBlLnJpcGVtZCA9IFR1LCBlLmhtYWMgPSBfZywgZS5zaGExID0gZS5zaGEuc2hhMSwgZS5zaGEyNTYgPSBlLnNoYS5zaGEyNTYsIGUuc2hhMjI0ID0gZS5zaGEuc2hhMjI0LCBlLnNoYTM4NCA9IGUuc2hhLnNoYTM4NCwgZS5zaGE1MTIgPSBlLnNoYS5zaGE1MTIsIGUucmlwZW1kMTYwID0gZS5yaXBlbWQucmlwZW1kMTYwO1xufSkobnMpO1xuY29uc3Qgc2kgPSAvKiBAX19QVVJFX18gKi8gYm4obnMpO1xuZnVuY3Rpb24geG4ociwgZSwgdCkge1xuICByZXR1cm4gdCA9IHtcbiAgICBwYXRoOiBlLFxuICAgIGV4cG9ydHM6IHt9LFxuICAgIHJlcXVpcmU6IGZ1bmN0aW9uKGksIG4pIHtcbiAgICAgIHJldHVybiB4ZyhpLCBuID8/IHQucGF0aCk7XG4gICAgfVxuICB9LCByKHQsIHQuZXhwb3J0cyksIHQuZXhwb3J0cztcbn1cbmZ1bmN0aW9uIHhnKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSBAcm9sbHVwL3BsdWdpbi1jb21tb25qc1wiKTtcbn1cbnZhciBCbyA9ICR1O1xuZnVuY3Rpb24gJHUociwgZSkge1xuICBpZiAoIXIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGUgfHwgXCJBc3NlcnRpb24gZmFpbGVkXCIpO1xufVxuJHUuZXF1YWwgPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gIGlmIChlICE9IHQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGkgfHwgXCJBc3NlcnRpb24gZmFpbGVkOiBcIiArIGUgKyBcIiAhPSBcIiArIHQpO1xufTtcbnZhciBNciA9IHhuKGZ1bmN0aW9uKHIsIGUpIHtcbiAgdmFyIHQgPSBlO1xuICBmdW5jdGlvbiBpKG8sIGYpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSlcbiAgICAgIHJldHVybiBvLnNsaWNlKCk7XG4gICAgaWYgKCFvKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIHZhciBoID0gW107XG4gICAgaWYgKHR5cGVvZiBvICE9IFwic3RyaW5nXCIpIHtcbiAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgby5sZW5ndGg7IGQrKylcbiAgICAgICAgaFtkXSA9IG9bZF0gfCAwO1xuICAgICAgcmV0dXJuIGg7XG4gICAgfVxuICAgIGlmIChmID09PSBcImhleFwiKSB7XG4gICAgICBvID0gby5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCBcIlwiKSwgby5sZW5ndGggJSAyICE9PSAwICYmIChvID0gXCIwXCIgKyBvKTtcbiAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgby5sZW5ndGg7IGQgKz0gMilcbiAgICAgICAgaC5wdXNoKHBhcnNlSW50KG9bZF0gKyBvW2QgKyAxXSwgMTYpKTtcbiAgICB9IGVsc2VcbiAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgby5sZW5ndGg7IGQrKykge1xuICAgICAgICB2YXIgdiA9IG8uY2hhckNvZGVBdChkKSwgdyA9IHYgPj4gOCwgQSA9IHYgJiAyNTU7XG4gICAgICAgIHcgPyBoLnB1c2godywgQSkgOiBoLnB1c2goQSk7XG4gICAgICB9XG4gICAgcmV0dXJuIGg7XG4gIH1cbiAgdC50b0FycmF5ID0gaTtcbiAgZnVuY3Rpb24gbihvKSB7XG4gICAgcmV0dXJuIG8ubGVuZ3RoID09PSAxID8gXCIwXCIgKyBvIDogbztcbiAgfVxuICB0Lnplcm8yID0gbjtcbiAgZnVuY3Rpb24gcyhvKSB7XG4gICAgZm9yICh2YXIgZiA9IFwiXCIsIGggPSAwOyBoIDwgby5sZW5ndGg7IGgrKylcbiAgICAgIGYgKz0gbihvW2hdLnRvU3RyaW5nKDE2KSk7XG4gICAgcmV0dXJuIGY7XG4gIH1cbiAgdC50b0hleCA9IHMsIHQuZW5jb2RlID0gZnVuY3Rpb24oZiwgaCkge1xuICAgIHJldHVybiBoID09PSBcImhleFwiID8gcyhmKSA6IGY7XG4gIH07XG59KSwgc3IgPSB4bihmdW5jdGlvbihyLCBlKSB7XG4gIHZhciB0ID0gZTtcbiAgdC5hc3NlcnQgPSBCbywgdC50b0FycmF5ID0gTXIudG9BcnJheSwgdC56ZXJvMiA9IE1yLnplcm8yLCB0LnRvSGV4ID0gTXIudG9IZXgsIHQuZW5jb2RlID0gTXIuZW5jb2RlO1xuICBmdW5jdGlvbiBpKGgsIGQsIHYpIHtcbiAgICB2YXIgdyA9IG5ldyBBcnJheShNYXRoLm1heChoLmJpdExlbmd0aCgpLCB2KSArIDEpO1xuICAgIHcuZmlsbCgwKTtcbiAgICBmb3IgKHZhciBBID0gMSA8PCBkICsgMSwgSSA9IGguY2xvbmUoKSwgRCA9IDA7IEQgPCB3Lmxlbmd0aDsgRCsrKSB7XG4gICAgICB2YXIgTiwgayA9IEkuYW5kbG4oQSAtIDEpO1xuICAgICAgSS5pc09kZCgpID8gKGsgPiAoQSA+PiAxKSAtIDEgPyBOID0gKEEgPj4gMSkgLSBrIDogTiA9IGssIEkuaXN1Ym4oTikpIDogTiA9IDAsIHdbRF0gPSBOLCBJLml1c2hybigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHc7XG4gIH1cbiAgdC5nZXROQUYgPSBpO1xuICBmdW5jdGlvbiBuKGgsIGQpIHtcbiAgICB2YXIgdiA9IFtcbiAgICAgIFtdLFxuICAgICAgW11cbiAgICBdO1xuICAgIGggPSBoLmNsb25lKCksIGQgPSBkLmNsb25lKCk7XG4gICAgZm9yICh2YXIgdyA9IDAsIEEgPSAwLCBJOyBoLmNtcG4oLXcpID4gMCB8fCBkLmNtcG4oLUEpID4gMDsgKSB7XG4gICAgICB2YXIgRCA9IGguYW5kbG4oMykgKyB3ICYgMywgTiA9IGQuYW5kbG4oMykgKyBBICYgMztcbiAgICAgIEQgPT09IDMgJiYgKEQgPSAtMSksIE4gPT09IDMgJiYgKE4gPSAtMSk7XG4gICAgICB2YXIgaztcbiAgICAgIEQgJiAxID8gKEkgPSBoLmFuZGxuKDcpICsgdyAmIDcsIChJID09PSAzIHx8IEkgPT09IDUpICYmIE4gPT09IDIgPyBrID0gLUQgOiBrID0gRCkgOiBrID0gMCwgdlswXS5wdXNoKGspO1xuICAgICAgdmFyIGo7XG4gICAgICBOICYgMSA/IChJID0gZC5hbmRsbig3KSArIEEgJiA3LCAoSSA9PT0gMyB8fCBJID09PSA1KSAmJiBEID09PSAyID8gaiA9IC1OIDogaiA9IE4pIDogaiA9IDAsIHZbMV0ucHVzaChqKSwgMiAqIHcgPT09IGsgKyAxICYmICh3ID0gMSAtIHcpLCAyICogQSA9PT0gaiArIDEgJiYgKEEgPSAxIC0gQSksIGguaXVzaHJuKDEpLCBkLml1c2hybigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgdC5nZXRKU0YgPSBuO1xuICBmdW5jdGlvbiBzKGgsIGQsIHYpIHtcbiAgICB2YXIgdyA9IFwiX1wiICsgZDtcbiAgICBoLnByb3RvdHlwZVtkXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNbd10gIT09IHZvaWQgMCA/IHRoaXNbd10gOiB0aGlzW3ddID0gdi5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH1cbiAgdC5jYWNoZWRQcm9wZXJ0eSA9IHM7XG4gIGZ1bmN0aW9uIG8oaCkge1xuICAgIHJldHVybiB0eXBlb2YgaCA9PSBcInN0cmluZ1wiID8gdC50b0FycmF5KGgsIFwiaGV4XCIpIDogaDtcbiAgfVxuICB0LnBhcnNlQnl0ZXMgPSBvO1xuICBmdW5jdGlvbiBmKGgpIHtcbiAgICByZXR1cm4gbmV3IEtlKGgsIFwiaGV4XCIsIFwibGVcIik7XG4gIH1cbiAgdC5pbnRGcm9tTEUgPSBmO1xufSksIGpzID0gc3IuZ2V0TkFGLCBFZyA9IHNyLmdldEpTRiwgS3MgPSBzci5hc3NlcnQ7XG5mdW5jdGlvbiBTaShyLCBlKSB7XG4gIHRoaXMudHlwZSA9IHIsIHRoaXMucCA9IG5ldyBLZShlLnAsIDE2KSwgdGhpcy5yZWQgPSBlLnByaW1lID8gS2UucmVkKGUucHJpbWUpIDogS2UubW9udCh0aGlzLnApLCB0aGlzLnplcm8gPSBuZXcgS2UoMCkudG9SZWQodGhpcy5yZWQpLCB0aGlzLm9uZSA9IG5ldyBLZSgxKS50b1JlZCh0aGlzLnJlZCksIHRoaXMudHdvID0gbmV3IEtlKDIpLnRvUmVkKHRoaXMucmVkKSwgdGhpcy5uID0gZS5uICYmIG5ldyBLZShlLm4sIDE2KSwgdGhpcy5nID0gZS5nICYmIHRoaXMucG9pbnRGcm9tSlNPTihlLmcsIGUuZ1JlZCksIHRoaXMuX3duYWZUMSA9IG5ldyBBcnJheSg0KSwgdGhpcy5fd25hZlQyID0gbmV3IEFycmF5KDQpLCB0aGlzLl93bmFmVDMgPSBuZXcgQXJyYXkoNCksIHRoaXMuX3duYWZUNCA9IG5ldyBBcnJheSg0KSwgdGhpcy5fYml0TGVuZ3RoID0gdGhpcy5uID8gdGhpcy5uLmJpdExlbmd0aCgpIDogMDtcbiAgdmFyIHQgPSB0aGlzLm4gJiYgdGhpcy5wLmRpdih0aGlzLm4pO1xuICAhdCB8fCB0LmNtcG4oMTAwKSA+IDAgPyB0aGlzLnJlZE4gPSBudWxsIDogKHRoaXMuX21heHdlbGxUcmljayA9ICEwLCB0aGlzLnJlZE4gPSB0aGlzLm4udG9SZWQodGhpcy5yZWQpKTtcbn1cbnZhciBYaSA9IFNpO1xuU2kucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5TaS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xufTtcblNpLnByb3RvdHlwZS5fZml4ZWROYWZNdWwgPSBmdW5jdGlvbihlLCB0KSB7XG4gIEtzKGUucHJlY29tcHV0ZWQpO1xuICB2YXIgaSA9IGUuX2dldERvdWJsZXMoKSwgbiA9IGpzKHQsIDEsIHRoaXMuX2JpdExlbmd0aCksIHMgPSAoMSA8PCBpLnN0ZXAgKyAxKSAtIChpLnN0ZXAgJSAyID09PSAwID8gMiA6IDEpO1xuICBzIC89IDM7XG4gIHZhciBvID0gW10sIGYsIGg7XG4gIGZvciAoZiA9IDA7IGYgPCBuLmxlbmd0aDsgZiArPSBpLnN0ZXApIHtcbiAgICBoID0gMDtcbiAgICBmb3IgKHZhciBkID0gZiArIGkuc3RlcCAtIDE7IGQgPj0gZjsgZC0tKVxuICAgICAgaCA9IChoIDw8IDEpICsgbltkXTtcbiAgICBvLnB1c2goaCk7XG4gIH1cbiAgZm9yICh2YXIgdiA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpLCB3ID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCksIEEgPSBzOyBBID4gMDsgQS0tKSB7XG4gICAgZm9yIChmID0gMDsgZiA8IG8ubGVuZ3RoOyBmKyspXG4gICAgICBoID0gb1tmXSwgaCA9PT0gQSA/IHcgPSB3Lm1peGVkQWRkKGkucG9pbnRzW2ZdKSA6IGggPT09IC1BICYmICh3ID0gdy5taXhlZEFkZChpLnBvaW50c1tmXS5uZWcoKSkpO1xuICAgIHYgPSB2LmFkZCh3KTtcbiAgfVxuICByZXR1cm4gdi50b1AoKTtcbn07XG5TaS5wcm90b3R5cGUuX3duYWZNdWwgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHZhciBpID0gNCwgbiA9IGUuX2dldE5BRlBvaW50cyhpKTtcbiAgaSA9IG4ud25kO1xuICBmb3IgKHZhciBzID0gbi5wb2ludHMsIG8gPSBqcyh0LCBpLCB0aGlzLl9iaXRMZW5ndGgpLCBmID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCksIGggPSBvLmxlbmd0aCAtIDE7IGggPj0gMDsgaC0tKSB7XG4gICAgZm9yICh2YXIgZCA9IDA7IGggPj0gMCAmJiBvW2hdID09PSAwOyBoLS0pXG4gICAgICBkKys7XG4gICAgaWYgKGggPj0gMCAmJiBkKyssIGYgPSBmLmRibHAoZCksIGggPCAwKVxuICAgICAgYnJlYWs7XG4gICAgdmFyIHYgPSBvW2hdO1xuICAgIEtzKHYgIT09IDApLCBlLnR5cGUgPT09IFwiYWZmaW5lXCIgPyB2ID4gMCA/IGYgPSBmLm1peGVkQWRkKHNbdiAtIDEgPj4gMV0pIDogZiA9IGYubWl4ZWRBZGQoc1stdiAtIDEgPj4gMV0ubmVnKCkpIDogdiA+IDAgPyBmID0gZi5hZGQoc1t2IC0gMSA+PiAxXSkgOiBmID0gZi5hZGQoc1stdiAtIDEgPj4gMV0ubmVnKCkpO1xuICB9XG4gIHJldHVybiBlLnR5cGUgPT09IFwiYWZmaW5lXCIgPyBmLnRvUCgpIDogZjtcbn07XG5TaS5wcm90b3R5cGUuX3duYWZNdWxBZGQgPSBmdW5jdGlvbihlLCB0LCBpLCBuLCBzKSB7XG4gIHZhciBvID0gdGhpcy5fd25hZlQxLCBmID0gdGhpcy5fd25hZlQyLCBoID0gdGhpcy5fd25hZlQzLCBkID0gMCwgdiwgdywgQTtcbiAgZm9yICh2ID0gMDsgdiA8IG47IHYrKykge1xuICAgIEEgPSB0W3ZdO1xuICAgIHZhciBJID0gQS5fZ2V0TkFGUG9pbnRzKGUpO1xuICAgIG9bdl0gPSBJLnduZCwgZlt2XSA9IEkucG9pbnRzO1xuICB9XG4gIGZvciAodiA9IG4gLSAxOyB2ID49IDE7IHYgLT0gMikge1xuICAgIHZhciBEID0gdiAtIDEsIE4gPSB2O1xuICAgIGlmIChvW0RdICE9PSAxIHx8IG9bTl0gIT09IDEpIHtcbiAgICAgIGhbRF0gPSBqcyhpW0RdLCBvW0RdLCB0aGlzLl9iaXRMZW5ndGgpLCBoW05dID0ganMoaVtOXSwgb1tOXSwgdGhpcy5fYml0TGVuZ3RoKSwgZCA9IE1hdGgubWF4KGhbRF0ubGVuZ3RoLCBkKSwgZCA9IE1hdGgubWF4KGhbTl0ubGVuZ3RoLCBkKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgayA9IFtcbiAgICAgIHRbRF0sXG4gICAgICAvKiAxICovXG4gICAgICBudWxsLFxuICAgICAgLyogMyAqL1xuICAgICAgbnVsbCxcbiAgICAgIC8qIDUgKi9cbiAgICAgIHRbTl1cbiAgICAgIC8qIDcgKi9cbiAgICBdO1xuICAgIHRbRF0ueS5jbXAodFtOXS55KSA9PT0gMCA/IChrWzFdID0gdFtEXS5hZGQodFtOXSksIGtbMl0gPSB0W0RdLnRvSigpLm1peGVkQWRkKHRbTl0ubmVnKCkpKSA6IHRbRF0ueS5jbXAodFtOXS55LnJlZE5lZygpKSA9PT0gMCA/IChrWzFdID0gdFtEXS50b0ooKS5taXhlZEFkZCh0W05dKSwga1syXSA9IHRbRF0uYWRkKHRbTl0ubmVnKCkpKSA6IChrWzFdID0gdFtEXS50b0ooKS5taXhlZEFkZCh0W05dKSwga1syXSA9IHRbRF0udG9KKCkubWl4ZWRBZGQodFtOXS5uZWcoKSkpO1xuICAgIHZhciBqID0gW1xuICAgICAgLTMsXG4gICAgICAvKiAtMSAtMSAqL1xuICAgICAgLTEsXG4gICAgICAvKiAtMSAwICovXG4gICAgICAtNSxcbiAgICAgIC8qIC0xIDEgKi9cbiAgICAgIC03LFxuICAgICAgLyogMCAtMSAqL1xuICAgICAgMCxcbiAgICAgIC8qIDAgMCAqL1xuICAgICAgNyxcbiAgICAgIC8qIDAgMSAqL1xuICAgICAgNSxcbiAgICAgIC8qIDEgLTEgKi9cbiAgICAgIDEsXG4gICAgICAvKiAxIDAgKi9cbiAgICAgIDNcbiAgICAgIC8qIDEgMSAqL1xuICAgIF0sIFQgPSBFZyhpW0RdLCBpW05dKTtcbiAgICBmb3IgKGQgPSBNYXRoLm1heChUWzBdLmxlbmd0aCwgZCksIGhbRF0gPSBuZXcgQXJyYXkoZCksIGhbTl0gPSBuZXcgQXJyYXkoZCksIHcgPSAwOyB3IDwgZDsgdysrKSB7XG4gICAgICB2YXIgSyA9IFRbMF1bd10gfCAwLCAkID0gVFsxXVt3XSB8IDA7XG4gICAgICBoW0RdW3ddID0galsoSyArIDEpICogMyArICgkICsgMSldLCBoW05dW3ddID0gMCwgZltEXSA9IGs7XG4gICAgfVxuICB9XG4gIHZhciB6ID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCksIEIgPSB0aGlzLl93bmFmVDQ7XG4gIGZvciAodiA9IGQ7IHYgPj0gMDsgdi0tKSB7XG4gICAgZm9yICh2YXIgXyA9IDA7IHYgPj0gMDsgKSB7XG4gICAgICB2YXIgUiA9ICEwO1xuICAgICAgZm9yICh3ID0gMDsgdyA8IG47IHcrKylcbiAgICAgICAgQlt3XSA9IGhbd11bdl0gfCAwLCBCW3ddICE9PSAwICYmIChSID0gITEpO1xuICAgICAgaWYgKCFSKVxuICAgICAgICBicmVhaztcbiAgICAgIF8rKywgdi0tO1xuICAgIH1cbiAgICBpZiAodiA+PSAwICYmIF8rKywgeiA9IHouZGJscChfKSwgdiA8IDApXG4gICAgICBicmVhaztcbiAgICBmb3IgKHcgPSAwOyB3IDwgbjsgdysrKSB7XG4gICAgICB2YXIgSiA9IEJbd107XG4gICAgICBKICE9PSAwICYmIChKID4gMCA/IEEgPSBmW3ddW0ogLSAxID4+IDFdIDogSiA8IDAgJiYgKEEgPSBmW3ddWy1KIC0gMSA+PiAxXS5uZWcoKSksIEEudHlwZSA9PT0gXCJhZmZpbmVcIiA/IHogPSB6Lm1peGVkQWRkKEEpIDogeiA9IHouYWRkKEEpKTtcbiAgICB9XG4gIH1cbiAgZm9yICh2ID0gMDsgdiA8IG47IHYrKylcbiAgICBmW3ZdID0gbnVsbDtcbiAgcmV0dXJuIHMgPyB6IDogei50b1AoKTtcbn07XG5mdW5jdGlvbiB2cihyLCBlKSB7XG4gIHRoaXMuY3VydmUgPSByLCB0aGlzLnR5cGUgPSBlLCB0aGlzLnByZWNvbXB1dGVkID0gbnVsbDtcbn1cblNpLkJhc2VQb2ludCA9IHZyO1xudnIucHJvdG90eXBlLmVxID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG52ci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUudmFsaWRhdGUodGhpcyk7XG59O1xuU2kucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24oZSwgdCkge1xuICBlID0gc3IudG9BcnJheShlLCB0KTtcbiAgdmFyIGkgPSB0aGlzLnAuYnl0ZUxlbmd0aCgpO1xuICBpZiAoKGVbMF0gPT09IDQgfHwgZVswXSA9PT0gNiB8fCBlWzBdID09PSA3KSAmJiBlLmxlbmd0aCAtIDEgPT09IDIgKiBpKSB7XG4gICAgZVswXSA9PT0gNiA/IEtzKGVbZS5sZW5ndGggLSAxXSAlIDIgPT09IDApIDogZVswXSA9PT0gNyAmJiBLcyhlW2UubGVuZ3RoIC0gMV0gJSAyID09PSAxKTtcbiAgICB2YXIgbiA9IHRoaXMucG9pbnQoXG4gICAgICBlLnNsaWNlKDEsIDEgKyBpKSxcbiAgICAgIGUuc2xpY2UoMSArIGksIDEgKyAyICogaSlcbiAgICApO1xuICAgIHJldHVybiBuO1xuICB9IGVsc2UgaWYgKChlWzBdID09PSAyIHx8IGVbMF0gPT09IDMpICYmIGUubGVuZ3RoIC0gMSA9PT0gaSlcbiAgICByZXR1cm4gdGhpcy5wb2ludEZyb21YKGUuc2xpY2UoMSwgMSArIGkpLCBlWzBdID09PSAzKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwb2ludCBmb3JtYXRcIik7XG59O1xudnIucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiB0aGlzLmVuY29kZShlLCAhMCk7XG59O1xudnIucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbihlKSB7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKSwgaSA9IHRoaXMuZ2V0WCgpLnRvQXJyYXkoXCJiZVwiLCB0KTtcbiAgcmV0dXJuIGUgPyBbdGhpcy5nZXRZKCkuaXNFdmVuKCkgPyAyIDogM10uY29uY2F0KGkpIDogWzRdLmNvbmNhdChpLCB0aGlzLmdldFkoKS50b0FycmF5KFwiYmVcIiwgdCkpO1xufTtcbnZyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBzci5lbmNvZGUodGhpcy5fZW5jb2RlKHQpLCBlKTtcbn07XG52ci5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIHRoaXM7XG4gIHZhciB0ID0ge1xuICAgIGRvdWJsZXM6IG51bGwsXG4gICAgbmFmOiBudWxsLFxuICAgIGJldGE6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHQubmFmID0gdGhpcy5fZ2V0TkFGUG9pbnRzKDgpLCB0LmRvdWJsZXMgPSB0aGlzLl9nZXREb3VibGVzKDQsIGUpLCB0LmJldGEgPSB0aGlzLl9nZXRCZXRhKCksIHRoaXMucHJlY29tcHV0ZWQgPSB0LCB0aGlzO1xufTtcbnZyLnByb3RvdHlwZS5faGFzRG91YmxlcyA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIHQgPSB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG4gIHJldHVybiB0ID8gdC5wb2ludHMubGVuZ3RoID49IE1hdGguY2VpbCgoZS5iaXRMZW5ndGgoKSArIDEpIC8gdC5zdGVwKSA6ICExO1xufTtcbnZyLnByb3RvdHlwZS5fZ2V0RG91YmxlcyA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzKVxuICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG4gIGZvciAodmFyIGkgPSBbdGhpc10sIG4gPSB0aGlzLCBzID0gMDsgcyA8IHQ7IHMgKz0gZSkge1xuICAgIGZvciAodmFyIG8gPSAwOyBvIDwgZTsgbysrKVxuICAgICAgbiA9IG4uZGJsKCk7XG4gICAgaS5wdXNoKG4pO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RlcDogZSxcbiAgICBwb2ludHM6IGlcbiAgfTtcbn07XG52ci5wcm90b3R5cGUuX2dldE5BRlBvaW50cyA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5uYWYpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQubmFmO1xuICBmb3IgKHZhciB0ID0gW3RoaXNdLCBpID0gKDEgPDwgZSkgLSAxLCBuID0gaSA9PT0gMSA/IG51bGwgOiB0aGlzLmRibCgpLCBzID0gMTsgcyA8IGk7IHMrKylcbiAgICB0W3NdID0gdFtzIC0gMV0uYWRkKG4pO1xuICByZXR1cm4ge1xuICAgIHduZDogZSxcbiAgICBwb2ludHM6IHRcbiAgfTtcbn07XG52ci5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xudnIucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbihlKSB7XG4gIGZvciAodmFyIHQgPSB0aGlzLCBpID0gMDsgaSA8IGU7IGkrKylcbiAgICB0ID0gdC5kYmwoKTtcbiAgcmV0dXJuIHQ7XG59O1xudmFyIGtvID0geG4oZnVuY3Rpb24ocikge1xuICB0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PSBcImZ1bmN0aW9uXCIgPyByLmV4cG9ydHMgPSBmdW5jdGlvbih0LCBpKSB7XG4gICAgaSAmJiAodC5zdXBlcl8gPSBpLCB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoaS5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiB0LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9XG4gICAgfSkpO1xuICB9IDogci5leHBvcnRzID0gZnVuY3Rpb24odCwgaSkge1xuICAgIGlmIChpKSB7XG4gICAgICB0LnN1cGVyXyA9IGk7XG4gICAgICB2YXIgbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIG4ucHJvdG90eXBlID0gaS5wcm90b3R5cGUsIHQucHJvdG90eXBlID0gbmV3IG4oKSwgdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSB0O1xuICAgIH1cbiAgfTtcbn0pLCBTZyA9IHNyLmFzc2VydDtcbmZ1bmN0aW9uIGJyKHIpIHtcbiAgWGkuY2FsbCh0aGlzLCBcInNob3J0XCIsIHIpLCB0aGlzLmEgPSBuZXcgS2Uoci5hLCAxNikudG9SZWQodGhpcy5yZWQpLCB0aGlzLmIgPSBuZXcgS2Uoci5iLCAxNikudG9SZWQodGhpcy5yZWQpLCB0aGlzLnRpbnYgPSB0aGlzLnR3by5yZWRJbnZtKCksIHRoaXMuemVyb0EgPSB0aGlzLmEuZnJvbVJlZCgpLmNtcG4oMCkgPT09IDAsIHRoaXMudGhyZWVBID0gdGhpcy5hLmZyb21SZWQoKS5zdWIodGhpcy5wKS5jbXBuKC0zKSA9PT0gMCwgdGhpcy5lbmRvID0gdGhpcy5fZ2V0RW5kb21vcnBoaXNtKHIpLCB0aGlzLl9lbmRvV25hZlQxID0gbmV3IEFycmF5KDQpLCB0aGlzLl9lbmRvV25hZlQyID0gbmV3IEFycmF5KDQpO1xufVxua28oYnIsIFhpKTtcbnZhciBNZyA9IGJyO1xuYnIucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc20gPSBmdW5jdGlvbihlKSB7XG4gIGlmICghKCF0aGlzLnplcm9BIHx8ICF0aGlzLmcgfHwgIXRoaXMubiB8fCB0aGlzLnAubW9kbigzKSAhPT0gMSkpIHtcbiAgICB2YXIgdCwgaTtcbiAgICBpZiAoZS5iZXRhKVxuICAgICAgdCA9IG5ldyBLZShlLmJldGEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbiA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLnApO1xuICAgICAgdCA9IG5bMF0uY21wKG5bMV0pIDwgMCA/IG5bMF0gOiBuWzFdLCB0ID0gdC50b1JlZCh0aGlzLnJlZCk7XG4gICAgfVxuICAgIGlmIChlLmxhbWJkYSlcbiAgICAgIGkgPSBuZXcgS2UoZS5sYW1iZGEsIDE2KTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMubik7XG4gICAgICB0aGlzLmcubXVsKHNbMF0pLnguY21wKHRoaXMuZy54LnJlZE11bCh0KSkgPT09IDAgPyBpID0gc1swXSA6IChpID0gc1sxXSwgU2codGhpcy5nLm11bChpKS54LmNtcCh0aGlzLmcueC5yZWRNdWwodCkpID09PSAwKSk7XG4gICAgfVxuICAgIHZhciBvO1xuICAgIHJldHVybiBlLmJhc2lzID8gbyA9IGUuYmFzaXMubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGE6IG5ldyBLZShmLmEsIDE2KSxcbiAgICAgICAgYjogbmV3IEtlKGYuYiwgMTYpXG4gICAgICB9O1xuICAgIH0pIDogbyA9IHRoaXMuX2dldEVuZG9CYXNpcyhpKSwge1xuICAgICAgYmV0YTogdCxcbiAgICAgIGxhbWJkYTogaSxcbiAgICAgIGJhc2lzOiBvXG4gICAgfTtcbiAgfVxufTtcbmJyLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdCA9IGUgPT09IHRoaXMucCA/IHRoaXMucmVkIDogS2UubW9udChlKSwgaSA9IG5ldyBLZSgyKS50b1JlZCh0KS5yZWRJbnZtKCksIG4gPSBpLnJlZE5lZygpLCBzID0gbmV3IEtlKDMpLnRvUmVkKHQpLnJlZE5lZygpLnJlZFNxcnQoKS5yZWRNdWwoaSksIG8gPSBuLnJlZEFkZChzKS5mcm9tUmVkKCksIGYgPSBuLnJlZFN1YihzKS5mcm9tUmVkKCk7XG4gIHJldHVybiBbbywgZl07XG59O1xuYnIucHJvdG90eXBlLl9nZXRFbmRvQmFzaXMgPSBmdW5jdGlvbihlKSB7XG4gIGZvciAodmFyIHQgPSB0aGlzLm4udXNocm4oTWF0aC5mbG9vcih0aGlzLm4uYml0TGVuZ3RoKCkgLyAyKSksIGkgPSBlLCBuID0gdGhpcy5uLmNsb25lKCksIHMgPSBuZXcgS2UoMSksIG8gPSBuZXcgS2UoMCksIGYgPSBuZXcgS2UoMCksIGggPSBuZXcgS2UoMSksIGQsIHYsIHcsIEEsIEksIEQsIE4sIGsgPSAwLCBqLCBUOyBpLmNtcG4oMCkgIT09IDA7ICkge1xuICAgIHZhciBLID0gbi5kaXYoaSk7XG4gICAgaiA9IG4uc3ViKEsubXVsKGkpKSwgVCA9IGYuc3ViKEsubXVsKHMpKTtcbiAgICB2YXIgJCA9IGguc3ViKEsubXVsKG8pKTtcbiAgICBpZiAoIXcgJiYgai5jbXAodCkgPCAwKVxuICAgICAgZCA9IE4ubmVnKCksIHYgPSBzLCB3ID0gai5uZWcoKSwgQSA9IFQ7XG4gICAgZWxzZSBpZiAodyAmJiArK2sgPT09IDIpXG4gICAgICBicmVhaztcbiAgICBOID0gaiwgbiA9IGksIGkgPSBqLCBmID0gcywgcyA9IFQsIGggPSBvLCBvID0gJDtcbiAgfVxuICBJID0gai5uZWcoKSwgRCA9IFQ7XG4gIHZhciB6ID0gdy5zcXIoKS5hZGQoQS5zcXIoKSksIEIgPSBJLnNxcigpLmFkZChELnNxcigpKTtcbiAgcmV0dXJuIEIuY21wKHopID49IDAgJiYgKEkgPSBkLCBEID0gdiksIHcubmVnYXRpdmUgJiYgKHcgPSB3Lm5lZygpLCBBID0gQS5uZWcoKSksIEkubmVnYXRpdmUgJiYgKEkgPSBJLm5lZygpLCBEID0gRC5uZWcoKSksIFtcbiAgICB7IGE6IHcsIGI6IEEgfSxcbiAgICB7IGE6IEksIGI6IEQgfVxuICBdO1xufTtcbmJyLnByb3RvdHlwZS5fZW5kb1NwbGl0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdCA9IHRoaXMuZW5kby5iYXNpcywgaSA9IHRbMF0sIG4gPSB0WzFdLCBzID0gbi5iLm11bChlKS5kaXZSb3VuZCh0aGlzLm4pLCBvID0gaS5iLm5lZygpLm11bChlKS5kaXZSb3VuZCh0aGlzLm4pLCBmID0gcy5tdWwoaS5hKSwgaCA9IG8ubXVsKG4uYSksIGQgPSBzLm11bChpLmIpLCB2ID0gby5tdWwobi5iKSwgdyA9IGUuc3ViKGYpLnN1YihoKSwgQSA9IGQuYWRkKHYpLm5lZygpO1xuICByZXR1cm4geyBrMTogdywgazI6IEEgfTtcbn07XG5ici5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgZSA9IG5ldyBLZShlLCAxNiksIGUucmVkIHx8IChlID0gZS50b1JlZCh0aGlzLnJlZCkpO1xuICB2YXIgaSA9IGUucmVkU3FyKCkucmVkTXVsKGUpLnJlZElBZGQoZS5yZWRNdWwodGhpcy5hKSkucmVkSUFkZCh0aGlzLmIpLCBuID0gaS5yZWRTcXJ0KCk7XG4gIGlmIChuLnJlZFNxcigpLnJlZFN1YihpKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50XCIpO1xuICB2YXIgcyA9IG4uZnJvbVJlZCgpLmlzT2RkKCk7XG4gIHJldHVybiAodCAmJiAhcyB8fCAhdCAmJiBzKSAmJiAobiA9IG4ucmVkTmVnKCkpLCB0aGlzLnBvaW50KGUsIG4pO1xufTtcbmJyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKGUuaW5mKVxuICAgIHJldHVybiAhMDtcbiAgdmFyIHQgPSBlLngsIGkgPSBlLnksIG4gPSB0aGlzLmEucmVkTXVsKHQpLCBzID0gdC5yZWRTcXIoKS5yZWRNdWwodCkucmVkSUFkZChuKS5yZWRJQWRkKHRoaXMuYik7XG4gIHJldHVybiBpLnJlZFNxcigpLnJlZElTdWIocykuY21wbigwKSA9PT0gMDtcbn07XG5ici5wcm90b3R5cGUuX2VuZG9XbmFmTXVsQWRkID0gZnVuY3Rpb24oZSwgdCwgaSkge1xuICBmb3IgKHZhciBuID0gdGhpcy5fZW5kb1duYWZUMSwgcyA9IHRoaXMuX2VuZG9XbmFmVDIsIG8gPSAwOyBvIDwgZS5sZW5ndGg7IG8rKykge1xuICAgIHZhciBmID0gdGhpcy5fZW5kb1NwbGl0KHRbb10pLCBoID0gZVtvXSwgZCA9IGguX2dldEJldGEoKTtcbiAgICBmLmsxLm5lZ2F0aXZlICYmIChmLmsxLmluZWcoKSwgaCA9IGgubmVnKCEwKSksIGYuazIubmVnYXRpdmUgJiYgKGYuazIuaW5lZygpLCBkID0gZC5uZWcoITApKSwgbltvICogMl0gPSBoLCBuW28gKiAyICsgMV0gPSBkLCBzW28gKiAyXSA9IGYuazEsIHNbbyAqIDIgKyAxXSA9IGYuazI7XG4gIH1cbiAgZm9yICh2YXIgdiA9IHRoaXMuX3duYWZNdWxBZGQoMSwgbiwgcywgbyAqIDIsIGkpLCB3ID0gMDsgdyA8IG8gKiAyOyB3KyspXG4gICAgblt3XSA9IG51bGwsIHNbd10gPSBudWxsO1xuICByZXR1cm4gdjtcbn07XG5mdW5jdGlvbiBEdChyLCBlLCB0LCBpKSB7XG4gIFhpLkJhc2VQb2ludC5jYWxsKHRoaXMsIHIsIFwiYWZmaW5lXCIpLCBlID09PSBudWxsICYmIHQgPT09IG51bGwgPyAodGhpcy54ID0gbnVsbCwgdGhpcy55ID0gbnVsbCwgdGhpcy5pbmYgPSAhMCkgOiAodGhpcy54ID0gbmV3IEtlKGUsIDE2KSwgdGhpcy55ID0gbmV3IEtlKHQsIDE2KSwgaSAmJiAodGhpcy54LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKSwgdGhpcy55LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKSksIHRoaXMueC5yZWQgfHwgKHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCkpLCB0aGlzLnkucmVkIHx8ICh0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpKSwgdGhpcy5pbmYgPSAhMSk7XG59XG5rbyhEdCwgWGkuQmFzZVBvaW50KTtcbmJyLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgcmV0dXJuIG5ldyBEdCh0aGlzLCBlLCB0LCBpKTtcbn07XG5ici5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIER0LmZyb21KU09OKHRoaXMsIGUsIHQpO1xufTtcbkR0LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKSB7XG4gICAgdmFyIGUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICAgIGlmIChlICYmIGUuYmV0YSlcbiAgICAgIHJldHVybiBlLmJldGE7XG4gICAgdmFyIHQgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueC5yZWRNdWwodGhpcy5jdXJ2ZS5lbmRvLmJldGEpLCB0aGlzLnkpO1xuICAgIGlmIChlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuY3VydmUsIG4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBpLnBvaW50KHMueC5yZWRNdWwoaS5lbmRvLmJldGEpLCBzLnkpO1xuICAgICAgfTtcbiAgICAgIGUuYmV0YSA9IHQsIHQucHJlY29tcHV0ZWQgPSB7XG4gICAgICAgIGJldGE6IG51bGwsXG4gICAgICAgIG5hZjogZS5uYWYgJiYge1xuICAgICAgICAgIHduZDogZS5uYWYud25kLFxuICAgICAgICAgIHBvaW50czogZS5uYWYucG9pbnRzLm1hcChuKVxuICAgICAgICB9LFxuICAgICAgICBkb3VibGVzOiBlLmRvdWJsZXMgJiYge1xuICAgICAgICAgIHN0ZXA6IGUuZG91Ymxlcy5zdGVwLFxuICAgICAgICAgIHBvaW50czogZS5kb3VibGVzLnBvaW50cy5tYXAobilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbn07XG5EdC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnByZWNvbXB1dGVkID8gW3RoaXMueCwgdGhpcy55LCB0aGlzLnByZWNvbXB1dGVkICYmIHtcbiAgICBkb3VibGVzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMgJiYge1xuICAgICAgc3RlcDogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnN0ZXAsXG4gICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5wb2ludHMuc2xpY2UoMSlcbiAgICB9LFxuICAgIG5hZjogdGhpcy5wcmVjb21wdXRlZC5uYWYgJiYge1xuICAgICAgd25kOiB0aGlzLnByZWNvbXB1dGVkLm5hZi53bmQsXG4gICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQubmFmLnBvaW50cy5zbGljZSgxKVxuICAgIH1cbiAgfV0gOiBbdGhpcy54LCB0aGlzLnldO1xufTtcbkR0LmZyb21KU09OID0gZnVuY3Rpb24oZSwgdCwgaSkge1xuICB0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmICh0ID0gSlNPTi5wYXJzZSh0KSk7XG4gIHZhciBuID0gZS5wb2ludCh0WzBdLCB0WzFdLCBpKTtcbiAgaWYgKCF0WzJdKVxuICAgIHJldHVybiBuO1xuICBmdW5jdGlvbiBzKGYpIHtcbiAgICByZXR1cm4gZS5wb2ludChmWzBdLCBmWzFdLCBpKTtcbiAgfVxuICB2YXIgbyA9IHRbMl07XG4gIHJldHVybiBuLnByZWNvbXB1dGVkID0ge1xuICAgIGJldGE6IG51bGwsXG4gICAgZG91Ymxlczogby5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IG8uZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiBbbl0uY29uY2F0KG8uZG91Ymxlcy5wb2ludHMubWFwKHMpKVxuICAgIH0sXG4gICAgbmFmOiBvLm5hZiAmJiB7XG4gICAgICB3bmQ6IG8ubmFmLnduZCxcbiAgICAgIHBvaW50czogW25dLmNvbmNhdChvLm5hZi5wb2ludHMubWFwKHMpKVxuICAgIH1cbiAgfSwgbjtcbn07XG5EdC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pc0luZmluaXR5KCkgPyBcIjxFQyBQb2ludCBJbmZpbml0eT5cIiA6IFwiPEVDIFBvaW50IHg6IFwiICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyBcIiB5OiBcIiArIHRoaXMueS5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgXCI+XCI7XG59O1xuRHQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaW5mO1xufTtcbkR0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gZTtcbiAgaWYgKGUuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAodGhpcy5lcShlKSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcbiAgaWYgKHRoaXMubmVnKCkuZXEoZSkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG4gIGlmICh0aGlzLnguY21wKGUueCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG4gIHZhciB0ID0gdGhpcy55LnJlZFN1YihlLnkpO1xuICB0LmNtcG4oMCkgIT09IDAgJiYgKHQgPSB0LnJlZE11bCh0aGlzLngucmVkU3ViKGUueCkucmVkSW52bSgpKSk7XG4gIHZhciBpID0gdC5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueCkucmVkSVN1YihlLngpLCBuID0gdC5yZWRNdWwodGhpcy54LnJlZFN1YihpKSkucmVkSVN1Yih0aGlzLnkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChpLCBuKTtcbn07XG5EdC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcbiAgdmFyIGUgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIGlmIChlLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5hLCBpID0gdGhpcy54LnJlZFNxcigpLCBuID0gZS5yZWRJbnZtKCksIHMgPSBpLnJlZEFkZChpKS5yZWRJQWRkKGkpLnJlZElBZGQodCkucmVkTXVsKG4pLCBvID0gcy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueC5yZWRBZGQodGhpcy54KSksIGYgPSBzLnJlZE11bCh0aGlzLngucmVkU3ViKG8pKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG8sIGYpO1xufTtcbkR0LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcbkR0LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcbkR0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlID0gbmV3IEtlKGUsIDE2KSwgdGhpcy5pc0luZmluaXR5KCkgPyB0aGlzIDogdGhpcy5faGFzRG91YmxlcyhlKSA/IHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGUpIDogdGhpcy5jdXJ2ZS5lbmRvID8gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQoW3RoaXNdLCBbZV0pIDogdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBlKTtcbn07XG5EdC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24oZSwgdCwgaSkge1xuICB2YXIgbiA9IFt0aGlzLCB0XSwgcyA9IFtlLCBpXTtcbiAgcmV0dXJuIHRoaXMuY3VydmUuZW5kbyA/IHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKG4sIHMpIDogdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBuLCBzLCAyKTtcbn07XG5EdC5wcm90b3R5cGUuam11bEFkZCA9IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgdmFyIG4gPSBbdGhpcywgdF0sIHMgPSBbZSwgaV07XG4gIHJldHVybiB0aGlzLmN1cnZlLmVuZG8gPyB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChuLCBzLCAhMCkgOiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIG4sIHMsIDIsICEwKTtcbn07XG5EdC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiB0aGlzID09PSBlIHx8IHRoaXMuaW5mID09PSBlLmluZiAmJiAodGhpcy5pbmYgfHwgdGhpcy54LmNtcChlLngpID09PSAwICYmIHRoaXMueS5jbXAoZS55KSA9PT0gMCk7XG59O1xuRHQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuICB2YXIgdCA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCkpO1xuICBpZiAoZSAmJiB0aGlzLnByZWNvbXB1dGVkKSB7XG4gICAgdmFyIGkgPSB0aGlzLnByZWNvbXB1dGVkLCBuID0gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHMubmVnKCk7XG4gICAgfTtcbiAgICB0LnByZWNvbXB1dGVkID0ge1xuICAgICAgbmFmOiBpLm5hZiAmJiB7XG4gICAgICAgIHduZDogaS5uYWYud25kLFxuICAgICAgICBwb2ludHM6IGkubmFmLnBvaW50cy5tYXAobilcbiAgICAgIH0sXG4gICAgICBkb3VibGVzOiBpLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBpLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBpLmRvdWJsZXMucG9pbnRzLm1hcChuKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHQ7XG59O1xuRHQucHJvdG90eXBlLnRvSiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICB2YXIgZSA9IHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LCB0aGlzLmN1cnZlLm9uZSk7XG4gIHJldHVybiBlO1xufTtcbmZ1bmN0aW9uIE50KHIsIGUsIHQsIGkpIHtcbiAgWGkuQmFzZVBvaW50LmNhbGwodGhpcywgciwgXCJqYWNvYmlhblwiKSwgZSA9PT0gbnVsbCAmJiB0ID09PSBudWxsICYmIGkgPT09IG51bGwgPyAodGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmUsIHRoaXMueSA9IHRoaXMuY3VydmUub25lLCB0aGlzLnogPSBuZXcgS2UoMCkpIDogKHRoaXMueCA9IG5ldyBLZShlLCAxNiksIHRoaXMueSA9IG5ldyBLZSh0LCAxNiksIHRoaXMueiA9IG5ldyBLZShpLCAxNikpLCB0aGlzLngucmVkIHx8ICh0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpKSwgdGhpcy55LnJlZCB8fCAodGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKSksIHRoaXMuei5yZWQgfHwgKHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCkpLCB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xufVxua28oTnQsIFhpLkJhc2VQb2ludCk7XG5ici5wcm90b3R5cGUuanBvaW50ID0gZnVuY3Rpb24oZSwgdCwgaSkge1xuICByZXR1cm4gbmV3IE50KHRoaXMsIGUsIHQsIGkpO1xufTtcbk50LnByb3RvdHlwZS50b1AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuICB2YXIgZSA9IHRoaXMuei5yZWRJbnZtKCksIHQgPSBlLnJlZFNxcigpLCBpID0gdGhpcy54LnJlZE11bCh0KSwgbiA9IHRoaXMueS5yZWRNdWwodCkucmVkTXVsKGUpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChpLCBuKTtcbn07XG5OdC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSwgdGhpcy56KTtcbn07XG5OdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZSkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIGU7XG4gIGlmIChlLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcbiAgdmFyIHQgPSBlLnoucmVkU3FyKCksIGkgPSB0aGlzLnoucmVkU3FyKCksIG4gPSB0aGlzLngucmVkTXVsKHQpLCBzID0gZS54LnJlZE11bChpKSwgbyA9IHRoaXMueS5yZWRNdWwodC5yZWRNdWwoZS56KSksIGYgPSBlLnkucmVkTXVsKGkucmVkTXVsKHRoaXMueikpLCBoID0gbi5yZWRTdWIocyksIGQgPSBvLnJlZFN1YihmKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gZC5jbXBuKDApICE9PSAwID8gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCkgOiB0aGlzLmRibCgpO1xuICB2YXIgdiA9IGgucmVkU3FyKCksIHcgPSB2LnJlZE11bChoKSwgQSA9IG4ucmVkTXVsKHYpLCBJID0gZC5yZWRTcXIoKS5yZWRJQWRkKHcpLnJlZElTdWIoQSkucmVkSVN1YihBKSwgRCA9IGQucmVkTXVsKEEucmVkSVN1YihJKSkucmVkSVN1YihvLnJlZE11bCh3KSksIE4gPSB0aGlzLnoucmVkTXVsKGUueikucmVkTXVsKGgpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoSSwgRCwgTik7XG59O1xuTnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24oZSkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIGUudG9KKCk7XG4gIGlmIChlLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcbiAgdmFyIHQgPSB0aGlzLnoucmVkU3FyKCksIGkgPSB0aGlzLngsIG4gPSBlLngucmVkTXVsKHQpLCBzID0gdGhpcy55LCBvID0gZS55LnJlZE11bCh0KS5yZWRNdWwodGhpcy56KSwgZiA9IGkucmVkU3ViKG4pLCBoID0gcy5yZWRTdWIobyk7XG4gIGlmIChmLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIGguY21wbigwKSAhPT0gMCA/IHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpIDogdGhpcy5kYmwoKTtcbiAgdmFyIGQgPSBmLnJlZFNxcigpLCB2ID0gZC5yZWRNdWwoZiksIHcgPSBpLnJlZE11bChkKSwgQSA9IGgucmVkU3FyKCkucmVkSUFkZCh2KS5yZWRJU3ViKHcpLnJlZElTdWIodyksIEkgPSBoLnJlZE11bCh3LnJlZElTdWIoQSkpLnJlZElTdWIocy5yZWRNdWwodikpLCBEID0gdGhpcy56LnJlZE11bChmKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KEEsIEksIEQpO1xufTtcbk50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24oZSkge1xuICBpZiAoZSA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAoIWUpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIHZhciB0O1xuICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSB8fCB0aGlzLmN1cnZlLnRocmVlQSkge1xuICAgIHZhciBpID0gdGhpcztcbiAgICBmb3IgKHQgPSAwOyB0IDwgZTsgdCsrKVxuICAgICAgaSA9IGkuZGJsKCk7XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgdmFyIG4gPSB0aGlzLmN1cnZlLmEsIHMgPSB0aGlzLmN1cnZlLnRpbnYsIG8gPSB0aGlzLngsIGYgPSB0aGlzLnksIGggPSB0aGlzLnosIGQgPSBoLnJlZFNxcigpLnJlZFNxcigpLCB2ID0gZi5yZWRBZGQoZik7XG4gIGZvciAodCA9IDA7IHQgPCBlOyB0KyspIHtcbiAgICB2YXIgdyA9IG8ucmVkU3FyKCksIEEgPSB2LnJlZFNxcigpLCBJID0gQS5yZWRTcXIoKSwgRCA9IHcucmVkQWRkKHcpLnJlZElBZGQodykucmVkSUFkZChuLnJlZE11bChkKSksIE4gPSBvLnJlZE11bChBKSwgayA9IEQucmVkU3FyKCkucmVkSVN1YihOLnJlZEFkZChOKSksIGogPSBOLnJlZElTdWIoayksIFQgPSBELnJlZE11bChqKTtcbiAgICBUID0gVC5yZWRJQWRkKFQpLnJlZElTdWIoSSk7XG4gICAgdmFyIEsgPSB2LnJlZE11bChoKTtcbiAgICB0ICsgMSA8IGUgJiYgKGQgPSBkLnJlZE11bChJKSksIG8gPSBrLCBoID0gSywgdiA9IFQ7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG8sIHYucmVkTXVsKHMpLCBoKTtcbn07XG5OdC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmlzSW5maW5pdHkoKSA/IHRoaXMgOiB0aGlzLmN1cnZlLnplcm9BID8gdGhpcy5femVyb0RibCgpIDogdGhpcy5jdXJ2ZS50aHJlZUEgPyB0aGlzLl90aHJlZURibCgpIDogdGhpcy5fZGJsKCk7XG59O1xuTnQucHJvdG90eXBlLl96ZXJvRGJsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlLCB0LCBpO1xuICBpZiAodGhpcy56T25lKSB7XG4gICAgdmFyIG4gPSB0aGlzLngucmVkU3FyKCksIHMgPSB0aGlzLnkucmVkU3FyKCksIG8gPSBzLnJlZFNxcigpLCBmID0gdGhpcy54LnJlZEFkZChzKS5yZWRTcXIoKS5yZWRJU3ViKG4pLnJlZElTdWIobyk7XG4gICAgZiA9IGYucmVkSUFkZChmKTtcbiAgICB2YXIgaCA9IG4ucmVkQWRkKG4pLnJlZElBZGQobiksIGQgPSBoLnJlZFNxcigpLnJlZElTdWIoZikucmVkSVN1YihmKSwgdiA9IG8ucmVkSUFkZChvKTtcbiAgICB2ID0gdi5yZWRJQWRkKHYpLCB2ID0gdi5yZWRJQWRkKHYpLCBlID0gZCwgdCA9IGgucmVkTXVsKGYucmVkSVN1YihkKSkucmVkSVN1Yih2KSwgaSA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdyA9IHRoaXMueC5yZWRTcXIoKSwgQSA9IHRoaXMueS5yZWRTcXIoKSwgSSA9IEEucmVkU3FyKCksIEQgPSB0aGlzLngucmVkQWRkKEEpLnJlZFNxcigpLnJlZElTdWIodykucmVkSVN1YihJKTtcbiAgICBEID0gRC5yZWRJQWRkKEQpO1xuICAgIHZhciBOID0gdy5yZWRBZGQodykucmVkSUFkZCh3KSwgayA9IE4ucmVkU3FyKCksIGogPSBJLnJlZElBZGQoSSk7XG4gICAgaiA9IGoucmVkSUFkZChqKSwgaiA9IGoucmVkSUFkZChqKSwgZSA9IGsucmVkSVN1YihEKS5yZWRJU3ViKEQpLCB0ID0gTi5yZWRNdWwoRC5yZWRJU3ViKGUpKS5yZWRJU3ViKGopLCBpID0gdGhpcy55LnJlZE11bCh0aGlzLnopLCBpID0gaS5yZWRJQWRkKGkpO1xuICB9XG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChlLCB0LCBpKTtcbn07XG5OdC5wcm90b3R5cGUuX3RocmVlRGJsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlLCB0LCBpO1xuICBpZiAodGhpcy56T25lKSB7XG4gICAgdmFyIG4gPSB0aGlzLngucmVkU3FyKCksIHMgPSB0aGlzLnkucmVkU3FyKCksIG8gPSBzLnJlZFNxcigpLCBmID0gdGhpcy54LnJlZEFkZChzKS5yZWRTcXIoKS5yZWRJU3ViKG4pLnJlZElTdWIobyk7XG4gICAgZiA9IGYucmVkSUFkZChmKTtcbiAgICB2YXIgaCA9IG4ucmVkQWRkKG4pLnJlZElBZGQobikucmVkSUFkZCh0aGlzLmN1cnZlLmEpLCBkID0gaC5yZWRTcXIoKS5yZWRJU3ViKGYpLnJlZElTdWIoZik7XG4gICAgZSA9IGQ7XG4gICAgdmFyIHYgPSBvLnJlZElBZGQobyk7XG4gICAgdiA9IHYucmVkSUFkZCh2KSwgdiA9IHYucmVkSUFkZCh2KSwgdCA9IGgucmVkTXVsKGYucmVkSVN1YihkKSkucmVkSVN1Yih2KSwgaSA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdyA9IHRoaXMuei5yZWRTcXIoKSwgQSA9IHRoaXMueS5yZWRTcXIoKSwgSSA9IHRoaXMueC5yZWRNdWwoQSksIEQgPSB0aGlzLngucmVkU3ViKHcpLnJlZE11bCh0aGlzLngucmVkQWRkKHcpKTtcbiAgICBEID0gRC5yZWRBZGQoRCkucmVkSUFkZChEKTtcbiAgICB2YXIgTiA9IEkucmVkSUFkZChJKTtcbiAgICBOID0gTi5yZWRJQWRkKE4pO1xuICAgIHZhciBrID0gTi5yZWRBZGQoTik7XG4gICAgZSA9IEQucmVkU3FyKCkucmVkSVN1YihrKSwgaSA9IHRoaXMueS5yZWRBZGQodGhpcy56KS5yZWRTcXIoKS5yZWRJU3ViKEEpLnJlZElTdWIodyk7XG4gICAgdmFyIGogPSBBLnJlZFNxcigpO1xuICAgIGogPSBqLnJlZElBZGQoaiksIGogPSBqLnJlZElBZGQoaiksIGogPSBqLnJlZElBZGQoaiksIHQgPSBELnJlZE11bChOLnJlZElTdWIoZSkpLnJlZElTdWIoaik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGUsIHQsIGkpO1xufTtcbk50LnByb3RvdHlwZS5fZGJsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlID0gdGhpcy5jdXJ2ZS5hLCB0ID0gdGhpcy54LCBpID0gdGhpcy55LCBuID0gdGhpcy56LCBzID0gbi5yZWRTcXIoKS5yZWRTcXIoKSwgbyA9IHQucmVkU3FyKCksIGYgPSBpLnJlZFNxcigpLCBoID0gby5yZWRBZGQobykucmVkSUFkZChvKS5yZWRJQWRkKGUucmVkTXVsKHMpKSwgZCA9IHQucmVkQWRkKHQpO1xuICBkID0gZC5yZWRJQWRkKGQpO1xuICB2YXIgdiA9IGQucmVkTXVsKGYpLCB3ID0gaC5yZWRTcXIoKS5yZWRJU3ViKHYucmVkQWRkKHYpKSwgQSA9IHYucmVkSVN1Yih3KSwgSSA9IGYucmVkU3FyKCk7XG4gIEkgPSBJLnJlZElBZGQoSSksIEkgPSBJLnJlZElBZGQoSSksIEkgPSBJLnJlZElBZGQoSSk7XG4gIHZhciBEID0gaC5yZWRNdWwoQSkucmVkSVN1YihJKSwgTiA9IGkucmVkQWRkKGkpLnJlZE11bChuKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHcsIEQsIE4pO1xufTtcbk50LnByb3RvdHlwZS50cnBsID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jdXJ2ZS56ZXJvQSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKS5hZGQodGhpcyk7XG4gIHZhciBlID0gdGhpcy54LnJlZFNxcigpLCB0ID0gdGhpcy55LnJlZFNxcigpLCBpID0gdGhpcy56LnJlZFNxcigpLCBuID0gdC5yZWRTcXIoKSwgcyA9IGUucmVkQWRkKGUpLnJlZElBZGQoZSksIG8gPSBzLnJlZFNxcigpLCBmID0gdGhpcy54LnJlZEFkZCh0KS5yZWRTcXIoKS5yZWRJU3ViKGUpLnJlZElTdWIobik7XG4gIGYgPSBmLnJlZElBZGQoZiksIGYgPSBmLnJlZEFkZChmKS5yZWRJQWRkKGYpLCBmID0gZi5yZWRJU3ViKG8pO1xuICB2YXIgaCA9IGYucmVkU3FyKCksIGQgPSBuLnJlZElBZGQobik7XG4gIGQgPSBkLnJlZElBZGQoZCksIGQgPSBkLnJlZElBZGQoZCksIGQgPSBkLnJlZElBZGQoZCk7XG4gIHZhciB2ID0gcy5yZWRJQWRkKGYpLnJlZFNxcigpLnJlZElTdWIobykucmVkSVN1YihoKS5yZWRJU3ViKGQpLCB3ID0gdC5yZWRNdWwodik7XG4gIHcgPSB3LnJlZElBZGQodyksIHcgPSB3LnJlZElBZGQodyk7XG4gIHZhciBBID0gdGhpcy54LnJlZE11bChoKS5yZWRJU3ViKHcpO1xuICBBID0gQS5yZWRJQWRkKEEpLCBBID0gQS5yZWRJQWRkKEEpO1xuICB2YXIgSSA9IHRoaXMueS5yZWRNdWwodi5yZWRNdWwoZC5yZWRJU3ViKHYpKS5yZWRJU3ViKGYucmVkTXVsKGgpKSk7XG4gIEkgPSBJLnJlZElBZGQoSSksIEkgPSBJLnJlZElBZGQoSSksIEkgPSBJLnJlZElBZGQoSSk7XG4gIHZhciBEID0gdGhpcy56LnJlZEFkZChmKS5yZWRTcXIoKS5yZWRJU3ViKGkpLnJlZElTdWIoaCk7XG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChBLCBJLCBEKTtcbn07XG5OdC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gZSA9IG5ldyBLZShlLCB0KSwgdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBlKTtcbn07XG5OdC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbihlKSB7XG4gIGlmIChlLnR5cGUgPT09IFwiYWZmaW5lXCIpXG4gICAgcmV0dXJuIHRoaXMuZXEoZS50b0ooKSk7XG4gIGlmICh0aGlzID09PSBlKVxuICAgIHJldHVybiAhMDtcbiAgdmFyIHQgPSB0aGlzLnoucmVkU3FyKCksIGkgPSBlLnoucmVkU3FyKCk7XG4gIGlmICh0aGlzLngucmVkTXVsKGkpLnJlZElTdWIoZS54LnJlZE11bCh0KSkuY21wbigwKSAhPT0gMClcbiAgICByZXR1cm4gITE7XG4gIHZhciBuID0gdC5yZWRNdWwodGhpcy56KSwgcyA9IGkucmVkTXVsKGUueik7XG4gIHJldHVybiB0aGlzLnkucmVkTXVsKHMpLnJlZElTdWIoZS55LnJlZE11bChuKSkuY21wbigwKSA9PT0gMDtcbn07XG5OdC5wcm90b3R5cGUuZXFYVG9QID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdCA9IHRoaXMuei5yZWRTcXIoKSwgaSA9IGUudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh0KTtcbiAgaWYgKHRoaXMueC5jbXAoaSkgPT09IDApXG4gICAgcmV0dXJuICEwO1xuICBmb3IgKHZhciBuID0gZS5jbG9uZSgpLCBzID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh0KTsgOyApIHtcbiAgICBpZiAobi5pYWRkKHRoaXMuY3VydmUubiksIG4uY21wKHRoaXMuY3VydmUucCkgPj0gMClcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAoaS5yZWRJQWRkKHMpLCB0aGlzLnguY21wKGkpID09PSAwKVxuICAgICAgcmV0dXJuICEwO1xuICB9XG59O1xuTnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXNJbmZpbml0eSgpID8gXCI8RUMgSlBvaW50IEluZmluaXR5PlwiIDogXCI8RUMgSlBvaW50IHg6IFwiICsgdGhpcy54LnRvU3RyaW5nKDE2LCAyKSArIFwiIHk6IFwiICsgdGhpcy55LnRvU3RyaW5nKDE2LCAyKSArIFwiIHo6IFwiICsgdGhpcy56LnRvU3RyaW5nKDE2LCAyKSArIFwiPlwiO1xufTtcbk50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcbn07XG52YXIgT3MgPSB4bihmdW5jdGlvbihyLCBlKSB7XG4gIHZhciB0ID0gZTtcbiAgdC5iYXNlID0gWGksIHQuc2hvcnQgPSBNZywgdC5tb250ID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoLi9tb250KSovXG4gIG51bGwsIHQuZWR3YXJkcyA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vZWR3YXJkcykqL1xuICBudWxsO1xufSksIFJzID0geG4oZnVuY3Rpb24ociwgZSkge1xuICB2YXIgdCA9IGUsIGkgPSBzci5hc3NlcnQ7XG4gIGZ1bmN0aW9uIG4oZikge1xuICAgIGYudHlwZSA9PT0gXCJzaG9ydFwiID8gdGhpcy5jdXJ2ZSA9IG5ldyBPcy5zaG9ydChmKSA6IGYudHlwZSA9PT0gXCJlZHdhcmRzXCIgPyB0aGlzLmN1cnZlID0gbmV3IE9zLmVkd2FyZHMoZikgOiB0aGlzLmN1cnZlID0gbmV3IE9zLm1vbnQoZiksIHRoaXMuZyA9IHRoaXMuY3VydmUuZywgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uLCB0aGlzLmhhc2ggPSBmLmhhc2gsIGkodGhpcy5nLnZhbGlkYXRlKCksIFwiSW52YWxpZCBjdXJ2ZVwiKSwgaSh0aGlzLmcubXVsKHRoaXMubikuaXNJbmZpbml0eSgpLCBcIkludmFsaWQgY3VydmUsIEcqTiAhPSBPXCIpO1xuICB9XG4gIHQuUHJlc2V0Q3VydmUgPSBuO1xuICBmdW5jdGlvbiBzKGYsIGgpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgZiwge1xuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGQgPSBuZXcgbihoKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBmLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICB2YWx1ZTogZFxuICAgICAgICB9KSwgZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzKFwicDE5MlwiLCB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIHByaW1lOiBcInAxOTJcIixcbiAgICBwOiBcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmXCIsXG4gICAgYTogXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmY1wiLFxuICAgIGI6IFwiNjQyMTA1MTkgZTU5YzgwZTcgMGZhN2U5YWIgNzIyNDMwNDkgZmViOGRlZWMgYzE0NmI5YjFcIixcbiAgICBuOiBcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDk5ZGVmODM2IDE0NmJjOWIxIGI0ZDIyODMxXCIsXG4gICAgaGFzaDogc2kuc2hhMjU2LFxuICAgIGdSZWQ6ICExLFxuICAgIGc6IFtcbiAgICAgIFwiMTg4ZGE4MGUgYjAzMDkwZjYgN2NiZjIwZWIgNDNhMTg4MDAgZjRmZjBhZmQgODJmZjEwMTJcIixcbiAgICAgIFwiMDcxOTJiOTUgZmZjOGRhNzggNjMxMDExZWQgNmIyNGNkZDUgNzNmOTc3YTEgMWU3OTQ4MTFcIlxuICAgIF1cbiAgfSksIHMoXCJwMjI0XCIsIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgcHJpbWU6IFwicDIyNFwiLFxuICAgIHA6IFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDFcIixcbiAgICBhOiBcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlXCIsXG4gICAgYjogXCJiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNFwiLFxuICAgIG46IFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZjE2YTIgZTBiOGYwM2UgMTNkZDI5NDUgNWM1YzJhM2RcIixcbiAgICBoYXNoOiBzaS5zaGEyNTYsXG4gICAgZ1JlZDogITEsXG4gICAgZzogW1xuICAgICAgXCJiNzBlMGNiZCA2YmI0YmY3ZiAzMjEzOTBiOSA0YTAzYzFkMyA1NmMyMTEyMiAzNDMyODBkNiAxMTVjMWQyMVwiLFxuICAgICAgXCJiZDM3NjM4OCBiNWY3MjNmYiA0YzIyZGZlNiBjZDQzNzVhMCA1YTA3NDc2NCA0NGQ1ODE5OSA4NTAwN2UzNFwiXG4gICAgXVxuICB9KSwgcyhcInAyNTZcIiwge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBwcmltZTogbnVsbCxcbiAgICBwOiBcImZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmXCIsXG4gICAgYTogXCJmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmY1wiLFxuICAgIGI6IFwiNWFjNjM1ZDggYWEzYTkzZTcgYjNlYmJkNTUgNzY5ODg2YmMgNjUxZDA2YjAgY2M1M2IwZjYgM2JjZTNjM2UgMjdkMjYwNGJcIixcbiAgICBuOiBcImZmZmZmZmZmIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGJjZTZmYWFkIGE3MTc5ZTg0IGYzYjljYWMyIGZjNjMyNTUxXCIsXG4gICAgaGFzaDogc2kuc2hhMjU2LFxuICAgIGdSZWQ6ICExLFxuICAgIGc6IFtcbiAgICAgIFwiNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTZcIixcbiAgICAgIFwiNGZlMzQyZTIgZmUxYTdmOWIgOGVlN2ViNGEgN2MwZjllMTYgMmJjZTMzNTcgNmIzMTVlY2UgY2JiNjQwNjggMzdiZjUxZjVcIlxuICAgIF1cbiAgfSksIHMoXCJwMzg0XCIsIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgcHJpbWU6IG51bGwsXG4gICAgcDogXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZlwiLFxuICAgIGE6IFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmNcIixcbiAgICBiOiBcImIzMzEyZmE3IGUyM2VlN2U0IDk4OGUwNTZiIGUzZjgyZDE5IDE4MWQ5YzZlIGZlODE0MTEyIDAzMTQwODhmIDUwMTM4NzVhIGM2NTYzOThkIDhhMmVkMTlkIDJhODVjOGVkIGQzZWMyYWVmXCIsXG4gICAgbjogXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBjNzYzNGQ4MSBmNDM3MmRkZiA1ODFhMGRiMiA0OGIwYTc3YSBlY2VjMTk2YSBjY2M1Mjk3M1wiLFxuICAgIGhhc2g6IHNpLnNoYTM4NCxcbiAgICBnUmVkOiAhMSxcbiAgICBnOiBbXG4gICAgICBcImFhODdjYTIyIGJlOGIwNTM3IDhlYjFjNzFlIGYzMjBhZDc0IDZlMWQzYjYyIDhiYTc5Yjk4IDU5Zjc0MWUwIDgyNTQyYTM4IDU1MDJmMjVkIGJmNTUyOTZjIDNhNTQ1ZTM4IDcyNzYwYWI3XCIsXG4gICAgICBcIjM2MTdkZTRhIDk2MjYyYzZmIDVkOWU5OGJmIDkyOTJkYzI5IGY4ZjQxZGJkIDI4OWExNDdjIGU5ZGEzMTEzIGI1ZjBiOGMwIDBhNjBiMWNlIDFkN2U4MTlkIDdhNDMxZDdjIDkwZWEwZTVmXCJcbiAgICBdXG4gIH0pLCBzKFwicDUyMVwiLCB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIHByaW1lOiBudWxsLFxuICAgIHA6IFwiMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmZcIixcbiAgICBhOiBcIjAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjXCIsXG4gICAgYjogXCIwMDAwMDA1MSA5NTNlYjk2MSA4ZTFjOWExZiA5MjlhMjFhMCBiNjg1NDBlZSBhMmRhNzI1YiA5OWIzMTVmMyBiOGI0ODk5MSA4ZWYxMDllMSA1NjE5Mzk1MSBlYzdlOTM3YiAxNjUyYzBiZCAzYmIxYmYwNyAzNTczZGY4OCAzZDJjMzRmMSBlZjQ1MWZkNCA2YjUwM2YwMFwiLFxuICAgIG46IFwiMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmEgNTE4Njg3ODMgYmYyZjk2NmIgN2ZjYzAxNDggZjcwOWE1ZDAgM2JiNWM5YjggODk5YzQ3YWUgYmI2ZmI3MWUgOTEzODY0MDlcIixcbiAgICBoYXNoOiBzaS5zaGE1MTIsXG4gICAgZ1JlZDogITEsXG4gICAgZzogW1xuICAgICAgXCIwMDAwMDBjNiA4NThlMDZiNyAwNDA0ZTljZCA5ZTNlY2I2NiAyMzk1YjQ0MiA5YzY0ODEzOSAwNTNmYjUyMSBmODI4YWY2MCA2YjRkM2RiYSBhMTRiNWU3NyBlZmU3NTkyOCBmZTFkYzEyNyBhMmZmYThkZSAzMzQ4YjNjMSA4NTZhNDI5YiBmOTdlN2UzMSBjMmU1YmQ2NlwiLFxuICAgICAgXCIwMDAwMDExOCAzOTI5NmE3OCA5YTNiYzAwNCA1YzhhNWZiNCAyYzdkMWJkOSA5OGY1NDQ0OSA1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYyA5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSAzZmFkMDc2MSAzNTNjNzA4NiBhMjcyYzI0MCA4OGJlOTQ3NiA5ZmQxNjY1MFwiXG4gICAgXVxuICB9KSwgcyhcImN1cnZlMjU1MTlcIiwge1xuICAgIHR5cGU6IFwibW9udFwiLFxuICAgIHByaW1lOiBcInAyNTUxOVwiLFxuICAgIHA6IFwiN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZFwiLFxuICAgIGE6IFwiNzZkMDZcIixcbiAgICBiOiBcIjFcIixcbiAgICBuOiBcIjEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWRcIixcbiAgICBoYXNoOiBzaS5zaGEyNTYsXG4gICAgZ1JlZDogITEsXG4gICAgZzogW1xuICAgICAgXCI5XCJcbiAgICBdXG4gIH0pLCBzKFwiZWQyNTUxOVwiLCB7XG4gICAgdHlwZTogXCJlZHdhcmRzXCIsXG4gICAgcHJpbWU6IFwicDI1NTE5XCIsXG4gICAgcDogXCI3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkXCIsXG4gICAgYTogXCItMVwiLFxuICAgIGM6IFwiMVwiLFxuICAgIC8vIC0xMjE2NjUgKiAoMTIxNjY2XigtMSkpIChtb2QgUClcbiAgICBkOiBcIjUyMDM2Y2VlMmI2ZmZlNzMgOGNjNzQwNzk3Nzc5ZTg5OCAwMDcwMGE0ZDQxNDFkOGFiIDc1ZWI0ZGNhMTM1OTc4YTNcIixcbiAgICBuOiBcIjEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWRcIixcbiAgICBoYXNoOiBzaS5zaGEyNTYsXG4gICAgZ1JlZDogITEsXG4gICAgZzogW1xuICAgICAgXCIyMTY5MzZkM2NkNmU1M2ZlYzBhNGUyMzFmZGQ2ZGM1YzY5MmNjNzYwOTUyNWE3YjJjOTU2MmQ2MDhmMjVkNTFhXCIsXG4gICAgICAvLyA0LzVcbiAgICAgIFwiNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY1OFwiXG4gICAgXVxuICB9KTtcbiAgdmFyIG87XG4gIHRyeSB7XG4gICAgbyA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vcHJlY29tcHV0ZWQvc2VjcDI1NmsxKSovXG4gICAgbnVsbC5jcmFzaCgpO1xuICB9IGNhdGNoIHtcbiAgICBvID0gdm9pZCAwO1xuICB9XG4gIHMoXCJzZWNwMjU2azFcIiwge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBwcmltZTogXCJrMjU2XCIsXG4gICAgcDogXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZlwiLFxuICAgIGE6IFwiMFwiLFxuICAgIGI6IFwiN1wiLFxuICAgIG46IFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgYmFhZWRjZTYgYWY0OGEwM2IgYmZkMjVlOGMgZDAzNjQxNDFcIixcbiAgICBoOiBcIjFcIixcbiAgICBoYXNoOiBzaS5zaGEyNTYsXG4gICAgLy8gUHJlY29tcHV0ZWQgZW5kb21vcnBoaXNtXG4gICAgYmV0YTogXCI3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlXCIsXG4gICAgbGFtYmRhOiBcIjUzNjNhZDRjYzA1YzMwZTBhNTI2MWMwMjg4MTI2NDVhMTIyZTIyZWEyMDgxNjY3OGRmMDI5NjdjMWIyM2JkNzJcIixcbiAgICBiYXNpczogW1xuICAgICAge1xuICAgICAgICBhOiBcIjMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1XCIsXG4gICAgICAgIGI6IFwiLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGE6IFwiMTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4XCIsXG4gICAgICAgIGI6IFwiMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTVcIlxuICAgICAgfVxuICAgIF0sXG4gICAgZ1JlZDogITEsXG4gICAgZzogW1xuICAgICAgXCI3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4XCIsXG4gICAgICBcIjQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjhcIixcbiAgICAgIG9cbiAgICBdXG4gIH0pO1xufSk7XG5mdW5jdGlvbiBfaShyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfaSkpXG4gICAgcmV0dXJuIG5ldyBfaShyKTtcbiAgdGhpcy5oYXNoID0gci5oYXNoLCB0aGlzLnByZWRSZXNpc3QgPSAhIXIucHJlZFJlc2lzdCwgdGhpcy5vdXRMZW4gPSB0aGlzLmhhc2gub3V0U2l6ZSwgdGhpcy5taW5FbnRyb3B5ID0gci5taW5FbnRyb3B5IHx8IHRoaXMuaGFzaC5obWFjU3RyZW5ndGgsIHRoaXMuX3Jlc2VlZCA9IG51bGwsIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSBudWxsLCB0aGlzLksgPSBudWxsLCB0aGlzLlYgPSBudWxsO1xuICB2YXIgZSA9IE1yLnRvQXJyYXkoci5lbnRyb3B5LCByLmVudHJvcHlFbmMgfHwgXCJoZXhcIiksIHQgPSBNci50b0FycmF5KHIubm9uY2UsIHIubm9uY2VFbmMgfHwgXCJoZXhcIiksIGkgPSBNci50b0FycmF5KHIucGVycywgci5wZXJzRW5jIHx8IFwiaGV4XCIpO1xuICBCbyhcbiAgICBlLmxlbmd0aCA+PSB0aGlzLm1pbkVudHJvcHkgLyA4LFxuICAgIFwiTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiBcIiArIHRoaXMubWluRW50cm9weSArIFwiIGJpdHNcIlxuICApLCB0aGlzLl9pbml0KGUsIHQsIGkpO1xufVxudmFyIEx1ID0gX2k7XG5faS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gIHZhciBuID0gZS5jb25jYXQodCkuY29uY2F0KGkpO1xuICB0aGlzLksgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KSwgdGhpcy5WID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIGZvciAodmFyIHMgPSAwOyBzIDwgdGhpcy5WLmxlbmd0aDsgcysrKVxuICAgIHRoaXMuS1tzXSA9IDAsIHRoaXMuVltzXSA9IDE7XG4gIHRoaXMuX3VwZGF0ZShuKSwgdGhpcy5fcmVzZWVkID0gMSwgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IDI4MTQ3NDk3NjcxMDY1Njtcbn07XG5faS5wcm90b3R5cGUuX2htYWMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBzaS5obWFjKHRoaXMuaGFzaCwgdGhpcy5LKTtcbn07XG5faS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikudXBkYXRlKFswXSk7XG4gIGUgJiYgKHQgPSB0LnVwZGF0ZShlKSksIHRoaXMuSyA9IHQuZGlnZXN0KCksIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKSwgZSAmJiAodGhpcy5LID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLnVwZGF0ZShbMV0pLnVwZGF0ZShlKS5kaWdlc3QoKSwgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpKTtcbn07XG5faS5wcm90b3R5cGUucmVzZWVkID0gZnVuY3Rpb24oZSwgdCwgaSwgbikge1xuICB0eXBlb2YgdCAhPSBcInN0cmluZ1wiICYmIChuID0gaSwgaSA9IHQsIHQgPSBudWxsKSwgZSA9IE1yLnRvQXJyYXkoZSwgdCksIGkgPSBNci50b0FycmF5KGksIG4pLCBCbyhcbiAgICBlLmxlbmd0aCA+PSB0aGlzLm1pbkVudHJvcHkgLyA4LFxuICAgIFwiTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiBcIiArIHRoaXMubWluRW50cm9weSArIFwiIGJpdHNcIlxuICApLCB0aGlzLl91cGRhdGUoZS5jb25jYXQoaSB8fCBbXSkpLCB0aGlzLl9yZXNlZWQgPSAxO1xufTtcbl9pLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uKGUsIHQsIGksIG4pIHtcbiAgaWYgKHRoaXMuX3Jlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzZWVkIGlzIHJlcXVpcmVkXCIpO1xuICB0eXBlb2YgdCAhPSBcInN0cmluZ1wiICYmIChuID0gaSwgaSA9IHQsIHQgPSBudWxsKSwgaSAmJiAoaSA9IE1yLnRvQXJyYXkoaSwgbiB8fCBcImhleFwiKSwgdGhpcy5fdXBkYXRlKGkpKTtcbiAgZm9yICh2YXIgcyA9IFtdOyBzLmxlbmd0aCA8IGU7IClcbiAgICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCksIHMgPSBzLmNvbmNhdCh0aGlzLlYpO1xuICB2YXIgbyA9IHMuc2xpY2UoMCwgZSk7XG4gIHJldHVybiB0aGlzLl91cGRhdGUoaSksIHRoaXMuX3Jlc2VlZCsrLCBNci5lbmNvZGUobywgdCk7XG59O1xudmFyIHhvID0gc3IuYXNzZXJ0O1xuZnVuY3Rpb24gcXQociwgZSkge1xuICB0aGlzLmVjID0gciwgdGhpcy5wcml2ID0gbnVsbCwgdGhpcy5wdWIgPSBudWxsLCBlLnByaXYgJiYgdGhpcy5faW1wb3J0UHJpdmF0ZShlLnByaXYsIGUucHJpdkVuYyksIGUucHViICYmIHRoaXMuX2ltcG9ydFB1YmxpYyhlLnB1YiwgZS5wdWJFbmMpO1xufVxudmFyIGpvID0gcXQ7XG5xdC5mcm9tUHVibGljID0gZnVuY3Rpb24oZSwgdCwgaSkge1xuICByZXR1cm4gdCBpbnN0YW5jZW9mIHF0ID8gdCA6IG5ldyBxdChlLCB7XG4gICAgcHViOiB0LFxuICAgIHB1YkVuYzogaVxuICB9KTtcbn07XG5xdC5mcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBxdCA/IHQgOiBuZXcgcXQoZSwge1xuICAgIHByaXY6IHQsXG4gICAgcHJpdkVuYzogaVxuICB9KTtcbn07XG5xdC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGUgPSB0aGlzLmdldFB1YmxpYygpO1xuICByZXR1cm4gZS5pc0luZmluaXR5KCkgPyB7IHJlc3VsdDogITEsIHJlYXNvbjogXCJJbnZhbGlkIHB1YmxpYyBrZXlcIiB9IDogZS52YWxpZGF0ZSgpID8gZS5tdWwodGhpcy5lYy5jdXJ2ZS5uKS5pc0luZmluaXR5KCkgPyB7IHJlc3VsdDogITAsIHJlYXNvbjogbnVsbCB9IDogeyByZXN1bHQ6ICExLCByZWFzb246IFwiUHVibGljIGtleSAqIE4gIT0gT1wiIH0gOiB7IHJlc3VsdDogITEsIHJlYXNvbjogXCJQdWJsaWMga2V5IGlzIG5vdCBhIHBvaW50XCIgfTtcbn07XG5xdC5wcm90b3R5cGUuZ2V0UHVibGljID0gZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiAodCA9IGUsIGUgPSBudWxsKSwgdGhpcy5wdWIgfHwgKHRoaXMucHViID0gdGhpcy5lYy5nLm11bCh0aGlzLnByaXYpKSwgdCA/IHRoaXMucHViLmVuY29kZSh0LCBlKSA6IHRoaXMucHViO1xufTtcbnF0LnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZSA9PT0gXCJoZXhcIiA/IHRoaXMucHJpdi50b1N0cmluZygxNiwgMikgOiB0aGlzLnByaXY7XG59O1xucXQucHJvdG90eXBlLl9pbXBvcnRQcml2YXRlID0gZnVuY3Rpb24oZSwgdCkge1xuICB0aGlzLnByaXYgPSBuZXcgS2UoZSwgdCB8fCAxNiksIHRoaXMucHJpdiA9IHRoaXMucHJpdi51bW9kKHRoaXMuZWMuY3VydmUubik7XG59O1xucXQucHJvdG90eXBlLl9pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbihlLCB0KSB7XG4gIGlmIChlLnggfHwgZS55KSB7XG4gICAgdGhpcy5lYy5jdXJ2ZS50eXBlID09PSBcIm1vbnRcIiA/IHhvKGUueCwgXCJOZWVkIHggY29vcmRpbmF0ZVwiKSA6ICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09IFwic2hvcnRcIiB8fCB0aGlzLmVjLmN1cnZlLnR5cGUgPT09IFwiZWR3YXJkc1wiKSAmJiB4byhlLnggJiYgZS55LCBcIk5lZWQgYm90aCB4IGFuZCB5IGNvb3JkaW5hdGVcIiksIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5wb2ludChlLngsIGUueSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5kZWNvZGVQb2ludChlLCB0KTtcbn07XG5xdC5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZS52YWxpZGF0ZSgpIHx8IHhvKGUudmFsaWRhdGUoKSwgXCJwdWJsaWMgcG9pbnQgbm90IHZhbGlkYXRlZFwiKSwgZS5tdWwodGhpcy5wcml2KS5nZXRYKCk7XG59O1xucXQucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gIHJldHVybiB0aGlzLmVjLnNpZ24oZSwgdGhpcywgdCwgaSk7XG59O1xucXQucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIHRoaXMuZWMudmVyaWZ5KGUsIHQsIHRoaXMpO1xufTtcbnF0LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBcIjxLZXkgcHJpdjogXCIgKyAodGhpcy5wcml2ICYmIHRoaXMucHJpdi50b1N0cmluZygxNiwgMikpICsgXCIgcHViOiBcIiArICh0aGlzLnB1YiAmJiB0aGlzLnB1Yi5pbnNwZWN0KCkpICsgXCIgPlwiO1xufTtcbnZhciBJZyA9IHNyLmFzc2VydDtcbmZ1bmN0aW9uIGxhKHIsIGUpIHtcbiAgaWYgKHIgaW5zdGFuY2VvZiBsYSlcbiAgICByZXR1cm4gcjtcbiAgdGhpcy5faW1wb3J0REVSKHIsIGUpIHx8IChJZyhyLnIgJiYgci5zLCBcIlNpZ25hdHVyZSB3aXRob3V0IHIgb3Igc1wiKSwgdGhpcy5yID0gbmV3IEtlKHIuciwgMTYpLCB0aGlzLnMgPSBuZXcgS2Uoci5zLCAxNiksIHIucmVjb3ZlcnlQYXJhbSA9PT0gdm9pZCAwID8gdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbCA6IHRoaXMucmVjb3ZlcnlQYXJhbSA9IHIucmVjb3ZlcnlQYXJhbSk7XG59XG52YXIgcGEgPSBsYTtcbmZ1bmN0aW9uIEFnKCkge1xuICB0aGlzLnBsYWNlID0gMDtcbn1cbmZ1bmN0aW9uIFZhKHIsIGUpIHtcbiAgdmFyIHQgPSByW2UucGxhY2UrK107XG4gIGlmICghKHQgJiAxMjgpKVxuICAgIHJldHVybiB0O1xuICB2YXIgaSA9IHQgJiAxNTtcbiAgaWYgKGkgPT09IDAgfHwgaSA+IDQpXG4gICAgcmV0dXJuICExO1xuICBmb3IgKHZhciBuID0gMCwgcyA9IDAsIG8gPSBlLnBsYWNlOyBzIDwgaTsgcysrLCBvKyspXG4gICAgbiA8PD0gOCwgbiB8PSByW29dLCBuID4+Pj0gMDtcbiAgcmV0dXJuIG4gPD0gMTI3ID8gITEgOiAoZS5wbGFjZSA9IG8sIG4pO1xufVxuZnVuY3Rpb24gbGMocikge1xuICBmb3IgKHZhciBlID0gMCwgdCA9IHIubGVuZ3RoIC0gMTsgIXJbZV0gJiYgIShyW2UgKyAxXSAmIDEyOCkgJiYgZSA8IHQ7IClcbiAgICBlKys7XG4gIHJldHVybiBlID09PSAwID8gciA6IHIuc2xpY2UoZSk7XG59XG5sYS5wcm90b3R5cGUuX2ltcG9ydERFUiA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgZSA9IHNyLnRvQXJyYXkoZSwgdCk7XG4gIHZhciBpID0gbmV3IEFnKCk7XG4gIGlmIChlW2kucGxhY2UrK10gIT09IDQ4KVxuICAgIHJldHVybiAhMTtcbiAgdmFyIG4gPSBWYShlLCBpKTtcbiAgaWYgKG4gPT09ICExIHx8IG4gKyBpLnBsYWNlICE9PSBlLmxlbmd0aCB8fCBlW2kucGxhY2UrK10gIT09IDIpXG4gICAgcmV0dXJuICExO1xuICB2YXIgcyA9IFZhKGUsIGkpO1xuICBpZiAocyA9PT0gITEpXG4gICAgcmV0dXJuICExO1xuICB2YXIgbyA9IGUuc2xpY2UoaS5wbGFjZSwgcyArIGkucGxhY2UpO1xuICBpZiAoaS5wbGFjZSArPSBzLCBlW2kucGxhY2UrK10gIT09IDIpXG4gICAgcmV0dXJuICExO1xuICB2YXIgZiA9IFZhKGUsIGkpO1xuICBpZiAoZiA9PT0gITEgfHwgZS5sZW5ndGggIT09IGYgKyBpLnBsYWNlKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIGggPSBlLnNsaWNlKGkucGxhY2UsIGYgKyBpLnBsYWNlKTtcbiAgaWYgKG9bMF0gPT09IDApXG4gICAgaWYgKG9bMV0gJiAxMjgpXG4gICAgICBvID0gby5zbGljZSgxKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gITE7XG4gIGlmIChoWzBdID09PSAwKVxuICAgIGlmIChoWzFdICYgMTI4KVxuICAgICAgaCA9IGguc2xpY2UoMSk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gdGhpcy5yID0gbmV3IEtlKG8pLCB0aGlzLnMgPSBuZXcgS2UoaCksIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGwsICEwO1xufTtcbmZ1bmN0aW9uIFdhKHIsIGUpIHtcbiAgaWYgKGUgPCAxMjgpIHtcbiAgICByLnB1c2goZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0ID0gMSArIChNYXRoLmxvZyhlKSAvIE1hdGguTE4yID4+PiAzKTtcbiAgZm9yIChyLnB1c2godCB8IDEyOCk7IC0tdDsgKVxuICAgIHIucHVzaChlID4+PiAodCA8PCAzKSAmIDI1NSk7XG4gIHIucHVzaChlKTtcbn1cbmxhLnByb3RvdHlwZS50b0RFUiA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSB0aGlzLnIudG9BcnJheSgpLCBpID0gdGhpcy5zLnRvQXJyYXkoKTtcbiAgZm9yICh0WzBdICYgMTI4ICYmICh0ID0gWzBdLmNvbmNhdCh0KSksIGlbMF0gJiAxMjggJiYgKGkgPSBbMF0uY29uY2F0KGkpKSwgdCA9IGxjKHQpLCBpID0gbGMoaSk7ICFpWzBdICYmICEoaVsxXSAmIDEyOCk7IClcbiAgICBpID0gaS5zbGljZSgxKTtcbiAgdmFyIG4gPSBbMl07XG4gIFdhKG4sIHQubGVuZ3RoKSwgbiA9IG4uY29uY2F0KHQpLCBuLnB1c2goMiksIFdhKG4sIGkubGVuZ3RoKTtcbiAgdmFyIHMgPSBuLmNvbmNhdChpKSwgbyA9IFs0OF07XG4gIHJldHVybiBXYShvLCBzLmxlbmd0aCksIG8gPSBvLmNvbmNhdChzKSwgc3IuZW5jb2RlKG8sIGUpO1xufTtcbnZhciBEZyA9IChcbiAgLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoYnJvcmFuZCkqL1xuICBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZFwiKTtcbiAgfVxuKSwgRnUgPSBzci5hc3NlcnQ7XG5mdW5jdGlvbiBscihyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBscikpXG4gICAgcmV0dXJuIG5ldyBscihyKTtcbiAgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiAmJiAoRnUoXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFJzLCByKSxcbiAgICBcIlVua25vd24gY3VydmUgXCIgKyByXG4gICksIHIgPSBSc1tyXSksIHIgaW5zdGFuY2VvZiBScy5QcmVzZXRDdXJ2ZSAmJiAociA9IHsgY3VydmU6IHIgfSksIHRoaXMuY3VydmUgPSByLmN1cnZlLmN1cnZlLCB0aGlzLm4gPSB0aGlzLmN1cnZlLm4sIHRoaXMubmggPSB0aGlzLm4udXNocm4oMSksIHRoaXMuZyA9IHRoaXMuY3VydmUuZywgdGhpcy5nID0gci5jdXJ2ZS5nLCB0aGlzLmcucHJlY29tcHV0ZShyLmN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKSwgdGhpcy5oYXNoID0gci5oYXNoIHx8IHIuY3VydmUuaGFzaDtcbn1cbnZhciBQZyA9IGxyO1xubHIucHJvdG90eXBlLmtleVBhaXIgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBuZXcgam8odGhpcywgZSk7XG59O1xubHIucHJvdG90eXBlLmtleUZyb21Qcml2YXRlID0gZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gam8uZnJvbVByaXZhdGUodGhpcywgZSwgdCk7XG59O1xubHIucHJvdG90eXBlLmtleUZyb21QdWJsaWMgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBqby5mcm9tUHVibGljKHRoaXMsIGUsIHQpO1xufTtcbmxyLnByb3RvdHlwZS5nZW5LZXlQYWlyID0gZnVuY3Rpb24oZSkge1xuICBlIHx8IChlID0ge30pO1xuICBmb3IgKHZhciB0ID0gbmV3IEx1KHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgcGVyczogZS5wZXJzLFxuICAgIHBlcnNFbmM6IGUucGVyc0VuYyB8fCBcInV0ZjhcIixcbiAgICBlbnRyb3B5OiBlLmVudHJvcHkgfHwgRGcodGhpcy5oYXNoLmhtYWNTdHJlbmd0aCksXG4gICAgZW50cm9weUVuYzogZS5lbnRyb3B5ICYmIGUuZW50cm9weUVuYyB8fCBcInV0ZjhcIixcbiAgICBub25jZTogdGhpcy5uLnRvQXJyYXkoKVxuICB9KSwgaSA9IHRoaXMubi5ieXRlTGVuZ3RoKCksIG4gPSB0aGlzLm4uc3ViKG5ldyBLZSgyKSk7IDsgKSB7XG4gICAgdmFyIHMgPSBuZXcgS2UodC5nZW5lcmF0ZShpKSk7XG4gICAgaWYgKCEocy5jbXAobikgPiAwKSlcbiAgICAgIHJldHVybiBzLmlhZGRuKDEpLCB0aGlzLmtleUZyb21Qcml2YXRlKHMpO1xuICB9XG59O1xubHIucHJvdG90eXBlLl90cnVuY2F0ZVRvTiA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgdmFyIGkgPSBlLmJ5dGVMZW5ndGgoKSAqIDggLSB0aGlzLm4uYml0TGVuZ3RoKCk7XG4gIHJldHVybiBpID4gMCAmJiAoZSA9IGUudXNocm4oaSkpLCAhdCAmJiBlLmNtcCh0aGlzLm4pID49IDAgPyBlLnN1Yih0aGlzLm4pIDogZTtcbn07XG5sci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uKGUsIHQsIGksIG4pIHtcbiAgdHlwZW9mIGkgPT0gXCJvYmplY3RcIiAmJiAobiA9IGksIGkgPSBudWxsKSwgbiB8fCAobiA9IHt9KSwgdCA9IHRoaXMua2V5RnJvbVByaXZhdGUodCwgaSksIGUgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgS2UoZSwgMTYpKTtcbiAgZm9yICh2YXIgcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCksIG8gPSB0LmdldFByaXZhdGUoKS50b0FycmF5KFwiYmVcIiwgcyksIGYgPSBlLnRvQXJyYXkoXCJiZVwiLCBzKSwgaCA9IG5ldyBMdSh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIGVudHJvcHk6IG8sXG4gICAgbm9uY2U6IGYsXG4gICAgcGVyczogbi5wZXJzLFxuICAgIHBlcnNFbmM6IG4ucGVyc0VuYyB8fCBcInV0ZjhcIlxuICB9KSwgZCA9IHRoaXMubi5zdWIobmV3IEtlKDEpKSwgdiA9IDA7IDsgdisrKSB7XG4gICAgdmFyIHcgPSBuLmsgPyBuLmsodikgOiBuZXcgS2UoaC5nZW5lcmF0ZSh0aGlzLm4uYnl0ZUxlbmd0aCgpKSk7XG4gICAgaWYgKHcgPSB0aGlzLl90cnVuY2F0ZVRvTih3LCAhMCksICEody5jbXBuKDEpIDw9IDAgfHwgdy5jbXAoZCkgPj0gMCkpIHtcbiAgICAgIHZhciBBID0gdGhpcy5nLm11bCh3KTtcbiAgICAgIGlmICghQS5pc0luZmluaXR5KCkpIHtcbiAgICAgICAgdmFyIEkgPSBBLmdldFgoKSwgRCA9IEkudW1vZCh0aGlzLm4pO1xuICAgICAgICBpZiAoRC5jbXBuKDApICE9PSAwKSB7XG4gICAgICAgICAgdmFyIE4gPSB3Lmludm0odGhpcy5uKS5tdWwoRC5tdWwodC5nZXRQcml2YXRlKCkpLmlhZGQoZSkpO1xuICAgICAgICAgIGlmIChOID0gTi51bW9kKHRoaXMubiksIE4uY21wbigwKSAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIGsgPSAoQS5nZXRZKCkuaXNPZGQoKSA/IDEgOiAwKSB8IChJLmNtcChEKSAhPT0gMCA/IDIgOiAwKTtcbiAgICAgICAgICAgIHJldHVybiBuLmNhbm9uaWNhbCAmJiBOLmNtcCh0aGlzLm5oKSA+IDAgJiYgKE4gPSB0aGlzLm4uc3ViKE4pLCBrIF49IDEpLCBuZXcgcGEoeyByOiBELCBzOiBOLCByZWNvdmVyeVBhcmFtOiBrIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmxyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbihlLCB0LCBpLCBuKSB7XG4gIGUgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgS2UoZSwgMTYpKSwgaSA9IHRoaXMua2V5RnJvbVB1YmxpYyhpLCBuKSwgdCA9IG5ldyBwYSh0LCBcImhleFwiKTtcbiAgdmFyIHMgPSB0LnIsIG8gPSB0LnM7XG4gIGlmIChzLmNtcG4oMSkgPCAwIHx8IHMuY21wKHRoaXMubikgPj0gMCB8fCBvLmNtcG4oMSkgPCAwIHx8IG8uY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gITE7XG4gIHZhciBmID0gby5pbnZtKHRoaXMubiksIGggPSBmLm11bChlKS51bW9kKHRoaXMubiksIGQgPSBmLm11bChzKS51bW9kKHRoaXMubiksIHY7XG4gIHJldHVybiB0aGlzLmN1cnZlLl9tYXh3ZWxsVHJpY2sgPyAodiA9IHRoaXMuZy5qbXVsQWRkKGgsIGkuZ2V0UHVibGljKCksIGQpLCB2LmlzSW5maW5pdHkoKSA/ICExIDogdi5lcVhUb1AocykpIDogKHYgPSB0aGlzLmcubXVsQWRkKGgsIGkuZ2V0UHVibGljKCksIGQpLCB2LmlzSW5maW5pdHkoKSA/ICExIDogdi5nZXRYKCkudW1vZCh0aGlzLm4pLmNtcChzKSA9PT0gMCk7XG59O1xubHIucHJvdG90eXBlLnJlY292ZXJQdWJLZXkgPSBmdW5jdGlvbihyLCBlLCB0LCBpKSB7XG4gIEZ1KCgzICYgdCkgPT09IHQsIFwiVGhlIHJlY292ZXJ5IHBhcmFtIGlzIG1vcmUgdGhhbiB0d28gYml0c1wiKSwgZSA9IG5ldyBwYShlLCBpKTtcbiAgdmFyIG4gPSB0aGlzLm4sIHMgPSBuZXcgS2UociksIG8gPSBlLnIsIGYgPSBlLnMsIGggPSB0ICYgMSwgZCA9IHQgPj4gMTtcbiAgaWYgKG8uY21wKHRoaXMuY3VydmUucC51bW9kKHRoaXMuY3VydmUubikpID49IDAgJiYgZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGVcIik7XG4gIGQgPyBvID0gdGhpcy5jdXJ2ZS5wb2ludEZyb21YKG8uYWRkKHRoaXMuY3VydmUubiksIGgpIDogbyA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChvLCBoKTtcbiAgdmFyIHYgPSBlLnIuaW52bShuKSwgdyA9IG4uc3ViKHMpLm11bCh2KS51bW9kKG4pLCBBID0gZi5tdWwodikudW1vZChuKTtcbiAgcmV0dXJuIHRoaXMuZy5tdWxBZGQodywgbywgQSk7XG59O1xubHIucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW0gPSBmdW5jdGlvbihyLCBlLCB0LCBpKSB7XG4gIGlmIChlID0gbmV3IHBhKGUsIGkpLCBlLnJlY292ZXJ5UGFyYW0gIT09IG51bGwpXG4gICAgcmV0dXJuIGUucmVjb3ZlcnlQYXJhbTtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA0OyBuKyspIHtcbiAgICB2YXIgcztcbiAgICB0cnkge1xuICAgICAgcyA9IHRoaXMucmVjb3ZlclB1YktleShyLCBlLCBuKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocy5lcSh0KSlcbiAgICAgIHJldHVybiBuO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHZhbGlkIHJlY292ZXJ5IGZhY3RvclwiKTtcbn07XG52YXIgT2cgPSB4bihmdW5jdGlvbihyLCBlKSB7XG4gIHZhciB0ID0gZTtcbiAgdC52ZXJzaW9uID0gXCI2LjUuNFwiLCB0LnV0aWxzID0gc3IsIHQucmFuZCA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKGJyb3JhbmQpKi9cbiAgZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWRcIik7XG4gIH0sIHQuY3VydmUgPSBPcywgdC5jdXJ2ZXMgPSBScywgdC5lYyA9IFBnLCB0LmVkZHNhID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoLi9lbGxpcHRpYy9lZGRzYSkqL1xuICBudWxsO1xufSksIFJnID0gT2cuZWM7XG5jb25zdCBOZyA9IFwic2lnbmluZy1rZXkvNS43LjBcIiwgRW8gPSBuZXcgaHQoTmcpO1xubGV0IEdhID0gbnVsbDtcbmZ1bmN0aW9uIENyKCkge1xuICByZXR1cm4gR2EgfHwgKEdhID0gbmV3IFJnKFwic2VjcDI1NmsxXCIpKSwgR2E7XG59XG5jbGFzcyBUZyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBUbih0aGlzLCBcImN1cnZlXCIsIFwic2VjcDI1NmsxXCIpLCBUbih0aGlzLCBcInByaXZhdGVLZXlcIiwgSnQoZSkpLCBxdih0aGlzLnByaXZhdGVLZXkpICE9PSAzMiAmJiBFby50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsIFwicHJpdmF0ZUtleVwiLCBcIltbIFJFREFDVEVEIF1dXCIpO1xuICAgIGNvbnN0IHQgPSBDcigpLmtleUZyb21Qcml2YXRlKHl0KHRoaXMucHJpdmF0ZUtleSkpO1xuICAgIFRuKHRoaXMsIFwicHVibGljS2V5XCIsIFwiMHhcIiArIHQuZ2V0UHVibGljKCExLCBcImhleFwiKSksIFRuKHRoaXMsIFwiY29tcHJlc3NlZFB1YmxpY0tleVwiLCBcIjB4XCIgKyB0LmdldFB1YmxpYyghMCwgXCJoZXhcIikpLCBUbih0aGlzLCBcIl9pc1NpZ25pbmdLZXlcIiwgITApO1xuICB9XG4gIF9hZGRQb2ludChlKSB7XG4gICAgY29uc3QgdCA9IENyKCkua2V5RnJvbVB1YmxpYyh5dCh0aGlzLnB1YmxpY0tleSkpLCBpID0gQ3IoKS5rZXlGcm9tUHVibGljKHl0KGUpKTtcbiAgICByZXR1cm4gXCIweFwiICsgdC5wdWIuYWRkKGkucHViKS5lbmNvZGVDb21wcmVzc2VkKFwiaGV4XCIpO1xuICB9XG4gIHNpZ25EaWdlc3QoZSkge1xuICAgIGNvbnN0IHQgPSBDcigpLmtleUZyb21Qcml2YXRlKHl0KHRoaXMucHJpdmF0ZUtleSkpLCBpID0geXQoZSk7XG4gICAgaS5sZW5ndGggIT09IDMyICYmIEVvLnRocm93QXJndW1lbnRFcnJvcihcImJhZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGUpO1xuICAgIGNvbnN0IG4gPSB0LnNpZ24oaSwgeyBjYW5vbmljYWw6ICEwIH0pO1xuICAgIHJldHVybiB2dSh7XG4gICAgICByZWNvdmVyeVBhcmFtOiBuLnJlY292ZXJ5UGFyYW0sXG4gICAgICByOiBobihcIjB4XCIgKyBuLnIudG9TdHJpbmcoMTYpLCAzMiksXG4gICAgICBzOiBobihcIjB4XCIgKyBuLnMudG9TdHJpbmcoMTYpLCAzMilcbiAgICB9KTtcbiAgfVxuICBjb21wdXRlU2hhcmVkU2VjcmV0KGUpIHtcbiAgICBjb25zdCB0ID0gQ3IoKS5rZXlGcm9tUHJpdmF0ZSh5dCh0aGlzLnByaXZhdGVLZXkpKSwgaSA9IENyKCkua2V5RnJvbVB1YmxpYyh5dChxdShlKSkpO1xuICAgIHJldHVybiBobihcIjB4XCIgKyB0LmRlcml2ZShpLmdldFB1YmxpYygpKS50b1N0cmluZygxNiksIDMyKTtcbiAgfVxuICBzdGF0aWMgaXNTaWduaW5nS2V5KGUpIHtcbiAgICByZXR1cm4gISEoZSAmJiBlLl9pc1NpZ25pbmdLZXkpO1xuICB9XG59XG5mdW5jdGlvbiBDZyhyLCBlKSB7XG4gIGNvbnN0IHQgPSB2dShlKSwgaSA9IHsgcjogeXQodC5yKSwgczogeXQodC5zKSB9O1xuICByZXR1cm4gXCIweFwiICsgQ3IoKS5yZWNvdmVyUHViS2V5KHl0KHIpLCBpLCB0LnJlY292ZXJ5UGFyYW0pLmVuY29kZShcImhleFwiLCAhMSk7XG59XG5mdW5jdGlvbiBxdShyLCBlKSB7XG4gIGNvbnN0IHQgPSB5dChyKTtcbiAgaWYgKHQubGVuZ3RoID09PSAzMikge1xuICAgIGNvbnN0IGkgPSBuZXcgVGcodCk7XG4gICAgcmV0dXJuIGUgPyBcIjB4XCIgKyBDcigpLmtleUZyb21Qcml2YXRlKHQpLmdldFB1YmxpYyghMCwgXCJoZXhcIikgOiBpLnB1YmxpY0tleTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodC5sZW5ndGggPT09IDMzKVxuICAgICAgcmV0dXJuIGUgPyBKdCh0KSA6IFwiMHhcIiArIENyKCkua2V5RnJvbVB1YmxpYyh0KS5nZXRQdWJsaWMoITEsIFwiaGV4XCIpO1xuICAgIGlmICh0Lmxlbmd0aCA9PT0gNjUpXG4gICAgICByZXR1cm4gZSA/IFwiMHhcIiArIENyKCkua2V5RnJvbVB1YmxpYyh0KS5nZXRQdWJsaWMoITAsIFwiaGV4XCIpIDogSnQodCk7XG4gIH1cbiAgcmV0dXJuIEVvLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcHVibGljIG9yIHByaXZhdGUga2V5XCIsIFwia2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcbn1cbnZhciBwYztcbihmdW5jdGlvbihyKSB7XG4gIHJbci5sZWdhY3kgPSAwXSA9IFwibGVnYWN5XCIsIHJbci5laXAyOTMwID0gMV0gPSBcImVpcDI5MzBcIiwgcltyLmVpcDE1NTkgPSAyXSA9IFwiZWlwMTU1OVwiO1xufSkocGMgfHwgKHBjID0ge30pKTtcbmZ1bmN0aW9uICRnKHIpIHtcbiAgY29uc3QgZSA9IHF1KHIpO1xuICByZXR1cm4gSnYoc2MocW8oc2MoZSwgMSkpLCAxMikpO1xufVxuZnVuY3Rpb24gTGcociwgZSkge1xuICByZXR1cm4gJGcoQ2coeXQociksIGUpKTtcbn1cbnZhciBLbyA9IHt9LCB2YSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgRnQgPSBWZSwgU28gPSBuciwgRmcgPSAyMDtcbmZ1bmN0aW9uIHFnKHIsIGUsIHQpIHtcbiAgZm9yICh2YXIgaSA9IDE2MzQ3NjA4MDUsIG4gPSA4NTc3NjA4NzgsIHMgPSAyMDM2NDc3MjM0LCBvID0gMTc5NzI4NTIzNiwgZiA9IHRbM10gPDwgMjQgfCB0WzJdIDw8IDE2IHwgdFsxXSA8PCA4IHwgdFswXSwgaCA9IHRbN10gPDwgMjQgfCB0WzZdIDw8IDE2IHwgdFs1XSA8PCA4IHwgdFs0XSwgZCA9IHRbMTFdIDw8IDI0IHwgdFsxMF0gPDwgMTYgfCB0WzldIDw8IDggfCB0WzhdLCB2ID0gdFsxNV0gPDwgMjQgfCB0WzE0XSA8PCAxNiB8IHRbMTNdIDw8IDggfCB0WzEyXSwgdyA9IHRbMTldIDw8IDI0IHwgdFsxOF0gPDwgMTYgfCB0WzE3XSA8PCA4IHwgdFsxNl0sIEEgPSB0WzIzXSA8PCAyNCB8IHRbMjJdIDw8IDE2IHwgdFsyMV0gPDwgOCB8IHRbMjBdLCBJID0gdFsyN10gPDwgMjQgfCB0WzI2XSA8PCAxNiB8IHRbMjVdIDw8IDggfCB0WzI0XSwgRCA9IHRbMzFdIDw8IDI0IHwgdFszMF0gPDwgMTYgfCB0WzI5XSA8PCA4IHwgdFsyOF0sIE4gPSBlWzNdIDw8IDI0IHwgZVsyXSA8PCAxNiB8IGVbMV0gPDwgOCB8IGVbMF0sIGsgPSBlWzddIDw8IDI0IHwgZVs2XSA8PCAxNiB8IGVbNV0gPDwgOCB8IGVbNF0sIGogPSBlWzExXSA8PCAyNCB8IGVbMTBdIDw8IDE2IHwgZVs5XSA8PCA4IHwgZVs4XSwgVCA9IGVbMTVdIDw8IDI0IHwgZVsxNF0gPDwgMTYgfCBlWzEzXSA8PCA4IHwgZVsxMl0sIEsgPSBpLCAkID0gbiwgeiA9IHMsIEIgPSBvLCBfID0gZiwgUiA9IGgsIEogPSBkLCBRID0gdiwgTyA9IHcsIHAgPSBBLCBsID0gSSwgYSA9IEQsIGMgPSBOLCBiID0gaywgRSA9IGosIFMgPSBULCB4ID0gMDsgeCA8IEZnOyB4ICs9IDIpXG4gICAgSyA9IEsgKyBfIHwgMCwgYyBePSBLLCBjID0gYyA+Pj4gMzIgLSAxNiB8IGMgPDwgMTYsIE8gPSBPICsgYyB8IDAsIF8gXj0gTywgXyA9IF8gPj4+IDMyIC0gMTIgfCBfIDw8IDEyLCAkID0gJCArIFIgfCAwLCBiIF49ICQsIGIgPSBiID4+PiAzMiAtIDE2IHwgYiA8PCAxNiwgcCA9IHAgKyBiIHwgMCwgUiBePSBwLCBSID0gUiA+Pj4gMzIgLSAxMiB8IFIgPDwgMTIsIHogPSB6ICsgSiB8IDAsIEUgXj0geiwgRSA9IEUgPj4+IDMyIC0gMTYgfCBFIDw8IDE2LCBsID0gbCArIEUgfCAwLCBKIF49IGwsIEogPSBKID4+PiAzMiAtIDEyIHwgSiA8PCAxMiwgQiA9IEIgKyBRIHwgMCwgUyBePSBCLCBTID0gUyA+Pj4gMzIgLSAxNiB8IFMgPDwgMTYsIGEgPSBhICsgUyB8IDAsIFEgXj0gYSwgUSA9IFEgPj4+IDMyIC0gMTIgfCBRIDw8IDEyLCB6ID0geiArIEogfCAwLCBFIF49IHosIEUgPSBFID4+PiAzMiAtIDggfCBFIDw8IDgsIGwgPSBsICsgRSB8IDAsIEogXj0gbCwgSiA9IEogPj4+IDMyIC0gNyB8IEogPDwgNywgQiA9IEIgKyBRIHwgMCwgUyBePSBCLCBTID0gUyA+Pj4gMzIgLSA4IHwgUyA8PCA4LCBhID0gYSArIFMgfCAwLCBRIF49IGEsIFEgPSBRID4+PiAzMiAtIDcgfCBRIDw8IDcsICQgPSAkICsgUiB8IDAsIGIgXj0gJCwgYiA9IGIgPj4+IDMyIC0gOCB8IGIgPDwgOCwgcCA9IHAgKyBiIHwgMCwgUiBePSBwLCBSID0gUiA+Pj4gMzIgLSA3IHwgUiA8PCA3LCBLID0gSyArIF8gfCAwLCBjIF49IEssIGMgPSBjID4+PiAzMiAtIDggfCBjIDw8IDgsIE8gPSBPICsgYyB8IDAsIF8gXj0gTywgXyA9IF8gPj4+IDMyIC0gNyB8IF8gPDwgNywgSyA9IEsgKyBSIHwgMCwgUyBePSBLLCBTID0gUyA+Pj4gMzIgLSAxNiB8IFMgPDwgMTYsIGwgPSBsICsgUyB8IDAsIFIgXj0gbCwgUiA9IFIgPj4+IDMyIC0gMTIgfCBSIDw8IDEyLCAkID0gJCArIEogfCAwLCBjIF49ICQsIGMgPSBjID4+PiAzMiAtIDE2IHwgYyA8PCAxNiwgYSA9IGEgKyBjIHwgMCwgSiBePSBhLCBKID0gSiA+Pj4gMzIgLSAxMiB8IEogPDwgMTIsIHogPSB6ICsgUSB8IDAsIGIgXj0geiwgYiA9IGIgPj4+IDMyIC0gMTYgfCBiIDw8IDE2LCBPID0gTyArIGIgfCAwLCBRIF49IE8sIFEgPSBRID4+PiAzMiAtIDEyIHwgUSA8PCAxMiwgQiA9IEIgKyBfIHwgMCwgRSBePSBCLCBFID0gRSA+Pj4gMzIgLSAxNiB8IEUgPDwgMTYsIHAgPSBwICsgRSB8IDAsIF8gXj0gcCwgXyA9IF8gPj4+IDMyIC0gMTIgfCBfIDw8IDEyLCB6ID0geiArIFEgfCAwLCBiIF49IHosIGIgPSBiID4+PiAzMiAtIDggfCBiIDw8IDgsIE8gPSBPICsgYiB8IDAsIFEgXj0gTywgUSA9IFEgPj4+IDMyIC0gNyB8IFEgPDwgNywgQiA9IEIgKyBfIHwgMCwgRSBePSBCLCBFID0gRSA+Pj4gMzIgLSA4IHwgRSA8PCA4LCBwID0gcCArIEUgfCAwLCBfIF49IHAsIF8gPSBfID4+PiAzMiAtIDcgfCBfIDw8IDcsICQgPSAkICsgSiB8IDAsIGMgXj0gJCwgYyA9IGMgPj4+IDMyIC0gOCB8IGMgPDwgOCwgYSA9IGEgKyBjIHwgMCwgSiBePSBhLCBKID0gSiA+Pj4gMzIgLSA3IHwgSiA8PCA3LCBLID0gSyArIFIgfCAwLCBTIF49IEssIFMgPSBTID4+PiAzMiAtIDggfCBTIDw8IDgsIGwgPSBsICsgUyB8IDAsIFIgXj0gbCwgUiA9IFIgPj4+IDMyIC0gNyB8IFIgPDwgNztcbiAgRnQud3JpdGVVaW50MzJMRShLICsgaSB8IDAsIHIsIDApLCBGdC53cml0ZVVpbnQzMkxFKCQgKyBuIHwgMCwgciwgNCksIEZ0LndyaXRlVWludDMyTEUoeiArIHMgfCAwLCByLCA4KSwgRnQud3JpdGVVaW50MzJMRShCICsgbyB8IDAsIHIsIDEyKSwgRnQud3JpdGVVaW50MzJMRShfICsgZiB8IDAsIHIsIDE2KSwgRnQud3JpdGVVaW50MzJMRShSICsgaCB8IDAsIHIsIDIwKSwgRnQud3JpdGVVaW50MzJMRShKICsgZCB8IDAsIHIsIDI0KSwgRnQud3JpdGVVaW50MzJMRShRICsgdiB8IDAsIHIsIDI4KSwgRnQud3JpdGVVaW50MzJMRShPICsgdyB8IDAsIHIsIDMyKSwgRnQud3JpdGVVaW50MzJMRShwICsgQSB8IDAsIHIsIDM2KSwgRnQud3JpdGVVaW50MzJMRShsICsgSSB8IDAsIHIsIDQwKSwgRnQud3JpdGVVaW50MzJMRShhICsgRCB8IDAsIHIsIDQ0KSwgRnQud3JpdGVVaW50MzJMRShjICsgTiB8IDAsIHIsIDQ4KSwgRnQud3JpdGVVaW50MzJMRShiICsgayB8IDAsIHIsIDUyKSwgRnQud3JpdGVVaW50MzJMRShFICsgaiB8IDAsIHIsIDU2KSwgRnQud3JpdGVVaW50MzJMRShTICsgVCB8IDAsIHIsIDYwKTtcbn1cbmZ1bmN0aW9uIFV1KHIsIGUsIHQsIGksIG4pIHtcbiAgaWYgKG4gPT09IHZvaWQgMCAmJiAobiA9IDApLCByLmxlbmd0aCAhPT0gMzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhQ2hhOiBrZXkgc2l6ZSBtdXN0IGJlIDMyIGJ5dGVzXCIpO1xuICBpZiAoaS5sZW5ndGggPCB0Lmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFDaGE6IGRlc3RpbmF0aW9uIGlzIHNob3J0ZXIgdGhhbiBzb3VyY2VcIik7XG4gIHZhciBzLCBvO1xuICBpZiAobiA9PT0gMCkge1xuICAgIGlmIChlLmxlbmd0aCAhPT0gOCAmJiBlLmxlbmd0aCAhPT0gMTIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFDaGEgbm9uY2UgbXVzdCBiZSA4IG9yIDEyIGJ5dGVzXCIpO1xuICAgIHMgPSBuZXcgVWludDhBcnJheSgxNiksIG8gPSBzLmxlbmd0aCAtIGUubGVuZ3RoLCBzLnNldChlLCBvKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZS5sZW5ndGggIT09IDE2KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhQ2hhIG5vbmNlIHdpdGggY291bnRlciBtdXN0IGJlIDE2IGJ5dGVzXCIpO1xuICAgIHMgPSBlLCBvID0gbjtcbiAgfVxuICBmb3IgKHZhciBmID0gbmV3IFVpbnQ4QXJyYXkoNjQpLCBoID0gMDsgaCA8IHQubGVuZ3RoOyBoICs9IDY0KSB7XG4gICAgcWcoZiwgcywgcik7XG4gICAgZm9yICh2YXIgZCA9IGg7IGQgPCBoICsgNjQgJiYgZCA8IHQubGVuZ3RoOyBkKyspXG4gICAgICBpW2RdID0gdFtkXSBeIGZbZCAtIGhdO1xuICAgIHpnKHMsIDAsIG8pO1xuICB9XG4gIHJldHVybiBTby53aXBlKGYpLCBuID09PSAwICYmIFNvLndpcGUocyksIGk7XG59XG52YS5zdHJlYW1YT1IgPSBVdTtcbmZ1bmN0aW9uIFVnKHIsIGUsIHQsIGkpIHtcbiAgcmV0dXJuIGkgPT09IHZvaWQgMCAmJiAoaSA9IDApLCBTby53aXBlKHQpLCBVdShyLCBlLCB0LCB0LCBpKTtcbn1cbnZhLnN0cmVhbSA9IFVnO1xuZnVuY3Rpb24gemcociwgZSwgdCkge1xuICBmb3IgKHZhciBpID0gMTsgdC0tOyApXG4gICAgaSA9IGkgKyAocltlXSAmIDI1NSkgfCAwLCByW2VdID0gaSAmIDI1NSwgaSA+Pj49IDgsIGUrKztcbiAgaWYgKGkgPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNoYUNoYTogY291bnRlciBvdmVyZmxvd1wiKTtcbn1cbnZhciB6dSA9IHt9LCBNaSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1pLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5mdW5jdGlvbiBCZyhyLCBlLCB0KSB7XG4gIHJldHVybiB+KHIgLSAxKSAmIGUgfCByIC0gMSAmIHQ7XG59XG5NaS5zZWxlY3QgPSBCZztcbmZ1bmN0aW9uIGtnKHIsIGUpIHtcbiAgcmV0dXJuIChyIHwgMCkgLSAoZSB8IDApIC0gMSA+Pj4gMzEgJiAxO1xufVxuTWkubGVzc09yRXF1YWwgPSBrZztcbmZ1bmN0aW9uIEJ1KHIsIGUpIHtcbiAgaWYgKHIubGVuZ3RoICE9PSBlLmxlbmd0aClcbiAgICByZXR1cm4gMDtcbiAgZm9yICh2YXIgdCA9IDAsIGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKylcbiAgICB0IHw9IHJbaV0gXiBlW2ldO1xuICByZXR1cm4gMSAmIHQgLSAxID4+PiA4O1xufVxuTWkuY29tcGFyZSA9IEJ1O1xuZnVuY3Rpb24gamcociwgZSkge1xuICByZXR1cm4gci5sZW5ndGggPT09IDAgfHwgZS5sZW5ndGggPT09IDAgPyAhMSA6IEJ1KHIsIGUpICE9PSAwO1xufVxuTWkuZXF1YWwgPSBqZztcbihmdW5jdGlvbihyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIHZhciBlID0gTWksIHQgPSBucjtcbiAgci5ESUdFU1RfTEVOR1RIID0gMTY7XG4gIHZhciBpID0gKFxuICAgIC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIG8oZikge1xuICAgICAgICB0aGlzLmRpZ2VzdExlbmd0aCA9IHIuRElHRVNUX0xFTkdUSCwgdGhpcy5fYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMTYpLCB0aGlzLl9yID0gbmV3IFVpbnQxNkFycmF5KDEwKSwgdGhpcy5faCA9IG5ldyBVaW50MTZBcnJheSgxMCksIHRoaXMuX3BhZCA9IG5ldyBVaW50MTZBcnJheSg4KSwgdGhpcy5fbGVmdG92ZXIgPSAwLCB0aGlzLl9maW4gPSAwLCB0aGlzLl9maW5pc2hlZCA9ICExO1xuICAgICAgICB2YXIgaCA9IGZbMF0gfCBmWzFdIDw8IDg7XG4gICAgICAgIHRoaXMuX3JbMF0gPSBoICYgODE5MTtcbiAgICAgICAgdmFyIGQgPSBmWzJdIHwgZlszXSA8PCA4O1xuICAgICAgICB0aGlzLl9yWzFdID0gKGggPj4+IDEzIHwgZCA8PCAzKSAmIDgxOTE7XG4gICAgICAgIHZhciB2ID0gZls0XSB8IGZbNV0gPDwgODtcbiAgICAgICAgdGhpcy5fclsyXSA9IChkID4+PiAxMCB8IHYgPDwgNikgJiA3OTM5O1xuICAgICAgICB2YXIgdyA9IGZbNl0gfCBmWzddIDw8IDg7XG4gICAgICAgIHRoaXMuX3JbM10gPSAodiA+Pj4gNyB8IHcgPDwgOSkgJiA4MTkxO1xuICAgICAgICB2YXIgQSA9IGZbOF0gfCBmWzldIDw8IDg7XG4gICAgICAgIHRoaXMuX3JbNF0gPSAodyA+Pj4gNCB8IEEgPDwgMTIpICYgMjU1LCB0aGlzLl9yWzVdID0gQSA+Pj4gMSAmIDgxOTA7XG4gICAgICAgIHZhciBJID0gZlsxMF0gfCBmWzExXSA8PCA4O1xuICAgICAgICB0aGlzLl9yWzZdID0gKEEgPj4+IDE0IHwgSSA8PCAyKSAmIDgxOTE7XG4gICAgICAgIHZhciBEID0gZlsxMl0gfCBmWzEzXSA8PCA4O1xuICAgICAgICB0aGlzLl9yWzddID0gKEkgPj4+IDExIHwgRCA8PCA1KSAmIDgwNjU7XG4gICAgICAgIHZhciBOID0gZlsxNF0gfCBmWzE1XSA8PCA4O1xuICAgICAgICB0aGlzLl9yWzhdID0gKEQgPj4+IDggfCBOIDw8IDgpICYgODE5MSwgdGhpcy5fcls5XSA9IE4gPj4+IDUgJiAxMjcsIHRoaXMuX3BhZFswXSA9IGZbMTZdIHwgZlsxN10gPDwgOCwgdGhpcy5fcGFkWzFdID0gZlsxOF0gfCBmWzE5XSA8PCA4LCB0aGlzLl9wYWRbMl0gPSBmWzIwXSB8IGZbMjFdIDw8IDgsIHRoaXMuX3BhZFszXSA9IGZbMjJdIHwgZlsyM10gPDwgOCwgdGhpcy5fcGFkWzRdID0gZlsyNF0gfCBmWzI1XSA8PCA4LCB0aGlzLl9wYWRbNV0gPSBmWzI2XSB8IGZbMjddIDw8IDgsIHRoaXMuX3BhZFs2XSA9IGZbMjhdIHwgZlsyOV0gPDwgOCwgdGhpcy5fcGFkWzddID0gZlszMF0gfCBmWzMxXSA8PCA4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG8ucHJvdG90eXBlLl9ibG9ja3MgPSBmdW5jdGlvbihmLCBoLCBkKSB7XG4gICAgICAgIGZvciAodmFyIHYgPSB0aGlzLl9maW4gPyAwIDogMjA0OCwgdyA9IHRoaXMuX2hbMF0sIEEgPSB0aGlzLl9oWzFdLCBJID0gdGhpcy5faFsyXSwgRCA9IHRoaXMuX2hbM10sIE4gPSB0aGlzLl9oWzRdLCBrID0gdGhpcy5faFs1XSwgaiA9IHRoaXMuX2hbNl0sIFQgPSB0aGlzLl9oWzddLCBLID0gdGhpcy5faFs4XSwgJCA9IHRoaXMuX2hbOV0sIHogPSB0aGlzLl9yWzBdLCBCID0gdGhpcy5fclsxXSwgXyA9IHRoaXMuX3JbMl0sIFIgPSB0aGlzLl9yWzNdLCBKID0gdGhpcy5fcls0XSwgUSA9IHRoaXMuX3JbNV0sIE8gPSB0aGlzLl9yWzZdLCBwID0gdGhpcy5fcls3XSwgbCA9IHRoaXMuX3JbOF0sIGEgPSB0aGlzLl9yWzldOyBkID49IDE2OyApIHtcbiAgICAgICAgICB2YXIgYyA9IGZbaCArIDBdIHwgZltoICsgMV0gPDwgODtcbiAgICAgICAgICB3ICs9IGMgJiA4MTkxO1xuICAgICAgICAgIHZhciBiID0gZltoICsgMl0gfCBmW2ggKyAzXSA8PCA4O1xuICAgICAgICAgIEEgKz0gKGMgPj4+IDEzIHwgYiA8PCAzKSAmIDgxOTE7XG4gICAgICAgICAgdmFyIEUgPSBmW2ggKyA0XSB8IGZbaCArIDVdIDw8IDg7XG4gICAgICAgICAgSSArPSAoYiA+Pj4gMTAgfCBFIDw8IDYpICYgODE5MTtcbiAgICAgICAgICB2YXIgUyA9IGZbaCArIDZdIHwgZltoICsgN10gPDwgODtcbiAgICAgICAgICBEICs9IChFID4+PiA3IHwgUyA8PCA5KSAmIDgxOTE7XG4gICAgICAgICAgdmFyIHggPSBmW2ggKyA4XSB8IGZbaCArIDldIDw8IDg7XG4gICAgICAgICAgTiArPSAoUyA+Pj4gNCB8IHggPDwgMTIpICYgODE5MSwgayArPSB4ID4+PiAxICYgODE5MTtcbiAgICAgICAgICB2YXIgdSA9IGZbaCArIDEwXSB8IGZbaCArIDExXSA8PCA4O1xuICAgICAgICAgIGogKz0gKHggPj4+IDE0IHwgdSA8PCAyKSAmIDgxOTE7XG4gICAgICAgICAgdmFyIG0gPSBmW2ggKyAxMl0gfCBmW2ggKyAxM10gPDwgODtcbiAgICAgICAgICBUICs9ICh1ID4+PiAxMSB8IG0gPDwgNSkgJiA4MTkxO1xuICAgICAgICAgIHZhciBnID0gZltoICsgMTRdIHwgZltoICsgMTVdIDw8IDg7XG4gICAgICAgICAgSyArPSAobSA+Pj4gOCB8IGcgPDwgOCkgJiA4MTkxLCAkICs9IGcgPj4+IDUgfCB2O1xuICAgICAgICAgIHZhciBQID0gMCwgRyA9IFA7XG4gICAgICAgICAgRyArPSB3ICogeiwgRyArPSBBICogKDUgKiBhKSwgRyArPSBJICogKDUgKiBsKSwgRyArPSBEICogKDUgKiBwKSwgRyArPSBOICogKDUgKiBPKSwgUCA9IEcgPj4+IDEzLCBHICY9IDgxOTEsIEcgKz0gayAqICg1ICogUSksIEcgKz0gaiAqICg1ICogSiksIEcgKz0gVCAqICg1ICogUiksIEcgKz0gSyAqICg1ICogXyksIEcgKz0gJCAqICg1ICogQiksIFAgKz0gRyA+Pj4gMTMsIEcgJj0gODE5MTtcbiAgICAgICAgICB2YXIgTSA9IFA7XG4gICAgICAgICAgTSArPSB3ICogQiwgTSArPSBBICogeiwgTSArPSBJICogKDUgKiBhKSwgTSArPSBEICogKDUgKiBsKSwgTSArPSBOICogKDUgKiBwKSwgUCA9IE0gPj4+IDEzLCBNICY9IDgxOTEsIE0gKz0gayAqICg1ICogTyksIE0gKz0gaiAqICg1ICogUSksIE0gKz0gVCAqICg1ICogSiksIE0gKz0gSyAqICg1ICogUiksIE0gKz0gJCAqICg1ICogXyksIFAgKz0gTSA+Pj4gMTMsIE0gJj0gODE5MTtcbiAgICAgICAgICB2YXIgSCA9IFA7XG4gICAgICAgICAgSCArPSB3ICogXywgSCArPSBBICogQiwgSCArPSBJICogeiwgSCArPSBEICogKDUgKiBhKSwgSCArPSBOICogKDUgKiBsKSwgUCA9IEggPj4+IDEzLCBIICY9IDgxOTEsIEggKz0gayAqICg1ICogcCksIEggKz0gaiAqICg1ICogTyksIEggKz0gVCAqICg1ICogUSksIEggKz0gSyAqICg1ICogSiksIEggKz0gJCAqICg1ICogUiksIFAgKz0gSCA+Pj4gMTMsIEggJj0gODE5MTtcbiAgICAgICAgICB2YXIgQyA9IFA7XG4gICAgICAgICAgQyArPSB3ICogUiwgQyArPSBBICogXywgQyArPSBJICogQiwgQyArPSBEICogeiwgQyArPSBOICogKDUgKiBhKSwgUCA9IEMgPj4+IDEzLCBDICY9IDgxOTEsIEMgKz0gayAqICg1ICogbCksIEMgKz0gaiAqICg1ICogcCksIEMgKz0gVCAqICg1ICogTyksIEMgKz0gSyAqICg1ICogUSksIEMgKz0gJCAqICg1ICogSiksIFAgKz0gQyA+Pj4gMTMsIEMgJj0gODE5MTtcbiAgICAgICAgICB2YXIgcSA9IFA7XG4gICAgICAgICAgcSArPSB3ICogSiwgcSArPSBBICogUiwgcSArPSBJICogXywgcSArPSBEICogQiwgcSArPSBOICogeiwgUCA9IHEgPj4+IDEzLCBxICY9IDgxOTEsIHEgKz0gayAqICg1ICogYSksIHEgKz0gaiAqICg1ICogbCksIHEgKz0gVCAqICg1ICogcCksIHEgKz0gSyAqICg1ICogTyksIHEgKz0gJCAqICg1ICogUSksIFAgKz0gcSA+Pj4gMTMsIHEgJj0gODE5MTtcbiAgICAgICAgICB2YXIgTCA9IFA7XG4gICAgICAgICAgTCArPSB3ICogUSwgTCArPSBBICogSiwgTCArPSBJICogUiwgTCArPSBEICogXywgTCArPSBOICogQiwgUCA9IEwgPj4+IDEzLCBMICY9IDgxOTEsIEwgKz0gayAqIHosIEwgKz0gaiAqICg1ICogYSksIEwgKz0gVCAqICg1ICogbCksIEwgKz0gSyAqICg1ICogcCksIEwgKz0gJCAqICg1ICogTyksIFAgKz0gTCA+Pj4gMTMsIEwgJj0gODE5MTtcbiAgICAgICAgICB2YXIgeSA9IFA7XG4gICAgICAgICAgeSArPSB3ICogTywgeSArPSBBICogUSwgeSArPSBJICogSiwgeSArPSBEICogUiwgeSArPSBOICogXywgUCA9IHkgPj4+IDEzLCB5ICY9IDgxOTEsIHkgKz0gayAqIEIsIHkgKz0gaiAqIHosIHkgKz0gVCAqICg1ICogYSksIHkgKz0gSyAqICg1ICogbCksIHkgKz0gJCAqICg1ICogcCksIFAgKz0geSA+Pj4gMTMsIHkgJj0gODE5MTtcbiAgICAgICAgICB2YXIgRiA9IFA7XG4gICAgICAgICAgRiArPSB3ICogcCwgRiArPSBBICogTywgRiArPSBJICogUSwgRiArPSBEICogSiwgRiArPSBOICogUiwgUCA9IEYgPj4+IDEzLCBGICY9IDgxOTEsIEYgKz0gayAqIF8sIEYgKz0gaiAqIEIsIEYgKz0gVCAqIHosIEYgKz0gSyAqICg1ICogYSksIEYgKz0gJCAqICg1ICogbCksIFAgKz0gRiA+Pj4gMTMsIEYgJj0gODE5MTtcbiAgICAgICAgICB2YXIgVyA9IFA7XG4gICAgICAgICAgVyArPSB3ICogbCwgVyArPSBBICogcCwgVyArPSBJICogTywgVyArPSBEICogUSwgVyArPSBOICogSiwgUCA9IFcgPj4+IDEzLCBXICY9IDgxOTEsIFcgKz0gayAqIFIsIFcgKz0gaiAqIF8sIFcgKz0gVCAqIEIsIFcgKz0gSyAqIHosIFcgKz0gJCAqICg1ICogYSksIFAgKz0gVyA+Pj4gMTMsIFcgJj0gODE5MTtcbiAgICAgICAgICB2YXIgWSA9IFA7XG4gICAgICAgICAgWSArPSB3ICogYSwgWSArPSBBICogbCwgWSArPSBJICogcCwgWSArPSBEICogTywgWSArPSBOICogUSwgUCA9IFkgPj4+IDEzLCBZICY9IDgxOTEsIFkgKz0gayAqIEosIFkgKz0gaiAqIFIsIFkgKz0gVCAqIF8sIFkgKz0gSyAqIEIsIFkgKz0gJCAqIHosIFAgKz0gWSA+Pj4gMTMsIFkgJj0gODE5MSwgUCA9IChQIDw8IDIpICsgUCB8IDAsIFAgPSBQICsgRyB8IDAsIEcgPSBQICYgODE5MSwgUCA9IFAgPj4+IDEzLCBNICs9IFAsIHcgPSBHLCBBID0gTSwgSSA9IEgsIEQgPSBDLCBOID0gcSwgayA9IEwsIGogPSB5LCBUID0gRiwgSyA9IFcsICQgPSBZLCBoICs9IDE2LCBkIC09IDE2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hbMF0gPSB3LCB0aGlzLl9oWzFdID0gQSwgdGhpcy5faFsyXSA9IEksIHRoaXMuX2hbM10gPSBELCB0aGlzLl9oWzRdID0gTiwgdGhpcy5faFs1XSA9IGssIHRoaXMuX2hbNl0gPSBqLCB0aGlzLl9oWzddID0gVCwgdGhpcy5faFs4XSA9IEssIHRoaXMuX2hbOV0gPSAkO1xuICAgICAgfSwgby5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oZiwgaCkge1xuICAgICAgICBoID09PSB2b2lkIDAgJiYgKGggPSAwKTtcbiAgICAgICAgdmFyIGQgPSBuZXcgVWludDE2QXJyYXkoMTApLCB2LCB3LCBBLCBJO1xuICAgICAgICBpZiAodGhpcy5fbGVmdG92ZXIpIHtcbiAgICAgICAgICBmb3IgKEkgPSB0aGlzLl9sZWZ0b3ZlciwgdGhpcy5fYnVmZmVyW0krK10gPSAxOyBJIDwgMTY7IEkrKylcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlcltJXSA9IDA7XG4gICAgICAgICAgdGhpcy5fZmluID0gMSwgdGhpcy5fYmxvY2tzKHRoaXMuX2J1ZmZlciwgMCwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodiA9IHRoaXMuX2hbMV0gPj4+IDEzLCB0aGlzLl9oWzFdICY9IDgxOTEsIEkgPSAyOyBJIDwgMTA7IEkrKylcbiAgICAgICAgICB0aGlzLl9oW0ldICs9IHYsIHYgPSB0aGlzLl9oW0ldID4+PiAxMywgdGhpcy5faFtJXSAmPSA4MTkxO1xuICAgICAgICBmb3IgKHRoaXMuX2hbMF0gKz0gdiAqIDUsIHYgPSB0aGlzLl9oWzBdID4+PiAxMywgdGhpcy5faFswXSAmPSA4MTkxLCB0aGlzLl9oWzFdICs9IHYsIHYgPSB0aGlzLl9oWzFdID4+PiAxMywgdGhpcy5faFsxXSAmPSA4MTkxLCB0aGlzLl9oWzJdICs9IHYsIGRbMF0gPSB0aGlzLl9oWzBdICsgNSwgdiA9IGRbMF0gPj4+IDEzLCBkWzBdICY9IDgxOTEsIEkgPSAxOyBJIDwgMTA7IEkrKylcbiAgICAgICAgICBkW0ldID0gdGhpcy5faFtJXSArIHYsIHYgPSBkW0ldID4+PiAxMywgZFtJXSAmPSA4MTkxO1xuICAgICAgICBmb3IgKGRbOV0gLT0gODE5MiwgdyA9ICh2IF4gMSkgLSAxLCBJID0gMDsgSSA8IDEwOyBJKyspXG4gICAgICAgICAgZFtJXSAmPSB3O1xuICAgICAgICBmb3IgKHcgPSB+dywgSSA9IDA7IEkgPCAxMDsgSSsrKVxuICAgICAgICAgIHRoaXMuX2hbSV0gPSB0aGlzLl9oW0ldICYgdyB8IGRbSV07XG4gICAgICAgIGZvciAodGhpcy5faFswXSA9ICh0aGlzLl9oWzBdIHwgdGhpcy5faFsxXSA8PCAxMykgJiA2NTUzNSwgdGhpcy5faFsxXSA9ICh0aGlzLl9oWzFdID4+PiAzIHwgdGhpcy5faFsyXSA8PCAxMCkgJiA2NTUzNSwgdGhpcy5faFsyXSA9ICh0aGlzLl9oWzJdID4+PiA2IHwgdGhpcy5faFszXSA8PCA3KSAmIDY1NTM1LCB0aGlzLl9oWzNdID0gKHRoaXMuX2hbM10gPj4+IDkgfCB0aGlzLl9oWzRdIDw8IDQpICYgNjU1MzUsIHRoaXMuX2hbNF0gPSAodGhpcy5faFs0XSA+Pj4gMTIgfCB0aGlzLl9oWzVdIDw8IDEgfCB0aGlzLl9oWzZdIDw8IDE0KSAmIDY1NTM1LCB0aGlzLl9oWzVdID0gKHRoaXMuX2hbNl0gPj4+IDIgfCB0aGlzLl9oWzddIDw8IDExKSAmIDY1NTM1LCB0aGlzLl9oWzZdID0gKHRoaXMuX2hbN10gPj4+IDUgfCB0aGlzLl9oWzhdIDw8IDgpICYgNjU1MzUsIHRoaXMuX2hbN10gPSAodGhpcy5faFs4XSA+Pj4gOCB8IHRoaXMuX2hbOV0gPDwgNSkgJiA2NTUzNSwgQSA9IHRoaXMuX2hbMF0gKyB0aGlzLl9wYWRbMF0sIHRoaXMuX2hbMF0gPSBBICYgNjU1MzUsIEkgPSAxOyBJIDwgODsgSSsrKVxuICAgICAgICAgIEEgPSAodGhpcy5faFtJXSArIHRoaXMuX3BhZFtJXSB8IDApICsgKEEgPj4+IDE2KSB8IDAsIHRoaXMuX2hbSV0gPSBBICYgNjU1MzU7XG4gICAgICAgIHJldHVybiBmW2ggKyAwXSA9IHRoaXMuX2hbMF0gPj4+IDAsIGZbaCArIDFdID0gdGhpcy5faFswXSA+Pj4gOCwgZltoICsgMl0gPSB0aGlzLl9oWzFdID4+PiAwLCBmW2ggKyAzXSA9IHRoaXMuX2hbMV0gPj4+IDgsIGZbaCArIDRdID0gdGhpcy5faFsyXSA+Pj4gMCwgZltoICsgNV0gPSB0aGlzLl9oWzJdID4+PiA4LCBmW2ggKyA2XSA9IHRoaXMuX2hbM10gPj4+IDAsIGZbaCArIDddID0gdGhpcy5faFszXSA+Pj4gOCwgZltoICsgOF0gPSB0aGlzLl9oWzRdID4+PiAwLCBmW2ggKyA5XSA9IHRoaXMuX2hbNF0gPj4+IDgsIGZbaCArIDEwXSA9IHRoaXMuX2hbNV0gPj4+IDAsIGZbaCArIDExXSA9IHRoaXMuX2hbNV0gPj4+IDgsIGZbaCArIDEyXSA9IHRoaXMuX2hbNl0gPj4+IDAsIGZbaCArIDEzXSA9IHRoaXMuX2hbNl0gPj4+IDgsIGZbaCArIDE0XSA9IHRoaXMuX2hbN10gPj4+IDAsIGZbaCArIDE1XSA9IHRoaXMuX2hbN10gPj4+IDgsIHRoaXMuX2ZpbmlzaGVkID0gITAsIHRoaXM7XG4gICAgICB9LCBvLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciBoID0gMCwgZCA9IGYubGVuZ3RoLCB2O1xuICAgICAgICBpZiAodGhpcy5fbGVmdG92ZXIpIHtcbiAgICAgICAgICB2ID0gMTYgLSB0aGlzLl9sZWZ0b3ZlciwgdiA+IGQgJiYgKHYgPSBkKTtcbiAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IHY7IHcrKylcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclt0aGlzLl9sZWZ0b3ZlciArIHddID0gZltoICsgd107XG4gICAgICAgICAgaWYgKGQgLT0gdiwgaCArPSB2LCB0aGlzLl9sZWZ0b3ZlciArPSB2LCB0aGlzLl9sZWZ0b3ZlciA8IDE2KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgdGhpcy5fYmxvY2tzKHRoaXMuX2J1ZmZlciwgMCwgMTYpLCB0aGlzLl9sZWZ0b3ZlciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQgPj0gMTYgJiYgKHYgPSBkIC0gZCAlIDE2LCB0aGlzLl9ibG9ja3MoZiwgaCwgdiksIGggKz0gdiwgZCAtPSB2KSwgZCkge1xuICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgZDsgdysrKVxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyW3RoaXMuX2xlZnRvdmVyICsgd10gPSBmW2ggKyB3XTtcbiAgICAgICAgICB0aGlzLl9sZWZ0b3ZlciArPSBkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgby5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9maW5pc2hlZClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5MTMwNSB3YXMgZmluaXNoZWRcIik7XG4gICAgICAgIHZhciBmID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goZiksIGY7XG4gICAgICB9LCBvLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdC53aXBlKHRoaXMuX2J1ZmZlciksIHQud2lwZSh0aGlzLl9yKSwgdC53aXBlKHRoaXMuX2gpLCB0LndpcGUodGhpcy5fcGFkKSwgdGhpcy5fbGVmdG92ZXIgPSAwLCB0aGlzLl9maW4gPSAwLCB0aGlzLl9maW5pc2hlZCA9ICEwLCB0aGlzO1xuICAgICAgfSwgbztcbiAgICB9KClcbiAgKTtcbiAgci5Qb2x5MTMwNSA9IGk7XG4gIGZ1bmN0aW9uIG4obywgZikge1xuICAgIHZhciBoID0gbmV3IGkobyk7XG4gICAgaC51cGRhdGUoZik7XG4gICAgdmFyIGQgPSBoLmRpZ2VzdCgpO1xuICAgIHJldHVybiBoLmNsZWFuKCksIGQ7XG4gIH1cbiAgci5vbmVUaW1lQXV0aCA9IG47XG4gIGZ1bmN0aW9uIHMobywgZikge1xuICAgIHJldHVybiBvLmxlbmd0aCAhPT0gci5ESUdFU1RfTEVOR1RIIHx8IGYubGVuZ3RoICE9PSByLkRJR0VTVF9MRU5HVEggPyAhMSA6IGUuZXF1YWwobywgZik7XG4gIH1cbiAgci5lcXVhbCA9IHM7XG59KSh6dSk7XG4oZnVuY3Rpb24ocikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICB2YXIgZSA9IHZhLCB0ID0genUsIGkgPSBuciwgbiA9IFZlLCBzID0gTWk7XG4gIHIuS0VZX0xFTkdUSCA9IDMyLCByLk5PTkNFX0xFTkdUSCA9IDEyLCByLlRBR19MRU5HVEggPSAxNjtcbiAgdmFyIG8gPSBuZXcgVWludDhBcnJheSgxNiksIGYgPSAoXG4gICAgLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gaChkKSB7XG4gICAgICAgIGlmICh0aGlzLm5vbmNlTGVuZ3RoID0gci5OT05DRV9MRU5HVEgsIHRoaXMudGFnTGVuZ3RoID0gci5UQUdfTEVOR1RILCBkLmxlbmd0aCAhPT0gci5LRVlfTEVOR1RIKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYUNoYTIwUG9seTEzMDUgbmVlZHMgMzItYnl0ZSBrZXlcIik7XG4gICAgICAgIHRoaXMuX2tleSA9IG5ldyBVaW50OEFycmF5KGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGgucHJvdG90eXBlLnNlYWwgPSBmdW5jdGlvbihkLCB2LCB3LCBBKSB7XG4gICAgICAgIGlmIChkLmxlbmd0aCA+IDE2KVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYUNoYTIwUG9seTEzMDU6IGluY29ycmVjdCBub25jZSBsZW5ndGhcIik7XG4gICAgICAgIHZhciBJID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBJLnNldChkLCBJLmxlbmd0aCAtIGQubGVuZ3RoKTtcbiAgICAgICAgdmFyIEQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGUuc3RyZWFtKHRoaXMuX2tleSwgSSwgRCwgNCk7XG4gICAgICAgIHZhciBOID0gdi5sZW5ndGggKyB0aGlzLnRhZ0xlbmd0aCwgaztcbiAgICAgICAgaWYgKEEpIHtcbiAgICAgICAgICBpZiAoQS5sZW5ndGggIT09IE4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFDaGEyMFBvbHkxMzA1OiBpbmNvcnJlY3QgZGVzdGluYXRpb24gbGVuZ3RoXCIpO1xuICAgICAgICAgIGsgPSBBO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBrID0gbmV3IFVpbnQ4QXJyYXkoTik7XG4gICAgICAgIHJldHVybiBlLnN0cmVhbVhPUih0aGlzLl9rZXksIEksIHYsIGssIDQpLCB0aGlzLl9hdXRoZW50aWNhdGUoay5zdWJhcnJheShrLmxlbmd0aCAtIHRoaXMudGFnTGVuZ3RoLCBrLmxlbmd0aCksIEQsIGsuc3ViYXJyYXkoMCwgay5sZW5ndGggLSB0aGlzLnRhZ0xlbmd0aCksIHcpLCBpLndpcGUoSSksIGs7XG4gICAgICB9LCBoLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24oZCwgdiwgdywgQSkge1xuICAgICAgICBpZiAoZC5sZW5ndGggPiAxNilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFDaGEyMFBvbHkxMzA1OiBpbmNvcnJlY3Qgbm9uY2UgbGVuZ3RoXCIpO1xuICAgICAgICBpZiAodi5sZW5ndGggPCB0aGlzLnRhZ0xlbmd0aClcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIEkgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIEkuc2V0KGQsIEkubGVuZ3RoIC0gZC5sZW5ndGgpO1xuICAgICAgICB2YXIgRCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgZS5zdHJlYW0odGhpcy5fa2V5LCBJLCBELCA0KTtcbiAgICAgICAgdmFyIE4gPSBuZXcgVWludDhBcnJheSh0aGlzLnRhZ0xlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLl9hdXRoZW50aWNhdGUoTiwgRCwgdi5zdWJhcnJheSgwLCB2Lmxlbmd0aCAtIHRoaXMudGFnTGVuZ3RoKSwgdyksICFzLmVxdWFsKE4sIHYuc3ViYXJyYXkodi5sZW5ndGggLSB0aGlzLnRhZ0xlbmd0aCwgdi5sZW5ndGgpKSlcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGsgPSB2Lmxlbmd0aCAtIHRoaXMudGFnTGVuZ3RoLCBqO1xuICAgICAgICBpZiAoQSkge1xuICAgICAgICAgIGlmIChBLmxlbmd0aCAhPT0gaylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYUNoYTIwUG9seTEzMDU6IGluY29ycmVjdCBkZXN0aW5hdGlvbiBsZW5ndGhcIik7XG4gICAgICAgICAgaiA9IEE7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGogPSBuZXcgVWludDhBcnJheShrKTtcbiAgICAgICAgcmV0dXJuIGUuc3RyZWFtWE9SKHRoaXMuX2tleSwgSSwgdi5zdWJhcnJheSgwLCB2Lmxlbmd0aCAtIHRoaXMudGFnTGVuZ3RoKSwgaiwgNCksIGkud2lwZShJKSwgajtcbiAgICAgIH0sIGgucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpLndpcGUodGhpcy5fa2V5KSwgdGhpcztcbiAgICAgIH0sIGgucHJvdG90eXBlLl9hdXRoZW50aWNhdGUgPSBmdW5jdGlvbihkLCB2LCB3LCBBKSB7XG4gICAgICAgIHZhciBJID0gbmV3IHQuUG9seTEzMDUodik7XG4gICAgICAgIEEgJiYgKEkudXBkYXRlKEEpLCBBLmxlbmd0aCAlIDE2ID4gMCAmJiBJLnVwZGF0ZShvLnN1YmFycmF5KEEubGVuZ3RoICUgMTYpKSksIEkudXBkYXRlKHcpLCB3Lmxlbmd0aCAlIDE2ID4gMCAmJiBJLnVwZGF0ZShvLnN1YmFycmF5KHcubGVuZ3RoICUgMTYpKTtcbiAgICAgICAgdmFyIEQgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICAgICAgQSAmJiBuLndyaXRlVWludDY0TEUoQS5sZW5ndGgsIEQpLCBJLnVwZGF0ZShEKSwgbi53cml0ZVVpbnQ2NExFKHcubGVuZ3RoLCBEKSwgSS51cGRhdGUoRCk7XG4gICAgICAgIGZvciAodmFyIE4gPSBJLmRpZ2VzdCgpLCBrID0gMDsgayA8IE4ubGVuZ3RoOyBrKyspXG4gICAgICAgICAgZFtrXSA9IE5ba107XG4gICAgICAgIEkuY2xlYW4oKSwgaS53aXBlKE4pLCBpLndpcGUoRCk7XG4gICAgICB9LCBoO1xuICAgIH0oKVxuICApO1xuICByLkNoYUNoYTIwUG9seTEzMDUgPSBmO1xufSkoS28pO1xudmFyIGt1ID0ge30sIHNzID0ge30sIEhvID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSG8sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmZ1bmN0aW9uIEtnKHIpIHtcbiAgcmV0dXJuIHR5cGVvZiByLnNhdmVTdGF0ZSA8IFwidVwiICYmIHR5cGVvZiByLnJlc3RvcmVTdGF0ZSA8IFwidVwiICYmIHR5cGVvZiByLmNsZWFuU2F2ZWRTdGF0ZSA8IFwidVwiO1xufVxuSG8uaXNTZXJpYWxpemFibGVIYXNoID0gS2c7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc3MsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnZhciBEciA9IEhvLCBIZyA9IE1pLCBWZyA9IG5yLCBqdSA9IChcbiAgLyoqIEBjbGFzcyAqL1xuICBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiByKGUsIHQpIHtcbiAgICAgIHRoaXMuX2ZpbmlzaGVkID0gITEsIHRoaXMuX2lubmVyID0gbmV3IGUoKSwgdGhpcy5fb3V0ZXIgPSBuZXcgZSgpLCB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMuX291dGVyLmJsb2NrU2l6ZSwgdGhpcy5kaWdlc3RMZW5ndGggPSB0aGlzLl9vdXRlci5kaWdlc3RMZW5ndGg7XG4gICAgICB2YXIgaSA9IG5ldyBVaW50OEFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgICAgIHQubGVuZ3RoID4gdGhpcy5ibG9ja1NpemUgPyB0aGlzLl9pbm5lci51cGRhdGUodCkuZmluaXNoKGkpLmNsZWFuKCkgOiBpLnNldCh0KTtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgaS5sZW5ndGg7IG4rKylcbiAgICAgICAgaVtuXSBePSA1NDtcbiAgICAgIHRoaXMuX2lubmVyLnVwZGF0ZShpKTtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgaS5sZW5ndGg7IG4rKylcbiAgICAgICAgaVtuXSBePSAxMDY7XG4gICAgICB0aGlzLl9vdXRlci51cGRhdGUoaSksIERyLmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9pbm5lcikgJiYgRHIuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX291dGVyKSAmJiAodGhpcy5faW5uZXJLZXllZFN0YXRlID0gdGhpcy5faW5uZXIuc2F2ZVN0YXRlKCksIHRoaXMuX291dGVyS2V5ZWRTdGF0ZSA9IHRoaXMuX291dGVyLnNhdmVTdGF0ZSgpKSwgVmcud2lwZShpKTtcbiAgICB9XG4gICAgcmV0dXJuIHIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIURyLmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9pbm5lcikgfHwgIURyLmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9vdXRlcikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImhtYWM6IGNhbid0IHJlc2V0KCkgYmVjYXVzZSBoYXNoIGRvZXNuJ3QgaW1wbGVtZW50IHJlc3RvcmVTdGF0ZSgpXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLnJlc3RvcmVTdGF0ZSh0aGlzLl9pbm5lcktleWVkU3RhdGUpLCB0aGlzLl9vdXRlci5yZXN0b3JlU3RhdGUodGhpcy5fb3V0ZXJLZXllZFN0YXRlKSwgdGhpcy5fZmluaXNoZWQgPSAhMSwgdGhpcztcbiAgICB9LCByLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgRHIuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX2lubmVyKSAmJiB0aGlzLl9pbm5lci5jbGVhblNhdmVkU3RhdGUodGhpcy5faW5uZXJLZXllZFN0YXRlKSwgRHIuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX291dGVyKSAmJiB0aGlzLl9vdXRlci5jbGVhblNhdmVkU3RhdGUodGhpcy5fb3V0ZXJLZXllZFN0YXRlKSwgdGhpcy5faW5uZXIuY2xlYW4oKSwgdGhpcy5fb3V0ZXIuY2xlYW4oKTtcbiAgICB9LCByLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5uZXIudXBkYXRlKGUpLCB0aGlzO1xuICAgIH0sIHIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maW5pc2hlZCA/ICh0aGlzLl9vdXRlci5maW5pc2goZSksIHRoaXMpIDogKHRoaXMuX2lubmVyLmZpbmlzaChlKSwgdGhpcy5fb3V0ZXIudXBkYXRlKGUuc3ViYXJyYXkoMCwgdGhpcy5kaWdlc3RMZW5ndGgpKS5maW5pc2goZSksIHRoaXMuX2ZpbmlzaGVkID0gITAsIHRoaXMpO1xuICAgIH0sIHIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBuZXcgVWludDhBcnJheSh0aGlzLmRpZ2VzdExlbmd0aCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2goZSksIGU7XG4gICAgfSwgci5wcm90b3R5cGUuc2F2ZVN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIURyLmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9pbm5lcikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImhtYWM6IGNhbid0IHNhdmVTdGF0ZSgpIGJlY2F1c2UgaGFzaCBkb2Vzbid0IGltcGxlbWVudCBpdFwiKTtcbiAgICAgIHJldHVybiB0aGlzLl9pbm5lci5zYXZlU3RhdGUoKTtcbiAgICB9LCByLnByb3RvdHlwZS5yZXN0b3JlU3RhdGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIURyLmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9pbm5lcikgfHwgIURyLmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9vdXRlcikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImhtYWM6IGNhbid0IHJlc3RvcmVTdGF0ZSgpIGJlY2F1c2UgaGFzaCBkb2Vzbid0IGltcGxlbWVudCBpdFwiKTtcbiAgICAgIHJldHVybiB0aGlzLl9pbm5lci5yZXN0b3JlU3RhdGUoZSksIHRoaXMuX291dGVyLnJlc3RvcmVTdGF0ZSh0aGlzLl9vdXRlcktleWVkU3RhdGUpLCB0aGlzLl9maW5pc2hlZCA9ICExLCB0aGlzO1xuICAgIH0sIHIucHJvdG90eXBlLmNsZWFuU2F2ZWRTdGF0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghRHIuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX2lubmVyKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaG1hYzogY2FuJ3QgY2xlYW5TYXZlZFN0YXRlKCkgYmVjYXVzZSBoYXNoIGRvZXNuJ3QgaW1wbGVtZW50IGl0XCIpO1xuICAgICAgdGhpcy5faW5uZXIuY2xlYW5TYXZlZFN0YXRlKGUpO1xuICAgIH0sIHI7XG4gIH0oKVxuKTtcbnNzLkhNQUMgPSBqdTtcbmZ1bmN0aW9uIFdnKHIsIGUsIHQpIHtcbiAgdmFyIGkgPSBuZXcganUociwgZSk7XG4gIGkudXBkYXRlKHQpO1xuICB2YXIgbiA9IGkuZGlnZXN0KCk7XG4gIHJldHVybiBpLmNsZWFuKCksIG47XG59XG5zcy5obWFjID0gV2c7XG5zcy5lcXVhbCA9IEhnLmVxdWFsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGt1LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgdmMgPSBzcywgYmMgPSBuciwgR2cgPSAoXG4gIC8qKiBAY2xhc3MgKi9cbiAgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gcihlLCB0LCBpLCBuKSB7XG4gICAgICBpID09PSB2b2lkIDAgJiYgKGkgPSBuZXcgVWludDhBcnJheSgwKSksIHRoaXMuX2NvdW50ZXIgPSBuZXcgVWludDhBcnJheSgxKSwgdGhpcy5faGFzaCA9IGUsIHRoaXMuX2luZm8gPSBuO1xuICAgICAgdmFyIHMgPSB2Yy5obWFjKHRoaXMuX2hhc2gsIGksIHQpO1xuICAgICAgdGhpcy5faG1hYyA9IG5ldyB2Yy5ITUFDKGUsIHMpLCB0aGlzLl9idWZmZXIgPSBuZXcgVWludDhBcnJheSh0aGlzLl9obWFjLmRpZ2VzdExlbmd0aCksIHRoaXMuX2J1ZnBvcyA9IHRoaXMuX2J1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByLnByb3RvdHlwZS5fZmlsbEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY291bnRlclswXSsrO1xuICAgICAgdmFyIGUgPSB0aGlzLl9jb3VudGVyWzBdO1xuICAgICAgaWYgKGUgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImhrZGY6IGNhbm5vdCBleHBhbmQgbW9yZVwiKTtcbiAgICAgIHRoaXMuX2htYWMucmVzZXQoKSwgZSA+IDEgJiYgdGhpcy5faG1hYy51cGRhdGUodGhpcy5fYnVmZmVyKSwgdGhpcy5faW5mbyAmJiB0aGlzLl9obWFjLnVwZGF0ZSh0aGlzLl9pbmZvKSwgdGhpcy5faG1hYy51cGRhdGUodGhpcy5fY291bnRlciksIHRoaXMuX2htYWMuZmluaXNoKHRoaXMuX2J1ZmZlciksIHRoaXMuX2J1ZnBvcyA9IDA7XG4gICAgfSwgci5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24oZSkge1xuICAgICAgZm9yICh2YXIgdCA9IG5ldyBVaW50OEFycmF5KGUpLCBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMuX2J1ZnBvcyA9PT0gdGhpcy5fYnVmZmVyLmxlbmd0aCAmJiB0aGlzLl9maWxsQnVmZmVyKCksIHRbaV0gPSB0aGlzLl9idWZmZXJbdGhpcy5fYnVmcG9zKytdO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSwgci5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2htYWMuY2xlYW4oKSwgYmMud2lwZSh0aGlzLl9idWZmZXIpLCBiYy53aXBlKHRoaXMuX2NvdW50ZXIpLCB0aGlzLl9idWZwb3MgPSAwO1xuICAgIH0sIHI7XG4gIH0oKVxuKSwgSmcgPSBrdS5IS0RGID0gR2csIGFzID0ge307XG4oZnVuY3Rpb24ocikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICB2YXIgZSA9IFZlLCB0ID0gbnI7XG4gIHIuRElHRVNUX0xFTkdUSCA9IDMyLCByLkJMT0NLX1NJWkUgPSA2NDtcbiAgdmFyIGkgPSAoXG4gICAgLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gZigpIHtcbiAgICAgICAgdGhpcy5kaWdlc3RMZW5ndGggPSByLkRJR0VTVF9MRU5HVEgsIHRoaXMuYmxvY2tTaXplID0gci5CTE9DS19TSVpFLCB0aGlzLl9zdGF0ZSA9IG5ldyBJbnQzMkFycmF5KDgpLCB0aGlzLl90ZW1wID0gbmV3IEludDMyQXJyYXkoNjQpLCB0aGlzLl9idWZmZXIgPSBuZXcgVWludDhBcnJheSgxMjgpLCB0aGlzLl9idWZmZXJMZW5ndGggPSAwLCB0aGlzLl9ieXRlc0hhc2hlZCA9IDAsIHRoaXMuX2ZpbmlzaGVkID0gITEsIHRoaXMucmVzZXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmLnByb3RvdHlwZS5faW5pdFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlWzBdID0gMTc3OTAzMzcwMywgdGhpcy5fc3RhdGVbMV0gPSAzMTQ0MTM0Mjc3LCB0aGlzLl9zdGF0ZVsyXSA9IDEwMTM5MDQyNDIsIHRoaXMuX3N0YXRlWzNdID0gMjc3MzQ4MDc2MiwgdGhpcy5fc3RhdGVbNF0gPSAxMzU5ODkzMTE5LCB0aGlzLl9zdGF0ZVs1XSA9IDI2MDA4MjI5MjQsIHRoaXMuX3N0YXRlWzZdID0gNTI4NzM0NjM1LCB0aGlzLl9zdGF0ZVs3XSA9IDE1NDE0NTkyMjU7XG4gICAgICB9LCBmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdFN0YXRlKCksIHRoaXMuX2J1ZmZlckxlbmd0aCA9IDAsIHRoaXMuX2J5dGVzSGFzaGVkID0gMCwgdGhpcy5fZmluaXNoZWQgPSAhMSwgdGhpcztcbiAgICAgIH0sIGYucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHQud2lwZSh0aGlzLl9idWZmZXIpLCB0LndpcGUodGhpcy5fdGVtcCksIHRoaXMucmVzZXQoKTtcbiAgICAgIH0sIGYucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGgsIGQpIHtcbiAgICAgICAgaWYgKGQgPT09IHZvaWQgMCAmJiAoZCA9IGgubGVuZ3RoKSwgdGhpcy5fZmluaXNoZWQpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU0hBMjU2OiBjYW4ndCB1cGRhdGUgYmVjYXVzZSBoYXNoIHdhcyBmaW5pc2hlZC5cIik7XG4gICAgICAgIHZhciB2ID0gMDtcbiAgICAgICAgaWYgKHRoaXMuX2J5dGVzSGFzaGVkICs9IGQsIHRoaXMuX2J1ZmZlckxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKDsgdGhpcy5fYnVmZmVyTGVuZ3RoIDwgdGhpcy5ibG9ja1NpemUgJiYgZCA+IDA7IClcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclt0aGlzLl9idWZmZXJMZW5ndGgrK10gPSBoW3YrK10sIGQtLTtcbiAgICAgICAgICB0aGlzLl9idWZmZXJMZW5ndGggPT09IHRoaXMuYmxvY2tTaXplICYmIChzKHRoaXMuX3RlbXAsIHRoaXMuX3N0YXRlLCB0aGlzLl9idWZmZXIsIDAsIHRoaXMuYmxvY2tTaXplKSwgdGhpcy5fYnVmZmVyTGVuZ3RoID0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChkID49IHRoaXMuYmxvY2tTaXplICYmICh2ID0gcyh0aGlzLl90ZW1wLCB0aGlzLl9zdGF0ZSwgaCwgdiwgZCksIGQgJT0gdGhpcy5ibG9ja1NpemUpOyBkID4gMDsgKVxuICAgICAgICAgIHRoaXMuX2J1ZmZlclt0aGlzLl9idWZmZXJMZW5ndGgrK10gPSBoW3YrK10sIGQtLTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCBmLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgICAgICB2YXIgZCA9IHRoaXMuX2J5dGVzSGFzaGVkLCB2ID0gdGhpcy5fYnVmZmVyTGVuZ3RoLCB3ID0gZCAvIDUzNjg3MDkxMiB8IDAsIEEgPSBkIDw8IDMsIEkgPSBkICUgNjQgPCA1NiA/IDY0IDogMTI4O1xuICAgICAgICAgIHRoaXMuX2J1ZmZlclt2XSA9IDEyODtcbiAgICAgICAgICBmb3IgKHZhciBEID0gdiArIDE7IEQgPCBJIC0gODsgRCsrKVxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyW0RdID0gMDtcbiAgICAgICAgICBlLndyaXRlVWludDMyQkUodywgdGhpcy5fYnVmZmVyLCBJIC0gOCksIGUud3JpdGVVaW50MzJCRShBLCB0aGlzLl9idWZmZXIsIEkgLSA0KSwgcyh0aGlzLl90ZW1wLCB0aGlzLl9zdGF0ZSwgdGhpcy5fYnVmZmVyLCAwLCBJKSwgdGhpcy5fZmluaXNoZWQgPSAhMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBEID0gMDsgRCA8IHRoaXMuZGlnZXN0TGVuZ3RoIC8gNDsgRCsrKVxuICAgICAgICAgIGUud3JpdGVVaW50MzJCRSh0aGlzLl9zdGF0ZVtEXSwgaCwgRCAqIDQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIGYucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaCA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGlnZXN0TGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKGgpLCBoO1xuICAgICAgfSwgZi5wcm90b3R5cGUuc2F2ZVN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9maW5pc2hlZClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTSEEyNTY6IGNhbm5vdCBzYXZlIGZpbmlzaGVkIHN0YXRlXCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXRlOiBuZXcgSW50MzJBcnJheSh0aGlzLl9zdGF0ZSksXG4gICAgICAgICAgYnVmZmVyOiB0aGlzLl9idWZmZXJMZW5ndGggPiAwID8gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmZmVyKSA6IHZvaWQgMCxcbiAgICAgICAgICBidWZmZXJMZW5ndGg6IHRoaXMuX2J1ZmZlckxlbmd0aCxcbiAgICAgICAgICBieXRlc0hhc2hlZDogdGhpcy5fYnl0ZXNIYXNoZWRcbiAgICAgICAgfTtcbiAgICAgIH0sIGYucHJvdG90eXBlLnJlc3RvcmVTdGF0ZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLnNldChoLnN0YXRlKSwgdGhpcy5fYnVmZmVyTGVuZ3RoID0gaC5idWZmZXJMZW5ndGgsIGguYnVmZmVyICYmIHRoaXMuX2J1ZmZlci5zZXQoaC5idWZmZXIpLCB0aGlzLl9ieXRlc0hhc2hlZCA9IGguYnl0ZXNIYXNoZWQsIHRoaXMuX2ZpbmlzaGVkID0gITEsIHRoaXM7XG4gICAgICB9LCBmLnByb3RvdHlwZS5jbGVhblNhdmVkU3RhdGUgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIHQud2lwZShoLnN0YXRlKSwgaC5idWZmZXIgJiYgdC53aXBlKGguYnVmZmVyKSwgaC5idWZmZXJMZW5ndGggPSAwLCBoLmJ5dGVzSGFzaGVkID0gMDtcbiAgICAgIH0sIGY7XG4gICAgfSgpXG4gICk7XG4gIHIuU0hBMjU2ID0gaTtcbiAgdmFyIG4gPSBuZXcgSW50MzJBcnJheShbXG4gICAgMTExNjM1MjQwOCxcbiAgICAxODk5NDQ3NDQxLFxuICAgIDMwNDkzMjM0NzEsXG4gICAgMzkyMTAwOTU3MyxcbiAgICA5NjE5ODcxNjMsXG4gICAgMTUwODk3MDk5MyxcbiAgICAyNDUzNjM1NzQ4LFxuICAgIDI4NzA3NjMyMjEsXG4gICAgMzYyNDM4MTA4MCxcbiAgICAzMTA1OTg0MDEsXG4gICAgNjA3MjI1Mjc4LFxuICAgIDE0MjY4ODE5ODcsXG4gICAgMTkyNTA3ODM4OCxcbiAgICAyMTYyMDc4MjA2LFxuICAgIDI2MTQ4ODgxMDMsXG4gICAgMzI0ODIyMjU4MCxcbiAgICAzODM1MzkwNDAxLFxuICAgIDQwMjIyMjQ3NzQsXG4gICAgMjY0MzQ3MDc4LFxuICAgIDYwNDgwNzYyOCxcbiAgICA3NzAyNTU5ODMsXG4gICAgMTI0OTE1MDEyMixcbiAgICAxNTU1MDgxNjkyLFxuICAgIDE5OTYwNjQ5ODYsXG4gICAgMjU1NDIyMDg4MixcbiAgICAyODIxODM0MzQ5LFxuICAgIDI5NTI5OTY4MDgsXG4gICAgMzIxMDMxMzY3MSxcbiAgICAzMzM2NTcxODkxLFxuICAgIDM1ODQ1Mjg3MTEsXG4gICAgMTEzOTI2OTkzLFxuICAgIDMzODI0MTg5NSxcbiAgICA2NjYzMDcyMDUsXG4gICAgNzczNTI5OTEyLFxuICAgIDEyOTQ3NTczNzIsXG4gICAgMTM5NjE4MjI5MSxcbiAgICAxNjk1MTgzNzAwLFxuICAgIDE5ODY2NjEwNTEsXG4gICAgMjE3NzAyNjM1MCxcbiAgICAyNDU2OTU2MDM3LFxuICAgIDI3MzA0ODU5MjEsXG4gICAgMjgyMDMwMjQxMSxcbiAgICAzMjU5NzMwODAwLFxuICAgIDMzNDU3NjQ3NzEsXG4gICAgMzUxNjA2NTgxNyxcbiAgICAzNjAwMzUyODA0LFxuICAgIDQwOTQ1NzE5MDksXG4gICAgMjc1NDIzMzQ0LFxuICAgIDQzMDIyNzczNCxcbiAgICA1MDY5NDg2MTYsXG4gICAgNjU5MDYwNTU2LFxuICAgIDg4Mzk5Nzg3NyxcbiAgICA5NTgxMzk1NzEsXG4gICAgMTMyMjgyMjIxOCxcbiAgICAxNTM3MDAyMDYzLFxuICAgIDE3NDc4NzM3NzksXG4gICAgMTk1NTU2MjIyMixcbiAgICAyMDI0MTA0ODE1LFxuICAgIDIyMjc3MzA0NTIsXG4gICAgMjM2MTg1MjQyNCxcbiAgICAyNDI4NDM2NDc0LFxuICAgIDI3NTY3MzQxODcsXG4gICAgMzIwNDAzMTQ3OSxcbiAgICAzMzI5MzI1Mjk4XG4gIF0pO1xuICBmdW5jdGlvbiBzKGYsIGgsIGQsIHYsIHcpIHtcbiAgICBmb3IgKDsgdyA+PSA2NDsgKSB7XG4gICAgICBmb3IgKHZhciBBID0gaFswXSwgSSA9IGhbMV0sIEQgPSBoWzJdLCBOID0gaFszXSwgayA9IGhbNF0sIGogPSBoWzVdLCBUID0gaFs2XSwgSyA9IGhbN10sICQgPSAwOyAkIDwgMTY7ICQrKykge1xuICAgICAgICB2YXIgeiA9IHYgKyAkICogNDtcbiAgICAgICAgZlskXSA9IGUucmVhZFVpbnQzMkJFKGQsIHopO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgJCA9IDE2OyAkIDwgNjQ7ICQrKykge1xuICAgICAgICB2YXIgQiA9IGZbJCAtIDJdLCBfID0gKEIgPj4+IDE3IHwgQiA8PCAzMiAtIDE3KSBeIChCID4+PiAxOSB8IEIgPDwgMzIgLSAxOSkgXiBCID4+PiAxMDtcbiAgICAgICAgQiA9IGZbJCAtIDE1XTtcbiAgICAgICAgdmFyIFIgPSAoQiA+Pj4gNyB8IEIgPDwgMzIgLSA3KSBeIChCID4+PiAxOCB8IEIgPDwgMzIgLSAxOCkgXiBCID4+PiAzO1xuICAgICAgICBmWyRdID0gKF8gKyBmWyQgLSA3XSB8IDApICsgKFIgKyBmWyQgLSAxNl0gfCAwKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyICQgPSAwOyAkIDwgNjQ7ICQrKykge1xuICAgICAgICB2YXIgXyA9ICgoKGsgPj4+IDYgfCBrIDw8IDI2KSBeIChrID4+PiAxMSB8IGsgPDwgMjEpIF4gKGsgPj4+IDI1IHwgayA8PCA3KSkgKyAoayAmIGogXiB+ayAmIFQpIHwgMCkgKyAoSyArIChuWyRdICsgZlskXSB8IDApIHwgMCkgfCAwLCBSID0gKChBID4+PiAyIHwgQSA8PCAzMiAtIDIpIF4gKEEgPj4+IDEzIHwgQSA8PCAzMiAtIDEzKSBeIChBID4+PiAyMiB8IEEgPDwgMzIgLSAyMikpICsgKEEgJiBJIF4gQSAmIEQgXiBJICYgRCkgfCAwO1xuICAgICAgICBLID0gVCwgVCA9IGosIGogPSBrLCBrID0gTiArIF8gfCAwLCBOID0gRCwgRCA9IEksIEkgPSBBLCBBID0gXyArIFIgfCAwO1xuICAgICAgfVxuICAgICAgaFswXSArPSBBLCBoWzFdICs9IEksIGhbMl0gKz0gRCwgaFszXSArPSBOLCBoWzRdICs9IGssIGhbNV0gKz0gaiwgaFs2XSArPSBULCBoWzddICs9IEssIHYgKz0gNjQsIHcgLT0gNjQ7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIGZ1bmN0aW9uIG8oZikge1xuICAgIHZhciBoID0gbmV3IGkoKTtcbiAgICBoLnVwZGF0ZShmKTtcbiAgICB2YXIgZCA9IGguZGlnZXN0KCk7XG4gICAgcmV0dXJuIGguY2xlYW4oKSwgZDtcbiAgfVxuICByLmhhc2ggPSBvO1xufSkoYXMpO1xudmFyIFZvID0ge307XG4oZnVuY3Rpb24ocikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCByLnNoYXJlZEtleSA9IHIuZ2VuZXJhdGVLZXlQYWlyID0gci5nZW5lcmF0ZUtleVBhaXJGcm9tU2VlZCA9IHIuc2NhbGFyTXVsdEJhc2UgPSByLnNjYWxhck11bHQgPSByLlNIQVJFRF9LRVlfTEVOR1RIID0gci5TRUNSRVRfS0VZX0xFTkdUSCA9IHIuUFVCTElDX0tFWV9MRU5HVEggPSB2b2lkIDA7XG4gIGNvbnN0IGUgPSBFaSwgdCA9IG5yO1xuICByLlBVQkxJQ19LRVlfTEVOR1RIID0gMzIsIHIuU0VDUkVUX0tFWV9MRU5HVEggPSAzMiwgci5TSEFSRURfS0VZX0xFTkdUSCA9IDMyO1xuICBmdW5jdGlvbiBpKCQpIHtcbiAgICBjb25zdCB6ID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gICAgaWYgKCQpXG4gICAgICBmb3IgKGxldCBCID0gMDsgQiA8ICQubGVuZ3RoOyBCKyspXG4gICAgICAgIHpbQl0gPSAkW0JdO1xuICAgIHJldHVybiB6O1xuICB9XG4gIGNvbnN0IG4gPSBuZXcgVWludDhBcnJheSgzMik7XG4gIG5bMF0gPSA5O1xuICBjb25zdCBzID0gaShbNTYxMjksIDFdKTtcbiAgZnVuY3Rpb24gbygkKSB7XG4gICAgbGV0IHogPSAxO1xuICAgIGZvciAobGV0IEIgPSAwOyBCIDwgMTY7IEIrKykge1xuICAgICAgbGV0IF8gPSAkW0JdICsgeiArIDY1NTM1O1xuICAgICAgeiA9IE1hdGguZmxvb3IoXyAvIDY1NTM2KSwgJFtCXSA9IF8gLSB6ICogNjU1MzY7XG4gICAgfVxuICAgICRbMF0gKz0geiAtIDEgKyAzNyAqICh6IC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gZigkLCB6LCBCKSB7XG4gICAgY29uc3QgXyA9IH4oQiAtIDEpO1xuICAgIGZvciAobGV0IFIgPSAwOyBSIDwgMTY7IFIrKykge1xuICAgICAgY29uc3QgSiA9IF8gJiAoJFtSXSBeIHpbUl0pO1xuICAgICAgJFtSXSBePSBKLCB6W1JdIF49IEo7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGgoJCwgeikge1xuICAgIGNvbnN0IEIgPSBpKCksIF8gPSBpKCk7XG4gICAgZm9yIChsZXQgUiA9IDA7IFIgPCAxNjsgUisrKVxuICAgICAgX1tSXSA9IHpbUl07XG4gICAgbyhfKSwgbyhfKSwgbyhfKTtcbiAgICBmb3IgKGxldCBSID0gMDsgUiA8IDI7IFIrKykge1xuICAgICAgQlswXSA9IF9bMF0gLSA2NTUxNztcbiAgICAgIGZvciAobGV0IFEgPSAxOyBRIDwgMTU7IFErKylcbiAgICAgICAgQltRXSA9IF9bUV0gLSA2NTUzNSAtIChCW1EgLSAxXSA+PiAxNiAmIDEpLCBCW1EgLSAxXSAmPSA2NTUzNTtcbiAgICAgIEJbMTVdID0gX1sxNV0gLSAzMjc2NyAtIChCWzE0XSA+PiAxNiAmIDEpO1xuICAgICAgY29uc3QgSiA9IEJbMTVdID4+IDE2ICYgMTtcbiAgICAgIEJbMTRdICY9IDY1NTM1LCBmKF8sIEIsIDEgLSBKKTtcbiAgICB9XG4gICAgZm9yIChsZXQgUiA9IDA7IFIgPCAxNjsgUisrKVxuICAgICAgJFsyICogUl0gPSBfW1JdICYgMjU1LCAkWzIgKiBSICsgMV0gPSBfW1JdID4+IDg7XG4gIH1cbiAgZnVuY3Rpb24gZCgkLCB6KSB7XG4gICAgZm9yIChsZXQgQiA9IDA7IEIgPCAxNjsgQisrKVxuICAgICAgJFtCXSA9IHpbMiAqIEJdICsgKHpbMiAqIEIgKyAxXSA8PCA4KTtcbiAgICAkWzE1XSAmPSAzMjc2NztcbiAgfVxuICBmdW5jdGlvbiB2KCQsIHosIEIpIHtcbiAgICBmb3IgKGxldCBfID0gMDsgXyA8IDE2OyBfKyspXG4gICAgICAkW19dID0geltfXSArIEJbX107XG4gIH1cbiAgZnVuY3Rpb24gdygkLCB6LCBCKSB7XG4gICAgZm9yIChsZXQgXyA9IDA7IF8gPCAxNjsgXysrKVxuICAgICAgJFtfXSA9IHpbX10gLSBCW19dO1xuICB9XG4gIGZ1bmN0aW9uIEEoJCwgeiwgQikge1xuICAgIGxldCBfLCBSLCBKID0gMCwgUSA9IDAsIE8gPSAwLCBwID0gMCwgbCA9IDAsIGEgPSAwLCBjID0gMCwgYiA9IDAsIEUgPSAwLCBTID0gMCwgeCA9IDAsIHUgPSAwLCBtID0gMCwgZyA9IDAsIFAgPSAwLCBHID0gMCwgTSA9IDAsIEggPSAwLCBDID0gMCwgcSA9IDAsIEwgPSAwLCB5ID0gMCwgRiA9IDAsIFcgPSAwLCBZID0gMCwgWCA9IDAsIGVlID0gMCwgd2UgPSAwLCBNZSA9IDAsIGhlID0gMCwgUmUgPSAwLCB4ZSA9IEJbMF0sIHNlID0gQlsxXSwgZ2UgPSBCWzJdLCBsZSA9IEJbM10sIG5lID0gQls0XSwgdWUgPSBCWzVdLCBmZSA9IEJbNl0sIHRlID0gQls3XSwgcGUgPSBCWzhdLCBfZSA9IEJbOV0sIHJlID0gQlsxMF0sIEVlID0gQlsxMV0sIFNlID0gQlsxMl0sIG9lID0gQlsxM10sIERlID0gQlsxNF0sIEllID0gQlsxNV07XG4gICAgXyA9IHpbMF0sIEogKz0gXyAqIHhlLCBRICs9IF8gKiBzZSwgTyArPSBfICogZ2UsIHAgKz0gXyAqIGxlLCBsICs9IF8gKiBuZSwgYSArPSBfICogdWUsIGMgKz0gXyAqIGZlLCBiICs9IF8gKiB0ZSwgRSArPSBfICogcGUsIFMgKz0gXyAqIF9lLCB4ICs9IF8gKiByZSwgdSArPSBfICogRWUsIG0gKz0gXyAqIFNlLCBnICs9IF8gKiBvZSwgUCArPSBfICogRGUsIEcgKz0gXyAqIEllLCBfID0gelsxXSwgUSArPSBfICogeGUsIE8gKz0gXyAqIHNlLCBwICs9IF8gKiBnZSwgbCArPSBfICogbGUsIGEgKz0gXyAqIG5lLCBjICs9IF8gKiB1ZSwgYiArPSBfICogZmUsIEUgKz0gXyAqIHRlLCBTICs9IF8gKiBwZSwgeCArPSBfICogX2UsIHUgKz0gXyAqIHJlLCBtICs9IF8gKiBFZSwgZyArPSBfICogU2UsIFAgKz0gXyAqIG9lLCBHICs9IF8gKiBEZSwgTSArPSBfICogSWUsIF8gPSB6WzJdLCBPICs9IF8gKiB4ZSwgcCArPSBfICogc2UsIGwgKz0gXyAqIGdlLCBhICs9IF8gKiBsZSwgYyArPSBfICogbmUsIGIgKz0gXyAqIHVlLCBFICs9IF8gKiBmZSwgUyArPSBfICogdGUsIHggKz0gXyAqIHBlLCB1ICs9IF8gKiBfZSwgbSArPSBfICogcmUsIGcgKz0gXyAqIEVlLCBQICs9IF8gKiBTZSwgRyArPSBfICogb2UsIE0gKz0gXyAqIERlLCBIICs9IF8gKiBJZSwgXyA9IHpbM10sIHAgKz0gXyAqIHhlLCBsICs9IF8gKiBzZSwgYSArPSBfICogZ2UsIGMgKz0gXyAqIGxlLCBiICs9IF8gKiBuZSwgRSArPSBfICogdWUsIFMgKz0gXyAqIGZlLCB4ICs9IF8gKiB0ZSwgdSArPSBfICogcGUsIG0gKz0gXyAqIF9lLCBnICs9IF8gKiByZSwgUCArPSBfICogRWUsIEcgKz0gXyAqIFNlLCBNICs9IF8gKiBvZSwgSCArPSBfICogRGUsIEMgKz0gXyAqIEllLCBfID0gels0XSwgbCArPSBfICogeGUsIGEgKz0gXyAqIHNlLCBjICs9IF8gKiBnZSwgYiArPSBfICogbGUsIEUgKz0gXyAqIG5lLCBTICs9IF8gKiB1ZSwgeCArPSBfICogZmUsIHUgKz0gXyAqIHRlLCBtICs9IF8gKiBwZSwgZyArPSBfICogX2UsIFAgKz0gXyAqIHJlLCBHICs9IF8gKiBFZSwgTSArPSBfICogU2UsIEggKz0gXyAqIG9lLCBDICs9IF8gKiBEZSwgcSArPSBfICogSWUsIF8gPSB6WzVdLCBhICs9IF8gKiB4ZSwgYyArPSBfICogc2UsIGIgKz0gXyAqIGdlLCBFICs9IF8gKiBsZSwgUyArPSBfICogbmUsIHggKz0gXyAqIHVlLCB1ICs9IF8gKiBmZSwgbSArPSBfICogdGUsIGcgKz0gXyAqIHBlLCBQICs9IF8gKiBfZSwgRyArPSBfICogcmUsIE0gKz0gXyAqIEVlLCBIICs9IF8gKiBTZSwgQyArPSBfICogb2UsIHEgKz0gXyAqIERlLCBMICs9IF8gKiBJZSwgXyA9IHpbNl0sIGMgKz0gXyAqIHhlLCBiICs9IF8gKiBzZSwgRSArPSBfICogZ2UsIFMgKz0gXyAqIGxlLCB4ICs9IF8gKiBuZSwgdSArPSBfICogdWUsIG0gKz0gXyAqIGZlLCBnICs9IF8gKiB0ZSwgUCArPSBfICogcGUsIEcgKz0gXyAqIF9lLCBNICs9IF8gKiByZSwgSCArPSBfICogRWUsIEMgKz0gXyAqIFNlLCBxICs9IF8gKiBvZSwgTCArPSBfICogRGUsIHkgKz0gXyAqIEllLCBfID0gels3XSwgYiArPSBfICogeGUsIEUgKz0gXyAqIHNlLCBTICs9IF8gKiBnZSwgeCArPSBfICogbGUsIHUgKz0gXyAqIG5lLCBtICs9IF8gKiB1ZSwgZyArPSBfICogZmUsIFAgKz0gXyAqIHRlLCBHICs9IF8gKiBwZSwgTSArPSBfICogX2UsIEggKz0gXyAqIHJlLCBDICs9IF8gKiBFZSwgcSArPSBfICogU2UsIEwgKz0gXyAqIG9lLCB5ICs9IF8gKiBEZSwgRiArPSBfICogSWUsIF8gPSB6WzhdLCBFICs9IF8gKiB4ZSwgUyArPSBfICogc2UsIHggKz0gXyAqIGdlLCB1ICs9IF8gKiBsZSwgbSArPSBfICogbmUsIGcgKz0gXyAqIHVlLCBQICs9IF8gKiBmZSwgRyArPSBfICogdGUsIE0gKz0gXyAqIHBlLCBIICs9IF8gKiBfZSwgQyArPSBfICogcmUsIHEgKz0gXyAqIEVlLCBMICs9IF8gKiBTZSwgeSArPSBfICogb2UsIEYgKz0gXyAqIERlLCBXICs9IF8gKiBJZSwgXyA9IHpbOV0sIFMgKz0gXyAqIHhlLCB4ICs9IF8gKiBzZSwgdSArPSBfICogZ2UsIG0gKz0gXyAqIGxlLCBnICs9IF8gKiBuZSwgUCArPSBfICogdWUsIEcgKz0gXyAqIGZlLCBNICs9IF8gKiB0ZSwgSCArPSBfICogcGUsIEMgKz0gXyAqIF9lLCBxICs9IF8gKiByZSwgTCArPSBfICogRWUsIHkgKz0gXyAqIFNlLCBGICs9IF8gKiBvZSwgVyArPSBfICogRGUsIFkgKz0gXyAqIEllLCBfID0gelsxMF0sIHggKz0gXyAqIHhlLCB1ICs9IF8gKiBzZSwgbSArPSBfICogZ2UsIGcgKz0gXyAqIGxlLCBQICs9IF8gKiBuZSwgRyArPSBfICogdWUsIE0gKz0gXyAqIGZlLCBIICs9IF8gKiB0ZSwgQyArPSBfICogcGUsIHEgKz0gXyAqIF9lLCBMICs9IF8gKiByZSwgeSArPSBfICogRWUsIEYgKz0gXyAqIFNlLCBXICs9IF8gKiBvZSwgWSArPSBfICogRGUsIFggKz0gXyAqIEllLCBfID0gelsxMV0sIHUgKz0gXyAqIHhlLCBtICs9IF8gKiBzZSwgZyArPSBfICogZ2UsIFAgKz0gXyAqIGxlLCBHICs9IF8gKiBuZSwgTSArPSBfICogdWUsIEggKz0gXyAqIGZlLCBDICs9IF8gKiB0ZSwgcSArPSBfICogcGUsIEwgKz0gXyAqIF9lLCB5ICs9IF8gKiByZSwgRiArPSBfICogRWUsIFcgKz0gXyAqIFNlLCBZICs9IF8gKiBvZSwgWCArPSBfICogRGUsIGVlICs9IF8gKiBJZSwgXyA9IHpbMTJdLCBtICs9IF8gKiB4ZSwgZyArPSBfICogc2UsIFAgKz0gXyAqIGdlLCBHICs9IF8gKiBsZSwgTSArPSBfICogbmUsIEggKz0gXyAqIHVlLCBDICs9IF8gKiBmZSwgcSArPSBfICogdGUsIEwgKz0gXyAqIHBlLCB5ICs9IF8gKiBfZSwgRiArPSBfICogcmUsIFcgKz0gXyAqIEVlLCBZICs9IF8gKiBTZSwgWCArPSBfICogb2UsIGVlICs9IF8gKiBEZSwgd2UgKz0gXyAqIEllLCBfID0gelsxM10sIGcgKz0gXyAqIHhlLCBQICs9IF8gKiBzZSwgRyArPSBfICogZ2UsIE0gKz0gXyAqIGxlLCBIICs9IF8gKiBuZSwgQyArPSBfICogdWUsIHEgKz0gXyAqIGZlLCBMICs9IF8gKiB0ZSwgeSArPSBfICogcGUsIEYgKz0gXyAqIF9lLCBXICs9IF8gKiByZSwgWSArPSBfICogRWUsIFggKz0gXyAqIFNlLCBlZSArPSBfICogb2UsIHdlICs9IF8gKiBEZSwgTWUgKz0gXyAqIEllLCBfID0gelsxNF0sIFAgKz0gXyAqIHhlLCBHICs9IF8gKiBzZSwgTSArPSBfICogZ2UsIEggKz0gXyAqIGxlLCBDICs9IF8gKiBuZSwgcSArPSBfICogdWUsIEwgKz0gXyAqIGZlLCB5ICs9IF8gKiB0ZSwgRiArPSBfICogcGUsIFcgKz0gXyAqIF9lLCBZICs9IF8gKiByZSwgWCArPSBfICogRWUsIGVlICs9IF8gKiBTZSwgd2UgKz0gXyAqIG9lLCBNZSArPSBfICogRGUsIGhlICs9IF8gKiBJZSwgXyA9IHpbMTVdLCBHICs9IF8gKiB4ZSwgTSArPSBfICogc2UsIEggKz0gXyAqIGdlLCBDICs9IF8gKiBsZSwgcSArPSBfICogbmUsIEwgKz0gXyAqIHVlLCB5ICs9IF8gKiBmZSwgRiArPSBfICogdGUsIFcgKz0gXyAqIHBlLCBZICs9IF8gKiBfZSwgWCArPSBfICogcmUsIGVlICs9IF8gKiBFZSwgd2UgKz0gXyAqIFNlLCBNZSArPSBfICogb2UsIGhlICs9IF8gKiBEZSwgUmUgKz0gXyAqIEllLCBKICs9IDM4ICogTSwgUSArPSAzOCAqIEgsIE8gKz0gMzggKiBDLCBwICs9IDM4ICogcSwgbCArPSAzOCAqIEwsIGEgKz0gMzggKiB5LCBjICs9IDM4ICogRiwgYiArPSAzOCAqIFcsIEUgKz0gMzggKiBZLCBTICs9IDM4ICogWCwgeCArPSAzOCAqIGVlLCB1ICs9IDM4ICogd2UsIG0gKz0gMzggKiBNZSwgZyArPSAzOCAqIGhlLCBQICs9IDM4ICogUmUsIFIgPSAxLCBfID0gSiArIFIgKyA2NTUzNSwgUiA9IE1hdGguZmxvb3IoXyAvIDY1NTM2KSwgSiA9IF8gLSBSICogNjU1MzYsIF8gPSBRICsgUiArIDY1NTM1LCBSID0gTWF0aC5mbG9vcihfIC8gNjU1MzYpLCBRID0gXyAtIFIgKiA2NTUzNiwgXyA9IE8gKyBSICsgNjU1MzUsIFIgPSBNYXRoLmZsb29yKF8gLyA2NTUzNiksIE8gPSBfIC0gUiAqIDY1NTM2LCBfID0gcCArIFIgKyA2NTUzNSwgUiA9IE1hdGguZmxvb3IoXyAvIDY1NTM2KSwgcCA9IF8gLSBSICogNjU1MzYsIF8gPSBsICsgUiArIDY1NTM1LCBSID0gTWF0aC5mbG9vcihfIC8gNjU1MzYpLCBsID0gXyAtIFIgKiA2NTUzNiwgXyA9IGEgKyBSICsgNjU1MzUsIFIgPSBNYXRoLmZsb29yKF8gLyA2NTUzNiksIGEgPSBfIC0gUiAqIDY1NTM2LCBfID0gYyArIFIgKyA2NTUzNSwgUiA9IE1hdGguZmxvb3IoXyAvIDY1NTM2KSwgYyA9IF8gLSBSICogNjU1MzYsIF8gPSBiICsgUiArIDY1NTM1LCBSID0gTWF0aC5mbG9vcihfIC8gNjU1MzYpLCBiID0gXyAtIFIgKiA2NTUzNiwgXyA9IEUgKyBSICsgNjU1MzUsIFIgPSBNYXRoLmZsb29yKF8gLyA2NTUzNiksIEUgPSBfIC0gUiAqIDY1NTM2LCBfID0gUyArIFIgKyA2NTUzNSwgUiA9IE1hdGguZmxvb3IoXyAvIDY1NTM2KSwgUyA9IF8gLSBSICogNjU1MzYsIF8gPSB4ICsgUiArIDY1NTM1LCBSID0gTWF0aC5mbG9vcihfIC8gNjU1MzYpLCB4ID0gXyAtIFIgKiA2NTUzNiwgXyA9IHUgKyBSICsgNjU1MzUsIFIgPSBNYXRoLmZsb29yKF8gLyA2NTUzNiksIHUgPSBfIC0gUiAqIDY1NTM2LCBfID0gbSArIFIgKyA2NTUzNSwgUiA9IE1hdGguZmxvb3IoXyAvIDY1NTM2KSwgbSA9IF8gLSBSICogNjU1MzYsIF8gPSBnICsgUiArIDY1NTM1LCBSID0gTWF0aC5mbG9vcihfIC8gNjU1MzYpLCBnID0gXyAtIFIgKiA2NTUzNiwgXyA9IFAgKyBSICsgNjU1MzUsIFIgPSBNYXRoLmZsb29yKF8gLyA2NTUzNiksIFAgPSBfIC0gUiAqIDY1NTM2LCBfID0gRyArIFIgKyA2NTUzNSwgUiA9IE1hdGguZmxvb3IoXyAvIDY1NTM2KSwgRyA9IF8gLSBSICogNjU1MzYsIEogKz0gUiAtIDEgKyAzNyAqIChSIC0gMSksIFIgPSAxLCBfID0gSiArIFIgKyA2NTUzNSwgUiA9IE1hdGguZmxvb3IoXyAvIDY1NTM2KSwgSiA9IF8gLSBSICogNjU1MzYsIF8gPSBRICsgUiArIDY1NTM1LCBSID0gTWF0aC5mbG9vcihfIC8gNjU1MzYpLCBRID0gXyAtIFIgKiA2NTUzNiwgXyA9IE8gKyBSICsgNjU1MzUsIFIgPSBNYXRoLmZsb29yKF8gLyA2NTUzNiksIE8gPSBfIC0gUiAqIDY1NTM2LCBfID0gcCArIFIgKyA2NTUzNSwgUiA9IE1hdGguZmxvb3IoXyAvIDY1NTM2KSwgcCA9IF8gLSBSICogNjU1MzYsIF8gPSBsICsgUiArIDY1NTM1LCBSID0gTWF0aC5mbG9vcihfIC8gNjU1MzYpLCBsID0gXyAtIFIgKiA2NTUzNiwgXyA9IGEgKyBSICsgNjU1MzUsIFIgPSBNYXRoLmZsb29yKF8gLyA2NTUzNiksIGEgPSBfIC0gUiAqIDY1NTM2LCBfID0gYyArIFIgKyA2NTUzNSwgUiA9IE1hdGguZmxvb3IoXyAvIDY1NTM2KSwgYyA9IF8gLSBSICogNjU1MzYsIF8gPSBiICsgUiArIDY1NTM1LCBSID0gTWF0aC5mbG9vcihfIC8gNjU1MzYpLCBiID0gXyAtIFIgKiA2NTUzNiwgXyA9IEUgKyBSICsgNjU1MzUsIFIgPSBNYXRoLmZsb29yKF8gLyA2NTUzNiksIEUgPSBfIC0gUiAqIDY1NTM2LCBfID0gUyArIFIgKyA2NTUzNSwgUiA9IE1hdGguZmxvb3IoXyAvIDY1NTM2KSwgUyA9IF8gLSBSICogNjU1MzYsIF8gPSB4ICsgUiArIDY1NTM1LCBSID0gTWF0aC5mbG9vcihfIC8gNjU1MzYpLCB4ID0gXyAtIFIgKiA2NTUzNiwgXyA9IHUgKyBSICsgNjU1MzUsIFIgPSBNYXRoLmZsb29yKF8gLyA2NTUzNiksIHUgPSBfIC0gUiAqIDY1NTM2LCBfID0gbSArIFIgKyA2NTUzNSwgUiA9IE1hdGguZmxvb3IoXyAvIDY1NTM2KSwgbSA9IF8gLSBSICogNjU1MzYsIF8gPSBnICsgUiArIDY1NTM1LCBSID0gTWF0aC5mbG9vcihfIC8gNjU1MzYpLCBnID0gXyAtIFIgKiA2NTUzNiwgXyA9IFAgKyBSICsgNjU1MzUsIFIgPSBNYXRoLmZsb29yKF8gLyA2NTUzNiksIFAgPSBfIC0gUiAqIDY1NTM2LCBfID0gRyArIFIgKyA2NTUzNSwgUiA9IE1hdGguZmxvb3IoXyAvIDY1NTM2KSwgRyA9IF8gLSBSICogNjU1MzYsIEogKz0gUiAtIDEgKyAzNyAqIChSIC0gMSksICRbMF0gPSBKLCAkWzFdID0gUSwgJFsyXSA9IE8sICRbM10gPSBwLCAkWzRdID0gbCwgJFs1XSA9IGEsICRbNl0gPSBjLCAkWzddID0gYiwgJFs4XSA9IEUsICRbOV0gPSBTLCAkWzEwXSA9IHgsICRbMTFdID0gdSwgJFsxMl0gPSBtLCAkWzEzXSA9IGcsICRbMTRdID0gUCwgJFsxNV0gPSBHO1xuICB9XG4gIGZ1bmN0aW9uIEkoJCwgeikge1xuICAgIEEoJCwgeiwgeik7XG4gIH1cbiAgZnVuY3Rpb24gRCgkLCB6KSB7XG4gICAgY29uc3QgQiA9IGkoKTtcbiAgICBmb3IgKGxldCBfID0gMDsgXyA8IDE2OyBfKyspXG4gICAgICBCW19dID0geltfXTtcbiAgICBmb3IgKGxldCBfID0gMjUzOyBfID49IDA7IF8tLSlcbiAgICAgIEkoQiwgQiksIF8gIT09IDIgJiYgXyAhPT0gNCAmJiBBKEIsIEIsIHopO1xuICAgIGZvciAobGV0IF8gPSAwOyBfIDwgMTY7IF8rKylcbiAgICAgICRbX10gPSBCW19dO1xuICB9XG4gIGZ1bmN0aW9uIE4oJCwgeikge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDhBcnJheSgzMiksIF8gPSBuZXcgRmxvYXQ2NEFycmF5KDgwKSwgUiA9IGkoKSwgSiA9IGkoKSwgUSA9IGkoKSwgTyA9IGkoKSwgcCA9IGkoKSwgbCA9IGkoKTtcbiAgICBmb3IgKGxldCBFID0gMDsgRSA8IDMxOyBFKyspXG4gICAgICBCW0VdID0gJFtFXTtcbiAgICBCWzMxXSA9ICRbMzFdICYgMTI3IHwgNjQsIEJbMF0gJj0gMjQ4LCBkKF8sIHopO1xuICAgIGZvciAobGV0IEUgPSAwOyBFIDwgMTY7IEUrKylcbiAgICAgIEpbRV0gPSBfW0VdO1xuICAgIFJbMF0gPSBPWzBdID0gMTtcbiAgICBmb3IgKGxldCBFID0gMjU0OyBFID49IDA7IC0tRSkge1xuICAgICAgY29uc3QgUyA9IEJbRSA+Pj4gM10gPj4+IChFICYgNykgJiAxO1xuICAgICAgZihSLCBKLCBTKSwgZihRLCBPLCBTKSwgdihwLCBSLCBRKSwgdyhSLCBSLCBRKSwgdihRLCBKLCBPKSwgdyhKLCBKLCBPKSwgSShPLCBwKSwgSShsLCBSKSwgQShSLCBRLCBSKSwgQShRLCBKLCBwKSwgdihwLCBSLCBRKSwgdyhSLCBSLCBRKSwgSShKLCBSKSwgdyhRLCBPLCBsKSwgQShSLCBRLCBzKSwgdihSLCBSLCBPKSwgQShRLCBRLCBSKSwgQShSLCBPLCBsKSwgQShPLCBKLCBfKSwgSShKLCBwKSwgZihSLCBKLCBTKSwgZihRLCBPLCBTKTtcbiAgICB9XG4gICAgZm9yIChsZXQgRSA9IDA7IEUgPCAxNjsgRSsrKVxuICAgICAgX1tFICsgMTZdID0gUltFXSwgX1tFICsgMzJdID0gUVtFXSwgX1tFICsgNDhdID0gSltFXSwgX1tFICsgNjRdID0gT1tFXTtcbiAgICBjb25zdCBhID0gXy5zdWJhcnJheSgzMiksIGMgPSBfLnN1YmFycmF5KDE2KTtcbiAgICBEKGEsIGEpLCBBKGMsIGMsIGEpO1xuICAgIGNvbnN0IGIgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcmV0dXJuIGgoYiwgYyksIGI7XG4gIH1cbiAgci5zY2FsYXJNdWx0ID0gTjtcbiAgZnVuY3Rpb24gaygkKSB7XG4gICAgcmV0dXJuIE4oJCwgbik7XG4gIH1cbiAgci5zY2FsYXJNdWx0QmFzZSA9IGs7XG4gIGZ1bmN0aW9uIGooJCkge1xuICAgIGlmICgkLmxlbmd0aCAhPT0gci5TRUNSRVRfS0VZX0xFTkdUSClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgeDI1NTE5OiBzZWVkIG11c3QgYmUgJHtyLlNFQ1JFVF9LRVlfTEVOR1RIfSBieXRlc2ApO1xuICAgIGNvbnN0IHogPSBuZXcgVWludDhBcnJheSgkKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHVibGljS2V5OiBrKHopLFxuICAgICAgc2VjcmV0S2V5OiB6XG4gICAgfTtcbiAgfVxuICByLmdlbmVyYXRlS2V5UGFpckZyb21TZWVkID0gajtcbiAgZnVuY3Rpb24gVCgkKSB7XG4gICAgY29uc3QgeiA9ICgwLCBlLnJhbmRvbUJ5dGVzKSgzMiwgJCksIEIgPSBqKHopO1xuICAgIHJldHVybiAoMCwgdC53aXBlKSh6KSwgQjtcbiAgfVxuICByLmdlbmVyYXRlS2V5UGFpciA9IFQ7XG4gIGZ1bmN0aW9uIEsoJCwgeiwgQiA9ICExKSB7XG4gICAgaWYgKCQubGVuZ3RoICE9PSByLlBVQkxJQ19LRVlfTEVOR1RIKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWDI1NTE5OiBpbmNvcnJlY3Qgc2VjcmV0IGtleSBsZW5ndGhcIik7XG4gICAgaWYgKHoubGVuZ3RoICE9PSByLlBVQkxJQ19LRVlfTEVOR1RIKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWDI1NTE5OiBpbmNvcnJlY3QgcHVibGljIGtleSBsZW5ndGhcIik7XG4gICAgY29uc3QgXyA9IE4oJCwgeik7XG4gICAgaWYgKEIpIHtcbiAgICAgIGxldCBSID0gMDtcbiAgICAgIGZvciAobGV0IEogPSAwOyBKIDwgXy5sZW5ndGg7IEorKylcbiAgICAgICAgUiB8PSBfW0pdO1xuICAgICAgaWYgKFIgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlgyNTUxOTogaW52YWxpZCBzaGFyZWQga2V5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gXztcbiAgfVxuICByLnNoYXJlZEtleSA9IEs7XG59KShWbyk7XG52YXIgS3UgPSB7fTtcbmNvbnN0IFlnID0gXCJlbGxpcHRpY1wiLCBYZyA9IFwiNi42LjFcIiwgWmcgPSBcIkVDIGNyeXB0b2dyYXBoeVwiLCBRZyA9IFwibGliL2VsbGlwdGljLmpzXCIsIGUyID0gW1xuICBcImxpYlwiXG5dLCB0MiA9IHtcbiAgbGludDogXCJlc2xpbnQgbGliIHRlc3RcIixcbiAgXCJsaW50OmZpeFwiOiBcIm5wbSBydW4gbGludCAtLSAtLWZpeFwiLFxuICB1bml0OiBcImlzdGFuYnVsIHRlc3QgX21vY2hhIC0tcmVwb3J0ZXI9c3BlYyB0ZXN0L2luZGV4LmpzXCIsXG4gIHRlc3Q6IFwibnBtIHJ1biBsaW50ICYmIG5wbSBydW4gdW5pdFwiLFxuICB2ZXJzaW9uOiBcImdydW50IGRpc3QgJiYgZ2l0IGFkZCBkaXN0L1wiXG59LCByMiA9IHtcbiAgdHlwZTogXCJnaXRcIixcbiAgdXJsOiBcImdpdEBnaXRodWIuY29tOmluZHV0bnkvZWxsaXB0aWNcIlxufSwgaTIgPSBbXG4gIFwiRUNcIixcbiAgXCJFbGxpcHRpY1wiLFxuICBcImN1cnZlXCIsXG4gIFwiQ3J5cHRvZ3JhcGh5XCJcbl0sIG4yID0gXCJGZWRvciBJbmR1dG55IDxmZWRvckBpbmR1dG55LmNvbT5cIiwgczIgPSBcIk1JVFwiLCBhMiA9IHtcbiAgdXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljL2lzc3Vlc1wiXG59LCBvMiA9IFwiaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWNcIiwgZjIgPSB7XG4gIGJyZnM6IFwiXjIuMC4yXCIsXG4gIGNvdmVyYWxsczogXCJeMy4xLjBcIixcbiAgZXNsaW50OiBcIl43LjYuMFwiLFxuICBncnVudDogXCJeMS4yLjFcIixcbiAgXCJncnVudC1icm93c2VyaWZ5XCI6IFwiXjUuMy4wXCIsXG4gIFwiZ3J1bnQtY2xpXCI6IFwiXjEuMy4yXCIsXG4gIFwiZ3J1bnQtY29udHJpYi1jb25uZWN0XCI6IFwiXjMuMC4wXCIsXG4gIFwiZ3J1bnQtY29udHJpYi1jb3B5XCI6IFwiXjEuMC4wXCIsXG4gIFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJeNS4wLjBcIixcbiAgXCJncnVudC1tb2NoYS1pc3RhbmJ1bFwiOiBcIl41LjAuMlwiLFxuICBcImdydW50LXNhdWNlbGFic1wiOiBcIl45LjAuMVwiLFxuICBpc3RhbmJ1bDogXCJeMC40LjVcIixcbiAgbW9jaGE6IFwiXjguMC4xXCJcbn0sIGMyID0ge1xuICBcImJuLmpzXCI6IFwiXjQuMTEuOVwiLFxuICBicm9yYW5kOiBcIl4xLjEuMFwiLFxuICBcImhhc2guanNcIjogXCJeMS4wLjBcIixcbiAgXCJobWFjLWRyYmdcIjogXCJeMS4wLjFcIixcbiAgaW5oZXJpdHM6IFwiXjIuMC40XCIsXG4gIFwibWluaW1hbGlzdGljLWFzc2VydFwiOiBcIl4xLjAuMVwiLFxuICBcIm1pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHNcIjogXCJeMS4wLjFcIlxufSwgaDIgPSB7XG4gIG5hbWU6IFlnLFxuICB2ZXJzaW9uOiBYZyxcbiAgZGVzY3JpcHRpb246IFpnLFxuICBtYWluOiBRZyxcbiAgZmlsZXM6IGUyLFxuICBzY3JpcHRzOiB0MixcbiAgcmVwb3NpdG9yeTogcjIsXG4gIGtleXdvcmRzOiBpMixcbiAgYXV0aG9yOiBuMixcbiAgbGljZW5zZTogczIsXG4gIGJ1Z3M6IGEyLFxuICBob21lcGFnZTogbzIsXG4gIGRldkRlcGVuZGVuY2llczogZjIsXG4gIGRlcGVuZGVuY2llczogYzJcbn07XG52YXIgYXIgPSB7fSwgV28gPSB7IGV4cG9ydHM6IHt9IH07XG5Xby5leHBvcnRzO1xuKGZ1bmN0aW9uKHIpIHtcbiAgKGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBmdW5jdGlvbiBpKE8sIHApIHtcbiAgICAgIGlmICghTylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHAgfHwgXCJBc3NlcnRpb24gZmFpbGVkXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuKE8sIHApIHtcbiAgICAgIE8uc3VwZXJfID0gcDtcbiAgICAgIHZhciBsID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgbC5wcm90b3R5cGUgPSBwLnByb3RvdHlwZSwgTy5wcm90b3R5cGUgPSBuZXcgbCgpLCBPLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE87XG4gICAgfVxuICAgIGZ1bmN0aW9uIHMoTywgcCwgbCkge1xuICAgICAgaWYgKHMuaXNCTihPKSlcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMCwgdGhpcy53b3JkcyA9IG51bGwsIHRoaXMubGVuZ3RoID0gMCwgdGhpcy5yZWQgPSBudWxsLCBPICE9PSBudWxsICYmICgocCA9PT0gXCJsZVwiIHx8IHAgPT09IFwiYmVcIikgJiYgKGwgPSBwLCBwID0gMTApLCB0aGlzLl9pbml0KE8gfHwgMCwgcCB8fCAxMCwgbCB8fCBcImJlXCIpKTtcbiAgICB9XG4gICAgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUuZXhwb3J0cyA9IHMgOiB0LkJOID0gcywgcy5CTiA9IHMsIHMud29yZFNpemUgPSAyNjtcbiAgICB2YXIgbztcbiAgICB0cnkge1xuICAgICAgdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHR5cGVvZiB3aW5kb3cuQnVmZmVyIDwgXCJ1XCIgPyBvID0gd2luZG93LkJ1ZmZlciA6IG8gPSBmYS5CdWZmZXI7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHMuaXNCTiA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBwIGluc3RhbmNlb2YgcyA/ICEwIDogcCAhPT0gbnVsbCAmJiB0eXBlb2YgcCA9PSBcIm9iamVjdFwiICYmIHAuY29uc3RydWN0b3Iud29yZFNpemUgPT09IHMud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShwLndvcmRzKTtcbiAgICB9LCBzLm1heCA9IGZ1bmN0aW9uKHAsIGwpIHtcbiAgICAgIHJldHVybiBwLmNtcChsKSA+IDAgPyBwIDogbDtcbiAgICB9LCBzLm1pbiA9IGZ1bmN0aW9uKHAsIGwpIHtcbiAgICAgIHJldHVybiBwLmNtcChsKSA8IDAgPyBwIDogbDtcbiAgICB9LCBzLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKHAsIGwsIGEpIHtcbiAgICAgIGlmICh0eXBlb2YgcCA9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihwLCBsLCBhKTtcbiAgICAgIGlmICh0eXBlb2YgcCA9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KHAsIGwsIGEpO1xuICAgICAgbCA9PT0gXCJoZXhcIiAmJiAobCA9IDE2KSwgaShsID09PSAobCB8IDApICYmIGwgPj0gMiAmJiBsIDw9IDM2KSwgcCA9IHAudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csIFwiXCIpO1xuICAgICAgdmFyIGMgPSAwO1xuICAgICAgcFswXSA9PT0gXCItXCIgJiYgKGMrKywgdGhpcy5uZWdhdGl2ZSA9IDEpLCBjIDwgcC5sZW5ndGggJiYgKGwgPT09IDE2ID8gdGhpcy5fcGFyc2VIZXgocCwgYywgYSkgOiAodGhpcy5fcGFyc2VCYXNlKHAsIGwsIGMpLCBhID09PSBcImxlXCIgJiYgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBsLCBhKSkpO1xuICAgIH0sIHMucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24ocCwgbCwgYSkge1xuICAgICAgcCA8IDAgJiYgKHRoaXMubmVnYXRpdmUgPSAxLCBwID0gLXApLCBwIDwgNjcxMDg4NjQgPyAodGhpcy53b3JkcyA9IFtwICYgNjcxMDg4NjNdLCB0aGlzLmxlbmd0aCA9IDEpIDogcCA8IDQ1MDM1OTk2MjczNzA0OTYgPyAodGhpcy53b3JkcyA9IFtcbiAgICAgICAgcCAmIDY3MTA4ODYzLFxuICAgICAgICBwIC8gNjcxMDg4NjQgJiA2NzEwODg2M1xuICAgICAgXSwgdGhpcy5sZW5ndGggPSAyKSA6IChpKHAgPCA5MDA3MTk5MjU0NzQwOTkyKSwgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgcCAmIDY3MTA4ODYzLFxuICAgICAgICBwIC8gNjcxMDg4NjQgJiA2NzEwODg2MyxcbiAgICAgICAgMVxuICAgICAgXSwgdGhpcy5sZW5ndGggPSAzKSwgYSA9PT0gXCJsZVwiICYmIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgbCwgYSk7XG4gICAgfSwgcy5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uKHAsIGwsIGEpIHtcbiAgICAgIGlmIChpKHR5cGVvZiBwLmxlbmd0aCA9PSBcIm51bWJlclwiKSwgcC5sZW5ndGggPD0gMClcbiAgICAgICAgcmV0dXJuIHRoaXMud29yZHMgPSBbMF0sIHRoaXMubGVuZ3RoID0gMSwgdGhpcztcbiAgICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKHAubGVuZ3RoIC8gMyksIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0aGlzLmxlbmd0aDsgYysrKVxuICAgICAgICB0aGlzLndvcmRzW2NdID0gMDtcbiAgICAgIHZhciBiLCBFLCBTID0gMDtcbiAgICAgIGlmIChhID09PSBcImJlXCIpXG4gICAgICAgIGZvciAoYyA9IHAubGVuZ3RoIC0gMSwgYiA9IDA7IGMgPj0gMDsgYyAtPSAzKVxuICAgICAgICAgIEUgPSBwW2NdIHwgcFtjIC0gMV0gPDwgOCB8IHBbYyAtIDJdIDw8IDE2LCB0aGlzLndvcmRzW2JdIHw9IEUgPDwgUyAmIDY3MTA4ODYzLCB0aGlzLndvcmRzW2IgKyAxXSA9IEUgPj4+IDI2IC0gUyAmIDY3MTA4ODYzLCBTICs9IDI0LCBTID49IDI2ICYmIChTIC09IDI2LCBiKyspO1xuICAgICAgZWxzZSBpZiAoYSA9PT0gXCJsZVwiKVxuICAgICAgICBmb3IgKGMgPSAwLCBiID0gMDsgYyA8IHAubGVuZ3RoOyBjICs9IDMpXG4gICAgICAgICAgRSA9IHBbY10gfCBwW2MgKyAxXSA8PCA4IHwgcFtjICsgMl0gPDwgMTYsIHRoaXMud29yZHNbYl0gfD0gRSA8PCBTICYgNjcxMDg4NjMsIHRoaXMud29yZHNbYiArIDFdID0gRSA+Pj4gMjYgLSBTICYgNjcxMDg4NjMsIFMgKz0gMjQsIFMgPj0gMjYgJiYgKFMgLT0gMjYsIGIrKyk7XG4gICAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZihPLCBwKSB7XG4gICAgICB2YXIgbCA9IE8uY2hhckNvZGVBdChwKTtcbiAgICAgIHJldHVybiBsID49IDY1ICYmIGwgPD0gNzAgPyBsIC0gNTUgOiBsID49IDk3ICYmIGwgPD0gMTAyID8gbCAtIDg3IDogbCAtIDQ4ICYgMTU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGgoTywgcCwgbCkge1xuICAgICAgdmFyIGEgPSBmKE8sIGwpO1xuICAgICAgcmV0dXJuIGwgLSAxID49IHAgJiYgKGEgfD0gZihPLCBsIC0gMSkgPDwgNCksIGE7XG4gICAgfVxuICAgIHMucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uKHAsIGwsIGEpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChwLmxlbmd0aCAtIGwpIC8gNiksIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0aGlzLmxlbmd0aDsgYysrKVxuICAgICAgICB0aGlzLndvcmRzW2NdID0gMDtcbiAgICAgIHZhciBiID0gMCwgRSA9IDAsIFM7XG4gICAgICBpZiAoYSA9PT0gXCJiZVwiKVxuICAgICAgICBmb3IgKGMgPSBwLmxlbmd0aCAtIDE7IGMgPj0gbDsgYyAtPSAyKVxuICAgICAgICAgIFMgPSBoKHAsIGwsIGMpIDw8IGIsIHRoaXMud29yZHNbRV0gfD0gUyAmIDY3MTA4ODYzLCBiID49IDE4ID8gKGIgLT0gMTgsIEUgKz0gMSwgdGhpcy53b3Jkc1tFXSB8PSBTID4+PiAyNikgOiBiICs9IDg7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHggPSBwLmxlbmd0aCAtIGw7XG4gICAgICAgIGZvciAoYyA9IHggJSAyID09PSAwID8gbCArIDEgOiBsOyBjIDwgcC5sZW5ndGg7IGMgKz0gMilcbiAgICAgICAgICBTID0gaChwLCBsLCBjKSA8PCBiLCB0aGlzLndvcmRzW0VdIHw9IFMgJiA2NzEwODg2MywgYiA+PSAxOCA/IChiIC09IDE4LCBFICs9IDEsIHRoaXMud29yZHNbRV0gfD0gUyA+Pj4gMjYpIDogYiArPSA4O1xuICAgICAgfVxuICAgICAgdGhpcy5zdHJpcCgpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZChPLCBwLCBsLCBhKSB7XG4gICAgICBmb3IgKHZhciBjID0gMCwgYiA9IE1hdGgubWluKE8ubGVuZ3RoLCBsKSwgRSA9IHA7IEUgPCBiOyBFKyspIHtcbiAgICAgICAgdmFyIFMgPSBPLmNoYXJDb2RlQXQoRSkgLSA0ODtcbiAgICAgICAgYyAqPSBhLCBTID49IDQ5ID8gYyArPSBTIC0gNDkgKyAxMCA6IFMgPj0gMTcgPyBjICs9IFMgLSAxNyArIDEwIDogYyArPSBTO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHMucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbihwLCBsLCBhKSB7XG4gICAgICB0aGlzLndvcmRzID0gWzBdLCB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICBmb3IgKHZhciBjID0gMCwgYiA9IDE7IGIgPD0gNjcxMDg4NjM7IGIgKj0gbClcbiAgICAgICAgYysrO1xuICAgICAgYy0tLCBiID0gYiAvIGwgfCAwO1xuICAgICAgZm9yICh2YXIgRSA9IHAubGVuZ3RoIC0gYSwgUyA9IEUgJSBjLCB4ID0gTWF0aC5taW4oRSwgRSAtIFMpICsgYSwgdSA9IDAsIG0gPSBhOyBtIDwgeDsgbSArPSBjKVxuICAgICAgICB1ID0gZChwLCBtLCBtICsgYywgbCksIHRoaXMuaW11bG4oYiksIHRoaXMud29yZHNbMF0gKyB1IDwgNjcxMDg4NjQgPyB0aGlzLndvcmRzWzBdICs9IHUgOiB0aGlzLl9pYWRkbih1KTtcbiAgICAgIGlmIChTICE9PSAwKSB7XG4gICAgICAgIHZhciBnID0gMTtcbiAgICAgICAgZm9yICh1ID0gZChwLCBtLCBwLmxlbmd0aCwgbCksIG0gPSAwOyBtIDwgUzsgbSsrKVxuICAgICAgICAgIGcgKj0gbDtcbiAgICAgICAgdGhpcy5pbXVsbihnKSwgdGhpcy53b3Jkc1swXSArIHUgPCA2NzEwODg2NCA/IHRoaXMud29yZHNbMF0gKz0gdSA6IHRoaXMuX2lhZGRuKHUpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdHJpcCgpO1xuICAgIH0sIHMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihwKSB7XG4gICAgICBwLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdGhpcy5sZW5ndGg7IGwrKylcbiAgICAgICAgcC53b3Jkc1tsXSA9IHRoaXMud29yZHNbbF07XG4gICAgICBwLmxlbmd0aCA9IHRoaXMubGVuZ3RoLCBwLm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZSwgcC5yZWQgPSB0aGlzLnJlZDtcbiAgICB9LCBzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHAgPSBuZXcgcyhudWxsKTtcbiAgICAgIHJldHVybiB0aGlzLmNvcHkocCksIHA7XG4gICAgfSwgcy5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIGZvciAoOyB0aGlzLmxlbmd0aCA8IHA7IClcbiAgICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBzLnByb3RvdHlwZS5zdHJpcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICg7IHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDA7IClcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH0sIHMucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDAgJiYgKHRoaXMubmVnYXRpdmUgPSAwKSwgdGhpcztcbiAgICB9LCBzLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKHRoaXMucmVkID8gXCI8Qk4tUjogXCIgOiBcIjxCTjogXCIpICsgdGhpcy50b1N0cmluZygxNikgKyBcIj5cIjtcbiAgICB9O1xuICAgIHZhciB2ID0gW1xuICAgICAgXCJcIixcbiAgICAgIFwiMFwiLFxuICAgICAgXCIwMFwiLFxuICAgICAgXCIwMDBcIixcbiAgICAgIFwiMDAwMFwiLFxuICAgICAgXCIwMDAwMFwiLFxuICAgICAgXCIwMDAwMDBcIixcbiAgICAgIFwiMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDBcIixcbiAgICAgIFwiMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDBcIixcbiAgICAgIFwiMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgIFwiMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgIFwiMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgIFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgIFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiXG4gICAgXSwgdyA9IFtcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMjUsXG4gICAgICAxNixcbiAgICAgIDEyLFxuICAgICAgMTEsXG4gICAgICAxMCxcbiAgICAgIDksXG4gICAgICA4LFxuICAgICAgOCxcbiAgICAgIDcsXG4gICAgICA3LFxuICAgICAgNyxcbiAgICAgIDcsXG4gICAgICA2LFxuICAgICAgNixcbiAgICAgIDYsXG4gICAgICA2LFxuICAgICAgNixcbiAgICAgIDYsXG4gICAgICA2LFxuICAgICAgNSxcbiAgICAgIDUsXG4gICAgICA1LFxuICAgICAgNSxcbiAgICAgIDUsXG4gICAgICA1LFxuICAgICAgNSxcbiAgICAgIDUsXG4gICAgICA1LFxuICAgICAgNSxcbiAgICAgIDUsXG4gICAgICA1LFxuICAgICAgNSxcbiAgICAgIDUsXG4gICAgICA1LFxuICAgICAgNVxuICAgIF0sIEEgPSBbXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDMzNTU0NDMyLFxuICAgICAgNDMwNDY3MjEsXG4gICAgICAxNjc3NzIxNixcbiAgICAgIDQ4ODI4MTI1LFxuICAgICAgNjA0NjYxNzYsXG4gICAgICA0MDM1MzYwNyxcbiAgICAgIDE2Nzc3MjE2LFxuICAgICAgNDMwNDY3MjEsXG4gICAgICAxZTcsXG4gICAgICAxOTQ4NzE3MSxcbiAgICAgIDM1ODMxODA4LFxuICAgICAgNjI3NDg1MTcsXG4gICAgICA3NTI5NTM2LFxuICAgICAgMTEzOTA2MjUsXG4gICAgICAxNjc3NzIxNixcbiAgICAgIDI0MTM3NTY5LFxuICAgICAgMzQwMTIyMjQsXG4gICAgICA0NzA0NTg4MSxcbiAgICAgIDY0ZTYsXG4gICAgICA0MDg0MTAxLFxuICAgICAgNTE1MzYzMixcbiAgICAgIDY0MzYzNDMsXG4gICAgICA3OTYyNjI0LFxuICAgICAgOTc2NTYyNSxcbiAgICAgIDExODgxMzc2LFxuICAgICAgMTQzNDg5MDcsXG4gICAgICAxNzIxMDM2OCxcbiAgICAgIDIwNTExMTQ5LFxuICAgICAgMjQzZTUsXG4gICAgICAyODYyOTE1MSxcbiAgICAgIDMzNTU0NDMyLFxuICAgICAgMzkxMzUzOTMsXG4gICAgICA0NTQzNTQyNCxcbiAgICAgIDUyNTIxODc1LFxuICAgICAgNjA0NjYxNzZcbiAgICBdO1xuICAgIHMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ocCwgbCkge1xuICAgICAgcCA9IHAgfHwgMTAsIGwgPSBsIHwgMCB8fCAxO1xuICAgICAgdmFyIGE7XG4gICAgICBpZiAocCA9PT0gMTYgfHwgcCA9PT0gXCJoZXhcIikge1xuICAgICAgICBhID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgYyA9IDAsIGIgPSAwLCBFID0gMDsgRSA8IHRoaXMubGVuZ3RoOyBFKyspIHtcbiAgICAgICAgICB2YXIgUyA9IHRoaXMud29yZHNbRV0sIHggPSAoKFMgPDwgYyB8IGIpICYgMTY3NzcyMTUpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICBiID0gUyA+Pj4gMjQgLSBjICYgMTY3NzcyMTUsIGMgKz0gMiwgYyA+PSAyNiAmJiAoYyAtPSAyNiwgRS0tKSwgYiAhPT0gMCB8fCBFICE9PSB0aGlzLmxlbmd0aCAtIDEgPyBhID0gdls2IC0geC5sZW5ndGhdICsgeCArIGEgOiBhID0geCArIGE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChiICE9PSAwICYmIChhID0gYi50b1N0cmluZygxNikgKyBhKTsgYS5sZW5ndGggJSBsICE9PSAwOyApXG4gICAgICAgICAgYSA9IFwiMFwiICsgYTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDAgJiYgKGEgPSBcIi1cIiArIGEpLCBhO1xuICAgICAgfVxuICAgICAgaWYgKHAgPT09IChwIHwgMCkgJiYgcCA+PSAyICYmIHAgPD0gMzYpIHtcbiAgICAgICAgdmFyIHUgPSB3W3BdLCBtID0gQVtwXTtcbiAgICAgICAgYSA9IFwiXCI7XG4gICAgICAgIHZhciBnID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBmb3IgKGcubmVnYXRpdmUgPSAwOyAhZy5pc1plcm8oKTsgKSB7XG4gICAgICAgICAgdmFyIFAgPSBnLm1vZG4obSkudG9TdHJpbmcocCk7XG4gICAgICAgICAgZyA9IGcuaWRpdm4obSksIGcuaXNaZXJvKCkgPyBhID0gUCArIGEgOiBhID0gdlt1IC0gUC5sZW5ndGhdICsgUCArIGE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh0aGlzLmlzWmVybygpICYmIChhID0gXCIwXCIgKyBhKTsgYS5sZW5ndGggJSBsICE9PSAwOyApXG4gICAgICAgICAgYSA9IFwiMFwiICsgYTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDAgJiYgKGEgPSBcIi1cIiArIGEpLCBhO1xuICAgICAgfVxuICAgICAgaSghMSwgXCJCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2XCIpO1xuICAgIH0sIHMucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IHRoaXMud29yZHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDIgPyBwICs9IHRoaXMud29yZHNbMV0gKiA2NzEwODg2NCA6IHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDEgPyBwICs9IDQ1MDM1OTk2MjczNzA0OTYgKyB0aGlzLndvcmRzWzFdICogNjcxMDg4NjQgOiB0aGlzLmxlbmd0aCA+IDIgJiYgaSghMSwgXCJOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHNcIiksIHRoaXMubmVnYXRpdmUgIT09IDAgPyAtcCA6IHA7XG4gICAgfSwgcy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG4gICAgfSwgcy5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbihwLCBsKSB7XG4gICAgICByZXR1cm4gaSh0eXBlb2YgbyA8IFwidVwiKSwgdGhpcy50b0FycmF5TGlrZShvLCBwLCBsKTtcbiAgICB9LCBzLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24ocCwgbCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIHAsIGwpO1xuICAgIH0sIHMucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24ocCwgbCwgYSkge1xuICAgICAgdmFyIGMgPSB0aGlzLmJ5dGVMZW5ndGgoKSwgYiA9IGEgfHwgTWF0aC5tYXgoMSwgYyk7XG4gICAgICBpKGMgPD0gYiwgXCJieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoXCIpLCBpKGIgPiAwLCBcIlJlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMFwiKSwgdGhpcy5zdHJpcCgpO1xuICAgICAgdmFyIEUgPSBsID09PSBcImxlXCIsIFMgPSBuZXcgcChiKSwgeCwgdSwgbSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGlmIChFKSB7XG4gICAgICAgIGZvciAodSA9IDA7ICFtLmlzWmVybygpOyB1KyspXG4gICAgICAgICAgeCA9IG0uYW5kbG4oMjU1KSwgbS5pdXNocm4oOCksIFNbdV0gPSB4O1xuICAgICAgICBmb3IgKDsgdSA8IGI7IHUrKylcbiAgICAgICAgICBTW3VdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodSA9IDA7IHUgPCBiIC0gYzsgdSsrKVxuICAgICAgICAgIFNbdV0gPSAwO1xuICAgICAgICBmb3IgKHUgPSAwOyAhbS5pc1plcm8oKTsgdSsrKVxuICAgICAgICAgIHggPSBtLmFuZGxuKDI1NSksIG0uaXVzaHJuKDgpLCBTW2IgLSB1IC0gMV0gPSB4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFM7XG4gICAgfSwgTWF0aC5jbHozMiA/IHMucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHApO1xuICAgIH0gOiBzLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGwgPSBwLCBhID0gMDtcbiAgICAgIHJldHVybiBsID49IDQwOTYgJiYgKGEgKz0gMTMsIGwgPj4+PSAxMyksIGwgPj0gNjQgJiYgKGEgKz0gNywgbCA+Pj49IDcpLCBsID49IDggJiYgKGEgKz0gNCwgbCA+Pj49IDQpLCBsID49IDIgJiYgKGEgKz0gMiwgbCA+Pj49IDIpLCBhICsgbDtcbiAgICB9LCBzLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbihwKSB7XG4gICAgICBpZiAocCA9PT0gMClcbiAgICAgICAgcmV0dXJuIDI2O1xuICAgICAgdmFyIGwgPSBwLCBhID0gMDtcbiAgICAgIHJldHVybiBsICYgODE5MSB8fCAoYSArPSAxMywgbCA+Pj49IDEzKSwgbCAmIDEyNyB8fCAoYSArPSA3LCBsID4+Pj0gNyksIGwgJiAxNSB8fCAoYSArPSA0LCBsID4+Pj0gNCksIGwgJiAzIHx8IChhICs9IDIsIGwgPj4+PSAyKSwgbCAmIDEgfHwgYSsrLCBhO1xuICAgIH0sIHMucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHAgPSB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0sIGwgPSB0aGlzLl9jb3VudEJpdHMocCk7XG4gICAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGw7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBJKE8pIHtcbiAgICAgIGZvciAodmFyIHAgPSBuZXcgQXJyYXkoTy5iaXRMZW5ndGgoKSksIGwgPSAwOyBsIDwgcC5sZW5ndGg7IGwrKykge1xuICAgICAgICB2YXIgYSA9IGwgLyAyNiB8IDAsIGMgPSBsICUgMjY7XG4gICAgICAgIHBbbF0gPSAoTy53b3Jkc1thXSAmIDEgPDwgYykgPj4+IGM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgcy5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzWmVybygpKVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGZvciAodmFyIHAgPSAwLCBsID0gMDsgbCA8IHRoaXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2xdKTtcbiAgICAgICAgaWYgKHAgKz0gYSwgYSAhPT0gMjYpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9LCBzLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbiAgICB9LCBzLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMCA/IHRoaXMuYWJzKCkuaW5vdG4ocCkuaWFkZG4oMSkgOiB0aGlzLmNsb25lKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXN0bihwIC0gMSkgPyB0aGlzLm5vdG4ocCkuaWFkZG4oMSkuaW5lZygpIDogdGhpcy5jbG9uZSgpO1xuICAgIH0sIHMucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMDtcbiAgICB9LCBzLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuICAgIH0sIHMucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzWmVybygpIHx8ICh0aGlzLm5lZ2F0aXZlIF49IDEpLCB0aGlzO1xuICAgIH0sIHMucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbihwKSB7XG4gICAgICBmb3IgKDsgdGhpcy5sZW5ndGggPCBwLmxlbmd0aDsgKVxuICAgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgcC5sZW5ndGg7IGwrKylcbiAgICAgICAgdGhpcy53b3Jkc1tsXSA9IHRoaXMud29yZHNbbF0gfCBwLndvcmRzW2xdO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gaSgodGhpcy5uZWdhdGl2ZSB8IHAubmVnYXRpdmUpID09PSAwKSwgdGhpcy5pdW9yKHApO1xuICAgIH0sIHMucHJvdG90eXBlLm9yID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcC5sZW5ndGggPyB0aGlzLmNsb25lKCkuaW9yKHApIDogcC5jbG9uZSgpLmlvcih0aGlzKTtcbiAgICB9LCBzLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPiBwLmxlbmd0aCA/IHRoaXMuY2xvbmUoKS5pdW9yKHApIDogcC5jbG9uZSgpLml1b3IodGhpcyk7XG4gICAgfSwgcy5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgbDtcbiAgICAgIHRoaXMubGVuZ3RoID4gcC5sZW5ndGggPyBsID0gcCA6IGwgPSB0aGlzO1xuICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBsLmxlbmd0aDsgYSsrKVxuICAgICAgICB0aGlzLndvcmRzW2FdID0gdGhpcy53b3Jkc1thXSAmIHAud29yZHNbYV07XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPSBsLmxlbmd0aCwgdGhpcy5zdHJpcCgpO1xuICAgIH0sIHMucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gaSgodGhpcy5uZWdhdGl2ZSB8IHAubmVnYXRpdmUpID09PSAwKSwgdGhpcy5pdWFuZChwKTtcbiAgICB9LCBzLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPiBwLmxlbmd0aCA/IHRoaXMuY2xvbmUoKS5pYW5kKHApIDogcC5jbG9uZSgpLmlhbmQodGhpcyk7XG4gICAgfSwgcy5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IHAubGVuZ3RoID8gdGhpcy5jbG9uZSgpLml1YW5kKHApIDogcC5jbG9uZSgpLml1YW5kKHRoaXMpO1xuICAgIH0sIHMucHJvdG90eXBlLml1eG9yID0gZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGwsIGE7XG4gICAgICB0aGlzLmxlbmd0aCA+IHAubGVuZ3RoID8gKGwgPSB0aGlzLCBhID0gcCkgOiAobCA9IHAsIGEgPSB0aGlzKTtcbiAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgYS5sZW5ndGg7IGMrKylcbiAgICAgICAgdGhpcy53b3Jkc1tjXSA9IGwud29yZHNbY10gXiBhLndvcmRzW2NdO1xuICAgICAgaWYgKHRoaXMgIT09IGwpXG4gICAgICAgIGZvciAoOyBjIDwgbC5sZW5ndGg7IGMrKylcbiAgICAgICAgICB0aGlzLndvcmRzW2NdID0gbC53b3Jkc1tjXTtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9IGwubGVuZ3RoLCB0aGlzLnN0cmlwKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBpKCh0aGlzLm5lZ2F0aXZlIHwgcC5uZWdhdGl2ZSkgPT09IDApLCB0aGlzLml1eG9yKHApO1xuICAgIH0sIHMucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IHAubGVuZ3RoID8gdGhpcy5jbG9uZSgpLml4b3IocCkgOiBwLmNsb25lKCkuaXhvcih0aGlzKTtcbiAgICB9LCBzLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gcC5sZW5ndGggPyB0aGlzLmNsb25lKCkuaXV4b3IocCkgOiBwLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gICAgfSwgcy5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbihwKSB7XG4gICAgICBpKHR5cGVvZiBwID09IFwibnVtYmVyXCIgJiYgcCA+PSAwKTtcbiAgICAgIHZhciBsID0gTWF0aC5jZWlsKHAgLyAyNikgfCAwLCBhID0gcCAlIDI2O1xuICAgICAgdGhpcy5fZXhwYW5kKGwpLCBhID4gMCAmJiBsLS07XG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGw7IGMrKylcbiAgICAgICAgdGhpcy53b3Jkc1tjXSA9IH50aGlzLndvcmRzW2NdICYgNjcxMDg4NjM7XG4gICAgICByZXR1cm4gYSA+IDAgJiYgKHRoaXMud29yZHNbY10gPSB+dGhpcy53b3Jkc1tjXSAmIDY3MTA4ODYzID4+IDI2IC0gYSksIHRoaXMuc3RyaXAoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bihwKTtcbiAgICB9LCBzLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24ocCwgbCkge1xuICAgICAgaSh0eXBlb2YgcCA9PSBcIm51bWJlclwiICYmIHAgPj0gMCk7XG4gICAgICB2YXIgYSA9IHAgLyAyNiB8IDAsIGMgPSBwICUgMjY7XG4gICAgICByZXR1cm4gdGhpcy5fZXhwYW5kKGEgKyAxKSwgbCA/IHRoaXMud29yZHNbYV0gPSB0aGlzLndvcmRzW2FdIHwgMSA8PCBjIDogdGhpcy53b3Jkc1thXSA9IHRoaXMud29yZHNbYV0gJiB+KDEgPDwgYyksIHRoaXMuc3RyaXAoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGw7XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBwLm5lZ2F0aXZlID09PSAwKVxuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSA9IDAsIGwgPSB0aGlzLmlzdWIocCksIHRoaXMubmVnYXRpdmUgXj0gMSwgdGhpcy5fbm9ybVNpZ24oKTtcbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIHAubmVnYXRpdmUgIT09IDApXG4gICAgICAgIHJldHVybiBwLm5lZ2F0aXZlID0gMCwgbCA9IHRoaXMuaXN1YihwKSwgcC5uZWdhdGl2ZSA9IDEsIGwuX25vcm1TaWduKCk7XG4gICAgICB2YXIgYSwgYztcbiAgICAgIHRoaXMubGVuZ3RoID4gcC5sZW5ndGggPyAoYSA9IHRoaXMsIGMgPSBwKSA6IChhID0gcCwgYyA9IHRoaXMpO1xuICAgICAgZm9yICh2YXIgYiA9IDAsIEUgPSAwOyBFIDwgYy5sZW5ndGg7IEUrKylcbiAgICAgICAgbCA9IChhLndvcmRzW0VdIHwgMCkgKyAoYy53b3Jkc1tFXSB8IDApICsgYiwgdGhpcy53b3Jkc1tFXSA9IGwgJiA2NzEwODg2MywgYiA9IGwgPj4+IDI2O1xuICAgICAgZm9yICg7IGIgIT09IDAgJiYgRSA8IGEubGVuZ3RoOyBFKyspXG4gICAgICAgIGwgPSAoYS53b3Jkc1tFXSB8IDApICsgYiwgdGhpcy53b3Jkc1tFXSA9IGwgJiA2NzEwODg2MywgYiA9IGwgPj4+IDI2O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID0gYS5sZW5ndGgsIGIgIT09IDApXG4gICAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gYiwgdGhpcy5sZW5ndGgrKztcbiAgICAgIGVsc2UgaWYgKGEgIT09IHRoaXMpXG4gICAgICAgIGZvciAoOyBFIDwgYS5sZW5ndGg7IEUrKylcbiAgICAgICAgICB0aGlzLndvcmRzW0VdID0gYS53b3Jkc1tFXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIHMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBsO1xuICAgICAgcmV0dXJuIHAubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCA/IChwLm5lZ2F0aXZlID0gMCwgbCA9IHRoaXMuc3ViKHApLCBwLm5lZ2F0aXZlIF49IDEsIGwpIDogcC5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwID8gKHRoaXMubmVnYXRpdmUgPSAwLCBsID0gcC5zdWIodGhpcyksIHRoaXMubmVnYXRpdmUgPSAxLCBsKSA6IHRoaXMubGVuZ3RoID4gcC5sZW5ndGggPyB0aGlzLmNsb25lKCkuaWFkZChwKSA6IHAuY2xvbmUoKS5pYWRkKHRoaXMpO1xuICAgIH0sIHMucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbihwKSB7XG4gICAgICBpZiAocC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBwLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgdmFyIGwgPSB0aGlzLmlhZGQocCk7XG4gICAgICAgIHJldHVybiBwLm5lZ2F0aXZlID0gMSwgbC5fbm9ybVNpZ24oKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMClcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgPSAwLCB0aGlzLmlhZGQocCksIHRoaXMubmVnYXRpdmUgPSAxLCB0aGlzLl9ub3JtU2lnbigpO1xuICAgICAgdmFyIGEgPSB0aGlzLmNtcChwKTtcbiAgICAgIGlmIChhID09PSAwKVxuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSA9IDAsIHRoaXMubGVuZ3RoID0gMSwgdGhpcy53b3Jkc1swXSA9IDAsIHRoaXM7XG4gICAgICB2YXIgYywgYjtcbiAgICAgIGEgPiAwID8gKGMgPSB0aGlzLCBiID0gcCkgOiAoYyA9IHAsIGIgPSB0aGlzKTtcbiAgICAgIGZvciAodmFyIEUgPSAwLCBTID0gMDsgUyA8IGIubGVuZ3RoOyBTKyspXG4gICAgICAgIGwgPSAoYy53b3Jkc1tTXSB8IDApIC0gKGIud29yZHNbU10gfCAwKSArIEUsIEUgPSBsID4+IDI2LCB0aGlzLndvcmRzW1NdID0gbCAmIDY3MTA4ODYzO1xuICAgICAgZm9yICg7IEUgIT09IDAgJiYgUyA8IGMubGVuZ3RoOyBTKyspXG4gICAgICAgIGwgPSAoYy53b3Jkc1tTXSB8IDApICsgRSwgRSA9IGwgPj4gMjYsIHRoaXMud29yZHNbU10gPSBsICYgNjcxMDg4NjM7XG4gICAgICBpZiAoRSA9PT0gMCAmJiBTIDwgYy5sZW5ndGggJiYgYyAhPT0gdGhpcylcbiAgICAgICAgZm9yICg7IFMgPCBjLmxlbmd0aDsgUysrKVxuICAgICAgICAgIHRoaXMud29yZHNbU10gPSBjLndvcmRzW1NdO1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIFMpLCBjICE9PSB0aGlzICYmICh0aGlzLm5lZ2F0aXZlID0gMSksIHRoaXMuc3RyaXAoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIocCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBEKE8sIHAsIGwpIHtcbiAgICAgIGwubmVnYXRpdmUgPSBwLm5lZ2F0aXZlIF4gTy5uZWdhdGl2ZTtcbiAgICAgIHZhciBhID0gTy5sZW5ndGggKyBwLmxlbmd0aCB8IDA7XG4gICAgICBsLmxlbmd0aCA9IGEsIGEgPSBhIC0gMSB8IDA7XG4gICAgICB2YXIgYyA9IE8ud29yZHNbMF0gfCAwLCBiID0gcC53b3Jkc1swXSB8IDAsIEUgPSBjICogYiwgUyA9IEUgJiA2NzEwODg2MywgeCA9IEUgLyA2NzEwODg2NCB8IDA7XG4gICAgICBsLndvcmRzWzBdID0gUztcbiAgICAgIGZvciAodmFyIHUgPSAxOyB1IDwgYTsgdSsrKSB7XG4gICAgICAgIGZvciAodmFyIG0gPSB4ID4+PiAyNiwgZyA9IHggJiA2NzEwODg2MywgUCA9IE1hdGgubWluKHUsIHAubGVuZ3RoIC0gMSksIEcgPSBNYXRoLm1heCgwLCB1IC0gTy5sZW5ndGggKyAxKTsgRyA8PSBQOyBHKyspIHtcbiAgICAgICAgICB2YXIgTSA9IHUgLSBHIHwgMDtcbiAgICAgICAgICBjID0gTy53b3Jkc1tNXSB8IDAsIGIgPSBwLndvcmRzW0ddIHwgMCwgRSA9IGMgKiBiICsgZywgbSArPSBFIC8gNjcxMDg4NjQgfCAwLCBnID0gRSAmIDY3MTA4ODYzO1xuICAgICAgICB9XG4gICAgICAgIGwud29yZHNbdV0gPSBnIHwgMCwgeCA9IG0gfCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHggIT09IDAgPyBsLndvcmRzW3VdID0geCB8IDAgOiBsLmxlbmd0aC0tLCBsLnN0cmlwKCk7XG4gICAgfVxuICAgIHZhciBOID0gZnVuY3Rpb24ocCwgbCwgYSkge1xuICAgICAgdmFyIGMgPSBwLndvcmRzLCBiID0gbC53b3JkcywgRSA9IGEud29yZHMsIFMgPSAwLCB4LCB1LCBtLCBnID0gY1swXSB8IDAsIFAgPSBnICYgODE5MSwgRyA9IGcgPj4+IDEzLCBNID0gY1sxXSB8IDAsIEggPSBNICYgODE5MSwgQyA9IE0gPj4+IDEzLCBxID0gY1syXSB8IDAsIEwgPSBxICYgODE5MSwgeSA9IHEgPj4+IDEzLCBGID0gY1szXSB8IDAsIFcgPSBGICYgODE5MSwgWSA9IEYgPj4+IDEzLCBYID0gY1s0XSB8IDAsIGVlID0gWCAmIDgxOTEsIHdlID0gWCA+Pj4gMTMsIE1lID0gY1s1XSB8IDAsIGhlID0gTWUgJiA4MTkxLCBSZSA9IE1lID4+PiAxMywgeGUgPSBjWzZdIHwgMCwgc2UgPSB4ZSAmIDgxOTEsIGdlID0geGUgPj4+IDEzLCBsZSA9IGNbN10gfCAwLCBuZSA9IGxlICYgODE5MSwgdWUgPSBsZSA+Pj4gMTMsIGZlID0gY1s4XSB8IDAsIHRlID0gZmUgJiA4MTkxLCBwZSA9IGZlID4+PiAxMywgX2UgPSBjWzldIHwgMCwgcmUgPSBfZSAmIDgxOTEsIEVlID0gX2UgPj4+IDEzLCBTZSA9IGJbMF0gfCAwLCBvZSA9IFNlICYgODE5MSwgRGUgPSBTZSA+Pj4gMTMsIEllID0gYlsxXSB8IDAsIFBlID0gSWUgJiA4MTkxLCBHZSA9IEllID4+PiAxMywgWWUgPSBiWzJdIHwgMCwgQWUgPSBZZSAmIDgxOTEsIFplID0gWWUgPj4+IDEzLCBldCA9IGJbM10gfCAwLCBOZSA9IGV0ICYgODE5MSwgQ2UgPSBldCA+Pj4gMTMsIFRlID0gYls0XSB8IDAsIGRlID0gVGUgJiA4MTkxLCAkZSA9IFRlID4+PiAxMywgTGUgPSBiWzVdIHwgMCwgY2UgPSBMZSAmIDgxOTEsIFVlID0gTGUgPj4+IDEzLCB6ZSA9IGJbNl0gfCAwLCB5ZSA9IHplICYgODE5MSwgQmUgPSB6ZSA+Pj4gMTMsIGtlID0gYls3XSB8IDAsIHZlID0ga2UgJiA4MTkxLCBGZSA9IGtlID4+PiAxMywgT2UgPSBiWzhdIHwgMCwgbWUgPSBPZSAmIDgxOTEsIGplID0gT2UgPj4+IDEzLCBydCA9IGJbOV0gfCAwLCBxZSA9IHJ0ICYgODE5MSwgaXQgPSBydCA+Pj4gMTM7XG4gICAgICBhLm5lZ2F0aXZlID0gcC5uZWdhdGl2ZSBeIGwubmVnYXRpdmUsIGEubGVuZ3RoID0gMTksIHggPSBNYXRoLmltdWwoUCwgb2UpLCB1ID0gTWF0aC5pbXVsKFAsIERlKSwgdSA9IHUgKyBNYXRoLmltdWwoRywgb2UpIHwgMCwgbSA9IE1hdGguaW11bChHLCBEZSk7XG4gICAgICB2YXIgSmUgPSAoUyArIHggfCAwKSArICgodSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICBTID0gKG0gKyAodSA+Pj4gMTMpIHwgMCkgKyAoSmUgPj4+IDI2KSB8IDAsIEplICY9IDY3MTA4ODYzLCB4ID0gTWF0aC5pbXVsKEgsIG9lKSwgdSA9IE1hdGguaW11bChILCBEZSksIHUgPSB1ICsgTWF0aC5pbXVsKEMsIG9lKSB8IDAsIG0gPSBNYXRoLmltdWwoQywgRGUpLCB4ID0geCArIE1hdGguaW11bChQLCBQZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChQLCBHZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChHLCBQZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChHLCBHZSkgfCAwO1xuICAgICAgdmFyIHR0ID0gKFMgKyB4IHwgMCkgKyAoKHUgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgUyA9IChtICsgKHUgPj4+IDEzKSB8IDApICsgKHR0ID4+PiAyNikgfCAwLCB0dCAmPSA2NzEwODg2MywgeCA9IE1hdGguaW11bChMLCBvZSksIHUgPSBNYXRoLmltdWwoTCwgRGUpLCB1ID0gdSArIE1hdGguaW11bCh5LCBvZSkgfCAwLCBtID0gTWF0aC5pbXVsKHksIERlKSwgeCA9IHggKyBNYXRoLmltdWwoSCwgUGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoSCwgR2UpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoQywgUGUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQywgR2UpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoUCwgQWUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoUCwgWmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoRywgQWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoRywgWmUpIHwgMDtcbiAgICAgIHZhciBqdCA9IChTICsgeCB8IDApICsgKCh1ICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgIFMgPSAobSArICh1ID4+PiAxMykgfCAwKSArIChqdCA+Pj4gMjYpIHwgMCwganQgJj0gNjcxMDg4NjMsIHggPSBNYXRoLmltdWwoVywgb2UpLCB1ID0gTWF0aC5pbXVsKFcsIERlKSwgdSA9IHUgKyBNYXRoLmltdWwoWSwgb2UpIHwgMCwgbSA9IE1hdGguaW11bChZLCBEZSksIHggPSB4ICsgTWF0aC5pbXVsKEwsIFBlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKEwsIEdlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHksIFBlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHksIEdlKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKEgsIEFlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKEgsIFplKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKEMsIEFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEMsIFplKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKFAsIE5lKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKFAsIENlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKEcsIE5lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEcsIENlKSB8IDA7XG4gICAgICB2YXIgS3QgPSAoUyArIHggfCAwKSArICgodSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICBTID0gKG0gKyAodSA+Pj4gMTMpIHwgMCkgKyAoS3QgPj4+IDI2KSB8IDAsIEt0ICY9IDY3MTA4ODYzLCB4ID0gTWF0aC5pbXVsKGVlLCBvZSksIHUgPSBNYXRoLmltdWwoZWUsIERlKSwgdSA9IHUgKyBNYXRoLmltdWwod2UsIG9lKSB8IDAsIG0gPSBNYXRoLmltdWwod2UsIERlKSwgeCA9IHggKyBNYXRoLmltdWwoVywgUGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoVywgR2UpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoWSwgUGUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoWSwgR2UpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoTCwgQWUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoTCwgWmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoeSwgQWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeSwgWmUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoSCwgTmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoSCwgQ2UpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoQywgTmUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQywgQ2UpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoUCwgZGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoUCwgJGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoRywgZGUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoRywgJGUpIHwgMDtcbiAgICAgIHZhciBIdCA9IChTICsgeCB8IDApICsgKCh1ICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgIFMgPSAobSArICh1ID4+PiAxMykgfCAwKSArIChIdCA+Pj4gMjYpIHwgMCwgSHQgJj0gNjcxMDg4NjMsIHggPSBNYXRoLmltdWwoaGUsIG9lKSwgdSA9IE1hdGguaW11bChoZSwgRGUpLCB1ID0gdSArIE1hdGguaW11bChSZSwgb2UpIHwgMCwgbSA9IE1hdGguaW11bChSZSwgRGUpLCB4ID0geCArIE1hdGguaW11bChlZSwgUGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoZWUsIEdlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHdlLCBQZSkgfCAwLCBtID0gbSArIE1hdGguaW11bCh3ZSwgR2UpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoVywgQWUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoVywgWmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoWSwgQWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoWSwgWmUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoTCwgTmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoTCwgQ2UpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoeSwgTmUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeSwgQ2UpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoSCwgZGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoSCwgJGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoQywgZGUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQywgJGUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoUCwgY2UpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoUCwgVWUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoRywgY2UpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoRywgVWUpIHwgMDtcbiAgICAgIHZhciBWdCA9IChTICsgeCB8IDApICsgKCh1ICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgIFMgPSAobSArICh1ID4+PiAxMykgfCAwKSArIChWdCA+Pj4gMjYpIHwgMCwgVnQgJj0gNjcxMDg4NjMsIHggPSBNYXRoLmltdWwoc2UsIG9lKSwgdSA9IE1hdGguaW11bChzZSwgRGUpLCB1ID0gdSArIE1hdGguaW11bChnZSwgb2UpIHwgMCwgbSA9IE1hdGguaW11bChnZSwgRGUpLCB4ID0geCArIE1hdGguaW11bChoZSwgUGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoaGUsIEdlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKFJlLCBQZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChSZSwgR2UpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoZWUsIEFlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKGVlLCBaZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bCh3ZSwgQWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwod2UsIFplKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKFcsIE5lKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKFcsIENlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKFksIE5lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFksIENlKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKEwsIGRlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKEwsICRlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHksIGRlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHksICRlKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKEgsIGNlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKEgsIFVlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKEMsIGNlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEMsIFVlKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKFAsIHllKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKFAsIEJlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKEcsIHllKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEcsIEJlKSB8IDA7XG4gICAgICB2YXIgZ3QgPSAoUyArIHggfCAwKSArICgodSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICBTID0gKG0gKyAodSA+Pj4gMTMpIHwgMCkgKyAoZ3QgPj4+IDI2KSB8IDAsIGd0ICY9IDY3MTA4ODYzLCB4ID0gTWF0aC5pbXVsKG5lLCBvZSksIHUgPSBNYXRoLmltdWwobmUsIERlKSwgdSA9IHUgKyBNYXRoLmltdWwodWUsIG9lKSB8IDAsIG0gPSBNYXRoLmltdWwodWUsIERlKSwgeCA9IHggKyBNYXRoLmltdWwoc2UsIFBlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHNlLCBHZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChnZSwgUGUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoZ2UsIEdlKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKGhlLCBBZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChoZSwgWmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoUmUsIEFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFJlLCBaZSkgfCAwLCB4ID0geCArIE1hdGguaW11bChlZSwgTmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoZWUsIENlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHdlLCBOZSkgfCAwLCBtID0gbSArIE1hdGguaW11bCh3ZSwgQ2UpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoVywgZGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoVywgJGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoWSwgZGUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoWSwgJGUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoTCwgY2UpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoTCwgVWUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoeSwgY2UpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeSwgVWUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoSCwgeWUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoSCwgQmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoQywgeWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQywgQmUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoUCwgdmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoUCwgRmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoRywgdmUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoRywgRmUpIHwgMDtcbiAgICAgIHZhciBWciA9IChTICsgeCB8IDApICsgKCh1ICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgIFMgPSAobSArICh1ID4+PiAxMykgfCAwKSArIChWciA+Pj4gMjYpIHwgMCwgVnIgJj0gNjcxMDg4NjMsIHggPSBNYXRoLmltdWwodGUsIG9lKSwgdSA9IE1hdGguaW11bCh0ZSwgRGUpLCB1ID0gdSArIE1hdGguaW11bChwZSwgb2UpIHwgMCwgbSA9IE1hdGguaW11bChwZSwgRGUpLCB4ID0geCArIE1hdGguaW11bChuZSwgUGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwobmUsIEdlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHVlLCBQZSkgfCAwLCBtID0gbSArIE1hdGguaW11bCh1ZSwgR2UpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoc2UsIEFlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHNlLCBaZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChnZSwgQWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoZ2UsIFplKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKGhlLCBOZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChoZSwgQ2UpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoUmUsIE5lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFJlLCBDZSkgfCAwLCB4ID0geCArIE1hdGguaW11bChlZSwgZGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoZWUsICRlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHdlLCBkZSkgfCAwLCBtID0gbSArIE1hdGguaW11bCh3ZSwgJGUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoVywgY2UpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoVywgVWUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoWSwgY2UpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoWSwgVWUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoTCwgeWUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoTCwgQmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoeSwgeWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeSwgQmUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoSCwgdmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoSCwgRmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoQywgdmUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQywgRmUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoUCwgbWUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoUCwgamUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoRywgbWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoRywgamUpIHwgMDtcbiAgICAgIHZhciBXciA9IChTICsgeCB8IDApICsgKCh1ICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgIFMgPSAobSArICh1ID4+PiAxMykgfCAwKSArIChXciA+Pj4gMjYpIHwgMCwgV3IgJj0gNjcxMDg4NjMsIHggPSBNYXRoLmltdWwocmUsIG9lKSwgdSA9IE1hdGguaW11bChyZSwgRGUpLCB1ID0gdSArIE1hdGguaW11bChFZSwgb2UpIHwgMCwgbSA9IE1hdGguaW11bChFZSwgRGUpLCB4ID0geCArIE1hdGguaW11bCh0ZSwgUGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwodGUsIEdlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHBlLCBQZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChwZSwgR2UpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwobmUsIEFlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKG5lLCBaZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bCh1ZSwgQWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwodWUsIFplKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKHNlLCBOZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChzZSwgQ2UpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoZ2UsIE5lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGdlLCBDZSkgfCAwLCB4ID0geCArIE1hdGguaW11bChoZSwgZGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoaGUsICRlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKFJlLCBkZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChSZSwgJGUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoZWUsIGNlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKGVlLCBVZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bCh3ZSwgY2UpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwod2UsIFVlKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKFcsIHllKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKFcsIEJlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKFksIHllKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFksIEJlKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKEwsIHZlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKEwsIEZlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHksIHZlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHksIEZlKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKEgsIG1lKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKEgsIGplKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKEMsIG1lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEMsIGplKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKFAsIHFlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKFAsIGl0KSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKEcsIHFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEcsIGl0KSB8IDA7XG4gICAgICB2YXIgR3IgPSAoUyArIHggfCAwKSArICgodSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICBTID0gKG0gKyAodSA+Pj4gMTMpIHwgMCkgKyAoR3IgPj4+IDI2KSB8IDAsIEdyICY9IDY3MTA4ODYzLCB4ID0gTWF0aC5pbXVsKHJlLCBQZSksIHUgPSBNYXRoLmltdWwocmUsIEdlKSwgdSA9IHUgKyBNYXRoLmltdWwoRWUsIFBlKSB8IDAsIG0gPSBNYXRoLmltdWwoRWUsIEdlKSwgeCA9IHggKyBNYXRoLmltdWwodGUsIEFlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHRlLCBaZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChwZSwgQWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwocGUsIFplKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKG5lLCBOZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChuZSwgQ2UpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwodWUsIE5lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHVlLCBDZSkgfCAwLCB4ID0geCArIE1hdGguaW11bChzZSwgZGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoc2UsICRlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKGdlLCBkZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChnZSwgJGUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoaGUsIGNlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKGhlLCBVZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChSZSwgY2UpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoUmUsIFVlKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKGVlLCB5ZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChlZSwgQmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwod2UsIHllKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHdlLCBCZSkgfCAwLCB4ID0geCArIE1hdGguaW11bChXLCB2ZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChXLCBGZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChZLCB2ZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChZLCBGZSkgfCAwLCB4ID0geCArIE1hdGguaW11bChMLCBtZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChMLCBqZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bCh5LCBtZSkgfCAwLCBtID0gbSArIE1hdGguaW11bCh5LCBqZSkgfCAwLCB4ID0geCArIE1hdGguaW11bChILCBxZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChILCBpdCkgfCAwLCB1ID0gdSArIE1hdGguaW11bChDLCBxZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChDLCBpdCkgfCAwO1xuICAgICAgdmFyIEpyID0gKFMgKyB4IHwgMCkgKyAoKHUgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgUyA9IChtICsgKHUgPj4+IDEzKSB8IDApICsgKEpyID4+PiAyNikgfCAwLCBKciAmPSA2NzEwODg2MywgeCA9IE1hdGguaW11bChyZSwgQWUpLCB1ID0gTWF0aC5pbXVsKHJlLCBaZSksIHUgPSB1ICsgTWF0aC5pbXVsKEVlLCBBZSkgfCAwLCBtID0gTWF0aC5pbXVsKEVlLCBaZSksIHggPSB4ICsgTWF0aC5pbXVsKHRlLCBOZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bCh0ZSwgQ2UpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwocGUsIE5lKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHBlLCBDZSkgfCAwLCB4ID0geCArIE1hdGguaW11bChuZSwgZGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwobmUsICRlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHVlLCBkZSkgfCAwLCBtID0gbSArIE1hdGguaW11bCh1ZSwgJGUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoc2UsIGNlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHNlLCBVZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChnZSwgY2UpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoZ2UsIFVlKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKGhlLCB5ZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChoZSwgQmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoUmUsIHllKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFJlLCBCZSkgfCAwLCB4ID0geCArIE1hdGguaW11bChlZSwgdmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoZWUsIEZlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHdlLCB2ZSkgfCAwLCBtID0gbSArIE1hdGguaW11bCh3ZSwgRmUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoVywgbWUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoVywgamUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoWSwgbWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoWSwgamUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoTCwgcWUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoTCwgaXQpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoeSwgcWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeSwgaXQpIHwgMDtcbiAgICAgIHZhciBZciA9IChTICsgeCB8IDApICsgKCh1ICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgIFMgPSAobSArICh1ID4+PiAxMykgfCAwKSArIChZciA+Pj4gMjYpIHwgMCwgWXIgJj0gNjcxMDg4NjMsIHggPSBNYXRoLmltdWwocmUsIE5lKSwgdSA9IE1hdGguaW11bChyZSwgQ2UpLCB1ID0gdSArIE1hdGguaW11bChFZSwgTmUpIHwgMCwgbSA9IE1hdGguaW11bChFZSwgQ2UpLCB4ID0geCArIE1hdGguaW11bCh0ZSwgZGUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwodGUsICRlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHBlLCBkZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChwZSwgJGUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwobmUsIGNlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKG5lLCBVZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bCh1ZSwgY2UpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwodWUsIFVlKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKHNlLCB5ZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChzZSwgQmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoZ2UsIHllKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGdlLCBCZSkgfCAwLCB4ID0geCArIE1hdGguaW11bChoZSwgdmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoaGUsIEZlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKFJlLCB2ZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChSZSwgRmUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoZWUsIG1lKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKGVlLCBqZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bCh3ZSwgbWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwod2UsIGplKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKFcsIHFlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKFcsIGl0KSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKFksIHFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFksIGl0KSB8IDA7XG4gICAgICB2YXIgb3IgPSAoUyArIHggfCAwKSArICgodSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICBTID0gKG0gKyAodSA+Pj4gMTMpIHwgMCkgKyAob3IgPj4+IDI2KSB8IDAsIG9yICY9IDY3MTA4ODYzLCB4ID0gTWF0aC5pbXVsKHJlLCBkZSksIHUgPSBNYXRoLmltdWwocmUsICRlKSwgdSA9IHUgKyBNYXRoLmltdWwoRWUsIGRlKSB8IDAsIG0gPSBNYXRoLmltdWwoRWUsICRlKSwgeCA9IHggKyBNYXRoLmltdWwodGUsIGNlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHRlLCBVZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChwZSwgY2UpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwocGUsIFVlKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKG5lLCB5ZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChuZSwgQmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwodWUsIHllKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHVlLCBCZSkgfCAwLCB4ID0geCArIE1hdGguaW11bChzZSwgdmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoc2UsIEZlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKGdlLCB2ZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChnZSwgRmUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoaGUsIG1lKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKGhlLCBqZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChSZSwgbWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoUmUsIGplKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKGVlLCBxZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChlZSwgaXQpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwod2UsIHFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHdlLCBpdCkgfCAwO1xuICAgICAgdmFyIFhyID0gKFMgKyB4IHwgMCkgKyAoKHUgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgUyA9IChtICsgKHUgPj4+IDEzKSB8IDApICsgKFhyID4+PiAyNikgfCAwLCBYciAmPSA2NzEwODg2MywgeCA9IE1hdGguaW11bChyZSwgY2UpLCB1ID0gTWF0aC5pbXVsKHJlLCBVZSksIHUgPSB1ICsgTWF0aC5pbXVsKEVlLCBjZSkgfCAwLCBtID0gTWF0aC5pbXVsKEVlLCBVZSksIHggPSB4ICsgTWF0aC5pbXVsKHRlLCB5ZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bCh0ZSwgQmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwocGUsIHllKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHBlLCBCZSkgfCAwLCB4ID0geCArIE1hdGguaW11bChuZSwgdmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwobmUsIEZlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHVlLCB2ZSkgfCAwLCBtID0gbSArIE1hdGguaW11bCh1ZSwgRmUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoc2UsIG1lKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHNlLCBqZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChnZSwgbWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoZ2UsIGplKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKGhlLCBxZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChoZSwgaXQpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwoUmUsIHFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFJlLCBpdCkgfCAwO1xuICAgICAgdmFyIFpyID0gKFMgKyB4IHwgMCkgKyAoKHUgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgUyA9IChtICsgKHUgPj4+IDEzKSB8IDApICsgKFpyID4+PiAyNikgfCAwLCBaciAmPSA2NzEwODg2MywgeCA9IE1hdGguaW11bChyZSwgeWUpLCB1ID0gTWF0aC5pbXVsKHJlLCBCZSksIHUgPSB1ICsgTWF0aC5pbXVsKEVlLCB5ZSkgfCAwLCBtID0gTWF0aC5pbXVsKEVlLCBCZSksIHggPSB4ICsgTWF0aC5pbXVsKHRlLCB2ZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bCh0ZSwgRmUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwocGUsIHZlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHBlLCBGZSkgfCAwLCB4ID0geCArIE1hdGguaW11bChuZSwgbWUpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwobmUsIGplKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHVlLCBtZSkgfCAwLCBtID0gbSArIE1hdGguaW11bCh1ZSwgamUpIHwgMCwgeCA9IHggKyBNYXRoLmltdWwoc2UsIHFlKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHNlLCBpdCkgfCAwLCB1ID0gdSArIE1hdGguaW11bChnZSwgcWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoZ2UsIGl0KSB8IDA7XG4gICAgICB2YXIgJHQgPSAoUyArIHggfCAwKSArICgodSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICBTID0gKG0gKyAodSA+Pj4gMTMpIHwgMCkgKyAoJHQgPj4+IDI2KSB8IDAsICR0ICY9IDY3MTA4ODYzLCB4ID0gTWF0aC5pbXVsKHJlLCB2ZSksIHUgPSBNYXRoLmltdWwocmUsIEZlKSwgdSA9IHUgKyBNYXRoLmltdWwoRWUsIHZlKSB8IDAsIG0gPSBNYXRoLmltdWwoRWUsIEZlKSwgeCA9IHggKyBNYXRoLmltdWwodGUsIG1lKSB8IDAsIHUgPSB1ICsgTWF0aC5pbXVsKHRlLCBqZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChwZSwgbWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwocGUsIGplKSB8IDAsIHggPSB4ICsgTWF0aC5pbXVsKG5lLCBxZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bChuZSwgaXQpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwodWUsIHFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHVlLCBpdCkgfCAwO1xuICAgICAgdmFyIFFyID0gKFMgKyB4IHwgMCkgKyAoKHUgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgUyA9IChtICsgKHUgPj4+IDEzKSB8IDApICsgKFFyID4+PiAyNikgfCAwLCBRciAmPSA2NzEwODg2MywgeCA9IE1hdGguaW11bChyZSwgbWUpLCB1ID0gTWF0aC5pbXVsKHJlLCBqZSksIHUgPSB1ICsgTWF0aC5pbXVsKEVlLCBtZSkgfCAwLCBtID0gTWF0aC5pbXVsKEVlLCBqZSksIHggPSB4ICsgTWF0aC5pbXVsKHRlLCBxZSkgfCAwLCB1ID0gdSArIE1hdGguaW11bCh0ZSwgaXQpIHwgMCwgdSA9IHUgKyBNYXRoLmltdWwocGUsIHFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHBlLCBpdCkgfCAwO1xuICAgICAgdmFyIGVpID0gKFMgKyB4IHwgMCkgKyAoKHUgJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgUyA9IChtICsgKHUgPj4+IDEzKSB8IDApICsgKGVpID4+PiAyNikgfCAwLCBlaSAmPSA2NzEwODg2MywgeCA9IE1hdGguaW11bChyZSwgcWUpLCB1ID0gTWF0aC5pbXVsKHJlLCBpdCksIHUgPSB1ICsgTWF0aC5pbXVsKEVlLCBxZSkgfCAwLCBtID0gTWF0aC5pbXVsKEVlLCBpdCk7XG4gICAgICB2YXIgdGkgPSAoUyArIHggfCAwKSArICgodSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICByZXR1cm4gUyA9IChtICsgKHUgPj4+IDEzKSB8IDApICsgKHRpID4+PiAyNikgfCAwLCB0aSAmPSA2NzEwODg2MywgRVswXSA9IEplLCBFWzFdID0gdHQsIEVbMl0gPSBqdCwgRVszXSA9IEt0LCBFWzRdID0gSHQsIEVbNV0gPSBWdCwgRVs2XSA9IGd0LCBFWzddID0gVnIsIEVbOF0gPSBXciwgRVs5XSA9IEdyLCBFWzEwXSA9IEpyLCBFWzExXSA9IFlyLCBFWzEyXSA9IG9yLCBFWzEzXSA9IFhyLCBFWzE0XSA9IFpyLCBFWzE1XSA9ICR0LCBFWzE2XSA9IFFyLCBFWzE3XSA9IGVpLCBFWzE4XSA9IHRpLCBTICE9PSAwICYmIChFWzE5XSA9IFMsIGEubGVuZ3RoKyspLCBhO1xuICAgIH07XG4gICAgTWF0aC5pbXVsIHx8IChOID0gRCk7XG4gICAgZnVuY3Rpb24gayhPLCBwLCBsKSB7XG4gICAgICBsLm5lZ2F0aXZlID0gcC5uZWdhdGl2ZSBeIE8ubmVnYXRpdmUsIGwubGVuZ3RoID0gTy5sZW5ndGggKyBwLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGEgPSAwLCBjID0gMCwgYiA9IDA7IGIgPCBsLmxlbmd0aCAtIDE7IGIrKykge1xuICAgICAgICB2YXIgRSA9IGM7XG4gICAgICAgIGMgPSAwO1xuICAgICAgICBmb3IgKHZhciBTID0gYSAmIDY3MTA4ODYzLCB4ID0gTWF0aC5taW4oYiwgcC5sZW5ndGggLSAxKSwgdSA9IE1hdGgubWF4KDAsIGIgLSBPLmxlbmd0aCArIDEpOyB1IDw9IHg7IHUrKykge1xuICAgICAgICAgIHZhciBtID0gYiAtIHUsIGcgPSBPLndvcmRzW21dIHwgMCwgUCA9IHAud29yZHNbdV0gfCAwLCBHID0gZyAqIFAsIE0gPSBHICYgNjcxMDg4NjM7XG4gICAgICAgICAgRSA9IEUgKyAoRyAvIDY3MTA4ODY0IHwgMCkgfCAwLCBNID0gTSArIFMgfCAwLCBTID0gTSAmIDY3MTA4ODYzLCBFID0gRSArIChNID4+PiAyNikgfCAwLCBjICs9IEUgPj4+IDI2LCBFICY9IDY3MTA4ODYzO1xuICAgICAgICB9XG4gICAgICAgIGwud29yZHNbYl0gPSBTLCBhID0gRSwgRSA9IGM7XG4gICAgICB9XG4gICAgICByZXR1cm4gYSAhPT0gMCA/IGwud29yZHNbYl0gPSBhIDogbC5sZW5ndGgtLSwgbC5zdHJpcCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqKE8sIHAsIGwpIHtcbiAgICAgIHZhciBhID0gbmV3IFQoKTtcbiAgICAgIHJldHVybiBhLm11bHAoTywgcCwgbCk7XG4gICAgfVxuICAgIHMucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24ocCwgbCkge1xuICAgICAgdmFyIGEsIGMgPSB0aGlzLmxlbmd0aCArIHAubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxMCAmJiBwLmxlbmd0aCA9PT0gMTAgPyBhID0gTih0aGlzLCBwLCBsKSA6IGMgPCA2MyA/IGEgPSBEKHRoaXMsIHAsIGwpIDogYyA8IDEwMjQgPyBhID0gayh0aGlzLCBwLCBsKSA6IGEgPSBqKHRoaXMsIHAsIGwpLCBhO1xuICAgIH07XG4gICAgZnVuY3Rpb24gVChPLCBwKSB7XG4gICAgICB0aGlzLnggPSBPLCB0aGlzLnkgPSBwO1xuICAgIH1cbiAgICBULnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24ocCkge1xuICAgICAgZm9yICh2YXIgbCA9IG5ldyBBcnJheShwKSwgYSA9IHMucHJvdG90eXBlLl9jb3VudEJpdHMocCkgLSAxLCBjID0gMDsgYyA8IHA7IGMrKylcbiAgICAgICAgbFtjXSA9IHRoaXMucmV2QmluKGMsIGEsIHApO1xuICAgICAgcmV0dXJuIGw7XG4gICAgfSwgVC5wcm90b3R5cGUucmV2QmluID0gZnVuY3Rpb24ocCwgbCwgYSkge1xuICAgICAgaWYgKHAgPT09IDAgfHwgcCA9PT0gYSAtIDEpXG4gICAgICAgIHJldHVybiBwO1xuICAgICAgZm9yICh2YXIgYyA9IDAsIGIgPSAwOyBiIDwgbDsgYisrKVxuICAgICAgICBjIHw9IChwICYgMSkgPDwgbCAtIGIgLSAxLCBwID4+PSAxO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfSwgVC5wcm90b3R5cGUucGVybXV0ZSA9IGZ1bmN0aW9uKHAsIGwsIGEsIGMsIGIsIEUpIHtcbiAgICAgIGZvciAodmFyIFMgPSAwOyBTIDwgRTsgUysrKVxuICAgICAgICBjW1NdID0gbFtwW1NdXSwgYltTXSA9IGFbcFtTXV07XG4gICAgfSwgVC5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24ocCwgbCwgYSwgYywgYiwgRSkge1xuICAgICAgdGhpcy5wZXJtdXRlKEUsIHAsIGwsIGEsIGMsIGIpO1xuICAgICAgZm9yICh2YXIgUyA9IDE7IFMgPCBiOyBTIDw8PSAxKVxuICAgICAgICBmb3IgKHZhciB4ID0gUyA8PCAxLCB1ID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyB4KSwgbSA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8geCksIGcgPSAwOyBnIDwgYjsgZyArPSB4KVxuICAgICAgICAgIGZvciAodmFyIFAgPSB1LCBHID0gbSwgTSA9IDA7IE0gPCBTOyBNKyspIHtcbiAgICAgICAgICAgIHZhciBIID0gYVtnICsgTV0sIEMgPSBjW2cgKyBNXSwgcSA9IGFbZyArIE0gKyBTXSwgTCA9IGNbZyArIE0gKyBTXSwgeSA9IFAgKiBxIC0gRyAqIEw7XG4gICAgICAgICAgICBMID0gUCAqIEwgKyBHICogcSwgcSA9IHksIGFbZyArIE1dID0gSCArIHEsIGNbZyArIE1dID0gQyArIEwsIGFbZyArIE0gKyBTXSA9IEggLSBxLCBjW2cgKyBNICsgU10gPSBDIC0gTCwgTSAhPT0geCAmJiAoeSA9IHUgKiBQIC0gbSAqIEcsIEcgPSB1ICogRyArIG0gKiBQLCBQID0geSk7XG4gICAgICAgICAgfVxuICAgIH0sIFQucHJvdG90eXBlLmd1ZXNzTGVuMTNiID0gZnVuY3Rpb24ocCwgbCkge1xuICAgICAgdmFyIGEgPSBNYXRoLm1heChsLCBwKSB8IDEsIGMgPSBhICYgMSwgYiA9IDA7XG4gICAgICBmb3IgKGEgPSBhIC8gMiB8IDA7IGE7IGEgPSBhID4+PiAxKVxuICAgICAgICBiKys7XG4gICAgICByZXR1cm4gMSA8PCBiICsgMSArIGM7XG4gICAgfSwgVC5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24ocCwgbCwgYSkge1xuICAgICAgaWYgKCEoYSA8PSAxKSlcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBhIC8gMjsgYysrKSB7XG4gICAgICAgICAgdmFyIGIgPSBwW2NdO1xuICAgICAgICAgIHBbY10gPSBwW2EgLSBjIC0gMV0sIHBbYSAtIGMgLSAxXSA9IGIsIGIgPSBsW2NdLCBsW2NdID0gLWxbYSAtIGMgLSAxXSwgbFthIC0gYyAtIDFdID0gLWI7XG4gICAgICAgIH1cbiAgICB9LCBULnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbihwLCBsKSB7XG4gICAgICBmb3IgKHZhciBhID0gMCwgYyA9IDA7IGMgPCBsIC8gMjsgYysrKSB7XG4gICAgICAgIHZhciBiID0gTWF0aC5yb3VuZChwWzIgKiBjICsgMV0gLyBsKSAqIDgxOTIgKyBNYXRoLnJvdW5kKHBbMiAqIGNdIC8gbCkgKyBhO1xuICAgICAgICBwW2NdID0gYiAmIDY3MTA4ODYzLCBiIDwgNjcxMDg4NjQgPyBhID0gMCA6IGEgPSBiIC8gNjcxMDg4NjQgfCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfSwgVC5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uKHAsIGwsIGEsIGMpIHtcbiAgICAgIGZvciAodmFyIGIgPSAwLCBFID0gMDsgRSA8IGw7IEUrKylcbiAgICAgICAgYiA9IGIgKyAocFtFXSB8IDApLCBhWzIgKiBFXSA9IGIgJiA4MTkxLCBiID0gYiA+Pj4gMTMsIGFbMiAqIEUgKyAxXSA9IGIgJiA4MTkxLCBiID0gYiA+Pj4gMTM7XG4gICAgICBmb3IgKEUgPSAyICogbDsgRSA8IGM7ICsrRSlcbiAgICAgICAgYVtFXSA9IDA7XG4gICAgICBpKGIgPT09IDApLCBpKChiICYgLTgxOTIpID09PSAwKTtcbiAgICB9LCBULnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24ocCkge1xuICAgICAgZm9yICh2YXIgbCA9IG5ldyBBcnJheShwKSwgYSA9IDA7IGEgPCBwOyBhKyspXG4gICAgICAgIGxbYV0gPSAwO1xuICAgICAgcmV0dXJuIGw7XG4gICAgfSwgVC5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uKHAsIGwsIGEpIHtcbiAgICAgIHZhciBjID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IocC5sZW5ndGgsIGwubGVuZ3RoKSwgYiA9IHRoaXMubWFrZVJCVChjKSwgRSA9IHRoaXMuc3R1YihjKSwgUyA9IG5ldyBBcnJheShjKSwgeCA9IG5ldyBBcnJheShjKSwgdSA9IG5ldyBBcnJheShjKSwgbSA9IG5ldyBBcnJheShjKSwgZyA9IG5ldyBBcnJheShjKSwgUCA9IG5ldyBBcnJheShjKSwgRyA9IGEud29yZHM7XG4gICAgICBHLmxlbmd0aCA9IGMsIHRoaXMuY29udmVydDEzYihwLndvcmRzLCBwLmxlbmd0aCwgUywgYyksIHRoaXMuY29udmVydDEzYihsLndvcmRzLCBsLmxlbmd0aCwgbSwgYyksIHRoaXMudHJhbnNmb3JtKFMsIEUsIHgsIHUsIGMsIGIpLCB0aGlzLnRyYW5zZm9ybShtLCBFLCBnLCBQLCBjLCBiKTtcbiAgICAgIGZvciAodmFyIE0gPSAwOyBNIDwgYzsgTSsrKSB7XG4gICAgICAgIHZhciBIID0geFtNXSAqIGdbTV0gLSB1W01dICogUFtNXTtcbiAgICAgICAgdVtNXSA9IHhbTV0gKiBQW01dICsgdVtNXSAqIGdbTV0sIHhbTV0gPSBIO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29uanVnYXRlKHgsIHUsIGMpLCB0aGlzLnRyYW5zZm9ybSh4LCB1LCBHLCBFLCBjLCBiKSwgdGhpcy5jb25qdWdhdGUoRywgRSwgYyksIHRoaXMubm9ybWFsaXplMTNiKEcsIGMpLCBhLm5lZ2F0aXZlID0gcC5uZWdhdGl2ZSBeIGwubmVnYXRpdmUsIGEubGVuZ3RoID0gcC5sZW5ndGggKyBsLmxlbmd0aCwgYS5zdHJpcCgpO1xuICAgIH0sIHMucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBsID0gbmV3IHMobnVsbCk7XG4gICAgICByZXR1cm4gbC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIHAubGVuZ3RoKSwgdGhpcy5tdWxUbyhwLCBsKTtcbiAgICB9LCBzLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGwgPSBuZXcgcyhudWxsKTtcbiAgICAgIHJldHVybiBsLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgcC5sZW5ndGgpLCBqKHRoaXMsIHAsIGwpO1xuICAgIH0sIHMucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKHAsIHRoaXMpO1xuICAgIH0sIHMucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24ocCkge1xuICAgICAgaSh0eXBlb2YgcCA9PSBcIm51bWJlclwiKSwgaShwIDwgNjcxMDg4NjQpO1xuICAgICAgZm9yICh2YXIgbCA9IDAsIGEgPSAwOyBhIDwgdGhpcy5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgYyA9ICh0aGlzLndvcmRzW2FdIHwgMCkgKiBwLCBiID0gKGMgJiA2NzEwODg2MykgKyAobCAmIDY3MTA4ODYzKTtcbiAgICAgICAgbCA+Pj0gMjYsIGwgKz0gYyAvIDY3MTA4ODY0IHwgMCwgbCArPSBiID4+PiAyNiwgdGhpcy53b3Jkc1thXSA9IGIgJiA2NzEwODg2MztcbiAgICAgIH1cbiAgICAgIHJldHVybiBsICE9PSAwICYmICh0aGlzLndvcmRzW2FdID0gbCwgdGhpcy5sZW5ndGgrKyksIHRoaXM7XG4gICAgfSwgcy5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4ocCk7XG4gICAgfSwgcy5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gICAgfSwgcy5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICAgIH0sIHMucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBsID0gSShwKTtcbiAgICAgIGlmIChsLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG5ldyBzKDEpO1xuICAgICAgZm9yICh2YXIgYSA9IHRoaXMsIGMgPSAwOyBjIDwgbC5sZW5ndGggJiYgbFtjXSA9PT0gMDsgYysrLCBhID0gYS5zcXIoKSlcbiAgICAgICAgO1xuICAgICAgaWYgKCsrYyA8IGwubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBiID0gYS5zcXIoKTsgYyA8IGwubGVuZ3RoOyBjKyssIGIgPSBiLnNxcigpKVxuICAgICAgICAgIGxbY10gIT09IDAgJiYgKGEgPSBhLm11bChiKSk7XG4gICAgICByZXR1cm4gYTtcbiAgICB9LCBzLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbihwKSB7XG4gICAgICBpKHR5cGVvZiBwID09IFwibnVtYmVyXCIgJiYgcCA+PSAwKTtcbiAgICAgIHZhciBsID0gcCAlIDI2LCBhID0gKHAgLSBsKSAvIDI2LCBjID0gNjcxMDg4NjMgPj4+IDI2IC0gbCA8PCAyNiAtIGwsIGI7XG4gICAgICBpZiAobCAhPT0gMCkge1xuICAgICAgICB2YXIgRSA9IDA7XG4gICAgICAgIGZvciAoYiA9IDA7IGIgPCB0aGlzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgdmFyIFMgPSB0aGlzLndvcmRzW2JdICYgYywgeCA9ICh0aGlzLndvcmRzW2JdIHwgMCkgLSBTIDw8IGw7XG4gICAgICAgICAgdGhpcy53b3Jkc1tiXSA9IHggfCBFLCBFID0gUyA+Pj4gMjYgLSBsO1xuICAgICAgICB9XG4gICAgICAgIEUgJiYgKHRoaXMud29yZHNbYl0gPSBFLCB0aGlzLmxlbmd0aCsrKTtcbiAgICAgIH1cbiAgICAgIGlmIChhICE9PSAwKSB7XG4gICAgICAgIGZvciAoYiA9IHRoaXMubGVuZ3RoIC0gMTsgYiA+PSAwOyBiLS0pXG4gICAgICAgICAgdGhpcy53b3Jkc1tiICsgYV0gPSB0aGlzLndvcmRzW2JdO1xuICAgICAgICBmb3IgKGIgPSAwOyBiIDwgYTsgYisrKVxuICAgICAgICAgIHRoaXMud29yZHNbYl0gPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSBhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBpKHRoaXMubmVnYXRpdmUgPT09IDApLCB0aGlzLml1c2hsbihwKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbihwLCBsLCBhKSB7XG4gICAgICBpKHR5cGVvZiBwID09IFwibnVtYmVyXCIgJiYgcCA+PSAwKTtcbiAgICAgIHZhciBjO1xuICAgICAgbCA/IGMgPSAobCAtIGwgJSAyNikgLyAyNiA6IGMgPSAwO1xuICAgICAgdmFyIGIgPSBwICUgMjYsIEUgPSBNYXRoLm1pbigocCAtIGIpIC8gMjYsIHRoaXMubGVuZ3RoKSwgUyA9IDY3MTA4ODYzIF4gNjcxMDg4NjMgPj4+IGIgPDwgYiwgeCA9IGE7XG4gICAgICBpZiAoYyAtPSBFLCBjID0gTWF0aC5tYXgoMCwgYyksIHgpIHtcbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBFOyB1KyspXG4gICAgICAgICAgeC53b3Jkc1t1XSA9IHRoaXMud29yZHNbdV07XG4gICAgICAgIHgubGVuZ3RoID0gRTtcbiAgICAgIH1cbiAgICAgIGlmIChFICE9PSAwKVxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiBFKVxuICAgICAgICAgIGZvciAodGhpcy5sZW5ndGggLT0gRSwgdSA9IDA7IHUgPCB0aGlzLmxlbmd0aDsgdSsrKVxuICAgICAgICAgICAgdGhpcy53b3Jkc1t1XSA9IHRoaXMud29yZHNbdSArIEVdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy53b3Jkc1swXSA9IDAsIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHZhciBtID0gMDtcbiAgICAgIGZvciAodSA9IHRoaXMubGVuZ3RoIC0gMTsgdSA+PSAwICYmIChtICE9PSAwIHx8IHUgPj0gYyk7IHUtLSkge1xuICAgICAgICB2YXIgZyA9IHRoaXMud29yZHNbdV0gfCAwO1xuICAgICAgICB0aGlzLndvcmRzW3VdID0gbSA8PCAyNiAtIGIgfCBnID4+PiBiLCBtID0gZyAmIFM7XG4gICAgICB9XG4gICAgICByZXR1cm4geCAmJiBtICE9PSAwICYmICh4LndvcmRzW3gubGVuZ3RoKytdID0gbSksIHRoaXMubGVuZ3RoID09PSAwICYmICh0aGlzLndvcmRzWzBdID0gMCwgdGhpcy5sZW5ndGggPSAxKSwgdGhpcy5zdHJpcCgpO1xuICAgIH0sIHMucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24ocCwgbCwgYSkge1xuICAgICAgcmV0dXJuIGkodGhpcy5uZWdhdGl2ZSA9PT0gMCksIHRoaXMuaXVzaHJuKHAsIGwsIGEpO1xuICAgIH0sIHMucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKHApO1xuICAgIH0sIHMucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4ocCk7XG4gICAgfSwgcy5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4ocCk7XG4gICAgfSwgcy5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihwKTtcbiAgICB9LCBzLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIGkodHlwZW9mIHAgPT0gXCJudW1iZXJcIiAmJiBwID49IDApO1xuICAgICAgdmFyIGwgPSBwICUgMjYsIGEgPSAocCAtIGwpIC8gMjYsIGMgPSAxIDw8IGw7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPD0gYSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgdmFyIGIgPSB0aGlzLndvcmRzW2FdO1xuICAgICAgcmV0dXJuICEhKGIgJiBjKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbihwKSB7XG4gICAgICBpKHR5cGVvZiBwID09IFwibnVtYmVyXCIgJiYgcCA+PSAwKTtcbiAgICAgIHZhciBsID0gcCAlIDI2LCBhID0gKHAgLSBsKSAvIDI2O1xuICAgICAgaWYgKGkodGhpcy5uZWdhdGl2ZSA9PT0gMCwgXCJpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnNcIiksIHRoaXMubGVuZ3RoIDw9IGEpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgaWYgKGwgIT09IDAgJiYgYSsrLCB0aGlzLmxlbmd0aCA9IE1hdGgubWluKGEsIHRoaXMubGVuZ3RoKSwgbCAhPT0gMCkge1xuICAgICAgICB2YXIgYyA9IDY3MTA4ODYzIF4gNjcxMDg4NjMgPj4+IGwgPDwgbDtcbiAgICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IGM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICAgIH0sIHMucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24ocCk7XG4gICAgfSwgcy5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gaSh0eXBlb2YgcCA9PSBcIm51bWJlclwiKSwgaShwIDwgNjcxMDg4NjQpLCBwIDwgMCA/IHRoaXMuaXN1Ym4oLXApIDogdGhpcy5uZWdhdGl2ZSAhPT0gMCA/IHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPCBwID8gKHRoaXMud29yZHNbMF0gPSBwIC0gKHRoaXMud29yZHNbMF0gfCAwKSwgdGhpcy5uZWdhdGl2ZSA9IDAsIHRoaXMpIDogKHRoaXMubmVnYXRpdmUgPSAwLCB0aGlzLmlzdWJuKHApLCB0aGlzLm5lZ2F0aXZlID0gMSwgdGhpcykgOiB0aGlzLl9pYWRkbihwKTtcbiAgICB9LCBzLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbihwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdICs9IHA7XG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbbF0gPj0gNjcxMDg4NjQ7IGwrKylcbiAgICAgICAgdGhpcy53b3Jkc1tsXSAtPSA2NzEwODg2NCwgbCA9PT0gdGhpcy5sZW5ndGggLSAxID8gdGhpcy53b3Jkc1tsICsgMV0gPSAxIDogdGhpcy53b3Jkc1tsICsgMV0rKztcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBsICsgMSksIHRoaXM7XG4gICAgfSwgcy5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbihwKSB7XG4gICAgICBpZiAoaSh0eXBlb2YgcCA9PSBcIm51bWJlclwiKSwgaShwIDwgNjcxMDg4NjQpLCBwIDwgMClcbiAgICAgICAgcmV0dXJuIHRoaXMuaWFkZG4oLXApO1xuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApXG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlID0gMCwgdGhpcy5pYWRkbihwKSwgdGhpcy5uZWdhdGl2ZSA9IDEsIHRoaXM7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSAtPSBwLCB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMClcbiAgICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdLCB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2xdIDwgMDsgbCsrKVxuICAgICAgICAgIHRoaXMud29yZHNbbF0gKz0gNjcxMDg4NjQsIHRoaXMud29yZHNbbCArIDFdIC09IDE7XG4gICAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICAgIH0sIHMucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKHApO1xuICAgIH0sIHMucHJvdG90eXBlLnN1Ym4gPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKHApO1xuICAgIH0sIHMucHJvdG90eXBlLmlhYnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlID0gMCwgdGhpcztcbiAgICB9LCBzLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xuICAgIH0sIHMucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uKHAsIGwsIGEpIHtcbiAgICAgIHZhciBjID0gcC5sZW5ndGggKyBhLCBiO1xuICAgICAgdGhpcy5fZXhwYW5kKGMpO1xuICAgICAgdmFyIEUsIFMgPSAwO1xuICAgICAgZm9yIChiID0gMDsgYiA8IHAubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgRSA9ICh0aGlzLndvcmRzW2IgKyBhXSB8IDApICsgUztcbiAgICAgICAgdmFyIHggPSAocC53b3Jkc1tiXSB8IDApICogbDtcbiAgICAgICAgRSAtPSB4ICYgNjcxMDg4NjMsIFMgPSAoRSA+PiAyNikgLSAoeCAvIDY3MTA4ODY0IHwgMCksIHRoaXMud29yZHNbYiArIGFdID0gRSAmIDY3MTA4ODYzO1xuICAgICAgfVxuICAgICAgZm9yICg7IGIgPCB0aGlzLmxlbmd0aCAtIGE7IGIrKylcbiAgICAgICAgRSA9ICh0aGlzLndvcmRzW2IgKyBhXSB8IDApICsgUywgUyA9IEUgPj4gMjYsIHRoaXMud29yZHNbYiArIGFdID0gRSAmIDY3MTA4ODYzO1xuICAgICAgaWYgKFMgPT09IDApXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gICAgICBmb3IgKGkoUyA9PT0gLTEpLCBTID0gMCwgYiA9IDA7IGIgPCB0aGlzLmxlbmd0aDsgYisrKVxuICAgICAgICBFID0gLSh0aGlzLndvcmRzW2JdIHwgMCkgKyBTLCBTID0gRSA+PiAyNiwgdGhpcy53b3Jkc1tiXSA9IEUgJiA2NzEwODg2MztcbiAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlID0gMSwgdGhpcy5zdHJpcCgpO1xuICAgIH0sIHMucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24ocCwgbCkge1xuICAgICAgdmFyIGEgPSB0aGlzLmxlbmd0aCAtIHAubGVuZ3RoLCBjID0gdGhpcy5jbG9uZSgpLCBiID0gcCwgRSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDAsIFMgPSB0aGlzLl9jb3VudEJpdHMoRSk7XG4gICAgICBhID0gMjYgLSBTLCBhICE9PSAwICYmIChiID0gYi51c2hsbihhKSwgYy5pdXNobG4oYSksIEUgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwKTtcbiAgICAgIHZhciB4ID0gYy5sZW5ndGggLSBiLmxlbmd0aCwgdTtcbiAgICAgIGlmIChsICE9PSBcIm1vZFwiKSB7XG4gICAgICAgIHUgPSBuZXcgcyhudWxsKSwgdS5sZW5ndGggPSB4ICsgMSwgdS53b3JkcyA9IG5ldyBBcnJheSh1Lmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgdS5sZW5ndGg7IG0rKylcbiAgICAgICAgICB1LndvcmRzW21dID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciBnID0gYy5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCB4KTtcbiAgICAgIGcubmVnYXRpdmUgPT09IDAgJiYgKGMgPSBnLCB1ICYmICh1LndvcmRzW3hdID0gMSkpO1xuICAgICAgZm9yICh2YXIgUCA9IHggLSAxOyBQID49IDA7IFAtLSkge1xuICAgICAgICB2YXIgRyA9IChjLndvcmRzW2IubGVuZ3RoICsgUF0gfCAwKSAqIDY3MTA4ODY0ICsgKGMud29yZHNbYi5sZW5ndGggKyBQIC0gMV0gfCAwKTtcbiAgICAgICAgZm9yIChHID0gTWF0aC5taW4oRyAvIEUgfCAwLCA2NzEwODg2MyksIGMuX2lzaGxuc3VibXVsKGIsIEcsIFApOyBjLm5lZ2F0aXZlICE9PSAwOyApXG4gICAgICAgICAgRy0tLCBjLm5lZ2F0aXZlID0gMCwgYy5faXNobG5zdWJtdWwoYiwgMSwgUCksIGMuaXNaZXJvKCkgfHwgKGMubmVnYXRpdmUgXj0gMSk7XG4gICAgICAgIHUgJiYgKHUud29yZHNbUF0gPSBHKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1ICYmIHUuc3RyaXAoKSwgYy5zdHJpcCgpLCBsICE9PSBcImRpdlwiICYmIGEgIT09IDAgJiYgYy5pdXNocm4oYSksIHtcbiAgICAgICAgZGl2OiB1IHx8IG51bGwsXG4gICAgICAgIG1vZDogY1xuICAgICAgfTtcbiAgICB9LCBzLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbihwLCBsLCBhKSB7XG4gICAgICBpZiAoaSghcC5pc1plcm8oKSksIHRoaXMuaXNaZXJvKCkpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBuZXcgcygwKSxcbiAgICAgICAgICBtb2Q6IG5ldyBzKDApXG4gICAgICAgIH07XG4gICAgICB2YXIgYywgYiwgRTtcbiAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwICYmIHAubmVnYXRpdmUgPT09IDAgPyAoRSA9IHRoaXMubmVnKCkuZGl2bW9kKHAsIGwpLCBsICE9PSBcIm1vZFwiICYmIChjID0gRS5kaXYubmVnKCkpLCBsICE9PSBcImRpdlwiICYmIChiID0gRS5tb2QubmVnKCksIGEgJiYgYi5uZWdhdGl2ZSAhPT0gMCAmJiBiLmlhZGQocCkpLCB7XG4gICAgICAgIGRpdjogYyxcbiAgICAgICAgbW9kOiBiXG4gICAgICB9KSA6IHRoaXMubmVnYXRpdmUgPT09IDAgJiYgcC5uZWdhdGl2ZSAhPT0gMCA/IChFID0gdGhpcy5kaXZtb2QocC5uZWcoKSwgbCksIGwgIT09IFwibW9kXCIgJiYgKGMgPSBFLmRpdi5uZWcoKSksIHtcbiAgICAgICAgZGl2OiBjLFxuICAgICAgICBtb2Q6IEUubW9kXG4gICAgICB9KSA6IHRoaXMubmVnYXRpdmUgJiBwLm5lZ2F0aXZlID8gKEUgPSB0aGlzLm5lZygpLmRpdm1vZChwLm5lZygpLCBsKSwgbCAhPT0gXCJkaXZcIiAmJiAoYiA9IEUubW9kLm5lZygpLCBhICYmIGIubmVnYXRpdmUgIT09IDAgJiYgYi5pc3ViKHApKSwge1xuICAgICAgICBkaXY6IEUuZGl2LFxuICAgICAgICBtb2Q6IGJcbiAgICAgIH0pIDogcC5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChwKSA8IDAgPyB7XG4gICAgICAgIGRpdjogbmV3IHMoMCksXG4gICAgICAgIG1vZDogdGhpc1xuICAgICAgfSA6IHAubGVuZ3RoID09PSAxID8gbCA9PT0gXCJkaXZcIiA/IHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4ocC53b3Jkc1swXSksXG4gICAgICAgIG1vZDogbnVsbFxuICAgICAgfSA6IGwgPT09IFwibW9kXCIgPyB7XG4gICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgbW9kOiBuZXcgcyh0aGlzLm1vZG4ocC53b3Jkc1swXSkpXG4gICAgICB9IDoge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihwLndvcmRzWzBdKSxcbiAgICAgICAgbW9kOiBuZXcgcyh0aGlzLm1vZG4ocC53b3Jkc1swXSkpXG4gICAgICB9IDogdGhpcy5fd29yZERpdihwLCBsKTtcbiAgICB9LCBzLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXZtb2QocCwgXCJkaXZcIiwgITEpLmRpdjtcbiAgICB9LCBzLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXZtb2QocCwgXCJtb2RcIiwgITEpLm1vZDtcbiAgICB9LCBzLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2bW9kKHAsIFwibW9kXCIsICEwKS5tb2Q7XG4gICAgfSwgcy5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgbCA9IHRoaXMuZGl2bW9kKHApO1xuICAgICAgaWYgKGwubW9kLmlzWmVybygpKVxuICAgICAgICByZXR1cm4gbC5kaXY7XG4gICAgICB2YXIgYSA9IGwuZGl2Lm5lZ2F0aXZlICE9PSAwID8gbC5tb2QuaXN1YihwKSA6IGwubW9kLCBjID0gcC51c2hybigxKSwgYiA9IHAuYW5kbG4oMSksIEUgPSBhLmNtcChjKTtcbiAgICAgIHJldHVybiBFIDwgMCB8fCBiID09PSAxICYmIEUgPT09IDAgPyBsLmRpdiA6IGwuZGl2Lm5lZ2F0aXZlICE9PSAwID8gbC5kaXYuaXN1Ym4oMSkgOiBsLmRpdi5pYWRkbigxKTtcbiAgICB9LCBzLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24ocCkge1xuICAgICAgaShwIDw9IDY3MTA4ODYzKTtcbiAgICAgIGZvciAodmFyIGwgPSAoMSA8PCAyNikgJSBwLCBhID0gMCwgYyA9IHRoaXMubGVuZ3RoIC0gMTsgYyA+PSAwOyBjLS0pXG4gICAgICAgIGEgPSAobCAqIGEgKyAodGhpcy53b3Jkc1tjXSB8IDApKSAlIHA7XG4gICAgICByZXR1cm4gYTtcbiAgICB9LCBzLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIGkocCA8PSA2NzEwODg2Myk7XG4gICAgICBmb3IgKHZhciBsID0gMCwgYSA9IHRoaXMubGVuZ3RoIC0gMTsgYSA+PSAwOyBhLS0pIHtcbiAgICAgICAgdmFyIGMgPSAodGhpcy53b3Jkc1thXSB8IDApICsgbCAqIDY3MTA4ODY0O1xuICAgICAgICB0aGlzLndvcmRzW2FdID0gYyAvIHAgfCAwLCBsID0gYyAlIHA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICAgIH0sIHMucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKHApO1xuICAgIH0sIHMucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbihwKSB7XG4gICAgICBpKHAubmVnYXRpdmUgPT09IDApLCBpKCFwLmlzWmVybygpKTtcbiAgICAgIHZhciBsID0gdGhpcywgYSA9IHAuY2xvbmUoKTtcbiAgICAgIGwubmVnYXRpdmUgIT09IDAgPyBsID0gbC51bW9kKHApIDogbCA9IGwuY2xvbmUoKTtcbiAgICAgIGZvciAodmFyIGMgPSBuZXcgcygxKSwgYiA9IG5ldyBzKDApLCBFID0gbmV3IHMoMCksIFMgPSBuZXcgcygxKSwgeCA9IDA7IGwuaXNFdmVuKCkgJiYgYS5pc0V2ZW4oKTsgKVxuICAgICAgICBsLml1c2hybigxKSwgYS5pdXNocm4oMSksICsreDtcbiAgICAgIGZvciAodmFyIHUgPSBhLmNsb25lKCksIG0gPSBsLmNsb25lKCk7ICFsLmlzWmVybygpOyApIHtcbiAgICAgICAgZm9yICh2YXIgZyA9IDAsIFAgPSAxOyAhKGwud29yZHNbMF0gJiBQKSAmJiBnIDwgMjY7ICsrZywgUCA8PD0gMSlcbiAgICAgICAgICA7XG4gICAgICAgIGlmIChnID4gMClcbiAgICAgICAgICBmb3IgKGwuaXVzaHJuKGcpOyBnLS0gPiAwOyApXG4gICAgICAgICAgICAoYy5pc09kZCgpIHx8IGIuaXNPZGQoKSkgJiYgKGMuaWFkZCh1KSwgYi5pc3ViKG0pKSwgYy5pdXNocm4oMSksIGIuaXVzaHJuKDEpO1xuICAgICAgICBmb3IgKHZhciBHID0gMCwgTSA9IDE7ICEoYS53b3Jkc1swXSAmIE0pICYmIEcgPCAyNjsgKytHLCBNIDw8PSAxKVxuICAgICAgICAgIDtcbiAgICAgICAgaWYgKEcgPiAwKVxuICAgICAgICAgIGZvciAoYS5pdXNocm4oRyk7IEctLSA+IDA7IClcbiAgICAgICAgICAgIChFLmlzT2RkKCkgfHwgUy5pc09kZCgpKSAmJiAoRS5pYWRkKHUpLCBTLmlzdWIobSkpLCBFLml1c2hybigxKSwgUy5pdXNocm4oMSk7XG4gICAgICAgIGwuY21wKGEpID49IDAgPyAobC5pc3ViKGEpLCBjLmlzdWIoRSksIGIuaXN1YihTKSkgOiAoYS5pc3ViKGwpLCBFLmlzdWIoYyksIFMuaXN1YihiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhOiBFLFxuICAgICAgICBiOiBTLFxuICAgICAgICBnY2Q6IGEuaXVzaGxuKHgpXG4gICAgICB9O1xuICAgIH0sIHMucHJvdG90eXBlLl9pbnZtcCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIGkocC5uZWdhdGl2ZSA9PT0gMCksIGkoIXAuaXNaZXJvKCkpO1xuICAgICAgdmFyIGwgPSB0aGlzLCBhID0gcC5jbG9uZSgpO1xuICAgICAgbC5uZWdhdGl2ZSAhPT0gMCA/IGwgPSBsLnVtb2QocCkgOiBsID0gbC5jbG9uZSgpO1xuICAgICAgZm9yICh2YXIgYyA9IG5ldyBzKDEpLCBiID0gbmV3IHMoMCksIEUgPSBhLmNsb25lKCk7IGwuY21wbigxKSA+IDAgJiYgYS5jbXBuKDEpID4gMDsgKSB7XG4gICAgICAgIGZvciAodmFyIFMgPSAwLCB4ID0gMTsgIShsLndvcmRzWzBdICYgeCkgJiYgUyA8IDI2OyArK1MsIHggPDw9IDEpXG4gICAgICAgICAgO1xuICAgICAgICBpZiAoUyA+IDApXG4gICAgICAgICAgZm9yIChsLml1c2hybihTKTsgUy0tID4gMDsgKVxuICAgICAgICAgICAgYy5pc09kZCgpICYmIGMuaWFkZChFKSwgYy5pdXNocm4oMSk7XG4gICAgICAgIGZvciAodmFyIHUgPSAwLCBtID0gMTsgIShhLndvcmRzWzBdICYgbSkgJiYgdSA8IDI2OyArK3UsIG0gPDw9IDEpXG4gICAgICAgICAgO1xuICAgICAgICBpZiAodSA+IDApXG4gICAgICAgICAgZm9yIChhLml1c2hybih1KTsgdS0tID4gMDsgKVxuICAgICAgICAgICAgYi5pc09kZCgpICYmIGIuaWFkZChFKSwgYi5pdXNocm4oMSk7XG4gICAgICAgIGwuY21wKGEpID49IDAgPyAobC5pc3ViKGEpLCBjLmlzdWIoYikpIDogKGEuaXN1YihsKSwgYi5pc3ViKGMpKTtcbiAgICAgIH1cbiAgICAgIHZhciBnO1xuICAgICAgcmV0dXJuIGwuY21wbigxKSA9PT0gMCA/IGcgPSBjIDogZyA9IGIsIGcuY21wbigwKSA8IDAgJiYgZy5pYWRkKHApLCBnO1xuICAgIH0sIHMucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIGlmICh0aGlzLmlzWmVybygpKVxuICAgICAgICByZXR1cm4gcC5hYnMoKTtcbiAgICAgIGlmIChwLmlzWmVybygpKVxuICAgICAgICByZXR1cm4gdGhpcy5hYnMoKTtcbiAgICAgIHZhciBsID0gdGhpcy5jbG9uZSgpLCBhID0gcC5jbG9uZSgpO1xuICAgICAgbC5uZWdhdGl2ZSA9IDAsIGEubmVnYXRpdmUgPSAwO1xuICAgICAgZm9yICh2YXIgYyA9IDA7IGwuaXNFdmVuKCkgJiYgYS5pc0V2ZW4oKTsgYysrKVxuICAgICAgICBsLml1c2hybigxKSwgYS5pdXNocm4oMSk7XG4gICAgICBkbyB7XG4gICAgICAgIGZvciAoOyBsLmlzRXZlbigpOyApXG4gICAgICAgICAgbC5pdXNocm4oMSk7XG4gICAgICAgIGZvciAoOyBhLmlzRXZlbigpOyApXG4gICAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICAgIHZhciBiID0gbC5jbXAoYSk7XG4gICAgICAgIGlmIChiIDwgMCkge1xuICAgICAgICAgIHZhciBFID0gbDtcbiAgICAgICAgICBsID0gYSwgYSA9IEU7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMCB8fCBhLmNtcG4oMSkgPT09IDApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGwuaXN1YihhKTtcbiAgICAgIH0gd2hpbGUgKCEwKTtcbiAgICAgIHJldHVybiBhLml1c2hsbihjKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWdjZChwKS5hLnVtb2QocCk7XG4gICAgfSwgcy5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgICB9LCBzLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gICAgfSwgcy5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIHA7XG4gICAgfSwgcy5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbihwKSB7XG4gICAgICBpKHR5cGVvZiBwID09IFwibnVtYmVyXCIpO1xuICAgICAgdmFyIGwgPSBwICUgMjYsIGEgPSAocCAtIGwpIC8gMjYsIGMgPSAxIDw8IGw7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPD0gYSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuZChhICsgMSksIHRoaXMud29yZHNbYV0gfD0gYywgdGhpcztcbiAgICAgIGZvciAodmFyIGIgPSBjLCBFID0gYTsgYiAhPT0gMCAmJiBFIDwgdGhpcy5sZW5ndGg7IEUrKykge1xuICAgICAgICB2YXIgUyA9IHRoaXMud29yZHNbRV0gfCAwO1xuICAgICAgICBTICs9IGIsIGIgPSBTID4+PiAyNiwgUyAmPSA2NzEwODg2MywgdGhpcy53b3Jkc1tFXSA9IFM7XG4gICAgICB9XG4gICAgICByZXR1cm4gYiAhPT0gMCAmJiAodGhpcy53b3Jkc1tFXSA9IGIsIHRoaXMubGVuZ3RoKyspLCB0aGlzO1xuICAgIH0sIHMucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gICAgfSwgcy5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBsID0gcCA8IDA7XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB0aGlzLnN0cmlwKCk7XG4gICAgICB2YXIgYTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpXG4gICAgICAgIGEgPSAxO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGwgJiYgKHAgPSAtcCksIGkocCA8PSA2NzEwODg2MywgXCJOdW1iZXIgaXMgdG9vIGJpZ1wiKTtcbiAgICAgICAgdmFyIGMgPSB0aGlzLndvcmRzWzBdIHwgMDtcbiAgICAgICAgYSA9IGMgPT09IHAgPyAwIDogYyA8IHAgPyAtMSA6IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMCA/IC1hIHwgMCA6IGE7XG4gICAgfSwgcy5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24ocCkge1xuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgcC5uZWdhdGl2ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgcC5uZWdhdGl2ZSAhPT0gMClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB2YXIgbCA9IHRoaXMudWNtcChwKTtcbiAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwID8gLWwgfCAwIDogbDtcbiAgICB9LCBzLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24ocCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gcC5sZW5ndGgpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgcC5sZW5ndGgpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGZvciAodmFyIGwgPSAwLCBhID0gdGhpcy5sZW5ndGggLSAxOyBhID49IDA7IGEtLSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMud29yZHNbYV0gfCAwLCBiID0gcC53b3Jkc1thXSB8IDA7XG4gICAgICAgIGlmIChjICE9PSBiKSB7XG4gICAgICAgICAgYyA8IGIgPyBsID0gLTEgOiBjID4gYiAmJiAobCA9IDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbDtcbiAgICB9LCBzLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbXBuKHApID09PSAxO1xuICAgIH0sIHMucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMuY21wKHApID09PSAxO1xuICAgIH0sIHMucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbXBuKHApID49IDA7XG4gICAgfSwgcy5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMuY21wKHApID49IDA7XG4gICAgfSwgcy5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMuY21wbihwKSA9PT0gLTE7XG4gICAgfSwgcy5wcm90b3R5cGUubHQgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbXAocCkgPT09IC0xO1xuICAgIH0sIHMucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbXBuKHApIDw9IDA7XG4gICAgfSwgcy5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMuY21wKHApIDw9IDA7XG4gICAgfSwgcy5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMuY21wbihwKSA9PT0gMDtcbiAgICB9LCBzLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiB0aGlzLmNtcChwKSA9PT0gMDtcbiAgICB9LCBzLnJlZCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBuZXcgSihwKTtcbiAgICB9LCBzLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBpKCF0aGlzLnJlZCwgXCJBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0XCIpLCBpKHRoaXMubmVnYXRpdmUgPT09IDAsIFwicmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXNcIiksIHAuY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChwKTtcbiAgICB9LCBzLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLnJlZCwgXCJmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0XCIpLCB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbiAgICB9LCBzLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWQgPSBwLCB0aGlzO1xuICAgIH0sIHMucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIGkoIXRoaXMucmVkLCBcIkFscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHRcIiksIHRoaXMuX2ZvcmNlUmVkKHApO1xuICAgIH0sIHMucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBpKHRoaXMucmVkLCBcInJlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLmFkZCh0aGlzLCBwKTtcbiAgICB9LCBzLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIGkodGhpcy5yZWQsIFwicmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLmlhZGQodGhpcywgcCk7XG4gICAgfSwgcy5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIGkodGhpcy5yZWQsIFwicmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuc3ViKHRoaXMsIHApO1xuICAgIH0sIHMucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLnJlZCwgXCJyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuaXN1Yih0aGlzLCBwKTtcbiAgICB9LCBzLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLnJlZCwgXCJyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5zaGwodGhpcywgcCk7XG4gICAgfSwgcy5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIGkodGhpcy5yZWQsIFwicmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgcCksIHRoaXMucmVkLm11bCh0aGlzLCBwKTtcbiAgICB9LCBzLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIGkodGhpcy5yZWQsIFwicmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgcCksIHRoaXMucmVkLmltdWwodGhpcywgcCk7XG4gICAgfSwgcy5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLnJlZCwgXCJyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSwgdGhpcy5yZWQuc3FyKHRoaXMpO1xuICAgIH0sIHMucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpKHRoaXMucmVkLCBcInJlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSwgdGhpcy5yZWQuaXNxcih0aGlzKTtcbiAgICB9LCBzLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLnJlZCwgXCJyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyksIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gICAgfSwgcy5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGkodGhpcy5yZWQsIFwicmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLCB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICAgIH0sIHMucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGkodGhpcy5yZWQsIFwicmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyksIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgICB9LCBzLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLnJlZCAmJiAhcC5yZWQsIFwicmVkUG93KG5vcm1hbE51bSlcIiksIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLCB0aGlzLnJlZC5wb3codGhpcywgcCk7XG4gICAgfTtcbiAgICB2YXIgSyA9IHtcbiAgICAgIGsyNTY6IG51bGwsXG4gICAgICBwMjI0OiBudWxsLFxuICAgICAgcDE5MjogbnVsbCxcbiAgICAgIHAyNTUxOTogbnVsbFxuICAgIH07XG4gICAgZnVuY3Rpb24gJChPLCBwKSB7XG4gICAgICB0aGlzLm5hbWUgPSBPLCB0aGlzLnAgPSBuZXcgcyhwLCAxNiksIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKSwgdGhpcy5rID0gbmV3IHMoMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApLCB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xuICAgIH1cbiAgICAkLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IG5ldyBzKG51bGwpO1xuICAgICAgcmV0dXJuIHAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSksIHA7XG4gICAgfSwgJC5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBsID0gcCwgYTtcbiAgICAgIGRvXG4gICAgICAgIHRoaXMuc3BsaXQobCwgdGhpcy50bXApLCBsID0gdGhpcy5pbXVsSyhsKSwgbCA9IGwuaWFkZCh0aGlzLnRtcCksIGEgPSBsLmJpdExlbmd0aCgpO1xuICAgICAgd2hpbGUgKGEgPiB0aGlzLm4pO1xuICAgICAgdmFyIGMgPSBhIDwgdGhpcy5uID8gLTEgOiBsLnVjbXAodGhpcy5wKTtcbiAgICAgIHJldHVybiBjID09PSAwID8gKGwud29yZHNbMF0gPSAwLCBsLmxlbmd0aCA9IDEpIDogYyA+IDAgPyBsLmlzdWIodGhpcy5wKSA6IGwuc3RyaXAgIT09IHZvaWQgMCA/IGwuc3RyaXAoKSA6IGwuX3N0cmlwKCksIGw7XG4gICAgfSwgJC5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbihwLCBsKSB7XG4gICAgICBwLml1c2hybih0aGlzLm4sIDAsIGwpO1xuICAgIH0sICQucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHAuaW11bCh0aGlzLmspO1xuICAgIH07XG4gICAgZnVuY3Rpb24geigpIHtcbiAgICAgICQuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgXCJrMjU2XCIsXG4gICAgICAgIFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmZcIlxuICAgICAgKTtcbiAgICB9XG4gICAgbih6LCAkKSwgei5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbihwLCBsKSB7XG4gICAgICBmb3IgKHZhciBhID0gNDE5NDMwMywgYyA9IE1hdGgubWluKHAubGVuZ3RoLCA5KSwgYiA9IDA7IGIgPCBjOyBiKyspXG4gICAgICAgIGwud29yZHNbYl0gPSBwLndvcmRzW2JdO1xuICAgICAgaWYgKGwubGVuZ3RoID0gYywgcC5sZW5ndGggPD0gOSkge1xuICAgICAgICBwLndvcmRzWzBdID0gMCwgcC5sZW5ndGggPSAxO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgRSA9IHAud29yZHNbOV07XG4gICAgICBmb3IgKGwud29yZHNbbC5sZW5ndGgrK10gPSBFICYgYSwgYiA9IDEwOyBiIDwgcC5sZW5ndGg7IGIrKykge1xuICAgICAgICB2YXIgUyA9IHAud29yZHNbYl0gfCAwO1xuICAgICAgICBwLndvcmRzW2IgLSAxMF0gPSAoUyAmIGEpIDw8IDQgfCBFID4+PiAyMiwgRSA9IFM7XG4gICAgICB9XG4gICAgICBFID4+Pj0gMjIsIHAud29yZHNbYiAtIDEwXSA9IEUsIEUgPT09IDAgJiYgcC5sZW5ndGggPiAxMCA/IHAubGVuZ3RoIC09IDEwIDogcC5sZW5ndGggLT0gOTtcbiAgICB9LCB6LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHAud29yZHNbcC5sZW5ndGhdID0gMCwgcC53b3Jkc1twLmxlbmd0aCArIDFdID0gMCwgcC5sZW5ndGggKz0gMjtcbiAgICAgIGZvciAodmFyIGwgPSAwLCBhID0gMDsgYSA8IHAubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgdmFyIGMgPSBwLndvcmRzW2FdIHwgMDtcbiAgICAgICAgbCArPSBjICogOTc3LCBwLndvcmRzW2FdID0gbCAmIDY3MTA4ODYzLCBsID0gYyAqIDY0ICsgKGwgLyA2NzEwODg2NCB8IDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHAud29yZHNbcC5sZW5ndGggLSAxXSA9PT0gMCAmJiAocC5sZW5ndGgtLSwgcC53b3Jkc1twLmxlbmd0aCAtIDFdID09PSAwICYmIHAubGVuZ3RoLS0pLCBwO1xuICAgIH07XG4gICAgZnVuY3Rpb24gQigpIHtcbiAgICAgICQuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgXCJwMjI0XCIsXG4gICAgICAgIFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDFcIlxuICAgICAgKTtcbiAgICB9XG4gICAgbihCLCAkKTtcbiAgICBmdW5jdGlvbiBfKCkge1xuICAgICAgJC5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICBcInAxOTJcIixcbiAgICAgICAgXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZlwiXG4gICAgICApO1xuICAgIH1cbiAgICBuKF8sICQpO1xuICAgIGZ1bmN0aW9uIFIoKSB7XG4gICAgICAkLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIFwiMjU1MTlcIixcbiAgICAgICAgXCI3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkXCJcbiAgICAgICk7XG4gICAgfVxuICAgIG4oUiwgJCksIFIucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24ocCkge1xuICAgICAgZm9yICh2YXIgbCA9IDAsIGEgPSAwOyBhIDwgcC5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgYyA9IChwLndvcmRzW2FdIHwgMCkgKiAxOSArIGwsIGIgPSBjICYgNjcxMDg4NjM7XG4gICAgICAgIGMgPj4+PSAyNiwgcC53b3Jkc1thXSA9IGIsIGwgPSBjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGwgIT09IDAgJiYgKHAud29yZHNbcC5sZW5ndGgrK10gPSBsKSwgcDtcbiAgICB9LCBzLl9wcmltZSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIGlmIChLW3BdKVxuICAgICAgICByZXR1cm4gS1twXTtcbiAgICAgIHZhciBsO1xuICAgICAgaWYgKHAgPT09IFwiazI1NlwiKVxuICAgICAgICBsID0gbmV3IHooKTtcbiAgICAgIGVsc2UgaWYgKHAgPT09IFwicDIyNFwiKVxuICAgICAgICBsID0gbmV3IEIoKTtcbiAgICAgIGVsc2UgaWYgKHAgPT09IFwicDE5MlwiKVxuICAgICAgICBsID0gbmV3IF8oKTtcbiAgICAgIGVsc2UgaWYgKHAgPT09IFwicDI1NTE5XCIpXG4gICAgICAgIGwgPSBuZXcgUigpO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHByaW1lIFwiICsgcCk7XG4gICAgICByZXR1cm4gS1twXSA9IGwsIGw7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBKKE8pIHtcbiAgICAgIGlmICh0eXBlb2YgTyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBwID0gcy5fcHJpbWUoTyk7XG4gICAgICAgIHRoaXMubSA9IHAucCwgdGhpcy5wcmltZSA9IHA7XG4gICAgICB9IGVsc2VcbiAgICAgICAgaShPLmd0bigxKSwgXCJtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDFcIiksIHRoaXMubSA9IE8sIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgICBKLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIGkocC5uZWdhdGl2ZSA9PT0gMCwgXCJyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlc1wiKSwgaShwLnJlZCwgXCJyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpO1xuICAgIH0sIEoucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24ocCwgbCkge1xuICAgICAgaSgocC5uZWdhdGl2ZSB8IGwubmVnYXRpdmUpID09PSAwLCBcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpLCBpKFxuICAgICAgICBwLnJlZCAmJiBwLnJlZCA9PT0gbC5yZWQsXG4gICAgICAgIFwicmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiXG4gICAgICApO1xuICAgIH0sIEoucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmltZSA/IHRoaXMucHJpbWUuaXJlZHVjZShwKS5fZm9yY2VSZWQodGhpcykgOiBwLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgfSwgSi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHAuaXNaZXJvKCkgPyBwLmNsb25lKCkgOiB0aGlzLm0uc3ViKHApLl9mb3JjZVJlZCh0aGlzKTtcbiAgICB9LCBKLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihwLCBsKSB7XG4gICAgICB0aGlzLl92ZXJpZnkyKHAsIGwpO1xuICAgICAgdmFyIGEgPSBwLmFkZChsKTtcbiAgICAgIHJldHVybiBhLmNtcCh0aGlzLm0pID49IDAgJiYgYS5pc3ViKHRoaXMubSksIGEuX2ZvcmNlUmVkKHRoaXMpO1xuICAgIH0sIEoucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbihwLCBsKSB7XG4gICAgICB0aGlzLl92ZXJpZnkyKHAsIGwpO1xuICAgICAgdmFyIGEgPSBwLmlhZGQobCk7XG4gICAgICByZXR1cm4gYS5jbXAodGhpcy5tKSA+PSAwICYmIGEuaXN1Yih0aGlzLm0pLCBhO1xuICAgIH0sIEoucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKHAsIGwpIHtcbiAgICAgIHRoaXMuX3ZlcmlmeTIocCwgbCk7XG4gICAgICB2YXIgYSA9IHAuc3ViKGwpO1xuICAgICAgcmV0dXJuIGEuY21wbigwKSA8IDAgJiYgYS5pYWRkKHRoaXMubSksIGEuX2ZvcmNlUmVkKHRoaXMpO1xuICAgIH0sIEoucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbihwLCBsKSB7XG4gICAgICB0aGlzLl92ZXJpZnkyKHAsIGwpO1xuICAgICAgdmFyIGEgPSBwLmlzdWIobCk7XG4gICAgICByZXR1cm4gYS5jbXBuKDApIDwgMCAmJiBhLmlhZGQodGhpcy5tKSwgYTtcbiAgICB9LCBKLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbihwLCBsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmVyaWZ5MShwKSwgdGhpcy5pbW9kKHAudXNobG4obCkpO1xuICAgIH0sIEoucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbihwLCBsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmVyaWZ5MihwLCBsKSwgdGhpcy5pbW9kKHAuaW11bChsKSk7XG4gICAgfSwgSi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24ocCwgbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeTIocCwgbCksIHRoaXMuaW1vZChwLm11bChsKSk7XG4gICAgfSwgSi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiB0aGlzLmltdWwocCwgcC5jbG9uZSgpKTtcbiAgICB9LCBKLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5tdWwocCwgcCk7XG4gICAgfSwgSi5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIGlmIChwLmlzWmVybygpKVxuICAgICAgICByZXR1cm4gcC5jbG9uZSgpO1xuICAgICAgdmFyIGwgPSB0aGlzLm0uYW5kbG4oMyk7XG4gICAgICBpZiAoaShsICUgMiA9PT0gMSksIGwgPT09IDMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm0uYWRkKG5ldyBzKDEpKS5pdXNocm4oMik7XG4gICAgICAgIHJldHVybiB0aGlzLnBvdyhwLCBhKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGMgPSB0aGlzLm0uc3VibigxKSwgYiA9IDA7ICFjLmlzWmVybygpICYmIGMuYW5kbG4oMSkgPT09IDA7IClcbiAgICAgICAgYisrLCBjLml1c2hybigxKTtcbiAgICAgIGkoIWMuaXNaZXJvKCkpO1xuICAgICAgdmFyIEUgPSBuZXcgcygxKS50b1JlZCh0aGlzKSwgUyA9IEUucmVkTmVnKCksIHggPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSksIHUgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgICBmb3IgKHUgPSBuZXcgcygyICogdSAqIHUpLnRvUmVkKHRoaXMpOyB0aGlzLnBvdyh1LCB4KS5jbXAoUykgIT09IDA7IClcbiAgICAgICAgdS5yZWRJQWRkKFMpO1xuICAgICAgZm9yICh2YXIgbSA9IHRoaXMucG93KHUsIGMpLCBnID0gdGhpcy5wb3cocCwgYy5hZGRuKDEpLml1c2hybigxKSksIFAgPSB0aGlzLnBvdyhwLCBjKSwgRyA9IGI7IFAuY21wKEUpICE9PSAwOyApIHtcbiAgICAgICAgZm9yICh2YXIgTSA9IFAsIEggPSAwOyBNLmNtcChFKSAhPT0gMDsgSCsrKVxuICAgICAgICAgIE0gPSBNLnJlZFNxcigpO1xuICAgICAgICBpKEggPCBHKTtcbiAgICAgICAgdmFyIEMgPSB0aGlzLnBvdyhtLCBuZXcgcygxKS5pdXNobG4oRyAtIEggLSAxKSk7XG4gICAgICAgIGcgPSBnLnJlZE11bChDKSwgbSA9IEMucmVkU3FyKCksIFAgPSBQLnJlZE11bChtKSwgRyA9IEg7XG4gICAgICB9XG4gICAgICByZXR1cm4gZztcbiAgICB9LCBKLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGwgPSBwLl9pbnZtcCh0aGlzLm0pO1xuICAgICAgcmV0dXJuIGwubmVnYXRpdmUgIT09IDAgPyAobC5uZWdhdGl2ZSA9IDAsIHRoaXMuaW1vZChsKS5yZWROZWcoKSkgOiB0aGlzLmltb2QobCk7XG4gICAgfSwgSi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24ocCwgbCkge1xuICAgICAgaWYgKGwuaXNaZXJvKCkpXG4gICAgICAgIHJldHVybiBuZXcgcygxKS50b1JlZCh0aGlzKTtcbiAgICAgIGlmIChsLmNtcG4oMSkgPT09IDApXG4gICAgICAgIHJldHVybiBwLmNsb25lKCk7XG4gICAgICB2YXIgYSA9IDQsIGMgPSBuZXcgQXJyYXkoMSA8PCBhKTtcbiAgICAgIGNbMF0gPSBuZXcgcygxKS50b1JlZCh0aGlzKSwgY1sxXSA9IHA7XG4gICAgICBmb3IgKHZhciBiID0gMjsgYiA8IGMubGVuZ3RoOyBiKyspXG4gICAgICAgIGNbYl0gPSB0aGlzLm11bChjW2IgLSAxXSwgcCk7XG4gICAgICB2YXIgRSA9IGNbMF0sIFMgPSAwLCB4ID0gMCwgdSA9IGwuYml0TGVuZ3RoKCkgJSAyNjtcbiAgICAgIGZvciAodSA9PT0gMCAmJiAodSA9IDI2KSwgYiA9IGwubGVuZ3RoIC0gMTsgYiA+PSAwOyBiLS0pIHtcbiAgICAgICAgZm9yICh2YXIgbSA9IGwud29yZHNbYl0sIGcgPSB1IC0gMTsgZyA+PSAwOyBnLS0pIHtcbiAgICAgICAgICB2YXIgUCA9IG0gPj4gZyAmIDE7XG4gICAgICAgICAgaWYgKEUgIT09IGNbMF0gJiYgKEUgPSB0aGlzLnNxcihFKSksIFAgPT09IDAgJiYgUyA9PT0gMCkge1xuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgUyA8PD0gMSwgUyB8PSBQLCB4KyssICEoeCAhPT0gYSAmJiAoYiAhPT0gMCB8fCBnICE9PSAwKSkgJiYgKEUgPSB0aGlzLm11bChFLCBjW1NdKSwgeCA9IDAsIFMgPSAwKTtcbiAgICAgICAgfVxuICAgICAgICB1ID0gMjY7XG4gICAgICB9XG4gICAgICByZXR1cm4gRTtcbiAgICB9LCBKLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgbCA9IHAudW1vZCh0aGlzLm0pO1xuICAgICAgcmV0dXJuIGwgPT09IHAgPyBsLmNsb25lKCkgOiBsO1xuICAgIH0sIEoucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGwgPSBwLmNsb25lKCk7XG4gICAgICByZXR1cm4gbC5yZWQgPSBudWxsLCBsO1xuICAgIH0sIHMubW9udCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBuZXcgUShwKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIFEoTykge1xuICAgICAgSi5jYWxsKHRoaXMsIE8pLCB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpLCB0aGlzLnNoaWZ0ICUgMjYgIT09IDAgJiYgKHRoaXMuc2hpZnQgKz0gMjYgLSB0aGlzLnNoaWZ0ICUgMjYpLCB0aGlzLnIgPSBuZXcgcygxKS5pdXNobG4odGhpcy5zaGlmdCksIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKSwgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pLCB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSksIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMuciksIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcbiAgICB9XG4gICAgbihRLCBKKSwgUS5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChwLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgICB9LCBRLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBsID0gdGhpcy5pbW9kKHAubXVsKHRoaXMucmludikpO1xuICAgICAgcmV0dXJuIGwucmVkID0gbnVsbCwgbDtcbiAgICB9LCBRLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24ocCwgbCkge1xuICAgICAgaWYgKHAuaXNaZXJvKCkgfHwgbC5pc1plcm8oKSlcbiAgICAgICAgcmV0dXJuIHAud29yZHNbMF0gPSAwLCBwLmxlbmd0aCA9IDEsIHA7XG4gICAgICB2YXIgYSA9IHAuaW11bChsKSwgYyA9IGEubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pLCBiID0gYS5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KSwgRSA9IGI7XG4gICAgICByZXR1cm4gYi5jbXAodGhpcy5tKSA+PSAwID8gRSA9IGIuaXN1Yih0aGlzLm0pIDogYi5jbXBuKDApIDwgMCAmJiAoRSA9IGIuaWFkZCh0aGlzLm0pKSwgRS5fZm9yY2VSZWQodGhpcyk7XG4gICAgfSwgUS5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24ocCwgbCkge1xuICAgICAgaWYgKHAuaXNaZXJvKCkgfHwgbC5pc1plcm8oKSlcbiAgICAgICAgcmV0dXJuIG5ldyBzKDApLl9mb3JjZVJlZCh0aGlzKTtcbiAgICAgIHZhciBhID0gcC5tdWwobCksIGMgPSBhLm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKSwgYiA9IGEuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCksIEUgPSBiO1xuICAgICAgcmV0dXJuIGIuY21wKHRoaXMubSkgPj0gMCA/IEUgPSBiLmlzdWIodGhpcy5tKSA6IGIuY21wbigwKSA8IDAgJiYgKEUgPSBiLmlhZGQodGhpcy5tKSksIEUuX2ZvcmNlUmVkKHRoaXMpO1xuICAgIH0sIFEucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgbCA9IHRoaXMuaW1vZChwLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG4gICAgICByZXR1cm4gbC5fZm9yY2VSZWQodGhpcyk7XG4gICAgfTtcbiAgfSkociwgdHIpO1xufSkoV28pO1xudmFyIGxpID0gV28uZXhwb3J0cywgR28gPSB7fTtcbihmdW5jdGlvbihyKSB7XG4gIHZhciBlID0gcjtcbiAgZnVuY3Rpb24gdChzLCBvKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocykpXG4gICAgICByZXR1cm4gcy5zbGljZSgpO1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiBbXTtcbiAgICB2YXIgZiA9IFtdO1xuICAgIGlmICh0eXBlb2YgcyAhPSBcInN0cmluZ1wiKSB7XG4gICAgICBmb3IgKHZhciBoID0gMDsgaCA8IHMubGVuZ3RoOyBoKyspXG4gICAgICAgIGZbaF0gPSBzW2hdIHwgMDtcbiAgICAgIHJldHVybiBmO1xuICAgIH1cbiAgICBpZiAobyA9PT0gXCJoZXhcIikge1xuICAgICAgcyA9IHMucmVwbGFjZSgvW15hLXowLTldKy9pZywgXCJcIiksIHMubGVuZ3RoICUgMiAhPT0gMCAmJiAocyA9IFwiMFwiICsgcyk7XG4gICAgICBmb3IgKHZhciBoID0gMDsgaCA8IHMubGVuZ3RoOyBoICs9IDIpXG4gICAgICAgIGYucHVzaChwYXJzZUludChzW2hdICsgc1toICsgMV0sIDE2KSk7XG4gICAgfSBlbHNlXG4gICAgICBmb3IgKHZhciBoID0gMDsgaCA8IHMubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgdmFyIGQgPSBzLmNoYXJDb2RlQXQoaCksIHYgPSBkID4+IDgsIHcgPSBkICYgMjU1O1xuICAgICAgICB2ID8gZi5wdXNoKHYsIHcpIDogZi5wdXNoKHcpO1xuICAgICAgfVxuICAgIHJldHVybiBmO1xuICB9XG4gIGUudG9BcnJheSA9IHQ7XG4gIGZ1bmN0aW9uIGkocykge1xuICAgIHJldHVybiBzLmxlbmd0aCA9PT0gMSA/IFwiMFwiICsgcyA6IHM7XG4gIH1cbiAgZS56ZXJvMiA9IGk7XG4gIGZ1bmN0aW9uIG4ocykge1xuICAgIGZvciAodmFyIG8gPSBcIlwiLCBmID0gMDsgZiA8IHMubGVuZ3RoOyBmKyspXG4gICAgICBvICs9IGkoc1tmXS50b1N0cmluZygxNikpO1xuICAgIHJldHVybiBvO1xuICB9XG4gIGUudG9IZXggPSBuLCBlLmVuY29kZSA9IGZ1bmN0aW9uKG8sIGYpIHtcbiAgICByZXR1cm4gZiA9PT0gXCJoZXhcIiA/IG4obykgOiBvO1xuICB9O1xufSkoR28pO1xuKGZ1bmN0aW9uKHIpIHtcbiAgdmFyIGUgPSByLCB0ID0gbGksIGkgPSBZaSwgbiA9IEdvO1xuICBlLmFzc2VydCA9IGksIGUudG9BcnJheSA9IG4udG9BcnJheSwgZS56ZXJvMiA9IG4uemVybzIsIGUudG9IZXggPSBuLnRvSGV4LCBlLmVuY29kZSA9IG4uZW5jb2RlO1xuICBmdW5jdGlvbiBzKHYsIHcsIEEpIHtcbiAgICB2YXIgSSA9IG5ldyBBcnJheShNYXRoLm1heCh2LmJpdExlbmd0aCgpLCBBKSArIDEpLCBEO1xuICAgIGZvciAoRCA9IDA7IEQgPCBJLmxlbmd0aDsgRCArPSAxKVxuICAgICAgSVtEXSA9IDA7XG4gICAgdmFyIE4gPSAxIDw8IHcgKyAxLCBrID0gdi5jbG9uZSgpO1xuICAgIGZvciAoRCA9IDA7IEQgPCBJLmxlbmd0aDsgRCsrKSB7XG4gICAgICB2YXIgaiwgVCA9IGsuYW5kbG4oTiAtIDEpO1xuICAgICAgay5pc09kZCgpID8gKFQgPiAoTiA+PiAxKSAtIDEgPyBqID0gKE4gPj4gMSkgLSBUIDogaiA9IFQsIGsuaXN1Ym4oaikpIDogaiA9IDAsIElbRF0gPSBqLCBrLml1c2hybigxKTtcbiAgICB9XG4gICAgcmV0dXJuIEk7XG4gIH1cbiAgZS5nZXROQUYgPSBzO1xuICBmdW5jdGlvbiBvKHYsIHcpIHtcbiAgICB2YXIgQSA9IFtcbiAgICAgIFtdLFxuICAgICAgW11cbiAgICBdO1xuICAgIHYgPSB2LmNsb25lKCksIHcgPSB3LmNsb25lKCk7XG4gICAgZm9yICh2YXIgSSA9IDAsIEQgPSAwLCBOOyB2LmNtcG4oLUkpID4gMCB8fCB3LmNtcG4oLUQpID4gMDsgKSB7XG4gICAgICB2YXIgayA9IHYuYW5kbG4oMykgKyBJICYgMywgaiA9IHcuYW5kbG4oMykgKyBEICYgMztcbiAgICAgIGsgPT09IDMgJiYgKGsgPSAtMSksIGogPT09IDMgJiYgKGogPSAtMSk7XG4gICAgICB2YXIgVDtcbiAgICAgIGsgJiAxID8gKE4gPSB2LmFuZGxuKDcpICsgSSAmIDcsIChOID09PSAzIHx8IE4gPT09IDUpICYmIGogPT09IDIgPyBUID0gLWsgOiBUID0gaykgOiBUID0gMCwgQVswXS5wdXNoKFQpO1xuICAgICAgdmFyIEs7XG4gICAgICBqICYgMSA/IChOID0gdy5hbmRsbig3KSArIEQgJiA3LCAoTiA9PT0gMyB8fCBOID09PSA1KSAmJiBrID09PSAyID8gSyA9IC1qIDogSyA9IGopIDogSyA9IDAsIEFbMV0ucHVzaChLKSwgMiAqIEkgPT09IFQgKyAxICYmIChJID0gMSAtIEkpLCAyICogRCA9PT0gSyArIDEgJiYgKEQgPSAxIC0gRCksIHYuaXVzaHJuKDEpLCB3Lml1c2hybigxKTtcbiAgICB9XG4gICAgcmV0dXJuIEE7XG4gIH1cbiAgZS5nZXRKU0YgPSBvO1xuICBmdW5jdGlvbiBmKHYsIHcsIEEpIHtcbiAgICB2YXIgSSA9IFwiX1wiICsgdztcbiAgICB2LnByb3RvdHlwZVt3XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNbSV0gIT09IHZvaWQgMCA/IHRoaXNbSV0gOiB0aGlzW0ldID0gQS5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH1cbiAgZS5jYWNoZWRQcm9wZXJ0eSA9IGY7XG4gIGZ1bmN0aW9uIGgodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PSBcInN0cmluZ1wiID8gZS50b0FycmF5KHYsIFwiaGV4XCIpIDogdjtcbiAgfVxuICBlLnBhcnNlQnl0ZXMgPSBoO1xuICBmdW5jdGlvbiBkKHYpIHtcbiAgICByZXR1cm4gbmV3IHQodiwgXCJoZXhcIiwgXCJsZVwiKTtcbiAgfVxuICBlLmludEZyb21MRSA9IGQ7XG59KShhcik7XG52YXIgSm8gPSB7IGV4cG9ydHM6IHt9IH0sIEphO1xuSm8uZXhwb3J0cyA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIEphIHx8IChKYSA9IG5ldyB5aShudWxsKSksIEphLmdlbmVyYXRlKGUpO1xufTtcbmZ1bmN0aW9uIHlpKHIpIHtcbiAgdGhpcy5yYW5kID0gcjtcbn1cbkpvLmV4cG9ydHMuUmFuZCA9IHlpO1xueWkucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gdGhpcy5fcmFuZChlKTtcbn07XG55aS5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbihlKSB7XG4gIGlmICh0aGlzLnJhbmQuZ2V0Qnl0ZXMpXG4gICAgcmV0dXJuIHRoaXMucmFuZC5nZXRCeXRlcyhlKTtcbiAgZm9yICh2YXIgdCA9IG5ldyBVaW50OEFycmF5KGUpLCBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspXG4gICAgdFtpXSA9IHRoaXMucmFuZC5nZXRCeXRlKCk7XG4gIHJldHVybiB0O1xufTtcbmlmICh0eXBlb2Ygc2VsZiA9PSBcIm9iamVjdFwiKVxuICBzZWxmLmNyeXB0byAmJiBzZWxmLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPyB5aS5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHQgPSBuZXcgVWludDhBcnJheShlKTtcbiAgICByZXR1cm4gc2VsZi5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHQpLCB0O1xuICB9IDogc2VsZi5tc0NyeXB0byAmJiBzZWxmLm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA/IHlpLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdCA9IG5ldyBVaW50OEFycmF5KGUpO1xuICAgIHJldHVybiBzZWxmLm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyh0KSwgdDtcbiAgfSA6IHR5cGVvZiB3aW5kb3cgPT0gXCJvYmplY3RcIiAmJiAoeWkucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkIHlldFwiKTtcbiAgfSk7XG5lbHNlXG4gIHRyeSB7XG4gICAgdmFyIGdjID0gZmE7XG4gICAgaWYgKHR5cGVvZiBnYy5yYW5kb21CeXRlcyAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkXCIpO1xuICAgIHlpLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiBnYy5yYW5kb21CeXRlcyhlKTtcbiAgICB9O1xuICB9IGNhdGNoIHtcbiAgfVxudmFyIEh1ID0gSm8uZXhwb3J0cywgWW8gPSB7fSwgTmkgPSBsaSwgb3MgPSBhciwgSHMgPSBvcy5nZXROQUYsIHUyID0gb3MuZ2V0SlNGLCBWcyA9IG9zLmFzc2VydDtcbmZ1bmN0aW9uIElpKHIsIGUpIHtcbiAgdGhpcy50eXBlID0gciwgdGhpcy5wID0gbmV3IE5pKGUucCwgMTYpLCB0aGlzLnJlZCA9IGUucHJpbWUgPyBOaS5yZWQoZS5wcmltZSkgOiBOaS5tb250KHRoaXMucCksIHRoaXMuemVybyA9IG5ldyBOaSgwKS50b1JlZCh0aGlzLnJlZCksIHRoaXMub25lID0gbmV3IE5pKDEpLnRvUmVkKHRoaXMucmVkKSwgdGhpcy50d28gPSBuZXcgTmkoMikudG9SZWQodGhpcy5yZWQpLCB0aGlzLm4gPSBlLm4gJiYgbmV3IE5pKGUubiwgMTYpLCB0aGlzLmcgPSBlLmcgJiYgdGhpcy5wb2ludEZyb21KU09OKGUuZywgZS5nUmVkKSwgdGhpcy5fd25hZlQxID0gbmV3IEFycmF5KDQpLCB0aGlzLl93bmFmVDIgPSBuZXcgQXJyYXkoNCksIHRoaXMuX3duYWZUMyA9IG5ldyBBcnJheSg0KSwgdGhpcy5fd25hZlQ0ID0gbmV3IEFycmF5KDQpLCB0aGlzLl9iaXRMZW5ndGggPSB0aGlzLm4gPyB0aGlzLm4uYml0TGVuZ3RoKCkgOiAwO1xuICB2YXIgdCA9IHRoaXMubiAmJiB0aGlzLnAuZGl2KHRoaXMubik7XG4gICF0IHx8IHQuY21wbigxMDApID4gMCA/IHRoaXMucmVkTiA9IG51bGwgOiAodGhpcy5fbWF4d2VsbFRyaWNrID0gITAsIHRoaXMucmVkTiA9IHRoaXMubi50b1JlZCh0aGlzLnJlZCkpO1xufVxudmFyIGJhID0gSWk7XG5JaS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xufTtcbklpLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG59O1xuSWkucHJvdG90eXBlLl9maXhlZE5hZk11bCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgVnMoZS5wcmVjb21wdXRlZCk7XG4gIHZhciBpID0gZS5fZ2V0RG91YmxlcygpLCBuID0gSHModCwgMSwgdGhpcy5fYml0TGVuZ3RoKSwgcyA9ICgxIDw8IGkuc3RlcCArIDEpIC0gKGkuc3RlcCAlIDIgPT09IDAgPyAyIDogMSk7XG4gIHMgLz0gMztcbiAgdmFyIG8gPSBbXSwgZiwgaDtcbiAgZm9yIChmID0gMDsgZiA8IG4ubGVuZ3RoOyBmICs9IGkuc3RlcCkge1xuICAgIGggPSAwO1xuICAgIGZvciAodmFyIGQgPSBmICsgaS5zdGVwIC0gMTsgZCA+PSBmOyBkLS0pXG4gICAgICBoID0gKGggPDwgMSkgKyBuW2RdO1xuICAgIG8ucHVzaChoKTtcbiAgfVxuICBmb3IgKHZhciB2ID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCksIHcgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKSwgQSA9IHM7IEEgPiAwOyBBLS0pIHtcbiAgICBmb3IgKGYgPSAwOyBmIDwgby5sZW5ndGg7IGYrKylcbiAgICAgIGggPSBvW2ZdLCBoID09PSBBID8gdyA9IHcubWl4ZWRBZGQoaS5wb2ludHNbZl0pIDogaCA9PT0gLUEgJiYgKHcgPSB3Lm1peGVkQWRkKGkucG9pbnRzW2ZdLm5lZygpKSk7XG4gICAgdiA9IHYuYWRkKHcpO1xuICB9XG4gIHJldHVybiB2LnRvUCgpO1xufTtcbklpLnByb3RvdHlwZS5fd25hZk11bCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgdmFyIGkgPSA0LCBuID0gZS5fZ2V0TkFGUG9pbnRzKGkpO1xuICBpID0gbi53bmQ7XG4gIGZvciAodmFyIHMgPSBuLnBvaW50cywgbyA9IEhzKHQsIGksIHRoaXMuX2JpdExlbmd0aCksIGYgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKSwgaCA9IG8ubGVuZ3RoIC0gMTsgaCA+PSAwOyBoLS0pIHtcbiAgICBmb3IgKHZhciBkID0gMDsgaCA+PSAwICYmIG9baF0gPT09IDA7IGgtLSlcbiAgICAgIGQrKztcbiAgICBpZiAoaCA+PSAwICYmIGQrKywgZiA9IGYuZGJscChkKSwgaCA8IDApXG4gICAgICBicmVhaztcbiAgICB2YXIgdiA9IG9baF07XG4gICAgVnModiAhPT0gMCksIGUudHlwZSA9PT0gXCJhZmZpbmVcIiA/IHYgPiAwID8gZiA9IGYubWl4ZWRBZGQoc1t2IC0gMSA+PiAxXSkgOiBmID0gZi5taXhlZEFkZChzWy12IC0gMSA+PiAxXS5uZWcoKSkgOiB2ID4gMCA/IGYgPSBmLmFkZChzW3YgLSAxID4+IDFdKSA6IGYgPSBmLmFkZChzWy12IC0gMSA+PiAxXS5uZWcoKSk7XG4gIH1cbiAgcmV0dXJuIGUudHlwZSA9PT0gXCJhZmZpbmVcIiA/IGYudG9QKCkgOiBmO1xufTtcbklpLnByb3RvdHlwZS5fd25hZk11bEFkZCA9IGZ1bmN0aW9uKGUsIHQsIGksIG4sIHMpIHtcbiAgdmFyIG8gPSB0aGlzLl93bmFmVDEsIGYgPSB0aGlzLl93bmFmVDIsIGggPSB0aGlzLl93bmFmVDMsIGQgPSAwLCB2LCB3LCBBO1xuICBmb3IgKHYgPSAwOyB2IDwgbjsgdisrKSB7XG4gICAgQSA9IHRbdl07XG4gICAgdmFyIEkgPSBBLl9nZXROQUZQb2ludHMoZSk7XG4gICAgb1t2XSA9IEkud25kLCBmW3ZdID0gSS5wb2ludHM7XG4gIH1cbiAgZm9yICh2ID0gbiAtIDE7IHYgPj0gMTsgdiAtPSAyKSB7XG4gICAgdmFyIEQgPSB2IC0gMSwgTiA9IHY7XG4gICAgaWYgKG9bRF0gIT09IDEgfHwgb1tOXSAhPT0gMSkge1xuICAgICAgaFtEXSA9IEhzKGlbRF0sIG9bRF0sIHRoaXMuX2JpdExlbmd0aCksIGhbTl0gPSBIcyhpW05dLCBvW05dLCB0aGlzLl9iaXRMZW5ndGgpLCBkID0gTWF0aC5tYXgoaFtEXS5sZW5ndGgsIGQpLCBkID0gTWF0aC5tYXgoaFtOXS5sZW5ndGgsIGQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBrID0gW1xuICAgICAgdFtEXSxcbiAgICAgIC8qIDEgKi9cbiAgICAgIG51bGwsXG4gICAgICAvKiAzICovXG4gICAgICBudWxsLFxuICAgICAgLyogNSAqL1xuICAgICAgdFtOXVxuICAgICAgLyogNyAqL1xuICAgIF07XG4gICAgdFtEXS55LmNtcCh0W05dLnkpID09PSAwID8gKGtbMV0gPSB0W0RdLmFkZCh0W05dKSwga1syXSA9IHRbRF0udG9KKCkubWl4ZWRBZGQodFtOXS5uZWcoKSkpIDogdFtEXS55LmNtcCh0W05dLnkucmVkTmVnKCkpID09PSAwID8gKGtbMV0gPSB0W0RdLnRvSigpLm1peGVkQWRkKHRbTl0pLCBrWzJdID0gdFtEXS5hZGQodFtOXS5uZWcoKSkpIDogKGtbMV0gPSB0W0RdLnRvSigpLm1peGVkQWRkKHRbTl0pLCBrWzJdID0gdFtEXS50b0ooKS5taXhlZEFkZCh0W05dLm5lZygpKSk7XG4gICAgdmFyIGogPSBbXG4gICAgICAtMyxcbiAgICAgIC8qIC0xIC0xICovXG4gICAgICAtMSxcbiAgICAgIC8qIC0xIDAgKi9cbiAgICAgIC01LFxuICAgICAgLyogLTEgMSAqL1xuICAgICAgLTcsXG4gICAgICAvKiAwIC0xICovXG4gICAgICAwLFxuICAgICAgLyogMCAwICovXG4gICAgICA3LFxuICAgICAgLyogMCAxICovXG4gICAgICA1LFxuICAgICAgLyogMSAtMSAqL1xuICAgICAgMSxcbiAgICAgIC8qIDEgMCAqL1xuICAgICAgM1xuICAgICAgLyogMSAxICovXG4gICAgXSwgVCA9IHUyKGlbRF0sIGlbTl0pO1xuICAgIGZvciAoZCA9IE1hdGgubWF4KFRbMF0ubGVuZ3RoLCBkKSwgaFtEXSA9IG5ldyBBcnJheShkKSwgaFtOXSA9IG5ldyBBcnJheShkKSwgdyA9IDA7IHcgPCBkOyB3KyspIHtcbiAgICAgIHZhciBLID0gVFswXVt3XSB8IDAsICQgPSBUWzFdW3ddIHwgMDtcbiAgICAgIGhbRF1bd10gPSBqWyhLICsgMSkgKiAzICsgKCQgKyAxKV0sIGhbTl1bd10gPSAwLCBmW0RdID0gaztcbiAgICB9XG4gIH1cbiAgdmFyIHogPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKSwgQiA9IHRoaXMuX3duYWZUNDtcbiAgZm9yICh2ID0gZDsgdiA+PSAwOyB2LS0pIHtcbiAgICBmb3IgKHZhciBfID0gMDsgdiA+PSAwOyApIHtcbiAgICAgIHZhciBSID0gITA7XG4gICAgICBmb3IgKHcgPSAwOyB3IDwgbjsgdysrKVxuICAgICAgICBCW3ddID0gaFt3XVt2XSB8IDAsIEJbd10gIT09IDAgJiYgKFIgPSAhMSk7XG4gICAgICBpZiAoIVIpXG4gICAgICAgIGJyZWFrO1xuICAgICAgXysrLCB2LS07XG4gICAgfVxuICAgIGlmICh2ID49IDAgJiYgXysrLCB6ID0gei5kYmxwKF8pLCB2IDwgMClcbiAgICAgIGJyZWFrO1xuICAgIGZvciAodyA9IDA7IHcgPCBuOyB3KyspIHtcbiAgICAgIHZhciBKID0gQlt3XTtcbiAgICAgIEogIT09IDAgJiYgKEogPiAwID8gQSA9IGZbd11bSiAtIDEgPj4gMV0gOiBKIDwgMCAmJiAoQSA9IGZbd11bLUogLSAxID4+IDFdLm5lZygpKSwgQS50eXBlID09PSBcImFmZmluZVwiID8geiA9IHoubWl4ZWRBZGQoQSkgOiB6ID0gei5hZGQoQSkpO1xuICAgIH1cbiAgfVxuICBmb3IgKHYgPSAwOyB2IDwgbjsgdisrKVxuICAgIGZbdl0gPSBudWxsO1xuICByZXR1cm4gcyA/IHogOiB6LnRvUCgpO1xufTtcbmZ1bmN0aW9uIGdyKHIsIGUpIHtcbiAgdGhpcy5jdXJ2ZSA9IHIsIHRoaXMudHlwZSA9IGUsIHRoaXMucHJlY29tcHV0ZWQgPSBudWxsO1xufVxuSWkuQmFzZVBvaW50ID0gZ3I7XG5nci5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xufTtcbmdyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS52YWxpZGF0ZSh0aGlzKTtcbn07XG5JaS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbihlLCB0KSB7XG4gIGUgPSBvcy50b0FycmF5KGUsIHQpO1xuICB2YXIgaSA9IHRoaXMucC5ieXRlTGVuZ3RoKCk7XG4gIGlmICgoZVswXSA9PT0gNCB8fCBlWzBdID09PSA2IHx8IGVbMF0gPT09IDcpICYmIGUubGVuZ3RoIC0gMSA9PT0gMiAqIGkpIHtcbiAgICBlWzBdID09PSA2ID8gVnMoZVtlLmxlbmd0aCAtIDFdICUgMiA9PT0gMCkgOiBlWzBdID09PSA3ICYmIFZzKGVbZS5sZW5ndGggLSAxXSAlIDIgPT09IDEpO1xuICAgIHZhciBuID0gdGhpcy5wb2ludChcbiAgICAgIGUuc2xpY2UoMSwgMSArIGkpLFxuICAgICAgZS5zbGljZSgxICsgaSwgMSArIDIgKiBpKVxuICAgICk7XG4gICAgcmV0dXJuIG47XG4gIH0gZWxzZSBpZiAoKGVbMF0gPT09IDIgfHwgZVswXSA9PT0gMykgJiYgZS5sZW5ndGggLSAxID09PSBpKVxuICAgIHJldHVybiB0aGlzLnBvaW50RnJvbVgoZS5zbGljZSgxLCAxICsgaSksIGVbMF0gPT09IDMpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHBvaW50IGZvcm1hdFwiKTtcbn07XG5nci5wcm90b3R5cGUuZW5jb2RlQ29tcHJlc3NlZCA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIHRoaXMuZW5jb2RlKGUsICEwKTtcbn07XG5nci5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSB0aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpLCBpID0gdGhpcy5nZXRYKCkudG9BcnJheShcImJlXCIsIHQpO1xuICByZXR1cm4gZSA/IFt0aGlzLmdldFkoKS5pc0V2ZW4oKSA/IDIgOiAzXS5jb25jYXQoaSkgOiBbNF0uY29uY2F0KGksIHRoaXMuZ2V0WSgpLnRvQXJyYXkoXCJiZVwiLCB0KSk7XG59O1xuZ3IucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIG9zLmVuY29kZSh0aGlzLl9lbmNvZGUodCksIGUpO1xufTtcbmdyLnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24oZSkge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gdGhpcztcbiAgdmFyIHQgPSB7XG4gICAgZG91YmxlczogbnVsbCxcbiAgICBuYWY6IG51bGwsXG4gICAgYmV0YTogbnVsbFxuICB9O1xuICByZXR1cm4gdC5uYWYgPSB0aGlzLl9nZXROQUZQb2ludHMoOCksIHQuZG91YmxlcyA9IHRoaXMuX2dldERvdWJsZXMoNCwgZSksIHQuYmV0YSA9IHRoaXMuX2dldEJldGEoKSwgdGhpcy5wcmVjb21wdXRlZCA9IHQsIHRoaXM7XG59O1xuZ3IucHJvdG90eXBlLl9oYXNEb3VibGVzID0gZnVuY3Rpb24oZSkge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuICExO1xuICB2YXIgdCA9IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcbiAgcmV0dXJuIHQgPyB0LnBvaW50cy5sZW5ndGggPj0gTWF0aC5jZWlsKChlLmJpdExlbmd0aCgpICsgMSkgLyB0LnN0ZXApIDogITE7XG59O1xuZ3IucHJvdG90eXBlLl9nZXREb3VibGVzID0gZnVuY3Rpb24oZSwgdCkge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcbiAgZm9yICh2YXIgaSA9IFt0aGlzXSwgbiA9IHRoaXMsIHMgPSAwOyBzIDwgdDsgcyArPSBlKSB7XG4gICAgZm9yICh2YXIgbyA9IDA7IG8gPCBlOyBvKyspXG4gICAgICBuID0gbi5kYmwoKTtcbiAgICBpLnB1c2gobik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGVwOiBlLFxuICAgIHBvaW50czogaVxuICB9O1xufTtcbmdyLnByb3RvdHlwZS5fZ2V0TkFGUG9pbnRzID0gZnVuY3Rpb24oZSkge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLm5hZilcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7XG4gIGZvciAodmFyIHQgPSBbdGhpc10sIGkgPSAoMSA8PCBlKSAtIDEsIG4gPSBpID09PSAxID8gbnVsbCA6IHRoaXMuZGJsKCksIHMgPSAxOyBzIDwgaTsgcysrKVxuICAgIHRbc10gPSB0W3MgLSAxXS5hZGQobik7XG4gIHJldHVybiB7XG4gICAgd25kOiBlLFxuICAgIHBvaW50czogdFxuICB9O1xufTtcbmdyLnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5nci5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uKGUpIHtcbiAgZm9yICh2YXIgdCA9IHRoaXMsIGkgPSAwOyBpIDwgZTsgaSsrKVxuICAgIHQgPSB0LmRibCgpO1xuICByZXR1cm4gdDtcbn07XG52YXIgZDIgPSBhciwgcHQgPSBsaSwgWG8gPSB1YSwgRW4gPSBiYSwgbDIgPSBkMi5hc3NlcnQ7XG5mdW5jdGlvbiB5cihyKSB7XG4gIEVuLmNhbGwodGhpcywgXCJzaG9ydFwiLCByKSwgdGhpcy5hID0gbmV3IHB0KHIuYSwgMTYpLnRvUmVkKHRoaXMucmVkKSwgdGhpcy5iID0gbmV3IHB0KHIuYiwgMTYpLnRvUmVkKHRoaXMucmVkKSwgdGhpcy50aW52ID0gdGhpcy50d28ucmVkSW52bSgpLCB0aGlzLnplcm9BID0gdGhpcy5hLmZyb21SZWQoKS5jbXBuKDApID09PSAwLCB0aGlzLnRocmVlQSA9IHRoaXMuYS5mcm9tUmVkKCkuc3ViKHRoaXMucCkuY21wbigtMykgPT09IDAsIHRoaXMuZW5kbyA9IHRoaXMuX2dldEVuZG9tb3JwaGlzbShyKSwgdGhpcy5fZW5kb1duYWZUMSA9IG5ldyBBcnJheSg0KSwgdGhpcy5fZW5kb1duYWZUMiA9IG5ldyBBcnJheSg0KTtcbn1cblhvKHlyLCBFbik7XG52YXIgcDIgPSB5cjtcbnlyLnByb3RvdHlwZS5fZ2V0RW5kb21vcnBoaXNtID0gZnVuY3Rpb24oZSkge1xuICBpZiAoISghdGhpcy56ZXJvQSB8fCAhdGhpcy5nIHx8ICF0aGlzLm4gfHwgdGhpcy5wLm1vZG4oMykgIT09IDEpKSB7XG4gICAgdmFyIHQsIGk7XG4gICAgaWYgKGUuYmV0YSlcbiAgICAgIHQgPSBuZXcgcHQoZS5iZXRhLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIG4gPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5wKTtcbiAgICAgIHQgPSBuWzBdLmNtcChuWzFdKSA8IDAgPyBuWzBdIDogblsxXSwgdCA9IHQudG9SZWQodGhpcy5yZWQpO1xuICAgIH1cbiAgICBpZiAoZS5sYW1iZGEpXG4gICAgICBpID0gbmV3IHB0KGUubGFtYmRhLCAxNik7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLm4pO1xuICAgICAgdGhpcy5nLm11bChzWzBdKS54LmNtcCh0aGlzLmcueC5yZWRNdWwodCkpID09PSAwID8gaSA9IHNbMF0gOiAoaSA9IHNbMV0sIGwyKHRoaXMuZy5tdWwoaSkueC5jbXAodGhpcy5nLngucmVkTXVsKHQpKSA9PT0gMCkpO1xuICAgIH1cbiAgICB2YXIgbztcbiAgICByZXR1cm4gZS5iYXNpcyA/IG8gPSBlLmJhc2lzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhOiBuZXcgcHQoZi5hLCAxNiksXG4gICAgICAgIGI6IG5ldyBwdChmLmIsIDE2KVxuICAgICAgfTtcbiAgICB9KSA6IG8gPSB0aGlzLl9nZXRFbmRvQmFzaXMoaSksIHtcbiAgICAgIGJldGE6IHQsXG4gICAgICBsYW1iZGE6IGksXG4gICAgICBiYXNpczogb1xuICAgIH07XG4gIH1cbn07XG55ci5wcm90b3R5cGUuX2dldEVuZG9Sb290cyA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSBlID09PSB0aGlzLnAgPyB0aGlzLnJlZCA6IHB0Lm1vbnQoZSksIGkgPSBuZXcgcHQoMikudG9SZWQodCkucmVkSW52bSgpLCBuID0gaS5yZWROZWcoKSwgcyA9IG5ldyBwdCgzKS50b1JlZCh0KS5yZWROZWcoKS5yZWRTcXJ0KCkucmVkTXVsKGkpLCBvID0gbi5yZWRBZGQocykuZnJvbVJlZCgpLCBmID0gbi5yZWRTdWIocykuZnJvbVJlZCgpO1xuICByZXR1cm4gW28sIGZdO1xufTtcbnlyLnByb3RvdHlwZS5fZ2V0RW5kb0Jhc2lzID0gZnVuY3Rpb24oZSkge1xuICBmb3IgKHZhciB0ID0gdGhpcy5uLnVzaHJuKE1hdGguZmxvb3IodGhpcy5uLmJpdExlbmd0aCgpIC8gMikpLCBpID0gZSwgbiA9IHRoaXMubi5jbG9uZSgpLCBzID0gbmV3IHB0KDEpLCBvID0gbmV3IHB0KDApLCBmID0gbmV3IHB0KDApLCBoID0gbmV3IHB0KDEpLCBkLCB2LCB3LCBBLCBJLCBELCBOLCBrID0gMCwgaiwgVDsgaS5jbXBuKDApICE9PSAwOyApIHtcbiAgICB2YXIgSyA9IG4uZGl2KGkpO1xuICAgIGogPSBuLnN1YihLLm11bChpKSksIFQgPSBmLnN1YihLLm11bChzKSk7XG4gICAgdmFyICQgPSBoLnN1YihLLm11bChvKSk7XG4gICAgaWYgKCF3ICYmIGouY21wKHQpIDwgMClcbiAgICAgIGQgPSBOLm5lZygpLCB2ID0gcywgdyA9IGoubmVnKCksIEEgPSBUO1xuICAgIGVsc2UgaWYgKHcgJiYgKytrID09PSAyKVxuICAgICAgYnJlYWs7XG4gICAgTiA9IGosIG4gPSBpLCBpID0gaiwgZiA9IHMsIHMgPSBULCBoID0gbywgbyA9ICQ7XG4gIH1cbiAgSSA9IGoubmVnKCksIEQgPSBUO1xuICB2YXIgeiA9IHcuc3FyKCkuYWRkKEEuc3FyKCkpLCBCID0gSS5zcXIoKS5hZGQoRC5zcXIoKSk7XG4gIHJldHVybiBCLmNtcCh6KSA+PSAwICYmIChJID0gZCwgRCA9IHYpLCB3Lm5lZ2F0aXZlICYmICh3ID0gdy5uZWcoKSwgQSA9IEEubmVnKCkpLCBJLm5lZ2F0aXZlICYmIChJID0gSS5uZWcoKSwgRCA9IEQubmVnKCkpLCBbXG4gICAgeyBhOiB3LCBiOiBBIH0sXG4gICAgeyBhOiBJLCBiOiBEIH1cbiAgXTtcbn07XG55ci5wcm90b3R5cGUuX2VuZG9TcGxpdCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSB0aGlzLmVuZG8uYmFzaXMsIGkgPSB0WzBdLCBuID0gdFsxXSwgcyA9IG4uYi5tdWwoZSkuZGl2Um91bmQodGhpcy5uKSwgbyA9IGkuYi5uZWcoKS5tdWwoZSkuZGl2Um91bmQodGhpcy5uKSwgZiA9IHMubXVsKGkuYSksIGggPSBvLm11bChuLmEpLCBkID0gcy5tdWwoaS5iKSwgdiA9IG8ubXVsKG4uYiksIHcgPSBlLnN1YihmKS5zdWIoaCksIEEgPSBkLmFkZCh2KS5uZWcoKTtcbiAgcmV0dXJuIHsgazE6IHcsIGsyOiBBIH07XG59O1xueXIucHJvdG90eXBlLnBvaW50RnJvbVggPSBmdW5jdGlvbihlLCB0KSB7XG4gIGUgPSBuZXcgcHQoZSwgMTYpLCBlLnJlZCB8fCAoZSA9IGUudG9SZWQodGhpcy5yZWQpKTtcbiAgdmFyIGkgPSBlLnJlZFNxcigpLnJlZE11bChlKS5yZWRJQWRkKGUucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKSwgbiA9IGkucmVkU3FydCgpO1xuICBpZiAobi5yZWRTcXIoKS5yZWRTdWIoaSkuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludFwiKTtcbiAgdmFyIHMgPSBuLmZyb21SZWQoKS5pc09kZCgpO1xuICByZXR1cm4gKHQgJiYgIXMgfHwgIXQgJiYgcykgJiYgKG4gPSBuLnJlZE5lZygpKSwgdGhpcy5wb2ludChlLCBuKTtcbn07XG55ci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbihlKSB7XG4gIGlmIChlLmluZilcbiAgICByZXR1cm4gITA7XG4gIHZhciB0ID0gZS54LCBpID0gZS55LCBuID0gdGhpcy5hLnJlZE11bCh0KSwgcyA9IHQucmVkU3FyKCkucmVkTXVsKHQpLnJlZElBZGQobikucmVkSUFkZCh0aGlzLmIpO1xuICByZXR1cm4gaS5yZWRTcXIoKS5yZWRJU3ViKHMpLmNtcG4oMCkgPT09IDA7XG59O1xueXIucHJvdG90eXBlLl9lbmRvV25hZk11bEFkZCA9IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgZm9yICh2YXIgbiA9IHRoaXMuX2VuZG9XbmFmVDEsIHMgPSB0aGlzLl9lbmRvV25hZlQyLCBvID0gMDsgbyA8IGUubGVuZ3RoOyBvKyspIHtcbiAgICB2YXIgZiA9IHRoaXMuX2VuZG9TcGxpdCh0W29dKSwgaCA9IGVbb10sIGQgPSBoLl9nZXRCZXRhKCk7XG4gICAgZi5rMS5uZWdhdGl2ZSAmJiAoZi5rMS5pbmVnKCksIGggPSBoLm5lZyghMCkpLCBmLmsyLm5lZ2F0aXZlICYmIChmLmsyLmluZWcoKSwgZCA9IGQubmVnKCEwKSksIG5bbyAqIDJdID0gaCwgbltvICogMiArIDFdID0gZCwgc1tvICogMl0gPSBmLmsxLCBzW28gKiAyICsgMV0gPSBmLmsyO1xuICB9XG4gIGZvciAodmFyIHYgPSB0aGlzLl93bmFmTXVsQWRkKDEsIG4sIHMsIG8gKiAyLCBpKSwgdyA9IDA7IHcgPCBvICogMjsgdysrKVxuICAgIG5bd10gPSBudWxsLCBzW3ddID0gbnVsbDtcbiAgcmV0dXJuIHY7XG59O1xuZnVuY3Rpb24gUHQociwgZSwgdCwgaSkge1xuICBFbi5CYXNlUG9pbnQuY2FsbCh0aGlzLCByLCBcImFmZmluZVwiKSwgZSA9PT0gbnVsbCAmJiB0ID09PSBudWxsID8gKHRoaXMueCA9IG51bGwsIHRoaXMueSA9IG51bGwsIHRoaXMuaW5mID0gITApIDogKHRoaXMueCA9IG5ldyBwdChlLCAxNiksIHRoaXMueSA9IG5ldyBwdCh0LCAxNiksIGkgJiYgKHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCksIHRoaXMueS5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCkpLCB0aGlzLngucmVkIHx8ICh0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpKSwgdGhpcy55LnJlZCB8fCAodGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKSksIHRoaXMuaW5mID0gITEpO1xufVxuWG8oUHQsIEVuLkJhc2VQb2ludCk7XG55ci5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gIHJldHVybiBuZXcgUHQodGhpcywgZSwgdCwgaSk7XG59O1xueXIucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBQdC5mcm9tSlNPTih0aGlzLCBlLCB0KTtcbn07XG5QdC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY3VydmUuZW5kbykge1xuICAgIHZhciBlID0gdGhpcy5wcmVjb21wdXRlZDtcbiAgICBpZiAoZSAmJiBlLmJldGEpXG4gICAgICByZXR1cm4gZS5iZXRhO1xuICAgIHZhciB0ID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTXVsKHRoaXMuY3VydmUuZW5kby5iZXRhKSwgdGhpcy55KTtcbiAgICBpZiAoZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLmN1cnZlLCBuID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gaS5wb2ludChzLngucmVkTXVsKGkuZW5kby5iZXRhKSwgcy55KTtcbiAgICAgIH07XG4gICAgICBlLmJldGEgPSB0LCB0LnByZWNvbXB1dGVkID0ge1xuICAgICAgICBiZXRhOiBudWxsLFxuICAgICAgICBuYWY6IGUubmFmICYmIHtcbiAgICAgICAgICB3bmQ6IGUubmFmLnduZCxcbiAgICAgICAgICBwb2ludHM6IGUubmFmLnBvaW50cy5tYXAobilcbiAgICAgICAgfSxcbiAgICAgICAgZG91YmxlczogZS5kb3VibGVzICYmIHtcbiAgICAgICAgICBzdGVwOiBlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgICBwb2ludHM6IGUuZG91Ymxlcy5wb2ludHMubWFwKG4pXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG59O1xuUHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZCA/IFt0aGlzLngsIHRoaXMueSwgdGhpcy5wcmVjb21wdXRlZCAmJiB7XG4gICAgZG91YmxlczogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMucG9pbnRzLnNsaWNlKDEpXG4gICAgfSxcbiAgICBuYWY6IHRoaXMucHJlY29tcHV0ZWQubmFmICYmIHtcbiAgICAgIHduZDogdGhpcy5wcmVjb21wdXRlZC5uYWYud25kLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLm5hZi5wb2ludHMuc2xpY2UoMSlcbiAgICB9XG4gIH1dIDogW3RoaXMueCwgdGhpcy55XTtcbn07XG5QdC5mcm9tSlNPTiA9IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAodCA9IEpTT04ucGFyc2UodCkpO1xuICB2YXIgbiA9IGUucG9pbnQodFswXSwgdFsxXSwgaSk7XG4gIGlmICghdFsyXSlcbiAgICByZXR1cm4gbjtcbiAgZnVuY3Rpb24gcyhmKSB7XG4gICAgcmV0dXJuIGUucG9pbnQoZlswXSwgZlsxXSwgaSk7XG4gIH1cbiAgdmFyIG8gPSB0WzJdO1xuICByZXR1cm4gbi5wcmVjb21wdXRlZCA9IHtcbiAgICBiZXRhOiBudWxsLFxuICAgIGRvdWJsZXM6IG8uZG91YmxlcyAmJiB7XG4gICAgICBzdGVwOiBvLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogW25dLmNvbmNhdChvLmRvdWJsZXMucG9pbnRzLm1hcChzKSlcbiAgICB9LFxuICAgIG5hZjogby5uYWYgJiYge1xuICAgICAgd25kOiBvLm5hZi53bmQsXG4gICAgICBwb2ludHM6IFtuXS5jb25jYXQoby5uYWYucG9pbnRzLm1hcChzKSlcbiAgICB9XG4gIH0sIG47XG59O1xuUHQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXNJbmZpbml0eSgpID8gXCI8RUMgUG9pbnQgSW5maW5pdHk+XCIgOiBcIjxFQyBQb2ludCB4OiBcIiArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgXCIgeTogXCIgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArIFwiPlwiO1xufTtcblB0LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmluZjtcbn07XG5QdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZSkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIGU7XG4gIGlmIChlLmluZilcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKHRoaXMuZXEoZSkpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIGlmICh0aGlzLm5lZygpLmVxKGUpKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuICBpZiAodGhpcy54LmNtcChlLngpID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuICB2YXIgdCA9IHRoaXMueS5yZWRTdWIoZS55KTtcbiAgdC5jbXBuKDApICE9PSAwICYmICh0ID0gdC5yZWRNdWwodGhpcy54LnJlZFN1YihlLngpLnJlZEludm0oKSkpO1xuICB2YXIgaSA9IHQucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIoZS54KSwgbiA9IHQucmVkTXVsKHRoaXMueC5yZWRTdWIoaSkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoaSwgbik7XG59O1xuUHQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG4gIHZhciBlID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICBpZiAoZS5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuICB2YXIgdCA9IHRoaXMuY3VydmUuYSwgaSA9IHRoaXMueC5yZWRTcXIoKSwgbiA9IGUucmVkSW52bSgpLCBzID0gaS5yZWRBZGQoaSkucmVkSUFkZChpKS5yZWRJQWRkKHQpLnJlZE11bChuKSwgbyA9IHMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngucmVkQWRkKHRoaXMueCkpLCBmID0gcy5yZWRNdWwodGhpcy54LnJlZFN1YihvKSkucmVkSVN1Yih0aGlzLnkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChvLCBmKTtcbn07XG5QdC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG5QdC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcbn07XG5QdC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZSA9IG5ldyBwdChlLCAxNiksIHRoaXMuaXNJbmZpbml0eSgpID8gdGhpcyA6IHRoaXMuX2hhc0RvdWJsZXMoZSkgPyB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBlKSA6IHRoaXMuY3VydmUuZW5kbyA/IHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKFt0aGlzXSwgW2VdKSA6IHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgZSk7XG59O1xuUHQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgdmFyIG4gPSBbdGhpcywgdF0sIHMgPSBbZSwgaV07XG4gIHJldHVybiB0aGlzLmN1cnZlLmVuZG8gPyB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChuLCBzKSA6IHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgbiwgcywgMik7XG59O1xuUHQucHJvdG90eXBlLmptdWxBZGQgPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gIHZhciBuID0gW3RoaXMsIHRdLCBzID0gW2UsIGldO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5lbmRvID8gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQobiwgcywgITApIDogdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBuLCBzLCAyLCAhMCk7XG59O1xuUHQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gdGhpcyA9PT0gZSB8fCB0aGlzLmluZiA9PT0gZS5pbmYgJiYgKHRoaXMuaW5mIHx8IHRoaXMueC5jbXAoZS54KSA9PT0gMCAmJiB0aGlzLnkuY21wKGUueSkgPT09IDApO1xufTtcblB0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbihlKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcbiAgdmFyIHQgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpKTtcbiAgaWYgKGUgJiYgdGhpcy5wcmVjb21wdXRlZCkge1xuICAgIHZhciBpID0gdGhpcy5wcmVjb21wdXRlZCwgbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBzLm5lZygpO1xuICAgIH07XG4gICAgdC5wcmVjb21wdXRlZCA9IHtcbiAgICAgIG5hZjogaS5uYWYgJiYge1xuICAgICAgICB3bmQ6IGkubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBpLm5hZi5wb2ludHMubWFwKG4pXG4gICAgICB9LFxuICAgICAgZG91YmxlczogaS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogaS5kb3VibGVzLnN0ZXAsXG4gICAgICAgIHBvaW50czogaS5kb3VibGVzLnBvaW50cy5tYXAobilcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB0O1xufTtcblB0LnByb3RvdHlwZS50b0ogPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIGUgPSB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueSwgdGhpcy5jdXJ2ZS5vbmUpO1xuICByZXR1cm4gZTtcbn07XG5mdW5jdGlvbiBUdChyLCBlLCB0LCBpKSB7XG4gIEVuLkJhc2VQb2ludC5jYWxsKHRoaXMsIHIsIFwiamFjb2JpYW5cIiksIGUgPT09IG51bGwgJiYgdCA9PT0gbnVsbCAmJiBpID09PSBudWxsID8gKHRoaXMueCA9IHRoaXMuY3VydmUub25lLCB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZSwgdGhpcy56ID0gbmV3IHB0KDApKSA6ICh0aGlzLnggPSBuZXcgcHQoZSwgMTYpLCB0aGlzLnkgPSBuZXcgcHQodCwgMTYpLCB0aGlzLnogPSBuZXcgcHQoaSwgMTYpKSwgdGhpcy54LnJlZCB8fCAodGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKSksIHRoaXMueS5yZWQgfHwgKHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCkpLCB0aGlzLnoucmVkIHx8ICh0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpKSwgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcbn1cblhvKFR0LCBFbi5CYXNlUG9pbnQpO1xueXIucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgcmV0dXJuIG5ldyBUdCh0aGlzLCBlLCB0LCBpKTtcbn07XG5UdC5wcm90b3R5cGUudG9QID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcbiAgdmFyIGUgPSB0aGlzLnoucmVkSW52bSgpLCB0ID0gZS5yZWRTcXIoKSwgaSA9IHRoaXMueC5yZWRNdWwodCksIG4gPSB0aGlzLnkucmVkTXVsKHQpLnJlZE11bChlKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoaSwgbik7XG59O1xuVHQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCksIHRoaXMueik7XG59O1xuVHQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBlO1xuICBpZiAoZS5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIHZhciB0ID0gZS56LnJlZFNxcigpLCBpID0gdGhpcy56LnJlZFNxcigpLCBuID0gdGhpcy54LnJlZE11bCh0KSwgcyA9IGUueC5yZWRNdWwoaSksIG8gPSB0aGlzLnkucmVkTXVsKHQucmVkTXVsKGUueikpLCBmID0gZS55LnJlZE11bChpLnJlZE11bCh0aGlzLnopKSwgaCA9IG4ucmVkU3ViKHMpLCBkID0gby5yZWRTdWIoZik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIGQuY21wbigwKSAhPT0gMCA/IHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpIDogdGhpcy5kYmwoKTtcbiAgdmFyIHYgPSBoLnJlZFNxcigpLCB3ID0gdi5yZWRNdWwoaCksIEEgPSBuLnJlZE11bCh2KSwgSSA9IGQucmVkU3FyKCkucmVkSUFkZCh3KS5yZWRJU3ViKEEpLnJlZElTdWIoQSksIEQgPSBkLnJlZE11bChBLnJlZElTdWIoSSkpLnJlZElTdWIoby5yZWRNdWwodykpLCBOID0gdGhpcy56LnJlZE11bChlLnopLnJlZE11bChoKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KEksIEQsIE4pO1xufTtcblR0LnByb3RvdHlwZS5taXhlZEFkZCA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBlLnRvSigpO1xuICBpZiAoZS5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIHZhciB0ID0gdGhpcy56LnJlZFNxcigpLCBpID0gdGhpcy54LCBuID0gZS54LnJlZE11bCh0KSwgcyA9IHRoaXMueSwgbyA9IGUueS5yZWRNdWwodCkucmVkTXVsKHRoaXMueiksIGYgPSBpLnJlZFN1YihuKSwgaCA9IHMucmVkU3ViKG8pO1xuICBpZiAoZi5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiBoLmNtcG4oMCkgIT09IDAgPyB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKSA6IHRoaXMuZGJsKCk7XG4gIHZhciBkID0gZi5yZWRTcXIoKSwgdiA9IGQucmVkTXVsKGYpLCB3ID0gaS5yZWRNdWwoZCksIEEgPSBoLnJlZFNxcigpLnJlZElBZGQodikucmVkSVN1Yih3KS5yZWRJU3ViKHcpLCBJID0gaC5yZWRNdWwody5yZWRJU3ViKEEpKS5yZWRJU3ViKHMucmVkTXVsKHYpKSwgRCA9IHRoaXMuei5yZWRNdWwoZik7XG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChBLCBJLCBEKTtcbn07XG5UdC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKGUgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKCFlKVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB2YXIgdDtcbiAgaWYgKHRoaXMuY3VydmUuemVyb0EgfHwgdGhpcy5jdXJ2ZS50aHJlZUEpIHtcbiAgICB2YXIgaSA9IHRoaXM7XG4gICAgZm9yICh0ID0gMDsgdCA8IGU7IHQrKylcbiAgICAgIGkgPSBpLmRibCgpO1xuICAgIHJldHVybiBpO1xuICB9XG4gIHZhciBuID0gdGhpcy5jdXJ2ZS5hLCBzID0gdGhpcy5jdXJ2ZS50aW52LCBvID0gdGhpcy54LCBmID0gdGhpcy55LCBoID0gdGhpcy56LCBkID0gaC5yZWRTcXIoKS5yZWRTcXIoKSwgdiA9IGYucmVkQWRkKGYpO1xuICBmb3IgKHQgPSAwOyB0IDwgZTsgdCsrKSB7XG4gICAgdmFyIHcgPSBvLnJlZFNxcigpLCBBID0gdi5yZWRTcXIoKSwgSSA9IEEucmVkU3FyKCksIEQgPSB3LnJlZEFkZCh3KS5yZWRJQWRkKHcpLnJlZElBZGQobi5yZWRNdWwoZCkpLCBOID0gby5yZWRNdWwoQSksIGsgPSBELnJlZFNxcigpLnJlZElTdWIoTi5yZWRBZGQoTikpLCBqID0gTi5yZWRJU3ViKGspLCBUID0gRC5yZWRNdWwoaik7XG4gICAgVCA9IFQucmVkSUFkZChUKS5yZWRJU3ViKEkpO1xuICAgIHZhciBLID0gdi5yZWRNdWwoaCk7XG4gICAgdCArIDEgPCBlICYmIChkID0gZC5yZWRNdWwoSSkpLCBvID0gaywgaCA9IEssIHYgPSBUO1xuICB9XG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChvLCB2LnJlZE11bChzKSwgaCk7XG59O1xuVHQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pc0luZmluaXR5KCkgPyB0aGlzIDogdGhpcy5jdXJ2ZS56ZXJvQSA/IHRoaXMuX3plcm9EYmwoKSA6IHRoaXMuY3VydmUudGhyZWVBID8gdGhpcy5fdGhyZWVEYmwoKSA6IHRoaXMuX2RibCgpO1xufTtcblR0LnByb3RvdHlwZS5femVyb0RibCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZSwgdCwgaTtcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIHZhciBuID0gdGhpcy54LnJlZFNxcigpLCBzID0gdGhpcy55LnJlZFNxcigpLCBvID0gcy5yZWRTcXIoKSwgZiA9IHRoaXMueC5yZWRBZGQocykucmVkU3FyKCkucmVkSVN1YihuKS5yZWRJU3ViKG8pO1xuICAgIGYgPSBmLnJlZElBZGQoZik7XG4gICAgdmFyIGggPSBuLnJlZEFkZChuKS5yZWRJQWRkKG4pLCBkID0gaC5yZWRTcXIoKS5yZWRJU3ViKGYpLnJlZElTdWIoZiksIHYgPSBvLnJlZElBZGQobyk7XG4gICAgdiA9IHYucmVkSUFkZCh2KSwgdiA9IHYucmVkSUFkZCh2KSwgZSA9IGQsIHQgPSBoLnJlZE11bChmLnJlZElTdWIoZCkpLnJlZElTdWIodiksIGkgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHcgPSB0aGlzLngucmVkU3FyKCksIEEgPSB0aGlzLnkucmVkU3FyKCksIEkgPSBBLnJlZFNxcigpLCBEID0gdGhpcy54LnJlZEFkZChBKS5yZWRTcXIoKS5yZWRJU3ViKHcpLnJlZElTdWIoSSk7XG4gICAgRCA9IEQucmVkSUFkZChEKTtcbiAgICB2YXIgTiA9IHcucmVkQWRkKHcpLnJlZElBZGQodyksIGsgPSBOLnJlZFNxcigpLCBqID0gSS5yZWRJQWRkKEkpO1xuICAgIGogPSBqLnJlZElBZGQoaiksIGogPSBqLnJlZElBZGQoaiksIGUgPSBrLnJlZElTdWIoRCkucmVkSVN1YihEKSwgdCA9IE4ucmVkTXVsKEQucmVkSVN1YihlKSkucmVkSVN1YihqKSwgaSA9IHRoaXMueS5yZWRNdWwodGhpcy56KSwgaSA9IGkucmVkSUFkZChpKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoZSwgdCwgaSk7XG59O1xuVHQucHJvdG90eXBlLl90aHJlZURibCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZSwgdCwgaTtcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIHZhciBuID0gdGhpcy54LnJlZFNxcigpLCBzID0gdGhpcy55LnJlZFNxcigpLCBvID0gcy5yZWRTcXIoKSwgZiA9IHRoaXMueC5yZWRBZGQocykucmVkU3FyKCkucmVkSVN1YihuKS5yZWRJU3ViKG8pO1xuICAgIGYgPSBmLnJlZElBZGQoZik7XG4gICAgdmFyIGggPSBuLnJlZEFkZChuKS5yZWRJQWRkKG4pLnJlZElBZGQodGhpcy5jdXJ2ZS5hKSwgZCA9IGgucmVkU3FyKCkucmVkSVN1YihmKS5yZWRJU3ViKGYpO1xuICAgIGUgPSBkO1xuICAgIHZhciB2ID0gby5yZWRJQWRkKG8pO1xuICAgIHYgPSB2LnJlZElBZGQodiksIHYgPSB2LnJlZElBZGQodiksIHQgPSBoLnJlZE11bChmLnJlZElTdWIoZCkpLnJlZElTdWIodiksIGkgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHcgPSB0aGlzLnoucmVkU3FyKCksIEEgPSB0aGlzLnkucmVkU3FyKCksIEkgPSB0aGlzLngucmVkTXVsKEEpLCBEID0gdGhpcy54LnJlZFN1Yih3KS5yZWRNdWwodGhpcy54LnJlZEFkZCh3KSk7XG4gICAgRCA9IEQucmVkQWRkKEQpLnJlZElBZGQoRCk7XG4gICAgdmFyIE4gPSBJLnJlZElBZGQoSSk7XG4gICAgTiA9IE4ucmVkSUFkZChOKTtcbiAgICB2YXIgayA9IE4ucmVkQWRkKE4pO1xuICAgIGUgPSBELnJlZFNxcigpLnJlZElTdWIoayksIGkgPSB0aGlzLnkucmVkQWRkKHRoaXMueikucmVkU3FyKCkucmVkSVN1YihBKS5yZWRJU3ViKHcpO1xuICAgIHZhciBqID0gQS5yZWRTcXIoKTtcbiAgICBqID0gai5yZWRJQWRkKGopLCBqID0gai5yZWRJQWRkKGopLCBqID0gai5yZWRJQWRkKGopLCB0ID0gRC5yZWRNdWwoTi5yZWRJU3ViKGUpKS5yZWRJU3ViKGopO1xuICB9XG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChlLCB0LCBpKTtcbn07XG5UdC5wcm90b3R5cGUuX2RibCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZSA9IHRoaXMuY3VydmUuYSwgdCA9IHRoaXMueCwgaSA9IHRoaXMueSwgbiA9IHRoaXMueiwgcyA9IG4ucmVkU3FyKCkucmVkU3FyKCksIG8gPSB0LnJlZFNxcigpLCBmID0gaS5yZWRTcXIoKSwgaCA9IG8ucmVkQWRkKG8pLnJlZElBZGQobykucmVkSUFkZChlLnJlZE11bChzKSksIGQgPSB0LnJlZEFkZCh0KTtcbiAgZCA9IGQucmVkSUFkZChkKTtcbiAgdmFyIHYgPSBkLnJlZE11bChmKSwgdyA9IGgucmVkU3FyKCkucmVkSVN1Yih2LnJlZEFkZCh2KSksIEEgPSB2LnJlZElTdWIodyksIEkgPSBmLnJlZFNxcigpO1xuICBJID0gSS5yZWRJQWRkKEkpLCBJID0gSS5yZWRJQWRkKEkpLCBJID0gSS5yZWRJQWRkKEkpO1xuICB2YXIgRCA9IGgucmVkTXVsKEEpLnJlZElTdWIoSSksIE4gPSBpLnJlZEFkZChpKS5yZWRNdWwobik7XG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludCh3LCBELCBOKTtcbn07XG5UdC5wcm90b3R5cGUudHJwbCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCkuYWRkKHRoaXMpO1xuICB2YXIgZSA9IHRoaXMueC5yZWRTcXIoKSwgdCA9IHRoaXMueS5yZWRTcXIoKSwgaSA9IHRoaXMuei5yZWRTcXIoKSwgbiA9IHQucmVkU3FyKCksIHMgPSBlLnJlZEFkZChlKS5yZWRJQWRkKGUpLCBvID0gcy5yZWRTcXIoKSwgZiA9IHRoaXMueC5yZWRBZGQodCkucmVkU3FyKCkucmVkSVN1YihlKS5yZWRJU3ViKG4pO1xuICBmID0gZi5yZWRJQWRkKGYpLCBmID0gZi5yZWRBZGQoZikucmVkSUFkZChmKSwgZiA9IGYucmVkSVN1YihvKTtcbiAgdmFyIGggPSBmLnJlZFNxcigpLCBkID0gbi5yZWRJQWRkKG4pO1xuICBkID0gZC5yZWRJQWRkKGQpLCBkID0gZC5yZWRJQWRkKGQpLCBkID0gZC5yZWRJQWRkKGQpO1xuICB2YXIgdiA9IHMucmVkSUFkZChmKS5yZWRTcXIoKS5yZWRJU3ViKG8pLnJlZElTdWIoaCkucmVkSVN1YihkKSwgdyA9IHQucmVkTXVsKHYpO1xuICB3ID0gdy5yZWRJQWRkKHcpLCB3ID0gdy5yZWRJQWRkKHcpO1xuICB2YXIgQSA9IHRoaXMueC5yZWRNdWwoaCkucmVkSVN1Yih3KTtcbiAgQSA9IEEucmVkSUFkZChBKSwgQSA9IEEucmVkSUFkZChBKTtcbiAgdmFyIEkgPSB0aGlzLnkucmVkTXVsKHYucmVkTXVsKGQucmVkSVN1Yih2KSkucmVkSVN1YihmLnJlZE11bChoKSkpO1xuICBJID0gSS5yZWRJQWRkKEkpLCBJID0gSS5yZWRJQWRkKEkpLCBJID0gSS5yZWRJQWRkKEkpO1xuICB2YXIgRCA9IHRoaXMuei5yZWRBZGQoZikucmVkU3FyKCkucmVkSVN1YihpKS5yZWRJU3ViKGgpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoQSwgSSwgRCk7XG59O1xuVHQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIGUgPSBuZXcgcHQoZSwgdCksIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgZSk7XG59O1xuVHQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24oZSkge1xuICBpZiAoZS50eXBlID09PSBcImFmZmluZVwiKVxuICAgIHJldHVybiB0aGlzLmVxKGUudG9KKCkpO1xuICBpZiAodGhpcyA9PT0gZSlcbiAgICByZXR1cm4gITA7XG4gIHZhciB0ID0gdGhpcy56LnJlZFNxcigpLCBpID0gZS56LnJlZFNxcigpO1xuICBpZiAodGhpcy54LnJlZE11bChpKS5yZWRJU3ViKGUueC5yZWRNdWwodCkpLmNtcG4oMCkgIT09IDApXG4gICAgcmV0dXJuICExO1xuICB2YXIgbiA9IHQucmVkTXVsKHRoaXMueiksIHMgPSBpLnJlZE11bChlLnopO1xuICByZXR1cm4gdGhpcy55LnJlZE11bChzKS5yZWRJU3ViKGUueS5yZWRNdWwobikpLmNtcG4oMCkgPT09IDA7XG59O1xuVHQucHJvdG90eXBlLmVxWFRvUCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSB0aGlzLnoucmVkU3FyKCksIGkgPSBlLnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwodCk7XG4gIGlmICh0aGlzLnguY21wKGkpID09PSAwKVxuICAgIHJldHVybiAhMDtcbiAgZm9yICh2YXIgbiA9IGUuY2xvbmUoKSwgcyA9IHRoaXMuY3VydmUucmVkTi5yZWRNdWwodCk7IDsgKSB7XG4gICAgaWYgKG4uaWFkZCh0aGlzLmN1cnZlLm4pLCBuLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKGkucmVkSUFkZChzKSwgdGhpcy54LmNtcChpKSA9PT0gMClcbiAgICAgIHJldHVybiAhMDtcbiAgfVxufTtcblR0LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmlzSW5maW5pdHkoKSA/IFwiPEVDIEpQb2ludCBJbmZpbml0eT5cIiA6IFwiPEVDIEpQb2ludCB4OiBcIiArIHRoaXMueC50b1N0cmluZygxNiwgMikgKyBcIiB5OiBcIiArIHRoaXMueS50b1N0cmluZygxNiwgMikgKyBcIiB6OiBcIiArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyBcIj5cIjtcbn07XG5UdC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xudmFyIG9uID0gbGksIFZ1ID0gdWEsIGdhID0gYmEsIHYyID0gYXI7XG5mdW5jdGlvbiBTbihyKSB7XG4gIGdhLmNhbGwodGhpcywgXCJtb250XCIsIHIpLCB0aGlzLmEgPSBuZXcgb24oci5hLCAxNikudG9SZWQodGhpcy5yZWQpLCB0aGlzLmIgPSBuZXcgb24oci5iLCAxNikudG9SZWQodGhpcy5yZWQpLCB0aGlzLmk0ID0gbmV3IG9uKDQpLnRvUmVkKHRoaXMucmVkKS5yZWRJbnZtKCksIHRoaXMudHdvID0gbmV3IG9uKDIpLnRvUmVkKHRoaXMucmVkKSwgdGhpcy5hMjQgPSB0aGlzLmk0LnJlZE11bCh0aGlzLmEucmVkQWRkKHRoaXMudHdvKSk7XG59XG5WdShTbiwgZ2EpO1xudmFyIGIyID0gU247XG5Tbi5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbihlKSB7XG4gIHZhciB0ID0gZS5ub3JtYWxpemUoKS54LCBpID0gdC5yZWRTcXIoKSwgbiA9IGkucmVkTXVsKHQpLnJlZEFkZChpLnJlZE11bCh0aGlzLmEpKS5yZWRBZGQodCksIHMgPSBuLnJlZFNxcnQoKTtcbiAgcmV0dXJuIHMucmVkU3FyKCkuY21wKG4pID09PSAwO1xufTtcbmZ1bmN0aW9uIEF0KHIsIGUsIHQpIHtcbiAgZ2EuQmFzZVBvaW50LmNhbGwodGhpcywgciwgXCJwcm9qZWN0aXZlXCIpLCBlID09PSBudWxsICYmIHQgPT09IG51bGwgPyAodGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmUsIHRoaXMueiA9IHRoaXMuY3VydmUuemVybykgOiAodGhpcy54ID0gbmV3IG9uKGUsIDE2KSwgdGhpcy56ID0gbmV3IG9uKHQsIDE2KSwgdGhpcy54LnJlZCB8fCAodGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKSksIHRoaXMuei5yZWQgfHwgKHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCkpKTtcbn1cblZ1KEF0LCBnYS5CYXNlUG9pbnQpO1xuU24ucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gdGhpcy5wb2ludCh2Mi50b0FycmF5KGUsIHQpLCAxKTtcbn07XG5Tbi5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBuZXcgQXQodGhpcywgZSwgdCk7XG59O1xuU24ucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBBdC5mcm9tSlNPTih0aGlzLCBlKTtcbn07XG5BdC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uKCkge1xufTtcbkF0LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKS50b0FycmF5KFwiYmVcIiwgdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKSk7XG59O1xuQXQuZnJvbUpTT04gPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBuZXcgQXQoZSwgdFswXSwgdFsxXSB8fCBlLm9uZSk7XG59O1xuQXQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXNJbmZpbml0eSgpID8gXCI8RUMgUG9pbnQgSW5maW5pdHk+XCIgOiBcIjxFQyBQb2ludCB4OiBcIiArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgXCIgejogXCIgKyB0aGlzLnouZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArIFwiPlwiO1xufTtcbkF0LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcbn07XG5BdC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh0aGlzLnopLCB0ID0gZS5yZWRTcXIoKSwgaSA9IHRoaXMueC5yZWRTdWIodGhpcy56KSwgbiA9IGkucmVkU3FyKCksIHMgPSB0LnJlZFN1YihuKSwgbyA9IHQucmVkTXVsKG4pLCBmID0gcy5yZWRNdWwobi5yZWRBZGQodGhpcy5jdXJ2ZS5hMjQucmVkTXVsKHMpKSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG8sIGYpO1xufTtcbkF0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlXCIpO1xufTtcbkF0LnByb3RvdHlwZS5kaWZmQWRkID0gZnVuY3Rpb24oZSwgdCkge1xuICB2YXIgaSA9IHRoaXMueC5yZWRBZGQodGhpcy56KSwgbiA9IHRoaXMueC5yZWRTdWIodGhpcy56KSwgcyA9IGUueC5yZWRBZGQoZS56KSwgbyA9IGUueC5yZWRTdWIoZS56KSwgZiA9IG8ucmVkTXVsKGkpLCBoID0gcy5yZWRNdWwobiksIGQgPSB0LnoucmVkTXVsKGYucmVkQWRkKGgpLnJlZFNxcigpKSwgdiA9IHQueC5yZWRNdWwoZi5yZWRJU3ViKGgpLnJlZFNxcigpKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoZCwgdik7XG59O1xuQXQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKGUpIHtcbiAgZm9yICh2YXIgdCA9IGUuY2xvbmUoKSwgaSA9IHRoaXMsIG4gPSB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpLCBzID0gdGhpcywgbyA9IFtdOyB0LmNtcG4oMCkgIT09IDA7IHQuaXVzaHJuKDEpKVxuICAgIG8ucHVzaCh0LmFuZGxuKDEpKTtcbiAgZm9yICh2YXIgZiA9IG8ubGVuZ3RoIC0gMTsgZiA+PSAwOyBmLS0pXG4gICAgb1tmXSA9PT0gMCA/IChpID0gaS5kaWZmQWRkKG4sIHMpLCBuID0gbi5kYmwoKSkgOiAobiA9IGkuZGlmZkFkZChuLCBzKSwgaSA9IGkuZGJsKCkpO1xuICByZXR1cm4gbjtcbn07XG5BdC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZVwiKTtcbn07XG5BdC5wcm90b3R5cGUuanVtbEFkZCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIG9uIE1vbnRnb21lcnkgY3VydmVcIik7XG59O1xuQXQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gdGhpcy5nZXRYKCkuY21wKGUuZ2V0WCgpKSA9PT0gMDtcbn07XG5BdC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnggPSB0aGlzLngucmVkTXVsKHRoaXMuei5yZWRJbnZtKCkpLCB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZSwgdGhpcztcbn07XG5BdC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKSwgdGhpcy54LmZyb21SZWQoKTtcbn07XG52YXIgZzIgPSBhciwgY2kgPSBsaSwgV3UgPSB1YSwgeWEgPSBiYSwgeTIgPSBnMi5hc3NlcnQ7XG5mdW5jdGlvbiBIcihyKSB7XG4gIHRoaXMudHdpc3RlZCA9IChyLmEgfCAwKSAhPT0gMSwgdGhpcy5tT25lQSA9IHRoaXMudHdpc3RlZCAmJiAoci5hIHwgMCkgPT09IC0xLCB0aGlzLmV4dGVuZGVkID0gdGhpcy5tT25lQSwgeWEuY2FsbCh0aGlzLCBcImVkd2FyZHNcIiwgciksIHRoaXMuYSA9IG5ldyBjaShyLmEsIDE2KS51bW9kKHRoaXMucmVkLm0pLCB0aGlzLmEgPSB0aGlzLmEudG9SZWQodGhpcy5yZWQpLCB0aGlzLmMgPSBuZXcgY2koci5jLCAxNikudG9SZWQodGhpcy5yZWQpLCB0aGlzLmMyID0gdGhpcy5jLnJlZFNxcigpLCB0aGlzLmQgPSBuZXcgY2koci5kLCAxNikudG9SZWQodGhpcy5yZWQpLCB0aGlzLmRkID0gdGhpcy5kLnJlZEFkZCh0aGlzLmQpLCB5MighdGhpcy50d2lzdGVkIHx8IHRoaXMuYy5mcm9tUmVkKCkuY21wbigxKSA9PT0gMCksIHRoaXMub25lQyA9IChyLmMgfCAwKSA9PT0gMTtcbn1cbld1KEhyLCB5YSk7XG52YXIgbTIgPSBIcjtcbkhyLnByb3RvdHlwZS5fbXVsQSA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIHRoaXMubU9uZUEgPyBlLnJlZE5lZygpIDogdGhpcy5hLnJlZE11bChlKTtcbn07XG5Ici5wcm90b3R5cGUuX211bEMgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiB0aGlzLm9uZUMgPyBlIDogdGhpcy5jLnJlZE11bChlKTtcbn07XG5Ici5wcm90b3R5cGUuanBvaW50ID0gZnVuY3Rpb24oZSwgdCwgaSwgbikge1xuICByZXR1cm4gdGhpcy5wb2ludChlLCB0LCBpLCBuKTtcbn07XG5Ici5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgZSA9IG5ldyBjaShlLCAxNiksIGUucmVkIHx8IChlID0gZS50b1JlZCh0aGlzLnJlZCkpO1xuICB2YXIgaSA9IGUucmVkU3FyKCksIG4gPSB0aGlzLmMyLnJlZFN1Yih0aGlzLmEucmVkTXVsKGkpKSwgcyA9IHRoaXMub25lLnJlZFN1Yih0aGlzLmMyLnJlZE11bCh0aGlzLmQpLnJlZE11bChpKSksIG8gPSBuLnJlZE11bChzLnJlZEludm0oKSksIGYgPSBvLnJlZFNxcnQoKTtcbiAgaWYgKGYucmVkU3FyKCkucmVkU3ViKG8pLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnRcIik7XG4gIHZhciBoID0gZi5mcm9tUmVkKCkuaXNPZGQoKTtcbiAgcmV0dXJuICh0ICYmICFoIHx8ICF0ICYmIGgpICYmIChmID0gZi5yZWROZWcoKSksIHRoaXMucG9pbnQoZSwgZik7XG59O1xuSHIucHJvdG90eXBlLnBvaW50RnJvbVkgPSBmdW5jdGlvbihlLCB0KSB7XG4gIGUgPSBuZXcgY2koZSwgMTYpLCBlLnJlZCB8fCAoZSA9IGUudG9SZWQodGhpcy5yZWQpKTtcbiAgdmFyIGkgPSBlLnJlZFNxcigpLCBuID0gaS5yZWRTdWIodGhpcy5jMiksIHMgPSBpLnJlZE11bCh0aGlzLmQpLnJlZE11bCh0aGlzLmMyKS5yZWRTdWIodGhpcy5hKSwgbyA9IG4ucmVkTXVsKHMucmVkSW52bSgpKTtcbiAgaWYgKG8uY21wKHRoaXMuemVybykgPT09IDApIHtcbiAgICBpZiAodClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnRcIik7XG4gICAgcmV0dXJuIHRoaXMucG9pbnQodGhpcy56ZXJvLCBlKTtcbiAgfVxuICB2YXIgZiA9IG8ucmVkU3FydCgpO1xuICBpZiAoZi5yZWRTcXIoKS5yZWRTdWIobykuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludFwiKTtcbiAgcmV0dXJuIGYuZnJvbVJlZCgpLmlzT2RkKCkgIT09IHQgJiYgKGYgPSBmLnJlZE5lZygpKSwgdGhpcy5wb2ludChmLCBlKTtcbn07XG5Ici5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbihlKSB7XG4gIGlmIChlLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gITA7XG4gIGUubm9ybWFsaXplKCk7XG4gIHZhciB0ID0gZS54LnJlZFNxcigpLCBpID0gZS55LnJlZFNxcigpLCBuID0gdC5yZWRNdWwodGhpcy5hKS5yZWRBZGQoaSksIHMgPSB0aGlzLmMyLnJlZE11bCh0aGlzLm9uZS5yZWRBZGQodGhpcy5kLnJlZE11bCh0KS5yZWRNdWwoaSkpKTtcbiAgcmV0dXJuIG4uY21wKHMpID09PSAwO1xufTtcbmZ1bmN0aW9uIGZ0KHIsIGUsIHQsIGksIG4pIHtcbiAgeWEuQmFzZVBvaW50LmNhbGwodGhpcywgciwgXCJwcm9qZWN0aXZlXCIpLCBlID09PSBudWxsICYmIHQgPT09IG51bGwgJiYgaSA9PT0gbnVsbCA/ICh0aGlzLnggPSB0aGlzLmN1cnZlLnplcm8sIHRoaXMueSA9IHRoaXMuY3VydmUub25lLCB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZSwgdGhpcy50ID0gdGhpcy5jdXJ2ZS56ZXJvLCB0aGlzLnpPbmUgPSAhMCkgOiAodGhpcy54ID0gbmV3IGNpKGUsIDE2KSwgdGhpcy55ID0gbmV3IGNpKHQsIDE2KSwgdGhpcy56ID0gaSA/IG5ldyBjaShpLCAxNikgOiB0aGlzLmN1cnZlLm9uZSwgdGhpcy50ID0gbiAmJiBuZXcgY2kobiwgMTYpLCB0aGlzLngucmVkIHx8ICh0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpKSwgdGhpcy55LnJlZCB8fCAodGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKSksIHRoaXMuei5yZWQgfHwgKHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCkpLCB0aGlzLnQgJiYgIXRoaXMudC5yZWQgJiYgKHRoaXMudCA9IHRoaXMudC50b1JlZCh0aGlzLmN1cnZlLnJlZCkpLCB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lLCB0aGlzLmN1cnZlLmV4dGVuZGVkICYmICF0aGlzLnQgJiYgKHRoaXMudCA9IHRoaXMueC5yZWRNdWwodGhpcy55KSwgdGhpcy56T25lIHx8ICh0aGlzLnQgPSB0aGlzLnQucmVkTXVsKHRoaXMuei5yZWRJbnZtKCkpKSkpO1xufVxuV3UoZnQsIHlhLkJhc2VQb2ludCk7XG5Ici5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGZ0LmZyb21KU09OKHRoaXMsIGUpO1xufTtcbkhyLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uKGUsIHQsIGksIG4pIHtcbiAgcmV0dXJuIG5ldyBmdCh0aGlzLCBlLCB0LCBpLCBuKTtcbn07XG5mdC5mcm9tSlNPTiA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIG5ldyBmdChlLCB0WzBdLCB0WzFdLCB0WzJdKTtcbn07XG5mdC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pc0luZmluaXR5KCkgPyBcIjxFQyBQb2ludCBJbmZpbml0eT5cIiA6IFwiPEVDIFBvaW50IHg6IFwiICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyBcIiB5OiBcIiArIHRoaXMueS5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgXCIgejogXCIgKyB0aGlzLnouZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArIFwiPlwiO1xufTtcbmZ0LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnguY21wbigwKSA9PT0gMCAmJiAodGhpcy55LmNtcCh0aGlzLnopID09PSAwIHx8IHRoaXMuek9uZSAmJiB0aGlzLnkuY21wKHRoaXMuY3VydmUuYykgPT09IDApO1xufTtcbmZ0LnByb3RvdHlwZS5fZXh0RGJsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlID0gdGhpcy54LnJlZFNxcigpLCB0ID0gdGhpcy55LnJlZFNxcigpLCBpID0gdGhpcy56LnJlZFNxcigpO1xuICBpID0gaS5yZWRJQWRkKGkpO1xuICB2YXIgbiA9IHRoaXMuY3VydmUuX211bEEoZSksIHMgPSB0aGlzLngucmVkQWRkKHRoaXMueSkucmVkU3FyKCkucmVkSVN1YihlKS5yZWRJU3ViKHQpLCBvID0gbi5yZWRBZGQodCksIGYgPSBvLnJlZFN1YihpKSwgaCA9IG4ucmVkU3ViKHQpLCBkID0gcy5yZWRNdWwoZiksIHYgPSBvLnJlZE11bChoKSwgdyA9IHMucmVkTXVsKGgpLCBBID0gZi5yZWRNdWwobyk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KGQsIHYsIEEsIHcpO1xufTtcbmZ0LnByb3RvdHlwZS5fcHJvakRibCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZSA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKSwgdCA9IHRoaXMueC5yZWRTcXIoKSwgaSA9IHRoaXMueS5yZWRTcXIoKSwgbiwgcywgbywgZiwgaCwgZDtcbiAgaWYgKHRoaXMuY3VydmUudHdpc3RlZCkge1xuICAgIGYgPSB0aGlzLmN1cnZlLl9tdWxBKHQpO1xuICAgIHZhciB2ID0gZi5yZWRBZGQoaSk7XG4gICAgdGhpcy56T25lID8gKG4gPSBlLnJlZFN1Yih0KS5yZWRTdWIoaSkucmVkTXVsKHYucmVkU3ViKHRoaXMuY3VydmUudHdvKSksIHMgPSB2LnJlZE11bChmLnJlZFN1YihpKSksIG8gPSB2LnJlZFNxcigpLnJlZFN1Yih2KS5yZWRTdWIodikpIDogKGggPSB0aGlzLnoucmVkU3FyKCksIGQgPSB2LnJlZFN1YihoKS5yZWRJU3ViKGgpLCBuID0gZS5yZWRTdWIodCkucmVkSVN1YihpKS5yZWRNdWwoZCksIHMgPSB2LnJlZE11bChmLnJlZFN1YihpKSksIG8gPSB2LnJlZE11bChkKSk7XG4gIH0gZWxzZVxuICAgIGYgPSB0LnJlZEFkZChpKSwgaCA9IHRoaXMuY3VydmUuX211bEModGhpcy56KS5yZWRTcXIoKSwgZCA9IGYucmVkU3ViKGgpLnJlZFN1YihoKSwgbiA9IHRoaXMuY3VydmUuX211bEMoZS5yZWRJU3ViKGYpKS5yZWRNdWwoZCksIHMgPSB0aGlzLmN1cnZlLl9tdWxDKGYpLnJlZE11bCh0LnJlZElTdWIoaSkpLCBvID0gZi5yZWRNdWwoZCk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG4sIHMsIG8pO1xufTtcbmZ0LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXNJbmZpbml0eSgpID8gdGhpcyA6IHRoaXMuY3VydmUuZXh0ZW5kZWQgPyB0aGlzLl9leHREYmwoKSA6IHRoaXMuX3Byb2pEYmwoKTtcbn07XG5mdC5wcm90b3R5cGUuX2V4dEFkZCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSB0aGlzLnkucmVkU3ViKHRoaXMueCkucmVkTXVsKGUueS5yZWRTdWIoZS54KSksIGkgPSB0aGlzLnkucmVkQWRkKHRoaXMueCkucmVkTXVsKGUueS5yZWRBZGQoZS54KSksIG4gPSB0aGlzLnQucmVkTXVsKHRoaXMuY3VydmUuZGQpLnJlZE11bChlLnQpLCBzID0gdGhpcy56LnJlZE11bChlLnoucmVkQWRkKGUueikpLCBvID0gaS5yZWRTdWIodCksIGYgPSBzLnJlZFN1YihuKSwgaCA9IHMucmVkQWRkKG4pLCBkID0gaS5yZWRBZGQodCksIHYgPSBvLnJlZE11bChmKSwgdyA9IGgucmVkTXVsKGQpLCBBID0gby5yZWRNdWwoZCksIEkgPSBmLnJlZE11bChoKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQodiwgdywgSSwgQSk7XG59O1xuZnQucHJvdG90eXBlLl9wcm9qQWRkID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdCA9IHRoaXMuei5yZWRNdWwoZS56KSwgaSA9IHQucmVkU3FyKCksIG4gPSB0aGlzLngucmVkTXVsKGUueCksIHMgPSB0aGlzLnkucmVkTXVsKGUueSksIG8gPSB0aGlzLmN1cnZlLmQucmVkTXVsKG4pLnJlZE11bChzKSwgZiA9IGkucmVkU3ViKG8pLCBoID0gaS5yZWRBZGQobyksIGQgPSB0aGlzLngucmVkQWRkKHRoaXMueSkucmVkTXVsKGUueC5yZWRBZGQoZS55KSkucmVkSVN1YihuKS5yZWRJU3ViKHMpLCB2ID0gdC5yZWRNdWwoZikucmVkTXVsKGQpLCB3LCBBO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS50d2lzdGVkID8gKHcgPSB0LnJlZE11bChoKS5yZWRNdWwocy5yZWRTdWIodGhpcy5jdXJ2ZS5fbXVsQShuKSkpLCBBID0gZi5yZWRNdWwoaCkpIDogKHcgPSB0LnJlZE11bChoKS5yZWRNdWwocy5yZWRTdWIobikpLCBBID0gdGhpcy5jdXJ2ZS5fbXVsQyhmKS5yZWRNdWwoaCkpLCB0aGlzLmN1cnZlLnBvaW50KHYsIHcsIEEpO1xufTtcbmZ0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiB0aGlzLmlzSW5maW5pdHkoKSA/IGUgOiBlLmlzSW5maW5pdHkoKSA/IHRoaXMgOiB0aGlzLmN1cnZlLmV4dGVuZGVkID8gdGhpcy5fZXh0QWRkKGUpIDogdGhpcy5fcHJvakFkZChlKTtcbn07XG5mdC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gdGhpcy5faGFzRG91YmxlcyhlKSA/IHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGUpIDogdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBlKTtcbn07XG5mdC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24oZSwgdCwgaSkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBbdGhpcywgdF0sIFtlLCBpXSwgMiwgITEpO1xufTtcbmZ0LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24oZSwgdCwgaSkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBbdGhpcywgdF0sIFtlLCBpXSwgMiwgITApO1xufTtcbmZ0LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuek9uZSlcbiAgICByZXR1cm4gdGhpcztcbiAgdmFyIGUgPSB0aGlzLnoucmVkSW52bSgpO1xuICByZXR1cm4gdGhpcy54ID0gdGhpcy54LnJlZE11bChlKSwgdGhpcy55ID0gdGhpcy55LnJlZE11bChlKSwgdGhpcy50ICYmICh0aGlzLnQgPSB0aGlzLnQucmVkTXVsKGUpKSwgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmUsIHRoaXMuek9uZSA9ICEwLCB0aGlzO1xufTtcbmZ0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoXG4gICAgdGhpcy54LnJlZE5lZygpLFxuICAgIHRoaXMueSxcbiAgICB0aGlzLnosXG4gICAgdGhpcy50ICYmIHRoaXMudC5yZWROZWcoKVxuICApO1xufTtcbmZ0LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLCB0aGlzLnguZnJvbVJlZCgpO1xufTtcbmZ0LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLCB0aGlzLnkuZnJvbVJlZCgpO1xufTtcbmZ0LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIHRoaXMgPT09IGUgfHwgdGhpcy5nZXRYKCkuY21wKGUuZ2V0WCgpKSA9PT0gMCAmJiB0aGlzLmdldFkoKS5jbXAoZS5nZXRZKCkpID09PSAwO1xufTtcbmZ0LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbihlKSB7XG4gIHZhciB0ID0gZS50b1JlZCh0aGlzLmN1cnZlLnJlZCkucmVkTXVsKHRoaXMueik7XG4gIGlmICh0aGlzLnguY21wKHQpID09PSAwKVxuICAgIHJldHVybiAhMDtcbiAgZm9yICh2YXIgaSA9IGUuY2xvbmUoKSwgbiA9IHRoaXMuY3VydmUucmVkTi5yZWRNdWwodGhpcy56KTsgOyApIHtcbiAgICBpZiAoaS5pYWRkKHRoaXMuY3VydmUubiksIGkuY21wKHRoaXMuY3VydmUucCkgPj0gMClcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAodC5yZWRJQWRkKG4pLCB0aGlzLnguY21wKHQpID09PSAwKVxuICAgICAgcmV0dXJuICEwO1xuICB9XG59O1xuZnQucHJvdG90eXBlLnRvUCA9IGZ0LnByb3RvdHlwZS5ub3JtYWxpemU7XG5mdC5wcm90b3R5cGUubWl4ZWRBZGQgPSBmdC5wcm90b3R5cGUuYWRkO1xuKGZ1bmN0aW9uKHIpIHtcbiAgdmFyIGUgPSByO1xuICBlLmJhc2UgPSBiYSwgZS5zaG9ydCA9IHAyLCBlLm1vbnQgPSBiMiwgZS5lZHdhcmRzID0gbTI7XG59KShZbyk7XG52YXIgbWEgPSB7fSwgWWEsIHljO1xuZnVuY3Rpb24gdzIoKSB7XG4gIHJldHVybiB5YyB8fCAoeWMgPSAxLCBZYSA9IHtcbiAgICBkb3VibGVzOiB7XG4gICAgICBzdGVwOiA0LFxuICAgICAgcG9pbnRzOiBbXG4gICAgICAgIFtcbiAgICAgICAgICBcImU2MGZjZTkzYjU5ZTllYzUzMDExYWFiYzIxYzIzZTk3YjJhMzEzNjliODdhNWFlOWM0NGVlODllMmE2ZGVjMGFcIixcbiAgICAgICAgICBcImY3ZTM1MDczOTllNTk1OTI5ZGI5OWYzNGY1NzkzNzEwMTI5Njg5MWU0NGQyM2YwYmUxZjMyY2NlNjk2MTY4MjFcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI4MjgyMjYzMjEyYzYwOWQ5ZWEyYTZlM2UxNzJkZTIzOGQ4YzM5Y2FiZDVhYzFjYTEwNjQ2ZTIzZmQ1ZjUxNTA4XCIsXG4gICAgICAgICAgXCIxMWY4YTgwOTg1NTdkZmU0NWU4MjU2ZTgzMGI2MGFjZTYyZDYxM2FjMmY3YjE3YmVkMzFiNmVhZmY2ZTI2Y2FmXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiMTc1ZTE1OWY3MjhiODY1YTcyZjk5Y2M2YzZmYzg0NmRlMGI5MzgzM2ZkMjIyMmVkNzNmY2U1YjU1MWU1YjczOVwiLFxuICAgICAgICAgIFwiZDM1MDZlMGQ5ZTNjNzllYmE0ZWY5N2E1MWZmNzFmNWVhY2I1OTU1YWRkMjQzNDVjNmVmYTZmZmVlOWZlZDY5NVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjM2M2Q5MGQ0NDdiMDBjOWM5OWNlYWMwNWI2MjYyZWUwNTM0NDFjN2U1NTU1MmZmZTUyNmJhZDhmODNmZjQ2NDBcIixcbiAgICAgICAgICBcIjRlMjczYWRmYzczMjIyMTk1M2I0NDUzOTdmMzM2MzE0NWI5YTg5MDA4MTk5ZWNiNjIwMDNjN2YzYmVlOWRlOVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjhiNGI1ZjE2NWRmM2MyYmU4YzYyNDRiNWI3NDU2Mzg4NDNlNGE3ODFhMTViY2QxYjY5Zjc5YTU1ZGZmZGY4MGNcIixcbiAgICAgICAgICBcIjRhYWQwYTZmNjhkMzA4YjRiM2ZiZDc4MTNhYjBkYTA0ZjllMzM2NTQ2MTYyZWU1NmIzZWZmMGM2NWZkNGZkMzZcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI3MjNjYmFhNmU1ZGI5OTZkNmJmNzcxYzAwYmQ1NDhjN2I3MDBkYmZmYTZjMGU3N2JjYjYxMTU5MjUyMzJmY2RhXCIsXG4gICAgICAgICAgXCI5NmU4NjdiNTU5NWNjNDk4YTkyMTEzNzQ4ODgyNGQ2ZTI2NjBhMDY1Mzc3OTQ5NDgwMWRjMDY5ZDllYjM5ZjVmXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZWViZmE0ZDQ5M2JlYmY5OGJhNWZlZWM4MTJjMmQzYjUwOTQ3OTYxMjM3YTkxOTgzOWE1MzNlY2EwZTdkZDdmYVwiLFxuICAgICAgICAgIFwiNWQ5YThjYTM5NzBlZjBmMjY5ZWU3ZWRhZjE3ODA4OWQ5YWU0Y2RjM2E3MTFmNzEyZGRmZDRmZGFlMWRlODk5OVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjEwMGY0NGRhNjk2ZTcxNjcyNzkxZDBhMDliN2JkZTQ1OWYxMjE1YTI5YjNjMDNiZmVmZDc4MzViMzlhNDhkYjBcIixcbiAgICAgICAgICBcImNkZDllMTMxOTJhMDBiNzcyZWM4ZjMzMDBjMDkwNjY2YjdmZjRhMThmZjUxOTVhYzBmYmQ1Y2Q2MmJjNjVhMDlcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJlMTAzMWJlMjYyYzdlZDFiMWRjOTIyN2E0YTA0YzAxN2E3N2Y4ZDQ0NjRmM2IzODUyYzhhY2RlNmU1MzRmZDJkXCIsXG4gICAgICAgICAgXCI5ZDcwNjE5Mjg5NDA0MDVlNmJiNmE0MTc2NTk3NTM1YWYyOTJkZDQxOWUxY2VkNzlhNDRmMThmMjk0NTZhMDBkXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZmVlYTZjYWU0NmQ1NWI1MzBhYzI4MzlmMTQzYmQ3ZWM1Y2Y4YjI2NmE0MWQ2YWY1MmQ1ZTY4OGQ5MDk0Njk2ZFwiLFxuICAgICAgICAgIFwiZTU3YzZiNmM5N2RjZTFiYWIwNmU0ZTEyYmYzZWNkNWM5ODFjODk1N2NjNDE0NDJkMzE1NWRlYmYxODA5MDA4OFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImRhNjdhOTFkOTEwNDljZGNiMzY3YmU0YmU2ZmZjYTNjZmVlZDY1N2Q4MDg1ODNkZTMzZmE5NzhiYzFlYzZjYjFcIixcbiAgICAgICAgICBcIjliYWNhYTM1NDgxNjQyYmM0MWY0NjNmN2VjOTc4MGU1ZGVjN2FkYzUwOGY3NDBhMTdlOWVhOGUyN2E2OGJlMWRcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI1MzkwNGZhYTBiMzM0Y2RkYTZlMDAwOTM1ZWYyMjE1MWVjMDhkMGY3YmIxMTA2OWY1NzU0NWNjYzFhMzdiN2MwXCIsXG4gICAgICAgICAgXCI1YmMwODdkMGJjODAxMDZkODhjOWVjY2FjMjBkM2MxYzEzOTk5OTgxZTE0NDM0Njk5ZGNiMDk2YjAyMjc3MWM4XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiOGU3YmNkMGJkMzU5ODNhNzcxOWNjYTc3NjRjYTkwNjc3OWI1M2EwNDNhOWI4YmNhZWZmOTU5ZjQzYWQ4NjA0N1wiLFxuICAgICAgICAgIFwiMTBiNzc3MGIyYTNkYTRiMzk0MDMxMDQyMGNhOTUxNDU3OWU4OGUyZTQ3ZmQ2OGIzZWExMDA0N2U4NDYwMzcyYVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjM4NWVlZDM0YzFjZGZmMjFlNmQwODE4Njg5YjgxYmRlNzFhN2Y0ZjE4Mzk3ZTY2OTBhODQxZTE1OTljNDM4NjJcIixcbiAgICAgICAgICBcIjI4M2JlYmMzZThlYTIzZjU2NzAxZGUxOWU5ZWJmNDU3NmIzMDRlZWMyMDg2ZGM4Y2MwNDU4ZmU1NTQyZTU0NTNcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI2ZjlkOWI4MDNlY2YxOTE2MzdjNzNhNDQxM2RmYTE4MGZkZGY4NGE1OTQ3ZmJjOWM2MDZlZDg2YzNmYWMzYTdcIixcbiAgICAgICAgICBcIjdjODBjNjhlNjAzMDU5YmE2OWI4ZTJhMzBlNDVjNGQ0N2VhNGRkMmY1YzI4MTAwMmQ4Njg5MDYwM2E4NDIxNjBcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCIzMzIyZDQwMTI0M2M0ZTI1ODJhMjE0N2MxMDRkNmVjYmY3NzRkMTYzZGIwZjVlNTMxM2I3ZTBlNzQyZDBlNmJkXCIsXG4gICAgICAgICAgXCI1NmU3MDc5N2U5NjY0ZWY1YmZiMDE5YmM0ZGRhZjliNzI4MDVmNjNlYTI4NzNhZjYyNGYzYTJlOTZjMjhiMmEwXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiODU2NzJjN2QyZGUwYjdkYTJiZDE3NzBkODk2NjU4Njg3NDFiM2Y5YWY3NjQzMzk3NzIxZDc0ZDI4MTM0YWI4M1wiLFxuICAgICAgICAgIFwiN2M0ODFiOWI1YjQzYjJlYjYzNzQwNDliZmE2MmMyZTVlNzdmMTdmY2M1Mjk4ZjQ0YzhlMzA5NGY3OTAzMTNhNlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjk0OGJmODA5YjE5ODhhNDZiMDZjOWYxOTE5NDEzYjEwZjkyMjZjNjBmNjY4ODMyZmZkOTU5YWY2MGM4MmEwYVwiLFxuICAgICAgICAgIFwiNTNhNTYyODU2ZGNiNjY0NmRjNmI3NGM1ZDFjMzQxOGM2ZDRkZmYwOGM5N2NkMmJlZDRjYjdmODhkOGM4ZTU4OVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjYyNjBjZTdmNDYxODAxYzM0ZjA2N2NlMGYwMjg3M2E4ZjFiMGU0NGRmYzY5NzUyYWNjZWNkODE5ZjM4ZmQ4ZThcIixcbiAgICAgICAgICBcImJjMmRhODJiNmZhNWI1NzFhN2YwOTA0OTc3NmExZWY3ZWNkMjkyMjM4MDUxYzE5OGMxYTg0ZTk1YjJiNGFlMTdcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJlNTAzN2RlMGFmYzFkOGQ0M2Q4MzQ4NDE0YmJmNDEwMzA0M2VjOGY1NzViZmRjNDMyOTUzY2M4ZDIwMzdmYTJkXCIsXG4gICAgICAgICAgXCI0NTcxNTM0YmFhOTRkM2I1ZjlmOThkMDlmYjk5MGJkZGJkNWY1YjAzZWM0ODFmMTBlMGU1ZGM4NDFkNzU1YmRhXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZTA2MzcyYjBmNGEyMDdhZGY1ZWE5MDVlOGYxNzcxYjRlN2U4ZGJkMWM2YTZjNWI3MjU4NjZhMGFlNGZjZTcyNVwiLFxuICAgICAgICAgIFwiN2E5MDg5NzRiY2UxOGNmZTEyYTI3YmIyYWQ1YTQ4OGNkNzQ4NGE3Nzg3MTA0ODcwYjI3MDM0Zjk0ZWVlMzFkZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjIxM2M3YTcxNWNkNWQ0NTM1OGQwYmJmOWRjMGNlMDIyMDRiMTBiZGRlMmEzZjU4NTQwYWQ2OTA4ZDA1NTk3NTRcIixcbiAgICAgICAgICBcIjRiNmRhZDBiNWFlNDYyNTA3MDEzYWQwNjI0NWJhMTkwYmI0ODUwZjVmMzZhN2VlZGRmZjJjMjc1MzRiNDU4ZjJcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI0ZTdjMjcyYTdhZjRiMzRlOGRiYjkzNTJhNTQxOWE4N2UyODM4YzcwYWRjNjJjZGRmMGNjM2EzYjA4ZmJkNTNjXCIsXG4gICAgICAgICAgXCIxNzc0OWM3NjZjOWQwYjE4ZTE2ZmQwOWY2ZGVmNjgxYjUzMGI5NjE0YmZmN2RkMzNlMGIzOTQxODE3ZGNhYWU2XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZmVhNzRlM2RiZTc3OGIxYjEwZjIzOGFkNjE2ODZhYTVjNzZlM2RiMmJlNDMwNTc2MzI0MjdlMjg0MGZiMjdiNlwiLFxuICAgICAgICAgIFwiNmUwNTY4ZGI5YjBiMTMyOTdjZjY3NGRlY2NiNmFmOTMxMjZiNTk2Yjk3M2Y3Yjc3NzAxZDNkYjdmMjNjYjk2ZlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjc2ZTY0MTEzZjY3N2NmMGUxMGEyNTcwZDU5OTk2OGQzMTU0NGUxNzliNzYwNDMyOTUyYzAyYTQ0MTdiZGRlMzlcIixcbiAgICAgICAgICBcImM5MGRkZjhkZWU0ZTk1Y2Y1NzcwNjZkNzA2ODFmMGQzNWUyYTMzZDJiNTZkMjAzMmI0YjE3NTJkMTkwMWFjMDFcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJjNzM4YzU2YjAzYjJhYmUxZTgyODFiYWE3NDNmOGY5YThmN2NjNjQzZGYyNmNiZWUzYWIxNTAyNDJiY2JiODkxXCIsXG4gICAgICAgICAgXCI4OTNmYjU3ODk1MWFkMjUzN2Y3MThmMmVhY2JmYmJiYjgyMzE0ZWVmNzg4MGNmZTkxN2U3MzVkOTY5OWE4NGMzXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZDg5NTYyNjU0OGI2NWI4MWUyNjRjNzYzN2M5NzI4NzdkMWQ3MmU1ZjNhOTI1MDE0MzcyZTlmNjU4OGY2YzE0YlwiLFxuICAgICAgICAgIFwiZmViZmFhMzhmMmJjN2VhZTcyOGVjNjA4MThjMzQwZWIwMzQyOGQ2MzJiYjA2N2UxNzkzNjNlZDc1ZDdkOTkxZlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImI4ZGE5NDAzMmE5NTc1MThlYjBmNjQzMzU3MWU4NzYxY2VmZmM3MzY5M2U4NGVkZDQ5MTUwYTU2NGY2NzZlMDNcIixcbiAgICAgICAgICBcIjI4MDRkZmE0NDgwNWExZTRkN2M5OWNjOTc2MjgwOGIwOTJjYzU4NGQ5NWZmM2I1MTE0ODhlNGU3NGVmZGY2ZTdcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJlODBmZWExNDQ0MWZiMzNhN2Q4YWRhYjk0NzVkN2ZhYjIwMTllZmZiNTE1NmE3OTJmMWExMTc3OGUzYzBkZjVkXCIsXG4gICAgICAgICAgXCJlZWQxZGU3ZjYzOGUwMDc3MWU4OTc2OGNhM2NhOTQ0NzJkMTU1ZTgwYWYzMjJlYTlmY2I0MjkxYjZhYzllYzc4XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiYTMwMTY5N2JkZmNkNzA0MzEzYmE0OGU1MWQ1Njc1NDNmMmExODIwMzFlZmQ2OTE1ZGRjMDdiYmNjNGUxNjA3MFwiLFxuICAgICAgICAgIFwiNzM3MGY5MWNmYjY3ZTRmNTA4MTgwOWZhMjVkNDBmOWIxNzM1ZGJmN2MwYTExYTEzMGMwZDFhMDQxZTE3N2VhMVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjkwYWQ4NWIzODlkNmI5MzY0NjNmOWQwNTEyNjc4ZGUyMDhjYzMzMGIxMTMwN2ZmZmFiN2FjNjNlM2ZiMDRlZDRcIixcbiAgICAgICAgICBcImU1MDdhMzYyMGEzODI2MWFmZmRjYmQ5NDI3MjIyYjgzOWFlZmFiZTE1ODI4OTRkOTkxZDRkNDhjYjZlZjE1MFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjhmNjhiOWQyZjYzYjVmMzM5MjM5YzFhZDk4MWYxNjJlZTg4YzU2Nzg3MjNlYTMzNTFiN2I0NDRjOWVjNGMwZGFcIixcbiAgICAgICAgICBcIjY2MmE5ZjJkYmEwNjM5ODZkZTFkOTBjMmI2YmUyMTVkYmJlYTJjZmU5NTUxMGJmZGYyM2NiZjc5NTAxZmZmODJcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJlNGYzZmIwMTc2YWY4NWQ2NWZmOTlmZjkxOThjMzYwOTFmNDhlODY1MDM2ODFlM2U2Njg2ZmQ1MDUzMjMxZTExXCIsXG4gICAgICAgICAgXCIxZTYzNjMzYWQwZWY0ZjFjMTY2MWE2ZDBlYTAyYjcyODZjYzdlNzRlYzk1MWQxYzk4MjJjMzg1NzZmZWI3M2JjXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiOGMwMGZhOWIxOGViZjMzMWViOTYxNTM3YTQ1YTQyNjZjNzAzNGYyZjBkNGUxZDA3MTZmYjZlYWUyMGVhZTI5ZVwiLFxuICAgICAgICAgIFwiZWZhNDcyNjdmZWE1MjFhMWE5ZGMzNDNhMzczNmM5NzRjMmZhZGFmYTgxZTM2YzU0ZTdkMmE0YzY2NzAyNDE0YlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImU3YTI2Y2U2OWRkNDgyOWYzZTEwY2VjMGE5ZTk4ZWQzMTQzZDA4NGYzMDhiOTJjMDk5N2ZkZGZjNjBjYjNlNDFcIixcbiAgICAgICAgICBcIjJhNzU4ZTMwMGZhNzk4NGI0NzFiMDA2YTFhYWZiYjE4ZDBhNmIyYzA0MjBlODNlMjBlOGE5NDIxY2YyY2ZkNTFcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJiNjQ1OWUwZWUzNjYyZWM4ZDIzNTQwYzIyM2JjYmRjNTcxY2JjYjk2N2Q3OTQyNGYzY2YyOWViM2RlNmI4MGVmXCIsXG4gICAgICAgICAgXCI2N2M4NzZkMDZmM2UwNmRlMWRhZGYxNmU1NjYxZGIzYzRiM2FlNmQ0OGUzNWIyZmYzMGJmMGI2MWE3MWJhNDVcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJkNjhhODBjODI4MGJiODQwNzkzMjM0YWExMThmMDYyMzFkNmYxZmM2N2U3M2M1YTVkZWRhMGY1YjQ5Njk0M2U4XCIsXG4gICAgICAgICAgXCJkYjhiYTlmZmY0YjU4NmQwMGM0YjFmOTE3N2IwZTI4YjViMGU3YjhmNzg0NTI5NWEyOTRjODQyNjZiMTMzMTIwXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiMzI0YWVkN2RmNjVjODA0MjUyZGMwMjcwOTA3YTMwYjA5NjEyYWViOTczNDQ5Y2VhNDA5NTk4MGZjMjhkM2Q1ZFwiLFxuICAgICAgICAgIFwiNjQ4YTM2NTc3NGI2MWYyZmYxMzBjMGMzNWFlYzFmNGYxOTIxM2IwYzdlMzMyODQzOTY3MjI0YWY5NmFiN2M4NFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjRkZjljMTQ5MTljZGU2MWY2ZDUxZGZkYmU1ZmVlNWRjZWVjNDE0M2JhOGQxY2E4ODhlOGJkMzczZmQwNTRjOTZcIixcbiAgICAgICAgICBcIjM1ZWM1MTA5MmQ4NzI4MDUwOTc0YzIzYTFkODVkNGI1ZDUwNmNkYzI4ODQ5MDE5MmViYWMwNmNhZDEwZDVkXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiOWMzOTE5YTg0YTQ3NDg3MGZhZWQ4YTljMWNjNjYwMjE1MjM0ODkwNTRkN2YwMzA4Y2JmYzk5YzhhYzFmOThjZFwiLFxuICAgICAgICAgIFwiZGRiODRmMGY0YTRkZGQ1NzU4NGYwNDRiZjI2MGU2NDE5MDUzMjZmNzZjNjRjOGU2YmU3ZTVlMDNkNGZjNTk5ZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjYwNTcxNzBiMWRkMTJmZGY4ZGUwNWYyODFkOGUwNmJiOTFlMTQ5M2E4YjkxZDRjYzVhMjEzODIxMjBhOTU5ZTVcIixcbiAgICAgICAgICBcIjlhMWFmMGIyNmE2YTQ4MDdhZGQ5YTJkYWY3MWRmMjYyNDY1MTUyYmMzZWUyNGM2NWU4OTliZTkzMjM4NWEyYThcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJhNTc2ZGY4ZTIzYTA4NDExNDIxNDM5YTQ1MThkYTMxODgwY2VmMGZiYTdkNGRmMTJiMWE2OTczZWVjYjk0MjY2XCIsXG4gICAgICAgICAgXCI0MGE2YmYyMGU3NjY0MGIyYzkyYjk3YWZlNThjZDgyYzQzMmUxMGE3ZjUxNGQ5ZjNlZThiZTExYWUxYjI4ZWM4XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiNzc3OGE3OGMyOGRlYzNlMzBhMDVmZTk2MjlkZThjMzhiYjMwZDFmNWNmOWEzYTIwOGY3NjM4ODliZTU4YWQ3MVwiLFxuICAgICAgICAgIFwiMzQ2MjZkOWFiNWE1YjIyZmY3MDk4ZTEyZjJmZjU4MDA4N2IzODQxMWZmMjRhYzU2M2I1MTNmYzFmZDlmNDNhY1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjkyODk1NWVlNjM3YTg0NDYzNzI5ZmQzMGU3YWZkMmVkNWY5NjI3NGU1YWQ3ZTVjYjA5ZWRhOWMwNmQ5MDNhY1wiLFxuICAgICAgICAgIFwiYzI1NjIxMDAzZDNmNDJhODI3Yjc4YTEzMDkzYTk1ZWVhYzNkMjZlZmE4YThkODNmYzUxODBlOTM1YmNkMDkxZlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjg1ZDBmZWYzZWM2ZGIxMDkzOTkwNjRmM2EwZTNiMjg1NTY0NWI0YTkwN2FkMzU0NTI3YWFlNzUxNjNkODI3NTFcIixcbiAgICAgICAgICBcIjFmMDM2NDg0MTNhMzhjMGJlMjlkNDk2ZTU4MmNmNTY2M2U4NzUxZTk2ODc3MzMxNTgyYzIzN2EyNGViMWY5NjJcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJmZjJiMGRjZTk3ZWVjZTk3YzFjOWI2MDQxNzk4Yjg1ZGZkZmI2ZDg4ODJkYTIwMzA4ZjU0MDQ4MjQ1MjYwODdlXCIsXG4gICAgICAgICAgXCI0OTNkMTNmZWY1MjRiYTE4OGFmNGM0ZGM1NGQwNzkzNmM3YjdlZDZmYjkwZTJjZWIyYzk1MWUwMWYwYzI5OTA3XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiODI3ZmJiZTRiMWU4ODBlYTllZDJiMmU2MzAxYjIxMmI1N2YxZWUxNDhjZDZkZDI4NzgwZTVlMmNmODU2ZTI0MVwiLFxuICAgICAgICAgIFwiYzYwZjljOTIzYzcyN2IwYjcxYmVmMmM2N2QxZDEyNjg3ZmY3YTYzMTg2OTAzMTY2ZDYwNWI2OGJhZWMyOTNlY1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImVhYTY0OWYyMWY1MWJkYmFlN2JlNGFlMzRjZTZlNTIxN2E1OGZkY2U3ZjQ3ZjlhYTdmM2I1OGZhMjEyMGUyYjNcIixcbiAgICAgICAgICBcImJlMzI3OWVkNWJiYmIwM2FjNjlhODBmODk4NzlhYTVhMDFhNmI5NjVmMTNmN2U1OWQ0N2E1MzA1YmE1YWQ5M2RcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJlNGE0MmQ0M2M1Y2YxNjlkOTM5MWRmNmRlY2Y0MmVlNTQxYjZkOGYwYzlhMTM3NDAxZTIzNjMyZGRhMzRkMjRmXCIsXG4gICAgICAgICAgXCI0ZDlmOTJlNzE2ZDFjNzM1MjZmYzk5Y2NmYjhhZDM0Y2U4ODZlZWRmYThkOGU0ZjEzYTdmNzEzMWRlYmE5NDE0XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiMWVjODBmZWYzNjBjYmRkOTU0MTYwZmFkYWIzNTJiNmI5MmI1MzU3NmE4OGZlYTQ5NDcxNzNiOWQ0MzAwYmYxOVwiLFxuICAgICAgICAgIFwiYWVlZmU5Mzc1NmI1MzQwZDJmM2E0OTU4YTdhYmJmNWUwMTQ2ZTc3ZjYyOTVhMDdiNjcxY2RjMWNjMTA3Y2VmZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjE0NmE3NzhjMDQ2NzBjMmY5MWIwMGFmNDY4MGRmYThiY2UzNDkwNzE3ZDU4YmE4ODlkZGI1OTI4MzY2NjQyYmVcIixcbiAgICAgICAgICBcImIzMThlMGVjMzM1NDAyOGFkZDY2OTgyN2Y5ZDRiMjg3MGFhYTk3MWQyZjdlNWVkMWQwYjI5NzQ4M2Q4M2VmZDBcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJmYTUwYzBmNjFkMjJlNWYwN2UzYWNlYmIxYWEwN2IxMjhkMDAxMjIwOWEyOGI5Nzc2ZDc2YTg3OTMxODBlZWY5XCIsXG4gICAgICAgICAgXCI2Yjg0YzY5MjIzOTdlYmE5YjcyY2QyODcyMjgxYTY4YTVlNjgzMjkzYTU3YTIxM2IzOGNkOGQ3ZDNmNGYyODExXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZGExZDYxZDBjYTcyMWExMWIxYTViZjZiN2Q4OGU4NDIxYTI4OGFiNWQ1YmJhNTIyMGU1M2QzMmI1ZjA2N2VjMlwiLFxuICAgICAgICAgIFwiODE1N2Y1NWE3Yzk5MzA2Yzc5YzA3NjYxNjFjOTFlMjk2NmE3Mzg5OWQyNzliNDhhNjU1ZmJhMGYxYWQ4MzZmMVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImE4ZTI4MmZmMGM5NzA2OTA3MjE1ZmY5OGU4ZmQ0MTY2MTUzMTFkZTA0NDZmMWUwNjJhNzNiMDYxMGQwNjRlMTNcIixcbiAgICAgICAgICBcIjdmOTczNTViOGRiODFjMDlhYmZiN2YzYzViMjUxNTg4OGI2NzlhM2U1MGRkNmJkNmNlZjdjNzMxMTFmNGNjMGNcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCIxNzRhNTNiOWM5YTI4NTg3MmQzOWU1NmU2OTEzY2FiMTVkNTliMWZhNTEyNTA4YzAyMmYzODJkZTgzMTk0OTdjXCIsXG4gICAgICAgICAgXCJjY2M5ZGMzN2FiZmM5YzE2NTdiNDE1NWYyYzQ3ZjllNjY0NmIzYTFkOGNiOTg1NDM4M2RhMTNhYzA3OWFmYTczXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiOTU5Mzk2OTgxOTQzNzg1YzNkM2U1N2VkZjUwMThjZGJlMDM5ZTczMGU0OTE4YjNkODg0ZmRmZjA5NDc1YjdiYVwiLFxuICAgICAgICAgIFwiMmU3ZTU1Mjg4OGMzMzFkZDhiYTAzODZhNGI5Y2Q2ODQ5YzY1M2Y2NGM4NzA5Mzg1ZTliOGFiZjg3NTI0ZjJmZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImQyYTYzYTUwYWU0MDFlNTZkNjQ1YTExNTNiMTA5YThmY2NhMGE0M2Q1NjFmYmEyZGJiNTEzNDBjOWQ4MmIxNTFcIixcbiAgICAgICAgICBcImU4MmQ4NmZiNjQ0M2ZjYjc1NjVhZWU1OGIyOTQ4MjIwYTcwZjc1MGFmNDg0Y2E1MmQ0MTQyMTc0ZGNmODk0MDVcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI2NDU4N2UyMzM1NDcxZWI4OTBlZTc4OTZkN2NmZGM4NjZiYWNiZGJkMzgzOTMxN2IzNDM2ZjliNDU2MTdlMDczXCIsXG4gICAgICAgICAgXCJkOTlmY2RkNWJmNjkwMmUyYWU5NmRkNjQ0N2MyOTlhMTg1YjkwYTM5MTMzYWVhYjM1ODI5OWU1ZTlmYWY2NTg5XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiODQ4MWJkZTBlNGU0ZDg4NWIzYTU0NmQzZTU0OWRlMDQyZjBhYTZjZWEyNTBlN2ZkMzU4ZDZjODZkZDQ1ZTQ1OFwiLFxuICAgICAgICAgIFwiMzhlZTdiOGNiYTU0MDRkZDg0YTI1YmYzOWNlY2IyY2E5MDBhNzljNDJiMjYyZTU1NmQ2NGIxYjU5Nzc5MDU3ZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjEzNDY0YTU3YTc4MTAyYWE2MmI2OTc5YWU4MTdmNDYzN2ZmY2ZlZDNjNGIxY2UzMGJjZDYzMDNmNmNhZjY2NmJcIixcbiAgICAgICAgICBcIjY5YmUxNTkwMDQ2MTQ1ODBlZjdlNDMzNDUzY2NiMGNhNDhmMzAwYTgxZDA5NDJlMTNmNDk1YTkwN2Y2ZWNjMjdcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJiYzRhOWRmNWI3MTNmZTJlOWFlZjQzMGJjYzFkYzk3YTBjZDljY2VkZTJmMjg1ODhjYWRhM2EwZDJkODNmMzY2XCIsXG4gICAgICAgICAgXCJkM2E4MWNhNmU3ODVjMDYzODM5MzdhZGY0Yjc5OGNhYTZlOGE5ZmJmYTU0N2IxNmQ3NThkNjY2NTgxZjMzYzFcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI4YzI4YTk3YmY4Mjk4YmMwZDIzZDhjNzQ5NDUyYTMyZTY5NGI2NWUzMGE5NDcyYTM5NTRhYjMwZmU1MzI0Y2FhXCIsXG4gICAgICAgICAgXCI0MGEzMDQ2M2EzMzA1MTkzMzc4ZmVkZjMxZjdjYzBlYjdhZTc4NGYwNDUxY2I5NDU5ZTcxZGM3M2NiZWY5NDgyXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiOGVhOTY2NjEzOTUyN2E4YzFkZDk0Y2U0ZjA3MWZkMjNjOGIzNTBjNWE0YmIzMzc0OGM0YmExMTFmYWNjYWUwXCIsXG4gICAgICAgICAgXCI2MjBlZmFiYmM4ZWUyNzgyZTI0ZTdjMGNmYjk1YzVkNzM1Yjc4M2JlOWNmMGY4ZTk1NWFmMzRhMzBlNjJiOTQ1XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZGQzNjI1ZmFlZjViYTA2MDc0NjY5NzE2YmJkMzc4OGQ4OWJkZGU4MTU5NTk5NjgwOTJmNzZjYzRlYjlhOTc4N1wiLFxuICAgICAgICAgIFwiN2ExODhmYTM1MjBlMzBkNDYxZGEyNTAxMDQ1NzMxY2E5NDE0NjE5ODI4ODMzOTU5MzdmNjhkMDBjNjQ0YTU3M1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImY3MTBkNzlkOWViOTYyMjk3ZTRmNjIzMmI0MGU4ZjdmZWIyYmM2MzgxNDYxNGQ2OTJjMTJkZTc1MjQwODIyMWVcIixcbiAgICAgICAgICBcImVhOThlNjcyMzJkM2IzMjk1ZDNiNTM1NTMyMTE1Y2NhYzg2MTJjNzIxODUxNjE3NTI2YWU0N2E5Yzc3YmZjODJcIlxuICAgICAgICBdXG4gICAgICBdXG4gICAgfSxcbiAgICBuYWY6IHtcbiAgICAgIHduZDogNyxcbiAgICAgIHBvaW50czogW1xuICAgICAgICBbXG4gICAgICAgICAgXCJmOTMwOGEwMTkyNThjMzEwNDkzNDRmODVmODlkNTIyOWI1MzFjODQ1ODM2Zjk5YjA4NjAxZjExM2JjZTAzNmY5XCIsXG4gICAgICAgICAgXCIzODhmN2IwZjYzMmRlODE0MGZlMzM3ZTYyYTM3ZjM1NjY1MDBhOTk5MzRjMjIzMWI2Y2I5ZmQ3NTg0YjhlNjcyXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiMmY4YmRlNGQxYTA3MjA5MzU1YjRhNzI1MGE1YzUxMjhlODhiODRiZGRjNjE5YWI3Y2JhOGQ1NjliMjQwZWZlNFwiLFxuICAgICAgICAgIFwiZDhhYzIyMjYzNmU1ZTNkNmQ0ZGJhOWRkYTZjOWM0MjZmNzg4MjcxYmFiMGQ2ODQwZGNhODdkM2FhNmFjNjJkNlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjVjYmRmMDY0NmU1ZGI0ZWFhMzk4ZjM2NWYyZWE3YTBlM2Q0MTliN2UwMzMwZTM5Y2U5MmJkZGVkY2FjNGY5YmNcIixcbiAgICAgICAgICBcIjZhZWJjYTQwYmEyNTU5NjBhMzE3OGQ2ZDg2MWE1NGRiYTgxM2QwYjgxM2ZkZTdiNWE1MDgyNjI4MDg3MjY0ZGFcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJhY2Q0ODRlMmYwYzdmNjUzMDlhZDE3OGE5ZjU1OWFiZGUwOTc5Njk3NGM1N2U3MTRjMzVmMTEwZGZjMjdjY2JlXCIsXG4gICAgICAgICAgXCJjYzMzODkyMWIwYTdkOWZkNjQzODA5NzE3NjNiNjFlOWFkZDg4OGE0Mzc1ZjhlMGYwNWNjMjYyYWM2NGY5YzM3XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiNzc0YWU3Zjg1OGE5NDExZTVlZjQyNDZiNzBjNjVhYWM1NjQ5OTgwYmU1YzE3ODkxYmJlYzE3ODk1ZGEwMDhjYlwiLFxuICAgICAgICAgIFwiZDk4NGEwMzJlYjZiNWUxOTAyNDNkZDU2ZDdiN2IzNjUzNzJkYjFlMmRmZjlkNmE4MzAxZDc0YzljOTUzYzYxYlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImYyODc3M2MyZDk3NTI4OGJjN2QxZDIwNWMzNzQ4NjUxYjA3NWZiYzY2MTBlNThjZGRlZWRkZjhmMTk0MDVhYThcIixcbiAgICAgICAgICBcImFiMDkwMmU4ZDg4MGE4OTc1ODIxMmViNjVjZGFmNDczYTFhMDZkYTUyMWZhOTFmMjliNWNiNTJkYjAzZWQ4MVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImQ3OTI0ZDRmN2Q0M2VhOTY1YTQ2NWFlMzA5NWZmNDExMzFlNTk0NmYzYzg1Zjc5ZTQ0YWRiY2Y4ZTI3ZTA4MGVcIixcbiAgICAgICAgICBcIjU4MWUyODcyYTg2YzcyYTY4Mzg0MmVjMjI4Y2M2ZGVmZWE0MGFmMmJkODk2ZDNhNWM1MDRkYzlmZjZhMjZiNThcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJkZWZkZWE0Y2RiNjc3NzUwYTQyMGZlZTgwN2VhY2YyMWViOTg5OGFlNzliOTc2ODc2NmU0ZmFhMDRhMmQ0YTM0XCIsXG4gICAgICAgICAgXCI0MjExYWIwNjk0NjM1MTY4ZTk5N2IwZWFkMmE5M2RhZWNlZDFmNGEwNGE5NWMwZjZjZmIxOTlmNjllNTZlYjc3XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiMmI0ZWEwYTc5N2E0NDNkMjkzZWY1Y2ZmNDQ0ZjQ5NzlmMDZhY2ZlYmQ3ZTg2ZDI3NzQ3NTY1NjEzODM4NWI2Y1wiLFxuICAgICAgICAgIFwiODVlODliYzAzNzk0NWQ5M2IzNDMwODNiNWExYzg2MTMxYTAxZjYwYzUwMjY5NzYzYjU3MGM4NTRlNWMwOWI3YVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjM1MmJiZjRhNGNkZDEyNTY0ZjkzZmEzMzJjZTMzMzMwMWQ5YWQ0MDI3MWY4MTA3MTgxMzQwYWVmMjViZTU5ZDVcIixcbiAgICAgICAgICBcIjMyMWViNDA3NTM0OGY1MzRkNTljMTgyNTlkZGEzZTFmNGExYjNiMmU3MWIxMDM5YzY3YmQzZDhiY2Y4MTk5OGNcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCIyZmEyMTA0ZDZiMzhkMTFiMDIzMDAxMDU1OTg3OTEyNGU0MmFiOGRmZWZmNWZmMjlkYzljZGFkZDRlY2FjYzNmXCIsXG4gICAgICAgICAgXCIyZGUxMDY4Mjk1ZGQ4NjViNjQ1NjkzMzViZDVkZDgwMTgxZDcwZWNmYzg4MjY0ODQyM2JhNzZiNTMyYjdkNjdcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI5MjQ4Mjc5YjA5YjRkNjhkYWIyMWE5YjA2NmVkZGE4MzI2M2MzZDg0ZTA5NTcyZTI2OWNhMGNkN2Y1NDUzNzE0XCIsXG4gICAgICAgICAgXCI3MzAxNmY3YmYyMzRhYWRlNWQxYWE3MWJkZWEyYjFmZjNmYzBkZTJhODg3OTEyZmZlNTRhMzJjZTk3Y2IzNDAyXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZGFlZDRmMmJlM2E4YmYyNzhlNzAxMzJmYjBiZWI3NTIyZjU3MGUxNDRiZjYxNWMwN2U5OTZkNDQzZGVlODcyOVwiLFxuICAgICAgICAgIFwiYTY5ZGNlNGE3ZDZjOThlOGQ0YTFhY2E4N2VmOGQ3MDAzZjgzYzIzMGYzYWZhNzI2YWI0MGU1MjI5MGJlMWM1NVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImM0NGQxMmM3MDY1ZDgxMmU4YWNmMjhkN2NiYjE5ZjkwMTFlY2Q5ZTlmZGYyODFiMGU2YTNiNWU4N2QyMmU3ZGJcIixcbiAgICAgICAgICBcIjIxMTlhNDYwY2UzMjZjZGM3NmM0NTkyNmM5ODJmZGFjMGUxMDZlODYxZWRmNjFjNWEwMzkwNjNmMGUwZTY0ODJcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI2YTI0NWJmNmRjNjk4NTA0Yzg5YTIwY2ZkZWQ2MDg1MzE1MmI2OTUzMzZjMjgwNjNiNjFjNjVjYmQyNjllNmI0XCIsXG4gICAgICAgICAgXCJlMDIyY2Y0MmMyYmQ0YTcwOGIzZjUxMjZmMTZhMjRhZDhiMzNiYTQ4ZDA0MjNiNmVmZDVlNjM0ODEwMGQ4YTgyXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiMTY5N2ZmYTZmZDlkZTYyN2MwNzdlM2QyZmU1NDEwODRjZTEzMzAwYjBiZWMxMTQ2Zjk1YWU1N2YwZDBiZDZhNVwiLFxuICAgICAgICAgIFwiYjljMzk4ZjE4NjgwNmY1ZDI3NTYxNTA2ZTQ1NTc0MzNhMmNmMTUwMDllNDk4YWU3YWRlZTlkNjNkMDFiMjM5NlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjYwNWJkYjAxOTk4MTcxOGI5ODZkMGYwN2U4MzRjYjBkOWRlYjgzNjBmZmI3ZjYxZGY5ODIzNDVlZjI3YTc0NzlcIixcbiAgICAgICAgICBcIjI5NzJkMmRlNGY4ZDIwNjgxYTc4ZDkzZWM5NmZlMjNjMjZiZmFlODRmYjE0ZGI0M2IwMWUxZTkwNTZiOGM0OVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjYyZDE0ZGFiNDE1MGJmNDk3NDAyZmRjNDVhMjE1ZTEwZGNiMDFjMzU0OTU5YjEwY2ZlMzFjN2U5ZDg3ZmYzM2RcIixcbiAgICAgICAgICBcIjgwZmMwNmJkOGNjNWIwMTA5ODA4OGExOTUwZWVkMGRiMDFhYTEzMjk2N2FiNDcyMjM1ZjU2NDI0ODNiMjVlYWZcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI4MGM2MGFkMDA0MGYyN2RhZGU1YjRiMDZjNDA4ZTU2YjJjNTBlOWY1NmI5YjhiNDI1ZTU1NWMyZjg2MzA4YjZmXCIsXG4gICAgICAgICAgXCIxYzM4MzAzZjFjYzVjMzBmMjZlNjZiYWQ3ZmU3MmY3MGE2NWVlZDRjYmU3MDI0ZWIxYWEwMWY1NjQzMGJkNTdhXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiN2E5Mzc1YWQ2MTY3YWQ1NGFhNzRjNjM0OGNjNTRkMzQ0Y2M1ZGM5NDg3ZDg0NzA0OWQ1ZWFiYjBmYTAzYzhmYlwiLFxuICAgICAgICAgIFwiZDBlM2ZhOWVjYTg3MjY5MDk1NTllMGQ3OTI2OTA0NmJkYzU5ZWExMGM3MGNlMmIwMmQ0OTllYzIyNGRjN2Y3XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZDUyOGVjZDliNjk2YjU0YzkwN2E5ZWQwNDU0NDdhNzliYjQwOGVjMzliNjhkZjUwNGJiNTFmNDU5YmMzZmZjOVwiLFxuICAgICAgICAgIFwiZWVjZjQxMjUzMTM2ZTVmOTk5NjZmMjE4ODFmZDY1NmViYzQzNDU0MDVjNTIwZGJjMDYzNDY1YjUyMTQwOTkzM1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjQ5MzcwYTRiNWY0MzQxMmVhMjVmNTE0ZThlY2RhZDA1MjY2MTE1ZTRhN2VjYjEzODcyMzE4MDhmOGI0NTk2M1wiLFxuICAgICAgICAgIFwiNzU4ZjNmNDFhZmQ2ZWQ0MjhiMzA4MWIwNTEyZmQ2MmE1NGMzZjNhZmJiNWI2NzY0YjY1MzA1MmExMjk0OWM5YVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjc3ZjIzMDkzNmVlODhjYmJkNzNkZjkzMGQ2NDcwMmVmODgxZDgxMWUwZTE0OThlMmYxYzEzZWIxZmMzNDVkNzRcIixcbiAgICAgICAgICBcIjk1OGVmNDJhNzg4NmI2NDAwYTA4MjY2ZTliYTFiMzc4OTZjOTUzMzBkOTcwNzdjYmJlOGViM2M3NjcxYzYwZDZcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJmMmRhYzk5MWNjNGNlNGI5ZWE0NDg4N2U1YzdjMGJjZTU4YzgwMDc0YWI5ZDRkYmFlYjI4NTMxYjc3MzlmNTMwXCIsXG4gICAgICAgICAgXCJlMGRlZGM5YjNiMmY4ZGFkNGRhMWYzMmRlYzI1MzFkZjllYjVmYmViMDU5OGU0ZmQxYTExN2RiYTcwM2EzYzM3XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiNDYzYjNkOWY2NjI2MjFmYjFiNGJlOGZiYmUyNTIwMTI1YTIxNmNkZmM5ZGFlM2RlYmNiYTQ4NTBjNjkwZDQ1YlwiLFxuICAgICAgICAgIFwiNWVkNDMwZDc4YzI5NmMzNTQzMTE0MzA2ZGQ4NjIyZDdjNjIyZTI3Yzk3MGExZGUzMWNiMzc3YjAxYWY3MzA3ZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImYxNmY4MDQyNDRlNDZlMmEwOTIzMmQ0YWZmM2I1OTk3NmI5OGZhYzE0MzI4YTJkMWEzMjQ5NmI0OTk5OGYyNDdcIixcbiAgICAgICAgICBcImNlZGFiZDliODIyMDNmN2UxM2QyMDZmY2RmNGUzM2Q5MmE2YzUzYzI2ZTVjY2UyNmQ2NTc5OTYyYzRlMzFkZjZcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJjYWY3NTQyNzJkYzg0NTYzYjAzNTJiN2ExNDMxMWFmNTVkMjQ1MzE1YWNlMjdjNjUzNjllMTVmNzE1MWQ0MWQxXCIsXG4gICAgICAgICAgXCJjYjQ3NDY2MGVmMzVmNWYyYTQxYjY0M2ZhNWU0NjA1NzVmNGZhOWI3OTYyMjMyYTVjMzJmOTA4MzE4YTA0NDc2XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiMjYwMGNhNGIyODJjYjk4NmY4NWQwZjE3MDk5NzlkOGI0NGEwOWMwN2NiODZkN2MxMjQ0OTdiYzg2ZjA4MjEyMFwiLFxuICAgICAgICAgIFwiNDExOWI4ODc1M2MxNWJkNmE2OTNiMDNmY2RkYmI0NWQ1YWM2YmU3NGFiNWYwZWY0NGIwYmU5NDc1YTdlNGI0MFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjc2MzVjYTcyZDdlODQzMmMzMzhlYzUzY2QxMjIyMGJjMDFjNDg2ODVlMjRmN2RjOGM2MDJhNzc0Njk5OGU0MzVcIixcbiAgICAgICAgICBcIjkxYjY0OTYwOTQ4OWQ2MTNkMWQ1ZTU5MGY3OGU2ZDc0ZWNmYzA2MWQ1NzA0OGJhZDllNzZmMzAyYzViOWM2MVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjc1NGUzMjM5ZjMyNTU3MGNkYmJmNGE4N2RlZWU4YTY2YjdmMmIzMzQ3OWQ0NjhmYmMxYTUwNzQzYmY1NmNjMThcIixcbiAgICAgICAgICBcIjY3M2ZiODZlNWJkYTMwZmIzY2QwZWQzMDRlYTQ5YTAyM2VlMzNkMDE5N2E2OTVkMGM1ZDk4MDkzYzUzNjY4M1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImUzZTZiZDEwNzFhMWU5NmFmZjU3ODU5YzgyZDU3MGYwMzMwODAwNjYxZDFjOTUyZjlmZTI2OTQ2OTFkOWI5ZThcIixcbiAgICAgICAgICBcIjU5YzllMGJiYTM5NGU3NmY0MGMwYWE1ODM3OWEzY2I2YTVhMjI4Mzk5M2U5MGM0MTY3MDAyYWY0OTIwZTM3ZjVcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCIxODZiNDgzZDA1NmEwMzM4MjZhZTczZDg4ZjczMjk4NWM0Y2NiMWYzMmJhMzVmNGI0Y2M0N2ZkY2YwNGFhNmViXCIsXG4gICAgICAgICAgXCIzYjk1MmQzMmM2N2NmNzdlMmUxNzQ0NmUyMDQxODBhYjIxZmI4MDkwODk1MTM4YjRhNGE3OTdmODZlODA4ODhiXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZGY5ZDcwYTZiOTg3NmNlNTQ0Yzk4NTYxZjRiZTRmNzI1NDQyZTZkMmI3MzdkOWM5MWE4MzIxNzI0Y2UwOTYzZlwiLFxuICAgICAgICAgIFwiNTVlYjJkYWZkODRkNmNjZDVmODYyYjc4NWRjMzlkNGFiMTU3MjIyNzIwZWY5ZGEyMTdiOGM0NWNmMmJhMjQxN1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjVlZGQ1Y2MyM2M1MWU4N2E0OTdjYTgxNWQ1ZGNlMGY4YWI1MjU1NGY4NDllZDg5OTVkZTY0YzVmMzRjZTcxNDNcIixcbiAgICAgICAgICBcImVmYWU5YzhkYmMxNDEzMDY2MWU4Y2VjMDMwYzg5YWQwYzEzYzY2YzBkMTdhMjkwNWNkYzcwNmFiNzM5OWE4NjhcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCIyOTA3OThjMmI2NDc2ODMwZGExMmZlMDIyODdlOWU3NzdhYTNmYmExYzM1NWIxN2E3MjJkMzYyZjg0NjE0ZmJhXCIsXG4gICAgICAgICAgXCJlMzhkYTc2ZGNkNDQwNjIxOTg4ZDAwYmNmNzlhZjI1ZDViMjljMDk0ZGIyYTIzMTQ2ZDAwM2FmZDQxOTQzZTdhXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiYWYzYzQyM2E5NWQ5ZjViMzA1NDc1NGVmYTE1MGFjMzljZDI5NTUyZmUzNjAyNTczNjJkZmRlY2VmNDA1M2I0NVwiLFxuICAgICAgICAgIFwiZjk4YTNmZDgzMWViMmI3NDlhOTNiMGU2ZjM1Y2ZiNDBjOGNkNWFhNjY3YTE1NTgxYmMyZmVkZWQ0OThmZDljNlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjc2NmRiYjI0ZDEzNGU3NDVjY2NhYTI4Yzk5YmYyNzQ5MDZiYjY2YjI2ZGNmOThkZjhkMmZlZDUwZDg4NDI0OWFcIixcbiAgICAgICAgICBcIjc0NGIxMTUyZWFjYmU1ZTM4ZGNjODg3OTgwZGEzOGI4OTc1ODRhNjVmYTA2Y2VkZDJjOTI0Zjk3Y2JhYzU5OTZcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI1OWRiZjQ2ZjhjOTQ3NTliYTIxMjc3YzMzNzg0ZjQxNjQ1ZjdiNDRmNmM1OTZhNThjZTkyZTY2NjE5MWFiZTNlXCIsXG4gICAgICAgICAgXCJjNTM0YWQ0NDE3NWZiYzMwMGY0ZWE2Y2U2NDgzMDlhMDQyY2U3MzlhNzkxOTc5OGNkODVlMjE2YzRhMzA3ZjZlXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZjEzYWRhOTUxMDNjNDUzNzMwNWU2OTFlNzRlOWE0YThkZDY0N2U3MTFhOTVlNzNjYjYyZGM2MDE4Y2ZkODdiOFwiLFxuICAgICAgICAgIFwiZTEzODE3YjQ0ZWUxNGRlNjYzYmY0YmM4MDgzNDFmMzI2OTQ5ZTIxYTZhNzVjMjU3MDc3ODQxOWJkYWY1NzMzZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjc3NTRiNGZhMGU4YWNlZDA2ZDQxNjdhMmM1OWNjYTRjZGExODY5YzA2ZWJhZGZiNjQ4ODU1MDAxNWE4ODUyMmNcIixcbiAgICAgICAgICBcIjMwZTkzZTg2NGU2NjlkODIyMjRiOTY3YzMwMjBiOGZhOGQxZTRlMzUwYjZjYmNjNTM3YTQ4YjU3ODQxMTYzYTJcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI5NDhkY2FkZjU5OTBlMDQ4YWEzODc0ZDQ2YWJlZjlkNzAxODU4Zjk1ZGU4MDQxZDJhNjgyOGM5OWUyMjYyNTE5XCIsXG4gICAgICAgICAgXCJlNDkxYTQyNTM3ZjZlNTk3ZDVkMjhhMzIyNGIxYmMyNWRmOTE1NGVmYmQyZWYxZDJjYmJhMmNhZTUzNDdkNTdlXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiNzk2MjQxNDQ1MGM3NmMxNjg5YzdiNDhmODIwMmVjMzdmYjIyNGNmNWFjMGJmYTE1NzAzMjhhOGEzZDdjNzdhYlwiLFxuICAgICAgICAgIFwiMTAwYjYxMGVjNGZmYjQ3NjBkNWMxZmMxMzNlZjZmNmIxMjUwN2EwNTFmMDRhYzU3NjBhZmE1YjI5ZGI4MzQzN1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjM1MTQwODc4MzQ5NjRiNTRiMTViMTYwNjQ0ZDkxNTQ4NWExNjk3NzIyNWI4ODQ3YmIwZGQwODUxMzdlYzQ3Y2FcIixcbiAgICAgICAgICBcImVmMGFmYmIyMDU2MjA1NDQ4ZTE2NTJjNDhlODEyN2ZjNjAzOWU3N2MxNWMyMzc4YjdlN2QxNWEwZGUyOTMzMTFcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJkM2NjMzBhZDZiNDgzZTRiYzc5Y2UyYzlkZDhiYzU0OTkzZTk0N2ViOGRmNzg3YjQ0Mjk0M2QzZjdiNTI3ZWFmXCIsXG4gICAgICAgICAgXCI4YjM3OGEyMmQ4MjcyNzhkODljNWU5YmU4Zjk1MDhhZTNjMmFkNDYyOTAzNTg2MzBhZmIzNGRiMDRlZWRlMGE0XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiMTYyNGQ4NDc4MDczMjg2MGNlMWM3OGZjYmZlZmUwOGIyYjI5ODIzZGI5MTNmNjQ5Mzk3NWJhMGZmNDg0NzYxMFwiLFxuICAgICAgICAgIFwiNjg2NTFjZjliNmRhOTAzZTA5MTQ0NDhjNmNkOWQ0Y2E4OTY4NzhmNTI4MmJlNGM4Y2MwNmUyYTQwNDA3ODU3NVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjczM2NlODBkYTk1NWE4YTI2OTAyYzk1NjMzZTYyYTk4NTE5MjQ3NGI1YWYyMDdkYTZkZjdiNGZkNWZjNjFjZDRcIixcbiAgICAgICAgICBcImY1NDM1YTJiZDJiYWRmN2Q0ODVhNGQ4YjhkYjlmY2NlM2UxZWY4ZTAyMDFlNDU3OGM1NDY3M2JjMWRjNWVhMWRcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCIxNWQ5NDQxMjU0OTQ1MDY0Y2YxYTFjMzNiYmQzYjQ5Zjg5NjZjNTA5MjE3MWU2OTllZjI1OGRmYWI4MWMwNDVjXCIsXG4gICAgICAgICAgXCJkNTZlYjMwYjY5NDYzZTcyMzRmNTEzN2I3M2I4NDE3NzQzNDgwMGJhY2ViZmM2ODVmYzM3YmJlOWVmZTQwNzBkXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiYTFkMGZjZjJlYzlkZTY3NWI2MTIxMzZlNWNlNzBkMjcxYzIxNDE3YzlkMmI4YWFhYWMxMzg1OTlkMDcxNzk0MFwiLFxuICAgICAgICAgIFwiZWRkNzdmNTBiY2I1YTNjYWIyZTkwNzM3MzA5NjY3ZjI2NDE0NjJhNTQwNzBmM2Q1MTkyMTJkMzljMTk3YTYyOVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImUyMmZiZTE1YzBhZjhjY2M1NzgwYzA3MzVmODRkYmU5YTc5MGJhZGVlODI0NWMwNmM3Y2EzNzMzMWNiMzY5ODBcIixcbiAgICAgICAgICBcImE4NTViYWJhZDVjZDYwYzg4YjQzMGE2OWY1M2ExYTdhMzgyODkxNTQ5NjQ3OTliZTQzZDA2ZDc3ZDMxZGEwNlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjMxMTA5MWRkOTg2MGU4ZTIwZWUxMzQ3M2MxMTU1ZjVmNjk2MzVlMzk0NzA0ZWFhNzQwMDk0NTIyNDZjZmE5YjNcIixcbiAgICAgICAgICBcIjY2ZGI2NTZmODdkMWYwNGZmZmQxZjA0Nzg4YzA2ODMwODcxZWM1YTY0ZmVlZTY4NWJkODBmMGIxMjg2ZDgzNzRcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCIzNGMxZmQwNGQzMDFiZTg5YjMxYzA0NDJkM2U2YWMyNDg4MzkyOGI0NWE5MzQwNzgxODY3ZDQyMzJlYzJkYmRmXCIsXG4gICAgICAgICAgXCI5NDE0Njg1ZTk3YjFiNTk1NGJkNDZmNzMwMTc0MTM2ZDU3ZjFjZWViNDg3NDQzZGM1MzIxODU3YmE3M2FiZWVcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJmMjE5ZWE1ZDZiNTQ3MDFjMWMxNGRlNWI1NTdlYjQyYThkMTNmM2FiYmNkMDhhZmZjYzJhNWU2YjA0OWI4ZDYzXCIsXG4gICAgICAgICAgXCI0Y2I5NTk1N2U4M2Q0MGIwZjczYWY0NTQ0Y2NjZjZiMWY0YjA4ZDNjMDdiMjdmYjhkOGMyOTYyYTQwMDc2NmQxXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZDdiODc0MGY3NGE4ZmJhYWIxZjY4M2RiOGY0NWRlMjY1NDNhNTQ5MGJjYTYyNzA4NzIzNjkxMjQ2OWEwYjQ0OFwiLFxuICAgICAgICAgIFwiZmE3Nzk2ODEyOGQ5YzkyZWUxMDEwZjMzN2FkNDcxN2VmZjE1ZGI1ZWQzYzA0OWIzNDExZTAzMTVlYWE0NTkzYlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjMyZDMxYzIyMmY4ZjZmMGVmODZmN2M5OGQzYTMzMzVlYWQ1YmNkMzJhYmRkOTQyODlmZTRkMzA5MWFhODI0YmZcIixcbiAgICAgICAgICBcIjVmMzAzMmY1ODkyMTU2ZTM5Y2NkM2Q3OTE1YjllMWRhMmU2ZGFjOWU2ZjI2ZTk2MTExOGQxNGI4NDYyZTE2NjFcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI3NDYxZjM3MTkxNGFiMzI2NzEwNDVhMTU1ZDk4MzFlYTg3OTNkNzdjZDU5NTkyYzQzNDBmODZjYmMxODM0N2I1XCIsXG4gICAgICAgICAgXCI4ZWMwYmEyMzhiOTZiZWMwY2JkZGRjYWUwYWE0NDI1NDJlZWUxZmY1MGM5ODZlYTZiMzk4NDdiM2NjMDkyZmY2XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZWUwNzlhZGIxZGYxODYwMDc0MzU2YTI1YWEzODIwNmE2ZDcxNmIyYzNlNjc0NTNkMjg3Njk4YmFkN2IyYjJkNlwiLFxuICAgICAgICAgIFwiOGRjMjQxMmFhZmUzYmU1YzRjNWYzN2UwZWNjNWY5ZjZhNDQ2OTg5YWYwNGM0ZTI1ZWJhYWM0NzllYzFjOGMxZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjE2ZWM5M2U0NDdlYzgzZjA0NjdiMTgzMDJlZTYyMGY3ZTY1ZGUzMzE4NzRjOWRjNzJiZmQ4NjE2YmE5ZGE2YjVcIixcbiAgICAgICAgICBcIjVlNDYzMTE1MGU2MmZiNDBkMGU4YzJhN2NhNTgwNGEzOWQ1ODE4NmE1MGU0OTcxMzk2MjY3NzhlMjViMDY3NGRcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJlYWE1Zjk4MGMyNDVmNmYwMzg5NzgyOTBhZmE3MGI2YmQ4ODU1ODk3Zjk4YjZhYTQ4NWI5NjA2NWQ1MzdiZDk5XCIsXG4gICAgICAgICAgXCJmNjVmNWQzZTI5MmMyZTA4MTlhNTI4MzkxYzk5NDYyNGQ3ODQ4NjlkN2U2ZWE2N2ZiMTgwNDEwMjRlZGMwN2RjXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiNzhjOTQwNzU0NGFjMTMyNjkyZWUxOTEwYTAyNDM5OTU4YWUwNDg3NzE1MTM0MmVhOTZjNGI2YjM1YTQ5ZjUxXCIsXG4gICAgICAgICAgXCJmM2UwMzE5MTY5ZWI5Yjg1ZDU0MDQ3OTU1MzlhNWU2OGZhMWZiZDU4M2MwNjRkMjQ2MmI2NzVmMTk0YTNkZGI0XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiNDk0ZjRiZTIxOWExYTc3MDE2ZGNkODM4NDMxYWVhMDAwMWNkYzhhZTdhNmZjNjg4NzI2NTc4ZDk3MDI4NTdhNVwiLFxuICAgICAgICAgIFwiNDIyNDJhOTY5MjgzYTVmMzM5YmE3ZjA3NWUzNmJhMmFmOTI1Y2UzMGQ3NjdlZDZlNTVmNGIwMzE4ODBkNTYyY1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImE1OThhODAzMGRhNmQ4NmM2YmM3ZjJmNTE0NGVhNTQ5ZDI4MjExZWE1OGZhYTcwZWJmNGMxZTY2NWMxZmU5YjVcIixcbiAgICAgICAgICBcIjIwNGI1ZDZmODQ4MjJjMzA3ZTRiNGE3MTQwNzM3YWVjMjNmYzYzYjY1YjM1Zjg2YTEwMDI2ZGJkMmQ4NjRlNmJcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJjNDE5MTYzNjVhYmIyYjVkMDkxOTJmNWYyZGJlYWZlYzIwOGYwMjBmMTI1NzBhMTg0ZGJhZGMzZTU4NTk1OTk3XCIsXG4gICAgICAgICAgXCI0ZjE0MzUxZDAwODdlZmE0OWQyNDViMzI4OTg0OTg5ZDVjYWY5NDUwZjM0YmZjMGVkMTZlOTZiNThmYTk5MTNcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI4NDFkNjA2M2E1ODZmYTQ3NWE3MjQ2MDRkYTAzYmM1YjkyYTJlMGQyZTBhMzZhY2ZlNGM3M2E1NTE0NzQyODgxXCIsXG4gICAgICAgICAgXCI3Mzg2N2Y1OWMwNjU5ZTgxOTA0ZjlhMWM3NTQzNjk4ZTYyNTYyZDY3NDRjMTY5Y2U3YTM2ZGUwMWE4ZDYxNTRcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI1ZTk1YmIzOTlhNjk3MWQzNzYwMjY5NDdmODliZGUyZjI4MmIzMzgxMDkyOGJlNGRlZDExMmFjNGQ3MGUyMGQ1XCIsXG4gICAgICAgICAgXCIzOWYyM2YzNjY4MDkwODViZWViZmM3MTE4MTMxMzc3NWE5OWM5YWVkN2Q4YmEzOGIxNjEzODRjNzQ2MDEyODY1XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiMzZlNDY0MWE1Mzk0OGZkNDc2YzM5ZjhhOTlmZDk3NGU1ZWMwNzU2NGI1MzE1ZDhiZjk5NDcxYmNhMGVmMmY2NlwiLFxuICAgICAgICAgIFwiZDI0MjRiMWIxYWJlNGViODE2NDIyN2IwODVjOWFhOTQ1NmVhMTM0OTNmZDU2M2UwNmZkNTFjZjU2OTRjNzhmY1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjMzNjU4MWVhN2JmYmJiMjkwYzE5MWEyZjUwN2E0MWNmNTY0Mzg0MjE3MGU5MTRmYWVhYjI3YzJjNTc5ZjcyNlwiLFxuICAgICAgICAgIFwiZWFkMTIxNjg1OTVmZTFiZTk5MjUyMTI5YjZlNTZiMzM5MWY3YWIxNDEwY2QxZTBlZjNkY2RjYWJkMmZkYTIyNFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjhhYjg5ODE2ZGFkZmQ2YjZhMWYyNjM0ZmNmMDBlYzg0MDM3ODEwMjVlZDY4OTBjNDg0OTc0MjcwNmJkNDNlZGVcIixcbiAgICAgICAgICBcIjZmZGNlZjA5ZjJmNmQwYTA0NGU2NTRhZWY2MjQxMzZmNTAzZDQ1OWMzZTg5ODQ1ODU4YTQ3YTkxMjljZGQyNGVcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCIxZTMzZjFhNzQ2YzljNTc3ODEzMzM0NGQ5Mjk5ZmNhYTIwYjA5MzhlOGFjZmYyNTQ0YmI0MDI4NGI4YzVmYjk0XCIsXG4gICAgICAgICAgXCI2MDY2MDI1N2RkMTFiM2FhOWM4ZWQ2MThkMjRlZGZmMjMwNmQzMjBmMWQwMzAxMGUzM2E3ZDIwNTdmM2IzYjZcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI4NWI3YzFkY2IzY2VjMWI3ZWU3ZjMwZGVkNzlkZDIwYTBlZDFmNGNjMThjYmNmY2ZhNDEwMzYxZmQ4ZjA4ZjMxXCIsXG4gICAgICAgICAgXCIzZDk4YTljZGQwMjZkZDQzZjM5MDQ4ZjI1YTg4NDdmNGZjYWZhZDE4OTVkN2E2MzNjNmZlZDNjMzVlOTk5NTExXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiMjlkZjlmYmQ4ZDllNDY1MDkyNzVmNGIxMjVkNmQ0NWQ3ZmJlOWEzYjg3OGE3YWY4NzJhMjgwMDY2MWFjNWY1MVwiLFxuICAgICAgICAgIFwiYjRjNGZlOTljNzc1YTYwNmUyZDg4NjIxNzkxMzlmZmRhNjFkYzg2MWMwMTllNTVjZDI4NzZlYjJhMjdkODRiXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiYTBiMWNhZTA2YjBhODQ3YTNmZWE2ZTY3MWFhZjhhZGZkZmU1OGNhMmY3NjgxMDVjODA4MmIyZTQ0OWZjZTI1MlwiLFxuICAgICAgICAgIFwiYWU0MzQxMDJlZGRlMDk1OGVjNGIxOWQ5MTdhNmEyOGU2YjcyZGExODM0YWZmMGU2NTBmMDQ5NTAzYTI5NmNmMlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjRlOGNlYWZiOWIzZTlhMTM2ZGM3ZmY2N2U4NDAyOTViNDk5ZGZiM2IyMTMzZTRiYTExM2YyZTRjMGUxMjFlNVwiLFxuICAgICAgICAgIFwiY2YyMTc0MTE4YzhiNmQ3YTRiNDhmNmQ1MzRjZTVjNzk0MjJjMDg2YTYzNDYwNTAyYjgyN2NlNjJhMzI2NjgzY1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImQyNGE0NGUwNDdlMTliNmY1YWZiODFjN2NhMmY2OTA4MGE1MDc2Njg5YTAxMDkxOWY0MjcyNWMyYjc4OWEzM2JcIixcbiAgICAgICAgICBcIjZmYjhkNTU5MWI0NjZmOGZjNjNkYjUwZjFjMGYxYzY5MDEzZjk5Njg4N2I4MjQ0ZDJjZGVjNDE3YWZlYThmYTNcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJlYTAxNjA2YTdhNmM5Y2RkMjQ5ZmRmY2ZhY2I5OTU4NDAwMWVkZDI4YWJiYWI3N2I1MTA0ZTk4ZThlM2IzNWQ0XCIsXG4gICAgICAgICAgXCIzMjJhZjQ5MDhjNzMxMmIwY2ZiZmUzNjlmN2E3YjNjZGI3ZDQ0OTRiYzI4MjM3MDBjZmQ2NTIxODhhM2VhOThkXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiYWY4YWRkYmYyYjY2MWM4YTZjNjMyODY1NWViOTY2NTEyNTIwMDdkOGM1ZWEzMWJlNGFkMTk2ZGU4Y2UyMTMxZlwiLFxuICAgICAgICAgIFwiNjc0OWU2N2MwMjliODVmNTJhMDM0ZWFmZDA5NjgzNmIyNTIwODE4NjgwZTI2YWM4ZjNkZmJjZGI3MTc0OTcwMFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImUzYWUxOTc0NTY2Y2EwNmNjNTE2ZDQ3ZTBmYjE2NWE2NzRhM2RhYmNmY2ExNWU3MjJmMGUzNDUwZjQ1ODg5XCIsXG4gICAgICAgICAgXCIyYWVhYmU3ZTQ1MzE1MTAxMTYyMTdmMDdiZjRkMDczMDBkZTk3ZTQ4NzRmODFmNTMzNDIwYTcyZWViMGJkNmE0XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiNTkxZWUzNTUzMTNkOTk3MjFjZjY5OTNmZmVkMWUzZTMwMTk5M2ZmM2VkMjU4ODAyMDc1ZWE4Y2VkMzk3ZTI0NlwiLFxuICAgICAgICAgIFwiYjBlYTU1OGExMTNjMzBiZWE2MGZjNDc3NTQ2MGM3OTAxZmYwYjA1M2QyNWNhMmJkZWVlOThmMWE0YmU1ZDE5NlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjExMzk2ZDU1ZmRhNTRjNDlmMTlhYTk3MzE4ZDhkYTYxZmE4NTg0ZTQ3YjA4NDk0NTA3N2NmMDMyNTViNTI5ODRcIixcbiAgICAgICAgICBcIjk5OGM3NGE4Y2Q0NWFjMDEyODlkNTgzM2E3YmViNDc0NGZmNTM2YjAxYjI1N2JlNGM1NzY3YmVhOTNlYTU3YTRcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCIzYzVkMmExYmEzOWM1YTE3OTAwMDA3MzhjOWUwYzQwYjhkY2RmZDU0Njg3NTRiNjQwNTU0MDE1N2UwMTdhYTdhXCIsXG4gICAgICAgICAgXCJiMjI4NDI3OTk5NWEzNGUyZjlkNGRlNzM5NmZjMThiODBmOWI4YjlmZGQyNzBmNjY2MWY3OWNhNGM4MWJkMjU3XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiY2M4NzA0YjhhNjBhMGRlZmEzYTk5YTcyOTlmMmU5YzNmYmMzOTVhZmIwNGFjMDc4NDI1ZWY4YTE3OTNjYzAzMFwiLFxuICAgICAgICAgIFwiYmRkNDYwMzlmZWVkMTc4ODFkMWUwODYyZGIzNDdmOGNmMzk1Yjc0ZmM0YmNkYzRlOTQwYjc0ZTNhYzFmMWIxM1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImM1MzNlNGY3ZWE4NTU1YWFjZDk3NzdhYzVjYWQyOWI5N2RkNGRlZmNjYzUzZWU3ZWEyMDQxMTliMjg4OWIxOTdcIixcbiAgICAgICAgICBcIjZmMGEyNTZiYzVlZmRmNDI5YTJmYjYyNDJmMWE0M2EyZDliOTI1YmI0YTRiM2EyNmJiOGUwZjQ1ZWI1OTYwOTZcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJjMTRmOGYyY2NiMjdkNmYxMDlmNmQwOGQwM2NjOTZhNjliYThjMzRlZWMwN2JiY2Y1NjZkNDhlMzNkYTY1OTNcIixcbiAgICAgICAgICBcImMzNTlkNjkyM2JiMzk4ZjdmZDQ0NzNlMTZmZTFjMjg0NzViNzQwZGQwOTgwNzVlNmMwZTg2NDkxMTNkYzNhMzhcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJhNmNiYzMwNDZiYzZhNDUwYmFjMjQ3ODlmYTE3MTE1YTRjOTczOWVkNzVmOGYyMWNlNDQxZjcyZTBiOTBlNmVmXCIsXG4gICAgICAgICAgXCIyMWFlN2Y0NjgwZTg4OWJiMTMwNjE5ZTJjMGY5NWEzNjBjZWI1NzNjNzA2MDMxMzk4NjJhZmQ2MTdmYTliOWZcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCIzNDdkNmQ5YTAyYzQ4OTI3ZWJmYjg2YzEzNTliMWNhZjEzMGEzYzAyNjdkMTFjZTYzNDRiMzlmOTlkNDNjYzM4XCIsXG4gICAgICAgICAgXCI2MGVhN2Y2MWEzNTM1MjRkMWM5ODdmNmVjZWM5MmYwODZkNTY1YWI2ODc4NzBjYjEyNjg5ZmYxZTMxYzc0NDQ4XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZGE2NTQ1ZDIxODFkYjhkOTgzZjdkY2IzNzVlZjU4NjZkNDdjNjdiMWJmMzFjOGNmODU1ZWY3NDM3YjcyNjU2YVwiLFxuICAgICAgICAgIFwiNDliOTY3MTVhYjY4NzhhNzllNzhmMDdjZTU2ODBjNWQ2NjczMDUxYjQ5MzViZDg5N2ZlYTgyNGI3N2RjMjA4YVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImM0MDc0N2NjOWQwMTJjYjFhMTNiODE0ODMwOWM2ZGU3ZWMyNWQ2OTQ1ZDY1NzE0NmI5ZDU5OTRiOGZlYjExMTFcIixcbiAgICAgICAgICBcIjVjYTU2MDc1M2JlMmExMmZjNmRlNmNhZjJjYjQ4OTU2NWRiOTM2MTU2Yjk1MTRlMWJiNWU4MzAzN2UwZmEyZDRcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI0ZTQyYzhlYzgyYzk5Nzk4Y2NmM2E2MTBiZTg3MGU3ODMzOGM3ZjcxMzM0OGJkMzRjODIwM2VmNDAzN2YzNTAyXCIsXG4gICAgICAgICAgXCI3NTcxZDc0ZWU1ZTBmYjkyYTdhOGIzM2EwNzc4MzM0MWE1NDkyMTQ0Y2M1NGJjYzQwYTk0NDczNjkzNjA2NDM3XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiMzc3NWFiNzA4OWJjNmFmODIzYWJhMmUxYWY3MGIyMzZkMjUxY2FkYjBjODY3NDMyODc1MjJhMWIzYjBkZWRlYVwiLFxuICAgICAgICAgIFwiYmU1MmQxMDdiY2ZhMDlkOGJjYjk3MzZhODI4Y2ZhN2ZhYzhkYjE3YmY3YTc2YTJjNDJhZDk2MTQwOTAxOGNmN1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImNlZTMxY2JmN2UzNGVjMzc5ZDk0ZmI4MTRkM2Q3NzVhZDk1NDU5NWQxMzE0YmE4ODQ2OTU5ZTNlODJmNzRlMjZcIixcbiAgICAgICAgICBcIjhmZDY0YTE0YzA2YjU4OWMyNmI5NDdhZTJiY2Y2YmZhMDE0OWVmMGJlMTRlZDRkODBmNDQ4YTAxYzQzYjFjNmRcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJiNGY5ZWFlYTA5YjY5MTc2MTlmNmVhNmE0ZWI1NDY0ZWZkZGI1OGZkNDViMWViZWZjZGMxYTAxZDA4YjQ3OTg2XCIsXG4gICAgICAgICAgXCIzOWU1Yzk5MjViNWE1NGIwNzQzM2E0ZjE4YzYxNzI2ZjhiYjEzMWMwMTJjYTU0MmViMjRhOGFjMDcyMDA2ODJhXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZDQyNjNkZmMzZDJkZjkyM2EwMTc5YTQ4OTY2ZDMwY2U4NGUyNTE1YWZjM2RjY2MxYjc3OTA3NzkyZWJjYzYwZVwiLFxuICAgICAgICAgIFwiNjJkZmFmMDdhMGY3OGZlYjMwZTMwZDYyOTU4NTNjZTE4OWUxMjc3NjBhZDZjZjdmYWUxNjRlMTIyYTIwOGQ1NFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjQ4NDU3NTI0ODIwZmE2NWE0ZjhkMzVlYjY5MzA4NTdjMDAzMmFjYzBhNGEyZGU0MjIyMzNlZWRhODk3NjEyYzRcIixcbiAgICAgICAgICBcIjI1YTc0OGFiMzY3OTc5ZDk4NzMzYzM4YTFmYTFjMmU3ZGM2Y2MwN2RiMmQ2MGE5YWU3YTc2YWFhNDliZDBmNzdcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJkZmVlZWYxODgxMTAxZjJjYjExNjQ0ZjNhMmFmZGZjMjA0NWUxOTkxOTE1MjkyM2YzNjdhMTc2N2MxMWNjZWRhXCIsXG4gICAgICAgICAgXCJlY2ZiNzA1NmNmMWRlMDQyZjk0MjBiYWIzOTY3OTNjMGMzOTBiZGU3NGI0YmJkZmYxNmE4M2FlMDlhOWE3NTE3XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiNmQ3ZWY2YjE3NTQzZjgzNzNjNTczZjQ0ZTFmMzg5ODM1ZDg5YmNiYzYwNjJjZWQzNmM4MmRmODNiOGZhZTg1OVwiLFxuICAgICAgICAgIFwiY2Q0NTBlYzMzNTQzODk4NmRmZWZhMTBjNTdmZWE5YmNjNTIxYTA5NTliMmQ4MGJiZjc0YjE5MGRjYTcxMmQxMFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImU3NTYwNWQ1OTEwMmE1YTI2ODQ1MDBkM2I5OTFmMmUzZjNjODhiOTMyMjU1NDcwMzVhZjI1YWY2NmUwNDU0MWZcIixcbiAgICAgICAgICBcImY1YzU0NzU0YThmNzFlZTU0MGI5YjQ4NzI4NDczZTMxNGY3MjlhYzUzMDhiMDY5MzgzNjA5OTBlMmJmYWQxMjVcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJlYjk4NjYwZjRjNGRmYWEwNmEyYmU0NTNkNTAyMGJjOTlhMGMyZTYwYWJlMzg4NDU3ZGQ0M2ZlZmIxZWQ2MjBjXCIsXG4gICAgICAgICAgXCI2Y2I5YTg4NzZkOWNiODUyMDYwOWFmM2FkZDI2Y2QyMGEwYTdjZDhhOTQxMTEzMWNlODVmNDQxMDAwOTkyMjNlXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiMTNlODdiMDI3ZDg1MTRkMzU5MzlmMmU2ODkyYjE5OTIyMTU0NTk2OTQxODg4MzM2ZGMzNTYzZTNiOGRiYTk0MlwiLFxuICAgICAgICAgIFwiZmVmNWEzYzY4MDU5YTZkZWM1ZDYyNDExNGJmMWU5MWFhYzJiOWRhNTY4ZDZhYmViMjU3MGQ1NTY0NmI4YWRmMVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImVlMTYzMDI2ZTlmZDZmZTAxN2MzOGYwNmE1YmU2ZmMxMjU0MjRiMzcxY2UyNzA4ZTdiZjQ0OTE2OTFlNTc2NGFcIixcbiAgICAgICAgICBcIjFhY2IyNTBmMjU1ZGQ2MWM0M2Q5NGNjYzY3MGQwZjU4ZjQ5YWUzZmExNWI5NjYyM2U1NDMwZGEwYWQ2YzYyYjJcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJiMjY4ZjVlZjlhZDUxZTRkNzhkZTNhNzUwYzJkYzg5YjFlNjI2ZDQzNTA1ODY3OTk5OTMyZTVkYjMzYWYzZDgwXCIsXG4gICAgICAgICAgXCI1ZjMxMGQ0YjNjOTliOWViYjE5Zjc3ZDQxYzFkZWUwMThjZjBkMzRmZDQxOTE2MTQwMDNlOTQ1YTEyMTZlNDIzXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZmYwN2YzMTE4YTlkZjAzNWU5ZmFkODVlYjZjN2JmZTQyYjAyZjAxY2E5OWNlZWEzYmY3ZmZkYmE5M2M0NzUwZFwiLFxuICAgICAgICAgIFwiNDM4MTM2ZDYwM2U4NThhM2E1YzQ0MGMzOGVjY2JhZGRjMWQyOTQyMTE0ZTJlZGRkNDc0MGQwOThjZWQxZjBkOFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjhkOGI5ODU1YzdjMDUyYTM0MTQ2ZmQyMGZmYjY1OGJlYTRiOWY2OWUwZDgyNWViZWMxNmU4YzNjZTJiNTI2YTFcIixcbiAgICAgICAgICBcImNkYjU1OWVlZGMyZDc5ZjkyNmJhZjQ0ZmI4NGVhNGQ0NGJjZjUwZmVlNTFkN2NlYjMwZTJlN2Y0NjMwMzY3NThcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI1MmRiMGI1Mzg0ZGZiZjA1YmZhOWQ0NzJkN2FlMjZkZmU0Yjg1MWNlY2E5MWIxZWJhNTQyNjMxODBkYTMyYjYzXCIsXG4gICAgICAgICAgXCJjM2I5OTdkMDUwZWU1ZDQyM2ViYWY2NmE2ZGI5ZjU3YjMxODBjOTAyODc1Njc5ZGU5MjRiNjlkODRhN2IzNzVcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJlNjJmOTQ5MGQzZDUxZGE2Mzk1ZWZkMjRlODA5MTljYzdkMGYyOWMzZjNmYTQ4YzZmZmY1NDNiZWNiZDQzMzUyXCIsXG4gICAgICAgICAgXCI2ZDg5YWQ3YmE0ODc2YjBiMjJjMmNhMjgwYzY4Mjg2MmYzNDJjODU5MWYxZGFmNTE3MGUwN2JmZDljY2FmYTdkXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiN2YzMGVhMjQ3NmIzOTliNDk1NzUwOWM4OGY3N2QwMTkxYWZhMmZmNWNiN2IxNGZkNmQ4ZTdkNjVhYWFiMTE5M1wiLFxuICAgICAgICAgIFwiY2E1ZWY3ZDRiMjMxYzk0YzNiMTUzODlhNWY2MzExZTlkYWZmN2JiNjdiMTAzZTk4ODBlZjRiZmY2MzdhY2FlY1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjUwOThmZjFlMWQ5ZjE0ZmI0NmEyMTBmYWRhNmM5MDNmZWYwZmI3YjRhMWRkMWQ5YWM2MGEwMzYxODAwYjdhMDBcIixcbiAgICAgICAgICBcIjk3MzExNDFkODFmYzhmODA4NGQzN2M2ZTc1NDIwMDZiM2VlMWI0MGQ2MGRmZTUzNjJhNWIxMzJmZDE3ZGRjMFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjMyYjc4YzdkZTllZTUxMmE3Mjg5NWJlNmI5Y2JlZmE2ZTJmM2M0Y2NjZTQ0NWM5NmI5ZjJjODFlMjc3OGFkNThcIixcbiAgICAgICAgICBcImVlMTg0OWY1MTNkZjcxZTMyZWZjMzg5NmVlMjgyNjBjNzNiYjgwNTQ3YWUyMjc1YmE0OTcyMzc3OTRjODc1M2NcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJlMmNiNzRmZGRjOGU5ZmJjZDA3NmVlZjJhN2M3MmIwY2UzN2Q1MGYwODI2OWRmYzA3NGI1ODE1NTA1NDdhNGY3XCIsXG4gICAgICAgICAgXCJkM2FhMmVkNzFjOWRkMjI0N2E2MmRmMDYyNzM2ZWIwYmFkZGVhOWUzNjEyMmQyYmU4NjQxYWJjYjAwNWNjNGE0XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiODQzODQ0NzU2NmQ0ZDdiZWRhZGMyOTk0OTZhYjM1NzQyNjAwOWEzNWYyMzVjYjE0MWJlMGQ5OWNkMTBhZTNhOFwiLFxuICAgICAgICAgIFwiYzRlMTAyMDkxNjk4MGE0ZGE1ZDAxYWM1ZTZhZDMzMDczNGVmMGQ3OTA2NjMxYzRmMjM5MDQyNmIyZWRkNzkxZlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjQxNjJkNDg4Yjg5NDAyMDM5YjU4NGM2ZmM2YzMwODg3MDU4N2Q5YzQ2ZjY2MGI4NzhhYjY1YzgyYzcxMWQ2N2VcIixcbiAgICAgICAgICBcIjY3MTYzZTkwMzIzNjI4OWY3NzZmMjJjMjVmYjhhM2FmYzE3MzJmMmI4NGI0ZTk1ZGJkYTQ3YWU1YTA4NTI2NDlcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCIzZmFkM2ZhODRjYWYwZjM0ZjBmODliZmQyZGNmNTRmYzE3NWQ3NjdhZWMzZTUwNjg0ZjNiYTRhNGJmNWY2ODNkXCIsXG4gICAgICAgICAgXCJjZDFiYzdjYjZjYzQwN2JiMmYwY2E2NDdjNzE4YTczMGNmNzE4NzJlN2QwZDJhNTNmYTIwZWZjZGZlNjE4MjZcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI2NzRmMjYwMGEzMDA3YTAwNTY4YzFhN2NlMDVkMDgxNmMxZmI4NGJmMTM3MDc5OGYxYzY5NTMyZmFlYjFhODZiXCIsXG4gICAgICAgICAgXCIyOTlkMjFmOTQxM2YzM2IzZWRmNDNiMjU3MDA0NTgwYjcwZGI1N2RhMGIxODIyNTllMDllZWNjNjllMGQzOGE1XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZDMyZjRkYTU0YWRlNzRhYmI4MWI4MTVhZDFmYjNiMjYzZDgyZDZjNjkyNzE0YmNmZjg3ZDI5YmQ1ZWU5ZjA4ZlwiLFxuICAgICAgICAgIFwiZjk0MjllNzM4YjhlNTNiOTY4ZTk5MDE2YzA1OTcwNzc4MmUxNGY0NTM1MzU5ZDU4MmZjNDE2OTEwYjNlZWE4N1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjMwZTRlNjcwNDM1Mzg1NTU2ZTU5MzY1NzEzNTg0NWQzNmZiYjY5MzFmNzJiMDhjYjFlZDk1NGYxZTNjZTNmZjZcIixcbiAgICAgICAgICBcIjQ2MmY5YmNlNjE5ODk4NjM4NDk5MzUwMTEzYmJjOWIxMGE4NzhkMzVkYTcwNzQwZGM2OTVhNTU5ZWI4OGRiN2JcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJiZTIwNjIwMDNjNTFjYzMwMDQ2ODI5MDQzMzBlNGRlZTdmM2RjZDEwYjAxZTU4MGJmMTk3MWIwNGQ0Y2FkMjk3XCIsXG4gICAgICAgICAgXCI2MjE4OGJjNDlkNjFlNTQyODU3M2Q0OGE3NGUxYzY1NWIxYzYxMDkwOTA1NjgyYTBkNTU1OGVkNzJkY2NiOWJjXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiOTMxNDQ0MjNhY2UzNDUxZWQyOWUwZmI5YWMyYWYyMTFjYjZlODRhNjAxZGY1OTkzYzQxOTg1OWZmZjVkZjA0YVwiLFxuICAgICAgICAgIFwiN2MxMGRmYjE2NGMzNDI1ZjVjNzFhM2Y5ZDc5OTIwMzhmMTA2NTIyNGY3MmJiOWQxZDkwMmE2ZDEzMDM3YjQ3Y1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcImIwMTVmODA0NGY1ZmNiZGNmMjFjYTI2ZDZjMzRmYjgxOTc4MjkyMDVjN2I3ZDJhN2NiNjY0MThjMTU3YjExMmNcIixcbiAgICAgICAgICBcImFiOGMxZTA4NmQwNGU4MTM3NDRhNjU1YjJkZjhkNWY4M2IzY2RjNmZhYTMwODhjMWQzYWVhMTQ1NGUzYTFkNWZcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCJkNWU5ZTFkYTY0OWQ5N2Q4OWU0ODY4MTE3YTQ2NWEzYTRmOGExOGRlNTdhMTQwZDM2YjNmMmFmMzQxYTIxYjUyXCIsXG4gICAgICAgICAgXCI0Y2IwNDQzN2YzOTFlZDczMTExYTEzY2MxZDRkZDBkYjE2OTM0NjVjMjI0MDQ4MGQ4OTU1ZTg1OTJmMjc0NDdhXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiZDNhZTQxMDQ3ZGQ3Y2EwNjVkYmY4ZWQ3N2I5OTI0Mzk5ODMwMDVjZDcyZTE2ZDZmOTk2YTUzMTZkMzY5NjZiYlwiLFxuICAgICAgICAgIFwiYmQxYWViMjFhZDIyZWJiMjJhMTBmMDMwMzQxN2M2ZDk2NGY4Y2RkN2RmMGFjYTYxNGIxMGRjMTRkMTI1YWM0NlwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjQ2M2UyNzYzZDg4NWY5NThmYzY2Y2RkMjI4MDBmMGE0ODcxOTdkMGE4MmUzNzdiNDlmODBhZjg3Yzg5N2IwNjVcIixcbiAgICAgICAgICBcImJmZWZhY2RiMGU1ZDBmZDdkZjNhMzExYTk0ZGUwNjJiMjZiODBjNjFmYmM5NzUwOGI3OTk5MjY3MWVmN2NhN2ZcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI3OTg1ZmRmZDEyN2MwNTY3YzZmNTNlYzFiYjYzZWMzMTU4ZTU5N2M0MGJmZTc0N2M4M2NkZGZjOTEwNjQxOTE3XCIsXG4gICAgICAgICAgXCI2MDNjMTJkYWYzZDk4NjJlZjJiMjVmZTFkZTI4OWFlZDI0ZWQyOTFlMGVjNjcwODcwM2E1YmQ1NjdmMzJlZDAzXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiNzRhMWFkNmI1Zjc2ZTM5ZGIyZGQyNDk0MTBlYWM3Zjk5ZTc0YzU5Y2I4M2QyZDBlZDVmZjE1NDNkYTc3MDNlOVwiLFxuICAgICAgICAgIFwiY2M2MTU3ZWYxOGM5YzYzY2Q2MTkzZDgzNjMxYmJlYTAwOTNlMDk2ODk0MmU4YzMzZDU3MzdmZDc5MGUwZGIwOFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjMwNjgyYTUwNzAzMzc1ZjYwMmQ0MTY2NjRiYTE5YjdmYzliYWI0MmM3Mjc0NzQ2M2E3MWQwODk2YjIyZjZkYTNcIixcbiAgICAgICAgICBcIjU1M2UwNGY2YjAxOGI0ZmE2YzhmMzllN2YzMTFkMzE3NjI5MGQwZTBmMTljYTczZjE3NzE0ZDk5NzdhMjJmZjhcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCI5ZTIxNThmMGQ3YzBkNWYyNmMzNzkxZWZlZmE3OTU5NzY1NGU3YTJiMjQ2NGY1MmIxZWU2YzEzNDc3NjllZjU3XCIsXG4gICAgICAgICAgXCI3MTJmY2RkMWI5MDUzZjA5MDAzYTM0ODFmYTc3NjJlOWZmZDdjOGVmMzVhMzg1MDllMmZiZjI2MjkwMDgzNzNcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCIxNzZlMjY5ODlhNDNjOWNmZWJhNDAyOWMyMDI1MzhjMjgxNzJlNTY2ZTNjNGZjZTczMjI4NTdmM2JlMzI3ZDY2XCIsXG4gICAgICAgICAgXCJlZDhjYzlkMDRiMjllYjg3N2QyNzBiNDg3OGRjNDNjMTlhZWZkMzFmNGVlZTA5ZWU3YjQ3ODM0YzFmYTRiMWMzXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwiNzVkNDZlZmVhMzc3MWU2ZTY4YWJiODlhMTNhZDc0N2VjZjE4OTIzOTNkZmM0ZjFiNzAwNDc4OGM1MDM3NGRhOFwiLFxuICAgICAgICAgIFwiOTg1MjM5MGE5OTUwNzY3OWZkMGI4NmZkMmIzOWE4NjhkN2VmYzIyMTUxMzQ2ZTFhM2NhNDcyNjU4NmE2YmVkOFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBcIjgwOWEyMGM2N2Q2NDkwMGZmYjY5OGM0YzgyNWY2ZDVmMjMxMGZiMDQ1MWM4NjkzNDViNzMxOWY2NDU2MDU3MjFcIixcbiAgICAgICAgICBcIjllOTk0OTgwZDk5MTdlMjJiNzZiMDYxOTI3ZmEwNDE0M2QwOTZjY2M1NDk2M2U2YTVlYmZhNWYzZjhlMjg2YzFcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgXCIxYjM4OTAzYTQzZjdmMTE0ZWQ0NTAwYjRlYWM3MDgzZmRlZmVjZTFjZjI5YzYzNTI4ZDU2MzQ0NmY5NzJjMTgwXCIsXG4gICAgICAgICAgXCI0MDM2ZWRjOTMxYTYwYWU4ODkzNTNmNzdmZDUzZGU0YTI3MDhiMjZiNmY1ZGE3MmFkMzM5NDExOWRhZjQwOGY5XCJcbiAgICAgICAgXVxuICAgICAgXVxuICAgIH1cbiAgfSksIFlhO1xufVxuKGZ1bmN0aW9uKHIpIHtcbiAgdmFyIGUgPSByLCB0ID0gbnMsIGkgPSBZbywgbiA9IGFyLCBzID0gbi5hc3NlcnQ7XG4gIGZ1bmN0aW9uIG8oZCkge1xuICAgIGQudHlwZSA9PT0gXCJzaG9ydFwiID8gdGhpcy5jdXJ2ZSA9IG5ldyBpLnNob3J0KGQpIDogZC50eXBlID09PSBcImVkd2FyZHNcIiA/IHRoaXMuY3VydmUgPSBuZXcgaS5lZHdhcmRzKGQpIDogdGhpcy5jdXJ2ZSA9IG5ldyBpLm1vbnQoZCksIHRoaXMuZyA9IHRoaXMuY3VydmUuZywgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uLCB0aGlzLmhhc2ggPSBkLmhhc2gsIHModGhpcy5nLnZhbGlkYXRlKCksIFwiSW52YWxpZCBjdXJ2ZVwiKSwgcyh0aGlzLmcubXVsKHRoaXMubikuaXNJbmZpbml0eSgpLCBcIkludmFsaWQgY3VydmUsIEcqTiAhPSBPXCIpO1xuICB9XG4gIGUuUHJlc2V0Q3VydmUgPSBvO1xuICBmdW5jdGlvbiBmKGQsIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgZCwge1xuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHcgPSBuZXcgbyh2KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBkLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICB2YWx1ZTogd1xuICAgICAgICB9KSwgdztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmKFwicDE5MlwiLCB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIHByaW1lOiBcInAxOTJcIixcbiAgICBwOiBcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmXCIsXG4gICAgYTogXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmY1wiLFxuICAgIGI6IFwiNjQyMTA1MTkgZTU5YzgwZTcgMGZhN2U5YWIgNzIyNDMwNDkgZmViOGRlZWMgYzE0NmI5YjFcIixcbiAgICBuOiBcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDk5ZGVmODM2IDE0NmJjOWIxIGI0ZDIyODMxXCIsXG4gICAgaGFzaDogdC5zaGEyNTYsXG4gICAgZ1JlZDogITEsXG4gICAgZzogW1xuICAgICAgXCIxODhkYTgwZSBiMDMwOTBmNiA3Y2JmMjBlYiA0M2ExODgwMCBmNGZmMGFmZCA4MmZmMTAxMlwiLFxuICAgICAgXCIwNzE5MmI5NSBmZmM4ZGE3OCA2MzEwMTFlZCA2YjI0Y2RkNSA3M2Y5NzdhMSAxZTc5NDgxMVwiXG4gICAgXVxuICB9KSwgZihcInAyMjRcIiwge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBwcmltZTogXCJwMjI0XCIsXG4gICAgcDogXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMVwiLFxuICAgIGE6IFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmVcIixcbiAgICBiOiBcImI0MDUwYTg1IDBjMDRiM2FiIGY1NDEzMjU2IDUwNDRiMGI3IGQ3YmZkOGJhIDI3MGIzOTQzIDIzNTVmZmI0XCIsXG4gICAgbjogXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmMTZhMiBlMGI4ZjAzZSAxM2RkMjk0NSA1YzVjMmEzZFwiLFxuICAgIGhhc2g6IHQuc2hhMjU2LFxuICAgIGdSZWQ6ICExLFxuICAgIGc6IFtcbiAgICAgIFwiYjcwZTBjYmQgNmJiNGJmN2YgMzIxMzkwYjkgNGEwM2MxZDMgNTZjMjExMjIgMzQzMjgwZDYgMTE1YzFkMjFcIixcbiAgICAgIFwiYmQzNzYzODggYjVmNzIzZmIgNGMyMmRmZTYgY2Q0Mzc1YTAgNWEwNzQ3NjQgNDRkNTgxOTkgODUwMDdlMzRcIlxuICAgIF1cbiAgfSksIGYoXCJwMjU2XCIsIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgcHJpbWU6IG51bGwsXG4gICAgcDogXCJmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZlwiLFxuICAgIGE6IFwiZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmNcIixcbiAgICBiOiBcIjVhYzYzNWQ4IGFhM2E5M2U3IGIzZWJiZDU1IDc2OTg4NmJjIDY1MWQwNmIwIGNjNTNiMGY2IDNiY2UzYzNlIDI3ZDI2MDRiXCIsXG4gICAgbjogXCJmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MVwiLFxuICAgIGhhc2g6IHQuc2hhMjU2LFxuICAgIGdSZWQ6ICExLFxuICAgIGc6IFtcbiAgICAgIFwiNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTZcIixcbiAgICAgIFwiNGZlMzQyZTIgZmUxYTdmOWIgOGVlN2ViNGEgN2MwZjllMTYgMmJjZTMzNTcgNmIzMTVlY2UgY2JiNjQwNjggMzdiZjUxZjVcIlxuICAgIF1cbiAgfSksIGYoXCJwMzg0XCIsIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgcHJpbWU6IG51bGwsXG4gICAgcDogXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZlwiLFxuICAgIGE6IFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmNcIixcbiAgICBiOiBcImIzMzEyZmE3IGUyM2VlN2U0IDk4OGUwNTZiIGUzZjgyZDE5IDE4MWQ5YzZlIGZlODE0MTEyIDAzMTQwODhmIDUwMTM4NzVhIGM2NTYzOThkIDhhMmVkMTlkIDJhODVjOGVkIGQzZWMyYWVmXCIsXG4gICAgbjogXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBjNzYzNGQ4MSBmNDM3MmRkZiA1ODFhMGRiMiA0OGIwYTc3YSBlY2VjMTk2YSBjY2M1Mjk3M1wiLFxuICAgIGhhc2g6IHQuc2hhMzg0LFxuICAgIGdSZWQ6ICExLFxuICAgIGc6IFtcbiAgICAgIFwiYWE4N2NhMjIgYmU4YjA1MzcgOGViMWM3MWUgZjMyMGFkNzQgNmUxZDNiNjIgOGJhNzliOTggNTlmNzQxZTAgODI1NDJhMzggNTUwMmYyNWQgYmY1NTI5NmMgM2E1NDVlMzggNzI3NjBhYjdcIixcbiAgICAgIFwiMzYxN2RlNGEgOTYyNjJjNmYgNWQ5ZTk4YmYgOTI5MmRjMjkgZjhmNDFkYmQgMjg5YTE0N2MgZTlkYTMxMTMgYjVmMGI4YzAgMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWZcIlxuICAgIF1cbiAgfSksIGYoXCJwNTIxXCIsIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgcHJpbWU6IG51bGwsXG4gICAgcDogXCIwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZlwiLFxuICAgIGE6IFwiMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmNcIixcbiAgICBiOiBcIjAwMDAwMDUxIDk1M2ViOTYxIDhlMWM5YTFmIDkyOWEyMWEwIGI2ODU0MGVlIGEyZGE3MjViIDk5YjMxNWYzIGI4YjQ4OTkxIDhlZjEwOWUxIDU2MTkzOTUxIGVjN2U5MzdiIDE2NTJjMGJkIDNiYjFiZjA3IDM1NzNkZjg4IDNkMmMzNGYxIGVmNDUxZmQ0IDZiNTAzZjAwXCIsXG4gICAgbjogXCIwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYSA1MTg2ODc4MyBiZjJmOTY2YiA3ZmNjMDE0OCBmNzA5YTVkMCAzYmI1YzliOCA4OTljNDdhZSBiYjZmYjcxZSA5MTM4NjQwOVwiLFxuICAgIGhhc2g6IHQuc2hhNTEyLFxuICAgIGdSZWQ6ICExLFxuICAgIGc6IFtcbiAgICAgIFwiMDAwMDAwYzYgODU4ZTA2YjcgMDQwNGU5Y2QgOWUzZWNiNjYgMjM5NWI0NDIgOWM2NDgxMzkgMDUzZmI1MjEgZjgyOGFmNjAgNmI0ZDNkYmEgYTE0YjVlNzcgZWZlNzU5MjggZmUxZGMxMjcgYTJmZmE4ZGUgMzM0OGIzYzEgODU2YTQyOWIgZjk3ZTdlMzEgYzJlNWJkNjZcIixcbiAgICAgIFwiMDAwMDAxMTggMzkyOTZhNzggOWEzYmMwMDQgNWM4YTVmYjQgMmM3ZDFiZDkgOThmNTQ0NDkgNTc5YjQ0NjggMTdhZmJkMTcgMjczZTY2MmMgOTdlZTcyOTkgNWVmNDI2NDAgYzU1MGI5MDEgM2ZhZDA3NjEgMzUzYzcwODYgYTI3MmMyNDAgODhiZTk0NzYgOWZkMTY2NTBcIlxuICAgIF1cbiAgfSksIGYoXCJjdXJ2ZTI1NTE5XCIsIHtcbiAgICB0eXBlOiBcIm1vbnRcIixcbiAgICBwcmltZTogXCJwMjU1MTlcIixcbiAgICBwOiBcIjdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWRcIixcbiAgICBhOiBcIjc2ZDA2XCIsXG4gICAgYjogXCIxXCIsXG4gICAgbjogXCIxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkXCIsXG4gICAgaGFzaDogdC5zaGEyNTYsXG4gICAgZ1JlZDogITEsXG4gICAgZzogW1xuICAgICAgXCI5XCJcbiAgICBdXG4gIH0pLCBmKFwiZWQyNTUxOVwiLCB7XG4gICAgdHlwZTogXCJlZHdhcmRzXCIsXG4gICAgcHJpbWU6IFwicDI1NTE5XCIsXG4gICAgcDogXCI3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkXCIsXG4gICAgYTogXCItMVwiLFxuICAgIGM6IFwiMVwiLFxuICAgIC8vIC0xMjE2NjUgKiAoMTIxNjY2XigtMSkpIChtb2QgUClcbiAgICBkOiBcIjUyMDM2Y2VlMmI2ZmZlNzMgOGNjNzQwNzk3Nzc5ZTg5OCAwMDcwMGE0ZDQxNDFkOGFiIDc1ZWI0ZGNhMTM1OTc4YTNcIixcbiAgICBuOiBcIjEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWRcIixcbiAgICBoYXNoOiB0LnNoYTI1NixcbiAgICBnUmVkOiAhMSxcbiAgICBnOiBbXG4gICAgICBcIjIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWFcIixcbiAgICAgIC8vIDQvNVxuICAgICAgXCI2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjU4XCJcbiAgICBdXG4gIH0pO1xuICB2YXIgaDtcbiAgdHJ5IHtcbiAgICBoID0gdzIoKTtcbiAgfSBjYXRjaCB7XG4gICAgaCA9IHZvaWQgMDtcbiAgfVxuICBmKFwic2VjcDI1NmsxXCIsIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgcHJpbWU6IFwiazI1NlwiLFxuICAgIHA6IFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmZcIixcbiAgICBhOiBcIjBcIixcbiAgICBiOiBcIjdcIixcbiAgICBuOiBcImZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGJhYWVkY2U2IGFmNDhhMDNiIGJmZDI1ZThjIGQwMzY0MTQxXCIsXG4gICAgaDogXCIxXCIsXG4gICAgaGFzaDogdC5zaGEyNTYsXG4gICAgLy8gUHJlY29tcHV0ZWQgZW5kb21vcnBoaXNtXG4gICAgYmV0YTogXCI3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlXCIsXG4gICAgbGFtYmRhOiBcIjUzNjNhZDRjYzA1YzMwZTBhNTI2MWMwMjg4MTI2NDVhMTIyZTIyZWEyMDgxNjY3OGRmMDI5NjdjMWIyM2JkNzJcIixcbiAgICBiYXNpczogW1xuICAgICAge1xuICAgICAgICBhOiBcIjMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1XCIsXG4gICAgICAgIGI6IFwiLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGE6IFwiMTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4XCIsXG4gICAgICAgIGI6IFwiMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTVcIlxuICAgICAgfVxuICAgIF0sXG4gICAgZ1JlZDogITEsXG4gICAgZzogW1xuICAgICAgXCI3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4XCIsXG4gICAgICBcIjQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjhcIixcbiAgICAgIGhcbiAgICBdXG4gIH0pO1xufSkobWEpO1xudmFyIF8yID0gbnMsIGtpID0gR28sIEd1ID0gWWk7XG5mdW5jdGlvbiB4aShyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiB4aSkpXG4gICAgcmV0dXJuIG5ldyB4aShyKTtcbiAgdGhpcy5oYXNoID0gci5oYXNoLCB0aGlzLnByZWRSZXNpc3QgPSAhIXIucHJlZFJlc2lzdCwgdGhpcy5vdXRMZW4gPSB0aGlzLmhhc2gub3V0U2l6ZSwgdGhpcy5taW5FbnRyb3B5ID0gci5taW5FbnRyb3B5IHx8IHRoaXMuaGFzaC5obWFjU3RyZW5ndGgsIHRoaXMuX3Jlc2VlZCA9IG51bGwsIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSBudWxsLCB0aGlzLksgPSBudWxsLCB0aGlzLlYgPSBudWxsO1xuICB2YXIgZSA9IGtpLnRvQXJyYXkoci5lbnRyb3B5LCByLmVudHJvcHlFbmMgfHwgXCJoZXhcIiksIHQgPSBraS50b0FycmF5KHIubm9uY2UsIHIubm9uY2VFbmMgfHwgXCJoZXhcIiksIGkgPSBraS50b0FycmF5KHIucGVycywgci5wZXJzRW5jIHx8IFwiaGV4XCIpO1xuICBHdShcbiAgICBlLmxlbmd0aCA+PSB0aGlzLm1pbkVudHJvcHkgLyA4LFxuICAgIFwiTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiBcIiArIHRoaXMubWluRW50cm9weSArIFwiIGJpdHNcIlxuICApLCB0aGlzLl9pbml0KGUsIHQsIGkpO1xufVxudmFyIHgyID0geGk7XG54aS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gIHZhciBuID0gZS5jb25jYXQodCkuY29uY2F0KGkpO1xuICB0aGlzLksgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KSwgdGhpcy5WID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIGZvciAodmFyIHMgPSAwOyBzIDwgdGhpcy5WLmxlbmd0aDsgcysrKVxuICAgIHRoaXMuS1tzXSA9IDAsIHRoaXMuVltzXSA9IDE7XG4gIHRoaXMuX3VwZGF0ZShuKSwgdGhpcy5fcmVzZWVkID0gMSwgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IDI4MTQ3NDk3NjcxMDY1Njtcbn07XG54aS5wcm90b3R5cGUuX2htYWMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBfMi5obWFjKHRoaXMuaGFzaCwgdGhpcy5LKTtcbn07XG54aS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikudXBkYXRlKFswXSk7XG4gIGUgJiYgKHQgPSB0LnVwZGF0ZShlKSksIHRoaXMuSyA9IHQuZGlnZXN0KCksIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKSwgZSAmJiAodGhpcy5LID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLnVwZGF0ZShbMV0pLnVwZGF0ZShlKS5kaWdlc3QoKSwgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpKTtcbn07XG54aS5wcm90b3R5cGUucmVzZWVkID0gZnVuY3Rpb24oZSwgdCwgaSwgbikge1xuICB0eXBlb2YgdCAhPSBcInN0cmluZ1wiICYmIChuID0gaSwgaSA9IHQsIHQgPSBudWxsKSwgZSA9IGtpLnRvQXJyYXkoZSwgdCksIGkgPSBraS50b0FycmF5KGksIG4pLCBHdShcbiAgICBlLmxlbmd0aCA+PSB0aGlzLm1pbkVudHJvcHkgLyA4LFxuICAgIFwiTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiBcIiArIHRoaXMubWluRW50cm9weSArIFwiIGJpdHNcIlxuICApLCB0aGlzLl91cGRhdGUoZS5jb25jYXQoaSB8fCBbXSkpLCB0aGlzLl9yZXNlZWQgPSAxO1xufTtcbnhpLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uKGUsIHQsIGksIG4pIHtcbiAgaWYgKHRoaXMuX3Jlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzZWVkIGlzIHJlcXVpcmVkXCIpO1xuICB0eXBlb2YgdCAhPSBcInN0cmluZ1wiICYmIChuID0gaSwgaSA9IHQsIHQgPSBudWxsKSwgaSAmJiAoaSA9IGtpLnRvQXJyYXkoaSwgbiB8fCBcImhleFwiKSwgdGhpcy5fdXBkYXRlKGkpKTtcbiAgZm9yICh2YXIgcyA9IFtdOyBzLmxlbmd0aCA8IGU7IClcbiAgICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCksIHMgPSBzLmNvbmNhdCh0aGlzLlYpO1xuICB2YXIgbyA9IHMuc2xpY2UoMCwgZSk7XG4gIHJldHVybiB0aGlzLl91cGRhdGUoaSksIHRoaXMuX3Jlc2VlZCsrLCBraS5lbmNvZGUobywgdCk7XG59O1xudmFyIEUyID0gbGksIFMyID0gYXIsIE1vID0gUzIuYXNzZXJ0O1xuZnVuY3Rpb24gVXQociwgZSkge1xuICB0aGlzLmVjID0gciwgdGhpcy5wcml2ID0gbnVsbCwgdGhpcy5wdWIgPSBudWxsLCBlLnByaXYgJiYgdGhpcy5faW1wb3J0UHJpdmF0ZShlLnByaXYsIGUucHJpdkVuYyksIGUucHViICYmIHRoaXMuX2ltcG9ydFB1YmxpYyhlLnB1YiwgZS5wdWJFbmMpO1xufVxudmFyIE0yID0gVXQ7XG5VdC5mcm9tUHVibGljID0gZnVuY3Rpb24oZSwgdCwgaSkge1xuICByZXR1cm4gdCBpbnN0YW5jZW9mIFV0ID8gdCA6IG5ldyBVdChlLCB7XG4gICAgcHViOiB0LFxuICAgIHB1YkVuYzogaVxuICB9KTtcbn07XG5VdC5mcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBVdCA/IHQgOiBuZXcgVXQoZSwge1xuICAgIHByaXY6IHQsXG4gICAgcHJpdkVuYzogaVxuICB9KTtcbn07XG5VdC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGUgPSB0aGlzLmdldFB1YmxpYygpO1xuICByZXR1cm4gZS5pc0luZmluaXR5KCkgPyB7IHJlc3VsdDogITEsIHJlYXNvbjogXCJJbnZhbGlkIHB1YmxpYyBrZXlcIiB9IDogZS52YWxpZGF0ZSgpID8gZS5tdWwodGhpcy5lYy5jdXJ2ZS5uKS5pc0luZmluaXR5KCkgPyB7IHJlc3VsdDogITAsIHJlYXNvbjogbnVsbCB9IDogeyByZXN1bHQ6ICExLCByZWFzb246IFwiUHVibGljIGtleSAqIE4gIT0gT1wiIH0gOiB7IHJlc3VsdDogITEsIHJlYXNvbjogXCJQdWJsaWMga2V5IGlzIG5vdCBhIHBvaW50XCIgfTtcbn07XG5VdC5wcm90b3R5cGUuZ2V0UHVibGljID0gZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiAodCA9IGUsIGUgPSBudWxsKSwgdGhpcy5wdWIgfHwgKHRoaXMucHViID0gdGhpcy5lYy5nLm11bCh0aGlzLnByaXYpKSwgdCA/IHRoaXMucHViLmVuY29kZSh0LCBlKSA6IHRoaXMucHViO1xufTtcblV0LnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZSA9PT0gXCJoZXhcIiA/IHRoaXMucHJpdi50b1N0cmluZygxNiwgMikgOiB0aGlzLnByaXY7XG59O1xuVXQucHJvdG90eXBlLl9pbXBvcnRQcml2YXRlID0gZnVuY3Rpb24oZSwgdCkge1xuICB0aGlzLnByaXYgPSBuZXcgRTIoZSwgdCB8fCAxNiksIHRoaXMucHJpdiA9IHRoaXMucHJpdi51bW9kKHRoaXMuZWMuY3VydmUubik7XG59O1xuVXQucHJvdG90eXBlLl9pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbihlLCB0KSB7XG4gIGlmIChlLnggfHwgZS55KSB7XG4gICAgdGhpcy5lYy5jdXJ2ZS50eXBlID09PSBcIm1vbnRcIiA/IE1vKGUueCwgXCJOZWVkIHggY29vcmRpbmF0ZVwiKSA6ICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09IFwic2hvcnRcIiB8fCB0aGlzLmVjLmN1cnZlLnR5cGUgPT09IFwiZWR3YXJkc1wiKSAmJiBNbyhlLnggJiYgZS55LCBcIk5lZWQgYm90aCB4IGFuZCB5IGNvb3JkaW5hdGVcIiksIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5wb2ludChlLngsIGUueSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5kZWNvZGVQb2ludChlLCB0KTtcbn07XG5VdC5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZS52YWxpZGF0ZSgpIHx8IE1vKGUudmFsaWRhdGUoKSwgXCJwdWJsaWMgcG9pbnQgbm90IHZhbGlkYXRlZFwiKSwgZS5tdWwodGhpcy5wcml2KS5nZXRYKCk7XG59O1xuVXQucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gIHJldHVybiB0aGlzLmVjLnNpZ24oZSwgdGhpcywgdCwgaSk7XG59O1xuVXQucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uKGUsIHQsIGkpIHtcbiAgcmV0dXJuIHRoaXMuZWMudmVyaWZ5KGUsIHQsIHRoaXMsIHZvaWQgMCwgaSk7XG59O1xuVXQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiPEtleSBwcml2OiBcIiArICh0aGlzLnByaXYgJiYgdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKSkgKyBcIiBwdWI6IFwiICsgKHRoaXMucHViICYmIHRoaXMucHViLmluc3BlY3QoKSkgKyBcIiA+XCI7XG59O1xudmFyIFdzID0gbGksIFpvID0gYXIsIEkyID0gWm8uYXNzZXJ0O1xuZnVuY3Rpb24gd2EociwgZSkge1xuICBpZiAociBpbnN0YW5jZW9mIHdhKVxuICAgIHJldHVybiByO1xuICB0aGlzLl9pbXBvcnRERVIociwgZSkgfHwgKEkyKHIuciAmJiByLnMsIFwiU2lnbmF0dXJlIHdpdGhvdXQgciBvciBzXCIpLCB0aGlzLnIgPSBuZXcgV3Moci5yLCAxNiksIHRoaXMucyA9IG5ldyBXcyhyLnMsIDE2KSwgci5yZWNvdmVyeVBhcmFtID09PSB2b2lkIDAgPyB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsIDogdGhpcy5yZWNvdmVyeVBhcmFtID0gci5yZWNvdmVyeVBhcmFtKTtcbn1cbnZhciBBMiA9IHdhO1xuZnVuY3Rpb24gRDIoKSB7XG4gIHRoaXMucGxhY2UgPSAwO1xufVxuZnVuY3Rpb24gWGEociwgZSkge1xuICB2YXIgdCA9IHJbZS5wbGFjZSsrXTtcbiAgaWYgKCEodCAmIDEyOCkpXG4gICAgcmV0dXJuIHQ7XG4gIHZhciBpID0gdCAmIDE1O1xuICBpZiAoaSA9PT0gMCB8fCBpID4gNCB8fCByW2UucGxhY2VdID09PSAwKVxuICAgIHJldHVybiAhMTtcbiAgZm9yICh2YXIgbiA9IDAsIHMgPSAwLCBvID0gZS5wbGFjZTsgcyA8IGk7IHMrKywgbysrKVxuICAgIG4gPDw9IDgsIG4gfD0gcltvXSwgbiA+Pj49IDA7XG4gIHJldHVybiBuIDw9IDEyNyA/ICExIDogKGUucGxhY2UgPSBvLCBuKTtcbn1cbmZ1bmN0aW9uIG1jKHIpIHtcbiAgZm9yICh2YXIgZSA9IDAsIHQgPSByLmxlbmd0aCAtIDE7ICFyW2VdICYmICEocltlICsgMV0gJiAxMjgpICYmIGUgPCB0OyApXG4gICAgZSsrO1xuICByZXR1cm4gZSA9PT0gMCA/IHIgOiByLnNsaWNlKGUpO1xufVxud2EucHJvdG90eXBlLl9pbXBvcnRERVIgPSBmdW5jdGlvbihlLCB0KSB7XG4gIGUgPSBaby50b0FycmF5KGUsIHQpO1xuICB2YXIgaSA9IG5ldyBEMigpO1xuICBpZiAoZVtpLnBsYWNlKytdICE9PSA0OClcbiAgICByZXR1cm4gITE7XG4gIHZhciBuID0gWGEoZSwgaSk7XG4gIGlmIChuID09PSAhMSB8fCBuICsgaS5wbGFjZSAhPT0gZS5sZW5ndGggfHwgZVtpLnBsYWNlKytdICE9PSAyKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIHMgPSBYYShlLCBpKTtcbiAgaWYgKHMgPT09ICExIHx8IGVbaS5wbGFjZV0gJiAxMjgpXG4gICAgcmV0dXJuICExO1xuICB2YXIgbyA9IGUuc2xpY2UoaS5wbGFjZSwgcyArIGkucGxhY2UpO1xuICBpZiAoaS5wbGFjZSArPSBzLCBlW2kucGxhY2UrK10gIT09IDIpXG4gICAgcmV0dXJuICExO1xuICB2YXIgZiA9IFhhKGUsIGkpO1xuICBpZiAoZiA9PT0gITEgfHwgZS5sZW5ndGggIT09IGYgKyBpLnBsYWNlIHx8IGVbaS5wbGFjZV0gJiAxMjgpXG4gICAgcmV0dXJuICExO1xuICB2YXIgaCA9IGUuc2xpY2UoaS5wbGFjZSwgZiArIGkucGxhY2UpO1xuICBpZiAob1swXSA9PT0gMClcbiAgICBpZiAob1sxXSAmIDEyOClcbiAgICAgIG8gPSBvLnNsaWNlKDEpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiAhMTtcbiAgaWYgKGhbMF0gPT09IDApXG4gICAgaWYgKGhbMV0gJiAxMjgpXG4gICAgICBoID0gaC5zbGljZSgxKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiB0aGlzLnIgPSBuZXcgV3MobyksIHRoaXMucyA9IG5ldyBXcyhoKSwgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbCwgITA7XG59O1xuZnVuY3Rpb24gWmEociwgZSkge1xuICBpZiAoZSA8IDEyOCkge1xuICAgIHIucHVzaChlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHQgPSAxICsgKE1hdGgubG9nKGUpIC8gTWF0aC5MTjIgPj4+IDMpO1xuICBmb3IgKHIucHVzaCh0IHwgMTI4KTsgLS10OyApXG4gICAgci5wdXNoKGUgPj4+ICh0IDw8IDMpICYgMjU1KTtcbiAgci5wdXNoKGUpO1xufVxud2EucHJvdG90eXBlLnRvREVSID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdCA9IHRoaXMuci50b0FycmF5KCksIGkgPSB0aGlzLnMudG9BcnJheSgpO1xuICBmb3IgKHRbMF0gJiAxMjggJiYgKHQgPSBbMF0uY29uY2F0KHQpKSwgaVswXSAmIDEyOCAmJiAoaSA9IFswXS5jb25jYXQoaSkpLCB0ID0gbWModCksIGkgPSBtYyhpKTsgIWlbMF0gJiYgIShpWzFdICYgMTI4KTsgKVxuICAgIGkgPSBpLnNsaWNlKDEpO1xuICB2YXIgbiA9IFsyXTtcbiAgWmEobiwgdC5sZW5ndGgpLCBuID0gbi5jb25jYXQodCksIG4ucHVzaCgyKSwgWmEobiwgaS5sZW5ndGgpO1xuICB2YXIgcyA9IG4uY29uY2F0KGkpLCBvID0gWzQ4XTtcbiAgcmV0dXJuIFphKG8sIHMubGVuZ3RoKSwgbyA9IG8uY29uY2F0KHMpLCBaby5lbmNvZGUobywgZSk7XG59O1xudmFyIElyID0gbGksIEp1ID0geDIsIFAyID0gYXIsIFFhID0gbWEsIE8yID0gSHUsIEZpID0gUDIuYXNzZXJ0LCBRbyA9IE0yLCBfYSA9IEEyO1xuZnVuY3Rpb24gcHIocikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgcHIpKVxuICAgIHJldHVybiBuZXcgcHIocik7XG4gIHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgKEZpKFxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChRYSwgciksXG4gICAgXCJVbmtub3duIGN1cnZlIFwiICsgclxuICApLCByID0gUWFbcl0pLCByIGluc3RhbmNlb2YgUWEuUHJlc2V0Q3VydmUgJiYgKHIgPSB7IGN1cnZlOiByIH0pLCB0aGlzLmN1cnZlID0gci5jdXJ2ZS5jdXJ2ZSwgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uLCB0aGlzLm5oID0gdGhpcy5uLnVzaHJuKDEpLCB0aGlzLmcgPSB0aGlzLmN1cnZlLmcsIHRoaXMuZyA9IHIuY3VydmUuZywgdGhpcy5nLnByZWNvbXB1dGUoci5jdXJ2ZS5uLmJpdExlbmd0aCgpICsgMSksIHRoaXMuaGFzaCA9IHIuaGFzaCB8fCByLmN1cnZlLmhhc2g7XG59XG52YXIgUjIgPSBwcjtcbnByLnByb3RvdHlwZS5rZXlQYWlyID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gbmV3IFFvKHRoaXMsIGUpO1xufTtcbnByLnByb3RvdHlwZS5rZXlGcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIFFvLmZyb21Qcml2YXRlKHRoaXMsIGUsIHQpO1xufTtcbnByLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gUW8uZnJvbVB1YmxpYyh0aGlzLCBlLCB0KTtcbn07XG5wci5wcm90b3R5cGUuZ2VuS2V5UGFpciA9IGZ1bmN0aW9uKGUpIHtcbiAgZSB8fCAoZSA9IHt9KTtcbiAgZm9yICh2YXIgdCA9IG5ldyBKdSh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIHBlcnM6IGUucGVycyxcbiAgICBwZXJzRW5jOiBlLnBlcnNFbmMgfHwgXCJ1dGY4XCIsXG4gICAgZW50cm9weTogZS5lbnRyb3B5IHx8IE8yKHRoaXMuaGFzaC5obWFjU3RyZW5ndGgpLFxuICAgIGVudHJvcHlFbmM6IGUuZW50cm9weSAmJiBlLmVudHJvcHlFbmMgfHwgXCJ1dGY4XCIsXG4gICAgbm9uY2U6IHRoaXMubi50b0FycmF5KClcbiAgfSksIGkgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpLCBuID0gdGhpcy5uLnN1YihuZXcgSXIoMikpOyA7ICkge1xuICAgIHZhciBzID0gbmV3IElyKHQuZ2VuZXJhdGUoaSkpO1xuICAgIGlmICghKHMuY21wKG4pID4gMCkpXG4gICAgICByZXR1cm4gcy5pYWRkbigxKSwgdGhpcy5rZXlGcm9tUHJpdmF0ZShzKTtcbiAgfVxufTtcbnByLnByb3RvdHlwZS5fdHJ1bmNhdGVUb04gPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gIHZhciBuO1xuICBpZiAoSXIuaXNCTihlKSB8fCB0eXBlb2YgZSA9PSBcIm51bWJlclwiKVxuICAgIGUgPSBuZXcgSXIoZSwgMTYpLCBuID0gZS5ieXRlTGVuZ3RoKCk7XG4gIGVsc2UgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgbiA9IGUubGVuZ3RoLCBlID0gbmV3IElyKGUsIDE2KTtcbiAgZWxzZSB7XG4gICAgdmFyIHMgPSBlLnRvU3RyaW5nKCk7XG4gICAgbiA9IHMubGVuZ3RoICsgMSA+Pj4gMSwgZSA9IG5ldyBJcihzLCAxNik7XG4gIH1cbiAgdHlwZW9mIGkgIT0gXCJudW1iZXJcIiAmJiAoaSA9IG4gKiA4KTtcbiAgdmFyIG8gPSBpIC0gdGhpcy5uLmJpdExlbmd0aCgpO1xuICByZXR1cm4gbyA+IDAgJiYgKGUgPSBlLnVzaHJuKG8pKSwgIXQgJiYgZS5jbXAodGhpcy5uKSA+PSAwID8gZS5zdWIodGhpcy5uKSA6IGU7XG59O1xucHIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbihlLCB0LCBpLCBuKSB7XG4gIGlmICh0eXBlb2YgaSA9PSBcIm9iamVjdFwiICYmIChuID0gaSwgaSA9IG51bGwpLCBuIHx8IChuID0ge30pLCB0eXBlb2YgZSAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBlICE9IFwibnVtYmVyXCIgJiYgIUlyLmlzQk4oZSkpIHtcbiAgICBGaShcbiAgICAgIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAmJiB0eXBlb2YgZS5sZW5ndGggPT0gXCJudW1iZXJcIixcbiAgICAgIFwiRXhwZWN0ZWQgbWVzc2FnZSB0byBiZSBhbiBhcnJheS1saWtlLCBhIGhleCBzdHJpbmcsIG9yIGEgQk4gaW5zdGFuY2VcIlxuICAgICksIEZpKGUubGVuZ3RoID4+PiAwID09PSBlLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBlLmxlbmd0aDsgcysrKVxuICAgICAgRmkoKGVbc10gJiAyNTUpID09PSBlW3NdKTtcbiAgfVxuICB0ID0gdGhpcy5rZXlGcm9tUHJpdmF0ZSh0LCBpKSwgZSA9IHRoaXMuX3RydW5jYXRlVG9OKGUsICExLCBuLm1zZ0JpdExlbmd0aCksIEZpKCFlLmlzTmVnKCksIFwiQ2FuIG5vdCBzaWduIGEgbmVnYXRpdmUgbWVzc2FnZVwiKTtcbiAgdmFyIG8gPSB0aGlzLm4uYnl0ZUxlbmd0aCgpLCBmID0gdC5nZXRQcml2YXRlKCkudG9BcnJheShcImJlXCIsIG8pLCBoID0gZS50b0FycmF5KFwiYmVcIiwgbyk7XG4gIEZpKG5ldyBJcihoKS5lcShlKSwgXCJDYW4gbm90IHNpZ24gbWVzc2FnZVwiKTtcbiAgZm9yICh2YXIgZCA9IG5ldyBKdSh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIGVudHJvcHk6IGYsXG4gICAgbm9uY2U6IGgsXG4gICAgcGVyczogbi5wZXJzLFxuICAgIHBlcnNFbmM6IG4ucGVyc0VuYyB8fCBcInV0ZjhcIlxuICB9KSwgdiA9IHRoaXMubi5zdWIobmV3IElyKDEpKSwgdyA9IDA7IDsgdysrKSB7XG4gICAgdmFyIEEgPSBuLmsgPyBuLmsodykgOiBuZXcgSXIoZC5nZW5lcmF0ZSh0aGlzLm4uYnl0ZUxlbmd0aCgpKSk7XG4gICAgaWYgKEEgPSB0aGlzLl90cnVuY2F0ZVRvTihBLCAhMCksICEoQS5jbXBuKDEpIDw9IDAgfHwgQS5jbXAodikgPj0gMCkpIHtcbiAgICAgIHZhciBJID0gdGhpcy5nLm11bChBKTtcbiAgICAgIGlmICghSS5pc0luZmluaXR5KCkpIHtcbiAgICAgICAgdmFyIEQgPSBJLmdldFgoKSwgTiA9IEQudW1vZCh0aGlzLm4pO1xuICAgICAgICBpZiAoTi5jbXBuKDApICE9PSAwKSB7XG4gICAgICAgICAgdmFyIGsgPSBBLmludm0odGhpcy5uKS5tdWwoTi5tdWwodC5nZXRQcml2YXRlKCkpLmlhZGQoZSkpO1xuICAgICAgICAgIGlmIChrID0gay51bW9kKHRoaXMubiksIGsuY21wbigwKSAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIGogPSAoSS5nZXRZKCkuaXNPZGQoKSA/IDEgOiAwKSB8IChELmNtcChOKSAhPT0gMCA/IDIgOiAwKTtcbiAgICAgICAgICAgIHJldHVybiBuLmNhbm9uaWNhbCAmJiBrLmNtcCh0aGlzLm5oKSA+IDAgJiYgKGsgPSB0aGlzLm4uc3ViKGspLCBqIF49IDEpLCBuZXcgX2EoeyByOiBOLCBzOiBrLCByZWNvdmVyeVBhcmFtOiBqIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnByLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbihlLCB0LCBpLCBuLCBzKSB7XG4gIHMgfHwgKHMgPSB7fSksIGUgPSB0aGlzLl90cnVuY2F0ZVRvTihlLCAhMSwgcy5tc2dCaXRMZW5ndGgpLCBpID0gdGhpcy5rZXlGcm9tUHVibGljKGksIG4pLCB0ID0gbmV3IF9hKHQsIFwiaGV4XCIpO1xuICB2YXIgbyA9IHQuciwgZiA9IHQucztcbiAgaWYgKG8uY21wbigxKSA8IDAgfHwgby5jbXAodGhpcy5uKSA+PSAwIHx8IGYuY21wbigxKSA8IDAgfHwgZi5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIGggPSBmLmludm0odGhpcy5uKSwgZCA9IGgubXVsKGUpLnVtb2QodGhpcy5uKSwgdiA9IGgubXVsKG8pLnVtb2QodGhpcy5uKSwgdztcbiAgcmV0dXJuIHRoaXMuY3VydmUuX21heHdlbGxUcmljayA/ICh3ID0gdGhpcy5nLmptdWxBZGQoZCwgaS5nZXRQdWJsaWMoKSwgdiksIHcuaXNJbmZpbml0eSgpID8gITEgOiB3LmVxWFRvUChvKSkgOiAodyA9IHRoaXMuZy5tdWxBZGQoZCwgaS5nZXRQdWJsaWMoKSwgdiksIHcuaXNJbmZpbml0eSgpID8gITEgOiB3LmdldFgoKS51bW9kKHRoaXMubikuY21wKG8pID09PSAwKTtcbn07XG5wci5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKHIsIGUsIHQsIGkpIHtcbiAgRmkoKDMgJiB0KSA9PT0gdCwgXCJUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzXCIpLCBlID0gbmV3IF9hKGUsIGkpO1xuICB2YXIgbiA9IHRoaXMubiwgcyA9IG5ldyBJcihyKSwgbyA9IGUuciwgZiA9IGUucywgaCA9IHQgJiAxLCBkID0gdCA+PiAxO1xuICBpZiAoby5jbXAodGhpcy5jdXJ2ZS5wLnVtb2QodGhpcy5jdXJ2ZS5uKSkgPj0gMCAmJiBkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHNlbmNvbmQga2V5IGNhbmRpbmF0ZVwiKTtcbiAgZCA/IG8gPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgoby5hZGQodGhpcy5jdXJ2ZS5uKSwgaCkgOiBvID0gdGhpcy5jdXJ2ZS5wb2ludEZyb21YKG8sIGgpO1xuICB2YXIgdiA9IGUuci5pbnZtKG4pLCB3ID0gbi5zdWIocykubXVsKHYpLnVtb2QobiksIEEgPSBmLm11bCh2KS51bW9kKG4pO1xuICByZXR1cm4gdGhpcy5nLm11bEFkZCh3LCBvLCBBKTtcbn07XG5wci5wcm90b3R5cGUuZ2V0S2V5UmVjb3ZlcnlQYXJhbSA9IGZ1bmN0aW9uKHIsIGUsIHQsIGkpIHtcbiAgaWYgKGUgPSBuZXcgX2EoZSwgaSksIGUucmVjb3ZlcnlQYXJhbSAhPT0gbnVsbClcbiAgICByZXR1cm4gZS5yZWNvdmVyeVBhcmFtO1xuICBmb3IgKHZhciBuID0gMDsgbiA8IDQ7IG4rKykge1xuICAgIHZhciBzO1xuICAgIHRyeSB7XG4gICAgICBzID0gdGhpcy5yZWNvdmVyUHViS2V5KHIsIGUsIG4pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzLmVxKHQpKVxuICAgICAgcmV0dXJuIG47XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yXCIpO1xufTtcbnZhciBmcyA9IGFyLCBZdSA9IGZzLmFzc2VydCwgd2MgPSBmcy5wYXJzZUJ5dGVzLCBNbiA9IGZzLmNhY2hlZFByb3BlcnR5O1xuZnVuY3Rpb24gSXQociwgZSkge1xuICB0aGlzLmVkZHNhID0gciwgdGhpcy5fc2VjcmV0ID0gd2MoZS5zZWNyZXQpLCByLmlzUG9pbnQoZS5wdWIpID8gdGhpcy5fcHViID0gZS5wdWIgOiB0aGlzLl9wdWJCeXRlcyA9IHdjKGUucHViKTtcbn1cbkl0LmZyb21QdWJsaWMgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgSXQgPyB0IDogbmV3IEl0KGUsIHsgcHViOiB0IH0pO1xufTtcbkl0LmZyb21TZWNyZXQgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgSXQgPyB0IDogbmV3IEl0KGUsIHsgc2VjcmV0OiB0IH0pO1xufTtcbkl0LnByb3RvdHlwZS5zZWNyZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NlY3JldDtcbn07XG5NbihJdCwgXCJwdWJCeXRlc1wiLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlUG9pbnQodGhpcy5wdWIoKSk7XG59KTtcbk1uKEl0LCBcInB1YlwiLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3B1YkJ5dGVzID8gdGhpcy5lZGRzYS5kZWNvZGVQb2ludCh0aGlzLl9wdWJCeXRlcykgOiB0aGlzLmVkZHNhLmcubXVsKHRoaXMucHJpdigpKTtcbn0pO1xuTW4oSXQsIFwicHJpdkJ5dGVzXCIsIGZ1bmN0aW9uKCkge1xuICB2YXIgZSA9IHRoaXMuZWRkc2EsIHQgPSB0aGlzLmhhc2goKSwgaSA9IGUuZW5jb2RpbmdMZW5ndGggLSAxLCBuID0gdC5zbGljZSgwLCBlLmVuY29kaW5nTGVuZ3RoKTtcbiAgcmV0dXJuIG5bMF0gJj0gMjQ4LCBuW2ldICY9IDEyNywgbltpXSB8PSA2NCwgbjtcbn0pO1xuTW4oSXQsIFwicHJpdlwiLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlSW50KHRoaXMucHJpdkJ5dGVzKCkpO1xufSk7XG5NbihJdCwgXCJoYXNoXCIsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5oYXNoKCkudXBkYXRlKHRoaXMuc2VjcmV0KCkpLmRpZ2VzdCgpO1xufSk7XG5NbihJdCwgXCJtZXNzYWdlUHJlZml4XCIsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5oYXNoKCkuc2xpY2UodGhpcy5lZGRzYS5lbmNvZGluZ0xlbmd0aCk7XG59KTtcbkl0LnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gWXUodGhpcy5fc2VjcmV0LCBcIktleVBhaXIgY2FuIG9ubHkgdmVyaWZ5XCIpLCB0aGlzLmVkZHNhLnNpZ24oZSwgdGhpcyk7XG59O1xuSXQucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EudmVyaWZ5KGUsIHQsIHRoaXMpO1xufTtcbkl0LnByb3RvdHlwZS5nZXRTZWNyZXQgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBZdSh0aGlzLl9zZWNyZXQsIFwiS2V5UGFpciBpcyBwdWJsaWMgb25seVwiKSwgZnMuZW5jb2RlKHRoaXMuc2VjcmV0KCksIGUpO1xufTtcbkl0LnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBmcy5lbmNvZGUodGhpcy5wdWJCeXRlcygpLCBlKTtcbn07XG52YXIgTjIgPSBJdCwgVDIgPSBsaSwgeGEgPSBhciwgX2MgPSB4YS5hc3NlcnQsIEVhID0geGEuY2FjaGVkUHJvcGVydHksIEMyID0geGEucGFyc2VCeXRlcztcbmZ1bmN0aW9uIFppKHIsIGUpIHtcbiAgdGhpcy5lZGRzYSA9IHIsIHR5cGVvZiBlICE9IFwib2JqZWN0XCIgJiYgKGUgPSBDMihlKSksIEFycmF5LmlzQXJyYXkoZSkgJiYgKF9jKGUubGVuZ3RoID09PSByLmVuY29kaW5nTGVuZ3RoICogMiwgXCJTaWduYXR1cmUgaGFzIGludmFsaWQgc2l6ZVwiKSwgZSA9IHtcbiAgICBSOiBlLnNsaWNlKDAsIHIuZW5jb2RpbmdMZW5ndGgpLFxuICAgIFM6IGUuc2xpY2Uoci5lbmNvZGluZ0xlbmd0aClcbiAgfSksIF9jKGUuUiAmJiBlLlMsIFwiU2lnbmF0dXJlIHdpdGhvdXQgUiBvciBTXCIpLCByLmlzUG9pbnQoZS5SKSAmJiAodGhpcy5fUiA9IGUuUiksIGUuUyBpbnN0YW5jZW9mIFQyICYmICh0aGlzLl9TID0gZS5TKSwgdGhpcy5fUmVuY29kZWQgPSBBcnJheS5pc0FycmF5KGUuUikgPyBlLlIgOiBlLlJlbmNvZGVkLCB0aGlzLl9TZW5jb2RlZCA9IEFycmF5LmlzQXJyYXkoZS5TKSA/IGUuUyA6IGUuU2VuY29kZWQ7XG59XG5FYShaaSwgXCJTXCIsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVJbnQodGhpcy5TZW5jb2RlZCgpKTtcbn0pO1xuRWEoWmksIFwiUlwiLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlUG9pbnQodGhpcy5SZW5jb2RlZCgpKTtcbn0pO1xuRWEoWmksIFwiUmVuY29kZWRcIiwgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmVuY29kZVBvaW50KHRoaXMuUigpKTtcbn0pO1xuRWEoWmksIFwiU2VuY29kZWRcIiwgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmVuY29kZUludCh0aGlzLlMoKSk7XG59KTtcblppLnByb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLlJlbmNvZGVkKCkuY29uY2F0KHRoaXMuU2VuY29kZWQoKSk7XG59O1xuWmkucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB4YS5lbmNvZGUodGhpcy50b0J5dGVzKCksIFwiaGV4XCIpLnRvVXBwZXJDYXNlKCk7XG59O1xudmFyICQyID0gWmksIEwyID0gbnMsIEYyID0gbWEsIHZuID0gYXIsIHEyID0gdm4uYXNzZXJ0LCBYdSA9IHZuLnBhcnNlQnl0ZXMsIFp1ID0gTjIsIHhjID0gJDI7XG5mdW5jdGlvbiBYdChyKSB7XG4gIGlmIChxMihyID09PSBcImVkMjU1MTlcIiwgXCJvbmx5IHRlc3RlZCB3aXRoIGVkMjU1MTkgc28gZmFyXCIpLCAhKHRoaXMgaW5zdGFuY2VvZiBYdCkpXG4gICAgcmV0dXJuIG5ldyBYdChyKTtcbiAgciA9IEYyW3JdLmN1cnZlLCB0aGlzLmN1cnZlID0gciwgdGhpcy5nID0gci5nLCB0aGlzLmcucHJlY29tcHV0ZShyLm4uYml0TGVuZ3RoKCkgKyAxKSwgdGhpcy5wb2ludENsYXNzID0gci5wb2ludCgpLmNvbnN0cnVjdG9yLCB0aGlzLmVuY29kaW5nTGVuZ3RoID0gTWF0aC5jZWlsKHIubi5iaXRMZW5ndGgoKSAvIDgpLCB0aGlzLmhhc2ggPSBMMi5zaGE1MTI7XG59XG52YXIgVTIgPSBYdDtcblh0LnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24oZSwgdCkge1xuICBlID0gWHUoZSk7XG4gIHZhciBpID0gdGhpcy5rZXlGcm9tU2VjcmV0KHQpLCBuID0gdGhpcy5oYXNoSW50KGkubWVzc2FnZVByZWZpeCgpLCBlKSwgcyA9IHRoaXMuZy5tdWwobiksIG8gPSB0aGlzLmVuY29kZVBvaW50KHMpLCBmID0gdGhpcy5oYXNoSW50KG8sIGkucHViQnl0ZXMoKSwgZSkubXVsKGkucHJpdigpKSwgaCA9IG4uYWRkKGYpLnVtb2QodGhpcy5jdXJ2ZS5uKTtcbiAgcmV0dXJuIHRoaXMubWFrZVNpZ25hdHVyZSh7IFI6IHMsIFM6IGgsIFJlbmNvZGVkOiBvIH0pO1xufTtcblh0LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbihlLCB0LCBpKSB7XG4gIGlmIChlID0gWHUoZSksIHQgPSB0aGlzLm1ha2VTaWduYXR1cmUodCksIHQuUygpLmd0ZSh0LmVkZHNhLmN1cnZlLm4pIHx8IHQuUygpLmlzTmVnKCkpXG4gICAgcmV0dXJuICExO1xuICB2YXIgbiA9IHRoaXMua2V5RnJvbVB1YmxpYyhpKSwgcyA9IHRoaXMuaGFzaEludCh0LlJlbmNvZGVkKCksIG4ucHViQnl0ZXMoKSwgZSksIG8gPSB0aGlzLmcubXVsKHQuUygpKSwgZiA9IHQuUigpLmFkZChuLnB1YigpLm11bChzKSk7XG4gIHJldHVybiBmLmVxKG8pO1xufTtcblh0LnByb3RvdHlwZS5oYXNoSW50ID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGUgPSB0aGlzLmhhc2goKSwgdCA9IDA7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspXG4gICAgZS51cGRhdGUoYXJndW1lbnRzW3RdKTtcbiAgcmV0dXJuIHZuLmludEZyb21MRShlLmRpZ2VzdCgpKS51bW9kKHRoaXMuY3VydmUubik7XG59O1xuWHQucHJvdG90eXBlLmtleUZyb21QdWJsaWMgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBadS5mcm9tUHVibGljKHRoaXMsIGUpO1xufTtcblh0LnByb3RvdHlwZS5rZXlGcm9tU2VjcmV0ID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gWnUuZnJvbVNlY3JldCh0aGlzLCBlKTtcbn07XG5YdC5wcm90b3R5cGUubWFrZVNpZ25hdHVyZSA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiB4YyA/IGUgOiBuZXcgeGModGhpcywgZSk7XG59O1xuWHQucHJvdG90eXBlLmVuY29kZVBvaW50ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdCA9IGUuZ2V0WSgpLnRvQXJyYXkoXCJsZVwiLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbiAgcmV0dXJuIHRbdGhpcy5lbmNvZGluZ0xlbmd0aCAtIDFdIHw9IGUuZ2V0WCgpLmlzT2RkKCkgPyAxMjggOiAwLCB0O1xufTtcblh0LnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uKGUpIHtcbiAgZSA9IHZuLnBhcnNlQnl0ZXMoZSk7XG4gIHZhciB0ID0gZS5sZW5ndGggLSAxLCBpID0gZS5zbGljZSgwLCB0KS5jb25jYXQoZVt0XSAmIC0xMjkpLCBuID0gKGVbdF0gJiAxMjgpICE9PSAwLCBzID0gdm4uaW50RnJvbUxFKGkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludEZyb21ZKHMsIG4pO1xufTtcblh0LnByb3RvdHlwZS5lbmNvZGVJbnQgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlLnRvQXJyYXkoXCJsZVwiLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbn07XG5YdC5wcm90b3R5cGUuZGVjb2RlSW50ID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gdm4uaW50RnJvbUxFKGUpO1xufTtcblh0LnByb3RvdHlwZS5pc1BvaW50ID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZSBpbnN0YW5jZW9mIHRoaXMucG9pbnRDbGFzcztcbn07XG4oZnVuY3Rpb24ocikge1xuICB2YXIgZSA9IHI7XG4gIGUudmVyc2lvbiA9IGgyLnZlcnNpb24sIGUudXRpbHMgPSBhciwgZS5yYW5kID0gSHUsIGUuY3VydmUgPSBZbywgZS5jdXJ2ZXMgPSBtYSwgZS5lYyA9IFIyLCBlLmVkZHNhID0gVTI7XG59KShLdSk7XG5jb25zdCB6MiA9IHsgd2FrdTogeyBwdWJsaXNoOiBcIndha3VfcHVibGlzaFwiLCBiYXRjaFB1Ymxpc2g6IFwid2FrdV9iYXRjaFB1Ymxpc2hcIiwgc3Vic2NyaWJlOiBcIndha3Vfc3Vic2NyaWJlXCIsIGJhdGNoU3Vic2NyaWJlOiBcIndha3VfYmF0Y2hTdWJzY3JpYmVcIiwgc3Vic2NyaXB0aW9uOiBcIndha3Vfc3Vic2NyaXB0aW9uXCIsIHVuc3Vic2NyaWJlOiBcIndha3VfdW5zdWJzY3JpYmVcIiwgYmF0Y2hVbnN1YnNjcmliZTogXCJ3YWt1X2JhdGNoVW5zdWJzY3JpYmVcIiwgYmF0Y2hGZXRjaE1lc3NhZ2VzOiBcIndha3VfYmF0Y2hGZXRjaE1lc3NhZ2VzXCIgfSwgaXJuOiB7IHB1Ymxpc2g6IFwiaXJuX3B1Ymxpc2hcIiwgYmF0Y2hQdWJsaXNoOiBcImlybl9iYXRjaFB1Ymxpc2hcIiwgc3Vic2NyaWJlOiBcImlybl9zdWJzY3JpYmVcIiwgYmF0Y2hTdWJzY3JpYmU6IFwiaXJuX2JhdGNoU3Vic2NyaWJlXCIsIHN1YnNjcmlwdGlvbjogXCJpcm5fc3Vic2NyaXB0aW9uXCIsIHVuc3Vic2NyaWJlOiBcImlybl91bnN1YnNjcmliZVwiLCBiYXRjaFVuc3Vic2NyaWJlOiBcImlybl9iYXRjaFVuc3Vic2NyaWJlXCIsIGJhdGNoRmV0Y2hNZXNzYWdlczogXCJpcm5fYmF0Y2hGZXRjaE1lc3NhZ2VzXCIgfSwgaXJpZGl1bTogeyBwdWJsaXNoOiBcImlyaWRpdW1fcHVibGlzaFwiLCBiYXRjaFB1Ymxpc2g6IFwiaXJpZGl1bV9iYXRjaFB1Ymxpc2hcIiwgc3Vic2NyaWJlOiBcImlyaWRpdW1fc3Vic2NyaWJlXCIsIGJhdGNoU3Vic2NyaWJlOiBcImlyaWRpdW1fYmF0Y2hTdWJzY3JpYmVcIiwgc3Vic2NyaXB0aW9uOiBcImlyaWRpdW1fc3Vic2NyaXB0aW9uXCIsIHVuc3Vic2NyaWJlOiBcImlyaWRpdW1fdW5zdWJzY3JpYmVcIiwgYmF0Y2hVbnN1YnNjcmliZTogXCJpcmlkaXVtX2JhdGNoVW5zdWJzY3JpYmVcIiwgYmF0Y2hGZXRjaE1lc3NhZ2VzOiBcImlyaWRpdW1fYmF0Y2hGZXRjaE1lc3NhZ2VzXCIgfSB9LCBlZiA9IFwiOlwiO1xuZnVuY3Rpb24gTnMocikge1xuICBjb25zdCBbZSwgdF0gPSByLnNwbGl0KGVmKTtcbiAgcmV0dXJuIHsgbmFtZXNwYWNlOiBlLCByZWZlcmVuY2U6IHQgfTtcbn1cbmZ1bmN0aW9uIEIyKHIpIHtcbiAgY29uc3QgeyBuYW1lc3BhY2U6IGUsIHJlZmVyZW5jZTogdCB9ID0gcjtcbiAgcmV0dXJuIFtlLCB0XS5qb2luKGVmKTtcbn1cbmZ1bmN0aW9uIGsyKHIpIHtcbiAgY29uc3QgW2UsIHQsIGldID0gci5zcGxpdChlZik7XG4gIHJldHVybiB7IG5hbWVzcGFjZTogZSwgcmVmZXJlbmNlOiB0LCBhZGRyZXNzOiBpIH07XG59XG5mdW5jdGlvbiBqMihyLCBlKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcmV0dXJuIHIuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGNvbnN0IG4gPSBlKGkpO1xuICAgIHQuaW5jbHVkZXMobikgfHwgdC5wdXNoKG4pO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIEsyKHIpIHtcbiAgY29uc3QgeyBuYW1lc3BhY2U6IGUsIHJlZmVyZW5jZTogdCB9ID0gazIocik7XG4gIHJldHVybiBCMih7IG5hbWVzcGFjZTogZSwgcmVmZXJlbmNlOiB0IH0pO1xufVxuZnVuY3Rpb24gSDIocikge1xuICByZXR1cm4gajIociwgSzIpO1xufVxuZnVuY3Rpb24gUXUociwgZSA9IFtdKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHIpLmZvckVhY2goKGkpID0+IHtcbiAgICBpZiAoZS5sZW5ndGggJiYgIWUuaW5jbHVkZXMoaSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IHJbaV07XG4gICAgdC5wdXNoKC4uLm4uYWNjb3VudHMpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIGVkKHIsIGUgPSBbXSkge1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiBPYmplY3Qua2V5cyhyKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgaWYgKGUubGVuZ3RoICYmICFlLmluY2x1ZGVzKGkpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSByW2ldO1xuICAgIHQucHVzaCguLi5IMihuLmFjY291bnRzKSk7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gVjIociwgZSA9IFtdKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHIpLmZvckVhY2goKGkpID0+IHtcbiAgICBpZiAoZS5sZW5ndGggJiYgIWUuaW5jbHVkZXMoaSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IHJbaV07XG4gICAgdC5wdXNoKC4uLnRmKGksIG4pKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiB0ZihyLCBlKSB7XG4gIHJldHVybiByLmluY2x1ZGVzKFwiOlwiKSA/IFtyXSA6IGUuY2hhaW5zIHx8IFtdO1xufVxudmFyIFcyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBFYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIEcyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgSjIgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBTYyA9IChyLCBlLCB0KSA9PiBlIGluIHIgPyBXMihyLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogcltlXSA9IHQsIE1jID0gKHIsIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIEcyLmNhbGwoZSwgdCkgJiYgU2MociwgdCwgZVt0XSk7XG4gIGlmIChFYylcbiAgICBmb3IgKHZhciB0IG9mIEVjKGUpKVxuICAgICAgSjIuY2FsbChlLCB0KSAmJiBTYyhyLCB0LCBlW3RdKTtcbiAgcmV0dXJuIHI7XG59O1xuY29uc3QgWTIgPSBcIlJlYWN0TmF0aXZlXCIsIHJyID0geyByZWFjdE5hdGl2ZTogXCJyZWFjdC1uYXRpdmVcIiwgbm9kZTogXCJub2RlXCIsIGJyb3dzZXI6IFwiYnJvd3NlclwiLCB1bmtub3duOiBcInVua25vd25cIiB9LCBYMiA9IFwianNcIjtcbmZ1bmN0aW9uIEdzKCkge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgPCBcInVcIiAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA8IFwidVwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgPCBcInVcIjtcbn1cbmZ1bmN0aW9uIEFpKCkge1xuICByZXR1cm4gIWlzKCkgJiYgISEkbygpICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBZMjtcbn1cbmZ1bmN0aW9uIFoyKCkge1xuICByZXR1cm4gQWkoKSAmJiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgJiYgdHlwZW9mIChnbG9iYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbC5QbGF0Zm9ybSkgPCBcInVcIiAmJiAoZ2xvYmFsID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWwuUGxhdGZvcm0uT1MpID09PSBcImFuZHJvaWRcIjtcbn1cbmZ1bmN0aW9uIFEyKCkge1xuICByZXR1cm4gQWkoKSAmJiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgJiYgdHlwZW9mIChnbG9iYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbC5QbGF0Zm9ybSkgPCBcInVcIiAmJiAoZ2xvYmFsID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWwuUGxhdGZvcm0uT1MpID09PSBcImlvc1wiO1xufVxuZnVuY3Rpb24gY3MoKSB7XG4gIHJldHVybiAhR3MoKSAmJiAhISRvKCkgJiYgISFpcygpO1xufVxuZnVuY3Rpb24gaHMoKSB7XG4gIHJldHVybiBBaSgpID8gcnIucmVhY3ROYXRpdmUgOiBHcygpID8gcnIubm9kZSA6IGNzKCkgPyByci5icm93c2VyIDogcnIudW5rbm93bjtcbn1cbmZ1bmN0aW9uIEljKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByZXR1cm4gQWkoKSAmJiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgJiYgdHlwZW9mIChnbG9iYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbC5BcHBsaWNhdGlvbikgPCBcInVcIiA/IChyID0gZ2xvYmFsLkFwcGxpY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogci5hcHBsaWNhdGlvbklkIDogdm9pZCAwO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm47XG4gIH1cbn1cbmZ1bmN0aW9uIGV5KHIsIGUpIHtcbiAgbGV0IHQgPSBZbi5wYXJzZShyKTtcbiAgcmV0dXJuIHQgPSBNYyhNYyh7fSwgdCksIGUpLCByID0gWW4uc3RyaW5naWZ5KHQpLCByO1xufVxuZnVuY3Rpb24gdGQoKSB7XG4gIHJldHVybiB1dSgpIHx8IHsgbmFtZTogXCJcIiwgZGVzY3JpcHRpb246IFwiXCIsIHVybDogXCJcIiwgaWNvbnM6IFtcIlwiXSB9O1xufVxuZnVuY3Rpb24gdHkoKSB7XG4gIGlmIChocygpID09PSByci5yZWFjdE5hdGl2ZSAmJiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgJiYgdHlwZW9mIChnbG9iYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbC5QbGF0Zm9ybSkgPCBcInVcIikge1xuICAgIGNvbnN0IHsgT1M6IHQsIFZlcnNpb246IGkgfSA9IGdsb2JhbC5QbGF0Zm9ybTtcbiAgICByZXR1cm4gW3QsIGldLmpvaW4oXCItXCIpO1xuICB9XG4gIGNvbnN0IHIgPSBjdSgpO1xuICBpZiAociA9PT0gbnVsbClcbiAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gIGNvbnN0IGUgPSByLm9zID8gci5vcy5yZXBsYWNlKFwiIFwiLCBcIlwiKS50b0xvd2VyQ2FzZSgpIDogXCJ1bmtub3duXCI7XG4gIHJldHVybiByLnR5cGUgPT09IFwiYnJvd3NlclwiID8gW2UsIHIubmFtZSwgci52ZXJzaW9uXS5qb2luKFwiLVwiKSA6IFtlLCByLnZlcnNpb25dLmpvaW4oXCItXCIpO1xufVxuZnVuY3Rpb24gcnkoKSB7XG4gIHZhciByO1xuICBjb25zdCBlID0gaHMoKTtcbiAgcmV0dXJuIGUgPT09IHJyLmJyb3dzZXIgPyBbZSwgKChyID0gaHUoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaG9zdCkgfHwgXCJ1bmtub3duXCJdLmpvaW4oXCI6XCIpIDogZTtcbn1cbmZ1bmN0aW9uIHJkKHIsIGUsIHQpIHtcbiAgY29uc3QgaSA9IHR5KCksIG4gPSByeSgpO1xuICByZXR1cm4gW1tyLCBlXS5qb2luKFwiLVwiKSwgW1gyLCB0XS5qb2luKFwiLVwiKSwgaSwgbl0uam9pbihcIi9cIik7XG59XG5mdW5jdGlvbiBpeSh7IHByb3RvY29sOiByLCB2ZXJzaW9uOiBlLCByZWxheVVybDogdCwgc2RrVmVyc2lvbjogaSwgYXV0aDogbiwgcHJvamVjdElkOiBzLCB1c2VPbkNsb3NlRXZlbnQ6IG8sIGJ1bmRsZUlkOiBmLCBwYWNrYWdlTmFtZTogaCB9KSB7XG4gIGNvbnN0IGQgPSB0LnNwbGl0KFwiP1wiKSwgdiA9IHJkKHIsIGUsIGkpLCB3ID0geyBhdXRoOiBuLCB1YTogdiwgcHJvamVjdElkOiBzLCB1c2VPbkNsb3NlRXZlbnQ6IG8gfHwgdm9pZCAwLCBwYWNrYWdlTmFtZTogaCB8fCB2b2lkIDAsIGJ1bmRsZUlkOiBmIHx8IHZvaWQgMCB9LCBBID0gZXkoZFsxXSB8fCBcIlwiLCB3KTtcbiAgcmV0dXJuIGRbMF0gKyBcIj9cIiArIEE7XG59XG5mdW5jdGlvbiBVaShyLCBlKSB7XG4gIHJldHVybiByLmZpbHRlcigodCkgPT4gZS5pbmNsdWRlcyh0KSkubGVuZ3RoID09PSByLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlkKHIpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhyLmVudHJpZXMoKSk7XG59XG5mdW5jdGlvbiBuZChyKSB7XG4gIHJldHVybiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHIpKTtcbn1cbmZ1bmN0aW9uIExpKHIgPSBpZS5GSVZFX01JTlVURVMsIGUpIHtcbiAgY29uc3QgdCA9IGllLnRvTWlsaXNlY29uZHMociB8fCBpZS5GSVZFX01JTlVURVMpO1xuICBsZXQgaSwgbiwgcywgbztcbiAgcmV0dXJuIHsgcmVzb2x2ZTogKGYpID0+IHtcbiAgICBzICYmIGkgJiYgKGNsZWFyVGltZW91dChzKSwgaShmKSwgbyA9IFByb21pc2UucmVzb2x2ZShmKSk7XG4gIH0sIHJlamVjdDogKGYpID0+IHtcbiAgICBzICYmIG4gJiYgKGNsZWFyVGltZW91dChzKSwgbihmKSk7XG4gIH0sIGRvbmU6ICgpID0+IG5ldyBQcm9taXNlKChmLCBoKSA9PiB7XG4gICAgaWYgKG8pXG4gICAgICByZXR1cm4gZihvKTtcbiAgICBzID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBkID0gbmV3IEVycm9yKGUpO1xuICAgICAgbyA9IFByb21pc2UucmVqZWN0KGQpLCBoKGQpO1xuICAgIH0sIHQpLCBpID0gZiwgbiA9IGg7XG4gIH0pIH07XG59XG5mdW5jdGlvbiBtaShyLCBlLCB0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAoaSwgbikgPT4ge1xuICAgIGNvbnN0IHMgPSBzZXRUaW1lb3V0KCgpID0+IG4obmV3IEVycm9yKHQpKSwgZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG8gPSBhd2FpdCByO1xuICAgICAgaShvKTtcbiAgICB9IGNhdGNoIChvKSB7XG4gICAgICBuKG8pO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQocyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2QociwgZSkge1xuICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiBlLnN0YXJ0c1dpdGgoYCR7cn06YCkpXG4gICAgcmV0dXJuIGU7XG4gIGlmIChyLnRvTG93ZXJDYXNlKCkgPT09IFwidG9waWNcIikge1xuICAgIGlmICh0eXBlb2YgZSAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBtdXN0IGJlIFwic3RyaW5nXCIgZm9yIGV4cGlyZXIgdGFyZ2V0IHR5cGU6IHRvcGljJyk7XG4gICAgcmV0dXJuIGB0b3BpYzoke2V9YDtcbiAgfSBlbHNlIGlmIChyLnRvTG93ZXJDYXNlKCkgPT09IFwiaWRcIikge1xuICAgIGlmICh0eXBlb2YgZSAhPSBcIm51bWJlclwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBtdXN0IGJlIFwibnVtYmVyXCIgZm9yIGV4cGlyZXIgdGFyZ2V0IHR5cGU6IGlkJyk7XG4gICAgcmV0dXJuIGBpZDoke2V9YDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZXhwaXJlciB0YXJnZXQgdHlwZTogJHtyfWApO1xufVxuZnVuY3Rpb24gbnkocikge1xuICByZXR1cm4gc2QoXCJ0b3BpY1wiLCByKTtcbn1cbmZ1bmN0aW9uIHN5KHIpIHtcbiAgcmV0dXJuIHNkKFwiaWRcIiwgcik7XG59XG5mdW5jdGlvbiBhZChyKSB7XG4gIGNvbnN0IFtlLCB0XSA9IHIuc3BsaXQoXCI6XCIpLCBpID0geyBpZDogdm9pZCAwLCB0b3BpYzogdm9pZCAwIH07XG4gIGlmIChlID09PSBcInRvcGljXCIgJiYgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIilcbiAgICBpLnRvcGljID0gdDtcbiAgZWxzZSBpZiAoZSA9PT0gXCJpZFwiICYmIE51bWJlci5pc0ludGVnZXIoTnVtYmVyKHQpKSlcbiAgICBpLmlkID0gTnVtYmVyKHQpO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhcmdldCwgZXhwZWN0ZWQgaWQ6bnVtYmVyIG9yIHRvcGljOnN0cmluZywgZ290ICR7ZX06JHt0fWApO1xuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIG10KHIsIGUpIHtcbiAgcmV0dXJuIGllLmZyb21NaWxpc2Vjb25kcygoZSB8fCBEYXRlLm5vdygpKSArIGllLnRvTWlsaXNlY29uZHMocikpO1xufVxuZnVuY3Rpb24gZ2kocikge1xuICByZXR1cm4gRGF0ZS5ub3coKSA+PSBpZS50b01pbGlzZWNvbmRzKHIpO1xufVxuZnVuY3Rpb24gWGUociwgZSkge1xuICByZXR1cm4gYCR7cn0ke2UgPyBgOiR7ZX1gIDogXCJcIn1gO1xufVxuZnVuY3Rpb24gYXkociA9IFtdLCBlID0gW10pIHtcbiAgcmV0dXJuIFsuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uciwgLi4uZV0pXTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG95KHsgaWQ6IHIsIHRvcGljOiBlLCB3Y0RlZXBMaW5rOiB0IH0pIHtcbiAgdmFyIGk7XG4gIHRyeSB7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZSh0KSA6IHQsIHMgPSBuPy5ocmVmO1xuICAgIGlmICh0eXBlb2YgcyAhPSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSBmeShzLCByLCBlKSwgZiA9IGhzKCk7XG4gICAgaWYgKGYgPT09IHJyLmJyb3dzZXIpIHtcbiAgICAgIGlmICghKChpID0gaXMoKSkgIT0gbnVsbCAmJiBpLmhhc0ZvY3VzKCkpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkRvY3VtZW50IGRvZXMgbm90IGhhdmUgZm9jdXMsIHNraXBwaW5nIGRlZXBsaW5rLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgby5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikgfHwgby5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSA/IHdpbmRvdy5vcGVuKG8sIFwiX2JsYW5rXCIsIFwibm9yZWZlcnJlciBub29wZW5lclwiKSA6IHdpbmRvdy5vcGVuKG8sIGh5KCkgPyBcIl9ibGFua1wiIDogXCJfc2VsZlwiLCBcIm5vcmVmZXJyZXIgbm9vcGVuZXJcIik7XG4gICAgfSBlbHNlXG4gICAgICBmID09PSByci5yZWFjdE5hdGl2ZSAmJiB0eXBlb2YgKGdsb2JhbCA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsLkxpbmtpbmcpIDwgXCJ1XCIgJiYgYXdhaXQgZ2xvYmFsLkxpbmtpbmcub3BlblVSTChvKTtcbiAgfSBjYXRjaCAobikge1xuICAgIGNvbnNvbGUuZXJyb3Iobik7XG4gIH1cbn1cbmZ1bmN0aW9uIGZ5KHIsIGUsIHQpIHtcbiAgY29uc3QgaSA9IGByZXF1ZXN0SWQ9JHtlfSZzZXNzaW9uVG9waWM9JHt0fWA7XG4gIHIuZW5kc1dpdGgoXCIvXCIpICYmIChyID0gci5zbGljZSgwLCAtMSkpO1xuICBsZXQgbiA9IGAke3J9YDtcbiAgaWYgKHIuc3RhcnRzV2l0aChcImh0dHBzOi8vdC5tZVwiKSkge1xuICAgIGNvbnN0IHMgPSByLmluY2x1ZGVzKFwiP1wiKSA/IFwiJnN0YXJ0YXBwPVwiIDogXCI/c3RhcnRhcHA9XCI7XG4gICAgbiA9IGAke259JHtzfSR7dXkoaSwgITApfWA7XG4gIH0gZWxzZVxuICAgIG4gPSBgJHtufS93Yz8ke2l9YDtcbiAgcmV0dXJuIG47XG59XG5hc3luYyBmdW5jdGlvbiBjeShyLCBlKSB7XG4gIGxldCB0ID0gXCJcIjtcbiAgdHJ5IHtcbiAgICBpZiAoY3MoKSAmJiAodCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGUpLCB0KSlcbiAgICAgIHJldHVybiB0O1xuICAgIHQgPSBhd2FpdCByLmdldEl0ZW0oZSk7XG4gIH0gY2F0Y2ggKGkpIHtcbiAgICBjb25zb2xlLmVycm9yKGkpO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gQWMociwgZSkge1xuICBpZiAoIXIuaW5jbHVkZXMoZSkpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHQgPSByLnNwbGl0KC8oWyYsPyw9XSkvKSwgaSA9IHQuaW5kZXhPZihlKTtcbiAgcmV0dXJuIHRbaSArIDJdO1xufVxuZnVuY3Rpb24gRGMoKSB7XG4gIHJldHVybiB0eXBlb2YgY3J5cHRvIDwgXCJ1XCIgJiYgY3J5cHRvICE9IG51bGwgJiYgY3J5cHRvLnJhbmRvbVVVSUQgPyBjcnlwdG8ucmFuZG9tVVVJRCgpIDogXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIi5yZXBsYWNlKC9beHldL2d1LCAocikgPT4ge1xuICAgIGNvbnN0IGUgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwO1xuICAgIHJldHVybiAociA9PT0gXCJ4XCIgPyBlIDogZSAmIDMgfCA4KS50b1N0cmluZygxNik7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmYoKSB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyA8IFwidVwiICYmIHByb2Nlc3MuZW52LklTX1ZJVEVTVCA9PT0gXCJ0cnVlXCI7XG59XG5mdW5jdGlvbiBoeSgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiAoISF3aW5kb3cuVGVsZWdyYW1XZWJ2aWV3UHJveHkgfHwgISF3aW5kb3cuVGVsZWdyYW0gfHwgISF3aW5kb3cuVGVsZWdyYW1XZWJ2aWV3UHJveHlQcm90byk7XG59XG5mdW5jdGlvbiB1eShyLCBlID0gITEpIHtcbiAgY29uc3QgdCA9IEJ1ZmZlci5mcm9tKHIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICByZXR1cm4gZSA/IHQucmVwbGFjZSgvWz1dL2csIFwiXCIpIDogdDtcbn1cbmZ1bmN0aW9uIG9kKHIpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHIsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwidXRmLThcIik7XG59XG5mdW5jdGlvbiBkeShyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoZSkgPT4gc2V0VGltZW91dChlLCByKSk7XG59XG5jb25zdCBseSA9IFwiaHR0cHM6Ly9ycGMud2FsbGV0Y29ubmVjdC5vcmcvdjFcIjtcbmFzeW5jIGZ1bmN0aW9uIHB5KHIsIGUsIHQsIGksIG4sIHMpIHtcbiAgc3dpdGNoICh0LnQpIHtcbiAgICBjYXNlIFwiZWlwMTkxXCI6XG4gICAgICByZXR1cm4gdnkociwgZSwgdC5zKTtcbiAgICBjYXNlIFwiZWlwMTI3MVwiOlxuICAgICAgcmV0dXJuIGF3YWl0IGJ5KHIsIGUsIHQucywgaSwgbiwgcyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdmVyaWZ5U2lnbmF0dXJlIGZhaWxlZDogQXR0ZW1wdGVkIHRvIHZlcmlmeSBDYWNhb1NpZ25hdHVyZSB3aXRoIHVua25vd24gdHlwZTogJHt0LnR9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZ5KHIsIGUsIHQpIHtcbiAgcmV0dXJuIExnKGJ1KGUpLCB0KS50b0xvd2VyQ2FzZSgpID09PSByLnRvTG93ZXJDYXNlKCk7XG59XG5hc3luYyBmdW5jdGlvbiBieShyLCBlLCB0LCBpLCBuLCBzKSB7XG4gIGNvbnN0IG8gPSBOcyhpKTtcbiAgaWYgKCFvLm5hbWVzcGFjZSB8fCAhby5yZWZlcmVuY2UpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBpc1ZhbGlkRWlwMTI3MVNpZ25hdHVyZSBmYWlsZWQ6IGNoYWluSWQgbXVzdCBiZSBpbiBDQUlQLTIgZm9ybWF0LCByZWNlaXZlZDogJHtpfWApO1xuICB0cnkge1xuICAgIGNvbnN0IGYgPSBcIjB4MTYyNmJhN2VcIiwgaCA9IFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0MFwiLCBkID0gXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQxXCIsIHYgPSB0LnN1YnN0cmluZygyKSwgdyA9IGJ1KGUpLnN1YnN0cmluZygyKSwgQSA9IGYgKyB3ICsgaCArIGQgKyB2LCBJID0gYXdhaXQgZmV0Y2goYCR7cyB8fCBseX0vP2NoYWluSWQ9JHtpfSZwcm9qZWN0SWQ9JHtufWAsIHsgbWV0aG9kOiBcIlBPU1RcIiwgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpZDogZ3koKSwganNvbnJwYzogXCIyLjBcIiwgbWV0aG9kOiBcImV0aF9jYWxsXCIsIHBhcmFtczogW3sgdG86IHIsIGRhdGE6IEEgfSwgXCJsYXRlc3RcIl0gfSkgfSksIHsgcmVzdWx0OiBEIH0gPSBhd2FpdCBJLmpzb24oKTtcbiAgICByZXR1cm4gRCA/IEQuc2xpY2UoMCwgZi5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IGYudG9Mb3dlckNhc2UoKSA6ICExO1xuICB9IGNhdGNoIChmKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJpc1ZhbGlkRWlwMTI3MVNpZ25hdHVyZTogXCIsIGYpLCAhMTtcbiAgfVxufVxuZnVuY3Rpb24gZ3koKSB7XG4gIHJldHVybiBEYXRlLm5vdygpICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWUzKTtcbn1cbnZhciB5eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgbXkgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgd3kgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycywgUGMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBfeSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIHh5ID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgT2MgPSAociwgZSwgdCkgPT4gZSBpbiByID8geXkociwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IHJbZV0gPSB0LCBFeSA9IChyLCBlKSA9PiB7XG4gIGZvciAodmFyIHQgaW4gZSB8fCAoZSA9IHt9KSlcbiAgICBfeS5jYWxsKGUsIHQpICYmIE9jKHIsIHQsIGVbdF0pO1xuICBpZiAoUGMpXG4gICAgZm9yICh2YXIgdCBvZiBQYyhlKSlcbiAgICAgIHh5LmNhbGwoZSwgdCkgJiYgT2MociwgdCwgZVt0XSk7XG4gIHJldHVybiByO1xufSwgU3kgPSAociwgZSkgPT4gbXkociwgd3koZSkpO1xuY29uc3QgTXkgPSBcImRpZDpwa2g6XCIsIG5mID0gKHIpID0+IHI/LnNwbGl0KFwiOlwiKSwgSXkgPSAocikgPT4ge1xuICBjb25zdCBlID0gciAmJiBuZihyKTtcbiAgaWYgKGUpXG4gICAgcmV0dXJuIHIuaW5jbHVkZXMoTXkpID8gZVszXSA6IGVbMV07XG59LCBJbyA9IChyKSA9PiB7XG4gIGNvbnN0IGUgPSByICYmIG5mKHIpO1xuICBpZiAoZSlcbiAgICByZXR1cm4gZVsyXSArIFwiOlwiICsgZVszXTtcbn0sIEpzID0gKHIpID0+IHtcbiAgY29uc3QgZSA9IHIgJiYgbmYocik7XG4gIGlmIChlKVxuICAgIHJldHVybiBlLnBvcCgpO1xufTtcbmFzeW5jIGZ1bmN0aW9uIFJjKHIpIHtcbiAgY29uc3QgeyBjYWNhbzogZSwgcHJvamVjdElkOiB0IH0gPSByLCB7IHM6IGksIHA6IG4gfSA9IGUsIHMgPSBmZChuLCBuLmlzcyksIG8gPSBKcyhuLmlzcyk7XG4gIHJldHVybiBhd2FpdCBweShvLCBzLCBpLCBJbyhuLmlzcyksIHQpO1xufVxuY29uc3QgZmQgPSAociwgZSkgPT4ge1xuICBjb25zdCB0ID0gYCR7ci5kb21haW59IHdhbnRzIHlvdSB0byBzaWduIGluIHdpdGggeW91ciBFdGhlcmV1bSBhY2NvdW50OmAsIGkgPSBKcyhlKTtcbiAgaWYgKCFyLmF1ZCAmJiAhci51cmkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGBhdWRgIG9yIGB1cmlgIGlzIHJlcXVpcmVkIHRvIGNvbnN0cnVjdCB0aGUgbWVzc2FnZVwiKTtcbiAgbGV0IG4gPSByLnN0YXRlbWVudCB8fCB2b2lkIDA7XG4gIGNvbnN0IHMgPSBgVVJJOiAke3IuYXVkIHx8IHIudXJpfWAsIG8gPSBgVmVyc2lvbjogJHtyLnZlcnNpb259YCwgZiA9IGBDaGFpbiBJRDogJHtJeShlKX1gLCBoID0gYE5vbmNlOiAke3Iubm9uY2V9YCwgZCA9IGBJc3N1ZWQgQXQ6ICR7ci5pYXR9YCwgdiA9IHIuZXhwID8gYEV4cGlyYXRpb24gVGltZTogJHtyLmV4cH1gIDogdm9pZCAwLCB3ID0gci5uYmYgPyBgTm90IEJlZm9yZTogJHtyLm5iZn1gIDogdm9pZCAwLCBBID0gci5yZXF1ZXN0SWQgPyBgUmVxdWVzdCBJRDogJHtyLnJlcXVlc3RJZH1gIDogdm9pZCAwLCBJID0gci5yZXNvdXJjZXMgPyBgUmVzb3VyY2VzOiR7ci5yZXNvdXJjZXMubWFwKChOKSA9PiBgXG4tICR7Tn1gKS5qb2luKFwiXCIpfWAgOiB2b2lkIDAsIEQgPSBUcyhyLnJlc291cmNlcyk7XG4gIGlmIChEKSB7XG4gICAgY29uc3QgTiA9IFhuKEQpO1xuICAgIG4gPSAkeShuLCBOKTtcbiAgfVxuICByZXR1cm4gW3QsIGksIFwiXCIsIG4sIFwiXCIsIHMsIG8sIGYsIGgsIGQsIHYsIHcsIEEsIEldLmZpbHRlcigoTikgPT4gTiAhPSBudWxsKS5qb2luKGBcbmApO1xufTtcbmZ1bmN0aW9uIEF5KHIpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHIpKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbn1cbmZ1bmN0aW9uIER5KHIpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoQnVmZmVyLmZyb20ociwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJ1dGYtOFwiKSk7XG59XG5mdW5jdGlvbiBIaShyKSB7XG4gIGlmICghcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZWNhcCBwcm92aWRlZCwgdmFsdWUgaXMgdW5kZWZpbmVkXCIpO1xuICBpZiAoIXIuYXR0KVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGBhdHRgIHByb3BlcnR5IGZvdW5kXCIpO1xuICBjb25zdCBlID0gT2JqZWN0LmtleXMoci5hdHQpO1xuICBpZiAoIShlICE9IG51bGwgJiYgZS5sZW5ndGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlc291cmNlcyBmb3VuZCBpbiBgYXR0YCBwcm9wZXJ0eVwiKTtcbiAgZS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgY29uc3QgaSA9IHIuYXR0W3RdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGkpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNvdXJjZSBtdXN0IGJlIGFuIG9iamVjdDogJHt0fWApO1xuICAgIGlmICh0eXBlb2YgaSAhPSBcIm9iamVjdFwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNvdXJjZSBtdXN0IGJlIGFuIG9iamVjdDogJHt0fWApO1xuICAgIGlmICghT2JqZWN0LmtleXMoaSkubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNvdXJjZSBvYmplY3QgaXMgZW1wdHk6ICR7dH1gKTtcbiAgICBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBjb25zdCBzID0gaVtuXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBYmlsaXR5IGxpbWl0cyAke259IG11c3QgYmUgYW4gYXJyYXkgb2Ygb2JqZWN0cywgZm91bmQ6ICR7c31gKTtcbiAgICAgIGlmICghcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgb2YgJHtufSBpcyBlbXB0eSBhcnJheSwgbXVzdCBiZSBhbiBhcnJheSB3aXRoIG9iamVjdHNgKTtcbiAgICAgIHMuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG8gIT0gXCJvYmplY3RcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFiaWxpdHkgbGltaXRzICgke259KSBtdXN0IGJlIGFuIGFycmF5IG9mIG9iamVjdHMsIGZvdW5kOiAke299YCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBQeShyLCBlLCB0LCBpID0ge30pIHtcbiAgcmV0dXJuIHQ/LnNvcnQoKG4sIHMpID0+IG4ubG9jYWxlQ29tcGFyZShzKSksIHsgYXR0OiB7IFtyXTogT3koZSwgdCwgaSkgfSB9O1xufVxuZnVuY3Rpb24gT3kociwgZSwgdCA9IHt9KSB7XG4gIGUgPSBlPy5zb3J0KChuLCBzKSA9PiBuLmxvY2FsZUNvbXBhcmUocykpO1xuICBjb25zdCBpID0gZS5tYXAoKG4pID0+ICh7IFtgJHtyfS8ke259YF06IFt0XSB9KSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAuLi5pKTtcbn1cbmZ1bmN0aW9uIGNkKHIpIHtcbiAgcmV0dXJuIEhpKHIpLCBgdXJuOnJlY2FwOiR7QXkocikucmVwbGFjZSgvPS9nLCBcIlwiKX1gO1xufVxuZnVuY3Rpb24gWG4ocikge1xuICBjb25zdCBlID0gRHkoci5yZXBsYWNlKFwidXJuOnJlY2FwOlwiLCBcIlwiKSk7XG4gIHJldHVybiBIaShlKSwgZTtcbn1cbmZ1bmN0aW9uIFJ5KHIsIGUsIHQpIHtcbiAgY29uc3QgaSA9IFB5KHIsIGUsIHQpO1xuICByZXR1cm4gY2QoaSk7XG59XG5mdW5jdGlvbiBOeShyKSB7XG4gIHJldHVybiByICYmIHIuaW5jbHVkZXMoXCJ1cm46cmVjYXA6XCIpO1xufVxuZnVuY3Rpb24gVHkociwgZSkge1xuICBjb25zdCB0ID0gWG4ociksIGkgPSBYbihlKSwgbiA9IEN5KHQsIGkpO1xuICByZXR1cm4gY2Qobik7XG59XG5mdW5jdGlvbiBDeShyLCBlKSB7XG4gIEhpKHIpLCBIaShlKTtcbiAgY29uc3QgdCA9IE9iamVjdC5rZXlzKHIuYXR0KS5jb25jYXQoT2JqZWN0LmtleXMoZS5hdHQpKS5zb3J0KChuLCBzKSA9PiBuLmxvY2FsZUNvbXBhcmUocykpLCBpID0geyBhdHQ6IHt9IH07XG4gIHJldHVybiB0LmZvckVhY2goKG4pID0+IHtcbiAgICB2YXIgcywgbztcbiAgICBPYmplY3Qua2V5cygoKHMgPSByLmF0dCkgPT0gbnVsbCA/IHZvaWQgMCA6IHNbbl0pIHx8IHt9KS5jb25jYXQoT2JqZWN0LmtleXMoKChvID0gZS5hdHQpID09IG51bGwgPyB2b2lkIDAgOiBvW25dKSB8fCB7fSkpLnNvcnQoKGYsIGgpID0+IGYubG9jYWxlQ29tcGFyZShoKSkuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgdmFyIGgsIGQ7XG4gICAgICBpLmF0dFtuXSA9IFN5KEV5KHt9LCBpLmF0dFtuXSksIHsgW2ZdOiAoKGggPSByLmF0dFtuXSkgPT0gbnVsbCA/IHZvaWQgMCA6IGhbZl0pIHx8ICgoZCA9IGUuYXR0W25dKSA9PSBudWxsID8gdm9pZCAwIDogZFtmXSkgfSk7XG4gICAgfSk7XG4gIH0pLCBpO1xufVxuZnVuY3Rpb24gJHkociA9IFwiXCIsIGUpIHtcbiAgSGkoZSk7XG4gIGNvbnN0IHQgPSBcIkkgZnVydGhlciBhdXRob3JpemUgdGhlIHN0YXRlZCBVUkkgdG8gcGVyZm9ybSB0aGUgZm9sbG93aW5nIGFjdGlvbnMgb24gbXkgYmVoYWxmOiBcIjtcbiAgaWYgKHIuaW5jbHVkZXModCkpXG4gICAgcmV0dXJuIHI7XG4gIGNvbnN0IGkgPSBbXTtcbiAgbGV0IG4gPSAwO1xuICBPYmplY3Qua2V5cyhlLmF0dCkuZm9yRWFjaCgoZikgPT4ge1xuICAgIGNvbnN0IGggPSBPYmplY3Qua2V5cyhlLmF0dFtmXSkubWFwKCh3KSA9PiAoeyBhYmlsaXR5OiB3LnNwbGl0KFwiL1wiKVswXSwgYWN0aW9uOiB3LnNwbGl0KFwiL1wiKVsxXSB9KSk7XG4gICAgaC5zb3J0KCh3LCBBKSA9PiB3LmFjdGlvbi5sb2NhbGVDb21wYXJlKEEuYWN0aW9uKSk7XG4gICAgY29uc3QgZCA9IHt9O1xuICAgIGguZm9yRWFjaCgodykgPT4ge1xuICAgICAgZFt3LmFiaWxpdHldIHx8IChkW3cuYWJpbGl0eV0gPSBbXSksIGRbdy5hYmlsaXR5XS5wdXNoKHcuYWN0aW9uKTtcbiAgICB9KTtcbiAgICBjb25zdCB2ID0gT2JqZWN0LmtleXMoZCkubWFwKCh3KSA9PiAobisrLCBgKCR7bn0pICcke3d9JzogJyR7ZFt3XS5qb2luKFwiJywgJ1wiKX0nIGZvciAnJHtmfScuYCkpO1xuICAgIGkucHVzaCh2LmpvaW4oXCIsIFwiKS5yZXBsYWNlKFwiLixcIiwgXCIuXCIpKTtcbiAgfSk7XG4gIGNvbnN0IHMgPSBpLmpvaW4oXCIgXCIpLCBvID0gYCR7dH0ke3N9YDtcbiAgcmV0dXJuIGAke3IgPyByICsgXCIgXCIgOiBcIlwifSR7b31gO1xufVxuZnVuY3Rpb24gTmMocikge1xuICB2YXIgZTtcbiAgY29uc3QgdCA9IFhuKHIpO1xuICBIaSh0KTtcbiAgY29uc3QgaSA9IChlID0gdC5hdHQpID09IG51bGwgPyB2b2lkIDAgOiBlLmVpcDE1NTtcbiAgcmV0dXJuIGkgPyBPYmplY3Qua2V5cyhpKS5tYXAoKG4pID0+IG4uc3BsaXQoXCIvXCIpWzFdKSA6IFtdO1xufVxuZnVuY3Rpb24gVGMocikge1xuICBjb25zdCBlID0gWG4ocik7XG4gIEhpKGUpO1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGUuYXR0KS5mb3JFYWNoKChpKSA9PiB7XG4gICAgT2JqZWN0LnZhbHVlcyhpKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICB2YXIgcztcbiAgICAgIChzID0gbj8uWzBdKSAhPSBudWxsICYmIHMuY2hhaW5zICYmIHQucHVzaChuWzBdLmNoYWlucyk7XG4gICAgfSk7XG4gIH0pLCBbLi4ubmV3IFNldCh0LmZsYXQoKSldO1xufVxuZnVuY3Rpb24gVHMocikge1xuICBpZiAoIXIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBlID0gcj8uW3IubGVuZ3RoIC0gMV07XG4gIHJldHVybiBOeShlKSA/IGUgOiB2b2lkIDA7XG59XG5jb25zdCBoZCA9IFwiYmFzZTEwXCIsIEJ0ID0gXCJiYXNlMTZcIiwgd2kgPSBcImJhc2U2NHBhZFwiLCBMbiA9IFwiYmFzZTY0dXJsXCIsIHVzID0gXCJ1dGY4XCIsIHVkID0gMCwgaGkgPSAxLCBkcyA9IDIsIEx5ID0gMCwgQ2MgPSAxLCBLbiA9IDEyLCBzZiA9IDMyO1xuZnVuY3Rpb24gRnkoKSB7XG4gIGNvbnN0IHIgPSBWby5nZW5lcmF0ZUtleVBhaXIoKTtcbiAgcmV0dXJuIHsgcHJpdmF0ZUtleTogTXQoci5zZWNyZXRLZXksIEJ0KSwgcHVibGljS2V5OiBNdChyLnB1YmxpY0tleSwgQnQpIH07XG59XG5mdW5jdGlvbiBBbygpIHtcbiAgY29uc3QgciA9IEVpLnJhbmRvbUJ5dGVzKHNmKTtcbiAgcmV0dXJuIE10KHIsIEJ0KTtcbn1cbmZ1bmN0aW9uIHF5KHIsIGUpIHtcbiAgY29uc3QgdCA9IFZvLnNoYXJlZEtleShTdChyLCBCdCksIFN0KGUsIEJ0KSwgITApLCBpID0gbmV3IEpnKGFzLlNIQTI1NiwgdCkuZXhwYW5kKHNmKTtcbiAgcmV0dXJuIE10KGksIEJ0KTtcbn1cbmZ1bmN0aW9uIENzKHIpIHtcbiAgY29uc3QgZSA9IGFzLmhhc2goU3QociwgQnQpKTtcbiAgcmV0dXJuIE10KGUsIEJ0KTtcbn1cbmZ1bmN0aW9uIGZpKHIpIHtcbiAgY29uc3QgZSA9IGFzLmhhc2goU3QociwgdXMpKTtcbiAgcmV0dXJuIE10KGUsIEJ0KTtcbn1cbmZ1bmN0aW9uIGRkKHIpIHtcbiAgcmV0dXJuIFN0KGAke3J9YCwgaGQpO1xufVxuZnVuY3Rpb24gVmkocikge1xuICByZXR1cm4gTnVtYmVyKE10KHIsIGhkKSk7XG59XG5mdW5jdGlvbiBVeShyKSB7XG4gIGNvbnN0IGUgPSBkZCh0eXBlb2Ygci50eXBlIDwgXCJ1XCIgPyByLnR5cGUgOiB1ZCk7XG4gIGlmIChWaShlKSA9PT0gaGkgJiYgdHlwZW9mIHIuc2VuZGVyUHVibGljS2V5ID4gXCJ1XCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzZW5kZXIgcHVibGljIGtleSBmb3IgdHlwZSAxIGVudmVsb3BlXCIpO1xuICBjb25zdCB0ID0gdHlwZW9mIHIuc2VuZGVyUHVibGljS2V5IDwgXCJ1XCIgPyBTdChyLnNlbmRlclB1YmxpY0tleSwgQnQpIDogdm9pZCAwLCBpID0gdHlwZW9mIHIuaXYgPCBcInVcIiA/IFN0KHIuaXYsIEJ0KSA6IEVpLnJhbmRvbUJ5dGVzKEtuKSwgbiA9IG5ldyBLby5DaGFDaGEyMFBvbHkxMzA1KFN0KHIuc3ltS2V5LCBCdCkpLnNlYWwoaSwgU3Qoci5tZXNzYWdlLCB1cykpO1xuICByZXR1cm4gbGQoeyB0eXBlOiBlLCBzZWFsZWQ6IG4sIGl2OiBpLCBzZW5kZXJQdWJsaWNLZXk6IHQsIGVuY29kaW5nOiByLmVuY29kaW5nIH0pO1xufVxuZnVuY3Rpb24genkociwgZSkge1xuICBjb25zdCB0ID0gZGQoZHMpLCBpID0gRWkucmFuZG9tQnl0ZXMoS24pLCBuID0gU3QociwgdXMpO1xuICByZXR1cm4gbGQoeyB0eXBlOiB0LCBzZWFsZWQ6IG4sIGl2OiBpLCBlbmNvZGluZzogZSB9KTtcbn1cbmZ1bmN0aW9uIEJ5KHIpIHtcbiAgY29uc3QgZSA9IG5ldyBLby5DaGFDaGEyMFBvbHkxMzA1KFN0KHIuc3ltS2V5LCBCdCkpLCB7IHNlYWxlZDogdCwgaXY6IGkgfSA9IFpuKHsgZW5jb2RlZDogci5lbmNvZGVkLCBlbmNvZGluZzogcj8uZW5jb2RpbmcgfSksIG4gPSBlLm9wZW4oaSwgdCk7XG4gIGlmIChuID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0XCIpO1xuICByZXR1cm4gTXQobiwgdXMpO1xufVxuZnVuY3Rpb24ga3kociwgZSkge1xuICBjb25zdCB7IHNlYWxlZDogdCB9ID0gWm4oeyBlbmNvZGVkOiByLCBlbmNvZGluZzogZSB9KTtcbiAgcmV0dXJuIE10KHQsIHVzKTtcbn1cbmZ1bmN0aW9uIGxkKHIpIHtcbiAgY29uc3QgeyBlbmNvZGluZzogZSA9IHdpIH0gPSByO1xuICBpZiAoVmkoci50eXBlKSA9PT0gZHMpXG4gICAgcmV0dXJuIE10KERzKFtyLnR5cGUsIHIuc2VhbGVkXSksIGUpO1xuICBpZiAoVmkoci50eXBlKSA9PT0gaGkpIHtcbiAgICBpZiAodHlwZW9mIHIuc2VuZGVyUHVibGljS2V5ID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHNlbmRlciBwdWJsaWMga2V5IGZvciB0eXBlIDEgZW52ZWxvcGVcIik7XG4gICAgcmV0dXJuIE10KERzKFtyLnR5cGUsIHIuc2VuZGVyUHVibGljS2V5LCByLml2LCByLnNlYWxlZF0pLCBlKTtcbiAgfVxuICByZXR1cm4gTXQoRHMoW3IudHlwZSwgci5pdiwgci5zZWFsZWRdKSwgZSk7XG59XG5mdW5jdGlvbiBabihyKSB7XG4gIGNvbnN0IHsgZW5jb2RlZDogZSwgZW5jb2Rpbmc6IHQgPSB3aSB9ID0gciwgaSA9IFN0KGUsIHQpLCBuID0gaS5zbGljZShMeSwgQ2MpLCBzID0gQ2M7XG4gIGlmIChWaShuKSA9PT0gaGkpIHtcbiAgICBjb25zdCBkID0gcyArIHNmLCB2ID0gZCArIEtuLCB3ID0gaS5zbGljZShzLCBkKSwgQSA9IGkuc2xpY2UoZCwgdiksIEkgPSBpLnNsaWNlKHYpO1xuICAgIHJldHVybiB7IHR5cGU6IG4sIHNlYWxlZDogSSwgaXY6IEEsIHNlbmRlclB1YmxpY0tleTogdyB9O1xuICB9XG4gIGlmIChWaShuKSA9PT0gZHMpIHtcbiAgICBjb25zdCBkID0gaS5zbGljZShzKSwgdiA9IEVpLnJhbmRvbUJ5dGVzKEtuKTtcbiAgICByZXR1cm4geyB0eXBlOiBuLCBzZWFsZWQ6IGQsIGl2OiB2IH07XG4gIH1cbiAgY29uc3QgbyA9IHMgKyBLbiwgZiA9IGkuc2xpY2UocywgbyksIGggPSBpLnNsaWNlKG8pO1xuICByZXR1cm4geyB0eXBlOiBuLCBzZWFsZWQ6IGgsIGl2OiBmIH07XG59XG5mdW5jdGlvbiBqeShyLCBlKSB7XG4gIGNvbnN0IHQgPSBabih7IGVuY29kZWQ6IHIsIGVuY29kaW5nOiBlPy5lbmNvZGluZyB9KTtcbiAgcmV0dXJuIHBkKHsgdHlwZTogVmkodC50eXBlKSwgc2VuZGVyUHVibGljS2V5OiB0eXBlb2YgdC5zZW5kZXJQdWJsaWNLZXkgPCBcInVcIiA/IE10KHQuc2VuZGVyUHVibGljS2V5LCBCdCkgOiB2b2lkIDAsIHJlY2VpdmVyUHVibGljS2V5OiBlPy5yZWNlaXZlclB1YmxpY0tleSB9KTtcbn1cbmZ1bmN0aW9uIHBkKHIpIHtcbiAgY29uc3QgZSA9IHI/LnR5cGUgfHwgdWQ7XG4gIGlmIChlID09PSBoaSkge1xuICAgIGlmICh0eXBlb2Ygcj8uc2VuZGVyUHVibGljS2V5ID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNlbmRlciBwdWJsaWMga2V5XCIpO1xuICAgIGlmICh0eXBlb2Ygcj8ucmVjZWl2ZXJQdWJsaWNLZXkgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgcmVjZWl2ZXIgcHVibGljIGtleVwiKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBlLCBzZW5kZXJQdWJsaWNLZXk6IHI/LnNlbmRlclB1YmxpY0tleSwgcmVjZWl2ZXJQdWJsaWNLZXk6IHI/LnJlY2VpdmVyUHVibGljS2V5IH07XG59XG5mdW5jdGlvbiAkYyhyKSB7XG4gIHJldHVybiByLnR5cGUgPT09IGhpICYmIHR5cGVvZiByLnNlbmRlclB1YmxpY0tleSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiByLnJlY2VpdmVyUHVibGljS2V5ID09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBMYyhyKSB7XG4gIHJldHVybiByLnR5cGUgPT09IGRzO1xufVxuZnVuY3Rpb24gS3kocikge1xuICByZXR1cm4gbmV3IEt1LmVjKFwicDI1NlwiKS5rZXlGcm9tUHVibGljKHsgeDogQnVmZmVyLmZyb20oci54LCBcImJhc2U2NFwiKS50b1N0cmluZyhcImhleFwiKSwgeTogQnVmZmVyLmZyb20oci55LCBcImJhc2U2NFwiKS50b1N0cmluZyhcImhleFwiKSB9LCBcImhleFwiKTtcbn1cbmZ1bmN0aW9uIEh5KHIpIHtcbiAgbGV0IGUgPSByLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICBjb25zdCB0ID0gZS5sZW5ndGggJSA0O1xuICByZXR1cm4gdCA+IDAgJiYgKGUgKz0gXCI9XCIucmVwZWF0KDQgLSB0KSksIGU7XG59XG5mdW5jdGlvbiBWeShyKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShIeShyKSwgXCJiYXNlNjRcIik7XG59XG5mdW5jdGlvbiBXeShyLCBlKSB7XG4gIGNvbnN0IFt0LCBpLCBuXSA9IHIuc3BsaXQoXCIuXCIpLCBzID0gVnkobik7XG4gIGlmIChzLmxlbmd0aCAhPT0gNjQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoXCIpO1xuICBjb25zdCBvID0gcy5zbGljZSgwLCAzMikudG9TdHJpbmcoXCJoZXhcIiksIGYgPSBzLnNsaWNlKDMyLCA2NCkudG9TdHJpbmcoXCJoZXhcIiksIGggPSBgJHt0fS4ke2l9YCwgZCA9IG5ldyBhcy5TSEEyNTYoKS51cGRhdGUoQnVmZmVyLmZyb20oaCkpLmRpZ2VzdCgpLCB2ID0gS3koZSksIHcgPSBCdWZmZXIuZnJvbShkKS50b1N0cmluZyhcImhleFwiKTtcbiAgaWYgKCF2LnZlcmlmeSh3LCB7IHI6IG8sIHM6IGYgfSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYXR1cmVcIik7XG4gIHJldHVybiBibyhyKS5wYXlsb2FkO1xufVxuY29uc3QgR3kgPSBcImlyblwiO1xuZnVuY3Rpb24gWXMocikge1xuICByZXR1cm4gcj8ucmVsYXkgfHwgeyBwcm90b2NvbDogR3kgfTtcbn1cbmZ1bmN0aW9uIGpuKHIpIHtcbiAgY29uc3QgZSA9IHoyW3JdO1xuICBpZiAodHlwZW9mIGUgPiBcInVcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJlbGF5IFByb3RvY29sIG5vdCBzdXBwb3J0ZWQ6ICR7cn1gKTtcbiAgcmV0dXJuIGU7XG59XG52YXIgSnkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIFl5ID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsIFh5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMsIEZjID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgWnkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBReSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIHFjID0gKHIsIGUsIHQpID0+IGUgaW4gciA/IEp5KHIsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiByW2VdID0gdCwgVWMgPSAociwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgWnkuY2FsbChlLCB0KSAmJiBxYyhyLCB0LCBlW3RdKTtcbiAgaWYgKEZjKVxuICAgIGZvciAodmFyIHQgb2YgRmMoZSkpXG4gICAgICBReS5jYWxsKGUsIHQpICYmIHFjKHIsIHQsIGVbdF0pO1xuICByZXR1cm4gcjtcbn0sIGVtID0gKHIsIGUpID0+IFl5KHIsIFh5KGUpKTtcbmZ1bmN0aW9uIHRtKHIsIGUgPSBcIi1cIikge1xuICBjb25zdCB0ID0ge30sIGkgPSBcInJlbGF5XCIgKyBlO1xuICByZXR1cm4gT2JqZWN0LmtleXMocikuZm9yRWFjaCgobikgPT4ge1xuICAgIGlmIChuLnN0YXJ0c1dpdGgoaSkpIHtcbiAgICAgIGNvbnN0IHMgPSBuLnJlcGxhY2UoaSwgXCJcIiksIG8gPSByW25dO1xuICAgICAgdFtzXSA9IG87XG4gICAgfVxuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIHpjKHIpIHtcbiAgaWYgKCFyLmluY2x1ZGVzKFwid2M6XCIpKSB7XG4gICAgY29uc3QgaCA9IG9kKHIpO1xuICAgIGggIT0gbnVsbCAmJiBoLmluY2x1ZGVzKFwid2M6XCIpICYmIChyID0gaCk7XG4gIH1cbiAgciA9IHIuaW5jbHVkZXMoXCJ3YzovL1wiKSA/IHIucmVwbGFjZShcIndjOi8vXCIsIFwiXCIpIDogciwgciA9IHIuaW5jbHVkZXMoXCJ3YzpcIikgPyByLnJlcGxhY2UoXCJ3YzpcIiwgXCJcIikgOiByO1xuICBjb25zdCBlID0gci5pbmRleE9mKFwiOlwiKSwgdCA9IHIuaW5kZXhPZihcIj9cIikgIT09IC0xID8gci5pbmRleE9mKFwiP1wiKSA6IHZvaWQgMCwgaSA9IHIuc3Vic3RyaW5nKDAsIGUpLCBuID0gci5zdWJzdHJpbmcoZSArIDEsIHQpLnNwbGl0KFwiQFwiKSwgcyA9IHR5cGVvZiB0IDwgXCJ1XCIgPyByLnN1YnN0cmluZyh0KSA6IFwiXCIsIG8gPSBZbi5wYXJzZShzKSwgZiA9IHR5cGVvZiBvLm1ldGhvZHMgPT0gXCJzdHJpbmdcIiA/IG8ubWV0aG9kcy5zcGxpdChcIixcIikgOiB2b2lkIDA7XG4gIHJldHVybiB7IHByb3RvY29sOiBpLCB0b3BpYzogcm0oblswXSksIHZlcnNpb246IHBhcnNlSW50KG5bMV0sIDEwKSwgc3ltS2V5OiBvLnN5bUtleSwgcmVsYXk6IHRtKG8pLCBtZXRob2RzOiBmLCBleHBpcnlUaW1lc3RhbXA6IG8uZXhwaXJ5VGltZXN0YW1wID8gcGFyc2VJbnQoby5leHBpcnlUaW1lc3RhbXAsIDEwKSA6IHZvaWQgMCB9O1xufVxuZnVuY3Rpb24gcm0ocikge1xuICByZXR1cm4gci5zdGFydHNXaXRoKFwiLy9cIikgPyByLnN1YnN0cmluZygyKSA6IHI7XG59XG5mdW5jdGlvbiBpbShyLCBlID0gXCItXCIpIHtcbiAgY29uc3QgdCA9IFwicmVsYXlcIiwgaSA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXMocikuZm9yRWFjaCgobikgPT4ge1xuICAgIGNvbnN0IHMgPSB0ICsgZSArIG47XG4gICAgcltuXSAmJiAoaVtzXSA9IHJbbl0pO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIEJjKHIpIHtcbiAgcmV0dXJuIGAke3IucHJvdG9jb2x9OiR7ci50b3BpY31AJHtyLnZlcnNpb259P2AgKyBZbi5zdHJpbmdpZnkoVWMoZW0oVWMoeyBzeW1LZXk6IHIuc3ltS2V5IH0sIGltKHIucmVsYXkpKSwgeyBleHBpcnlUaW1lc3RhbXA6IHIuZXhwaXJ5VGltZXN0YW1wIH0pLCByLm1ldGhvZHMgPyB7IG1ldGhvZHM6IHIubWV0aG9kcy5qb2luKFwiLFwiKSB9IDoge30pKTtcbn1cbmZ1bmN0aW9uIEVzKHIsIGUsIHQpIHtcbiAgcmV0dXJuIGAke3J9P3djX2V2PSR7dH0mdG9waWM9JHtlfWA7XG59XG5mdW5jdGlvbiBJbihyKSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgcmV0dXJuIHIuZm9yRWFjaCgodCkgPT4ge1xuICAgIGNvbnN0IFtpLCBuXSA9IHQuc3BsaXQoXCI6XCIpO1xuICAgIGUucHVzaChgJHtpfToke259YCk7XG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gbm0ocikge1xuICBjb25zdCBlID0gW107XG4gIHJldHVybiBPYmplY3QudmFsdWVzKHIpLmZvckVhY2goKHQpID0+IHtcbiAgICBlLnB1c2goLi4uSW4odC5hY2NvdW50cykpO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIHNtKHIsIGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgSW4oaS5hY2NvdW50cykuaW5jbHVkZXMoZSkgJiYgdC5wdXNoKC4uLmkubWV0aG9kcyk7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gYW0ociwgZSkge1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiBPYmplY3QudmFsdWVzKHIpLmZvckVhY2goKGkpID0+IHtcbiAgICBJbihpLmFjY291bnRzKS5pbmNsdWRlcyhlKSAmJiB0LnB1c2goLi4uaS5ldmVudHMpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIG9tKHIpIHtcbiAgY29uc3QgZSA9IHt9O1xuICByZXR1cm4gcj8uZm9yRWFjaCgodCkgPT4ge1xuICAgIGNvbnN0IFtpLCBuXSA9IHQuc3BsaXQoXCI6XCIpO1xuICAgIGVbaV0gfHwgKGVbaV0gPSB7IGFjY291bnRzOiBbXSwgY2hhaW5zOiBbXSwgZXZlbnRzOiBbXSB9KSwgZVtpXS5hY2NvdW50cy5wdXNoKHQpLCBlW2ldLmNoYWlucy5wdXNoKGAke2l9OiR7bn1gKTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBrYyhyLCBlKSB7XG4gIGUgPSBlLm1hcCgoaSkgPT4gaS5yZXBsYWNlKFwiZGlkOnBraDpcIiwgXCJcIikpO1xuICBjb25zdCB0ID0gb20oZSk7XG4gIGZvciAoY29uc3QgW2ksIG5dIG9mIE9iamVjdC5lbnRyaWVzKHQpKVxuICAgIG4ubWV0aG9kcyA/IG4ubWV0aG9kcyA9IGF5KG4ubWV0aG9kcywgcikgOiBuLm1ldGhvZHMgPSByLCBuLmV2ZW50cyA9IFtcImNoYWluQ2hhbmdlZFwiLCBcImFjY291bnRzQ2hhbmdlZFwiXTtcbiAgcmV0dXJuIHQ7XG59XG5jb25zdCBmbSA9IHsgSU5WQUxJRF9NRVRIT0Q6IHsgbWVzc2FnZTogXCJJbnZhbGlkIG1ldGhvZC5cIiwgY29kZTogMTAwMSB9LCBJTlZBTElEX0VWRU5UOiB7IG1lc3NhZ2U6IFwiSW52YWxpZCBldmVudC5cIiwgY29kZTogMTAwMiB9LCBJTlZBTElEX1VQREFURV9SRVFVRVNUOiB7IG1lc3NhZ2U6IFwiSW52YWxpZCB1cGRhdGUgcmVxdWVzdC5cIiwgY29kZTogMTAwMyB9LCBJTlZBTElEX0VYVEVORF9SRVFVRVNUOiB7IG1lc3NhZ2U6IFwiSW52YWxpZCBleHRlbmQgcmVxdWVzdC5cIiwgY29kZTogMTAwNCB9LCBJTlZBTElEX1NFU1NJT05fU0VUVExFX1JFUVVFU1Q6IHsgbWVzc2FnZTogXCJJbnZhbGlkIHNlc3Npb24gc2V0dGxlIHJlcXVlc3QuXCIsIGNvZGU6IDEwMDUgfSwgVU5BVVRIT1JJWkVEX01FVEhPRDogeyBtZXNzYWdlOiBcIlVuYXV0aG9yaXplZCBtZXRob2QuXCIsIGNvZGU6IDMwMDEgfSwgVU5BVVRIT1JJWkVEX0VWRU5UOiB7IG1lc3NhZ2U6IFwiVW5hdXRob3JpemVkIGV2ZW50LlwiLCBjb2RlOiAzMDAyIH0sIFVOQVVUSE9SSVpFRF9VUERBVEVfUkVRVUVTVDogeyBtZXNzYWdlOiBcIlVuYXV0aG9yaXplZCB1cGRhdGUgcmVxdWVzdC5cIiwgY29kZTogMzAwMyB9LCBVTkFVVEhPUklaRURfRVhURU5EX1JFUVVFU1Q6IHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWQgZXh0ZW5kIHJlcXVlc3QuXCIsIGNvZGU6IDMwMDQgfSwgVVNFUl9SRUpFQ1RFRDogeyBtZXNzYWdlOiBcIlVzZXIgcmVqZWN0ZWQuXCIsIGNvZGU6IDVlMyB9LCBVU0VSX1JFSkVDVEVEX0NIQUlOUzogeyBtZXNzYWdlOiBcIlVzZXIgcmVqZWN0ZWQgY2hhaW5zLlwiLCBjb2RlOiA1MDAxIH0sIFVTRVJfUkVKRUNURURfTUVUSE9EUzogeyBtZXNzYWdlOiBcIlVzZXIgcmVqZWN0ZWQgbWV0aG9kcy5cIiwgY29kZTogNTAwMiB9LCBVU0VSX1JFSkVDVEVEX0VWRU5UUzogeyBtZXNzYWdlOiBcIlVzZXIgcmVqZWN0ZWQgZXZlbnRzLlwiLCBjb2RlOiA1MDAzIH0sIFVOU1VQUE9SVEVEX0NIQUlOUzogeyBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIGNoYWlucy5cIiwgY29kZTogNTEwMCB9LCBVTlNVUFBPUlRFRF9NRVRIT0RTOiB7IG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgbWV0aG9kcy5cIiwgY29kZTogNTEwMSB9LCBVTlNVUFBPUlRFRF9FVkVOVFM6IHsgbWVzc2FnZTogXCJVbnN1cHBvcnRlZCBldmVudHMuXCIsIGNvZGU6IDUxMDIgfSwgVU5TVVBQT1JURURfQUNDT1VOVFM6IHsgbWVzc2FnZTogXCJVbnN1cHBvcnRlZCBhY2NvdW50cy5cIiwgY29kZTogNTEwMyB9LCBVTlNVUFBPUlRFRF9OQU1FU1BBQ0VfS0VZOiB7IG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgbmFtZXNwYWNlIGtleS5cIiwgY29kZTogNTEwNCB9LCBVU0VSX0RJU0NPTk5FQ1RFRDogeyBtZXNzYWdlOiBcIlVzZXIgZGlzY29ubmVjdGVkLlwiLCBjb2RlOiA2ZTMgfSwgU0VTU0lPTl9TRVRUTEVNRU5UX0ZBSUxFRDogeyBtZXNzYWdlOiBcIlNlc3Npb24gc2V0dGxlbWVudCBmYWlsZWQuXCIsIGNvZGU6IDdlMyB9LCBXQ19NRVRIT0RfVU5TVVBQT1JURUQ6IHsgbWVzc2FnZTogXCJVbnN1cHBvcnRlZCB3Y18gbWV0aG9kLlwiLCBjb2RlOiAxMDAwMSB9IH0sIGNtID0geyBOT1RfSU5JVElBTElaRUQ6IHsgbWVzc2FnZTogXCJOb3QgaW5pdGlhbGl6ZWQuXCIsIGNvZGU6IDEgfSwgTk9fTUFUQ0hJTkdfS0VZOiB7IG1lc3NhZ2U6IFwiTm8gbWF0Y2hpbmcga2V5LlwiLCBjb2RlOiAyIH0sIFJFU1RPUkVfV0lMTF9PVkVSUklERTogeyBtZXNzYWdlOiBcIlJlc3RvcmUgd2lsbCBvdmVycmlkZS5cIiwgY29kZTogMyB9LCBSRVNVQlNDUklCRUQ6IHsgbWVzc2FnZTogXCJSZXN1YnNjcmliZWQuXCIsIGNvZGU6IDQgfSwgTUlTU0lOR19PUl9JTlZBTElEOiB7IG1lc3NhZ2U6IFwiTWlzc2luZyBvciBpbnZhbGlkLlwiLCBjb2RlOiA1IH0sIEVYUElSRUQ6IHsgbWVzc2FnZTogXCJFeHBpcmVkLlwiLCBjb2RlOiA2IH0sIFVOS05PV05fVFlQRTogeyBtZXNzYWdlOiBcIlVua25vd24gdHlwZS5cIiwgY29kZTogNyB9LCBNSVNNQVRDSEVEX1RPUElDOiB7IG1lc3NhZ2U6IFwiTWlzbWF0Y2hlZCB0b3BpYy5cIiwgY29kZTogOCB9LCBOT05fQ09ORk9STUlOR19OQU1FU1BBQ0VTOiB7IG1lc3NhZ2U6IFwiTm9uIGNvbmZvcm1pbmcgbmFtZXNwYWNlcy5cIiwgY29kZTogOSB9IH07XG5mdW5jdGlvbiBhZShyLCBlKSB7XG4gIGNvbnN0IHsgbWVzc2FnZTogdCwgY29kZTogaSB9ID0gY21bcl07XG4gIHJldHVybiB7IG1lc3NhZ2U6IGUgPyBgJHt0fSAke2V9YCA6IHQsIGNvZGU6IGkgfTtcbn1cbmZ1bmN0aW9uIHN0KHIsIGUpIHtcbiAgY29uc3QgeyBtZXNzYWdlOiB0LCBjb2RlOiBpIH0gPSBmbVtyXTtcbiAgcmV0dXJuIHsgbWVzc2FnZTogZSA/IGAke3R9ICR7ZX1gIDogdCwgY29kZTogaSB9O1xufVxuZnVuY3Rpb24gU2EociwgZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShyKSA/IHR5cGVvZiBlIDwgXCJ1XCIgJiYgci5sZW5ndGggPyByLmV2ZXJ5KGUpIDogITAgOiAhMTtcbn1cbmZ1bmN0aW9uIFhzKHIpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihyKSA9PT0gT2JqZWN0LnByb3RvdHlwZSAmJiBPYmplY3Qua2V5cyhyKS5sZW5ndGg7XG59XG5mdW5jdGlvbiB6dChyKSB7XG4gIHJldHVybiB0eXBlb2YgciA+IFwidVwiO1xufVxuZnVuY3Rpb24gYnQociwgZSkge1xuICByZXR1cm4gZSAmJiB6dChyKSA/ICEwIDogdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiAmJiAhIXIudHJpbSgpLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGFmKHIsIGUpIHtcbiAgcmV0dXJuIGUgJiYgenQocikgPyAhMCA6IHR5cGVvZiByID09IFwibnVtYmVyXCIgJiYgIWlzTmFOKHIpO1xufVxuZnVuY3Rpb24gaG0ociwgZSkge1xuICBjb25zdCB7IHJlcXVpcmVkTmFtZXNwYWNlczogdCB9ID0gZSwgaSA9IE9iamVjdC5rZXlzKHIubmFtZXNwYWNlcyksIG4gPSBPYmplY3Qua2V5cyh0KTtcbiAgbGV0IHMgPSAhMDtcbiAgcmV0dXJuIFVpKG4sIGkpID8gKGkuZm9yRWFjaCgobykgPT4ge1xuICAgIGNvbnN0IHsgYWNjb3VudHM6IGYsIG1ldGhvZHM6IGgsIGV2ZW50czogZCB9ID0gci5uYW1lc3BhY2VzW29dLCB2ID0gSW4oZiksIHcgPSB0W29dO1xuICAgICghVWkodGYobywgdyksIHYpIHx8ICFVaSh3Lm1ldGhvZHMsIGgpIHx8ICFVaSh3LmV2ZW50cywgZCkpICYmIChzID0gITEpO1xuICB9KSwgcykgOiAhMTtcbn1cbmZ1bmN0aW9uIFpzKHIpIHtcbiAgcmV0dXJuIGJ0KHIsICExKSAmJiByLmluY2x1ZGVzKFwiOlwiKSA/IHIuc3BsaXQoXCI6XCIpLmxlbmd0aCA9PT0gMiA6ICExO1xufVxuZnVuY3Rpb24gdW0ocikge1xuICBpZiAoYnQociwgITEpICYmIHIuaW5jbHVkZXMoXCI6XCIpKSB7XG4gICAgY29uc3QgZSA9IHIuc3BsaXQoXCI6XCIpO1xuICAgIGlmIChlLmxlbmd0aCA9PT0gMykge1xuICAgICAgY29uc3QgdCA9IGVbMF0gKyBcIjpcIiArIGVbMV07XG4gICAgICByZXR1cm4gISFlWzJdICYmIFpzKHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBkbShyKSB7XG4gIGZ1bmN0aW9uIGUodCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG5ldyBVUkwodCkgPCBcInVcIjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAoYnQociwgITEpKSB7XG4gICAgICBpZiAoZShyKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgY29uc3QgdCA9IG9kKHIpO1xuICAgICAgcmV0dXJuIGUodCk7XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBsbShyKSB7XG4gIHZhciBlO1xuICByZXR1cm4gKGUgPSByPy5wcm9wb3NlcikgPT0gbnVsbCA/IHZvaWQgMCA6IGUucHVibGljS2V5O1xufVxuZnVuY3Rpb24gcG0ocikge1xuICByZXR1cm4gcj8udG9waWM7XG59XG5mdW5jdGlvbiB2bShyLCBlKSB7XG4gIGxldCB0ID0gbnVsbDtcbiAgcmV0dXJuIGJ0KHI/LnB1YmxpY0tleSwgITEpIHx8ICh0ID0gYWUoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYCR7ZX0gY29udHJvbGxlciBwdWJsaWMga2V5IHNob3VsZCBiZSBhIHN0cmluZ2ApKSwgdDtcbn1cbmZ1bmN0aW9uIGpjKHIpIHtcbiAgbGV0IGUgPSAhMDtcbiAgcmV0dXJuIFNhKHIpID8gci5sZW5ndGggJiYgKGUgPSByLmV2ZXJ5KCh0KSA9PiBidCh0LCAhMSkpKSA6IGUgPSAhMSwgZTtcbn1cbmZ1bmN0aW9uIGJtKHIsIGUsIHQpIHtcbiAgbGV0IGkgPSBudWxsO1xuICByZXR1cm4gU2EoZSkgJiYgZS5sZW5ndGggPyBlLmZvckVhY2goKG4pID0+IHtcbiAgICBpIHx8IFpzKG4pIHx8IChpID0gc3QoXCJVTlNVUFBPUlRFRF9DSEFJTlNcIiwgYCR7dH0sIGNoYWluICR7bn0gc2hvdWxkIGJlIGEgc3RyaW5nIGFuZCBjb25mb3JtIHRvIFwibmFtZXNwYWNlOmNoYWluSWRcIiBmb3JtYXRgKSk7XG4gIH0pIDogWnMocikgfHwgKGkgPSBzdChcIlVOU1VQUE9SVEVEX0NIQUlOU1wiLCBgJHt0fSwgY2hhaW5zIG11c3QgYmUgZGVmaW5lZCBhcyBcIm5hbWVzcGFjZTpjaGFpbklkXCIgZS5nLiBcImVpcDE1NToxXCI6IHsuLi59IGluIHRoZSBuYW1lc3BhY2Uga2V5IE9SIGFzIGFuIGFycmF5IG9mIENBSVAtMiBjaGFpbklkcyBlLmcuIGVpcDE1NTogeyBjaGFpbnM6IFtcImVpcDE1NToxXCIsIFwiZWlwMTU1OjVcIl0gfWApKSwgaTtcbn1cbmZ1bmN0aW9uIGdtKHIsIGUsIHQpIHtcbiAgbGV0IGkgPSBudWxsO1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocikuZm9yRWFjaCgoW24sIHNdKSA9PiB7XG4gICAgaWYgKGkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9IGJtKG4sIHRmKG4sIHMpLCBgJHtlfSAke3R9YCk7XG4gICAgbyAmJiAoaSA9IG8pO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIHltKHIsIGUpIHtcbiAgbGV0IHQgPSBudWxsO1xuICByZXR1cm4gU2EocikgPyByLmZvckVhY2goKGkpID0+IHtcbiAgICB0IHx8IHVtKGkpIHx8ICh0ID0gc3QoXCJVTlNVUFBPUlRFRF9BQ0NPVU5UU1wiLCBgJHtlfSwgYWNjb3VudCAke2l9IHNob3VsZCBiZSBhIHN0cmluZyBhbmQgY29uZm9ybSB0byBcIm5hbWVzcGFjZTpjaGFpbklkOmFkZHJlc3NcIiBmb3JtYXRgKSk7XG4gIH0pIDogdCA9IHN0KFwiVU5TVVBQT1JURURfQUNDT1VOVFNcIiwgYCR7ZX0sIGFjY291bnRzIHNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIGNvbmZvcm1pbmcgdG8gXCJuYW1lc3BhY2U6Y2hhaW5JZDphZGRyZXNzXCIgZm9ybWF0YCksIHQ7XG59XG5mdW5jdGlvbiBtbShyLCBlKSB7XG4gIGxldCB0ID0gbnVsbDtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMocikuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGlmICh0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSB5bShpPy5hY2NvdW50cywgYCR7ZX0gbmFtZXNwYWNlYCk7XG4gICAgbiAmJiAodCA9IG4pO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIHdtKHIsIGUpIHtcbiAgbGV0IHQgPSBudWxsO1xuICByZXR1cm4gamMocj8ubWV0aG9kcykgPyBqYyhyPy5ldmVudHMpIHx8ICh0ID0gc3QoXCJVTlNVUFBPUlRFRF9FVkVOVFNcIiwgYCR7ZX0sIGV2ZW50cyBzaG91bGQgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncyBvciBlbXB0eSBhcnJheSBmb3Igbm8gZXZlbnRzYCkpIDogdCA9IHN0KFwiVU5TVVBQT1JURURfTUVUSE9EU1wiLCBgJHtlfSwgbWV0aG9kcyBzaG91bGQgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncyBvciBlbXB0eSBhcnJheSBmb3Igbm8gbWV0aG9kc2ApLCB0O1xufVxuZnVuY3Rpb24gdmQociwgZSkge1xuICBsZXQgdCA9IG51bGw7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKHIpLmZvckVhY2goKGkpID0+IHtcbiAgICBpZiAodClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gd20oaSwgYCR7ZX0sIG5hbWVzcGFjZWApO1xuICAgIG4gJiYgKHQgPSBuKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBfbShyLCBlLCB0KSB7XG4gIGxldCBpID0gbnVsbDtcbiAgaWYgKHIgJiYgWHMocikpIHtcbiAgICBjb25zdCBuID0gdmQociwgZSk7XG4gICAgbiAmJiAoaSA9IG4pO1xuICAgIGNvbnN0IHMgPSBnbShyLCBlLCB0KTtcbiAgICBzICYmIChpID0gcyk7XG4gIH0gZWxzZVxuICAgIGkgPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgJHtlfSwgJHt0fSBzaG91bGQgYmUgYW4gb2JqZWN0IHdpdGggZGF0YWApO1xuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIGVvKHIsIGUpIHtcbiAgbGV0IHQgPSBudWxsO1xuICBpZiAociAmJiBYcyhyKSkge1xuICAgIGNvbnN0IGkgPSB2ZChyLCBlKTtcbiAgICBpICYmICh0ID0gaSk7XG4gICAgY29uc3QgbiA9IG1tKHIsIGUpO1xuICAgIG4gJiYgKHQgPSBuKTtcbiAgfSBlbHNlXG4gICAgdCA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGAke2V9LCBuYW1lc3BhY2VzIHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBkYXRhYCk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gYmQocikge1xuICByZXR1cm4gYnQoci5wcm90b2NvbCwgITApO1xufVxuZnVuY3Rpb24geG0ociwgZSkge1xuICBsZXQgdCA9ICExO1xuICByZXR1cm4gZSAmJiAhciA/IHQgPSAhMCA6IHIgJiYgU2EocikgJiYgci5sZW5ndGggJiYgci5mb3JFYWNoKChpKSA9PiB7XG4gICAgdCA9IGJkKGkpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIEVtKHIpIHtcbiAgcmV0dXJuIHR5cGVvZiByID09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBHdChyKSB7XG4gIHJldHVybiB0eXBlb2YgciA8IFwidVwiICYmIHR5cGVvZiByICE9PSBudWxsO1xufVxuZnVuY3Rpb24gU20ocikge1xuICByZXR1cm4gISghciB8fCB0eXBlb2YgciAhPSBcIm9iamVjdFwiIHx8ICFyLmNvZGUgfHwgIWFmKHIuY29kZSwgITEpIHx8ICFyLm1lc3NhZ2UgfHwgIWJ0KHIubWVzc2FnZSwgITEpKTtcbn1cbmZ1bmN0aW9uIE1tKHIpIHtcbiAgcmV0dXJuICEoenQocikgfHwgIWJ0KHIubWV0aG9kLCAhMSkpO1xufVxuZnVuY3Rpb24gSW0ocikge1xuICByZXR1cm4gISh6dChyKSB8fCB6dChyLnJlc3VsdCkgJiYgenQoci5lcnJvcikgfHwgIWFmKHIuaWQsICExKSB8fCAhYnQoci5qc29ucnBjLCAhMSkpO1xufVxuZnVuY3Rpb24gQW0ocikge1xuICByZXR1cm4gISh6dChyKSB8fCAhYnQoci5uYW1lLCAhMSkpO1xufVxuZnVuY3Rpb24gS2MociwgZSkge1xuICByZXR1cm4gISghWnMoZSkgfHwgIW5tKHIpLmluY2x1ZGVzKGUpKTtcbn1cbmZ1bmN0aW9uIERtKHIsIGUsIHQpIHtcbiAgcmV0dXJuIGJ0KHQsICExKSA/IHNtKHIsIGUpLmluY2x1ZGVzKHQpIDogITE7XG59XG5mdW5jdGlvbiBQbShyLCBlLCB0KSB7XG4gIHJldHVybiBidCh0LCAhMSkgPyBhbShyLCBlKS5pbmNsdWRlcyh0KSA6ICExO1xufVxuZnVuY3Rpb24gSGMociwgZSwgdCkge1xuICBsZXQgaSA9IG51bGw7XG4gIGNvbnN0IG4gPSBPbShyKSwgcyA9IFJtKGUpLCBvID0gT2JqZWN0LmtleXMobiksIGYgPSBPYmplY3Qua2V5cyhzKSwgaCA9IFZjKE9iamVjdC5rZXlzKHIpKSwgZCA9IFZjKE9iamVjdC5rZXlzKGUpKSwgdiA9IGguZmlsdGVyKCh3KSA9PiAhZC5pbmNsdWRlcyh3KSk7XG4gIHJldHVybiB2Lmxlbmd0aCAmJiAoaSA9IGFlKFwiTk9OX0NPTkZPUk1JTkdfTkFNRVNQQUNFU1wiLCBgJHt0fSBuYW1lc3BhY2VzIGtleXMgZG9uJ3Qgc2F0aXNmeSByZXF1aXJlZE5hbWVzcGFjZXMuXG4gICAgICBSZXF1aXJlZDogJHt2LnRvU3RyaW5nKCl9XG4gICAgICBSZWNlaXZlZDogJHtPYmplY3Qua2V5cyhlKS50b1N0cmluZygpfWApKSwgVWkobywgZikgfHwgKGkgPSBhZShcIk5PTl9DT05GT1JNSU5HX05BTUVTUEFDRVNcIiwgYCR7dH0gbmFtZXNwYWNlcyBjaGFpbnMgZG9uJ3Qgc2F0aXNmeSByZXF1aXJlZCBuYW1lc3BhY2VzLlxuICAgICAgUmVxdWlyZWQ6ICR7by50b1N0cmluZygpfVxuICAgICAgQXBwcm92ZWQ6ICR7Zi50b1N0cmluZygpfWApKSwgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgodykgPT4ge1xuICAgIGlmICghdy5pbmNsdWRlcyhcIjpcIikgfHwgaSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBBID0gSW4oZVt3XS5hY2NvdW50cyk7XG4gICAgQS5pbmNsdWRlcyh3KSB8fCAoaSA9IGFlKFwiTk9OX0NPTkZPUk1JTkdfTkFNRVNQQUNFU1wiLCBgJHt0fSBuYW1lc3BhY2VzIGFjY291bnRzIGRvbid0IHNhdGlzZnkgbmFtZXNwYWNlIGFjY291bnRzIGZvciAke3d9XG4gICAgICAgIFJlcXVpcmVkOiAke3d9XG4gICAgICAgIEFwcHJvdmVkOiAke0EudG9TdHJpbmcoKX1gKSk7XG4gIH0pLCBvLmZvckVhY2goKHcpID0+IHtcbiAgICBpIHx8IChVaShuW3ddLm1ldGhvZHMsIHNbd10ubWV0aG9kcykgPyBVaShuW3ddLmV2ZW50cywgc1t3XS5ldmVudHMpIHx8IChpID0gYWUoXCJOT05fQ09ORk9STUlOR19OQU1FU1BBQ0VTXCIsIGAke3R9IG5hbWVzcGFjZXMgZXZlbnRzIGRvbid0IHNhdGlzZnkgbmFtZXNwYWNlIGV2ZW50cyBmb3IgJHt3fWApKSA6IGkgPSBhZShcIk5PTl9DT05GT1JNSU5HX05BTUVTUEFDRVNcIiwgYCR7dH0gbmFtZXNwYWNlcyBtZXRob2RzIGRvbid0IHNhdGlzZnkgbmFtZXNwYWNlIG1ldGhvZHMgZm9yICR7d31gKSk7XG4gIH0pLCBpO1xufVxuZnVuY3Rpb24gT20ocikge1xuICBjb25zdCBlID0ge307XG4gIHJldHVybiBPYmplY3Qua2V5cyhyKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgdmFyIGk7XG4gICAgdC5pbmNsdWRlcyhcIjpcIikgPyBlW3RdID0gclt0XSA6IChpID0gclt0XS5jaGFpbnMpID09IG51bGwgfHwgaS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBlW25dID0geyBtZXRob2RzOiByW3RdLm1ldGhvZHMsIGV2ZW50czogclt0XS5ldmVudHMgfTtcbiAgICB9KTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBWYyhyKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChyLm1hcCgoZSkgPT4gZS5pbmNsdWRlcyhcIjpcIikgPyBlLnNwbGl0KFwiOlwiKVswXSA6IGUpKV07XG59XG5mdW5jdGlvbiBSbShyKSB7XG4gIGNvbnN0IGUgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHIpLmZvckVhY2goKHQpID0+IHtcbiAgICB0LmluY2x1ZGVzKFwiOlwiKSA/IGVbdF0gPSByW3RdIDogSW4oclt0XS5hY2NvdW50cyk/LmZvckVhY2goKG4pID0+IHtcbiAgICAgIGVbbl0gPSB7IGFjY291bnRzOiByW3RdLmFjY291bnRzLmZpbHRlcigocykgPT4gcy5pbmNsdWRlcyhgJHtufTpgKSksIG1ldGhvZHM6IHJbdF0ubWV0aG9kcywgZXZlbnRzOiByW3RdLmV2ZW50cyB9O1xuICAgIH0pO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIE5tKHIsIGUpIHtcbiAgcmV0dXJuIGFmKHIsICExKSAmJiByIDw9IGUubWF4ICYmIHIgPj0gZS5taW47XG59XG5mdW5jdGlvbiBXYygpIHtcbiAgY29uc3QgciA9IGhzKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoZSkgPT4ge1xuICAgIHN3aXRjaCAocikge1xuICAgICAgY2FzZSByci5icm93c2VyOlxuICAgICAgICBlKFRtKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcnIucmVhY3ROYXRpdmU6XG4gICAgICAgIGUoQ20oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSByci5ub2RlOlxuICAgICAgICBlKCRtKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGUoITApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBUbSgpIHtcbiAgcmV0dXJuIGNzKCkgJiYgbmF2aWdhdG9yPy5vbkxpbmU7XG59XG5hc3luYyBmdW5jdGlvbiBDbSgpIHtcbiAgcmV0dXJuIEFpKCkgJiYgdHlwZW9mIGdsb2JhbCA8IFwidVwiICYmIGdsb2JhbCAhPSBudWxsICYmIGdsb2JhbC5OZXRJbmZvID8gKGF3YWl0IChnbG9iYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbC5OZXRJbmZvLmZldGNoKCkpKT8uaXNDb25uZWN0ZWQgOiAhMDtcbn1cbmZ1bmN0aW9uICRtKCkge1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBMbShyKSB7XG4gIHN3aXRjaCAoaHMoKSkge1xuICAgIGNhc2UgcnIuYnJvd3NlcjpcbiAgICAgIEZtKHIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSByci5yZWFjdE5hdGl2ZTpcbiAgICAgIHFtKHIpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIEZtKHIpIHtcbiAgIUFpKCkgJiYgY3MoKSAmJiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgKCkgPT4gcighMCkpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgKCkgPT4gcighMSkpKTtcbn1cbmZ1bmN0aW9uIHFtKHIpIHtcbiAgQWkoKSAmJiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgJiYgZ2xvYmFsICE9IG51bGwgJiYgZ2xvYmFsLk5ldEluZm8gJiYgZ2xvYmFsPy5OZXRJbmZvLmFkZEV2ZW50TGlzdGVuZXIoKGUpID0+IHIoZT8uaXNDb25uZWN0ZWQpKTtcbn1cbmNvbnN0IHRvID0ge307XG5jbGFzcyBGbiB7XG4gIHN0YXRpYyBnZXQoZSkge1xuICAgIHJldHVybiB0b1tlXTtcbiAgfVxuICBzdGF0aWMgc2V0KGUsIHQpIHtcbiAgICB0b1tlXSA9IHQ7XG4gIH1cbiAgc3RhdGljIGRlbGV0ZShlKSB7XG4gICAgZGVsZXRlIHRvW2VdO1xuICB9XG59XG5jb25zdCBVbSA9IFwiUEFSU0VfRVJST1JcIiwgem0gPSBcIklOVkFMSURfUkVRVUVTVFwiLCBCbSA9IFwiTUVUSE9EX05PVF9GT1VORFwiLCBrbSA9IFwiSU5WQUxJRF9QQVJBTVNcIiwgZ2QgPSBcIklOVEVSTkFMX0VSUk9SXCIsIG9mID0gXCJTRVJWRVJfRVJST1JcIiwgam0gPSBbLTMyNzAwLCAtMzI2MDAsIC0zMjYwMSwgLTMyNjAyLCAtMzI2MDNdLCBIbiA9IHtcbiAgW1VtXTogeyBjb2RlOiAtMzI3MDAsIG1lc3NhZ2U6IFwiUGFyc2UgZXJyb3JcIiB9LFxuICBbem1dOiB7IGNvZGU6IC0zMjYwMCwgbWVzc2FnZTogXCJJbnZhbGlkIFJlcXVlc3RcIiB9LFxuICBbQm1dOiB7IGNvZGU6IC0zMjYwMSwgbWVzc2FnZTogXCJNZXRob2Qgbm90IGZvdW5kXCIgfSxcbiAgW2ttXTogeyBjb2RlOiAtMzI2MDIsIG1lc3NhZ2U6IFwiSW52YWxpZCBwYXJhbXNcIiB9LFxuICBbZ2RdOiB7IGNvZGU6IC0zMjYwMywgbWVzc2FnZTogXCJJbnRlcm5hbCBlcnJvclwiIH0sXG4gIFtvZl06IHsgY29kZTogLTMyZTMsIG1lc3NhZ2U6IFwiU2VydmVyIGVycm9yXCIgfVxufSwgeWQgPSBvZjtcbmZ1bmN0aW9uIEttKHIpIHtcbiAgcmV0dXJuIGptLmluY2x1ZGVzKHIpO1xufVxuZnVuY3Rpb24gR2Mocikge1xuICByZXR1cm4gT2JqZWN0LmtleXMoSG4pLmluY2x1ZGVzKHIpID8gSG5bcl0gOiBIblt5ZF07XG59XG5mdW5jdGlvbiBIbShyKSB7XG4gIGNvbnN0IGUgPSBPYmplY3QudmFsdWVzKEhuKS5maW5kKCh0KSA9PiB0LmNvZGUgPT09IHIpO1xuICByZXR1cm4gZSB8fCBIblt5ZF07XG59XG5mdW5jdGlvbiBWbShyLCBlLCB0KSB7XG4gIHJldHVybiByLm1lc3NhZ2UuaW5jbHVkZXMoXCJnZXRhZGRyaW5mbyBFTk9URk9VTkRcIikgfHwgci5tZXNzYWdlLmluY2x1ZGVzKFwiY29ubmVjdCBFQ09OTlJFRlVTRURcIikgPyBuZXcgRXJyb3IoYFVuYXZhaWxhYmxlICR7dH0gUlBDIHVybCBhdCAke2V9YCkgOiByO1xufVxudmFyIG1kID0ge30sIGlpID0ge30sIEpjO1xuZnVuY3Rpb24gV20oKSB7XG4gIGlmIChKYylcbiAgICByZXR1cm4gaWk7XG4gIEpjID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGlpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGlpLmlzQnJvd3NlckNyeXB0b0F2YWlsYWJsZSA9IGlpLmdldFN1YnRsZUNyeXB0byA9IGlpLmdldEJyb3dlckNyeXB0byA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gcigpIHtcbiAgICByZXR1cm4gKHRyID09PSBudWxsIHx8IHRyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ci5jcnlwdG8pIHx8ICh0ciA9PT0gbnVsbCB8fCB0ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHIubXNDcnlwdG8pIHx8IHt9O1xuICB9XG4gIGlpLmdldEJyb3dlckNyeXB0byA9IHI7XG4gIGZ1bmN0aW9uIGUoKSB7XG4gICAgY29uc3QgaSA9IHIoKTtcbiAgICByZXR1cm4gaS5zdWJ0bGUgfHwgaS53ZWJraXRTdWJ0bGU7XG4gIH1cbiAgaWkuZ2V0U3VidGxlQ3J5cHRvID0gZTtcbiAgZnVuY3Rpb24gdCgpIHtcbiAgICByZXR1cm4gISFyKCkgJiYgISFlKCk7XG4gIH1cbiAgcmV0dXJuIGlpLmlzQnJvd3NlckNyeXB0b0F2YWlsYWJsZSA9IHQsIGlpO1xufVxudmFyIG5pID0ge30sIFljO1xuZnVuY3Rpb24gR20oKSB7XG4gIGlmIChZYylcbiAgICByZXR1cm4gbmk7XG4gIFljID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5pLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG5pLmlzQnJvd3NlciA9IG5pLmlzTm9kZSA9IG5pLmlzUmVhY3ROYXRpdmUgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIHIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCA+IFwidVwiICYmIHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiO1xuICB9XG4gIG5pLmlzUmVhY3ROYXRpdmUgPSByO1xuICBmdW5jdGlvbiBlKCkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvY2VzcyA8IFwidVwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zIDwgXCJ1XCIgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSA8IFwidVwiO1xuICB9XG4gIG5pLmlzTm9kZSA9IGU7XG4gIGZ1bmN0aW9uIHQoKSB7XG4gICAgcmV0dXJuICFyKCkgJiYgIWUoKTtcbiAgfVxuICByZXR1cm4gbmkuaXNCcm93c2VyID0gdCwgbmk7XG59XG4oZnVuY3Rpb24ocikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICBjb25zdCBlID0gUW47XG4gIGUuX19leHBvcnRTdGFyKFdtKCksIHIpLCBlLl9fZXhwb3J0U3RhcihHbSgpLCByKTtcbn0pKG1kKTtcbmZ1bmN0aW9uIG9pKHIgPSAzKSB7XG4gIGNvbnN0IGUgPSBEYXRlLm5vdygpICogTWF0aC5wb3coMTAsIHIpLCB0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMTAsIHIpKTtcbiAgcmV0dXJuIGUgKyB0O1xufVxuZnVuY3Rpb24gemkociA9IDYpIHtcbiAgcmV0dXJuIEJpZ0ludChvaShyKSk7XG59XG5mdW5jdGlvbiBCaShyLCBlLCB0KSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IHQgfHwgb2koKSxcbiAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgIG1ldGhvZDogcixcbiAgICBwYXJhbXM6IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIE1hKHIsIGUpIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogcixcbiAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgIHJlc3VsdDogZVxuICB9O1xufVxuZnVuY3Rpb24gSWEociwgZSwgdCkge1xuICByZXR1cm4ge1xuICAgIGlkOiByLFxuICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgZXJyb3I6IEptKGUsIHQpXG4gIH07XG59XG5mdW5jdGlvbiBKbShyLCBlKSB7XG4gIHJldHVybiB0eXBlb2YgciA+IFwidVwiID8gR2MoZ2QpIDogKHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgKHIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEdjKG9mKSksIHsgbWVzc2FnZTogciB9KSksIHR5cGVvZiBlIDwgXCJ1XCIgJiYgKHIuZGF0YSA9IGUpLCBLbShyLmNvZGUpICYmIChyID0gSG0oci5jb2RlKSksIHIpO1xufVxuY2xhc3Mgd2Qge1xufVxubGV0IFltID0gY2xhc3MgZXh0ZW5kcyB3ZCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpO1xuICB9XG59O1xuY2xhc3MgWG0gZXh0ZW5kcyB3ZCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cbn1cbmxldCBabSA9IGNsYXNzIGV4dGVuZHMgWG0ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufTtcbmNvbnN0IFFtID0gXCJed3NzPzpcIjtcbmZ1bmN0aW9uIGUzKHIpIHtcbiAgY29uc3QgZSA9IHIubWF0Y2gobmV3IFJlZ0V4cCgvXlxcdys6LywgXCJnaVwiKSk7XG4gIGlmICghKCFlIHx8ICFlLmxlbmd0aCkpXG4gICAgcmV0dXJuIGVbMF07XG59XG5mdW5jdGlvbiB0MyhyLCBlKSB7XG4gIGNvbnN0IHQgPSBlMyhyKTtcbiAgcmV0dXJuIHR5cGVvZiB0ID4gXCJ1XCIgPyAhMSA6IG5ldyBSZWdFeHAoZSkudGVzdCh0KTtcbn1cbmZ1bmN0aW9uIFhjKHIpIHtcbiAgcmV0dXJuIHQzKHIsIFFtKTtcbn1cbmZ1bmN0aW9uIHIzKHIpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJ3c3M/Oi8vbG9jYWxob3N0KDpkezIsNX0pP1wiKS50ZXN0KHIpO1xufVxuZnVuY3Rpb24gX2Qocikge1xuICByZXR1cm4gdHlwZW9mIHIgPT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gciAmJiBcImpzb25ycGNcIiBpbiByICYmIHIuanNvbnJwYyA9PT0gXCIyLjBcIjtcbn1cbmZ1bmN0aW9uIGZmKHIpIHtcbiAgcmV0dXJuIF9kKHIpICYmIFwibWV0aG9kXCIgaW4gcjtcbn1cbmZ1bmN0aW9uIEFhKHIpIHtcbiAgcmV0dXJuIF9kKHIpICYmIChScihyKSB8fCBkcihyKSk7XG59XG5mdW5jdGlvbiBScihyKSB7XG4gIHJldHVybiBcInJlc3VsdFwiIGluIHI7XG59XG5mdW5jdGlvbiBkcihyKSB7XG4gIHJldHVybiBcImVycm9yXCIgaW4gcjtcbn1cbmNsYXNzIHhkIGV4dGVuZHMgWm0ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSksIHRoaXMuZXZlbnRzID0gbmV3IGlyLkV2ZW50RW1pdHRlcigpLCB0aGlzLmhhc1JlZ2lzdGVyZWRFdmVudExpc3RlbmVycyA9ICExLCB0aGlzLmNvbm5lY3Rpb24gPSB0aGlzLnNldENvbm5lY3Rpb24oZSksIHRoaXMuY29ubmVjdGlvbi5jb25uZWN0ZWQgJiYgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChlID0gdGhpcy5jb25uZWN0aW9uKSB7XG4gICAgYXdhaXQgdGhpcy5vcGVuKGUpO1xuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgYXdhaXQgdGhpcy5jbG9zZSgpO1xuICB9XG4gIG9uKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vbihlLCB0KTtcbiAgfVxuICBvbmNlKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vbmNlKGUsIHQpO1xuICB9XG4gIG9mZihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHMub2ZmKGUsIHQpO1xuICB9XG4gIHJlbW92ZUxpc3RlbmVyKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihlLCB0KTtcbiAgfVxuICBhc3luYyByZXF1ZXN0KGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0U3RyaWN0KEJpKGUubWV0aG9kLCBlLnBhcmFtcyB8fCBbXSwgZS5pZCB8fCB6aSgpLnRvU3RyaW5nKCkpLCB0KTtcbiAgfVxuICBhc3luYyByZXF1ZXN0U3RyaWN0KGUsIHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKGksIG4pID0+IHtcbiAgICAgIGlmICghdGhpcy5jb25uZWN0aW9uLmNvbm5lY3RlZClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLm9wZW4oKTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgIG4ocyk7XG4gICAgICAgIH1cbiAgICAgIHRoaXMuZXZlbnRzLm9uKGAke2UuaWR9YCwgKHMpID0+IHtcbiAgICAgICAgZHIocykgPyBuKHMuZXJyb3IpIDogaShzLnJlc3VsdCk7XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kKGUsIHQpO1xuICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICBuKHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldENvbm5lY3Rpb24oZSA9IHRoaXMuY29ubmVjdGlvbikge1xuICAgIHJldHVybiBlO1xuICB9XG4gIG9uUGF5bG9hZChlKSB7XG4gICAgdGhpcy5ldmVudHMuZW1pdChcInBheWxvYWRcIiwgZSksIEFhKGUpID8gdGhpcy5ldmVudHMuZW1pdChgJHtlLmlkfWAsIGUpIDogdGhpcy5ldmVudHMuZW1pdChcIm1lc3NhZ2VcIiwgeyB0eXBlOiBlLm1ldGhvZCwgZGF0YTogZS5wYXJhbXMgfSk7XG4gIH1cbiAgb25DbG9zZShlKSB7XG4gICAgZSAmJiBlLmNvZGUgPT09IDNlMyAmJiB0aGlzLmV2ZW50cy5lbWl0KFwiZXJyb3JcIiwgbmV3IEVycm9yKGBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQgYWJub3JtYWxseSB3aXRoIGNvZGU6ICR7ZS5jb2RlfSAke2UucmVhc29uID8gYCgke2UucmVhc29ufSlgIDogXCJcIn1gKSksIHRoaXMuZXZlbnRzLmVtaXQoXCJkaXNjb25uZWN0XCIpO1xuICB9XG4gIGFzeW5jIG9wZW4oZSA9IHRoaXMuY29ubmVjdGlvbikge1xuICAgIHRoaXMuY29ubmVjdGlvbiA9PT0gZSAmJiB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdGVkIHx8ICh0aGlzLmNvbm5lY3Rpb24uY29ubmVjdGVkICYmIHRoaXMuY2xvc2UoKSwgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiAoYXdhaXQgdGhpcy5jb25uZWN0aW9uLm9wZW4oZSksIGUgPSB0aGlzLmNvbm5lY3Rpb24pLCB0aGlzLmNvbm5lY3Rpb24gPSB0aGlzLnNldENvbm5lY3Rpb24oZSksIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5vcGVuKCksIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCB0aGlzLmV2ZW50cy5lbWl0KFwiY29ubmVjdFwiKSk7XG4gIH1cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG4gIH1cbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLmhhc1JlZ2lzdGVyZWRFdmVudExpc3RlbmVycyB8fCAodGhpcy5jb25uZWN0aW9uLm9uKFwicGF5bG9hZFwiLCAoZSkgPT4gdGhpcy5vblBheWxvYWQoZSkpLCB0aGlzLmNvbm5lY3Rpb24ub24oXCJjbG9zZVwiLCAoZSkgPT4gdGhpcy5vbkNsb3NlKGUpKSwgdGhpcy5jb25uZWN0aW9uLm9uKFwiZXJyb3JcIiwgKGUpID0+IHRoaXMuZXZlbnRzLmVtaXQoXCJlcnJvclwiLCBlKSksIHRoaXMuY29ubmVjdGlvbi5vbihcInJlZ2lzdGVyX2Vycm9yXCIsIChlKSA9PiB0aGlzLm9uQ2xvc2UoKSksIHRoaXMuaGFzUmVnaXN0ZXJlZEV2ZW50TGlzdGVuZXJzID0gITApO1xuICB9XG59XG5jb25zdCBpMyA9ICgpID0+IHR5cGVvZiBXZWJTb2NrZXQgPCBcInVcIiA/IFdlYlNvY2tldCA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiAmJiB0eXBlb2YgZ2xvYmFsLldlYlNvY2tldCA8IFwidVwiID8gZ2xvYmFsLldlYlNvY2tldCA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB0eXBlb2Ygd2luZG93LldlYlNvY2tldCA8IFwidVwiID8gd2luZG93LldlYlNvY2tldCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgJiYgdHlwZW9mIHNlbGYuV2ViU29ja2V0IDwgXCJ1XCIgPyBzZWxmLldlYlNvY2tldCA6IHJlcXVpcmUoXCJ3c1wiKSwgbjMgPSAoKSA9PiB0eXBlb2YgV2ViU29ja2V0IDwgXCJ1XCIgfHwgdHlwZW9mIGdsb2JhbCA8IFwidVwiICYmIHR5cGVvZiBnbG9iYWwuV2ViU29ja2V0IDwgXCJ1XCIgfHwgdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHR5cGVvZiB3aW5kb3cuV2ViU29ja2V0IDwgXCJ1XCIgfHwgdHlwZW9mIHNlbGYgPCBcInVcIiAmJiB0eXBlb2Ygc2VsZi5XZWJTb2NrZXQgPCBcInVcIiwgWmMgPSAocikgPT4gci5zcGxpdChcIj9cIilbMF0sIFFjID0gMTAsIHMzID0gaTMoKTtcbmNsYXNzIGEzIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGlmICh0aGlzLnVybCA9IGUsIHRoaXMuZXZlbnRzID0gbmV3IGlyLkV2ZW50RW1pdHRlcigpLCB0aGlzLnJlZ2lzdGVyaW5nID0gITEsICFYYyhlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvdmlkZWQgVVJMIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggV2ViU29ja2V0IGNvbm5lY3Rpb246ICR7ZX1gKTtcbiAgICB0aGlzLnVybCA9IGU7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuc29ja2V0IDwgXCJ1XCI7XG4gIH1cbiAgZ2V0IGNvbm5lY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJpbmc7XG4gIH1cbiAgb24oZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uKGUsIHQpO1xuICB9XG4gIG9uY2UoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uY2UoZSwgdCk7XG4gIH1cbiAgb2ZmKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vZmYoZSwgdCk7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGUsIHQpO1xuICB9XG4gIGFzeW5jIG9wZW4oZSA9IHRoaXMudXJsKSB7XG4gICAgYXdhaXQgdGhpcy5yZWdpc3RlcihlKTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGUsIHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zb2NrZXQgPiBcInVcIikge1xuICAgICAgICB0KG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gYWxyZWFkeSBjbG9zZWRcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldC5vbmNsb3NlID0gKGkpID0+IHtcbiAgICAgICAgdGhpcy5vbkNsb3NlKGkpLCBlKCk7XG4gICAgICB9LCB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNlbmQoZSkge1xuICAgIHR5cGVvZiB0aGlzLnNvY2tldCA+IFwidVwiICYmICh0aGlzLnNvY2tldCA9IGF3YWl0IHRoaXMucmVnaXN0ZXIoKSk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQoamkoZSkpO1xuICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgIHRoaXMub25FcnJvcihlLmlkLCB0KTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXIoZSA9IHRoaXMudXJsKSB7XG4gICAgaWYgKCFYYyhlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvdmlkZWQgVVJMIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggV2ViU29ja2V0IGNvbm5lY3Rpb246ICR7ZX1gKTtcbiAgICBpZiAodGhpcy5yZWdpc3RlcmluZykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuZXZlbnRzLmdldE1heExpc3RlbmVycygpO1xuICAgICAgcmV0dXJuICh0aGlzLmV2ZW50cy5saXN0ZW5lckNvdW50KFwicmVnaXN0ZXJfZXJyb3JcIikgPj0gdCB8fCB0aGlzLmV2ZW50cy5saXN0ZW5lckNvdW50KFwib3BlblwiKSA+PSB0KSAmJiB0aGlzLmV2ZW50cy5zZXRNYXhMaXN0ZW5lcnModCArIDEpLCBuZXcgUHJvbWlzZSgoaSwgbikgPT4ge1xuICAgICAgICB0aGlzLmV2ZW50cy5vbmNlKFwicmVnaXN0ZXJfZXJyb3JcIiwgKHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TWF4TGlzdGVuZXJzKCksIG4ocyk7XG4gICAgICAgIH0pLCB0aGlzLmV2ZW50cy5vbmNlKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMucmVzZXRNYXhMaXN0ZW5lcnMoKSwgdHlwZW9mIHRoaXMuc29ja2V0ID4gXCJ1XCIpXG4gICAgICAgICAgICByZXR1cm4gbihuZXcgRXJyb3IoXCJXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBtaXNzaW5nIG9yIGludmFsaWRcIikpO1xuICAgICAgICAgIGkodGhpcy5zb2NrZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51cmwgPSBlLCB0aGlzLnJlZ2lzdGVyaW5nID0gITAsIG5ldyBQcm9taXNlKCh0LCBpKSA9PiB7XG4gICAgICBjb25zdCBuID0gbWQuaXNSZWFjdE5hdGl2ZSgpID8gdm9pZCAwIDogeyByZWplY3RVbmF1dGhvcml6ZWQ6ICFyMyhlKSB9LCBzID0gbmV3IHMzKGUsIFtdLCBuKTtcbiAgICAgIG4zKCkgPyBzLm9uZXJyb3IgPSAobykgPT4ge1xuICAgICAgICBjb25zdCBmID0gbztcbiAgICAgICAgaSh0aGlzLmVtaXRFcnJvcihmLmVycm9yKSk7XG4gICAgICB9IDogcy5vbihcImVycm9yXCIsIChvKSA9PiB7XG4gICAgICAgIGkodGhpcy5lbWl0RXJyb3IobykpO1xuICAgICAgfSksIHMub25vcGVuID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm9uT3BlbihzKSwgdChzKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgb25PcGVuKGUpIHtcbiAgICBlLm9ubWVzc2FnZSA9ICh0KSA9PiB0aGlzLm9uUGF5bG9hZCh0KSwgZS5vbmNsb3NlID0gKHQpID0+IHRoaXMub25DbG9zZSh0KSwgdGhpcy5zb2NrZXQgPSBlLCB0aGlzLnJlZ2lzdGVyaW5nID0gITEsIHRoaXMuZXZlbnRzLmVtaXQoXCJvcGVuXCIpO1xuICB9XG4gIG9uQ2xvc2UoZSkge1xuICAgIHRoaXMuc29ja2V0ID0gdm9pZCAwLCB0aGlzLnJlZ2lzdGVyaW5nID0gITEsIHRoaXMuZXZlbnRzLmVtaXQoXCJjbG9zZVwiLCBlKTtcbiAgfVxuICBvblBheWxvYWQoZSkge1xuICAgIGlmICh0eXBlb2YgZS5kYXRhID4gXCJ1XCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHR5cGVvZiBlLmRhdGEgPT0gXCJzdHJpbmdcIiA/IHVuKGUuZGF0YSkgOiBlLmRhdGE7XG4gICAgdGhpcy5ldmVudHMuZW1pdChcInBheWxvYWRcIiwgdCk7XG4gIH1cbiAgb25FcnJvcihlLCB0KSB7XG4gICAgY29uc3QgaSA9IHRoaXMucGFyc2VFcnJvcih0KSwgbiA9IGkubWVzc2FnZSB8fCBpLnRvU3RyaW5nKCksIHMgPSBJYShlLCBuKTtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KFwicGF5bG9hZFwiLCBzKTtcbiAgfVxuICBwYXJzZUVycm9yKGUsIHQgPSB0aGlzLnVybCkge1xuICAgIHJldHVybiBWbShlLCBaYyh0KSwgXCJXU1wiKTtcbiAgfVxuICByZXNldE1heExpc3RlbmVycygpIHtcbiAgICB0aGlzLmV2ZW50cy5nZXRNYXhMaXN0ZW5lcnMoKSA+IFFjICYmIHRoaXMuZXZlbnRzLnNldE1heExpc3RlbmVycyhRYyk7XG4gIH1cbiAgZW1pdEVycm9yKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5wYXJzZUVycm9yKG5ldyBFcnJvcihlPy5tZXNzYWdlIHx8IGBXZWJTb2NrZXQgY29ubmVjdGlvbiBmYWlsZWQgZm9yIGhvc3Q6ICR7WmModGhpcy51cmwpfWApKTtcbiAgICByZXR1cm4gdGhpcy5ldmVudHMuZW1pdChcInJlZ2lzdGVyX2Vycm9yXCIsIHQpLCB0O1xuICB9XG59XG52YXIgUXMgPSB7IGV4cG9ydHM6IHt9IH07XG5Rcy5leHBvcnRzO1xuKGZ1bmN0aW9uKHIsIGUpIHtcbiAgdmFyIHQgPSAyMDAsIGkgPSBcIl9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX19cIiwgbiA9IDEsIHMgPSAyLCBvID0gOTAwNzE5OTI1NDc0MDk5MSwgZiA9IFwiW29iamVjdCBBcmd1bWVudHNdXCIsIGggPSBcIltvYmplY3QgQXJyYXldXCIsIGQgPSBcIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIiwgdiA9IFwiW29iamVjdCBCb29sZWFuXVwiLCB3ID0gXCJbb2JqZWN0IERhdGVdXCIsIEEgPSBcIltvYmplY3QgRXJyb3JdXCIsIEkgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsIEQgPSBcIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCIsIE4gPSBcIltvYmplY3QgTWFwXVwiLCBrID0gXCJbb2JqZWN0IE51bWJlcl1cIiwgaiA9IFwiW29iamVjdCBOdWxsXVwiLCBUID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgSyA9IFwiW29iamVjdCBQcm9taXNlXVwiLCAkID0gXCJbb2JqZWN0IFByb3h5XVwiLCB6ID0gXCJbb2JqZWN0IFJlZ0V4cF1cIiwgQiA9IFwiW29iamVjdCBTZXRdXCIsIF8gPSBcIltvYmplY3QgU3RyaW5nXVwiLCBSID0gXCJbb2JqZWN0IFN5bWJvbF1cIiwgSiA9IFwiW29iamVjdCBVbmRlZmluZWRdXCIsIFEgPSBcIltvYmplY3QgV2Vha01hcF1cIiwgTyA9IFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIiwgcCA9IFwiW29iamVjdCBEYXRhVmlld11cIiwgbCA9IFwiW29iamVjdCBGbG9hdDMyQXJyYXldXCIsIGEgPSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiLCBjID0gXCJbb2JqZWN0IEludDhBcnJheV1cIiwgYiA9IFwiW29iamVjdCBJbnQxNkFycmF5XVwiLCBFID0gXCJbb2JqZWN0IEludDMyQXJyYXldXCIsIFMgPSBcIltvYmplY3QgVWludDhBcnJheV1cIiwgeCA9IFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIiwgdSA9IFwiW29iamVjdCBVaW50MTZBcnJheV1cIiwgbSA9IFwiW29iamVjdCBVaW50MzJBcnJheV1cIiwgZyA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgUCA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC8sIEcgPSAvXig/OjB8WzEtOV1cXGQqKSQvLCBNID0ge307XG4gIE1bbF0gPSBNW2FdID0gTVtjXSA9IE1bYl0gPSBNW0VdID0gTVtTXSA9IE1beF0gPSBNW3VdID0gTVttXSA9ICEwLCBNW2ZdID0gTVtoXSA9IE1bT10gPSBNW3ZdID0gTVtwXSA9IE1bd10gPSBNW0FdID0gTVtJXSA9IE1bTl0gPSBNW2tdID0gTVtUXSA9IE1bel0gPSBNW0JdID0gTVtfXSA9IE1bUV0gPSAhMTtcbiAgdmFyIEggPSB0eXBlb2YgdHIgPT0gXCJvYmplY3RcIiAmJiB0ciAmJiB0ci5PYmplY3QgPT09IE9iamVjdCAmJiB0ciwgQyA9IHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGYsIHEgPSBIIHx8IEMgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpLCBMID0gZSAmJiAhZS5ub2RlVHlwZSAmJiBlLCB5ID0gTCAmJiAhMCAmJiByICYmICFyLm5vZGVUeXBlICYmIHIsIEYgPSB5ICYmIHkuZXhwb3J0cyA9PT0gTCwgVyA9IEYgJiYgSC5wcm9jZXNzLCBZID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBXICYmIFcuYmluZGluZyAmJiBXLmJpbmRpbmcoXCJ1dGlsXCIpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfSgpLCBYID0gWSAmJiBZLmlzVHlwZWRBcnJheTtcbiAgZnVuY3Rpb24gZWUoVSwgVikge1xuICAgIGZvciAodmFyIFogPSAtMSwgYmUgPSBVID09IG51bGwgPyAwIDogVS5sZW5ndGgsIGN0ID0gMCwgV2UgPSBbXTsgKytaIDwgYmU7ICkge1xuICAgICAgdmFyIGR0ID0gVVtaXTtcbiAgICAgIFYoZHQsIFosIFUpICYmIChXZVtjdCsrXSA9IGR0KTtcbiAgICB9XG4gICAgcmV0dXJuIFdlO1xuICB9XG4gIGZ1bmN0aW9uIHdlKFUsIFYpIHtcbiAgICBmb3IgKHZhciBaID0gLTEsIGJlID0gVi5sZW5ndGgsIGN0ID0gVS5sZW5ndGg7ICsrWiA8IGJlOyApXG4gICAgICBVW2N0ICsgWl0gPSBWW1pdO1xuICAgIHJldHVybiBVO1xuICB9XG4gIGZ1bmN0aW9uIE1lKFUsIFYpIHtcbiAgICBmb3IgKHZhciBaID0gLTEsIGJlID0gVSA9PSBudWxsID8gMCA6IFUubGVuZ3RoOyArK1ogPCBiZTsgKVxuICAgICAgaWYgKFYoVVtaXSwgWiwgVSkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZnVuY3Rpb24gaGUoVSwgVikge1xuICAgIGZvciAodmFyIFogPSAtMSwgYmUgPSBBcnJheShVKTsgKytaIDwgVTsgKVxuICAgICAgYmVbWl0gPSBWKFopO1xuICAgIHJldHVybiBiZTtcbiAgfVxuICBmdW5jdGlvbiBSZShVKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKFYpIHtcbiAgICAgIHJldHVybiBVKFYpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24geGUoVSwgVikge1xuICAgIHJldHVybiBVLmhhcyhWKTtcbiAgfVxuICBmdW5jdGlvbiBzZShVLCBWKSB7XG4gICAgcmV0dXJuIFU/LltWXTtcbiAgfVxuICBmdW5jdGlvbiBnZShVKSB7XG4gICAgdmFyIFYgPSAtMSwgWiA9IEFycmF5KFUuc2l6ZSk7XG4gICAgcmV0dXJuIFUuZm9yRWFjaChmdW5jdGlvbihiZSwgY3QpIHtcbiAgICAgIFpbKytWXSA9IFtjdCwgYmVdO1xuICAgIH0pLCBaO1xuICB9XG4gIGZ1bmN0aW9uIGxlKFUsIFYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oWikge1xuICAgICAgcmV0dXJuIFUoVihaKSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBuZShVKSB7XG4gICAgdmFyIFYgPSAtMSwgWiA9IEFycmF5KFUuc2l6ZSk7XG4gICAgcmV0dXJuIFUuZm9yRWFjaChmdW5jdGlvbihiZSkge1xuICAgICAgWlsrK1ZdID0gYmU7XG4gICAgfSksIFo7XG4gIH1cbiAgdmFyIHVlID0gQXJyYXkucHJvdG90eXBlLCBmZSA9IEZ1bmN0aW9uLnByb3RvdHlwZSwgdGUgPSBPYmplY3QucHJvdG90eXBlLCBwZSA9IHFbXCJfX2NvcmUtanNfc2hhcmVkX19cIl0sIF9lID0gZmUudG9TdHJpbmcsIHJlID0gdGUuaGFzT3duUHJvcGVydHksIEVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFUgPSAvW14uXSskLy5leGVjKHBlICYmIHBlLmtleXMgJiYgcGUua2V5cy5JRV9QUk9UTyB8fCBcIlwiKTtcbiAgICByZXR1cm4gVSA/IFwiU3ltYm9sKHNyYylfMS5cIiArIFUgOiBcIlwiO1xuICB9KCksIFNlID0gdGUudG9TdHJpbmcsIG9lID0gUmVnRXhwKFxuICAgIFwiXlwiICsgX2UuY2FsbChyZSkucmVwbGFjZShnLCBcIlxcXFwkJlwiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCBcIiQxLio/XCIpICsgXCIkXCJcbiAgKSwgRGUgPSBGID8gcS5CdWZmZXIgOiB2b2lkIDAsIEllID0gcS5TeW1ib2wsIFBlID0gcS5VaW50OEFycmF5LCBHZSA9IHRlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBZZSA9IHVlLnNwbGljZSwgQWUgPSBJZSA/IEllLnRvU3RyaW5nVGFnIDogdm9pZCAwLCBaZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIGV0ID0gRGUgPyBEZS5pc0J1ZmZlciA6IHZvaWQgMCwgTmUgPSBsZShPYmplY3Qua2V5cywgT2JqZWN0KSwgQ2UgPSBlbihxLCBcIkRhdGFWaWV3XCIpLCBUZSA9IGVuKHEsIFwiTWFwXCIpLCBkZSA9IGVuKHEsIFwiUHJvbWlzZVwiKSwgJGUgPSBlbihxLCBcIlNldFwiKSwgTGUgPSBlbihxLCBcIldlYWtNYXBcIiksIGNlID0gZW4oT2JqZWN0LCBcImNyZWF0ZVwiKSwgVWUgPSBEaShDZSksIHplID0gRGkoVGUpLCB5ZSA9IERpKGRlKSwgQmUgPSBEaSgkZSksIGtlID0gRGkoTGUpLCB2ZSA9IEllID8gSWUucHJvdG90eXBlIDogdm9pZCAwLCBGZSA9IHZlID8gdmUudmFsdWVPZiA6IHZvaWQgMDtcbiAgZnVuY3Rpb24gT2UoVSkge1xuICAgIHZhciBWID0gLTEsIFogPSBVID09IG51bGwgPyAwIDogVS5sZW5ndGg7XG4gICAgZm9yICh0aGlzLmNsZWFyKCk7ICsrViA8IFo7ICkge1xuICAgICAgdmFyIGJlID0gVVtWXTtcbiAgICAgIHRoaXMuc2V0KGJlWzBdLCBiZVsxXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lKCkge1xuICAgIHRoaXMuX19kYXRhX18gPSBjZSA/IGNlKG51bGwpIDoge30sIHRoaXMuc2l6ZSA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gamUoVSkge1xuICAgIHZhciBWID0gdGhpcy5oYXMoVSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19bVV07XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSAtPSBWID8gMSA6IDAsIFY7XG4gIH1cbiAgZnVuY3Rpb24gcnQoVSkge1xuICAgIHZhciBWID0gdGhpcy5fX2RhdGFfXztcbiAgICBpZiAoY2UpIHtcbiAgICAgIHZhciBaID0gVltVXTtcbiAgICAgIHJldHVybiBaID09PSBpID8gdm9pZCAwIDogWjtcbiAgICB9XG4gICAgcmV0dXJuIHJlLmNhbGwoViwgVSkgPyBWW1VdIDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIHFlKFUpIHtcbiAgICB2YXIgViA9IHRoaXMuX19kYXRhX187XG4gICAgcmV0dXJuIGNlID8gVltVXSAhPT0gdm9pZCAwIDogcmUuY2FsbChWLCBVKTtcbiAgfVxuICBmdW5jdGlvbiBpdChVLCBWKSB7XG4gICAgdmFyIFogPSB0aGlzLl9fZGF0YV9fO1xuICAgIHJldHVybiB0aGlzLnNpemUgKz0gdGhpcy5oYXMoVSkgPyAwIDogMSwgWltVXSA9IGNlICYmIFYgPT09IHZvaWQgMCA/IGkgOiBWLCB0aGlzO1xuICB9XG4gIE9lLnByb3RvdHlwZS5jbGVhciA9IG1lLCBPZS5wcm90b3R5cGUuZGVsZXRlID0gamUsIE9lLnByb3RvdHlwZS5nZXQgPSBydCwgT2UucHJvdG90eXBlLmhhcyA9IHFlLCBPZS5wcm90b3R5cGUuc2V0ID0gaXQ7XG4gIGZ1bmN0aW9uIEplKFUpIHtcbiAgICB2YXIgViA9IC0xLCBaID0gVSA9PSBudWxsID8gMCA6IFUubGVuZ3RoO1xuICAgIGZvciAodGhpcy5jbGVhcigpOyArK1YgPCBaOyApIHtcbiAgICAgIHZhciBiZSA9IFVbVl07XG4gICAgICB0aGlzLnNldChiZVswXSwgYmVbMV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0dCgpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gW10sIHRoaXMuc2l6ZSA9IDA7XG4gIH1cbiAgZnVuY3Rpb24ganQoVSkge1xuICAgIHZhciBWID0gdGhpcy5fX2RhdGFfXywgWiA9IHBzKFYsIFUpO1xuICAgIGlmIChaIDwgMClcbiAgICAgIHJldHVybiAhMTtcbiAgICB2YXIgYmUgPSBWLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIFogPT0gYmUgPyBWLnBvcCgpIDogWWUuY2FsbChWLCBaLCAxKSwgLS10aGlzLnNpemUsICEwO1xuICB9XG4gIGZ1bmN0aW9uIEt0KFUpIHtcbiAgICB2YXIgViA9IHRoaXMuX19kYXRhX18sIFogPSBwcyhWLCBVKTtcbiAgICByZXR1cm4gWiA8IDAgPyB2b2lkIDAgOiBWW1pdWzFdO1xuICB9XG4gIGZ1bmN0aW9uIEh0KFUpIHtcbiAgICByZXR1cm4gcHModGhpcy5fX2RhdGFfXywgVSkgPiAtMTtcbiAgfVxuICBmdW5jdGlvbiBWdChVLCBWKSB7XG4gICAgdmFyIFogPSB0aGlzLl9fZGF0YV9fLCBiZSA9IHBzKFosIFUpO1xuICAgIHJldHVybiBiZSA8IDAgPyAoKyt0aGlzLnNpemUsIFoucHVzaChbVSwgVl0pKSA6IFpbYmVdWzFdID0gViwgdGhpcztcbiAgfVxuICBKZS5wcm90b3R5cGUuY2xlYXIgPSB0dCwgSmUucHJvdG90eXBlLmRlbGV0ZSA9IGp0LCBKZS5wcm90b3R5cGUuZ2V0ID0gS3QsIEplLnByb3RvdHlwZS5oYXMgPSBIdCwgSmUucHJvdG90eXBlLnNldCA9IFZ0O1xuICBmdW5jdGlvbiBndChVKSB7XG4gICAgdmFyIFYgPSAtMSwgWiA9IFUgPT0gbnVsbCA/IDAgOiBVLmxlbmd0aDtcbiAgICBmb3IgKHRoaXMuY2xlYXIoKTsgKytWIDwgWjsgKSB7XG4gICAgICB2YXIgYmUgPSBVW1ZdO1xuICAgICAgdGhpcy5zZXQoYmVbMF0sIGJlWzFdKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gVnIoKSB7XG4gICAgdGhpcy5zaXplID0gMCwgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAgIGhhc2g6IG5ldyBPZSgpLFxuICAgICAgbWFwOiBuZXcgKFRlIHx8IEplKSgpLFxuICAgICAgc3RyaW5nOiBuZXcgT2UoKVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gV3IoVSkge1xuICAgIHZhciBWID0gdnModGhpcywgVSkuZGVsZXRlKFUpO1xuICAgIHJldHVybiB0aGlzLnNpemUgLT0gViA/IDEgOiAwLCBWO1xuICB9XG4gIGZ1bmN0aW9uIEdyKFUpIHtcbiAgICByZXR1cm4gdnModGhpcywgVSkuZ2V0KFUpO1xuICB9XG4gIGZ1bmN0aW9uIEpyKFUpIHtcbiAgICByZXR1cm4gdnModGhpcywgVSkuaGFzKFUpO1xuICB9XG4gIGZ1bmN0aW9uIFlyKFUsIFYpIHtcbiAgICB2YXIgWiA9IHZzKHRoaXMsIFUpLCBiZSA9IFouc2l6ZTtcbiAgICByZXR1cm4gWi5zZXQoVSwgViksIHRoaXMuc2l6ZSArPSBaLnNpemUgPT0gYmUgPyAwIDogMSwgdGhpcztcbiAgfVxuICBndC5wcm90b3R5cGUuY2xlYXIgPSBWciwgZ3QucHJvdG90eXBlLmRlbGV0ZSA9IFdyLCBndC5wcm90b3R5cGUuZ2V0ID0gR3IsIGd0LnByb3RvdHlwZS5oYXMgPSBKciwgZ3QucHJvdG90eXBlLnNldCA9IFlyO1xuICBmdW5jdGlvbiBvcihVKSB7XG4gICAgdmFyIFYgPSAtMSwgWiA9IFUgPT0gbnVsbCA/IDAgOiBVLmxlbmd0aDtcbiAgICBmb3IgKHRoaXMuX19kYXRhX18gPSBuZXcgZ3QoKTsgKytWIDwgWjsgKVxuICAgICAgdGhpcy5hZGQoVVtWXSk7XG4gIH1cbiAgZnVuY3Rpb24gWHIoVSkge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLnNldChVLCBpKSwgdGhpcztcbiAgfVxuICBmdW5jdGlvbiBacihVKSB7XG4gICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKFUpO1xuICB9XG4gIG9yLnByb3RvdHlwZS5hZGQgPSBvci5wcm90b3R5cGUucHVzaCA9IFhyLCBvci5wcm90b3R5cGUuaGFzID0gWnI7XG4gIGZ1bmN0aW9uICR0KFUpIHtcbiAgICB2YXIgViA9IHRoaXMuX19kYXRhX18gPSBuZXcgSmUoVSk7XG4gICAgdGhpcy5zaXplID0gVi5zaXplO1xuICB9XG4gIGZ1bmN0aW9uIFFyKCkge1xuICAgIHRoaXMuX19kYXRhX18gPSBuZXcgSmUoKSwgdGhpcy5zaXplID0gMDtcbiAgfVxuICBmdW5jdGlvbiBlaShVKSB7XG4gICAgdmFyIFYgPSB0aGlzLl9fZGF0YV9fLCBaID0gVi5kZWxldGUoVSk7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSA9IFYuc2l6ZSwgWjtcbiAgfVxuICBmdW5jdGlvbiB0aShVKSB7XG4gICAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KFUpO1xuICB9XG4gIGZ1bmN0aW9uIEFuKFUpIHtcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoVSk7XG4gIH1cbiAgZnVuY3Rpb24gRG4oVSwgVikge1xuICAgIHZhciBaID0gdGhpcy5fX2RhdGFfXztcbiAgICBpZiAoWiBpbnN0YW5jZW9mIEplKSB7XG4gICAgICB2YXIgYmUgPSBaLl9fZGF0YV9fO1xuICAgICAgaWYgKCFUZSB8fCBiZS5sZW5ndGggPCB0IC0gMSlcbiAgICAgICAgcmV0dXJuIGJlLnB1c2goW1UsIFZdKSwgdGhpcy5zaXplID0gKytaLnNpemUsIHRoaXM7XG4gICAgICBaID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBndChiZSk7XG4gICAgfVxuICAgIHJldHVybiBaLnNldChVLCBWKSwgdGhpcy5zaXplID0gWi5zaXplLCB0aGlzO1xuICB9XG4gICR0LnByb3RvdHlwZS5jbGVhciA9IFFyLCAkdC5wcm90b3R5cGUuZGVsZXRlID0gZWksICR0LnByb3RvdHlwZS5nZXQgPSB0aSwgJHQucHJvdG90eXBlLmhhcyA9IEFuLCAkdC5wcm90b3R5cGUuc2V0ID0gRG47XG4gIGZ1bmN0aW9uIGtkKFUsIFYpIHtcbiAgICB2YXIgWiA9IGJzKFUpLCBiZSA9ICFaICYmIGlsKFUpLCBjdCA9ICFaICYmICFiZSAmJiBSYShVKSwgV2UgPSAhWiAmJiAhYmUgJiYgIWN0ICYmIHlmKFUpLCBkdCA9IFogfHwgYmUgfHwgY3QgfHwgV2UsIHd0ID0gZHQgPyBoZShVLmxlbmd0aCwgU3RyaW5nKSA6IFtdLCBPdCA9IHd0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciB1dCBpbiBVKVxuICAgICAgKFYgfHwgcmUuY2FsbChVLCB1dCkpICYmICEoZHQgJiYgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgKHV0ID09IFwibGVuZ3RoXCIgfHwgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICBjdCAmJiAodXQgPT0gXCJvZmZzZXRcIiB8fCB1dCA9PSBcInBhcmVudFwiKSB8fCAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICBXZSAmJiAodXQgPT0gXCJidWZmZXJcIiB8fCB1dCA9PSBcImJ5dGVMZW5ndGhcIiB8fCB1dCA9PSBcImJ5dGVPZmZzZXRcIikgfHwgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgWmQodXQsIE90KSkpICYmIHd0LnB1c2godXQpO1xuICAgIHJldHVybiB3dDtcbiAgfVxuICBmdW5jdGlvbiBwcyhVLCBWKSB7XG4gICAgZm9yICh2YXIgWiA9IFUubGVuZ3RoOyBaLS07IClcbiAgICAgIGlmIChwZihVW1pdWzBdLCBWKSlcbiAgICAgICAgcmV0dXJuIFo7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGZ1bmN0aW9uIGpkKFUsIFYsIFopIHtcbiAgICB2YXIgYmUgPSBWKFUpO1xuICAgIHJldHVybiBicyhVKSA/IGJlIDogd2UoYmUsIFooVSkpO1xuICB9XG4gIGZ1bmN0aW9uIFBuKFUpIHtcbiAgICByZXR1cm4gVSA9PSBudWxsID8gVSA9PT0gdm9pZCAwID8gSiA6IGogOiBBZSAmJiBBZSBpbiBPYmplY3QoVSkgPyBZZChVKSA6IHJsKFUpO1xuICB9XG4gIGZ1bmN0aW9uIGhmKFUpIHtcbiAgICByZXR1cm4gT24oVSkgJiYgUG4oVSkgPT0gZjtcbiAgfVxuICBmdW5jdGlvbiB1ZihVLCBWLCBaLCBiZSwgY3QpIHtcbiAgICByZXR1cm4gVSA9PT0gViA/ICEwIDogVSA9PSBudWxsIHx8IFYgPT0gbnVsbCB8fCAhT24oVSkgJiYgIU9uKFYpID8gVSAhPT0gVSAmJiBWICE9PSBWIDogS2QoVSwgViwgWiwgYmUsIHVmLCBjdCk7XG4gIH1cbiAgZnVuY3Rpb24gS2QoVSwgViwgWiwgYmUsIGN0LCBXZSkge1xuICAgIHZhciBkdCA9IGJzKFUpLCB3dCA9IGJzKFYpLCBPdCA9IGR0ID8gaCA6IHBpKFUpLCB1dCA9IHd0ID8gaCA6IHBpKFYpO1xuICAgIE90ID0gT3QgPT0gZiA/IFQgOiBPdCwgdXQgPSB1dCA9PSBmID8gVCA6IHV0O1xuICAgIHZhciBRdCA9IE90ID09IFQsIG1yID0gdXQgPT0gVCwgTHQgPSBPdCA9PSB1dDtcbiAgICBpZiAoTHQgJiYgUmEoVSkpIHtcbiAgICAgIGlmICghUmEoVikpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGR0ID0gITAsIFF0ID0gITE7XG4gICAgfVxuICAgIGlmIChMdCAmJiAhUXQpXG4gICAgICByZXR1cm4gV2UgfHwgKFdlID0gbmV3ICR0KCkpLCBkdCB8fCB5ZihVKSA/IGRmKFUsIFYsIFosIGJlLCBjdCwgV2UpIDogR2QoVSwgViwgT3QsIFosIGJlLCBjdCwgV2UpO1xuICAgIGlmICghKFogJiBuKSkge1xuICAgICAgdmFyIGZyID0gUXQgJiYgcmUuY2FsbChVLCBcIl9fd3JhcHBlZF9fXCIpLCBjciA9IG1yICYmIHJlLmNhbGwoViwgXCJfX3dyYXBwZWRfX1wiKTtcbiAgICAgIGlmIChmciB8fCBjcikge1xuICAgICAgICB2YXIgdmkgPSBmciA/IFUudmFsdWUoKSA6IFUsIHJpID0gY3IgPyBWLnZhbHVlKCkgOiBWO1xuICAgICAgICByZXR1cm4gV2UgfHwgKFdlID0gbmV3ICR0KCkpLCBjdCh2aSwgcmksIFosIGJlLCBXZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBMdCA/IChXZSB8fCAoV2UgPSBuZXcgJHQoKSksIEpkKFUsIFYsIFosIGJlLCBjdCwgV2UpKSA6ICExO1xuICB9XG4gIGZ1bmN0aW9uIEhkKFUpIHtcbiAgICBpZiAoIWdmKFUpIHx8IGVsKFUpKVxuICAgICAgcmV0dXJuICExO1xuICAgIHZhciBWID0gdmYoVSkgPyBvZSA6IFA7XG4gICAgcmV0dXJuIFYudGVzdChEaShVKSk7XG4gIH1cbiAgZnVuY3Rpb24gVmQoVSkge1xuICAgIHJldHVybiBPbihVKSAmJiBiZihVLmxlbmd0aCkgJiYgISFNW1BuKFUpXTtcbiAgfVxuICBmdW5jdGlvbiBXZChVKSB7XG4gICAgaWYgKCF0bChVKSlcbiAgICAgIHJldHVybiBOZShVKTtcbiAgICB2YXIgViA9IFtdO1xuICAgIGZvciAodmFyIFogaW4gT2JqZWN0KFUpKVxuICAgICAgcmUuY2FsbChVLCBaKSAmJiBaICE9IFwiY29uc3RydWN0b3JcIiAmJiBWLnB1c2goWik7XG4gICAgcmV0dXJuIFY7XG4gIH1cbiAgZnVuY3Rpb24gZGYoVSwgViwgWiwgYmUsIGN0LCBXZSkge1xuICAgIHZhciBkdCA9IFogJiBuLCB3dCA9IFUubGVuZ3RoLCBPdCA9IFYubGVuZ3RoO1xuICAgIGlmICh3dCAhPSBPdCAmJiAhKGR0ICYmIE90ID4gd3QpKVxuICAgICAgcmV0dXJuICExO1xuICAgIHZhciB1dCA9IFdlLmdldChVKTtcbiAgICBpZiAodXQgJiYgV2UuZ2V0KFYpKVxuICAgICAgcmV0dXJuIHV0ID09IFY7XG4gICAgdmFyIFF0ID0gLTEsIG1yID0gITAsIEx0ID0gWiAmIHMgPyBuZXcgb3IoKSA6IHZvaWQgMDtcbiAgICBmb3IgKFdlLnNldChVLCBWKSwgV2Uuc2V0KFYsIFUpOyArK1F0IDwgd3Q7ICkge1xuICAgICAgdmFyIGZyID0gVVtRdF0sIGNyID0gVltRdF07XG4gICAgICBpZiAoYmUpXG4gICAgICAgIHZhciB2aSA9IGR0ID8gYmUoY3IsIGZyLCBRdCwgViwgVSwgV2UpIDogYmUoZnIsIGNyLCBRdCwgVSwgViwgV2UpO1xuICAgICAgaWYgKHZpICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHZpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBtciA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChMdCkge1xuICAgICAgICBpZiAoIU1lKFYsIGZ1bmN0aW9uKHJpLCBQaSkge1xuICAgICAgICAgIGlmICgheGUoTHQsIFBpKSAmJiAoZnIgPT09IHJpIHx8IGN0KGZyLCByaSwgWiwgYmUsIFdlKSkpXG4gICAgICAgICAgICByZXR1cm4gTHQucHVzaChQaSk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgbXIgPSAhMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghKGZyID09PSBjciB8fCBjdChmciwgY3IsIFosIGJlLCBXZSkpKSB7XG4gICAgICAgIG1yID0gITE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gV2UuZGVsZXRlKFUpLCBXZS5kZWxldGUoViksIG1yO1xuICB9XG4gIGZ1bmN0aW9uIEdkKFUsIFYsIFosIGJlLCBjdCwgV2UsIGR0KSB7XG4gICAgc3dpdGNoIChaKSB7XG4gICAgICBjYXNlIHA6XG4gICAgICAgIGlmIChVLmJ5dGVMZW5ndGggIT0gVi5ieXRlTGVuZ3RoIHx8IFUuYnl0ZU9mZnNldCAhPSBWLmJ5dGVPZmZzZXQpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBVID0gVS5idWZmZXIsIFYgPSBWLmJ1ZmZlcjtcbiAgICAgIGNhc2UgTzpcbiAgICAgICAgcmV0dXJuICEoVS5ieXRlTGVuZ3RoICE9IFYuYnl0ZUxlbmd0aCB8fCAhV2UobmV3IFBlKFUpLCBuZXcgUGUoVikpKTtcbiAgICAgIGNhc2UgdjpcbiAgICAgIGNhc2UgdzpcbiAgICAgIGNhc2UgazpcbiAgICAgICAgcmV0dXJuIHBmKCtVLCArVik7XG4gICAgICBjYXNlIEE6XG4gICAgICAgIHJldHVybiBVLm5hbWUgPT0gVi5uYW1lICYmIFUubWVzc2FnZSA9PSBWLm1lc3NhZ2U7XG4gICAgICBjYXNlIHo6XG4gICAgICBjYXNlIF86XG4gICAgICAgIHJldHVybiBVID09IFYgKyBcIlwiO1xuICAgICAgY2FzZSBOOlxuICAgICAgICB2YXIgd3QgPSBnZTtcbiAgICAgIGNhc2UgQjpcbiAgICAgICAgdmFyIE90ID0gYmUgJiBuO1xuICAgICAgICBpZiAod3QgfHwgKHd0ID0gbmUpLCBVLnNpemUgIT0gVi5zaXplICYmICFPdClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIHZhciB1dCA9IGR0LmdldChVKTtcbiAgICAgICAgaWYgKHV0KVxuICAgICAgICAgIHJldHVybiB1dCA9PSBWO1xuICAgICAgICBiZSB8PSBzLCBkdC5zZXQoVSwgVik7XG4gICAgICAgIHZhciBRdCA9IGRmKHd0KFUpLCB3dChWKSwgYmUsIGN0LCBXZSwgZHQpO1xuICAgICAgICByZXR1cm4gZHQuZGVsZXRlKFUpLCBRdDtcbiAgICAgIGNhc2UgUjpcbiAgICAgICAgaWYgKEZlKVxuICAgICAgICAgIHJldHVybiBGZS5jYWxsKFUpID09IEZlLmNhbGwoVik7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBmdW5jdGlvbiBKZChVLCBWLCBaLCBiZSwgY3QsIFdlKSB7XG4gICAgdmFyIGR0ID0gWiAmIG4sIHd0ID0gbGYoVSksIE90ID0gd3QubGVuZ3RoLCB1dCA9IGxmKFYpLCBRdCA9IHV0Lmxlbmd0aDtcbiAgICBpZiAoT3QgIT0gUXQgJiYgIWR0KVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAodmFyIG1yID0gT3Q7IG1yLS07ICkge1xuICAgICAgdmFyIEx0ID0gd3RbbXJdO1xuICAgICAgaWYgKCEoZHQgPyBMdCBpbiBWIDogcmUuY2FsbChWLCBMdCkpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIHZhciBmciA9IFdlLmdldChVKTtcbiAgICBpZiAoZnIgJiYgV2UuZ2V0KFYpKVxuICAgICAgcmV0dXJuIGZyID09IFY7XG4gICAgdmFyIGNyID0gITA7XG4gICAgV2Uuc2V0KFUsIFYpLCBXZS5zZXQoViwgVSk7XG4gICAgZm9yICh2YXIgdmkgPSBkdDsgKyttciA8IE90OyApIHtcbiAgICAgIEx0ID0gd3RbbXJdO1xuICAgICAgdmFyIHJpID0gVVtMdF0sIFBpID0gVltMdF07XG4gICAgICBpZiAoYmUpXG4gICAgICAgIHZhciBtZiA9IGR0ID8gYmUoUGksIHJpLCBMdCwgViwgVSwgV2UpIDogYmUocmksIFBpLCBMdCwgVSwgViwgV2UpO1xuICAgICAgaWYgKCEobWYgPT09IHZvaWQgMCA/IHJpID09PSBQaSB8fCBjdChyaSwgUGksIFosIGJlLCBXZSkgOiBtZikpIHtcbiAgICAgICAgY3IgPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2aSB8fCAodmkgPSBMdCA9PSBcImNvbnN0cnVjdG9yXCIpO1xuICAgIH1cbiAgICBpZiAoY3IgJiYgIXZpKSB7XG4gICAgICB2YXIgZ3MgPSBVLmNvbnN0cnVjdG9yLCB5cyA9IFYuY29uc3RydWN0b3I7XG4gICAgICBncyAhPSB5cyAmJiBcImNvbnN0cnVjdG9yXCIgaW4gVSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gViAmJiAhKHR5cGVvZiBncyA9PSBcImZ1bmN0aW9uXCIgJiYgZ3MgaW5zdGFuY2VvZiBncyAmJiB0eXBlb2YgeXMgPT0gXCJmdW5jdGlvblwiICYmIHlzIGluc3RhbmNlb2YgeXMpICYmIChjciA9ICExKTtcbiAgICB9XG4gICAgcmV0dXJuIFdlLmRlbGV0ZShVKSwgV2UuZGVsZXRlKFYpLCBjcjtcbiAgfVxuICBmdW5jdGlvbiBsZihVKSB7XG4gICAgcmV0dXJuIGpkKFUsIGFsLCBYZCk7XG4gIH1cbiAgZnVuY3Rpb24gdnMoVSwgVikge1xuICAgIHZhciBaID0gVS5fX2RhdGFfXztcbiAgICByZXR1cm4gUWQoVikgPyBaW3R5cGVvZiBWID09IFwic3RyaW5nXCIgPyBcInN0cmluZ1wiIDogXCJoYXNoXCJdIDogWi5tYXA7XG4gIH1cbiAgZnVuY3Rpb24gZW4oVSwgVikge1xuICAgIHZhciBaID0gc2UoVSwgVik7XG4gICAgcmV0dXJuIEhkKFopID8gWiA6IHZvaWQgMDtcbiAgfVxuICBmdW5jdGlvbiBZZChVKSB7XG4gICAgdmFyIFYgPSByZS5jYWxsKFUsIEFlKSwgWiA9IFVbQWVdO1xuICAgIHRyeSB7XG4gICAgICBVW0FlXSA9IHZvaWQgMDtcbiAgICAgIHZhciBiZSA9ICEwO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICB2YXIgY3QgPSBTZS5jYWxsKFUpO1xuICAgIHJldHVybiBiZSAmJiAoViA/IFVbQWVdID0gWiA6IGRlbGV0ZSBVW0FlXSksIGN0O1xuICB9XG4gIHZhciBYZCA9IFplID8gZnVuY3Rpb24oVSkge1xuICAgIHJldHVybiBVID09IG51bGwgPyBbXSA6IChVID0gT2JqZWN0KFUpLCBlZShaZShVKSwgZnVuY3Rpb24oVikge1xuICAgICAgcmV0dXJuIEdlLmNhbGwoVSwgVik7XG4gICAgfSkpO1xuICB9IDogb2wsIHBpID0gUG47XG4gIChDZSAmJiBwaShuZXcgQ2UobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gcCB8fCBUZSAmJiBwaShuZXcgVGUoKSkgIT0gTiB8fCBkZSAmJiBwaShkZS5yZXNvbHZlKCkpICE9IEsgfHwgJGUgJiYgcGkobmV3ICRlKCkpICE9IEIgfHwgTGUgJiYgcGkobmV3IExlKCkpICE9IFEpICYmIChwaSA9IGZ1bmN0aW9uKFUpIHtcbiAgICB2YXIgViA9IFBuKFUpLCBaID0gViA9PSBUID8gVS5jb25zdHJ1Y3RvciA6IHZvaWQgMCwgYmUgPSBaID8gRGkoWikgOiBcIlwiO1xuICAgIGlmIChiZSlcbiAgICAgIHN3aXRjaCAoYmUpIHtcbiAgICAgICAgY2FzZSBVZTpcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgY2FzZSB6ZTpcbiAgICAgICAgICByZXR1cm4gTjtcbiAgICAgICAgY2FzZSB5ZTpcbiAgICAgICAgICByZXR1cm4gSztcbiAgICAgICAgY2FzZSBCZTpcbiAgICAgICAgICByZXR1cm4gQjtcbiAgICAgICAgY2FzZSBrZTpcbiAgICAgICAgICByZXR1cm4gUTtcbiAgICAgIH1cbiAgICByZXR1cm4gVjtcbiAgfSk7XG4gIGZ1bmN0aW9uIFpkKFUsIFYpIHtcbiAgICByZXR1cm4gViA9IFYgPz8gbywgISFWICYmICh0eXBlb2YgVSA9PSBcIm51bWJlclwiIHx8IEcudGVzdChVKSkgJiYgVSA+IC0xICYmIFUgJSAxID09IDAgJiYgVSA8IFY7XG4gIH1cbiAgZnVuY3Rpb24gUWQoVSkge1xuICAgIHZhciBWID0gdHlwZW9mIFU7XG4gICAgcmV0dXJuIFYgPT0gXCJzdHJpbmdcIiB8fCBWID09IFwibnVtYmVyXCIgfHwgViA9PSBcInN5bWJvbFwiIHx8IFYgPT0gXCJib29sZWFuXCIgPyBVICE9PSBcIl9fcHJvdG9fX1wiIDogVSA9PT0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBlbChVKSB7XG4gICAgcmV0dXJuICEhRWUgJiYgRWUgaW4gVTtcbiAgfVxuICBmdW5jdGlvbiB0bChVKSB7XG4gICAgdmFyIFYgPSBVICYmIFUuY29uc3RydWN0b3IsIFogPSB0eXBlb2YgViA9PSBcImZ1bmN0aW9uXCIgJiYgVi5wcm90b3R5cGUgfHwgdGU7XG4gICAgcmV0dXJuIFUgPT09IFo7XG4gIH1cbiAgZnVuY3Rpb24gcmwoVSkge1xuICAgIHJldHVybiBTZS5jYWxsKFUpO1xuICB9XG4gIGZ1bmN0aW9uIERpKFUpIHtcbiAgICBpZiAoVSAhPSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gX2UuY2FsbChVKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFUgKyBcIlwiO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIHBmKFUsIFYpIHtcbiAgICByZXR1cm4gVSA9PT0gViB8fCBVICE9PSBVICYmIFYgIT09IFY7XG4gIH1cbiAgdmFyIGlsID0gaGYoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgfSgpKSA/IGhmIDogZnVuY3Rpb24oVSkge1xuICAgIHJldHVybiBPbihVKSAmJiByZS5jYWxsKFUsIFwiY2FsbGVlXCIpICYmICFHZS5jYWxsKFUsIFwiY2FsbGVlXCIpO1xuICB9LCBicyA9IEFycmF5LmlzQXJyYXk7XG4gIGZ1bmN0aW9uIG5sKFUpIHtcbiAgICByZXR1cm4gVSAhPSBudWxsICYmIGJmKFUubGVuZ3RoKSAmJiAhdmYoVSk7XG4gIH1cbiAgdmFyIFJhID0gZXQgfHwgZmw7XG4gIGZ1bmN0aW9uIHNsKFUsIFYpIHtcbiAgICByZXR1cm4gdWYoVSwgVik7XG4gIH1cbiAgZnVuY3Rpb24gdmYoVSkge1xuICAgIGlmICghZ2YoVSkpXG4gICAgICByZXR1cm4gITE7XG4gICAgdmFyIFYgPSBQbihVKTtcbiAgICByZXR1cm4gViA9PSBJIHx8IFYgPT0gRCB8fCBWID09IGQgfHwgViA9PSAkO1xuICB9XG4gIGZ1bmN0aW9uIGJmKFUpIHtcbiAgICByZXR1cm4gdHlwZW9mIFUgPT0gXCJudW1iZXJcIiAmJiBVID4gLTEgJiYgVSAlIDEgPT0gMCAmJiBVIDw9IG87XG4gIH1cbiAgZnVuY3Rpb24gZ2YoVSkge1xuICAgIHZhciBWID0gdHlwZW9mIFU7XG4gICAgcmV0dXJuIFUgIT0gbnVsbCAmJiAoViA9PSBcIm9iamVjdFwiIHx8IFYgPT0gXCJmdW5jdGlvblwiKTtcbiAgfVxuICBmdW5jdGlvbiBPbihVKSB7XG4gICAgcmV0dXJuIFUgIT0gbnVsbCAmJiB0eXBlb2YgVSA9PSBcIm9iamVjdFwiO1xuICB9XG4gIHZhciB5ZiA9IFggPyBSZShYKSA6IFZkO1xuICBmdW5jdGlvbiBhbChVKSB7XG4gICAgcmV0dXJuIG5sKFUpID8ga2QoVSkgOiBXZChVKTtcbiAgfVxuICBmdW5jdGlvbiBvbCgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZnVuY3Rpb24gZmwoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHIuZXhwb3J0cyA9IHNsO1xufSkoUXMsIFFzLmV4cG9ydHMpO1xudmFyIG8zID0gUXMuZXhwb3J0cztcbmNvbnN0IGYzID0gLyogQF9fUFVSRV9fICovIGJuKG8zKSwgRWQgPSBcIndjXCIsIFNkID0gMiwgZWEgPSBcImNvcmVcIiwganIgPSBgJHtFZH1AMjoke2VhfTpgLCBjMyA9IHsgbmFtZTogZWEsIGxvZ2dlcjogXCJlcnJvclwiIH0sIGgzID0geyBkYXRhYmFzZTogXCI6bWVtb3J5OlwiIH0sIHUzID0gXCJjcnlwdG9cIiwgZWggPSBcImNsaWVudF9lZDI1NTE5X3NlZWRcIiwgZDMgPSBpZS5PTkVfREFZLCBsMyA9IFwia2V5Y2hhaW5cIiwgcDMgPSBcIjAuM1wiLCB2MyA9IFwibWVzc2FnZXNcIiwgYjMgPSBcIjAuM1wiLCB0aCA9IGllLlNJWF9IT1VSUywgZzMgPSBcInB1Ymxpc2hlclwiLCBNZCA9IFwiaXJuXCIsIHkzID0gXCJlcnJvclwiLCBJZCA9IFwid3NzOi8vcmVsYXkud2FsbGV0Y29ubmVjdC5vcmdcIiwgbTMgPSBcInJlbGF5ZXJcIiwgRXQgPSB7IG1lc3NhZ2U6IFwicmVsYXllcl9tZXNzYWdlXCIsIG1lc3NhZ2VfYWNrOiBcInJlbGF5ZXJfbWVzc2FnZV9hY2tcIiwgY29ubmVjdDogXCJyZWxheWVyX2Nvbm5lY3RcIiwgZGlzY29ubmVjdDogXCJyZWxheWVyX2Rpc2Nvbm5lY3RcIiwgZXJyb3I6IFwicmVsYXllcl9lcnJvclwiLCBjb25uZWN0aW9uX3N0YWxsZWQ6IFwicmVsYXllcl9jb25uZWN0aW9uX3N0YWxsZWRcIiwgdHJhbnNwb3J0X2Nsb3NlZDogXCJyZWxheWVyX3RyYW5zcG9ydF9jbG9zZWRcIiwgcHVibGlzaDogXCJyZWxheWVyX3B1Ymxpc2hcIiB9LCB3MyA9IFwiX3N1YnNjcmlwdGlvblwiLCBociA9IHsgcGF5bG9hZDogXCJwYXlsb2FkXCIsIGNvbm5lY3Q6IFwiY29ubmVjdFwiLCBkaXNjb25uZWN0OiBcImRpc2Nvbm5lY3RcIiwgZXJyb3I6IFwiZXJyb3JcIiB9LCBfMyA9IDAuMSwgRG8gPSBcIjIuMTcuM1wiLCBhdCA9IHsgbGlua19tb2RlOiBcImxpbmtfbW9kZVwiLCByZWxheTogXCJyZWxheVwiIH0sIHgzID0gXCIwLjNcIiwgRTMgPSBcIldBTExFVENPTk5FQ1RfQ0xJRU5UX0lEXCIsIHJoID0gXCJXQUxMRVRDT05ORUNUX0xJTktfTU9ERV9BUFBTXCIsIGVyID0geyBjcmVhdGVkOiBcInN1YnNjcmlwdGlvbl9jcmVhdGVkXCIsIGRlbGV0ZWQ6IFwic3Vic2NyaXB0aW9uX2RlbGV0ZWRcIiwgZXhwaXJlZDogXCJzdWJzY3JpcHRpb25fZXhwaXJlZFwiLCBkaXNhYmxlZDogXCJzdWJzY3JpcHRpb25fZGlzYWJsZWRcIiwgc3luYzogXCJzdWJzY3JpcHRpb25fc3luY1wiLCByZXN1YnNjcmliZWQ6IFwic3Vic2NyaXB0aW9uX3Jlc3Vic2NyaWJlZFwiIH0sIFMzID0gXCJzdWJzY3JpcHRpb25cIiwgTTMgPSBcIjAuM1wiLCBJMyA9IGllLkZJVkVfU0VDT05EUyAqIDFlMywgQTMgPSBcInBhaXJpbmdcIiwgRDMgPSBcIjAuM1wiLCBxbiA9IHsgd2NfcGFpcmluZ0RlbGV0ZTogeyByZXE6IHsgdHRsOiBpZS5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDFlMyB9LCByZXM6IHsgdHRsOiBpZS5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDEwMDEgfSB9LCB3Y19wYWlyaW5nUGluZzogeyByZXE6IHsgdHRsOiBpZS5USElSVFlfU0VDT05EUywgcHJvbXB0OiAhMSwgdGFnOiAxMDAyIH0sIHJlczogeyB0dGw6IGllLlRISVJUWV9TRUNPTkRTLCBwcm9tcHQ6ICExLCB0YWc6IDEwMDMgfSB9LCB1bnJlZ2lzdGVyZWRfbWV0aG9kOiB7IHJlcTogeyB0dGw6IGllLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMCB9LCByZXM6IHsgdHRsOiBpZS5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDAgfSB9IH0sIHFpID0geyBjcmVhdGU6IFwicGFpcmluZ19jcmVhdGVcIiwgZXhwaXJlOiBcInBhaXJpbmdfZXhwaXJlXCIsIGRlbGV0ZTogXCJwYWlyaW5nX2RlbGV0ZVwiLCBwaW5nOiBcInBhaXJpbmdfcGluZ1wiIH0sIF9yID0geyBjcmVhdGVkOiBcImhpc3RvcnlfY3JlYXRlZFwiLCB1cGRhdGVkOiBcImhpc3RvcnlfdXBkYXRlZFwiLCBkZWxldGVkOiBcImhpc3RvcnlfZGVsZXRlZFwiLCBzeW5jOiBcImhpc3Rvcnlfc3luY1wiIH0sIFAzID0gXCJoaXN0b3J5XCIsIE8zID0gXCIwLjNcIiwgUjMgPSBcImV4cGlyZXJcIiwgdXIgPSB7IGNyZWF0ZWQ6IFwiZXhwaXJlcl9jcmVhdGVkXCIsIGRlbGV0ZWQ6IFwiZXhwaXJlcl9kZWxldGVkXCIsIGV4cGlyZWQ6IFwiZXhwaXJlcl9leHBpcmVkXCIsIHN5bmM6IFwiZXhwaXJlcl9zeW5jXCIgfSwgTjMgPSBcIjAuM1wiLCBUMyA9IFwidmVyaWZ5LWFwaVwiLCBDMyA9IFwiaHR0cHM6Ly92ZXJpZnkud2FsbGV0Y29ubmVjdC5jb21cIiwgQWQgPSBcImh0dHBzOi8vdmVyaWZ5LndhbGxldGNvbm5lY3Qub3JnXCIsIFZuID0gQWQsICQzID0gYCR7Vm59L3YzYCwgTDMgPSBbQzMsIEFkXSwgRjMgPSBcImVjaG9cIiwgcTMgPSBcImh0dHBzOi8vZWNoby53YWxsZXRjb25uZWN0LmNvbVwiLCBPciA9IHsgcGFpcmluZ19zdGFydGVkOiBcInBhaXJpbmdfc3RhcnRlZFwiLCBwYWlyaW5nX3VyaV92YWxpZGF0aW9uX3N1Y2Nlc3M6IFwicGFpcmluZ191cmlfdmFsaWRhdGlvbl9zdWNjZXNzXCIsIHBhaXJpbmdfdXJpX25vdF9leHBpcmVkOiBcInBhaXJpbmdfdXJpX25vdF9leHBpcmVkXCIsIHN0b3JlX25ld19wYWlyaW5nOiBcInN0b3JlX25ld19wYWlyaW5nXCIsIHN1YnNjcmliaW5nX3BhaXJpbmdfdG9waWM6IFwic3Vic2NyaWJpbmdfcGFpcmluZ190b3BpY1wiLCBzdWJzY3JpYmVfcGFpcmluZ190b3BpY19zdWNjZXNzOiBcInN1YnNjcmliZV9wYWlyaW5nX3RvcGljX3N1Y2Nlc3NcIiwgZXhpc3RpbmdfcGFpcmluZzogXCJleGlzdGluZ19wYWlyaW5nXCIsIHBhaXJpbmdfbm90X2V4cGlyZWQ6IFwicGFpcmluZ19ub3RfZXhwaXJlZFwiLCBlbWl0X2luYWN0aXZlX3BhaXJpbmc6IFwiZW1pdF9pbmFjdGl2ZV9wYWlyaW5nXCIsIGVtaXRfc2Vzc2lvbl9wcm9wb3NhbDogXCJlbWl0X3Nlc3Npb25fcHJvcG9zYWxcIiwgc3Vic2NyaWJpbmdfdG9fcGFpcmluZ190b3BpYzogXCJzdWJzY3JpYmluZ190b19wYWlyaW5nX3RvcGljXCIgfSwgYWkgPSB7IG5vX3dzc19jb25uZWN0aW9uOiBcIm5vX3dzc19jb25uZWN0aW9uXCIsIG5vX2ludGVybmV0X2Nvbm5lY3Rpb246IFwibm9faW50ZXJuZXRfY29ubmVjdGlvblwiLCBtYWxmb3JtZWRfcGFpcmluZ191cmk6IFwibWFsZm9ybWVkX3BhaXJpbmdfdXJpXCIsIGFjdGl2ZV9wYWlyaW5nX2FscmVhZHlfZXhpc3RzOiBcImFjdGl2ZV9wYWlyaW5nX2FscmVhZHlfZXhpc3RzXCIsIHN1YnNjcmliZV9wYWlyaW5nX3RvcGljX2ZhaWx1cmU6IFwic3Vic2NyaWJlX3BhaXJpbmdfdG9waWNfZmFpbHVyZVwiLCBwYWlyaW5nX2V4cGlyZWQ6IFwicGFpcmluZ19leHBpcmVkXCIsIHByb3Bvc2FsX2V4cGlyZWQ6IFwicHJvcG9zYWxfZXhwaXJlZFwiLCBwcm9wb3NhbF9saXN0ZW5lcl9ub3RfZm91bmQ6IFwicHJvcG9zYWxfbGlzdGVuZXJfbm90X2ZvdW5kXCIgfSwgeHIgPSB7IHNlc3Npb25fYXBwcm92ZV9zdGFydGVkOiBcInNlc3Npb25fYXBwcm92ZV9zdGFydGVkXCIsIHByb3Bvc2FsX25vdF9leHBpcmVkOiBcInByb3Bvc2FsX25vdF9leHBpcmVkXCIsIHNlc3Npb25fbmFtZXNwYWNlc192YWxpZGF0aW9uX3N1Y2Nlc3M6IFwic2Vzc2lvbl9uYW1lc3BhY2VzX3ZhbGlkYXRpb25fc3VjY2Vzc1wiLCBjcmVhdGVfc2Vzc2lvbl90b3BpYzogXCJjcmVhdGVfc2Vzc2lvbl90b3BpY1wiLCBzdWJzY3JpYmluZ19zZXNzaW9uX3RvcGljOiBcInN1YnNjcmliaW5nX3Nlc3Npb25fdG9waWNcIiwgc3Vic2NyaWJlX3Nlc3Npb25fdG9waWNfc3VjY2VzczogXCJzdWJzY3JpYmVfc2Vzc2lvbl90b3BpY19zdWNjZXNzXCIsIHB1Ymxpc2hpbmdfc2Vzc2lvbl9hcHByb3ZlOiBcInB1Ymxpc2hpbmdfc2Vzc2lvbl9hcHByb3ZlXCIsIHNlc3Npb25fYXBwcm92ZV9wdWJsaXNoX3N1Y2Nlc3M6IFwic2Vzc2lvbl9hcHByb3ZlX3B1Ymxpc2hfc3VjY2Vzc1wiLCBzdG9yZV9zZXNzaW9uOiBcInN0b3JlX3Nlc3Npb25cIiwgcHVibGlzaGluZ19zZXNzaW9uX3NldHRsZTogXCJwdWJsaXNoaW5nX3Nlc3Npb25fc2V0dGxlXCIsIHNlc3Npb25fc2V0dGxlX3B1Ymxpc2hfc3VjY2VzczogXCJzZXNzaW9uX3NldHRsZV9wdWJsaXNoX3N1Y2Nlc3NcIiB9LCBUaSA9IHsgbm9faW50ZXJuZXRfY29ubmVjdGlvbjogXCJub19pbnRlcm5ldF9jb25uZWN0aW9uXCIsIG5vX3dzc19jb25uZWN0aW9uOiBcIm5vX3dzc19jb25uZWN0aW9uXCIsIHByb3Bvc2FsX2V4cGlyZWQ6IFwicHJvcG9zYWxfZXhwaXJlZFwiLCBzdWJzY3JpYmVfc2Vzc2lvbl90b3BpY19mYWlsdXJlOiBcInN1YnNjcmliZV9zZXNzaW9uX3RvcGljX2ZhaWx1cmVcIiwgc2Vzc2lvbl9hcHByb3ZlX3B1Ymxpc2hfZmFpbHVyZTogXCJzZXNzaW9uX2FwcHJvdmVfcHVibGlzaF9mYWlsdXJlXCIsIHNlc3Npb25fc2V0dGxlX3B1Ymxpc2hfZmFpbHVyZTogXCJzZXNzaW9uX3NldHRsZV9wdWJsaXNoX2ZhaWx1cmVcIiwgc2Vzc2lvbl9hcHByb3ZlX25hbWVzcGFjZV92YWxpZGF0aW9uX2ZhaWx1cmU6IFwic2Vzc2lvbl9hcHByb3ZlX25hbWVzcGFjZV92YWxpZGF0aW9uX2ZhaWx1cmVcIiwgcHJvcG9zYWxfbm90X2ZvdW5kOiBcInByb3Bvc2FsX25vdF9mb3VuZFwiIH0sIENpID0geyBhdXRoZW50aWNhdGVkX3Nlc3Npb25fYXBwcm92ZV9zdGFydGVkOiBcImF1dGhlbnRpY2F0ZWRfc2Vzc2lvbl9hcHByb3ZlX3N0YXJ0ZWRcIiwgYXV0aGVudGljYXRlZF9zZXNzaW9uX25vdF9leHBpcmVkOiBcImF1dGhlbnRpY2F0ZWRfc2Vzc2lvbl9ub3RfZXhwaXJlZFwiLCBjaGFpbnNfY2FpcDJfY29tcGxpYW50OiBcImNoYWluc19jYWlwMl9jb21wbGlhbnRcIiwgY2hhaW5zX2V2bV9jb21wbGlhbnQ6IFwiY2hhaW5zX2V2bV9jb21wbGlhbnRcIiwgY3JlYXRlX2F1dGhlbnRpY2F0ZWRfc2Vzc2lvbl90b3BpYzogXCJjcmVhdGVfYXV0aGVudGljYXRlZF9zZXNzaW9uX3RvcGljXCIsIGNhY2Fvc192ZXJpZmllZDogXCJjYWNhb3NfdmVyaWZpZWRcIiwgc3RvcmVfYXV0aGVudGljYXRlZF9zZXNzaW9uOiBcInN0b3JlX2F1dGhlbnRpY2F0ZWRfc2Vzc2lvblwiLCBzdWJzY3JpYmluZ19hdXRoZW50aWNhdGVkX3Nlc3Npb25fdG9waWM6IFwic3Vic2NyaWJpbmdfYXV0aGVudGljYXRlZF9zZXNzaW9uX3RvcGljXCIsIHN1YnNjcmliZV9hdXRoZW50aWNhdGVkX3Nlc3Npb25fdG9waWNfc3VjY2VzczogXCJzdWJzY3JpYmVfYXV0aGVudGljYXRlZF9zZXNzaW9uX3RvcGljX3N1Y2Nlc3NcIiwgcHVibGlzaGluZ19hdXRoZW50aWNhdGVkX3Nlc3Npb25fYXBwcm92ZTogXCJwdWJsaXNoaW5nX2F1dGhlbnRpY2F0ZWRfc2Vzc2lvbl9hcHByb3ZlXCIsIGF1dGhlbnRpY2F0ZWRfc2Vzc2lvbl9hcHByb3ZlX3B1Ymxpc2hfc3VjY2VzczogXCJhdXRoZW50aWNhdGVkX3Nlc3Npb25fYXBwcm92ZV9wdWJsaXNoX3N1Y2Nlc3NcIiB9LCBVbiA9IHsgbm9faW50ZXJuZXRfY29ubmVjdGlvbjogXCJub19pbnRlcm5ldF9jb25uZWN0aW9uXCIsIG5vX3dzc19jb25uZWN0aW9uOiBcIm5vX3dzc19jb25uZWN0aW9uXCIsIG1pc3Npbmdfc2Vzc2lvbl9hdXRoZW50aWNhdGVfcmVxdWVzdDogXCJtaXNzaW5nX3Nlc3Npb25fYXV0aGVudGljYXRlX3JlcXVlc3RcIiwgc2Vzc2lvbl9hdXRoZW50aWNhdGVfcmVxdWVzdF9leHBpcmVkOiBcInNlc3Npb25fYXV0aGVudGljYXRlX3JlcXVlc3RfZXhwaXJlZFwiLCBjaGFpbnNfY2FpcDJfY29tcGxpYW50X2ZhaWx1cmU6IFwiY2hhaW5zX2NhaXAyX2NvbXBsaWFudF9mYWlsdXJlXCIsIGNoYWluc19ldm1fY29tcGxpYW50X2ZhaWx1cmU6IFwiY2hhaW5zX2V2bV9jb21wbGlhbnRfZmFpbHVyZVwiLCBpbnZhbGlkX2NhY2FvOiBcImludmFsaWRfY2FjYW9cIiwgc3Vic2NyaWJlX2F1dGhlbnRpY2F0ZWRfc2Vzc2lvbl90b3BpY19mYWlsdXJlOiBcInN1YnNjcmliZV9hdXRoZW50aWNhdGVkX3Nlc3Npb25fdG9waWNfZmFpbHVyZVwiLCBhdXRoZW50aWNhdGVkX3Nlc3Npb25fYXBwcm92ZV9wdWJsaXNoX2ZhaWx1cmU6IFwiYXV0aGVudGljYXRlZF9zZXNzaW9uX2FwcHJvdmVfcHVibGlzaF9mYWlsdXJlXCIsIGF1dGhlbnRpY2F0ZWRfc2Vzc2lvbl9wZW5kaW5nX3JlcXVlc3Rfbm90X2ZvdW5kOiBcImF1dGhlbnRpY2F0ZWRfc2Vzc2lvbl9wZW5kaW5nX3JlcXVlc3Rfbm90X2ZvdW5kXCIgfSwgVTMgPSAwLjEsIHozID0gXCJldmVudC1jbGllbnRcIiwgQjMgPSA4NjQwMCwgazMgPSBcImh0dHBzOi8vcHVsc2Uud2FsbGV0Y29ubmVjdC5vcmcvYmF0Y2hcIjtcbmZ1bmN0aW9uIGozKHIsIGUpIHtcbiAgaWYgKHIubGVuZ3RoID49IDI1NSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQWxwaGFiZXQgdG9vIGxvbmdcIik7XG4gIGZvciAodmFyIHQgPSBuZXcgVWludDhBcnJheSgyNTYpLCBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspXG4gICAgdFtpXSA9IDI1NTtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCByLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIHMgPSByLmNoYXJBdChuKSwgbyA9IHMuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAodFtvXSAhPT0gMjU1KVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzICsgXCIgaXMgYW1iaWd1b3VzXCIpO1xuICAgIHRbb10gPSBuO1xuICB9XG4gIHZhciBmID0gci5sZW5ndGgsIGggPSByLmNoYXJBdCgwKSwgZCA9IE1hdGgubG9nKGYpIC8gTWF0aC5sb2coMjU2KSwgdiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhmKTtcbiAgZnVuY3Rpb24gdyhEKSB7XG4gICAgaWYgKEQgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoRCkgPyBEID0gbmV3IFVpbnQ4QXJyYXkoRC5idWZmZXIsIEQuYnl0ZU9mZnNldCwgRC5ieXRlTGVuZ3RoKSA6IEFycmF5LmlzQXJyYXkoRCkgJiYgKEQgPSBVaW50OEFycmF5LmZyb20oRCkpKSwgIShEIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheVwiKTtcbiAgICBpZiAoRC5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBmb3IgKHZhciBOID0gMCwgayA9IDAsIGogPSAwLCBUID0gRC5sZW5ndGg7IGogIT09IFQgJiYgRFtqXSA9PT0gMDsgKVxuICAgICAgaisrLCBOKys7XG4gICAgZm9yICh2YXIgSyA9IChUIC0gaikgKiB2ICsgMSA+Pj4gMCwgJCA9IG5ldyBVaW50OEFycmF5KEspOyBqICE9PSBUOyApIHtcbiAgICAgIGZvciAodmFyIHogPSBEW2pdLCBCID0gMCwgXyA9IEsgLSAxOyAoeiAhPT0gMCB8fCBCIDwgaykgJiYgXyAhPT0gLTE7IF8tLSwgQisrKVxuICAgICAgICB6ICs9IDI1NiAqICRbX10gPj4+IDAsICRbX10gPSB6ICUgZiA+Pj4gMCwgeiA9IHogLyBmID4+PiAwO1xuICAgICAgaWYgKHogIT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi16ZXJvIGNhcnJ5XCIpO1xuICAgICAgayA9IEIsIGorKztcbiAgICB9XG4gICAgZm9yICh2YXIgUiA9IEsgLSBrOyBSICE9PSBLICYmICRbUl0gPT09IDA7IClcbiAgICAgIFIrKztcbiAgICBmb3IgKHZhciBKID0gaC5yZXBlYXQoTik7IFIgPCBLOyArK1IpXG4gICAgICBKICs9IHIuY2hhckF0KCRbUl0pO1xuICAgIHJldHVybiBKO1xuICB9XG4gIGZ1bmN0aW9uIEEoRCkge1xuICAgIGlmICh0eXBlb2YgRCAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZ1wiKTtcbiAgICBpZiAoRC5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB2YXIgTiA9IDA7XG4gICAgaWYgKERbTl0gIT09IFwiIFwiKSB7XG4gICAgICBmb3IgKHZhciBrID0gMCwgaiA9IDA7IERbTl0gPT09IGg7IClcbiAgICAgICAgaysrLCBOKys7XG4gICAgICBmb3IgKHZhciBUID0gKEQubGVuZ3RoIC0gTikgKiBkICsgMSA+Pj4gMCwgSyA9IG5ldyBVaW50OEFycmF5KFQpOyBEW05dOyApIHtcbiAgICAgICAgdmFyICQgPSB0W0QuY2hhckNvZGVBdChOKV07XG4gICAgICAgIGlmICgkID09PSAyNTUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciB6ID0gMCwgQiA9IFQgLSAxOyAoJCAhPT0gMCB8fCB6IDwgaikgJiYgQiAhPT0gLTE7IEItLSwgeisrKVxuICAgICAgICAgICQgKz0gZiAqIEtbQl0gPj4+IDAsIEtbQl0gPSAkICUgMjU2ID4+PiAwLCAkID0gJCAvIDI1NiA+Pj4gMDtcbiAgICAgICAgaWYgKCQgIT09IDApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLXplcm8gY2FycnlcIik7XG4gICAgICAgIGogPSB6LCBOKys7XG4gICAgICB9XG4gICAgICBpZiAoRFtOXSAhPT0gXCIgXCIpIHtcbiAgICAgICAgZm9yICh2YXIgXyA9IFQgLSBqOyBfICE9PSBUICYmIEtbX10gPT09IDA7IClcbiAgICAgICAgICBfKys7XG4gICAgICAgIGZvciAodmFyIFIgPSBuZXcgVWludDhBcnJheShrICsgKFQgLSBfKSksIEogPSBrOyBfICE9PSBUOyApXG4gICAgICAgICAgUltKKytdID0gS1tfKytdO1xuICAgICAgICByZXR1cm4gUjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gSShEKSB7XG4gICAgdmFyIE4gPSBBKEQpO1xuICAgIGlmIChOKVxuICAgICAgcmV0dXJuIE47XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb24tJHtlfSBjaGFyYWN0ZXJgKTtcbiAgfVxuICByZXR1cm4geyBlbmNvZGU6IHcsIGRlY29kZVVuc2FmZTogQSwgZGVjb2RlOiBJIH07XG59XG52YXIgSzMgPSBqMywgSDMgPSBLMztcbmNvbnN0IERkID0gKHIpID0+IHtcbiAgaWYgKHIgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHIuY29uc3RydWN0b3IubmFtZSA9PT0gXCJVaW50OEFycmF5XCIpXG4gICAgcmV0dXJuIHI7XG4gIGlmIChyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHIpO1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHIpKVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyLmJ1ZmZlciwgci5ieXRlT2Zmc2V0LCByLmJ5dGVMZW5ndGgpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGVcIik7XG59LCBWMyA9IChyKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUociksIFczID0gKHIpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShyKTtcbmNsYXNzIEczIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgaSkge1xuICAgIHRoaXMubmFtZSA9IGUsIHRoaXMucHJlZml4ID0gdCwgdGhpcy5iYXNlRW5jb2RlID0gaTtcbiAgfVxuICBlbmNvZGUoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgIHJldHVybiBgJHt0aGlzLnByZWZpeH0ke3RoaXMuYmFzZUVuY29kZShlKX1gO1xuICAgIHRocm93IEVycm9yKFwiVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlXCIpO1xuICB9XG59XG5jbGFzcyBKMyB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIGkpIHtcbiAgICBpZiAodGhpcy5uYW1lID0gZSwgdGhpcy5wcmVmaXggPSB0LCB0LmNvZGVQb2ludEF0KDApID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByZWZpeCBjaGFyYWN0ZXJcIik7XG4gICAgdGhpcy5wcmVmaXhDb2RlUG9pbnQgPSB0LmNvZGVQb2ludEF0KDApLCB0aGlzLmJhc2VEZWNvZGUgPSBpO1xuICB9XG4gIGRlY29kZShlKSB7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChlLmNvZGVQb2ludEF0KDApICE9PSB0aGlzLnByZWZpeENvZGVQb2ludClcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBkZWNvZGUgbXVsdGliYXNlIHN0cmluZyAke0pTT04uc3RyaW5naWZ5KGUpfSwgJHt0aGlzLm5hbWV9IGRlY29kZXIgb25seSBzdXBwb3J0cyBpbnB1dHMgcHJlZml4ZWQgd2l0aCAke3RoaXMucHJlZml4fWApO1xuICAgICAgcmV0dXJuIHRoaXMuYmFzZURlY29kZShlLnNsaWNlKHRoaXMucHJlZml4Lmxlbmd0aCkpO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgRXJyb3IoXCJDYW4gb25seSBtdWx0aWJhc2UgZGVjb2RlIHN0cmluZ3NcIik7XG4gIH1cbiAgb3IoZSkge1xuICAgIHJldHVybiBQZCh0aGlzLCBlKTtcbiAgfVxufVxuY2xhc3MgWTMge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5kZWNvZGVycyA9IGU7XG4gIH1cbiAgb3IoZSkge1xuICAgIHJldHVybiBQZCh0aGlzLCBlKTtcbiAgfVxuICBkZWNvZGUoZSkge1xuICAgIGNvbnN0IHQgPSBlWzBdLCBpID0gdGhpcy5kZWNvZGVyc1t0XTtcbiAgICBpZiAoaSlcbiAgICAgIHJldHVybiBpLmRlY29kZShlKTtcbiAgICB0aHJvdyBSYW5nZUVycm9yKGBVbmFibGUgdG8gZGVjb2RlIG11bHRpYmFzZSBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShlKX0sIG9ubHkgaW5wdXRzIHByZWZpeGVkIHdpdGggJHtPYmplY3Qua2V5cyh0aGlzLmRlY29kZXJzKX0gYXJlIHN1cHBvcnRlZGApO1xuICB9XG59XG5jb25zdCBQZCA9IChyLCBlKSA9PiBuZXcgWTMoeyAuLi5yLmRlY29kZXJzIHx8IHsgW3IucHJlZml4XTogciB9LCAuLi5lLmRlY29kZXJzIHx8IHsgW2UucHJlZml4XTogZSB9IH0pO1xuY2xhc3MgWDMge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBpLCBuKSB7XG4gICAgdGhpcy5uYW1lID0gZSwgdGhpcy5wcmVmaXggPSB0LCB0aGlzLmJhc2VFbmNvZGUgPSBpLCB0aGlzLmJhc2VEZWNvZGUgPSBuLCB0aGlzLmVuY29kZXIgPSBuZXcgRzMoZSwgdCwgaSksIHRoaXMuZGVjb2RlciA9IG5ldyBKMyhlLCB0LCBuKTtcbiAgfVxuICBlbmNvZGUoZSkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZXIuZW5jb2RlKGUpO1xuICB9XG4gIGRlY29kZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2Rlci5kZWNvZGUoZSk7XG4gIH1cbn1cbmNvbnN0IERhID0gKHsgbmFtZTogciwgcHJlZml4OiBlLCBlbmNvZGU6IHQsIGRlY29kZTogaSB9KSA9PiBuZXcgWDMociwgZSwgdCwgaSksIGxzID0gKHsgcHJlZml4OiByLCBuYW1lOiBlLCBhbHBoYWJldDogdCB9KSA9PiB7XG4gIGNvbnN0IHsgZW5jb2RlOiBpLCBkZWNvZGU6IG4gfSA9IEgzKHQsIGUpO1xuICByZXR1cm4gRGEoeyBwcmVmaXg6IHIsIG5hbWU6IGUsIGVuY29kZTogaSwgZGVjb2RlOiAocykgPT4gRGQobihzKSkgfSk7XG59LCBaMyA9IChyLCBlLCB0LCBpKSA9PiB7XG4gIGNvbnN0IG4gPSB7fTtcbiAgZm9yIChsZXQgdiA9IDA7IHYgPCBlLmxlbmd0aDsgKyt2KVxuICAgIG5bZVt2XV0gPSB2O1xuICBsZXQgcyA9IHIubGVuZ3RoO1xuICBmb3IgKDsgcltzIC0gMV0gPT09IFwiPVwiOyApXG4gICAgLS1zO1xuICBjb25zdCBvID0gbmV3IFVpbnQ4QXJyYXkocyAqIHQgLyA4IHwgMCk7XG4gIGxldCBmID0gMCwgaCA9IDAsIGQgPSAwO1xuICBmb3IgKGxldCB2ID0gMDsgdiA8IHM7ICsrdikge1xuICAgIGNvbnN0IHcgPSBuW3Jbdl1dO1xuICAgIGlmICh3ID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE5vbi0ke2l9IGNoYXJhY3RlcmApO1xuICAgIGggPSBoIDw8IHQgfCB3LCBmICs9IHQsIGYgPj0gOCAmJiAoZiAtPSA4LCBvW2QrK10gPSAyNTUgJiBoID4+IGYpO1xuICB9XG4gIGlmIChmID49IHQgfHwgMjU1ICYgaCA8PCA4IC0gZilcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBkYXRhXCIpO1xuICByZXR1cm4gbztcbn0sIFEzID0gKHIsIGUsIHQpID0+IHtcbiAgY29uc3QgaSA9IGVbZS5sZW5ndGggLSAxXSA9PT0gXCI9XCIsIG4gPSAoMSA8PCB0KSAtIDE7XG4gIGxldCBzID0gXCJcIiwgbyA9IDAsIGYgPSAwO1xuICBmb3IgKGxldCBoID0gMDsgaCA8IHIubGVuZ3RoOyArK2gpXG4gICAgZm9yIChmID0gZiA8PCA4IHwgcltoXSwgbyArPSA4OyBvID4gdDsgKVxuICAgICAgbyAtPSB0LCBzICs9IGVbbiAmIGYgPj4gb107XG4gIGlmIChvICYmIChzICs9IGVbbiAmIGYgPDwgdCAtIG9dKSwgaSlcbiAgICBmb3IgKDsgcy5sZW5ndGggKiB0ICYgNzsgKVxuICAgICAgcyArPSBcIj1cIjtcbiAgcmV0dXJuIHM7XG59LCBDdCA9ICh7IG5hbWU6IHIsIHByZWZpeDogZSwgYml0c1BlckNoYXI6IHQsIGFscGhhYmV0OiBpIH0pID0+IERhKHsgcHJlZml4OiBlLCBuYW1lOiByLCBlbmNvZGUobikge1xuICByZXR1cm4gUTMobiwgaSwgdCk7XG59LCBkZWNvZGUobikge1xuICByZXR1cm4gWjMobiwgaSwgdCwgcik7XG59IH0pLCBlNiA9IERhKHsgcHJlZml4OiBcIlxcMFwiLCBuYW1lOiBcImlkZW50aXR5XCIsIGVuY29kZTogKHIpID0+IFczKHIpLCBkZWNvZGU6IChyKSA9PiBWMyhyKSB9KTtcbnZhciB0NiA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGlkZW50aXR5OiBlNiB9KTtcbmNvbnN0IHI2ID0gQ3QoeyBwcmVmaXg6IFwiMFwiLCBuYW1lOiBcImJhc2UyXCIsIGFscGhhYmV0OiBcIjAxXCIsIGJpdHNQZXJDaGFyOiAxIH0pO1xudmFyIGk2ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTI6IHI2IH0pO1xuY29uc3QgbjYgPSBDdCh7IHByZWZpeDogXCI3XCIsIG5hbWU6IFwiYmFzZThcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1NjdcIiwgYml0c1BlckNoYXI6IDMgfSk7XG52YXIgczYgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlODogbjYgfSk7XG5jb25zdCBhNiA9IGxzKHsgcHJlZml4OiBcIjlcIiwgbmFtZTogXCJiYXNlMTBcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OVwiIH0pO1xudmFyIG82ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTEwOiBhNiB9KTtcbmNvbnN0IGY2ID0gQ3QoeyBwcmVmaXg6IFwiZlwiLCBuYW1lOiBcImJhc2UxNlwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5YWJjZGVmXCIsIGJpdHNQZXJDaGFyOiA0IH0pLCBjNiA9IEN0KHsgcHJlZml4OiBcIkZcIiwgbmFtZTogXCJiYXNlMTZ1cHBlclwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5QUJDREVGXCIsIGJpdHNQZXJDaGFyOiA0IH0pO1xudmFyIGg2ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTE2OiBmNiwgYmFzZTE2dXBwZXI6IGM2IH0pO1xuY29uc3QgdTYgPSBDdCh7IHByZWZpeDogXCJiXCIsIG5hbWU6IFwiYmFzZTMyXCIsIGFscGhhYmV0OiBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3XCIsIGJpdHNQZXJDaGFyOiA1IH0pLCBkNiA9IEN0KHsgcHJlZml4OiBcIkJcIiwgbmFtZTogXCJiYXNlMzJ1cHBlclwiLCBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2N1wiLCBiaXRzUGVyQ2hhcjogNSB9KSwgbDYgPSBDdCh7IHByZWZpeDogXCJjXCIsIG5hbWU6IFwiYmFzZTMycGFkXCIsIGFscGhhYmV0OiBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PVwiLCBiaXRzUGVyQ2hhcjogNSB9KSwgcDYgPSBDdCh7IHByZWZpeDogXCJDXCIsIG5hbWU6IFwiYmFzZTMycGFkdXBwZXJcIiwgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1Njc9XCIsIGJpdHNQZXJDaGFyOiA1IH0pLCB2NiA9IEN0KHsgcHJlZml4OiBcInZcIiwgbmFtZTogXCJiYXNlMzJoZXhcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZcIiwgYml0c1BlckNoYXI6IDUgfSksIGI2ID0gQ3QoeyBwcmVmaXg6IFwiVlwiLCBuYW1lOiBcImJhc2UzMmhleHVwcGVyXCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWXCIsIGJpdHNQZXJDaGFyOiA1IH0pLCBnNiA9IEN0KHsgcHJlZml4OiBcInRcIiwgbmFtZTogXCJiYXNlMzJoZXhwYWRcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXY9XCIsIGJpdHNQZXJDaGFyOiA1IH0pLCB5NiA9IEN0KHsgcHJlZml4OiBcIlRcIiwgbmFtZTogXCJiYXNlMzJoZXhwYWR1cHBlclwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVj1cIiwgYml0c1BlckNoYXI6IDUgfSksIG02ID0gQ3QoeyBwcmVmaXg6IFwiaFwiLCBuYW1lOiBcImJhc2UzMnpcIiwgYWxwaGFiZXQ6IFwieWJuZHJmZzhlamttY3BxeG90MXV3aXN6YTM0NWg3NjlcIiwgYml0c1BlckNoYXI6IDUgfSk7XG52YXIgdzYgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlMzI6IHU2LCBiYXNlMzJ1cHBlcjogZDYsIGJhc2UzMnBhZDogbDYsIGJhc2UzMnBhZHVwcGVyOiBwNiwgYmFzZTMyaGV4OiB2NiwgYmFzZTMyaGV4dXBwZXI6IGI2LCBiYXNlMzJoZXhwYWQ6IGc2LCBiYXNlMzJoZXhwYWR1cHBlcjogeTYsIGJhc2UzMno6IG02IH0pO1xuY29uc3QgXzYgPSBscyh7IHByZWZpeDogXCJrXCIsIG5hbWU6IFwiYmFzZTM2XCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiIH0pLCB4NiA9IGxzKHsgcHJlZml4OiBcIktcIiwgbmFtZTogXCJiYXNlMzZ1cHBlclwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIiB9KTtcbnZhciBFNiA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2UzNjogXzYsIGJhc2UzNnVwcGVyOiB4NiB9KTtcbmNvbnN0IFM2ID0gbHMoeyBuYW1lOiBcImJhc2U1OGJ0Y1wiLCBwcmVmaXg6IFwielwiLCBhbHBoYWJldDogXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCIgfSksIE02ID0gbHMoeyBuYW1lOiBcImJhc2U1OGZsaWNrclwiLCBwcmVmaXg6IFwiWlwiLCBhbHBoYWJldDogXCIxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaXCIgfSk7XG52YXIgSTYgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlNThidGM6IFM2LCBiYXNlNThmbGlja3I6IE02IH0pO1xuY29uc3QgQTYgPSBDdCh7IHByZWZpeDogXCJtXCIsIG5hbWU6IFwiYmFzZTY0XCIsIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIiwgYml0c1BlckNoYXI6IDYgfSksIEQ2ID0gQ3QoeyBwcmVmaXg6IFwiTVwiLCBuYW1lOiBcImJhc2U2NHBhZFwiLCBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLCBiaXRzUGVyQ2hhcjogNiB9KSwgUDYgPSBDdCh7IHByZWZpeDogXCJ1XCIsIG5hbWU6IFwiYmFzZTY0dXJsXCIsIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV9cIiwgYml0c1BlckNoYXI6IDYgfSksIE82ID0gQ3QoeyBwcmVmaXg6IFwiVVwiLCBuYW1lOiBcImJhc2U2NHVybHBhZFwiLCBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fPVwiLCBiaXRzUGVyQ2hhcjogNiB9KTtcbnZhciBSNiA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2U2NDogQTYsIGJhc2U2NHBhZDogRDYsIGJhc2U2NHVybDogUDYsIGJhc2U2NHVybHBhZDogTzYgfSk7XG5jb25zdCBPZCA9IEFycmF5LmZyb20oXCLwn5qA8J+qkOKYhPCfm7Dwn4yM8J+MkfCfjJLwn4yT8J+MlPCfjJXwn4yW8J+Ml/CfjJjwn4yN8J+Mj/CfjI7wn5CJ4piA8J+Su/CflqXwn5K+8J+Sv/CfmILinaTwn5iN8J+ko/CfmIrwn5mP8J+SlfCfmK3wn5iY8J+RjfCfmIXwn5GP8J+YgfCflKXwn6Ww8J+SlPCfkpbwn5KZ8J+YovCfpJTwn5iG8J+ZhPCfkqrwn5iJ4pi68J+RjPCfpJfwn5Kc8J+YlPCfmI7wn5iH8J+MufCfpKbwn46J8J+SnuKcjOKcqPCfpLfwn5ix8J+YjPCfjLjwn5mM8J+Yi/Cfkpfwn5Ka8J+Yj/Cfkpvwn5mC8J+Sk/CfpKnwn5iE8J+YgPCflqTwn5iD8J+Sr/CfmYjwn5GH8J+OtvCfmJLwn6St4p2j8J+YnPCfkovwn5GA8J+YqvCfmJHwn5Kl8J+Zi/CfmJ7wn5ip8J+YofCfpKrwn5GK8J+ls/CfmKXwn6Sk8J+RifCfkoPwn5iz4pyL8J+YmvCfmJ3wn5i08J+Mn/CfmKzwn5mD8J+NgPCfjLfwn5i78J+Yk+KtkOKchfCfpbrwn4yI8J+YiPCfpJjwn5Km4pyU8J+Yo/Cfj4Pwn5KQ4pi58J+OivCfkpjwn5ig4pid8J+YlfCfjLrwn46C8J+Mu/CfmJDwn5aV8J+SnfCfmYrwn5i58J+Xo/Cfkqvwn5KA8J+RkfCfjrXwn6Se8J+Ym/CflLTwn5ik8J+MvPCfmKvimr3wn6SZ4piV8J+PhvCfpKvwn5GI8J+YrvCfmYbwn4278J+Ng/CfkLbwn5KB8J+YsvCfjL/wn6eh8J+OgeKaofCfjJ7wn46I4p2M4pyK8J+Ri/CfmLDwn6So8J+YtvCfpJ3wn5q28J+SsPCfjZPwn5Ki8J+kn/CfmYHwn5qo8J+SqPCfpKzinIjwn46A8J+NuvCfpJPwn5iZ8J+Sn/CfjLHwn5iW8J+RtvCfpbTilrbinqHinZPwn5KO8J+SuOKsh/CfmKjwn4ya8J+mi/CfmLfwn5W64pqg8J+ZhfCfmJ/wn5i18J+RjvCfpLLwn6Sg8J+kp/Cfk4zwn5S18J+ShfCfp5Dwn5C+8J+NkvCfmJfwn6SR8J+MivCfpK/wn5C34piO8J+Sp/CfmK/wn5KG8J+RhvCfjqTwn5mH8J+NkeKdhPCfjLTwn5Kj8J+QuPCfkozwn5ON8J+lgPCfpKLwn5GF8J+SofCfkqnwn5GQ8J+TuPCfkbvwn6SQ8J+krvCfjrzwn6W18J+aqfCfjY7wn42K8J+RvPCfko3wn5Oj8J+lglwiKSwgTjYgPSBPZC5yZWR1Y2UoKHIsIGUsIHQpID0+IChyW3RdID0gZSwgciksIFtdKSwgVDYgPSBPZC5yZWR1Y2UoKHIsIGUsIHQpID0+IChyW2UuY29kZVBvaW50QXQoMCldID0gdCwgciksIFtdKTtcbmZ1bmN0aW9uIEM2KHIpIHtcbiAgcmV0dXJuIHIucmVkdWNlKChlLCB0KSA9PiAoZSArPSBONlt0XSwgZSksIFwiXCIpO1xufVxuZnVuY3Rpb24gJDYocikge1xuICBjb25zdCBlID0gW107XG4gIGZvciAoY29uc3QgdCBvZiByKSB7XG4gICAgY29uc3QgaSA9IFQ2W3QuY29kZVBvaW50QXQoMCldO1xuICAgIGlmIChpID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi1iYXNlMjU2ZW1vamkgY2hhcmFjdGVyOiAke3R9YCk7XG4gICAgZS5wdXNoKGkpO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShlKTtcbn1cbmNvbnN0IEw2ID0gRGEoeyBwcmVmaXg6IFwi8J+agFwiLCBuYW1lOiBcImJhc2UyNTZlbW9qaVwiLCBlbmNvZGU6IEM2LCBkZWNvZGU6ICQ2IH0pO1xudmFyIEY2ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTI1NmVtb2ppOiBMNiB9KSwgcTYgPSBSZCwgaWggPSAxMjgsIFU2ID0gMTI3LCB6NiA9IH5VNiwgQjYgPSBNYXRoLnBvdygyLCAzMSk7XG5mdW5jdGlvbiBSZChyLCBlLCB0KSB7XG4gIGUgPSBlIHx8IFtdLCB0ID0gdCB8fCAwO1xuICBmb3IgKHZhciBpID0gdDsgciA+PSBCNjsgKVxuICAgIGVbdCsrXSA9IHIgJiAyNTUgfCBpaCwgciAvPSAxMjg7XG4gIGZvciAoOyByICYgejY7IClcbiAgICBlW3QrK10gPSByICYgMjU1IHwgaWgsIHIgPj4+PSA3O1xuICByZXR1cm4gZVt0XSA9IHIgfCAwLCBSZC5ieXRlcyA9IHQgLSBpICsgMSwgZTtcbn1cbnZhciBrNiA9IFBvLCBqNiA9IDEyOCwgbmggPSAxMjc7XG5mdW5jdGlvbiBQbyhyLCBpKSB7XG4gIHZhciB0ID0gMCwgaSA9IGkgfHwgMCwgbiA9IDAsIHMgPSBpLCBvLCBmID0gci5sZW5ndGg7XG4gIGRvIHtcbiAgICBpZiAocyA+PSBmKVxuICAgICAgdGhyb3cgUG8uYnl0ZXMgPSAwLCBuZXcgUmFuZ2VFcnJvcihcIkNvdWxkIG5vdCBkZWNvZGUgdmFyaW50XCIpO1xuICAgIG8gPSByW3MrK10sIHQgKz0gbiA8IDI4ID8gKG8gJiBuaCkgPDwgbiA6IChvICYgbmgpICogTWF0aC5wb3coMiwgbiksIG4gKz0gNztcbiAgfSB3aGlsZSAobyA+PSBqNik7XG4gIHJldHVybiBQby5ieXRlcyA9IHMgLSBpLCB0O1xufVxudmFyIEs2ID0gTWF0aC5wb3coMiwgNyksIEg2ID0gTWF0aC5wb3coMiwgMTQpLCBWNiA9IE1hdGgucG93KDIsIDIxKSwgVzYgPSBNYXRoLnBvdygyLCAyOCksIEc2ID0gTWF0aC5wb3coMiwgMzUpLCBKNiA9IE1hdGgucG93KDIsIDQyKSwgWTYgPSBNYXRoLnBvdygyLCA0OSksIFg2ID0gTWF0aC5wb3coMiwgNTYpLCBaNiA9IE1hdGgucG93KDIsIDYzKSwgUTYgPSBmdW5jdGlvbihyKSB7XG4gIHJldHVybiByIDwgSzYgPyAxIDogciA8IEg2ID8gMiA6IHIgPCBWNiA/IDMgOiByIDwgVzYgPyA0IDogciA8IEc2ID8gNSA6IHIgPCBKNiA/IDYgOiByIDwgWTYgPyA3IDogciA8IFg2ID8gOCA6IHIgPCBaNiA/IDkgOiAxMDtcbn0sIGV3ID0geyBlbmNvZGU6IHE2LCBkZWNvZGU6IGs2LCBlbmNvZGluZ0xlbmd0aDogUTYgfSwgTmQgPSBldztcbmNvbnN0IHNoID0gKHIsIGUsIHQgPSAwKSA9PiAoTmQuZW5jb2RlKHIsIGUsIHQpLCBlKSwgYWggPSAocikgPT4gTmQuZW5jb2RpbmdMZW5ndGgociksIE9vID0gKHIsIGUpID0+IHtcbiAgY29uc3QgdCA9IGUuYnl0ZUxlbmd0aCwgaSA9IGFoKHIpLCBuID0gaSArIGFoKHQpLCBzID0gbmV3IFVpbnQ4QXJyYXkobiArIHQpO1xuICByZXR1cm4gc2gociwgcywgMCksIHNoKHQsIHMsIGkpLCBzLnNldChlLCBuKSwgbmV3IHR3KHIsIHQsIGUsIHMpO1xufTtcbmNsYXNzIHR3IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgaSwgbikge1xuICAgIHRoaXMuY29kZSA9IGUsIHRoaXMuc2l6ZSA9IHQsIHRoaXMuZGlnZXN0ID0gaSwgdGhpcy5ieXRlcyA9IG47XG4gIH1cbn1cbmNvbnN0IFRkID0gKHsgbmFtZTogciwgY29kZTogZSwgZW5jb2RlOiB0IH0pID0+IG5ldyBydyhyLCBlLCB0KTtcbmNsYXNzIHJ3IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgaSkge1xuICAgIHRoaXMubmFtZSA9IGUsIHRoaXMuY29kZSA9IHQsIHRoaXMuZW5jb2RlID0gaTtcbiAgfVxuICBkaWdlc3QoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuZW5jb2RlKGUpO1xuICAgICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gT28odGhpcy5jb2RlLCB0KSA6IHQudGhlbigoaSkgPT4gT28odGhpcy5jb2RlLCBpKSk7XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZVwiKTtcbiAgfVxufVxuY29uc3QgQ2QgPSAocikgPT4gYXN5bmMgKGUpID0+IG5ldyBVaW50OEFycmF5KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KHIsIGUpKSwgaXcgPSBUZCh7IG5hbWU6IFwic2hhMi0yNTZcIiwgY29kZTogMTgsIGVuY29kZTogQ2QoXCJTSEEtMjU2XCIpIH0pLCBudyA9IFRkKHsgbmFtZTogXCJzaGEyLTUxMlwiLCBjb2RlOiAxOSwgZW5jb2RlOiBDZChcIlNIQS01MTJcIikgfSk7XG52YXIgc3cgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBzaGEyNTY6IGl3LCBzaGE1MTI6IG53IH0pO1xuY29uc3QgJGQgPSAwLCBhdyA9IFwiaWRlbnRpdHlcIiwgTGQgPSBEZCwgb3cgPSAocikgPT4gT28oJGQsIExkKHIpKSwgZncgPSB7IGNvZGU6ICRkLCBuYW1lOiBhdywgZW5jb2RlOiBMZCwgZGlnZXN0OiBvdyB9O1xudmFyIGN3ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgaWRlbnRpdHk6IGZ3IH0pO1xubmV3IFRleHRFbmNvZGVyKCksIG5ldyBUZXh0RGVjb2RlcigpO1xuY29uc3Qgb2ggPSB7IC4uLnQ2LCAuLi5pNiwgLi4uczYsIC4uLm82LCAuLi5oNiwgLi4udzYsIC4uLkU2LCAuLi5JNiwgLi4uUjYsIC4uLkY2IH07XG4oeyAuLi5zdywgLi4uY3cgfSk7XG5mdW5jdGlvbiBodyhyID0gMCkge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvY1Vuc2FmZSAhPSBudWxsID8gZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2NVbnNhZmUocikgOiBuZXcgVWludDhBcnJheShyKTtcbn1cbmZ1bmN0aW9uIEZkKHIsIGUsIHQsIGkpIHtcbiAgcmV0dXJuIHsgbmFtZTogciwgcHJlZml4OiBlLCBlbmNvZGVyOiB7IG5hbWU6IHIsIHByZWZpeDogZSwgZW5jb2RlOiB0IH0sIGRlY29kZXI6IHsgZGVjb2RlOiBpIH0gfTtcbn1cbmNvbnN0IGZoID0gRmQoXCJ1dGY4XCIsIFwidVwiLCAocikgPT4gXCJ1XCIgKyBuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpLmRlY29kZShyKSwgKHIpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShyLnN1YnN0cmluZygxKSkpLCBybyA9IEZkKFwiYXNjaWlcIiwgXCJhXCIsIChyKSA9PiB7XG4gIGxldCBlID0gXCJhXCI7XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKylcbiAgICBlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoclt0XSk7XG4gIHJldHVybiBlO1xufSwgKHIpID0+IHtcbiAgciA9IHIuc3Vic3RyaW5nKDEpO1xuICBjb25zdCBlID0gaHcoci5sZW5ndGgpO1xuICBmb3IgKGxldCB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspXG4gICAgZVt0XSA9IHIuY2hhckNvZGVBdCh0KTtcbiAgcmV0dXJuIGU7XG59KSwgdXcgPSB7IHV0Zjg6IGZoLCBcInV0Zi04XCI6IGZoLCBoZXg6IG9oLmJhc2UxNiwgbGF0aW4xOiBybywgYXNjaWk6IHJvLCBiaW5hcnk6IHJvLCAuLi5vaCB9O1xuZnVuY3Rpb24gZHcociwgZSA9IFwidXRmOFwiKSB7XG4gIGNvbnN0IHQgPSB1d1tlXTtcbiAgaWYgKCF0KVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZW5jb2RpbmcgXCIke2V9XCJgKTtcbiAgcmV0dXJuIChlID09PSBcInV0ZjhcIiB8fCBlID09PSBcInV0Zi04XCIpICYmIGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbSAhPSBudWxsID8gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShyLCBcInV0ZjhcIikgOiB0LmRlY29kZXIuZGVjb2RlKGAke3QucHJlZml4fSR7cn1gKTtcbn1cbmNsYXNzIGx3IHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5rZXljaGFpbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMubmFtZSA9IGwzLCB0aGlzLnZlcnNpb24gPSBwMywgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSBqciwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IGkgPSBhd2FpdCB0aGlzLmdldEtleUNoYWluKCk7XG4gICAgICAgIHR5cGVvZiBpIDwgXCJ1XCIgJiYgKHRoaXMua2V5Y2hhaW4gPSBpKSwgdGhpcy5pbml0aWFsaXplZCA9ICEwO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaGFzID0gKGkpID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5rZXljaGFpbi5oYXMoaSkpLCB0aGlzLnNldCA9IGFzeW5jIChpLCBuKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5rZXljaGFpbi5zZXQoaSwgbiksIGF3YWl0IHRoaXMucGVyc2lzdCgpO1xuICAgIH0sIHRoaXMuZ2V0ID0gKGkpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgbiA9IHRoaXMua2V5Y2hhaW4uZ2V0KGkpO1xuICAgICAgaWYgKHR5cGVvZiBuID4gXCJ1XCIpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBzIH0gPSBhZShcIk5PX01BVENISU5HX0tFWVwiLCBgJHt0aGlzLm5hbWV9OiAke2l9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICAgIH0sIHRoaXMuZGVsID0gYXN5bmMgKGkpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmtleWNoYWluLmRlbGV0ZShpKSwgYXdhaXQgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSBrdCh0LCB0aGlzLm5hbWUpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBadCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IHN0b3JhZ2VLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByZWZpeCArIHRoaXMudmVyc2lvbiArIHRoaXMuY29yZS5jdXN0b21TdG9yYWdlUHJlZml4ICsgXCIvL1wiICsgdGhpcy5uYW1lO1xuICB9XG4gIGFzeW5jIHNldEtleUNoYWluKGUpIHtcbiAgICBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgaWQoZSkpO1xuICB9XG4gIGFzeW5jIGdldEtleUNoYWluKCkge1xuICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgcmV0dXJuIHR5cGVvZiBlIDwgXCJ1XCIgPyBuZChlKSA6IHZvaWQgMDtcbiAgfVxuICBhc3luYyBwZXJzaXN0KCkge1xuICAgIGF3YWl0IHRoaXMuc2V0S2V5Q2hhaW4odGhpcy5rZXljaGFpbik7XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gYWUoXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIHB3IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgaSkge1xuICAgIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5uYW1lID0gdTMsIHRoaXMucmFuZG9tU2Vzc2lvbklkZW50aWZpZXIgPSBBbygpLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgKGF3YWl0IHRoaXMua2V5Y2hhaW4uaW5pdCgpLCB0aGlzLmluaXRpYWxpemVkID0gITApO1xuICAgIH0sIHRoaXMuaGFzS2V5cyA9IChuKSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMua2V5Y2hhaW4uaGFzKG4pKSwgdGhpcy5nZXRDbGllbnRJZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgbiA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50U2VlZCgpLCBzID0gSGYobik7XG4gICAgICByZXR1cm4gZnUocy5wdWJsaWNLZXkpO1xuICAgIH0sIHRoaXMuZ2VuZXJhdGVLZXlQYWlyID0gKCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBuID0gRnkoKTtcbiAgICAgIHJldHVybiB0aGlzLnNldFByaXZhdGVLZXkobi5wdWJsaWNLZXksIG4ucHJpdmF0ZUtleSk7XG4gICAgfSwgdGhpcy5zaWduSldUID0gYXN5bmMgKG4pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgcyA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50U2VlZCgpLCBvID0gSGYocyksIGYgPSB0aGlzLnJhbmRvbVNlc3Npb25JZGVudGlmaWVyO1xuICAgICAgcmV0dXJuIGF3YWl0IGV2KGYsIG4sIGQzLCBvKTtcbiAgICB9LCB0aGlzLmdlbmVyYXRlU2hhcmVkS2V5ID0gKG4sIHMsIG8pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0UHJpdmF0ZUtleShuKSwgaCA9IHF5KGYsIHMpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U3ltS2V5KGgsIG8pO1xuICAgIH0sIHRoaXMuc2V0U3ltS2V5ID0gYXN5bmMgKG4sIHMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgbyA9IHMgfHwgQ3Mobik7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5rZXljaGFpbi5zZXQobywgbiksIG87XG4gICAgfSwgdGhpcy5kZWxldGVLZXlQYWlyID0gYXN5bmMgKG4pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmtleWNoYWluLmRlbChuKTtcbiAgICB9LCB0aGlzLmRlbGV0ZVN5bUtleSA9IGFzeW5jIChuKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5rZXljaGFpbi5kZWwobik7XG4gICAgfSwgdGhpcy5lbmNvZGUgPSBhc3luYyAobiwgcywgbykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBmID0gcGQobyksIGggPSBqaShzKTtcbiAgICAgIGlmIChMYyhmKSlcbiAgICAgICAgcmV0dXJuIHp5KGgsIG8/LmVuY29kaW5nKTtcbiAgICAgIGlmICgkYyhmKSkge1xuICAgICAgICBjb25zdCBBID0gZi5zZW5kZXJQdWJsaWNLZXksIEkgPSBmLnJlY2VpdmVyUHVibGljS2V5O1xuICAgICAgICBuID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVNoYXJlZEtleShBLCBJKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGQgPSB0aGlzLmdldFN5bUtleShuKSwgeyB0eXBlOiB2LCBzZW5kZXJQdWJsaWNLZXk6IHcgfSA9IGY7XG4gICAgICByZXR1cm4gVXkoeyB0eXBlOiB2LCBzeW1LZXk6IGQsIG1lc3NhZ2U6IGgsIHNlbmRlclB1YmxpY0tleTogdywgZW5jb2Rpbmc6IG8/LmVuY29kaW5nIH0pO1xuICAgIH0sIHRoaXMuZGVjb2RlID0gYXN5bmMgKG4sIHMsIG8pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgZiA9IGp5KHMsIG8pO1xuICAgICAgaWYgKExjKGYpKSB7XG4gICAgICAgIGNvbnN0IGggPSBreShzLCBvPy5lbmNvZGluZyk7XG4gICAgICAgIHJldHVybiB1bihoKTtcbiAgICAgIH1cbiAgICAgIGlmICgkYyhmKSkge1xuICAgICAgICBjb25zdCBoID0gZi5yZWNlaXZlclB1YmxpY0tleSwgZCA9IGYuc2VuZGVyUHVibGljS2V5O1xuICAgICAgICBuID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVNoYXJlZEtleShoLCBkKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmdldFN5bUtleShuKSwgZCA9IEJ5KHsgc3ltS2V5OiBoLCBlbmNvZGVkOiBzLCBlbmNvZGluZzogbz8uZW5jb2RpbmcgfSk7XG4gICAgICAgIHJldHVybiB1bihkKTtcbiAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBkZWNvZGUgbWVzc2FnZSBmcm9tIHRvcGljOiAnJHtufScsIGNsaWVudElkOiAnJHthd2FpdCB0aGlzLmdldENsaWVudElkKCl9J2ApLCB0aGlzLmxvZ2dlci5lcnJvcihoKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmdldFBheWxvYWRUeXBlID0gKG4sIHMgPSB3aSkgPT4ge1xuICAgICAgY29uc3QgbyA9IFpuKHsgZW5jb2RlZDogbiwgZW5jb2Rpbmc6IHMgfSk7XG4gICAgICByZXR1cm4gVmkoby50eXBlKTtcbiAgICB9LCB0aGlzLmdldFBheWxvYWRTZW5kZXJQdWJsaWNLZXkgPSAobiwgcyA9IHdpKSA9PiB7XG4gICAgICBjb25zdCBvID0gWm4oeyBlbmNvZGVkOiBuLCBlbmNvZGluZzogcyB9KTtcbiAgICAgIHJldHVybiBvLnNlbmRlclB1YmxpY0tleSA/IE10KG8uc2VuZGVyUHVibGljS2V5LCBCdCkgOiB2b2lkIDA7XG4gICAgfSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSBrdCh0LCB0aGlzLm5hbWUpLCB0aGlzLmtleWNoYWluID0gaSB8fCBuZXcgbHcodGhpcy5jb3JlLCB0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIFp0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBhc3luYyBzZXRQcml2YXRlS2V5KGUsIHQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5rZXljaGFpbi5zZXQoZSwgdCksIGU7XG4gIH1cbiAgZ2V0UHJpdmF0ZUtleShlKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5Y2hhaW4uZ2V0KGUpO1xuICB9XG4gIGFzeW5jIGdldENsaWVudFNlZWQoKSB7XG4gICAgbGV0IGUgPSBcIlwiO1xuICAgIHRyeSB7XG4gICAgICBlID0gdGhpcy5rZXljaGFpbi5nZXQoZWgpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgZSA9IEFvKCksIGF3YWl0IHRoaXMua2V5Y2hhaW4uc2V0KGVoLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGR3KGUsIFwiYmFzZTE2XCIpO1xuICB9XG4gIGdldFN5bUtleShlKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5Y2hhaW4uZ2V0KGUpO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IGFlKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyB2dyBleHRlbmRzIHNwIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLmxvZ2dlciA9IGUsIHRoaXMuY29yZSA9IHQsIHRoaXMubWVzc2FnZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLm5hbWUgPSB2MywgdGhpcy52ZXJzaW9uID0gYjMsIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5zdG9yYWdlUHJlZml4ID0ganIsIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIkluaXRpYWxpemVkXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGkgPSBhd2FpdCB0aGlzLmdldFJlbGF5ZXJNZXNzYWdlcygpO1xuICAgICAgICAgIHR5cGVvZiBpIDwgXCJ1XCIgJiYgKHRoaXMubWVzc2FnZXMgPSBpKSwgdGhpcy5sb2dnZXIuZGVidWcoYFN1Y2Nlc3NmdWxseSBSZXN0b3JlZCByZWNvcmRzIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicmVzdG9yZVwiLCBzaXplOiB0aGlzLm1lc3NhZ2VzLnNpemUgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRmFpbGVkIHRvIFJlc3RvcmUgcmVjb3JkcyBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLmVycm9yKGkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMuc2V0ID0gYXN5bmMgKGksIG4pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgcyA9IGZpKG4pO1xuICAgICAgbGV0IG8gPSB0aGlzLm1lc3NhZ2VzLmdldChpKTtcbiAgICAgIHJldHVybiB0eXBlb2YgbyA+IFwidVwiICYmIChvID0ge30pLCB0eXBlb2Ygb1tzXSA8IFwidVwiIHx8IChvW3NdID0gbiwgdGhpcy5tZXNzYWdlcy5zZXQoaSwgbyksIGF3YWl0IHRoaXMucGVyc2lzdCgpKSwgcztcbiAgICB9LCB0aGlzLmdldCA9IChpKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGxldCBuID0gdGhpcy5tZXNzYWdlcy5nZXQoaSk7XG4gICAgICByZXR1cm4gdHlwZW9mIG4gPiBcInVcIiAmJiAobiA9IHt9KSwgbjtcbiAgICB9LCB0aGlzLmhhcyA9IChpLCBuKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmdldChpKSwgbyA9IGZpKG4pO1xuICAgICAgcmV0dXJuIHR5cGVvZiBzW29dIDwgXCJ1XCI7XG4gICAgfSwgdGhpcy5kZWwgPSBhc3luYyAoaSkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubWVzc2FnZXMuZGVsZXRlKGkpLCBhd2FpdCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9LCB0aGlzLmxvZ2dlciA9IGt0KGUsIHRoaXMubmFtZSksIHRoaXMuY29yZSA9IHQ7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIFp0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgc3RvcmFnZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUHJlZml4ICsgdGhpcy52ZXJzaW9uICsgdGhpcy5jb3JlLmN1c3RvbVN0b3JhZ2VQcmVmaXggKyBcIi8vXCIgKyB0aGlzLm5hbWU7XG4gIH1cbiAgYXN5bmMgc2V0UmVsYXllck1lc3NhZ2VzKGUpIHtcbiAgICBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgaWQoZSkpO1xuICB9XG4gIGFzeW5jIGdldFJlbGF5ZXJNZXNzYWdlcygpIHtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgIHJldHVybiB0eXBlb2YgZSA8IFwidVwiID8gbmQoZSkgOiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgcGVyc2lzdCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldFJlbGF5ZXJNZXNzYWdlcyh0aGlzLm1lc3NhZ2VzKTtcbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBhZShcIk5PVF9JTklUSUFMSVpFRFwiLCB0aGlzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxufVxudmFyIGJ3ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBndyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCB5dyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLCBjaCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIG13ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgd3cgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBoaCA9IChyLCBlLCB0KSA9PiBlIGluIHIgPyBidyhyLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogcltlXSA9IHQsIHVoID0gKHIsIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIG13LmNhbGwoZSwgdCkgJiYgaGgociwgdCwgZVt0XSk7XG4gIGlmIChjaClcbiAgICBmb3IgKHZhciB0IG9mIGNoKGUpKVxuICAgICAgd3cuY2FsbChlLCB0KSAmJiBoaChyLCB0LCBlW3RdKTtcbiAgcmV0dXJuIHI7XG59LCBkaCA9IChyLCBlKSA9PiBndyhyLCB5dyhlKSk7XG5jbGFzcyBfdyBleHRlbmRzIGFwIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLnJlbGF5ZXIgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMuZXZlbnRzID0gbmV3IGlyLkV2ZW50RW1pdHRlcigpLCB0aGlzLm5hbWUgPSBnMywgdGhpcy5xdWV1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMucHVibGlzaFRpbWVvdXQgPSBpZS50b01pbGlzZWNvbmRzKGllLk9ORV9NSU5VVEUpLCB0aGlzLmluaXRpYWxQdWJsaXNoVGltZW91dCA9IGllLnRvTWlsaXNlY29uZHMoaWUuT05FX1NFQ09ORCAqIDE1KSwgdGhpcy5uZWVkc1RyYW5zcG9ydFJlc3RhcnQgPSAhMSwgdGhpcy5wdWJsaXNoID0gYXN5bmMgKGksIG4sIHMpID0+IHtcbiAgICAgIHZhciBvO1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJQdWJsaXNoaW5nIFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInB1Ymxpc2hcIiwgcGFyYW1zOiB7IHRvcGljOiBpLCBtZXNzYWdlOiBuLCBvcHRzOiBzIH0gfSk7XG4gICAgICBjb25zdCBmID0gcz8udHRsIHx8IHRoLCBoID0gWXMocyksIGQgPSBzPy5wcm9tcHQgfHwgITEsIHYgPSBzPy50YWcgfHwgMCwgdyA9IHM/LmlkIHx8IHppKCkudG9TdHJpbmcoKSwgQSA9IHsgdG9waWM6IGksIG1lc3NhZ2U6IG4sIG9wdHM6IHsgdHRsOiBmLCByZWxheTogaCwgcHJvbXB0OiBkLCB0YWc6IHYsIGlkOiB3LCBhdHRlc3RhdGlvbjogcz8uYXR0ZXN0YXRpb24gfSB9LCBJID0gYEZhaWxlZCB0byBwdWJsaXNoIHBheWxvYWQsIHBsZWFzZSB0cnkgYWdhaW4uIGlkOiR7d30gdGFnOiR7dn1gO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgRCA9IG5ldyBQcm9taXNlKGFzeW5jIChOKSA9PiB7XG4gICAgICAgICAgY29uc3QgayA9ICh7IGlkOiBUIH0pID0+IHtcbiAgICAgICAgICAgIEEub3B0cy5pZCA9PT0gVCAmJiAodGhpcy5yZW1vdmVSZXF1ZXN0RnJvbVF1ZXVlKFQpLCB0aGlzLnJlbGF5ZXIuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKEV0LnB1Ymxpc2gsIGspLCBOKEEpKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMucmVsYXllci5ldmVudHMub24oRXQucHVibGlzaCwgayk7XG4gICAgICAgICAgY29uc3QgaiA9IG1pKG5ldyBQcm9taXNlKChULCBLKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJwY1B1Ymxpc2goeyB0b3BpYzogaSwgbWVzc2FnZTogbiwgdHRsOiBmLCBwcm9tcHQ6IGQsIHRhZzogdiwgaWQ6IHcsIGF0dGVzdGF0aW9uOiBzPy5hdHRlc3RhdGlvbiB9KS50aGVuKFQpLmNhdGNoKCgkKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJCwgJD8ubWVzc2FnZSksIEsoJCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSwgdGhpcy5pbml0aWFsUHVibGlzaFRpbWVvdXQsIGBGYWlsZWQgaW5pdGlhbCBwdWJsaXNoLCByZXRyeWluZy4uLi4gaWQ6JHt3fSB0YWc6JHt2fWApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBqLCB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihFdC5wdWJsaXNoLCBrKTtcbiAgICAgICAgICB9IGNhdGNoIChUKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnNldCh3LCBkaCh1aCh7fSwgQSksIHsgYXR0ZW1wdDogMSB9KSksIHRoaXMubG9nZ2VyLndhcm4oVCwgVD8ubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicHVibGlzaFwiLCBwYXJhbXM6IHsgaWQ6IHcsIHRvcGljOiBpLCBtZXNzYWdlOiBuLCBvcHRzOiBzIH0gfSksIGF3YWl0IG1pKEQsIHRoaXMucHVibGlzaFRpbWVvdXQsIEkpO1xuICAgICAgfSBjYXRjaCAoRCkge1xuICAgICAgICBpZiAodGhpcy5sb2dnZXIuZGVidWcoXCJGYWlsZWQgdG8gUHVibGlzaCBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci5lcnJvcihEKSwgKG8gPSBzPy5pbnRlcm5hbCkgIT0gbnVsbCAmJiBvLnRocm93T25GYWlsZWRQdWJsaXNoKVxuICAgICAgICAgIHRocm93IEQ7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnF1ZXVlLmRlbGV0ZSh3KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uID0gKGksIG4pID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uKGksIG4pO1xuICAgIH0sIHRoaXMub25jZSA9IChpLCBuKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbmNlKGksIG4pO1xuICAgIH0sIHRoaXMub2ZmID0gKGksIG4pID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9mZihpLCBuKTtcbiAgICB9LCB0aGlzLnJlbW92ZUxpc3RlbmVyID0gKGksIG4pID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGksIG4pO1xuICAgIH0sIHRoaXMucmVsYXllciA9IGUsIHRoaXMubG9nZ2VyID0ga3QodCwgdGhpcy5uYW1lKSwgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIFp0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBhc3luYyBycGNQdWJsaXNoKGUpIHtcbiAgICB2YXIgdCwgaSwgbiwgcztcbiAgICBjb25zdCB7IHRvcGljOiBvLCBtZXNzYWdlOiBmLCB0dGw6IGggPSB0aCwgcHJvbXB0OiBkLCB0YWc6IHYsIGlkOiB3LCBhdHRlc3RhdGlvbjogQSB9ID0gZSwgSSA9IHsgbWV0aG9kOiBqbihZcygpLnByb3RvY29sKS5wdWJsaXNoLCBwYXJhbXM6IHsgdG9waWM6IG8sIG1lc3NhZ2U6IGYsIHR0bDogaCwgcHJvbXB0OiBkLCB0YWc6IHYsIGF0dGVzdGF0aW9uOiBBIH0sIGlkOiB3IH07XG4gICAgenQoKHQgPSBJLnBhcmFtcykgPT0gbnVsbCA/IHZvaWQgMCA6IHQucHJvbXB0KSAmJiAoKGkgPSBJLnBhcmFtcykgPT0gbnVsbCB8fCBkZWxldGUgaS5wcm9tcHQpLCB6dCgobiA9IEkucGFyYW1zKSA9PSBudWxsID8gdm9pZCAwIDogbi50YWcpICYmICgocyA9IEkucGFyYW1zKSA9PSBudWxsIHx8IGRlbGV0ZSBzLnRhZyksIHRoaXMubG9nZ2VyLmRlYnVnKFwiT3V0Z29pbmcgUmVsYXkgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1lc3NhZ2VcIiwgZGlyZWN0aW9uOiBcIm91dGdvaW5nXCIsIHJlcXVlc3Q6IEkgfSk7XG4gICAgY29uc3QgRCA9IGF3YWl0IHRoaXMucmVsYXllci5yZXF1ZXN0KEkpO1xuICAgIHJldHVybiB0aGlzLnJlbGF5ZXIuZXZlbnRzLmVtaXQoRXQucHVibGlzaCwgZSksIHRoaXMubG9nZ2VyLmRlYnVnKFwiU3VjY2Vzc2Z1bGx5IFB1Ymxpc2hlZCBQYXlsb2FkXCIpLCBEO1xuICB9XG4gIHJlbW92ZVJlcXVlc3RGcm9tUXVldWUoZSkge1xuICAgIHRoaXMucXVldWUuZGVsZXRlKGUpO1xuICB9XG4gIGNoZWNrUXVldWUoKSB7XG4gICAgdGhpcy5xdWV1ZS5mb3JFYWNoKGFzeW5jIChlLCB0KSA9PiB7XG4gICAgICBjb25zdCBpID0gZS5hdHRlbXB0ICsgMTtcbiAgICAgIHRoaXMucXVldWUuc2V0KHQsIGRoKHVoKHt9LCBlKSwgeyBhdHRlbXB0OiBpIH0pKTtcbiAgICAgIGNvbnN0IHsgdG9waWM6IG4sIG1lc3NhZ2U6IHMsIG9wdHM6IG8sIGF0dGVzdGF0aW9uOiBmIH0gPSBlO1xuICAgICAgdGhpcy5sb2dnZXIud2Fybih7fSwgYFB1Ymxpc2hlcjogcXVldWUtPnB1Ymxpc2hpbmc6ICR7ZS5vcHRzLmlkfSwgdGFnOiAke2Uub3B0cy50YWd9LCBhdHRlbXB0OiAke2l9YCksIGF3YWl0IHRoaXMucnBjUHVibGlzaCh7IHRvcGljOiBuLCBtZXNzYWdlOiBzLCB0dGw6IG8udHRsLCBwcm9tcHQ6IG8ucHJvbXB0LCB0YWc6IG8udGFnLCBpZDogby5pZCwgYXR0ZXN0YXRpb246IGYgfSksIHRoaXMubG9nZ2VyLndhcm4oe30sIGBQdWJsaXNoZXI6IHF1ZXVlLT5wdWJsaXNoZWQ6ICR7ZS5vcHRzLmlkfWApO1xuICAgIH0pO1xuICB9XG4gIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5yZWxheWVyLmNvcmUuaGVhcnRiZWF0Lm9uKGduLnB1bHNlLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5uZWVkc1RyYW5zcG9ydFJlc3RhcnQpIHtcbiAgICAgICAgdGhpcy5uZWVkc1RyYW5zcG9ydFJlc3RhcnQgPSAhMSwgdGhpcy5yZWxheWVyLmV2ZW50cy5lbWl0KEV0LmNvbm5lY3Rpb25fc3RhbGxlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tRdWV1ZSgpO1xuICAgIH0pLCB0aGlzLnJlbGF5ZXIub24oRXQubWVzc2FnZV9hY2ssIChlKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZVJlcXVlc3RGcm9tUXVldWUoZS5pZC50b1N0cmluZygpKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgeHcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuc2V0ID0gKGUsIHQpID0+IHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLmdldChlKTtcbiAgICAgIHRoaXMuZXhpc3RzKGUsIHQpIHx8IHRoaXMubWFwLnNldChlLCBbLi4uaSwgdF0pO1xuICAgIH0sIHRoaXMuZ2V0ID0gKGUpID0+IHRoaXMubWFwLmdldChlKSB8fCBbXSwgdGhpcy5leGlzdHMgPSAoZSwgdCkgPT4gdGhpcy5nZXQoZSkuaW5jbHVkZXModCksIHRoaXMuZGVsZXRlID0gKGUsIHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdCA+IFwidVwiKSB7XG4gICAgICAgIHRoaXMubWFwLmRlbGV0ZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLm1hcC5oYXMoZSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLmdldChlKTtcbiAgICAgIGlmICghdGhpcy5leGlzdHMoZSwgdCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG4gPSBpLmZpbHRlcigocykgPT4gcyAhPT0gdCk7XG4gICAgICBpZiAoIW4ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubWFwLmRlbGV0ZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tYXAuc2V0KGUsIG4pO1xuICAgIH0sIHRoaXMuY2xlYXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLm1hcC5jbGVhcigpO1xuICAgIH07XG4gIH1cbiAgZ2V0IHRvcGljcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm1hcC5rZXlzKCkpO1xuICB9XG59XG52YXIgRXcgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIFN3ID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsIE13ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMsIGxoID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgSXcgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBBdyA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIHBoID0gKHIsIGUsIHQpID0+IGUgaW4gciA/IEV3KHIsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiByW2VdID0gdCwgem4gPSAociwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgSXcuY2FsbChlLCB0KSAmJiBwaChyLCB0LCBlW3RdKTtcbiAgaWYgKGxoKVxuICAgIGZvciAodmFyIHQgb2YgbGgoZSkpXG4gICAgICBBdy5jYWxsKGUsIHQpICYmIHBoKHIsIHQsIGVbdF0pO1xuICByZXR1cm4gcjtcbn0sIGlvID0gKHIsIGUpID0+IFN3KHIsIE13KGUpKTtcbmNsYXNzIER3IGV4dGVuZHMgY3Age1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCksIHRoaXMucmVsYXllciA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5zdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy50b3BpY01hcCA9IG5ldyB4dygpLCB0aGlzLmV2ZW50cyA9IG5ldyBpci5FdmVudEVtaXR0ZXIoKSwgdGhpcy5uYW1lID0gUzMsIHRoaXMudmVyc2lvbiA9IE0zLCB0aGlzLnBlbmRpbmcgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLmNhY2hlZCA9IFtdLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMucGVuZGluZ1N1YnNjcmlwdGlvbldhdGNoTGFiZWwgPSBcInBlbmRpbmdfc3ViX3dhdGNoX2xhYmVsXCIsIHRoaXMucG9sbGluZ0ludGVydmFsID0gMjAsIHRoaXMuc3RvcmFnZVByZWZpeCA9IGpyLCB0aGlzLnN1YnNjcmliZVRpbWVvdXQgPSBpZS50b01pbGlzZWNvbmRzKGllLk9ORV9NSU5VVEUpLCB0aGlzLmluaXRpYWxTdWJzY3JpYmVUaW1lb3V0ID0gaWUudG9NaWxpc2Vjb25kcyhpZS5PTkVfU0VDT05EICogMTUpLCB0aGlzLmJhdGNoU3Vic2NyaWJlVG9waWNzTGltaXQgPSA1MDAsIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgKHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIiksIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCB0aGlzLmNsaWVudElkID0gYXdhaXQgdGhpcy5yZWxheWVyLmNvcmUuY3J5cHRvLmdldENsaWVudElkKCksIGF3YWl0IHRoaXMucmVzdG9yZSgpKSwgdGhpcy5pbml0aWFsaXplZCA9ICEwO1xuICAgIH0sIHRoaXMuc3Vic2NyaWJlID0gYXN5bmMgKGksIG4pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlN1YnNjcmliaW5nIFRvcGljXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJzdWJzY3JpYmVcIiwgcGFyYW1zOiB7IHRvcGljOiBpLCBvcHRzOiBuIH0gfSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzID0gWXMobiksIG8gPSB7IHRvcGljOiBpLCByZWxheTogcywgdHJhbnNwb3J0VHlwZTogbj8udHJhbnNwb3J0VHlwZSB9O1xuICAgICAgICB0aGlzLnBlbmRpbmcuc2V0KGksIG8pO1xuICAgICAgICBjb25zdCBmID0gYXdhaXQgdGhpcy5ycGNTdWJzY3JpYmUoaSwgcywgbik7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZiA9PSBcInN0cmluZ1wiICYmICh0aGlzLm9uU3Vic2NyaWJlKGYsIG8pLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlN1Y2Nlc3NmdWxseSBTdWJzY3JpYmVkIFRvcGljXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJzdWJzY3JpYmVcIiwgcGFyYW1zOiB7IHRvcGljOiBpLCBvcHRzOiBuIH0gfSkpLCBmO1xuICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkZhaWxlZCB0byBTdWJzY3JpYmUgVG9waWNcIiksIHRoaXMubG9nZ2VyLmVycm9yKHMpLCBzO1xuICAgICAgfVxuICAgIH0sIHRoaXMudW5zdWJzY3JpYmUgPSBhc3luYyAoaSwgbikgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VG9Db21wbGV0ZSgpLCB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdHlwZW9mIG4/LmlkIDwgXCJ1XCIgPyBhd2FpdCB0aGlzLnVuc3Vic2NyaWJlQnlJZChpLCBuLmlkLCBuKSA6IGF3YWl0IHRoaXMudW5zdWJzY3JpYmVCeVRvcGljKGksIG4pO1xuICAgIH0sIHRoaXMuaXNTdWJzY3JpYmVkID0gYXN5bmMgKGkpID0+IHtcbiAgICAgIGlmICh0aGlzLnRvcGljcy5pbmNsdWRlcyhpKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgY29uc3QgbiA9IGAke3RoaXMucGVuZGluZ1N1YnNjcmlwdGlvbldhdGNoTGFiZWx9XyR7aX1gO1xuICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChzLCBvKSA9PiB7XG4gICAgICAgIGNvbnN0IGYgPSBuZXcgaWUuV2F0Y2goKTtcbiAgICAgICAgZi5zdGFydChuKTtcbiAgICAgICAgY29uc3QgaCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAoIXRoaXMucGVuZGluZy5oYXMoaSkgJiYgdGhpcy50b3BpY3MuaW5jbHVkZXMoaSkgfHwgdGhpcy5jYWNoZWQuc29tZSgoZCkgPT4gZC50b3BpYyA9PT0gaSkpICYmIChjbGVhckludGVydmFsKGgpLCBmLnN0b3AobiksIHMoITApKSwgZi5lbGFwc2VkKG4pID49IEkzICYmIChjbGVhckludGVydmFsKGgpLCBmLnN0b3AobiksIG8obmV3IEVycm9yKFwiU3Vic2NyaXB0aW9uIHJlc29sdXRpb24gdGltZW91dFwiKSkpO1xuICAgICAgICB9LCB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICB9KS5jYXRjaCgoKSA9PiAhMSk7XG4gICAgfSwgdGhpcy5vbiA9IChpLCBuKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbihpLCBuKTtcbiAgICB9LCB0aGlzLm9uY2UgPSAoaSwgbikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub25jZShpLCBuKTtcbiAgICB9LCB0aGlzLm9mZiA9IChpLCBuKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vZmYoaSwgbik7XG4gICAgfSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChpLCBuKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihpLCBuKTtcbiAgICB9LCB0aGlzLnN0YXJ0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5vbkNvbm5lY3QoKTtcbiAgICB9LCB0aGlzLnN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLm9uRGlzY29ubmVjdCgpO1xuICAgIH0sIHRoaXMucmVzdGFydCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdG9yZSgpLCBhd2FpdCB0aGlzLm9uUmVzdGFydCgpO1xuICAgIH0sIHRoaXMuY2hlY2tQZW5kaW5nID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucGVuZGluZy5zaXplID09PSAwICYmICghdGhpcy5pbml0aWFsaXplZCB8fCAhdGhpcy5yZWxheWVyLmNvbm5lY3RlZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGkgPSBbXTtcbiAgICAgIHRoaXMucGVuZGluZy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGkucHVzaChuKTtcbiAgICAgIH0pLCBhd2FpdCB0aGlzLmJhdGNoU3Vic2NyaWJlKGkpO1xuICAgIH0sIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVsYXllci5jb3JlLmhlYXJ0YmVhdC5vbihnbi5wdWxzZSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLmNoZWNrUGVuZGluZygpO1xuICAgICAgfSksIHRoaXMuZXZlbnRzLm9uKGVyLmNyZWF0ZWQsIGFzeW5jIChpKSA9PiB7XG4gICAgICAgIGNvbnN0IG4gPSBlci5jcmVhdGVkO1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBFbWl0dGluZyAke259YCksIHRoaXMubG9nZ2VyLmRlYnVnKHsgdHlwZTogXCJldmVudFwiLCBldmVudDogbiwgZGF0YTogaSB9KSwgYXdhaXQgdGhpcy5wZXJzaXN0KCk7XG4gICAgICB9KSwgdGhpcy5ldmVudHMub24oZXIuZGVsZXRlZCwgYXN5bmMgKGkpID0+IHtcbiAgICAgICAgY29uc3QgbiA9IGVyLmRlbGV0ZWQ7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7bn1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiBuLCBkYXRhOiBpIH0pLCBhd2FpdCB0aGlzLnBlcnNpc3QoKTtcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMucmVsYXllciA9IGUsIHRoaXMubG9nZ2VyID0ga3QodCwgdGhpcy5uYW1lKSwgdGhpcy5jbGllbnRJZCA9IFwiXCI7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIFp0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgc3RvcmFnZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUHJlZml4ICsgdGhpcy52ZXJzaW9uICsgdGhpcy5yZWxheWVyLmNvcmUuY3VzdG9tU3RvcmFnZVByZWZpeCArIFwiLy9cIiArIHRoaXMubmFtZTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvbnMuc2l6ZTtcbiAgfVxuICBnZXQgaWRzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3Vic2NyaXB0aW9ucy5rZXlzKCkpO1xuICB9XG4gIGdldCB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdWJzY3JpcHRpb25zLnZhbHVlcygpKTtcbiAgfVxuICBnZXQgdG9waWNzKCkge1xuICAgIHJldHVybiB0aGlzLnRvcGljTWFwLnRvcGljcztcbiAgfVxuICBoYXNTdWJzY3JpcHRpb24oZSwgdCkge1xuICAgIGxldCBpID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGkgPSB0aGlzLmdldFN1YnNjcmlwdGlvbihlKS50b3BpYyA9PT0gdDtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5pbml0aWFsaXplZCA9ICEwO1xuICB9XG4gIG9uRGlzYWJsZSgpIHtcbiAgICB0aGlzLmNhY2hlZCA9IHRoaXMudmFsdWVzLCB0aGlzLnN1YnNjcmlwdGlvbnMuY2xlYXIoKSwgdGhpcy50b3BpY01hcC5jbGVhcigpO1xuICB9XG4gIGFzeW5jIHVuc3Vic2NyaWJlQnlUb3BpYyhlLCB0KSB7XG4gICAgY29uc3QgaSA9IHRoaXMudG9waWNNYXAuZ2V0KGUpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKGkubWFwKGFzeW5jIChuKSA9PiBhd2FpdCB0aGlzLnVuc3Vic2NyaWJlQnlJZChlLCBuLCB0KSkpO1xuICB9XG4gIGFzeW5jIHVuc3Vic2NyaWJlQnlJZChlLCB0LCBpKSB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXCJVbnN1YnNjcmliaW5nIFRvcGljXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJ1bnN1YnNjcmliZVwiLCBwYXJhbXM6IHsgdG9waWM6IGUsIGlkOiB0LCBvcHRzOiBpIH0gfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG4gPSBZcyhpKTtcbiAgICAgIGF3YWl0IHRoaXMucnBjVW5zdWJzY3JpYmUoZSwgdCwgbik7XG4gICAgICBjb25zdCBzID0gc3QoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiLCBgJHt0aGlzLm5hbWV9LCAke2V9YCk7XG4gICAgICBhd2FpdCB0aGlzLm9uVW5zdWJzY3JpYmUoZSwgdCwgcyksIHRoaXMubG9nZ2VyLmRlYnVnKFwiU3VjY2Vzc2Z1bGx5IFVuc3Vic2NyaWJlZCBUb3BpY1wiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwidW5zdWJzY3JpYmVcIiwgcGFyYW1zOiB7IHRvcGljOiBlLCBpZDogdCwgb3B0czogaSB9IH0pO1xuICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgIHRocm93IHRoaXMubG9nZ2VyLmRlYnVnKFwiRmFpbGVkIHRvIFVuc3Vic2NyaWJlIFRvcGljXCIpLCB0aGlzLmxvZ2dlci5lcnJvcihuKSwgbjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcnBjU3Vic2NyaWJlKGUsIHQsIGkpIHtcbiAgICB2YXIgbjtcbiAgICBpPy50cmFuc3BvcnRUeXBlID09PSBhdC5yZWxheSAmJiBhd2FpdCB0aGlzLnJlc3RhcnRUb0NvbXBsZXRlKCk7XG4gICAgY29uc3QgcyA9IHsgbWV0aG9kOiBqbih0LnByb3RvY29sKS5zdWJzY3JpYmUsIHBhcmFtczogeyB0b3BpYzogZSB9IH07XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXCJPdXRnb2luZyBSZWxheSBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwicGF5bG9hZFwiLCBkaXJlY3Rpb246IFwib3V0Z29pbmdcIiwgcmVxdWVzdDogcyB9KTtcbiAgICBjb25zdCBvID0gKG4gPSBpPy5pbnRlcm5hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IG4udGhyb3dPbkZhaWxlZFB1Ymxpc2g7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGYgPSB0aGlzLmdldFN1YnNjcmlwdGlvbklkKGUpO1xuICAgICAgaWYgKGk/LnRyYW5zcG9ydFR5cGUgPT09IGF0LmxpbmtfbW9kZSlcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICh0aGlzLnJlbGF5ZXIuY29ubmVjdGVkIHx8IHRoaXMucmVsYXllci5jb25uZWN0aW5nKSAmJiB0aGlzLnJlbGF5ZXIucmVxdWVzdChzKS5jYXRjaCgodikgPT4gdGhpcy5sb2dnZXIud2Fybih2KSk7XG4gICAgICAgIH0sIGllLnRvTWlsaXNlY29uZHMoaWUuT05FX1NFQ09ORCkpLCBmO1xuICAgICAgY29uc3QgaCA9IG5ldyBQcm9taXNlKGFzeW5jICh2KSA9PiB7XG4gICAgICAgIGNvbnN0IHcgPSAoQSkgPT4ge1xuICAgICAgICAgIEEudG9waWMgPT09IGUgJiYgKHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGVyLmNyZWF0ZWQsIHcpLCB2KEEuaWQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oZXIuY3JlYXRlZCwgdyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgQSA9IGF3YWl0IG1pKG5ldyBQcm9taXNlKChJLCBEKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbGF5ZXIucmVxdWVzdChzKS5jYXRjaCgoTikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKE4sIE4/Lm1lc3NhZ2UpLCBEKE4pO1xuICAgICAgICAgICAgfSkudGhlbihJKTtcbiAgICAgICAgICB9KSwgdGhpcy5pbml0aWFsU3Vic2NyaWJlVGltZW91dCwgYFN1YnNjcmliaW5nIHRvICR7ZX0gZmFpbGVkLCBwbGVhc2UgdHJ5IGFnYWluYCk7XG4gICAgICAgICAgdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIoZXIuY3JlYXRlZCwgdyksIHYoQSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gICAgICB9KSwgZCA9IGF3YWl0IG1pKGgsIHRoaXMuc3Vic2NyaWJlVGltZW91dCwgYFN1YnNjcmliaW5nIHRvICR7ZX0gZmFpbGVkLCBwbGVhc2UgdHJ5IGFnYWluYCk7XG4gICAgICBpZiAoIWQgJiYgbylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJzY3JpYmluZyB0byAke2V9IGZhaWxlZCwgcGxlYXNlIHRyeSBhZ2FpbmApO1xuICAgICAgcmV0dXJuIGQgPyBmIDogbnVsbDtcbiAgICB9IGNhdGNoIChmKSB7XG4gICAgICBpZiAodGhpcy5sb2dnZXIuZGVidWcoXCJPdXRnb2luZyBSZWxheSBTdWJzY3JpYmUgUGF5bG9hZCBzdGFsbGVkXCIpLCB0aGlzLnJlbGF5ZXIuZXZlbnRzLmVtaXQoRXQuY29ubmVjdGlvbl9zdGFsbGVkKSwgbylcbiAgICAgICAgdGhyb3cgZjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYXN5bmMgcnBjQmF0Y2hTdWJzY3JpYmUoZSkge1xuICAgIGlmICghZS5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGVbMF0ucmVsYXksIGkgPSB7IG1ldGhvZDogam4odC5wcm90b2NvbCkuYmF0Y2hTdWJzY3JpYmUsIHBhcmFtczogeyB0b3BpY3M6IGUubWFwKChuKSA9PiBuLnRvcGljKSB9IH07XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXCJPdXRnb2luZyBSZWxheSBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwicGF5bG9hZFwiLCBkaXJlY3Rpb246IFwib3V0Z29pbmdcIiwgcmVxdWVzdDogaSB9KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYXdhaXQgbWkobmV3IFByb21pc2UoKG4pID0+IHtcbiAgICAgICAgdGhpcy5yZWxheWVyLnJlcXVlc3QoaSkuY2F0Y2goKHMpID0+IHRoaXMubG9nZ2VyLndhcm4ocykpLnRoZW4obik7XG4gICAgICB9KSwgdGhpcy5zdWJzY3JpYmVUaW1lb3V0LCBcInJwY0JhdGNoU3Vic2NyaWJlIGZhaWxlZCwgcGxlYXNlIHRyeSBhZ2FpblwiKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMucmVsYXllci5ldmVudHMuZW1pdChFdC5jb25uZWN0aW9uX3N0YWxsZWQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBycGNCYXRjaEZldGNoTWVzc2FnZXMoZSkge1xuICAgIGlmICghZS5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGVbMF0ucmVsYXksIGkgPSB7IG1ldGhvZDogam4odC5wcm90b2NvbCkuYmF0Y2hGZXRjaE1lc3NhZ2VzLCBwYXJhbXM6IHsgdG9waWNzOiBlLm1hcCgocykgPT4gcy50b3BpYykgfSB9O1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiT3V0Z29pbmcgUmVsYXkgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcInBheWxvYWRcIiwgZGlyZWN0aW9uOiBcIm91dGdvaW5nXCIsIHJlcXVlc3Q6IGkgfSk7XG4gICAgbGV0IG47XG4gICAgdHJ5IHtcbiAgICAgIG4gPSBhd2FpdCBhd2FpdCBtaShuZXcgUHJvbWlzZSgocywgbykgPT4ge1xuICAgICAgICB0aGlzLnJlbGF5ZXIucmVxdWVzdChpKS5jYXRjaCgoZikgPT4ge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oZiksIG8oZik7XG4gICAgICAgIH0pLnRoZW4ocyk7XG4gICAgICB9KSwgdGhpcy5zdWJzY3JpYmVUaW1lb3V0LCBcInJwY0JhdGNoRmV0Y2hNZXNzYWdlcyBmYWlsZWQsIHBsZWFzZSB0cnkgYWdhaW5cIik7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aGlzLnJlbGF5ZXIuZXZlbnRzLmVtaXQoRXQuY29ubmVjdGlvbl9zdGFsbGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgcnBjVW5zdWJzY3JpYmUoZSwgdCwgaSkge1xuICAgIGNvbnN0IG4gPSB7IG1ldGhvZDogam4oaS5wcm90b2NvbCkudW5zdWJzY3JpYmUsIHBhcmFtczogeyB0b3BpYzogZSwgaWQ6IHQgfSB9O1xuICAgIHJldHVybiB0aGlzLmxvZ2dlci5kZWJ1ZyhcIk91dGdvaW5nIFJlbGF5IFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJwYXlsb2FkXCIsIGRpcmVjdGlvbjogXCJvdXRnb2luZ1wiLCByZXF1ZXN0OiBuIH0pLCB0aGlzLnJlbGF5ZXIucmVxdWVzdChuKTtcbiAgfVxuICBvblN1YnNjcmliZShlLCB0KSB7XG4gICAgdGhpcy5zZXRTdWJzY3JpcHRpb24oZSwgaW8oem4oe30sIHQpLCB7IGlkOiBlIH0pKSwgdGhpcy5wZW5kaW5nLmRlbGV0ZSh0LnRvcGljKTtcbiAgfVxuICBvbkJhdGNoU3Vic2NyaWJlKGUpIHtcbiAgICBlLmxlbmd0aCAmJiBlLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHRoaXMuc2V0U3Vic2NyaXB0aW9uKHQuaWQsIHpuKHt9LCB0KSksIHRoaXMucGVuZGluZy5kZWxldGUodC50b3BpYyk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgb25VbnN1YnNjcmliZShlLCB0LCBpKSB7XG4gICAgdGhpcy5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKHQpLCB0aGlzLmhhc1N1YnNjcmlwdGlvbih0LCBlKSAmJiB0aGlzLmRlbGV0ZVN1YnNjcmlwdGlvbih0LCBpKSwgYXdhaXQgdGhpcy5yZWxheWVyLm1lc3NhZ2VzLmRlbChlKTtcbiAgfVxuICBhc3luYyBzZXRSZWxheWVyU3Vic2NyaXB0aW9ucyhlKSB7XG4gICAgYXdhaXQgdGhpcy5yZWxheWVyLmNvcmUuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgZSk7XG4gIH1cbiAgYXN5bmMgZ2V0UmVsYXllclN1YnNjcmlwdGlvbnMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVsYXllci5jb3JlLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICB9XG4gIHNldFN1YnNjcmlwdGlvbihlLCB0KSB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXCJTZXR0aW5nIHN1YnNjcmlwdGlvblwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwic2V0U3Vic2NyaXB0aW9uXCIsIGlkOiBlLCBzdWJzY3JpcHRpb246IHQgfSksIHRoaXMuYWRkU3Vic2NyaXB0aW9uKGUsIHQpO1xuICB9XG4gIGFkZFN1YnNjcmlwdGlvbihlLCB0KSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChlLCB6bih7fSwgdCkpLCB0aGlzLnRvcGljTWFwLnNldCh0LnRvcGljLCBlKSwgdGhpcy5ldmVudHMuZW1pdChlci5jcmVhdGVkLCB0KTtcbiAgfVxuICBnZXRTdWJzY3JpcHRpb24oZSkge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiR2V0dGluZyBzdWJzY3JpcHRpb25cIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcImdldFN1YnNjcmlwdGlvblwiLCBpZDogZSB9KTtcbiAgICBjb25zdCB0ID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChlKTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogaSB9ID0gYWUoXCJOT19NQVRDSElOR19LRVlcIiwgYCR7dGhpcy5uYW1lfTogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBkZWxldGVTdWJzY3JpcHRpb24oZSwgdCkge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiRGVsZXRpbmcgc3Vic2NyaXB0aW9uXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJkZWxldGVTdWJzY3JpcHRpb25cIiwgaWQ6IGUsIHJlYXNvbjogdCB9KTtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRTdWJzY3JpcHRpb24oZSk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShlKSwgdGhpcy50b3BpY01hcC5kZWxldGUoaS50b3BpYywgZSksIHRoaXMuZXZlbnRzLmVtaXQoZXIuZGVsZXRlZCwgaW8oem4oe30sIGkpLCB7IHJlYXNvbjogdCB9KSk7XG4gIH1cbiAgYXN5bmMgcGVyc2lzdCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldFJlbGF5ZXJTdWJzY3JpcHRpb25zKHRoaXMudmFsdWVzKSwgdGhpcy5ldmVudHMuZW1pdChlci5zeW5jKTtcbiAgfVxuICBhc3luYyBvblJlc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuY2FjaGVkLmxlbmd0aCkge1xuICAgICAgY29uc3QgZSA9IFsuLi50aGlzLmNhY2hlZF0sIHQgPSBNYXRoLmNlaWwodGhpcy5jYWNoZWQubGVuZ3RoIC8gdGhpcy5iYXRjaFN1YnNjcmliZVRvcGljc0xpbWl0KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG4gPSBlLnNwbGljZSgwLCB0aGlzLmJhdGNoU3Vic2NyaWJlVG9waWNzTGltaXQpO1xuICAgICAgICBhd2FpdCB0aGlzLmJhdGNoU3Vic2NyaWJlKG4pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV2ZW50cy5lbWl0KGVyLnJlc3Vic2NyaWJlZCk7XG4gIH1cbiAgYXN5bmMgcmVzdG9yZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuZ2V0UmVsYXllclN1YnNjcmlwdGlvbnMoKTtcbiAgICAgIGlmICh0eXBlb2YgZSA+IFwidVwiIHx8ICFlLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucy5zaXplKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gYWUoXCJSRVNUT1JFX1dJTExfT1ZFUlJJREVcIiwgdGhpcy5uYW1lKTtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3IodCksIHRoaXMubG9nZ2VyLmVycm9yKGAke3RoaXMubmFtZX06ICR7SlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZXMpfWApLCBuZXcgRXJyb3IodCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlZCA9IGUsIHRoaXMubG9nZ2VyLmRlYnVnKGBTdWNjZXNzZnVsbHkgUmVzdG9yZWQgc3Vic2NyaXB0aW9ucyBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInJlc3RvcmVcIiwgc3Vic2NyaXB0aW9uczogdGhpcy52YWx1ZXMgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBSZXN0b3JlIHN1YnNjcmlwdGlvbnMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci5lcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYmF0Y2hTdWJzY3JpYmUoZSkge1xuICAgIGUubGVuZ3RoICYmIChhd2FpdCB0aGlzLnJwY0JhdGNoU3Vic2NyaWJlKGUpLCB0aGlzLm9uQmF0Y2hTdWJzY3JpYmUoZS5tYXAoKHQpID0+IGlvKHpuKHt9LCB0KSwgeyBpZDogdGhpcy5nZXRTdWJzY3JpcHRpb25JZCh0LnRvcGljKSB9KSkpKTtcbiAgfVxuICBhc3luYyBiYXRjaEZldGNoTWVzc2FnZXMoZSkge1xuICAgIGlmICghZS5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoYEZldGNoaW5nIGJhdGNoIG1lc3NhZ2VzIGZvciAke2UubGVuZ3RofSBzdWJzY3JpcHRpb25zYCk7XG4gICAgY29uc3QgdCA9IGF3YWl0IHRoaXMucnBjQmF0Y2hGZXRjaE1lc3NhZ2VzKGUpO1xuICAgIHQgJiYgdC5tZXNzYWdlcyAmJiAoYXdhaXQgZHkoaWUudG9NaWxpc2Vjb25kcyhpZS5PTkVfU0VDT05EKSksIGF3YWl0IHRoaXMucmVsYXllci5oYW5kbGVCYXRjaE1lc3NhZ2VFdmVudHModC5tZXNzYWdlcykpO1xuICB9XG4gIGFzeW5jIG9uQ29ubmVjdCgpIHtcbiAgICBhd2FpdCB0aGlzLnJlc3RhcnQoKSwgdGhpcy5yZXNldCgpO1xuICB9XG4gIG9uRGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLm9uRGlzYWJsZSgpO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IGFlKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlc3RhcnRUb0NvbXBsZXRlKCkge1xuICAgICF0aGlzLnJlbGF5ZXIuY29ubmVjdGVkICYmICF0aGlzLnJlbGF5ZXIuY29ubmVjdGluZyAmJiBhd2FpdCB0aGlzLnJlbGF5ZXIudHJhbnNwb3J0T3BlbigpO1xuICB9XG4gIGdldFN1YnNjcmlwdGlvbklkKGUpIHtcbiAgICByZXR1cm4gZmkoZSArIHRoaXMuY2xpZW50SWQpO1xuICB9XG59XG52YXIgUHcgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIHZoID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgT3cgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBSdyA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIGJoID0gKHIsIGUsIHQpID0+IGUgaW4gciA/IFB3KHIsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiByW2VdID0gdCwgZ2ggPSAociwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgT3cuY2FsbChlLCB0KSAmJiBiaChyLCB0LCBlW3RdKTtcbiAgaWYgKHZoKVxuICAgIGZvciAodmFyIHQgb2YgdmgoZSkpXG4gICAgICBSdy5jYWxsKGUsIHQpICYmIGJoKHIsIHQsIGVbdF0pO1xuICByZXR1cm4gcjtcbn07XG5jbGFzcyBOdyBleHRlbmRzIG9wIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLnByb3RvY29sID0gXCJ3Y1wiLCB0aGlzLnZlcnNpb24gPSAyLCB0aGlzLmV2ZW50cyA9IG5ldyBpci5FdmVudEVtaXR0ZXIoKSwgdGhpcy5uYW1lID0gbTMsIHRoaXMudHJhbnNwb3J0RXhwbGljaXRseUNsb3NlZCA9ICExLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuY29ubmVjdGlvbkF0dGVtcHRJblByb2dyZXNzID0gITEsIHRoaXMuaGFzRXhwZXJpZW5jZWROZXR3b3JrRGlzcnVwdGlvbiA9ICExLCB0aGlzLmhlYXJ0QmVhdFRpbWVvdXQgPSBpZS50b01pbGlzZWNvbmRzKGllLlRISVJUWV9TRUNPTkRTICsgaWUuRklWRV9TRUNPTkRTKSwgdGhpcy5yZXF1ZXN0c0luRmxpZ2h0ID0gW10sIHRoaXMuY29ubmVjdFRpbWVvdXQgPSBpZS50b01pbGlzZWNvbmRzKGllLk9ORV9TRUNPTkQgKiAxNSksIHRoaXMucmVxdWVzdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB2YXIgaSwgbjtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiUHVibGlzaGluZyBSZXF1ZXN0IFBheWxvYWRcIik7XG4gICAgICBjb25zdCBzID0gdC5pZCB8fCB6aSgpLnRvU3RyaW5nKCk7XG4gICAgICBhd2FpdCB0aGlzLnRvRXN0YWJsaXNoQ29ubmVjdGlvbigpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoeyBpZDogcywgbWV0aG9kOiB0Lm1ldGhvZCwgdG9waWM6IChpID0gdC5wYXJhbXMpID09IG51bGwgPyB2b2lkIDAgOiBpLnRvcGljIH0sIFwicmVsYXllci5yZXF1ZXN0IC0gcHVibGlzaGluZy4uLlwiKTtcbiAgICAgICAgY29uc3QgbyA9IGAke3N9OiR7KChuID0gdC5wYXJhbXMpID09IG51bGwgPyB2b2lkIDAgOiBuLnRhZykgfHwgXCJcIn1gO1xuICAgICAgICB0aGlzLnJlcXVlc3RzSW5GbGlnaHQucHVzaChvKTtcbiAgICAgICAgY29uc3QgZiA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdHNJbkZsaWdodCA9IHRoaXMucmVxdWVzdHNJbkZsaWdodC5maWx0ZXIoKGgpID0+IGggIT09IG8pLCBmO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5kZWJ1ZyhgRmFpbGVkIHRvIFB1Ymxpc2ggUmVxdWVzdDogJHtzfWApLCBvO1xuICAgICAgfVxuICAgIH0sIHRoaXMucmVzZXRQaW5nVGltZW91dCA9ICgpID0+IHtcbiAgICAgIGlmIChHcygpKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0KSwgdGhpcy5waW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIHQsIGksIG47XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1Zyh7fSwgXCJwaW5nVGltZW91dDogQ29ubmVjdGlvbiBzdGFsbGVkLCB0ZXJtaW5hdGluZy4uLlwiKSwgKG4gPSAoaSA9ICh0ID0gdGhpcy5wcm92aWRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IHQuY29ubmVjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IGkuc29ja2V0KSA9PSBudWxsIHx8IG4udGVybWluYXRlKCk7XG4gICAgICAgICAgfSwgdGhpcy5oZWFydEJlYXRUaW1lb3V0KTtcbiAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4odCwgdD8ubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzLm9uUGF5bG9hZEhhbmRsZXIgPSAodCkgPT4ge1xuICAgICAgdGhpcy5vblByb3ZpZGVyUGF5bG9hZCh0KSwgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgfSwgdGhpcy5vbkNvbm5lY3RIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2dnZXIud2Fybih7fSwgXCJSZWxheWVyIGNvbm5lY3RlZCDwn5ucXCIpLCB0aGlzLnN0YXJ0UGluZ1RpbWVvdXQoKSwgdGhpcy5ldmVudHMuZW1pdChFdC5jb25uZWN0KTtcbiAgICB9LCB0aGlzLm9uRGlzY29ubmVjdEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKHt9LCBcIlJlbGF5ZXIgZGlzY29ubmVjdGVkIPCfm5FcIiksIHRoaXMucmVxdWVzdHNJbkZsaWdodCA9IFtdLCB0aGlzLm9uUHJvdmlkZXJEaXNjb25uZWN0KCk7XG4gICAgfSwgdGhpcy5vblByb3ZpZGVyRXJyb3JIYW5kbGVyID0gKHQpID0+IHtcbiAgICAgIHRoaXMubG9nZ2VyLmZhdGFsKHQsIGBGYXRhbCBzb2NrZXQgZXJyb3I6ICR7dD8ubWVzc2FnZX1gKSwgdGhpcy5ldmVudHMuZW1pdChFdC5lcnJvciwgdCksIHRoaXMubG9nZ2VyLmZhdGFsKFwiRmF0YWwgc29ja2V0IGVycm9yIHJlY2VpdmVkLCBjbG9zaW5nIHRyYW5zcG9ydFwiKSwgdGhpcy50cmFuc3BvcnRDbG9zZSgpO1xuICAgIH0sIHRoaXMucmVnaXN0ZXJQcm92aWRlckxpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgIHRoaXMucHJvdmlkZXIub24oaHIucGF5bG9hZCwgdGhpcy5vblBheWxvYWRIYW5kbGVyKSwgdGhpcy5wcm92aWRlci5vbihoci5jb25uZWN0LCB0aGlzLm9uQ29ubmVjdEhhbmRsZXIpLCB0aGlzLnByb3ZpZGVyLm9uKGhyLmRpc2Nvbm5lY3QsIHRoaXMub25EaXNjb25uZWN0SGFuZGxlciksIHRoaXMucHJvdmlkZXIub24oaHIuZXJyb3IsIHRoaXMub25Qcm92aWRlckVycm9ySGFuZGxlcik7XG4gICAgfSwgdGhpcy5jb3JlID0gZS5jb3JlLCB0aGlzLmxvZ2dlciA9IHR5cGVvZiBlLmxvZ2dlciA8IFwidVwiICYmIHR5cGVvZiBlLmxvZ2dlciAhPSBcInN0cmluZ1wiID8ga3QoZS5sb2dnZXIsIHRoaXMubmFtZSkgOiBuYShUbyh7IGxldmVsOiBlLmxvZ2dlciB8fCB5MyB9KSksIHRoaXMubWVzc2FnZXMgPSBuZXcgdncodGhpcy5sb2dnZXIsIGUuY29yZSksIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBEdyh0aGlzLCB0aGlzLmxvZ2dlciksIHRoaXMucHVibGlzaGVyID0gbmV3IF93KHRoaXMsIHRoaXMubG9nZ2VyKSwgdGhpcy5yZWxheVVybCA9IGU/LnJlbGF5VXJsIHx8IElkLCB0aGlzLnByb2plY3RJZCA9IGUucHJvamVjdElkLCBaMigpID8gdGhpcy5wYWNrYWdlTmFtZSA9IEljKCkgOiBRMigpICYmICh0aGlzLmJ1bmRsZUlkID0gSWMoKSksIHRoaXMucHJvdmlkZXIgPSB7fTtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIGlmICh0aGlzLmxvZ2dlci50cmFjZShcIkluaXRpYWxpemVkXCIpLCB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSwgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMubWVzc2FnZXMuaW5pdCgpLCB0aGlzLnN1YnNjcmliZXIuaW5pdCgpXSksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCwgdGhpcy5zdWJzY3JpYmVyLmNhY2hlZC5sZW5ndGggPiAwKVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnRPcGVuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oZSwgZT8ubWVzc2FnZSk7XG4gICAgICB9XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIFp0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHZhciBlLCB0LCBpO1xuICAgIHJldHVybiAoKGkgPSAodCA9IChlID0gdGhpcy5wcm92aWRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IGUuY29ubmVjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IHQuc29ja2V0KSA9PSBudWxsID8gdm9pZCAwIDogaS5yZWFkeVN0YXRlKSA9PT0gMTtcbiAgfVxuICBnZXQgY29ubmVjdGluZygpIHtcbiAgICB2YXIgZSwgdCwgaTtcbiAgICByZXR1cm4gKChpID0gKHQgPSAoZSA9IHRoaXMucHJvdmlkZXIpID09IG51bGwgPyB2b2lkIDAgOiBlLmNvbm5lY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiB0LnNvY2tldCkgPT0gbnVsbCA/IHZvaWQgMCA6IGkucmVhZHlTdGF0ZSkgPT09IDA7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChlLCB0LCBpKSB7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMucHVibGlzaGVyLnB1Ymxpc2goZSwgdCwgaSksIGF3YWl0IHRoaXMucmVjb3JkTWVzc2FnZUV2ZW50KHsgdG9waWM6IGUsIG1lc3NhZ2U6IHQsIHB1Ymxpc2hlZEF0OiBEYXRlLm5vdygpLCB0cmFuc3BvcnRUeXBlOiBhdC5yZWxheSB9KTtcbiAgfVxuICBhc3luYyBzdWJzY3JpYmUoZSwgdCkge1xuICAgIHZhciBpLCBuLCBzO1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCAoISh0ICE9IG51bGwgJiYgdC50cmFuc3BvcnRUeXBlKSB8fCB0Py50cmFuc3BvcnRUeXBlID09PSBcInJlbGF5XCIpICYmIGF3YWl0IHRoaXMudG9Fc3RhYmxpc2hDb25uZWN0aW9uKCk7XG4gICAgY29uc3QgbyA9IHR5cGVvZiAoKGkgPSB0Py5pbnRlcm5hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IGkudGhyb3dPbkZhaWxlZFB1Ymxpc2gpID4gXCJ1XCIgPyAhMCA6IChuID0gdD8uaW50ZXJuYWwpID09IG51bGwgPyB2b2lkIDAgOiBuLnRocm93T25GYWlsZWRQdWJsaXNoO1xuICAgIGxldCBmID0gKChzID0gdGhpcy5zdWJzY3JpYmVyLnRvcGljTWFwLmdldChlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHNbMF0pIHx8IFwiXCIsIGg7XG4gICAgY29uc3QgZCA9ICh2KSA9PiB7XG4gICAgICB2LnRvcGljID09PSBlICYmICh0aGlzLnN1YnNjcmliZXIub2ZmKGVyLmNyZWF0ZWQsIGQpLCBoKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKFtuZXcgUHJvbWlzZSgodikgPT4ge1xuICAgICAgaCA9IHYsIHRoaXMuc3Vic2NyaWJlci5vbihlci5jcmVhdGVkLCBkKTtcbiAgICB9KSwgbmV3IFByb21pc2UoYXN5bmMgKHYsIHcpID0+IHtcbiAgICAgIGYgPSBhd2FpdCB0aGlzLnN1YnNjcmliZXIuc3Vic2NyaWJlKGUsIGdoKHsgaW50ZXJuYWw6IHsgdGhyb3dPbkZhaWxlZFB1Ymxpc2g6IG8gfSB9LCB0KSkuY2F0Y2goKEEpID0+IHtcbiAgICAgICAgbyAmJiB3KEEpO1xuICAgICAgfSkgfHwgZiwgdigpO1xuICAgIH0pXSksIGY7XG4gIH1cbiAgYXN5bmMgdW5zdWJzY3JpYmUoZSwgdCkge1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLnN1YnNjcmliZXIudW5zdWJzY3JpYmUoZSwgdCk7XG4gIH1cbiAgb24oZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uKGUsIHQpO1xuICB9XG4gIG9uY2UoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uY2UoZSwgdCk7XG4gIH1cbiAgb2ZmKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vZmYoZSwgdCk7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGUsIHQpO1xuICB9XG4gIGFzeW5jIHRyYW5zcG9ydERpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5wcm92aWRlci5kaXNjb25uZWN0ICYmICh0aGlzLmhhc0V4cGVyaWVuY2VkTmV0d29ya0Rpc3J1cHRpb24gfHwgdGhpcy5jb25uZWN0ZWQpID8gYXdhaXQgbWkodGhpcy5wcm92aWRlci5kaXNjb25uZWN0KCksIDJlMywgXCJwcm92aWRlci5kaXNjb25uZWN0KClcIikuY2F0Y2goKCkgPT4gdGhpcy5vblByb3ZpZGVyRGlzY29ubmVjdCgpKSA6IHRoaXMub25Qcm92aWRlckRpc2Nvbm5lY3QoKTtcbiAgfVxuICBhc3luYyB0cmFuc3BvcnRDbG9zZSgpIHtcbiAgICB0aGlzLnRyYW5zcG9ydEV4cGxpY2l0bHlDbG9zZWQgPSAhMCwgYXdhaXQgdGhpcy50cmFuc3BvcnREaXNjb25uZWN0KCk7XG4gIH1cbiAgYXN5bmMgdHJhbnNwb3J0T3BlbihlKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdFByb21pc2UgPyAodGhpcy5sb2dnZXIuZGVidWcoe30sIFwiV2FpdGluZyBmb3IgZXhpc3RpbmcgY29ubmVjdGlvbiBhdHRlbXB0IHRvIHJlc29sdmUuLi5cIiksIGF3YWl0IHRoaXMuY29ubmVjdFByb21pc2UsIHRoaXMubG9nZ2VyLmRlYnVnKHt9LCBcIkV4aXN0aW5nIGNvbm5lY3Rpb24gYXR0ZW1wdCByZXNvbHZlZFwiKSkgOiAodGhpcy5jb25uZWN0UHJvbWlzZSA9IG5ldyBQcm9taXNlKGFzeW5jICh0LCBpKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3QoZSkudGhlbih0KS5jYXRjaChpKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy5jb25uZWN0UHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgIH0pO1xuICAgIH0pLCBhd2FpdCB0aGlzLmNvbm5lY3RQcm9taXNlKSwgIXRoaXMuY29ubmVjdGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBlc3RhYmxpc2ggc29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIHJlbGF5IHNlcnZlcjogJHt0aGlzLnJlbGF5VXJsfWApO1xuICB9XG4gIGFzeW5jIHJlc3RhcnRUcmFuc3BvcnQoZSkge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKHt9LCBcIlJlc3RhcnRpbmcgdHJhbnNwb3J0Li4uXCIpLCAhdGhpcy5jb25uZWN0aW9uQXR0ZW1wdEluUHJvZ3Jlc3MgJiYgKHRoaXMucmVsYXlVcmwgPSBlIHx8IHRoaXMucmVsYXlVcmwsIGF3YWl0IHRoaXMuY29uZmlybU9ubGluZVN0YXRlT3JUaHJvdygpLCBhd2FpdCB0aGlzLnRyYW5zcG9ydENsb3NlKCksIGF3YWl0IHRoaXMudHJhbnNwb3J0T3BlbigpKTtcbiAgfVxuICBhc3luYyBjb25maXJtT25saW5lU3RhdGVPclRocm93KCkge1xuICAgIGlmICghYXdhaXQgV2MoKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGludGVybmV0IGNvbm5lY3Rpb24gZGV0ZWN0ZWQuIFBsZWFzZSByZXN0YXJ0IHlvdXIgbmV0d29yayBhbmQgdHJ5IGFnYWluLlwiKTtcbiAgfVxuICBhc3luYyBoYW5kbGVCYXRjaE1lc3NhZ2VFdmVudHMoZSkge1xuICAgIGlmIChlPy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiQmF0Y2ggbWVzc2FnZSBldmVudHMgaXMgZW1wdHkuIElnbm9yaW5nLi4uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ID0gZS5zb3J0KChpLCBuKSA9PiBpLnB1Ymxpc2hlZEF0IC0gbi5wdWJsaXNoZWRBdCk7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoYEJhdGNoIG9mICR7dC5sZW5ndGh9IG1lc3NhZ2UgZXZlbnRzIHNvcnRlZGApO1xuICAgIGZvciAoY29uc3QgaSBvZiB0KVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5vbk1lc3NhZ2VFdmVudChpKTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihuLCBcIkVycm9yIHdoaWxlIHByb2Nlc3NpbmcgYmF0Y2ggbWVzc2FnZSBldmVudDogXCIgKyBuPy5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICB0aGlzLmxvZ2dlci50cmFjZShgQmF0Y2ggb2YgJHt0Lmxlbmd0aH0gbWVzc2FnZSBldmVudHMgcHJvY2Vzc2VkYCk7XG4gIH1cbiAgYXN5bmMgb25MaW5rTWVzc2FnZUV2ZW50KGUsIHQpIHtcbiAgICBjb25zdCB7IHRvcGljOiBpIH0gPSBlO1xuICAgIGlmICghdC5zZXNzaW9uRXhpc3RzKSB7XG4gICAgICBjb25zdCBuID0gbXQoaWUuRklWRV9NSU5VVEVTKSwgcyA9IHsgdG9waWM6IGksIGV4cGlyeTogbiwgcmVsYXk6IHsgcHJvdG9jb2w6IFwiaXJuXCIgfSwgYWN0aXZlOiAhMSB9O1xuICAgICAgYXdhaXQgdGhpcy5jb3JlLnBhaXJpbmcucGFpcmluZ3Muc2V0KGksIHMpO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50cy5lbWl0KEV0Lm1lc3NhZ2UsIGUpLCBhd2FpdCB0aGlzLnJlY29yZE1lc3NhZ2VFdmVudChlKTtcbiAgfVxuICBhc3luYyBjb25uZWN0KGUpIHtcbiAgICBhd2FpdCB0aGlzLmNvbmZpcm1PbmxpbmVTdGF0ZU9yVGhyb3coKSwgZSAmJiBlICE9PSB0aGlzLnJlbGF5VXJsICYmICh0aGlzLnJlbGF5VXJsID0gZSwgYXdhaXQgdGhpcy50cmFuc3BvcnREaXNjb25uZWN0KCkpLCB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0SW5Qcm9ncmVzcyA9ICEwLCB0aGlzLnRyYW5zcG9ydEV4cGxpY2l0bHlDbG9zZWQgPSAhMTtcbiAgICBsZXQgdCA9IDE7XG4gICAgZm9yICg7IHQgPCA2OyApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKHt9LCBgQ29ubmVjdGluZyB0byAke3RoaXMucmVsYXlVcmx9LCBhdHRlbXB0OiAke3R9Li4uYCksIGF3YWl0IHRoaXMuY3JlYXRlUHJvdmlkZXIoKSwgYXdhaXQgbmV3IFByb21pc2UoYXN5bmMgKGksIG4pID0+IHtcbiAgICAgICAgICBjb25zdCBzID0gKCkgPT4ge1xuICAgICAgICAgICAgbihuZXcgRXJyb3IoXCJDb25uZWN0aW9uIGludGVycnVwdGVkIHdoaWxlIHRyeWluZyB0byBzdWJzY3JpYmVcIikpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKGhyLmRpc2Nvbm5lY3QsIHMpLCBhd2FpdCBtaShuZXcgUHJvbWlzZSgobywgZikgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5jb25uZWN0KCkudGhlbihvKS5jYXRjaChmKTtcbiAgICAgICAgICB9KSwgdGhpcy5jb25uZWN0VGltZW91dCwgYFNvY2tldCBzdGFsbGVkIHdoZW4gdHJ5aW5nIHRvIGNvbm5lY3QgdG8gJHt0aGlzLnJlbGF5VXJsfWApLmNhdGNoKChvKSA9PiB7XG4gICAgICAgICAgICBuKG8pO1xuICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vZmYoaHIuZGlzY29ubmVjdCwgcyksIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpLCB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICAgICAgfSksIGF3YWl0IG5ldyBQcm9taXNlKGFzeW5jIChvLCBmKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoID0gKCkgPT4ge1xuICAgICAgICAgICAgICBmKG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gaW50ZXJydXB0ZWQgd2hpbGUgdHJ5aW5nIHRvIHN1YnNjcmliZVwiKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKGhyLmRpc2Nvbm5lY3QsIGgpLCBhd2FpdCB0aGlzLnN1YnNjcmliZXIuc3RhcnQoKS50aGVuKG8pLmNhdGNoKGYpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9mZihoci5kaXNjb25uZWN0LCBoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLCB0aGlzLmhhc0V4cGVyaWVuY2VkTmV0d29ya0Rpc3J1cHRpb24gPSAhMSwgaSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgY29uc3QgbiA9IGk7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oe30sIG4ubWVzc2FnZSksIHRoaXMuaGFzRXhwZXJpZW5jZWROZXR3b3JrRGlzcnVwdGlvbiA9ICEwO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uQXR0ZW1wdEluUHJvZ3Jlc3MgPSAhMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1Zyh7fSwgYENvbm5lY3RlZCB0byAke3RoaXMucmVsYXlVcmx9IHN1Y2Nlc3NmdWxseSBvbiBhdHRlbXB0OiAke3R9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKGkpID0+IHNldFRpbWVvdXQoaSwgaWUudG9NaWxpc2Vjb25kcyh0ICogMSkpKSwgdCsrO1xuICAgIH1cbiAgfVxuICBzdGFydFBpbmdUaW1lb3V0KCkge1xuICAgIHZhciBlLCB0LCBpLCBuLCBzO1xuICAgIGlmIChHcygpKVxuICAgICAgdHJ5IHtcbiAgICAgICAgKHQgPSAoZSA9IHRoaXMucHJvdmlkZXIpID09IG51bGwgPyB2b2lkIDAgOiBlLmNvbm5lY3Rpb24pICE9IG51bGwgJiYgdC5zb2NrZXQgJiYgKChzID0gKG4gPSAoaSA9IHRoaXMucHJvdmlkZXIpID09IG51bGwgPyB2b2lkIDAgOiBpLmNvbm5lY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBuLnNvY2tldCkgPT0gbnVsbCB8fCBzLm9uKFwicGluZ1wiLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgICAgIH0pKSwgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4obywgbz8ubWVzc2FnZSk7XG4gICAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlUHJvdmlkZXIoKSB7XG4gICAgdGhpcy5wcm92aWRlci5jb25uZWN0aW9uICYmIHRoaXMudW5yZWdpc3RlclByb3ZpZGVyTGlzdGVuZXJzKCk7XG4gICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uc2lnbkpXVCh0aGlzLnJlbGF5VXJsKTtcbiAgICB0aGlzLnByb3ZpZGVyID0gbmV3IHhkKG5ldyBhMyhpeSh7IHNka1ZlcnNpb246IERvLCBwcm90b2NvbDogdGhpcy5wcm90b2NvbCwgdmVyc2lvbjogdGhpcy52ZXJzaW9uLCByZWxheVVybDogdGhpcy5yZWxheVVybCwgcHJvamVjdElkOiB0aGlzLnByb2plY3RJZCwgYXV0aDogZSwgdXNlT25DbG9zZUV2ZW50OiAhMCwgYnVuZGxlSWQ6IHRoaXMuYnVuZGxlSWQsIHBhY2thZ2VOYW1lOiB0aGlzLnBhY2thZ2VOYW1lIH0pKSksIHRoaXMucmVnaXN0ZXJQcm92aWRlckxpc3RlbmVycygpO1xuICB9XG4gIGFzeW5jIHJlY29yZE1lc3NhZ2VFdmVudChlKSB7XG4gICAgY29uc3QgeyB0b3BpYzogdCwgbWVzc2FnZTogaSB9ID0gZTtcbiAgICBhd2FpdCB0aGlzLm1lc3NhZ2VzLnNldCh0LCBpKTtcbiAgfVxuICBhc3luYyBzaG91bGRJZ25vcmVNZXNzYWdlRXZlbnQoZSkge1xuICAgIGNvbnN0IHsgdG9waWM6IHQsIG1lc3NhZ2U6IGkgfSA9IGU7XG4gICAgaWYgKCFpIHx8IGkubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubG9nZ2VyLndhcm4oYElnbm9yaW5nIGludmFsaWQvZW1wdHkgbWVzc2FnZTogJHtpfWApLCAhMDtcbiAgICBpZiAoIWF3YWl0IHRoaXMuc3Vic2NyaWJlci5pc1N1YnNjcmliZWQodCkpXG4gICAgICByZXR1cm4gdGhpcy5sb2dnZXIud2FybihgSWdub3JpbmcgbWVzc2FnZSBmb3Igbm9uLXN1YnNjcmliZWQgdG9waWMgJHt0fWApLCAhMDtcbiAgICBjb25zdCBuID0gdGhpcy5tZXNzYWdlcy5oYXModCwgaSk7XG4gICAgcmV0dXJuIG4gJiYgdGhpcy5sb2dnZXIud2FybihgSWdub3JpbmcgZHVwbGljYXRlIG1lc3NhZ2U6ICR7aX1gKSwgbjtcbiAgfVxuICBhc3luYyBvblByb3ZpZGVyUGF5bG9hZChlKSB7XG4gICAgaWYgKHRoaXMubG9nZ2VyLmRlYnVnKFwiSW5jb21pbmcgUmVsYXkgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcInBheWxvYWRcIiwgZGlyZWN0aW9uOiBcImluY29taW5nXCIsIHBheWxvYWQ6IGUgfSksIGZmKGUpKSB7XG4gICAgICBpZiAoIWUubWV0aG9kLmVuZHNXaXRoKHczKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgdCA9IGUucGFyYW1zLCB7IHRvcGljOiBpLCBtZXNzYWdlOiBuLCBwdWJsaXNoZWRBdDogcywgYXR0ZXN0YXRpb246IG8gfSA9IHQuZGF0YSwgZiA9IHsgdG9waWM6IGksIG1lc3NhZ2U6IG4sIHB1Ymxpc2hlZEF0OiBzLCB0cmFuc3BvcnRUeXBlOiBhdC5yZWxheSwgYXR0ZXN0YXRpb246IG8gfTtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiRW1pdHRpbmcgUmVsYXllciBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci50cmFjZShnaCh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQuaWQgfSwgZikpLCB0aGlzLmV2ZW50cy5lbWl0KHQuaWQsIGYpLCBhd2FpdCB0aGlzLmFja25vd2xlZGdlUGF5bG9hZChlKSwgYXdhaXQgdGhpcy5vbk1lc3NhZ2VFdmVudChmKTtcbiAgICB9IGVsc2VcbiAgICAgIEFhKGUpICYmIHRoaXMuZXZlbnRzLmVtaXQoRXQubWVzc2FnZV9hY2ssIGUpO1xuICB9XG4gIGFzeW5jIG9uTWVzc2FnZUV2ZW50KGUpIHtcbiAgICBhd2FpdCB0aGlzLnNob3VsZElnbm9yZU1lc3NhZ2VFdmVudChlKSB8fCAodGhpcy5ldmVudHMuZW1pdChFdC5tZXNzYWdlLCBlKSwgYXdhaXQgdGhpcy5yZWNvcmRNZXNzYWdlRXZlbnQoZSkpO1xuICB9XG4gIGFzeW5jIGFja25vd2xlZGdlUGF5bG9hZChlKSB7XG4gICAgY29uc3QgdCA9IE1hKGUuaWQsICEwKTtcbiAgICBhd2FpdCB0aGlzLnByb3ZpZGVyLmNvbm5lY3Rpb24uc2VuZCh0KTtcbiAgfVxuICB1bnJlZ2lzdGVyUHJvdmlkZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5wcm92aWRlci5vZmYoaHIucGF5bG9hZCwgdGhpcy5vblBheWxvYWRIYW5kbGVyKSwgdGhpcy5wcm92aWRlci5vZmYoaHIuY29ubmVjdCwgdGhpcy5vbkNvbm5lY3RIYW5kbGVyKSwgdGhpcy5wcm92aWRlci5vZmYoaHIuZGlzY29ubmVjdCwgdGhpcy5vbkRpc2Nvbm5lY3RIYW5kbGVyKSwgdGhpcy5wcm92aWRlci5vZmYoaHIuZXJyb3IsIHRoaXMub25Qcm92aWRlckVycm9ySGFuZGxlciksIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0KTtcbiAgfVxuICBhc3luYyByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGxldCBlID0gYXdhaXQgV2MoKTtcbiAgICBMbShhc3luYyAodCkgPT4ge1xuICAgICAgZSAhPT0gdCAmJiAoZSA9IHQsIHQgPyBhd2FpdCB0aGlzLnRyYW5zcG9ydE9wZW4oKS5jYXRjaCgoaSkgPT4gdGhpcy5sb2dnZXIuZXJyb3IoaSwgaT8ubWVzc2FnZSkpIDogKHRoaXMuaGFzRXhwZXJpZW5jZWROZXR3b3JrRGlzcnVwdGlvbiA9ICEwLCBhd2FpdCB0aGlzLnRyYW5zcG9ydERpc2Nvbm5lY3QoKSwgdGhpcy50cmFuc3BvcnRFeHBsaWNpdGx5Q2xvc2VkID0gITEpKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBvblByb3ZpZGVyRGlzY29ubmVjdCgpIHtcbiAgICBhd2FpdCB0aGlzLnN1YnNjcmliZXIuc3RvcCgpLCBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dCksIHRoaXMuZXZlbnRzLmVtaXQoRXQuZGlzY29ubmVjdCksIHRoaXMuY29ubmVjdGlvbkF0dGVtcHRJblByb2dyZXNzID0gITEsICF0aGlzLnRyYW5zcG9ydEV4cGxpY2l0bHlDbG9zZWQgJiYgKHRoaXMucmVjb25uZWN0VGltZW91dCB8fCB0aGlzLmNvbm5lY3RQcm9taXNlIHx8ICh0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpLCBhd2FpdCB0aGlzLnRyYW5zcG9ydE9wZW4oKS5jYXRjaCgoZSkgPT4gdGhpcy5sb2dnZXIuZXJyb3IoZSwgZT8ubWVzc2FnZSkpO1xuICAgIH0sIGllLnRvTWlsaXNlY29uZHMoXzMpKSkpO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IGFlKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHRvRXN0YWJsaXNoQ29ubmVjdGlvbigpIHtcbiAgICBhd2FpdCB0aGlzLmNvbmZpcm1PbmxpbmVTdGF0ZU9yVGhyb3coKSwgIXRoaXMuY29ubmVjdGVkICYmIGF3YWl0IHRoaXMudHJhbnNwb3J0T3BlbigpO1xuICB9XG59XG52YXIgVHcgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIHloID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgQ3cgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCAkdyA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIG1oID0gKHIsIGUsIHQpID0+IGUgaW4gciA/IFR3KHIsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiByW2VdID0gdCwgd2ggPSAociwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgQ3cuY2FsbChlLCB0KSAmJiBtaChyLCB0LCBlW3RdKTtcbiAgaWYgKHloKVxuICAgIGZvciAodmFyIHQgb2YgeWgoZSkpXG4gICAgICAkdy5jYWxsKGUsIHQpICYmIG1oKHIsIHQsIGVbdF0pO1xuICByZXR1cm4gcjtcbn07XG5jbGFzcyBRaSBleHRlbmRzIGZwIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgaSwgbiA9IGpyLCBzID0gdm9pZCAwKSB7XG4gICAgc3VwZXIoZSwgdCwgaSwgbiksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5uYW1lID0gaSwgdGhpcy5tYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLnZlcnNpb24gPSB4MywgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSBqciwgdGhpcy5yZWNlbnRseURlbGV0ZWQgPSBbXSwgdGhpcy5yZWNlbnRseURlbGV0ZWRMaW1pdCA9IDIwMCwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCAodGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKSwgYXdhaXQgdGhpcy5yZXN0b3JlKCksIHRoaXMuY2FjaGVkLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgdGhpcy5nZXRLZXkgJiYgbyAhPT0gbnVsbCAmJiAhenQobykgPyB0aGlzLm1hcC5zZXQodGhpcy5nZXRLZXkobyksIG8pIDogbG0obykgPyB0aGlzLm1hcC5zZXQoby5pZCwgbykgOiBwbShvKSAmJiB0aGlzLm1hcC5zZXQoby50b3BpYywgbyk7XG4gICAgICB9KSwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5pbml0aWFsaXplZCA9ICEwKTtcbiAgICB9LCB0aGlzLnNldCA9IGFzeW5jIChvLCBmKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5tYXAuaGFzKG8pID8gYXdhaXQgdGhpcy51cGRhdGUobywgZikgOiAodGhpcy5sb2dnZXIuZGVidWcoXCJTZXR0aW5nIHZhbHVlXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJzZXRcIiwga2V5OiBvLCB2YWx1ZTogZiB9KSwgdGhpcy5tYXAuc2V0KG8sIGYpLCBhd2FpdCB0aGlzLnBlcnNpc3QoKSk7XG4gICAgfSwgdGhpcy5nZXQgPSAobykgPT4gKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkdldHRpbmcgdmFsdWVcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcImdldFwiLCBrZXk6IG8gfSksIHRoaXMuZ2V0RGF0YShvKSksIHRoaXMuZ2V0QWxsID0gKG8pID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgbyA/IHRoaXMudmFsdWVzLmZpbHRlcigoZikgPT4gT2JqZWN0LmtleXMobykuZXZlcnkoKGgpID0+IGYzKGZbaF0sIG9baF0pKSkgOiB0aGlzLnZhbHVlcyksIHRoaXMudXBkYXRlID0gYXN5bmMgKG8sIGYpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlVwZGF0aW5nIHZhbHVlXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJ1cGRhdGVcIiwga2V5OiBvLCB1cGRhdGU6IGYgfSk7XG4gICAgICBjb25zdCBoID0gd2god2goe30sIHRoaXMuZ2V0RGF0YShvKSksIGYpO1xuICAgICAgdGhpcy5tYXAuc2V0KG8sIGgpLCBhd2FpdCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9LCB0aGlzLmRlbGV0ZSA9IGFzeW5jIChvLCBmKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5tYXAuaGFzKG8pICYmICh0aGlzLmxvZ2dlci5kZWJ1ZyhcIkRlbGV0aW5nIHZhbHVlXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJkZWxldGVcIiwga2V5OiBvLCByZWFzb246IGYgfSksIHRoaXMubWFwLmRlbGV0ZShvKSwgdGhpcy5hZGRUb1JlY2VudGx5RGVsZXRlZChvKSwgYXdhaXQgdGhpcy5wZXJzaXN0KCkpO1xuICAgIH0sIHRoaXMubG9nZ2VyID0ga3QodCwgdGhpcy5uYW1lKSwgdGhpcy5zdG9yYWdlUHJlZml4ID0gbiwgdGhpcy5nZXRLZXkgPSBzO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBadCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IHN0b3JhZ2VLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByZWZpeCArIHRoaXMudmVyc2lvbiArIHRoaXMuY29yZS5jdXN0b21TdG9yYWdlUHJlZml4ICsgXCIvL1wiICsgdGhpcy5uYW1lO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLnNpemU7XG4gIH1cbiAgZ2V0IGtleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tYXAua2V5cygpKTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubWFwLnZhbHVlcygpKTtcbiAgfVxuICBhZGRUb1JlY2VudGx5RGVsZXRlZChlKSB7XG4gICAgdGhpcy5yZWNlbnRseURlbGV0ZWQucHVzaChlKSwgdGhpcy5yZWNlbnRseURlbGV0ZWQubGVuZ3RoID49IHRoaXMucmVjZW50bHlEZWxldGVkTGltaXQgJiYgdGhpcy5yZWNlbnRseURlbGV0ZWQuc3BsaWNlKDAsIHRoaXMucmVjZW50bHlEZWxldGVkTGltaXQgLyAyKTtcbiAgfVxuICBhc3luYyBzZXREYXRhU3RvcmUoZSkge1xuICAgIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBlKTtcbiAgfVxuICBhc3luYyBnZXREYXRhU3RvcmUoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgfVxuICBnZXREYXRhKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5tYXAuZ2V0KGUpO1xuICAgIGlmICghdCkge1xuICAgICAgaWYgKHRoaXMucmVjZW50bHlEZWxldGVkLmluY2x1ZGVzKGUpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbiB9ID0gYWUoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYFJlY29yZCB3YXMgcmVjZW50bHkgZGVsZXRlZCAtICR7dGhpcy5uYW1lfTogJHtlfWApO1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihuKSwgbmV3IEVycm9yKG4pO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBtZXNzYWdlOiBpIH0gPSBhZShcIk5PX01BVENISU5HX0tFWVwiLCBgJHt0aGlzLm5hbWV9OiAke2V9YCk7XG4gICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihpKSwgbmV3IEVycm9yKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBhc3luYyBwZXJzaXN0KCkge1xuICAgIGF3YWl0IHRoaXMuc2V0RGF0YVN0b3JlKHRoaXMudmFsdWVzKTtcbiAgfVxuICBhc3luYyByZXN0b3JlKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5nZXREYXRhU3RvcmUoKTtcbiAgICAgIGlmICh0eXBlb2YgZSA+IFwidVwiIHx8ICFlLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMubWFwLnNpemUpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBhZShcIlJFU1RPUkVfV0lMTF9PVkVSUklERVwiLCB0aGlzLm5hbWUpO1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcih0KSwgbmV3IEVycm9yKHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZWQgPSBlLCB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IFJlc3RvcmVkIHZhbHVlIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicmVzdG9yZVwiLCB2YWx1ZTogdGhpcy52YWx1ZXMgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBSZXN0b3JlIHZhbHVlIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IGFlKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBMdyB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMubmFtZSA9IEEzLCB0aGlzLnZlcnNpb24gPSBEMywgdGhpcy5ldmVudHMgPSBuZXcgemgoKSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSBqciwgdGhpcy5pZ25vcmVkUGF5bG9hZFR5cGVzID0gW2hpXSwgdGhpcy5yZWdpc3RlcmVkTWV0aG9kcyA9IFtdLCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkIHx8IChhd2FpdCB0aGlzLnBhaXJpbmdzLmluaXQoKSwgYXdhaXQgdGhpcy5jbGVhbnVwKCksIHRoaXMucmVnaXN0ZXJSZWxheWVyRXZlbnRzKCksIHRoaXMucmVnaXN0ZXJFeHBpcmVyRXZlbnRzKCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCwgdGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKSk7XG4gICAgfSwgdGhpcy5yZWdpc3RlciA9ICh7IG1ldGhvZHM6IGkgfSkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMucmVnaXN0ZXJlZE1ldGhvZHMgPSBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnRoaXMucmVnaXN0ZXJlZE1ldGhvZHMsIC4uLmldKV07XG4gICAgfSwgdGhpcy5jcmVhdGUgPSBhc3luYyAoaSkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBuID0gQW8oKSwgcyA9IGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uc2V0U3ltS2V5KG4pLCBvID0gbXQoaWUuRklWRV9NSU5VVEVTKSwgZiA9IHsgcHJvdG9jb2w6IE1kIH0sIGggPSB7IHRvcGljOiBzLCBleHBpcnk6IG8sIHJlbGF5OiBmLCBhY3RpdmU6ICExLCBtZXRob2RzOiBpPy5tZXRob2RzIH0sIGQgPSBCYyh7IHByb3RvY29sOiB0aGlzLmNvcmUucHJvdG9jb2wsIHZlcnNpb246IHRoaXMuY29yZS52ZXJzaW9uLCB0b3BpYzogcywgc3ltS2V5OiBuLCByZWxheTogZiwgZXhwaXJ5VGltZXN0YW1wOiBvLCBtZXRob2RzOiBpPy5tZXRob2RzIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzLmVtaXQocWkuY3JlYXRlLCBoKSwgdGhpcy5jb3JlLmV4cGlyZXIuc2V0KHMsIG8pLCBhd2FpdCB0aGlzLnBhaXJpbmdzLnNldChzLCBoKSwgYXdhaXQgdGhpcy5jb3JlLnJlbGF5ZXIuc3Vic2NyaWJlKHMsIHsgdHJhbnNwb3J0VHlwZTogaT8udHJhbnNwb3J0VHlwZSB9KSwgeyB0b3BpYzogcywgdXJpOiBkIH07XG4gICAgfSwgdGhpcy5wYWlyID0gYXN5bmMgKGkpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgbiA9IHRoaXMuY29yZS5ldmVudENsaWVudC5jcmVhdGVFdmVudCh7IHByb3BlcnRpZXM6IHsgdG9waWM6IGk/LnVyaSwgdHJhY2U6IFtPci5wYWlyaW5nX3N0YXJ0ZWRdIH0gfSk7XG4gICAgICB0aGlzLmlzVmFsaWRQYWlyKGksIG4pO1xuICAgICAgY29uc3QgeyB0b3BpYzogcywgc3ltS2V5OiBvLCByZWxheTogZiwgZXhwaXJ5VGltZXN0YW1wOiBoLCBtZXRob2RzOiBkIH0gPSB6YyhpLnVyaSk7XG4gICAgICBuLnByb3BzLnByb3BlcnRpZXMudG9waWMgPSBzLCBuLmFkZFRyYWNlKE9yLnBhaXJpbmdfdXJpX3ZhbGlkYXRpb25fc3VjY2VzcyksIG4uYWRkVHJhY2UoT3IucGFpcmluZ191cmlfbm90X2V4cGlyZWQpO1xuICAgICAgbGV0IHY7XG4gICAgICBpZiAodGhpcy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHMpKSB7XG4gICAgICAgIGlmICh2ID0gdGhpcy5wYWlyaW5ncy5nZXQocyksIG4uYWRkVHJhY2UoT3IuZXhpc3RpbmdfcGFpcmluZyksIHYuYWN0aXZlKVxuICAgICAgICAgIHRocm93IG4uc2V0RXJyb3IoYWkuYWN0aXZlX3BhaXJpbmdfYWxyZWFkeV9leGlzdHMpLCBuZXcgRXJyb3IoYFBhaXJpbmcgYWxyZWFkeSBleGlzdHM6ICR7c30uIFBsZWFzZSB0cnkgYWdhaW4gd2l0aCBhIG5ldyBjb25uZWN0aW9uIFVSSS5gKTtcbiAgICAgICAgbi5hZGRUcmFjZShPci5wYWlyaW5nX25vdF9leHBpcmVkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHcgPSBoIHx8IG10KGllLkZJVkVfTUlOVVRFUyksIEEgPSB7IHRvcGljOiBzLCByZWxheTogZiwgZXhwaXJ5OiB3LCBhY3RpdmU6ICExLCBtZXRob2RzOiBkIH07XG4gICAgICB0aGlzLmNvcmUuZXhwaXJlci5zZXQocywgdyksIGF3YWl0IHRoaXMucGFpcmluZ3Muc2V0KHMsIEEpLCBuLmFkZFRyYWNlKE9yLnN0b3JlX25ld19wYWlyaW5nKSwgaS5hY3RpdmF0ZVBhaXJpbmcgJiYgYXdhaXQgdGhpcy5hY3RpdmF0ZSh7IHRvcGljOiBzIH0pLCB0aGlzLmV2ZW50cy5lbWl0KHFpLmNyZWF0ZSwgQSksIG4uYWRkVHJhY2UoT3IuZW1pdF9pbmFjdGl2ZV9wYWlyaW5nKSwgdGhpcy5jb3JlLmNyeXB0by5rZXljaGFpbi5oYXMocykgfHwgYXdhaXQgdGhpcy5jb3JlLmNyeXB0by5zZXRTeW1LZXkobywgcyksIG4uYWRkVHJhY2UoT3Iuc3Vic2NyaWJpbmdfcGFpcmluZ190b3BpYyk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmNvcmUucmVsYXllci5jb25maXJtT25saW5lU3RhdGVPclRocm93KCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgbi5zZXRFcnJvcihhaS5ub19pbnRlcm5ldF9jb25uZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY29yZS5yZWxheWVyLnN1YnNjcmliZShzLCB7IHJlbGF5OiBmIH0pO1xuICAgICAgfSBjYXRjaCAoSSkge1xuICAgICAgICB0aHJvdyBuLnNldEVycm9yKGFpLnN1YnNjcmliZV9wYWlyaW5nX3RvcGljX2ZhaWx1cmUpLCBJO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG4uYWRkVHJhY2UoT3Iuc3Vic2NyaWJlX3BhaXJpbmdfdG9waWNfc3VjY2VzcyksIEE7XG4gICAgfSwgdGhpcy5hY3RpdmF0ZSA9IGFzeW5jICh7IHRvcGljOiBpIH0pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgbiA9IG10KGllLlRISVJUWV9EQVlTKTtcbiAgICAgIHRoaXMuY29yZS5leHBpcmVyLnNldChpLCBuKSwgYXdhaXQgdGhpcy5wYWlyaW5ncy51cGRhdGUoaSwgeyBhY3RpdmU6ICEwLCBleHBpcnk6IG4gfSk7XG4gICAgfSwgdGhpcy5waW5nID0gYXN5bmMgKGkpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRQaW5nKGkpO1xuICAgICAgY29uc3QgeyB0b3BpYzogbiB9ID0gaTtcbiAgICAgIGlmICh0aGlzLnBhaXJpbmdzLmtleXMuaW5jbHVkZXMobikpIHtcbiAgICAgICAgY29uc3QgcyA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QobiwgXCJ3Y19wYWlyaW5nUGluZ1wiLCB7fSksIHsgZG9uZTogbywgcmVzb2x2ZTogZiwgcmVqZWN0OiBoIH0gPSBMaSgpO1xuICAgICAgICB0aGlzLmV2ZW50cy5vbmNlKFhlKFwicGFpcmluZ19waW5nXCIsIHMpLCAoeyBlcnJvcjogZCB9KSA9PiB7XG4gICAgICAgICAgZCA/IGgoZCkgOiBmKCk7XG4gICAgICAgIH0pLCBhd2FpdCBvKCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy51cGRhdGVFeHBpcnkgPSBhc3luYyAoeyB0b3BpYzogaSwgZXhwaXJ5OiBuIH0pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLnBhaXJpbmdzLnVwZGF0ZShpLCB7IGV4cGlyeTogbiB9KTtcbiAgICB9LCB0aGlzLnVwZGF0ZU1ldGFkYXRhID0gYXN5bmMgKHsgdG9waWM6IGksIG1ldGFkYXRhOiBuIH0pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLnBhaXJpbmdzLnVwZGF0ZShpLCB7IHBlZXJNZXRhZGF0YTogbiB9KTtcbiAgICB9LCB0aGlzLmdldFBhaXJpbmdzID0gKCkgPT4gKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLnBhaXJpbmdzLnZhbHVlcyksIHRoaXMuZGlzY29ubmVjdCA9IGFzeW5jIChpKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkRGlzY29ubmVjdChpKTtcbiAgICAgIGNvbnN0IHsgdG9waWM6IG4gfSA9IGk7XG4gICAgICB0aGlzLnBhaXJpbmdzLmtleXMuaW5jbHVkZXMobikgJiYgKGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QobiwgXCJ3Y19wYWlyaW5nRGVsZXRlXCIsIHN0KFwiVVNFUl9ESVNDT05ORUNURURcIikpLCBhd2FpdCB0aGlzLmRlbGV0ZVBhaXJpbmcobikpO1xuICAgIH0sIHRoaXMuZm9ybWF0VXJpRnJvbVBhaXJpbmcgPSAoaSkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCB7IHRvcGljOiBuLCByZWxheTogcywgZXhwaXJ5OiBvLCBtZXRob2RzOiBmIH0gPSBpLCBoID0gdGhpcy5jb3JlLmNyeXB0by5rZXljaGFpbi5nZXQobik7XG4gICAgICByZXR1cm4gQmMoeyBwcm90b2NvbDogdGhpcy5jb3JlLnByb3RvY29sLCB2ZXJzaW9uOiB0aGlzLmNvcmUudmVyc2lvbiwgdG9waWM6IG4sIHN5bUtleTogaCwgcmVsYXk6IHMsIGV4cGlyeVRpbWVzdGFtcDogbywgbWV0aG9kczogZiB9KTtcbiAgICB9LCB0aGlzLnNlbmRSZXF1ZXN0ID0gYXN5bmMgKGksIG4sIHMpID0+IHtcbiAgICAgIGNvbnN0IG8gPSBCaShuLCBzKSwgZiA9IGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uZW5jb2RlKGksIG8pLCBoID0gcW5bbl0ucmVxO1xuICAgICAgcmV0dXJuIHRoaXMuY29yZS5oaXN0b3J5LnNldChpLCBvKSwgdGhpcy5jb3JlLnJlbGF5ZXIucHVibGlzaChpLCBmLCBoKSwgby5pZDtcbiAgICB9LCB0aGlzLnNlbmRSZXN1bHQgPSBhc3luYyAoaSwgbiwgcykgPT4ge1xuICAgICAgY29uc3QgbyA9IE1hKGksIHMpLCBmID0gYXdhaXQgdGhpcy5jb3JlLmNyeXB0by5lbmNvZGUobiwgbyksIGggPSBhd2FpdCB0aGlzLmNvcmUuaGlzdG9yeS5nZXQobiwgaSksIGQgPSBxbltoLnJlcXVlc3QubWV0aG9kXS5yZXM7XG4gICAgICBhd2FpdCB0aGlzLmNvcmUucmVsYXllci5wdWJsaXNoKG4sIGYsIGQpLCBhd2FpdCB0aGlzLmNvcmUuaGlzdG9yeS5yZXNvbHZlKG8pO1xuICAgIH0sIHRoaXMuc2VuZEVycm9yID0gYXN5bmMgKGksIG4sIHMpID0+IHtcbiAgICAgIGNvbnN0IG8gPSBJYShpLCBzKSwgZiA9IGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uZW5jb2RlKG4sIG8pLCBoID0gYXdhaXQgdGhpcy5jb3JlLmhpc3RvcnkuZ2V0KG4sIGkpLCBkID0gcW5baC5yZXF1ZXN0Lm1ldGhvZF0gPyBxbltoLnJlcXVlc3QubWV0aG9kXS5yZXMgOiBxbi51bnJlZ2lzdGVyZWRfbWV0aG9kLnJlcztcbiAgICAgIGF3YWl0IHRoaXMuY29yZS5yZWxheWVyLnB1Ymxpc2gobiwgZiwgZCksIGF3YWl0IHRoaXMuY29yZS5oaXN0b3J5LnJlc29sdmUobyk7XG4gICAgfSwgdGhpcy5kZWxldGVQYWlyaW5nID0gYXN5bmMgKGksIG4pID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuY29yZS5yZWxheWVyLnVuc3Vic2NyaWJlKGkpLCBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5wYWlyaW5ncy5kZWxldGUoaSwgc3QoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSksIHRoaXMuY29yZS5jcnlwdG8uZGVsZXRlU3ltS2V5KGkpLCBuID8gUHJvbWlzZS5yZXNvbHZlKCkgOiB0aGlzLmNvcmUuZXhwaXJlci5kZWwoaSldKTtcbiAgICB9LCB0aGlzLmNsZWFudXAgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpID0gdGhpcy5wYWlyaW5ncy5nZXRBbGwoKS5maWx0ZXIoKG4pID0+IGdpKG4uZXhwaXJ5KSk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChpLm1hcCgobikgPT4gdGhpcy5kZWxldGVQYWlyaW5nKG4udG9waWMpKSk7XG4gICAgfSwgdGhpcy5vblJlbGF5RXZlbnRSZXF1ZXN0ID0gKGkpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IG4sIHBheWxvYWQ6IHMgfSA9IGk7XG4gICAgICBzd2l0Y2ggKHMubWV0aG9kKSB7XG4gICAgICAgIGNhc2UgXCJ3Y19wYWlyaW5nUGluZ1wiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uUGFpcmluZ1BpbmdSZXF1ZXN0KG4sIHMpO1xuICAgICAgICBjYXNlIFwid2NfcGFpcmluZ0RlbGV0ZVwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uUGFpcmluZ0RlbGV0ZVJlcXVlc3Qobiwgcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25Vbmtub3duUnBjTWV0aG9kUmVxdWVzdChuLCBzKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uUmVsYXlFdmVudFJlc3BvbnNlID0gYXN5bmMgKGkpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IG4sIHBheWxvYWQ6IHMgfSA9IGksIG8gPSAoYXdhaXQgdGhpcy5jb3JlLmhpc3RvcnkuZ2V0KG4sIHMuaWQpKS5yZXF1ZXN0Lm1ldGhvZDtcbiAgICAgIHN3aXRjaCAobykge1xuICAgICAgICBjYXNlIFwid2NfcGFpcmluZ1BpbmdcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblBhaXJpbmdQaW5nUmVzcG9uc2Uobiwgcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25Vbmtub3duUnBjTWV0aG9kUmVzcG9uc2Uobyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblBhaXJpbmdQaW5nUmVxdWVzdCA9IGFzeW5jIChpLCBuKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiBzIH0gPSBuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pc1ZhbGlkUGluZyh7IHRvcGljOiBpIH0pLCBhd2FpdCB0aGlzLnNlbmRSZXN1bHQocywgaSwgITApLCB0aGlzLmV2ZW50cy5lbWl0KHFpLnBpbmcsIHsgaWQ6IHMsIHRvcGljOiBpIH0pO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihzLCBpLCBvKSwgdGhpcy5sb2dnZXIuZXJyb3Iobyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblBhaXJpbmdQaW5nUmVzcG9uc2UgPSAoaSwgbikgPT4ge1xuICAgICAgY29uc3QgeyBpZDogcyB9ID0gbjtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBScihuKSA/IHRoaXMuZXZlbnRzLmVtaXQoWGUoXCJwYWlyaW5nX3BpbmdcIiwgcyksIHt9KSA6IGRyKG4pICYmIHRoaXMuZXZlbnRzLmVtaXQoWGUoXCJwYWlyaW5nX3BpbmdcIiwgcyksIHsgZXJyb3I6IG4uZXJyb3IgfSk7XG4gICAgICB9LCA1MDApO1xuICAgIH0sIHRoaXMub25QYWlyaW5nRGVsZXRlUmVxdWVzdCA9IGFzeW5jIChpLCBuKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiBzIH0gPSBuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pc1ZhbGlkRGlzY29ubmVjdCh7IHRvcGljOiBpIH0pLCBhd2FpdCB0aGlzLmRlbGV0ZVBhaXJpbmcoaSksIHRoaXMuZXZlbnRzLmVtaXQocWkuZGVsZXRlLCB7IGlkOiBzLCB0b3BpYzogaSB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IocywgaSwgbyksIHRoaXMubG9nZ2VyLmVycm9yKG8pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25Vbmtub3duUnBjTWV0aG9kUmVxdWVzdCA9IGFzeW5jIChpLCBuKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiBzLCBtZXRob2Q6IG8gfSA9IG47XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5yZWdpc3RlcmVkTWV0aG9kcy5pbmNsdWRlcyhvKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGYgPSBzdChcIldDX01FVEhPRF9VTlNVUFBPUlRFRFwiLCBvKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IocywgaSwgZiksIHRoaXMubG9nZ2VyLmVycm9yKGYpO1xuICAgICAgfSBjYXRjaCAoZikge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihzLCBpLCBmKSwgdGhpcy5sb2dnZXIuZXJyb3IoZik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblVua25vd25ScGNNZXRob2RSZXNwb25zZSA9IChpKSA9PiB7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRNZXRob2RzLmluY2x1ZGVzKGkpIHx8IHRoaXMubG9nZ2VyLmVycm9yKHN0KFwiV0NfTUVUSE9EX1VOU1VQUE9SVEVEXCIsIGkpKTtcbiAgICB9LCB0aGlzLmlzVmFsaWRQYWlyID0gKGksIG4pID0+IHtcbiAgICAgIHZhciBzO1xuICAgICAgaWYgKCFHdChpKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGYgfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBwYWlyKCkgcGFyYW1zOiAke2l9YCk7XG4gICAgICAgIHRocm93IG4uc2V0RXJyb3IoYWkubWFsZm9ybWVkX3BhaXJpbmdfdXJpKSwgbmV3IEVycm9yKGYpO1xuICAgICAgfVxuICAgICAgaWYgKCFkbShpLnVyaSkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBmIH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcGFpcigpIHVyaTogJHtpLnVyaX1gKTtcbiAgICAgICAgdGhyb3cgbi5zZXRFcnJvcihhaS5tYWxmb3JtZWRfcGFpcmluZ191cmkpLCBuZXcgRXJyb3IoZik7XG4gICAgICB9XG4gICAgICBjb25zdCBvID0gemMoaT8udXJpKTtcbiAgICAgIGlmICghKChzID0gbz8ucmVsYXkpICE9IG51bGwgJiYgcy5wcm90b2NvbCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBmIH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBcInBhaXIoKSB1cmkjcmVsYXktcHJvdG9jb2xcIik7XG4gICAgICAgIHRocm93IG4uc2V0RXJyb3IoYWkubWFsZm9ybWVkX3BhaXJpbmdfdXJpKSwgbmV3IEVycm9yKGYpO1xuICAgICAgfVxuICAgICAgaWYgKCEobyAhPSBudWxsICYmIG8uc3ltS2V5KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGYgfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIFwicGFpcigpIHVyaSNzeW1LZXlcIik7XG4gICAgICAgIHRocm93IG4uc2V0RXJyb3IoYWkubWFsZm9ybWVkX3BhaXJpbmdfdXJpKSwgbmV3IEVycm9yKGYpO1xuICAgICAgfVxuICAgICAgaWYgKG8gIT0gbnVsbCAmJiBvLmV4cGlyeVRpbWVzdGFtcCAmJiBpZS50b01pbGlzZWNvbmRzKG8/LmV4cGlyeVRpbWVzdGFtcCkgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgIG4uc2V0RXJyb3IoYWkucGFpcmluZ19leHBpcmVkKTtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBmIH0gPSBhZShcIkVYUElSRURcIiwgXCJwYWlyKCkgVVJJIGhhcyBleHBpcmVkLiBQbGVhc2UgdHJ5IGFnYWluIHdpdGggYSBuZXcgY29ubmVjdGlvbiBVUkkuXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc1ZhbGlkUGluZyA9IGFzeW5jIChpKSA9PiB7XG4gICAgICBpZiAoIUd0KGkpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogcyB9ID0gYWUoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHBpbmcoKSBwYXJhbXM6ICR7aX1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHMpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogbiB9ID0gaTtcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFBhaXJpbmdUb3BpYyhuKTtcbiAgICB9LCB0aGlzLmlzVmFsaWREaXNjb25uZWN0ID0gYXN5bmMgKGkpID0+IHtcbiAgICAgIGlmICghR3QoaSkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBzIH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZGlzY29ubmVjdCgpIHBhcmFtczogJHtpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocyk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBuIH0gPSBpO1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkUGFpcmluZ1RvcGljKG4pO1xuICAgIH0sIHRoaXMuaXNWYWxpZFBhaXJpbmdUb3BpYyA9IGFzeW5jIChpKSA9PiB7XG4gICAgICBpZiAoIWJ0KGksICExKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBwYWlyaW5nIHRvcGljIHNob3VsZCBiZSBhIHN0cmluZzogJHtpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyhpKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IGFlKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGBwYWlyaW5nIHRvcGljIGRvZXNuJ3QgZXhpc3Q6ICR7aX1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG4pO1xuICAgICAgfVxuICAgICAgaWYgKGdpKHRoaXMucGFpcmluZ3MuZ2V0KGkpLmV4cGlyeSkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWxldGVQYWlyaW5nKGkpO1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IGFlKFwiRVhQSVJFRFwiLCBgcGFpcmluZyB0b3BpYzogJHtpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSBrdCh0LCB0aGlzLm5hbWUpLCB0aGlzLnBhaXJpbmdzID0gbmV3IFFpKHRoaXMuY29yZSwgdGhpcy5sb2dnZXIsIHRoaXMubmFtZSwgdGhpcy5zdG9yYWdlUHJlZml4KTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gWnQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IGFlKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyUmVsYXllckV2ZW50cygpIHtcbiAgICB0aGlzLmNvcmUucmVsYXllci5vbihFdC5tZXNzYWdlLCBhc3luYyAoZSkgPT4ge1xuICAgICAgY29uc3QgeyB0b3BpYzogdCwgbWVzc2FnZTogaSwgdHJhbnNwb3J0VHlwZTogbiB9ID0gZTtcbiAgICAgIGlmICghdGhpcy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHQpIHx8IG4gPT09IGF0LmxpbmtfbW9kZSB8fCB0aGlzLmlnbm9yZWRQYXlsb2FkVHlwZXMuaW5jbHVkZXModGhpcy5jb3JlLmNyeXB0by5nZXRQYXlsb2FkVHlwZShpKSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHMgPSBhd2FpdCB0aGlzLmNvcmUuY3J5cHRvLmRlY29kZSh0LCBpKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZmKHMpID8gKHRoaXMuY29yZS5oaXN0b3J5LnNldCh0LCBzKSwgdGhpcy5vblJlbGF5RXZlbnRSZXF1ZXN0KHsgdG9waWM6IHQsIHBheWxvYWQ6IHMgfSkpIDogQWEocykgJiYgKGF3YWl0IHRoaXMuY29yZS5oaXN0b3J5LnJlc29sdmUocyksIGF3YWl0IHRoaXMub25SZWxheUV2ZW50UmVzcG9uc2UoeyB0b3BpYzogdCwgcGF5bG9hZDogcyB9KSwgdGhpcy5jb3JlLmhpc3RvcnkuZGVsZXRlKHQsIHMuaWQpKTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3Iobyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJFeHBpcmVyRXZlbnRzKCkge1xuICAgIHRoaXMuY29yZS5leHBpcmVyLm9uKHVyLmV4cGlyZWQsIGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiB0IH0gPSBhZChlLnRhcmdldCk7XG4gICAgICB0ICYmIHRoaXMucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyh0KSAmJiAoYXdhaXQgdGhpcy5kZWxldGVQYWlyaW5nKHQsICEwKSwgdGhpcy5ldmVudHMuZW1pdChxaS5leHBpcmUsIHsgdG9waWM6IHQgfSkpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBGdyBleHRlbmRzIG5wIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMucmVjb3JkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuZXZlbnRzID0gbmV3IGlyLkV2ZW50RW1pdHRlcigpLCB0aGlzLm5hbWUgPSBQMywgdGhpcy52ZXJzaW9uID0gTzMsIHRoaXMuY2FjaGVkID0gW10sIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5zdG9yYWdlUHJlZml4ID0ganIsIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgKHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIiksIGF3YWl0IHRoaXMucmVzdG9yZSgpLCB0aGlzLmNhY2hlZC5mb3JFYWNoKChpKSA9PiB0aGlzLnJlY29yZHMuc2V0KGkuaWQsIGkpKSwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCk7XG4gICAgfSwgdGhpcy5zZXQgPSAoaSwgbiwgcykgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlNldHRpbmcgSlNPTi1SUEMgcmVxdWVzdCBoaXN0b3J5IHJlY29yZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwic2V0XCIsIHRvcGljOiBpLCByZXF1ZXN0OiBuLCBjaGFpbklkOiBzIH0pLCB0aGlzLnJlY29yZHMuaGFzKG4uaWQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0geyBpZDogbi5pZCwgdG9waWM6IGksIHJlcXVlc3Q6IHsgbWV0aG9kOiBuLm1ldGhvZCwgcGFyYW1zOiBuLnBhcmFtcyB8fCBudWxsIH0sIGNoYWluSWQ6IHMsIGV4cGlyeTogbXQoaWUuVEhJUlRZX0RBWVMpIH07XG4gICAgICB0aGlzLnJlY29yZHMuc2V0KG8uaWQsIG8pLCB0aGlzLnBlcnNpc3QoKSwgdGhpcy5ldmVudHMuZW1pdChfci5jcmVhdGVkLCBvKTtcbiAgICB9LCB0aGlzLnJlc29sdmUgPSBhc3luYyAoaSkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlVwZGF0aW5nIEpTT04tUlBDIHJlc3BvbnNlIGhpc3RvcnkgcmVjb3JkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJ1cGRhdGVcIiwgcmVzcG9uc2U6IGkgfSksICF0aGlzLnJlY29yZHMuaGFzKGkuaWQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBuID0gYXdhaXQgdGhpcy5nZXRSZWNvcmQoaS5pZCk7XG4gICAgICB0eXBlb2Ygbi5yZXNwb25zZSA+IFwidVwiICYmIChuLnJlc3BvbnNlID0gZHIoaSkgPyB7IGVycm9yOiBpLmVycm9yIH0gOiB7IHJlc3VsdDogaS5yZXN1bHQgfSwgdGhpcy5yZWNvcmRzLnNldChuLmlkLCBuKSwgdGhpcy5wZXJzaXN0KCksIHRoaXMuZXZlbnRzLmVtaXQoX3IudXBkYXRlZCwgbikpO1xuICAgIH0sIHRoaXMuZ2V0ID0gYXN5bmMgKGksIG4pID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJHZXR0aW5nIHJlY29yZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwiZ2V0XCIsIHRvcGljOiBpLCBpZDogbiB9KSwgYXdhaXQgdGhpcy5nZXRSZWNvcmQobikpLCB0aGlzLmRlbGV0ZSA9IChpLCBuKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJEZWxldGluZyByZWNvcmRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcImRlbGV0ZVwiLCBpZDogbiB9KSwgdGhpcy52YWx1ZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICBpZiAocy50b3BpYyA9PT0gaSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbiA8IFwidVwiICYmIHMuaWQgIT09IG4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgdGhpcy5yZWNvcmRzLmRlbGV0ZShzLmlkKSwgdGhpcy5ldmVudHMuZW1pdChfci5kZWxldGVkLCBzKTtcbiAgICAgICAgfVxuICAgICAgfSksIHRoaXMucGVyc2lzdCgpO1xuICAgIH0sIHRoaXMuZXhpc3RzID0gYXN5bmMgKGksIG4pID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5yZWNvcmRzLmhhcyhuKSA/IChhd2FpdCB0aGlzLmdldFJlY29yZChuKSkudG9waWMgPT09IGkgOiAhMSksIHRoaXMub24gPSAoaSwgbikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub24oaSwgbik7XG4gICAgfSwgdGhpcy5vbmNlID0gKGksIG4pID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uY2UoaSwgbik7XG4gICAgfSwgdGhpcy5vZmYgPSAoaSwgbikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub2ZmKGksIG4pO1xuICAgIH0sIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSAoaSwgbikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIoaSwgbik7XG4gICAgfSwgdGhpcy5sb2dnZXIgPSBrdCh0LCB0aGlzLm5hbWUpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBadCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IHN0b3JhZ2VLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByZWZpeCArIHRoaXMudmVyc2lvbiArIHRoaXMuY29yZS5jdXN0b21TdG9yYWdlUHJlZml4ICsgXCIvL1wiICsgdGhpcy5uYW1lO1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnJlY29yZHMuc2l6ZTtcbiAgfVxuICBnZXQga2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlY29yZHMua2V5cygpKTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVjb3Jkcy52YWx1ZXMoKSk7XG4gIH1cbiAgZ2V0IHBlbmRpbmcoKSB7XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIHJldHVybiB0aGlzLnZhbHVlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHQucmVzcG9uc2UgPCBcInVcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaSA9IHsgdG9waWM6IHQudG9waWMsIHJlcXVlc3Q6IEJpKHQucmVxdWVzdC5tZXRob2QsIHQucmVxdWVzdC5wYXJhbXMsIHQuaWQpLCBjaGFpbklkOiB0LmNoYWluSWQgfTtcbiAgICAgIHJldHVybiBlLnB1c2goaSk7XG4gICAgfSksIGU7XG4gIH1cbiAgYXN5bmMgc2V0SnNvblJwY1JlY29yZHMoZSkge1xuICAgIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBlKTtcbiAgfVxuICBhc3luYyBnZXRKc29uUnBjUmVjb3JkcygpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICB9XG4gIGdldFJlY29yZChlKSB7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgY29uc3QgdCA9IHRoaXMucmVjb3Jkcy5nZXQoZSk7XG4gICAgaWYgKCF0KSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGkgfSA9IGFlKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGAke3RoaXMubmFtZX06ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihpKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgYXN5bmMgcGVyc2lzdCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldEpzb25ScGNSZWNvcmRzKHRoaXMudmFsdWVzKSwgdGhpcy5ldmVudHMuZW1pdChfci5zeW5jKTtcbiAgfVxuICBhc3luYyByZXN0b3JlKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5nZXRKc29uUnBjUmVjb3JkcygpO1xuICAgICAgaWYgKHR5cGVvZiBlID4gXCJ1XCIgfHwgIWUubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5yZWNvcmRzLnNpemUpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBhZShcIlJFU1RPUkVfV0lMTF9PVkVSUklERVwiLCB0aGlzLm5hbWUpO1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcih0KSwgbmV3IEVycm9yKHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZWQgPSBlLCB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IFJlc3RvcmVkIHJlY29yZHMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJyZXN0b3JlXCIsIHJlY29yZHM6IHRoaXMudmFsdWVzIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGYWlsZWQgdG8gUmVzdG9yZSByZWNvcmRzIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5ldmVudHMub24oX3IuY3JlYXRlZCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBfci5jcmVhdGVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIHJlY29yZDogZSB9KTtcbiAgICB9KSwgdGhpcy5ldmVudHMub24oX3IudXBkYXRlZCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBfci51cGRhdGVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIHJlY29yZDogZSB9KTtcbiAgICB9KSwgdGhpcy5ldmVudHMub24oX3IuZGVsZXRlZCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBfci5kZWxldGVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIHJlY29yZDogZSB9KTtcbiAgICB9KSwgdGhpcy5jb3JlLmhlYXJ0YmVhdC5vbihnbi5wdWxzZSwgKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfSk7XG4gIH1cbiAgY2xlYW51cCgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBsZXQgZSA9ICExO1xuICAgICAgdGhpcy5yZWNvcmRzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgaWUudG9NaWxpc2Vjb25kcyh0LmV4cGlyeSB8fCAwKSAtIERhdGUubm93KCkgPD0gMCAmJiAodGhpcy5sb2dnZXIuaW5mbyhgRGVsZXRpbmcgZXhwaXJlZCBoaXN0b3J5IGxvZzogJHt0LmlkfWApLCB0aGlzLnJlY29yZHMuZGVsZXRlKHQuaWQpLCB0aGlzLmV2ZW50cy5lbWl0KF9yLmRlbGV0ZWQsIHQsICExKSwgZSA9ICEwKTtcbiAgICAgIH0pLCBlICYmIHRoaXMucGVyc2lzdCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oZSk7XG4gICAgfVxuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IGFlKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBxdyBleHRlbmRzIGhwIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMuZXhwaXJhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLmV2ZW50cyA9IG5ldyBpci5FdmVudEVtaXR0ZXIoKSwgdGhpcy5uYW1lID0gUjMsIHRoaXMudmVyc2lvbiA9IE4zLCB0aGlzLmNhY2hlZCA9IFtdLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuc3RvcmFnZVByZWZpeCA9IGpyLCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkIHx8ICh0aGlzLmxvZ2dlci50cmFjZShcIkluaXRpYWxpemVkXCIpLCBhd2FpdCB0aGlzLnJlc3RvcmUoKSwgdGhpcy5jYWNoZWQuZm9yRWFjaCgoaSkgPT4gdGhpcy5leHBpcmF0aW9ucy5zZXQoaS50YXJnZXQsIGkpKSwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCk7XG4gICAgfSwgdGhpcy5oYXMgPSAoaSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuZm9ybWF0VGFyZ2V0KGkpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuZ2V0RXhwaXJhdGlvbihuKSA8IFwidVwiO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnNldCA9IChpLCBuKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmZvcm1hdFRhcmdldChpKSwgbyA9IHsgdGFyZ2V0OiBzLCBleHBpcnk6IG4gfTtcbiAgICAgIHRoaXMuZXhwaXJhdGlvbnMuc2V0KHMsIG8pLCB0aGlzLmNoZWNrRXhwaXJ5KHMsIG8pLCB0aGlzLmV2ZW50cy5lbWl0KHVyLmNyZWF0ZWQsIHsgdGFyZ2V0OiBzLCBleHBpcmF0aW9uOiBvIH0pO1xuICAgIH0sIHRoaXMuZ2V0ID0gKGkpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgbiA9IHRoaXMuZm9ybWF0VGFyZ2V0KGkpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RXhwaXJhdGlvbihuKTtcbiAgICB9LCB0aGlzLmRlbCA9IChpKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMuaGFzKGkpKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLmZvcm1hdFRhcmdldChpKSwgcyA9IHRoaXMuZ2V0RXhwaXJhdGlvbihuKTtcbiAgICAgICAgdGhpcy5leHBpcmF0aW9ucy5kZWxldGUobiksIHRoaXMuZXZlbnRzLmVtaXQodXIuZGVsZXRlZCwgeyB0YXJnZXQ6IG4sIGV4cGlyYXRpb246IHMgfSk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vbiA9IChpLCBuKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbihpLCBuKTtcbiAgICB9LCB0aGlzLm9uY2UgPSAoaSwgbikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub25jZShpLCBuKTtcbiAgICB9LCB0aGlzLm9mZiA9IChpLCBuKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vZmYoaSwgbik7XG4gICAgfSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChpLCBuKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihpLCBuKTtcbiAgICB9LCB0aGlzLmxvZ2dlciA9IGt0KHQsIHRoaXMubmFtZSk7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIFp0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgc3RvcmFnZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUHJlZml4ICsgdGhpcy52ZXJzaW9uICsgdGhpcy5jb3JlLmN1c3RvbVN0b3JhZ2VQcmVmaXggKyBcIi8vXCIgKyB0aGlzLm5hbWU7XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHBpcmF0aW9ucy5zaXplO1xuICB9XG4gIGdldCBrZXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZXhwaXJhdGlvbnMua2V5cygpKTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZXhwaXJhdGlvbnMudmFsdWVzKCkpO1xuICB9XG4gIGZvcm1hdFRhcmdldChlKSB7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gbnkoZSk7XG4gICAgaWYgKHR5cGVvZiBlID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gc3koZSk7XG4gICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBhZShcIlVOS05PV05fVFlQRVwiLCBgVGFyZ2V0IHR5cGU6ICR7dHlwZW9mIGV9YCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICB9XG4gIGFzeW5jIHNldEV4cGlyYXRpb25zKGUpIHtcbiAgICBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXhwaXJhdGlvbnMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgfVxuICBhc3luYyBwZXJzaXN0KCkge1xuICAgIGF3YWl0IHRoaXMuc2V0RXhwaXJhdGlvbnModGhpcy52YWx1ZXMpLCB0aGlzLmV2ZW50cy5lbWl0KHVyLnN5bmMpO1xuICB9XG4gIGFzeW5jIHJlc3RvcmUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmdldEV4cGlyYXRpb25zKCk7XG4gICAgICBpZiAodHlwZW9mIGUgPiBcInVcIiB8fCAhZS5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmV4cGlyYXRpb25zLnNpemUpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBhZShcIlJFU1RPUkVfV0lMTF9PVkVSUklERVwiLCB0aGlzLm5hbWUpO1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcih0KSwgbmV3IEVycm9yKHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZWQgPSBlLCB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IFJlc3RvcmVkIGV4cGlyYXRpb25zIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicmVzdG9yZVwiLCBleHBpcmF0aW9uczogdGhpcy52YWx1ZXMgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBSZXN0b3JlIGV4cGlyYXRpb25zIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGdldEV4cGlyYXRpb24oZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmV4cGlyYXRpb25zLmdldChlKTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogaSB9ID0gYWUoXCJOT19NQVRDSElOR19LRVlcIiwgYCR7dGhpcy5uYW1lfTogJHtlfWApO1xuICAgICAgdGhyb3cgdGhpcy5sb2dnZXIud2FybihpKSwgbmV3IEVycm9yKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBjaGVja0V4cGlyeShlLCB0KSB7XG4gICAgY29uc3QgeyBleHBpcnk6IGkgfSA9IHQ7XG4gICAgaWUudG9NaWxpc2Vjb25kcyhpKSAtIERhdGUubm93KCkgPD0gMCAmJiB0aGlzLmV4cGlyZShlLCB0KTtcbiAgfVxuICBleHBpcmUoZSwgdCkge1xuICAgIHRoaXMuZXhwaXJhdGlvbnMuZGVsZXRlKGUpLCB0aGlzLmV2ZW50cy5lbWl0KHVyLmV4cGlyZWQsIHsgdGFyZ2V0OiBlLCBleHBpcmF0aW9uOiB0IH0pO1xuICB9XG4gIGNoZWNrRXhwaXJhdGlvbnMoKSB7XG4gICAgdGhpcy5jb3JlLnJlbGF5ZXIuY29ubmVjdGVkICYmIHRoaXMuZXhwaXJhdGlvbnMuZm9yRWFjaCgoZSwgdCkgPT4gdGhpcy5jaGVja0V4cGlyeSh0LCBlKSk7XG4gIH1cbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLmNvcmUuaGVhcnRiZWF0Lm9uKGduLnB1bHNlLCAoKSA9PiB0aGlzLmNoZWNrRXhwaXJhdGlvbnMoKSksIHRoaXMuZXZlbnRzLm9uKHVyLmNyZWF0ZWQsIChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gdXIuY3JlYXRlZDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7dH1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LCBkYXRhOiBlIH0pLCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9KSwgdGhpcy5ldmVudHMub24odXIuZXhwaXJlZCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB1ci5leHBpcmVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIGRhdGE6IGUgfSksIHRoaXMucGVyc2lzdCgpO1xuICAgIH0pLCB0aGlzLmV2ZW50cy5vbih1ci5kZWxldGVkLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IHVyLmRlbGV0ZWQ7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBFbWl0dGluZyAke3R9YCksIHRoaXMubG9nZ2VyLmRlYnVnKHsgdHlwZTogXCJldmVudFwiLCBldmVudDogdCwgZGF0YTogZSB9KSwgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSk7XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gYWUoXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFV3IGV4dGVuZHMgdXAge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBpKSB7XG4gICAgc3VwZXIoZSwgdCwgaSksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5zdG9yZSA9IGksIHRoaXMubmFtZSA9IFQzLCB0aGlzLnZlcmlmeVVybFYzID0gJDMsIHRoaXMuc3RvcmFnZVByZWZpeCA9IGpyLCB0aGlzLnZlcnNpb24gPSBTZCwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdmFyIG47XG4gICAgICB0aGlzLmlzRGV2RW52IHx8ICh0aGlzLnB1YmxpY0tleSA9IGF3YWl0IHRoaXMuc3RvcmUuZ2V0SXRlbSh0aGlzLnN0b3JlS2V5KSwgdGhpcy5wdWJsaWNLZXkgJiYgaWUudG9NaWxpc2Vjb25kcygobiA9IHRoaXMucHVibGljS2V5KSA9PSBudWxsID8gdm9pZCAwIDogbi5leHBpcmVzQXQpIDwgRGF0ZS5ub3coKSAmJiAodGhpcy5sb2dnZXIuZGVidWcoXCJ2ZXJpZnkgdjIgcHVibGljIGtleSBleHBpcmVkXCIpLCBhd2FpdCB0aGlzLnJlbW92ZVB1YmxpY0tleSgpKSk7XG4gICAgfSwgdGhpcy5yZWdpc3RlciA9IGFzeW5jIChuKSA9PiB7XG4gICAgICBpZiAoIWNzKCkgfHwgdGhpcy5pc0RldkVudilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcyA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sIHsgaWQ6IG8sIGRlY3J5cHRlZElkOiBmIH0gPSBuLCBoID0gYCR7dGhpcy52ZXJpZnlVcmxWM30vYXR0ZXN0YXRpb24/cHJvamVjdElkPSR7dGhpcy5jb3JlLnByb2plY3RJZH0mb3JpZ2luPSR7c30maWQ9JHtvfSZkZWNyeXB0ZWRJZD0ke2Z9YDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGQgPSBpcygpLCB2ID0gdGhpcy5zdGFydEFib3J0VGltZXIoaWUuT05FX1NFQ09ORCAqIDUpLCB3ID0gYXdhaXQgbmV3IFByb21pc2UoKEEsIEkpID0+IHtcbiAgICAgICAgICBjb25zdCBEID0gKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGspLCBkLmJvZHkucmVtb3ZlQ2hpbGQoTiksIEkoXCJhdHRlc3RhdGlvbiBhYm9ydGVkXCIpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBEKTtcbiAgICAgICAgICBjb25zdCBOID0gZC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICAgIE4uc3JjID0gaCwgTi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIE4uYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIEQsIHsgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwgfSk7XG4gICAgICAgICAgY29uc3QgayA9IChqKSA9PiB7XG4gICAgICAgICAgICBpZiAoai5kYXRhICYmIHR5cGVvZiBqLmRhdGEgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBUID0gSlNPTi5wYXJzZShqLmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChULnR5cGUgPT09IFwidmVyaWZ5X2F0dGVzdGF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChibyhULmF0dGVzdGF0aW9uKS5wYXlsb2FkLmlkICE9PSBvKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHYpLCBkLmJvZHkucmVtb3ZlQ2hpbGQoTiksIHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgRCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBrKSwgQShULmF0dGVzdGF0aW9uID09PSBudWxsID8gXCJcIiA6IFQuYXR0ZXN0YXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoVCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oVCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGQuYm9keS5hcHBlbmRDaGlsZChOKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGssIHsgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dnZXIuZGVidWcoXCJqd3QgYXR0ZXN0YXRpb25cIiwgdyksIHc7XG4gICAgICB9IGNhdGNoIChkKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9LCB0aGlzLnJlc29sdmUgPSBhc3luYyAobikgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNEZXZFbnYpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgY29uc3QgeyBhdHRlc3RhdGlvbklkOiBzLCBoYXNoOiBvLCBlbmNyeXB0ZWRJZDogZiB9ID0gbjtcbiAgICAgIGlmIChzID09PSBcIlwiKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwicmVzb2x2ZTogYXR0ZXN0YXRpb25JZCBpcyBlbXB0eSwgc2tpcHBpbmdcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzKSB7XG4gICAgICAgIGlmIChibyhzKS5wYXlsb2FkLmlkICE9PSBmKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZCA9IGF3YWl0IHRoaXMuaXNWYWxpZEp3dEF0dGVzdGF0aW9uKHMpO1xuICAgICAgICBpZiAoZCkge1xuICAgICAgICAgIGlmICghZC5pc1ZlcmlmaWVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwicmVzb2x2ZTogand0IGF0dGVzdGF0aW9uOiBvcmlnaW4gdXJsIG5vdCB2ZXJpZmllZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaCA9IHRoaXMuZ2V0VmVyaWZ5VXJsKG4/LnZlcmlmeVVybCk7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaEF0dGVzdGF0aW9uKG8sIGgpO1xuICAgIH0sIHRoaXMuZmV0Y2hBdHRlc3RhdGlvbiA9IGFzeW5jIChuLCBzKSA9PiB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgcmVzb2x2aW5nIGF0dGVzdGF0aW9uOiAke259IGZyb20gdXJsOiAke3N9YCk7XG4gICAgICBjb25zdCBvID0gdGhpcy5zdGFydEFib3J0VGltZXIoaWUuT05FX1NFQ09ORCAqIDUpLCBmID0gYXdhaXQgZmV0Y2goYCR7c30vYXR0ZXN0YXRpb24vJHtufT92MlN1cHBvcnRlZD10cnVlYCwgeyBzaWduYWw6IHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbCB9KTtcbiAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobyksIGYuc3RhdHVzID09PSAyMDAgPyBhd2FpdCBmLmpzb24oKSA6IHZvaWQgMDtcbiAgICB9LCB0aGlzLmdldFZlcmlmeVVybCA9IChuKSA9PiB7XG4gICAgICBsZXQgcyA9IG4gfHwgVm47XG4gICAgICByZXR1cm4gTDMuaW5jbHVkZXMocykgfHwgKHRoaXMubG9nZ2VyLmluZm8oYHZlcmlmeSB1cmw6ICR7c30sIG5vdCBpbmNsdWRlZCBpbiB0cnVzdGVkIGxpc3QsIGFzc2lnbmluZyBkZWZhdWx0OiAke1ZufWApLCBzID0gVm4pLCBzO1xuICAgIH0sIHRoaXMuZmV0Y2hQdWJsaWNLZXkgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgZmV0Y2hpbmcgcHVibGljIGtleSBmcm9tOiAke3RoaXMudmVyaWZ5VXJsVjN9YCk7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLnN0YXJ0QWJvcnRUaW1lcihpZS5GSVZFX1NFQ09ORFMpLCBzID0gYXdhaXQgZmV0Y2goYCR7dGhpcy52ZXJpZnlVcmxWM30vcHVibGljLWtleWAsIHsgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwgfSk7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobiksIGF3YWl0IHMuanNvbigpO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKG4pO1xuICAgICAgfVxuICAgIH0sIHRoaXMucGVyc2lzdFB1YmxpY0tleSA9IGFzeW5jIChuKSA9PiB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcInBlcnNpc3RpbmcgcHVibGljIGtleSB0byBsb2NhbCBzdG9yYWdlXCIsIG4pLCBhd2FpdCB0aGlzLnN0b3JlLnNldEl0ZW0odGhpcy5zdG9yZUtleSwgbiksIHRoaXMucHVibGljS2V5ID0gbjtcbiAgICB9LCB0aGlzLnJlbW92ZVB1YmxpY0tleSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwicmVtb3ZpbmcgdmVyaWZ5IHYyIHB1YmxpYyBrZXkgZnJvbSBzdG9yYWdlXCIpLCBhd2FpdCB0aGlzLnN0b3JlLnJlbW92ZUl0ZW0odGhpcy5zdG9yZUtleSksIHRoaXMucHVibGljS2V5ID0gdm9pZCAwO1xuICAgIH0sIHRoaXMuaXNWYWxpZEp3dEF0dGVzdGF0aW9uID0gYXN5bmMgKG4pID0+IHtcbiAgICAgIGNvbnN0IHMgPSBhd2FpdCB0aGlzLmdldFB1YmxpY0tleSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHMpXG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVBdHRlc3RhdGlvbihuLCBzKTtcbiAgICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZiksIHRoaXMubG9nZ2VyLndhcm4oXCJlcnJvciB2YWxpZGF0aW5nIGF0dGVzdGF0aW9uXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbyA9IGF3YWl0IHRoaXMuZmV0Y2hBbmRQZXJzaXN0UHVibGljS2V5KCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAobylcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUF0dGVzdGF0aW9uKG4sIG8pO1xuICAgICAgfSBjYXRjaCAoZikge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihmKSwgdGhpcy5sb2dnZXIud2FybihcImVycm9yIHZhbGlkYXRpbmcgYXR0ZXN0YXRpb25cIik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5nZXRQdWJsaWNLZXkgPSBhc3luYyAoKSA9PiB0aGlzLnB1YmxpY0tleSA/IHRoaXMucHVibGljS2V5IDogYXdhaXQgdGhpcy5mZXRjaEFuZFBlcnNpc3RQdWJsaWNLZXkoKSwgdGhpcy5mZXRjaEFuZFBlcnNpc3RQdWJsaWNLZXkgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5mZXRjaFByb21pc2UpXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoUHJvbWlzZSwgdGhpcy5wdWJsaWNLZXk7XG4gICAgICB0aGlzLmZldGNoUHJvbWlzZSA9IG5ldyBQcm9taXNlKGFzeW5jIChzKSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBhd2FpdCB0aGlzLmZldGNoUHVibGljS2V5KCk7XG4gICAgICAgIG8gJiYgKGF3YWl0IHRoaXMucGVyc2lzdFB1YmxpY0tleShvKSwgcyhvKSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG4gPSBhd2FpdCB0aGlzLmZldGNoUHJvbWlzZTtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoUHJvbWlzZSA9IHZvaWQgMCwgbjtcbiAgICB9LCB0aGlzLnZhbGlkYXRlQXR0ZXN0YXRpb24gPSAobiwgcykgPT4ge1xuICAgICAgY29uc3QgbyA9IFd5KG4sIHMucHVibGljS2V5KSwgZiA9IHsgaGFzRXhwaXJlZDogaWUudG9NaWxpc2Vjb25kcyhvLmV4cCkgPCBEYXRlLm5vdygpLCBwYXlsb2FkOiBvIH07XG4gICAgICBpZiAoZi5oYXNFeHBpcmVkKVxuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci53YXJuKFwicmVzb2x2ZTogand0IGF0dGVzdGF0aW9uIGV4cGlyZWRcIiksIG5ldyBFcnJvcihcIkpXVCBhdHRlc3RhdGlvbiBleHBpcmVkXCIpO1xuICAgICAgcmV0dXJuIHsgb3JpZ2luOiBmLnBheWxvYWQub3JpZ2luLCBpc1NjYW06IGYucGF5bG9hZC5pc1NjYW0sIGlzVmVyaWZpZWQ6IGYucGF5bG9hZC5pc1ZlcmlmaWVkIH07XG4gICAgfSwgdGhpcy5sb2dnZXIgPSBrdCh0LCB0aGlzLm5hbWUpLCB0aGlzLmFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSwgdGhpcy5pc0RldkVudiA9IHJmKCksIHRoaXMuaW5pdCgpO1xuICB9XG4gIGdldCBzdG9yZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUHJlZml4ICsgdGhpcy52ZXJzaW9uICsgdGhpcy5jb3JlLmN1c3RvbVN0b3JhZ2VQcmVmaXggKyBcIi8vdmVyaWZ5OnB1YmxpYzprZXlcIjtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gWnQodGhpcy5sb2dnZXIpO1xuICB9XG4gIHN0YXJ0QWJvcnRUaW1lcihlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpLCBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCksIGllLnRvTWlsaXNlY29uZHMoZSkpO1xuICB9XG59XG5jbGFzcyB6dyBleHRlbmRzIGRwIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLnByb2plY3RJZCA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5jb250ZXh0ID0gRjMsIHRoaXMucmVnaXN0ZXJEZXZpY2VUb2tlbiA9IGFzeW5jIChpKSA9PiB7XG4gICAgICBjb25zdCB7IGNsaWVudElkOiBuLCB0b2tlbjogcywgbm90aWZpY2F0aW9uVHlwZTogbywgZW5hYmxlRW5jcnlwdGVkOiBmID0gITEgfSA9IGksIGggPSBgJHtxM30vJHt0aGlzLnByb2plY3RJZH0vY2xpZW50c2A7XG4gICAgICBhd2FpdCBmZXRjaChoLCB7IG1ldGhvZDogXCJQT1NUXCIsIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjbGllbnRfaWQ6IG4sIHR5cGU6IG8sIHRva2VuOiBzLCBhbHdheXNfcmF3OiBmIH0pIH0pO1xuICAgIH0sIHRoaXMubG9nZ2VyID0ga3QodCwgdGhpcy5jb250ZXh0KTtcbiAgfVxufVxudmFyIEJ3ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfaCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIGt3ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgancgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCB4aCA9IChyLCBlLCB0KSA9PiBlIGluIHIgPyBCdyhyLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogcltlXSA9IHQsIEJuID0gKHIsIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIGt3LmNhbGwoZSwgdCkgJiYgeGgociwgdCwgZVt0XSk7XG4gIGlmIChfaClcbiAgICBmb3IgKHZhciB0IG9mIF9oKGUpKVxuICAgICAgancuY2FsbChlLCB0KSAmJiB4aChyLCB0LCBlW3RdKTtcbiAgcmV0dXJuIHI7XG59O1xuY2xhc3MgS3cgZXh0ZW5kcyBscCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIGkgPSAhMCkge1xuICAgIHN1cGVyKGUsIHQsIGkpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMuY29udGV4dCA9IHozLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSBqciwgdGhpcy5zdG9yYWdlVmVyc2lvbiA9IFUzLCB0aGlzLmV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuc2hvdWxkUGVyc2lzdCA9ICExLCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXJmKCkpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbiA9IHsgZXZlbnRJZDogRGMoKSwgdGltZXN0YW1wOiBEYXRlLm5vdygpLCBkb21haW46IHRoaXMuZ2V0QXBwRG9tYWluKCksIHByb3BzOiB7IGV2ZW50OiBcIklOSVRcIiwgdHlwZTogXCJcIiwgcHJvcGVydGllczogeyBjbGllbnRfaWQ6IGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uZ2V0Q2xpZW50SWQoKSwgdXNlcl9hZ2VudDogcmQodGhpcy5jb3JlLnJlbGF5ZXIucHJvdG9jb2wsIHRoaXMuY29yZS5yZWxheWVyLnZlcnNpb24sIERvKSB9IH0gfTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRFdmVudChbbl0pO1xuICAgICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihuKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMuY3JlYXRlRXZlbnQgPSAobikgPT4ge1xuICAgICAgY29uc3QgeyBldmVudDogcyA9IFwiRVJST1JcIiwgdHlwZTogbyA9IFwiXCIsIHByb3BlcnRpZXM6IHsgdG9waWM6IGYsIHRyYWNlOiBoIH0gfSA9IG4sIGQgPSBEYygpLCB2ID0gdGhpcy5jb3JlLnByb2plY3RJZCB8fCBcIlwiLCB3ID0gRGF0ZS5ub3coKSwgQSA9IEJuKHsgZXZlbnRJZDogZCwgdGltZXN0YW1wOiB3LCBwcm9wczogeyBldmVudDogcywgdHlwZTogbywgcHJvcGVydGllczogeyB0b3BpYzogZiwgdHJhY2U6IGggfSB9LCBidW5kbGVJZDogdiwgZG9tYWluOiB0aGlzLmdldEFwcERvbWFpbigpIH0sIHRoaXMuc2V0TWV0aG9kcyhkKSk7XG4gICAgICByZXR1cm4gdGhpcy50ZWxlbWV0cnlFbmFibGVkICYmICh0aGlzLmV2ZW50cy5zZXQoZCwgQSksIHRoaXMuc2hvdWxkUGVyc2lzdCA9ICEwKSwgQTtcbiAgICB9LCB0aGlzLmdldEV2ZW50ID0gKG4pID0+IHtcbiAgICAgIGNvbnN0IHsgZXZlbnRJZDogcywgdG9waWM6IG8gfSA9IG47XG4gICAgICBpZiAocylcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzLmdldChzKTtcbiAgICAgIGNvbnN0IGYgPSBBcnJheS5mcm9tKHRoaXMuZXZlbnRzLnZhbHVlcygpKS5maW5kKChoKSA9PiBoLnByb3BzLnByb3BlcnRpZXMudG9waWMgPT09IG8pO1xuICAgICAgaWYgKGYpXG4gICAgICAgIHJldHVybiBCbihCbih7fSwgZiksIHRoaXMuc2V0TWV0aG9kcyhmLmV2ZW50SWQpKTtcbiAgICB9LCB0aGlzLmRlbGV0ZUV2ZW50ID0gKG4pID0+IHtcbiAgICAgIGNvbnN0IHsgZXZlbnRJZDogcyB9ID0gbjtcbiAgICAgIHRoaXMuZXZlbnRzLmRlbGV0ZShzKSwgdGhpcy5zaG91bGRQZXJzaXN0ID0gITA7XG4gICAgfSwgdGhpcy5zZXRFdmVudExpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgIHRoaXMuY29yZS5oZWFydGJlYXQub24oZ24ucHVsc2UsIGFzeW5jICgpID0+IHtcbiAgICAgICAgdGhpcy5zaG91bGRQZXJzaXN0ICYmIGF3YWl0IHRoaXMucGVyc2lzdCgpLCB0aGlzLmV2ZW50cy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgICAgaWUuZnJvbU1pbGlzZWNvbmRzKERhdGUubm93KCkpIC0gaWUuZnJvbU1pbGlzZWNvbmRzKG4udGltZXN0YW1wKSA+IEIzICYmICh0aGlzLmV2ZW50cy5kZWxldGUobi5ldmVudElkKSwgdGhpcy5zaG91bGRQZXJzaXN0ID0gITApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMuc2V0TWV0aG9kcyA9IChuKSA9PiAoeyBhZGRUcmFjZTogKHMpID0+IHRoaXMuYWRkVHJhY2UobiwgcyksIHNldEVycm9yOiAocykgPT4gdGhpcy5zZXRFcnJvcihuLCBzKSB9KSwgdGhpcy5hZGRUcmFjZSA9IChuLCBzKSA9PiB7XG4gICAgICBjb25zdCBvID0gdGhpcy5ldmVudHMuZ2V0KG4pO1xuICAgICAgbyAmJiAoby5wcm9wcy5wcm9wZXJ0aWVzLnRyYWNlLnB1c2gocyksIHRoaXMuZXZlbnRzLnNldChuLCBvKSwgdGhpcy5zaG91bGRQZXJzaXN0ID0gITApO1xuICAgIH0sIHRoaXMuc2V0RXJyb3IgPSAobiwgcykgPT4ge1xuICAgICAgY29uc3QgbyA9IHRoaXMuZXZlbnRzLmdldChuKTtcbiAgICAgIG8gJiYgKG8ucHJvcHMudHlwZSA9IHMsIG8udGltZXN0YW1wID0gRGF0ZS5ub3coKSwgdGhpcy5ldmVudHMuc2V0KG4sIG8pLCB0aGlzLnNob3VsZFBlcnNpc3QgPSAhMCk7XG4gICAgfSwgdGhpcy5wZXJzaXN0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIEFycmF5LmZyb20odGhpcy5ldmVudHMudmFsdWVzKCkpKSwgdGhpcy5zaG91bGRQZXJzaXN0ID0gITE7XG4gICAgfSwgdGhpcy5yZXN0b3JlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbiA9IGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KSB8fCBbXTtcbiAgICAgICAgaWYgKCFuLmxlbmd0aClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIG4uZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgIHRoaXMuZXZlbnRzLnNldChzLmV2ZW50SWQsIEJuKEJuKHt9LCBzKSwgdGhpcy5zZXRNZXRob2RzKHMuZXZlbnRJZCkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4obik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5zdWJtaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudGVsZW1ldHJ5RW5hYmxlZCB8fCB0aGlzLmV2ZW50cy5zaXplID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBuID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtzLCBvXSBvZiB0aGlzLmV2ZW50cylcbiAgICAgICAgby5wcm9wcy50eXBlICYmIG4ucHVzaChvKTtcbiAgICAgIGlmIChuLmxlbmd0aCAhPT0gMClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoKGF3YWl0IHRoaXMuc2VuZEV2ZW50KG4pKS5vaylcbiAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiBuKVxuICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kZWxldGUocy5ldmVudElkKSwgdGhpcy5zaG91bGRQZXJzaXN0ID0gITA7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKHMpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcy5zZW5kRXZlbnQgPSBhc3luYyAobikgPT4ge1xuICAgICAgY29uc3QgcyA9IHRoaXMuZ2V0QXBwRG9tYWluKCkgPyBcIlwiIDogXCImc3A9ZGVza3RvcFwiO1xuICAgICAgcmV0dXJuIGF3YWl0IGZldGNoKGAke2szfT9wcm9qZWN0SWQ9JHt0aGlzLmNvcmUucHJvamVjdElkfSZzdD1ldmVudHNfc2RrJnN2PWpzLSR7RG99JHtzfWAsIHsgbWV0aG9kOiBcIlBPU1RcIiwgYm9keTogSlNPTi5zdHJpbmdpZnkobikgfSk7XG4gICAgfSwgdGhpcy5nZXRBcHBEb21haW4gPSAoKSA9PiB0ZCgpLnVybCwgdGhpcy5sb2dnZXIgPSBrdCh0LCB0aGlzLmNvbnRleHQpLCB0aGlzLnRlbGVtZXRyeUVuYWJsZWQgPSBpLCBpID8gdGhpcy5yZXN0b3JlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLnN1Ym1pdCgpLCB0aGlzLnNldEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfSkgOiB0aGlzLnBlcnNpc3QoKTtcbiAgfVxuICBnZXQgc3RvcmFnZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUHJlZml4ICsgdGhpcy5zdG9yYWdlVmVyc2lvbiArIHRoaXMuY29yZS5jdXN0b21TdG9yYWdlUHJlZml4ICsgXCIvL1wiICsgdGhpcy5jb250ZXh0O1xuICB9XG59XG52YXIgSHcgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIEVoID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgVncgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBXdyA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIFNoID0gKHIsIGUsIHQpID0+IGUgaW4gciA/IEh3KHIsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiByW2VdID0gdCwgTWggPSAociwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgVncuY2FsbChlLCB0KSAmJiBTaChyLCB0LCBlW3RdKTtcbiAgaWYgKEVoKVxuICAgIGZvciAodmFyIHQgb2YgRWgoZSkpXG4gICAgICBXdy5jYWxsKGUsIHQpICYmIFNoKHIsIHQsIGVbdF0pO1xuICByZXR1cm4gcjtcbn07XG5sZXQgR3cgPSBjbGFzcyBxZCBleHRlbmRzIGlwIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHZhciB0O1xuICAgIHN1cGVyKGUpLCB0aGlzLnByb3RvY29sID0gRWQsIHRoaXMudmVyc2lvbiA9IFNkLCB0aGlzLm5hbWUgPSBlYSwgdGhpcy5ldmVudHMgPSBuZXcgaXIuRXZlbnRFbWl0dGVyKCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5vbiA9IChvLCBmKSA9PiB0aGlzLmV2ZW50cy5vbihvLCBmKSwgdGhpcy5vbmNlID0gKG8sIGYpID0+IHRoaXMuZXZlbnRzLm9uY2UobywgZiksIHRoaXMub2ZmID0gKG8sIGYpID0+IHRoaXMuZXZlbnRzLm9mZihvLCBmKSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChvLCBmKSA9PiB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihvLCBmKSwgdGhpcy5kaXNwYXRjaEVudmVsb3BlID0gKHsgdG9waWM6IG8sIG1lc3NhZ2U6IGYsIHNlc3Npb25FeGlzdHM6IGggfSkgPT4ge1xuICAgICAgaWYgKCFvIHx8ICFmKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBkID0geyB0b3BpYzogbywgbWVzc2FnZTogZiwgcHVibGlzaGVkQXQ6IERhdGUubm93KCksIHRyYW5zcG9ydFR5cGU6IGF0LmxpbmtfbW9kZSB9O1xuICAgICAgdGhpcy5yZWxheWVyLm9uTGlua01lc3NhZ2VFdmVudChkLCB7IHNlc3Npb25FeGlzdHM6IGggfSk7XG4gICAgfSwgdGhpcy5wcm9qZWN0SWQgPSBlPy5wcm9qZWN0SWQsIHRoaXMucmVsYXlVcmwgPSBlPy5yZWxheVVybCB8fCBJZCwgdGhpcy5jdXN0b21TdG9yYWdlUHJlZml4ID0gZSAhPSBudWxsICYmIGUuY3VzdG9tU3RvcmFnZVByZWZpeCA/IGA6JHtlLmN1c3RvbVN0b3JhZ2VQcmVmaXh9YCA6IFwiXCI7XG4gICAgY29uc3QgaSA9IFRvKHsgbGV2ZWw6IHR5cGVvZiBlPy5sb2dnZXIgPT0gXCJzdHJpbmdcIiAmJiBlLmxvZ2dlciA/IGUubG9nZ2VyIDogYzMubG9nZ2VyLCBuYW1lOiBlYSB9KSwgeyBsb2dnZXI6IG4sIGNodW5rTG9nZ2VyQ29udHJvbGxlcjogcyB9ID0gcnAoeyBvcHRzOiBpLCBtYXhTaXplSW5CeXRlczogZT8ubWF4TG9nQmxvYlNpemVJbkJ5dGVzLCBsb2dnZXJPdmVycmlkZTogZT8ubG9nZ2VyIH0pO1xuICAgIHRoaXMubG9nQ2h1bmtDb250cm9sbGVyID0gcywgKHQgPSB0aGlzLmxvZ0NodW5rQ29udHJvbGxlcikgIT0gbnVsbCAmJiB0LmRvd25sb2FkTG9nc0Jsb2JJbkJyb3dzZXIgJiYgKHdpbmRvdy5kb3dubG9hZExvZ3NCbG9iSW5Ccm93c2VyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdmFyIG8sIGY7XG4gICAgICAobyA9IHRoaXMubG9nQ2h1bmtDb250cm9sbGVyKSAhPSBudWxsICYmIG8uZG93bmxvYWRMb2dzQmxvYkluQnJvd3NlciAmJiAoKGYgPSB0aGlzLmxvZ0NodW5rQ29udHJvbGxlcikgPT0gbnVsbCB8fCBmLmRvd25sb2FkTG9nc0Jsb2JJbkJyb3dzZXIoeyBjbGllbnRJZDogYXdhaXQgdGhpcy5jcnlwdG8uZ2V0Q2xpZW50SWQoKSB9KSk7XG4gICAgfSksIHRoaXMubG9nZ2VyID0ga3QobiwgdGhpcy5uYW1lKSwgdGhpcy5oZWFydGJlYXQgPSBuZXcgR2woKSwgdGhpcy5jcnlwdG8gPSBuZXcgcHcodGhpcywgdGhpcy5sb2dnZXIsIGU/LmtleWNoYWluKSwgdGhpcy5oaXN0b3J5ID0gbmV3IEZ3KHRoaXMsIHRoaXMubG9nZ2VyKSwgdGhpcy5leHBpcmVyID0gbmV3IHF3KHRoaXMsIHRoaXMubG9nZ2VyKSwgdGhpcy5zdG9yYWdlID0gZSAhPSBudWxsICYmIGUuc3RvcmFnZSA/IGUuc3RvcmFnZSA6IG5ldyBEMChNaChNaCh7fSwgaDMpLCBlPy5zdG9yYWdlT3B0aW9ucykpLCB0aGlzLnJlbGF5ZXIgPSBuZXcgTncoeyBjb3JlOiB0aGlzLCBsb2dnZXI6IHRoaXMubG9nZ2VyLCByZWxheVVybDogdGhpcy5yZWxheVVybCwgcHJvamVjdElkOiB0aGlzLnByb2plY3RJZCB9KSwgdGhpcy5wYWlyaW5nID0gbmV3IEx3KHRoaXMsIHRoaXMubG9nZ2VyKSwgdGhpcy52ZXJpZnkgPSBuZXcgVXcodGhpcywgdGhpcy5sb2dnZXIsIHRoaXMuc3RvcmFnZSksIHRoaXMuZWNob0NsaWVudCA9IG5ldyB6dyh0aGlzLnByb2plY3RJZCB8fCBcIlwiLCB0aGlzLmxvZ2dlciksIHRoaXMubGlua01vZGVTdXBwb3J0ZWRBcHBzID0gW10sIHRoaXMuZXZlbnRDbGllbnQgPSBuZXcgS3codGhpcywgdGhpcy5sb2dnZXIsIGU/LnRlbGVtZXRyeUVuYWJsZWQpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBpbml0KGUpIHtcbiAgICBjb25zdCB0ID0gbmV3IHFkKGUpO1xuICAgIGF3YWl0IHQuaW5pdGlhbGl6ZSgpO1xuICAgIGNvbnN0IGkgPSBhd2FpdCB0LmNyeXB0by5nZXRDbGllbnRJZCgpO1xuICAgIHJldHVybiBhd2FpdCB0LnN0b3JhZ2Uuc2V0SXRlbShFMywgaSksIHQ7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIFp0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBhc3luYyBzdGFydCgpIHtcbiAgICB0aGlzLmluaXRpYWxpemVkIHx8IGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIGFzeW5jIGdldExvZ3NCbG9iKCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiAoZSA9IHRoaXMubG9nQ2h1bmtDb250cm9sbGVyKSA9PSBudWxsID8gdm9pZCAwIDogZS5sb2dzVG9CbG9iKHsgY2xpZW50SWQ6IGF3YWl0IHRoaXMuY3J5cHRvLmdldENsaWVudElkKCkgfSk7XG4gIH1cbiAgYXN5bmMgYWRkTGlua01vZGVTdXBwb3J0ZWRBcHAoZSkge1xuICAgIHRoaXMubGlua01vZGVTdXBwb3J0ZWRBcHBzLmluY2x1ZGVzKGUpIHx8ICh0aGlzLmxpbmtNb2RlU3VwcG9ydGVkQXBwcy5wdXNoKGUpLCBhd2FpdCB0aGlzLnN0b3JhZ2Uuc2V0SXRlbShyaCwgdGhpcy5saW5rTW9kZVN1cHBvcnRlZEFwcHMpKTtcbiAgfVxuICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIik7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY3J5cHRvLmluaXQoKSwgYXdhaXQgdGhpcy5oaXN0b3J5LmluaXQoKSwgYXdhaXQgdGhpcy5leHBpcmVyLmluaXQoKSwgYXdhaXQgdGhpcy5yZWxheWVyLmluaXQoKSwgYXdhaXQgdGhpcy5oZWFydGJlYXQuaW5pdCgpLCBhd2FpdCB0aGlzLnBhaXJpbmcuaW5pdCgpLCB0aGlzLmV2ZW50Q2xpZW50LmluaXQoKSwgdGhpcy5saW5rTW9kZVN1cHBvcnRlZEFwcHMgPSBhd2FpdCB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShyaCkgfHwgW10sIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCwgdGhpcy5sb2dnZXIuaW5mbyhcIkNvcmUgSW5pdGlhbGl6YXRpb24gU3VjY2Vzc1wiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyB0aGlzLmxvZ2dlci53YXJuKGBDb3JlIEluaXRpYWxpemF0aW9uIEZhaWx1cmUgYXQgZXBvY2ggJHtEYXRlLm5vdygpfWAsIGUpLCB0aGlzLmxvZ2dlci5lcnJvcihlLm1lc3NhZ2UpLCBlO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IEp3ID0gR3csIFVkID0gXCJ3Y1wiLCB6ZCA9IDIsIEJkID0gXCJjbGllbnRcIiwgY2YgPSBgJHtVZH1AJHt6ZH06JHtCZH06YCwgbm8gPSB7IG5hbWU6IEJkLCBsb2dnZXI6IFwiZXJyb3JcIiwgY29udHJvbGxlcjogITEsIHJlbGF5VXJsOiBcIndzczovL3JlbGF5LndhbGxldGNvbm5lY3Qub3JnXCIgfSwgSWggPSBcIldBTExFVENPTk5FQ1RfREVFUExJTktfQ0hPSUNFXCIsIFl3ID0gXCJwcm9wb3NhbFwiLCBYdyA9IFwiUHJvcG9zYWwgZXhwaXJlZFwiLCBadyA9IFwic2Vzc2lvblwiLCBzbiA9IGllLlNFVkVOX0RBWVMsIFF3ID0gXCJlbmdpbmVcIiwgX3QgPSB7IHdjX3Nlc3Npb25Qcm9wb3NlOiB7IHJlcTogeyB0dGw6IGllLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMCwgdGFnOiAxMTAwIH0sIHJlczogeyB0dGw6IGllLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMSwgdGFnOiAxMTAxIH0sIHJlamVjdDogeyB0dGw6IGllLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMSwgdGFnOiAxMTIwIH0sIGF1dG9SZWplY3Q6IHsgdHRsOiBpZS5GSVZFX01JTlVURVMsIHByb21wdDogITEsIHRhZzogMTEyMSB9IH0sIHdjX3Nlc3Npb25TZXR0bGU6IHsgcmVxOiB7IHR0bDogaWUuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICExLCB0YWc6IDExMDIgfSwgcmVzOiB7IHR0bDogaWUuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICExLCB0YWc6IDExMDMgfSB9LCB3Y19zZXNzaW9uVXBkYXRlOiB7IHJlcTogeyB0dGw6IGllLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMTEwNCB9LCByZXM6IHsgdHRsOiBpZS5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDExMDUgfSB9LCB3Y19zZXNzaW9uRXh0ZW5kOiB7IHJlcTogeyB0dGw6IGllLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMTEwNiB9LCByZXM6IHsgdHRsOiBpZS5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDExMDcgfSB9LCB3Y19zZXNzaW9uUmVxdWVzdDogeyByZXE6IHsgdHRsOiBpZS5GSVZFX01JTlVURVMsIHByb21wdDogITAsIHRhZzogMTEwOCB9LCByZXM6IHsgdHRsOiBpZS5GSVZFX01JTlVURVMsIHByb21wdDogITEsIHRhZzogMTEwOSB9IH0sIHdjX3Nlc3Npb25FdmVudDogeyByZXE6IHsgdHRsOiBpZS5GSVZFX01JTlVURVMsIHByb21wdDogITAsIHRhZzogMTExMCB9LCByZXM6IHsgdHRsOiBpZS5GSVZFX01JTlVURVMsIHByb21wdDogITEsIHRhZzogMTExMSB9IH0sIHdjX3Nlc3Npb25EZWxldGU6IHsgcmVxOiB7IHR0bDogaWUuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxMTEyIH0sIHJlczogeyB0dGw6IGllLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMTExMyB9IH0sIHdjX3Nlc3Npb25QaW5nOiB7IHJlcTogeyB0dGw6IGllLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMTExNCB9LCByZXM6IHsgdHRsOiBpZS5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDExMTUgfSB9LCB3Y19zZXNzaW9uQXV0aGVudGljYXRlOiB7IHJlcTogeyB0dGw6IGllLk9ORV9IT1VSLCBwcm9tcHQ6ICEwLCB0YWc6IDExMTYgfSwgcmVzOiB7IHR0bDogaWUuT05FX0hPVVIsIHByb21wdDogITEsIHRhZzogMTExNyB9LCByZWplY3Q6IHsgdHRsOiBpZS5GSVZFX01JTlVURVMsIHByb21wdDogITEsIHRhZzogMTExOCB9LCBhdXRvUmVqZWN0OiB7IHR0bDogaWUuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICExLCB0YWc6IDExMTkgfSB9IH0sIHNvID0geyBtaW46IGllLkZJVkVfTUlOVVRFUywgbWF4OiBpZS5TRVZFTl9EQVlTIH0sIFByID0geyBpZGxlOiBcIklETEVcIiwgYWN0aXZlOiBcIkFDVElWRVwiIH0sIGU1ID0gXCJyZXF1ZXN0XCIsIHQ1ID0gW1wid2Nfc2Vzc2lvblByb3Bvc2VcIiwgXCJ3Y19zZXNzaW9uUmVxdWVzdFwiLCBcIndjX2F1dGhSZXF1ZXN0XCIsIFwid2Nfc2Vzc2lvbkF1dGhlbnRpY2F0ZVwiXSwgcjUgPSBcIndjXCIsIGk1ID0gXCJhdXRoXCIsIG41ID0gXCJhdXRoS2V5c1wiLCBzNSA9IFwicGFpcmluZ1RvcGljc1wiLCBhNSA9IFwicmVxdWVzdHNcIiwgUGEgPSBgJHtyNX1AJHsxLjV9OiR7aTV9OmAsICRzID0gYCR7UGF9OlBVQl9LRVlgO1xudmFyIG81ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBmNSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCBjNSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLCBBaCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIGg1ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgdTUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBEaCA9IChyLCBlLCB0KSA9PiBlIGluIHIgPyBvNShyLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogcltlXSA9IHQsIGx0ID0gKHIsIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIGg1LmNhbGwoZSwgdCkgJiYgRGgociwgdCwgZVt0XSk7XG4gIGlmIChBaClcbiAgICBmb3IgKHZhciB0IG9mIEFoKGUpKVxuICAgICAgdTUuY2FsbChlLCB0KSAmJiBEaChyLCB0LCBlW3RdKTtcbiAgcmV0dXJuIHI7XG59LCBFciA9IChyLCBlKSA9PiBmNShyLCBjNShlKSk7XG5jbGFzcyBkNSBleHRlbmRzIHZwIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLm5hbWUgPSBRdywgdGhpcy5ldmVudHMgPSBuZXcgemgoKSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnJlcXVlc3RRdWV1ZSA9IHsgc3RhdGU6IFByLmlkbGUsIHF1ZXVlOiBbXSB9LCB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUgPSB7IHN0YXRlOiBQci5pZGxlLCBxdWV1ZTogW10gfSwgdGhpcy5yZXF1ZXN0UXVldWVEZWxheSA9IGllLk9ORV9TRUNPTkQsIHRoaXMuZXhwZWN0ZWRQYWlyaW5nTWV0aG9kTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5yZWNlbnRseURlbGV0ZWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLnJlY2VudGx5RGVsZXRlZExpbWl0ID0gMjAwLCB0aGlzLnJlbGF5TWVzc2FnZUNhY2hlID0gW10sIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgKGF3YWl0IHRoaXMuY2xlYW51cCgpLCB0aGlzLnJlZ2lzdGVyUmVsYXllckV2ZW50cygpLCB0aGlzLnJlZ2lzdGVyRXhwaXJlckV2ZW50cygpLCB0aGlzLnJlZ2lzdGVyUGFpcmluZ0V2ZW50cygpLCBhd2FpdCB0aGlzLnJlZ2lzdGVyTGlua01vZGVMaXN0ZW5lcnMoKSwgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnJlZ2lzdGVyKHsgbWV0aG9kczogT2JqZWN0LmtleXMoX3QpIH0pLCB0aGlzLmluaXRpYWxpemVkID0gITAsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUucXVldWUgPSB0aGlzLmdldFBlbmRpbmdTZXNzaW9uUmVxdWVzdHMoKSwgdGhpcy5wcm9jZXNzU2Vzc2lvblJlcXVlc3RRdWV1ZSgpO1xuICAgICAgfSwgaWUudG9NaWxpc2Vjb25kcyh0aGlzLnJlcXVlc3RRdWV1ZURlbGF5KSkpO1xuICAgIH0sIHRoaXMuY29ubmVjdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5jb25maXJtT25saW5lU3RhdGVPclRocm93KCk7XG4gICAgICBjb25zdCBpID0gRXIobHQoe30sIHQpLCB7IHJlcXVpcmVkTmFtZXNwYWNlczogdC5yZXF1aXJlZE5hbWVzcGFjZXMgfHwge30sIG9wdGlvbmFsTmFtZXNwYWNlczogdC5vcHRpb25hbE5hbWVzcGFjZXMgfHwge30gfSk7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRDb25uZWN0KGkpO1xuICAgICAgY29uc3QgeyBwYWlyaW5nVG9waWM6IG4sIHJlcXVpcmVkTmFtZXNwYWNlczogcywgb3B0aW9uYWxOYW1lc3BhY2VzOiBvLCBzZXNzaW9uUHJvcGVydGllczogZiwgcmVsYXlzOiBoIH0gPSBpO1xuICAgICAgbGV0IGQgPSBuLCB2LCB3ID0gITE7XG4gICAgICB0cnkge1xuICAgICAgICBkICYmICh3ID0gdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXJpbmdzLmdldChkKS5hY3RpdmUpO1xuICAgICAgfSBjYXRjaCAoJCkge1xuICAgICAgICB0aHJvdyB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoYGNvbm5lY3QoKSAtPiBwYWlyaW5nLmdldCgke2R9KSBmYWlsZWRgKSwgJDtcbiAgICAgIH1cbiAgICAgIGlmICghZCB8fCAhdykge1xuICAgICAgICBjb25zdCB7IHRvcGljOiAkLCB1cmk6IHogfSA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5jcmVhdGUoKTtcbiAgICAgICAgZCA9ICQsIHYgPSB6O1xuICAgICAgfVxuICAgICAgaWYgKCFkKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogJCB9ID0gYWUoXCJOT19NQVRDSElOR19LRVlcIiwgYGNvbm5lY3QoKSBwYWlyaW5nIHRvcGljOiAke2R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IEEgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5nZW5lcmF0ZUtleVBhaXIoKSwgSSA9IF90LndjX3Nlc3Npb25Qcm9wb3NlLnJlcS50dGwgfHwgaWUuRklWRV9NSU5VVEVTLCBEID0gbXQoSSksIE4gPSBsdCh7IHJlcXVpcmVkTmFtZXNwYWNlczogcywgb3B0aW9uYWxOYW1lc3BhY2VzOiBvLCByZWxheXM6IGggPz8gW3sgcHJvdG9jb2w6IE1kIH1dLCBwcm9wb3NlcjogeyBwdWJsaWNLZXk6IEEsIG1ldGFkYXRhOiB0aGlzLmNsaWVudC5tZXRhZGF0YSB9LCBleHBpcnlUaW1lc3RhbXA6IEQsIHBhaXJpbmdUb3BpYzogZCB9LCBmICYmIHsgc2Vzc2lvblByb3BlcnRpZXM6IGYgfSksIHsgcmVqZWN0OiBrLCByZXNvbHZlOiBqLCBkb25lOiBUIH0gPSBMaShJLCBYdyk7XG4gICAgICB0aGlzLmV2ZW50cy5vbmNlKFhlKFwic2Vzc2lvbl9jb25uZWN0XCIpLCBhc3luYyAoeyBlcnJvcjogJCwgc2Vzc2lvbjogeiB9KSA9PiB7XG4gICAgICAgIGlmICgkKVxuICAgICAgICAgIGsoJCk7XG4gICAgICAgIGVsc2UgaWYgKHopIHtcbiAgICAgICAgICB6LnNlbGYucHVibGljS2V5ID0gQTtcbiAgICAgICAgICBjb25zdCBCID0gRXIobHQoe30sIHopLCB7IHBhaXJpbmdUb3BpYzogTi5wYWlyaW5nVG9waWMsIHJlcXVpcmVkTmFtZXNwYWNlczogTi5yZXF1aXJlZE5hbWVzcGFjZXMsIG9wdGlvbmFsTmFtZXNwYWNlczogTi5vcHRpb25hbE5hbWVzcGFjZXMsIHRyYW5zcG9ydFR5cGU6IGF0LnJlbGF5IH0pO1xuICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24uc2V0KHoudG9waWMsIEIpLCBhd2FpdCB0aGlzLnNldEV4cGlyeSh6LnRvcGljLCB6LmV4cGlyeSksIGQgJiYgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnVwZGF0ZU1ldGFkYXRhKHsgdG9waWM6IGQsIG1ldGFkYXRhOiB6LnBlZXIubWV0YWRhdGEgfSksIHRoaXMuY2xlYW51cER1cGxpY2F0ZVBhaXJpbmdzKEIpLCBqKEIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IEsgPSBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHsgdG9waWM6IGQsIG1ldGhvZDogXCJ3Y19zZXNzaW9uUHJvcG9zZVwiLCBwYXJhbXM6IE4sIHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCB9KTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNldFByb3Bvc2FsKEssIGx0KHsgaWQ6IEsgfSwgTikpLCB7IHVyaTogdiwgYXBwcm92YWw6IFQgfTtcbiAgICB9LCB0aGlzLnBhaXIgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuY29uZmlybU9ubGluZVN0YXRlT3JUaHJvdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyKHQpO1xuICAgICAgfSBjYXRjaCAoaSkge1xuICAgICAgICB0aHJvdyB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoXCJwYWlyKCkgZmFpbGVkXCIpLCBpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuYXBwcm92ZSA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB2YXIgaSwgbiwgcztcbiAgICAgIGNvbnN0IG8gPSB0aGlzLmNsaWVudC5jb3JlLmV2ZW50Q2xpZW50LmNyZWF0ZUV2ZW50KHsgcHJvcGVydGllczogeyB0b3BpYzogKGkgPSB0Py5pZCkgPT0gbnVsbCA/IHZvaWQgMCA6IGkudG9TdHJpbmcoKSwgdHJhY2U6IFt4ci5zZXNzaW9uX2FwcHJvdmVfc3RhcnRlZF0gfSB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmNvbmZpcm1PbmxpbmVTdGF0ZU9yVGhyb3coKTtcbiAgICAgIH0gY2F0Y2ggKFIpIHtcbiAgICAgICAgdGhyb3cgby5zZXRFcnJvcihUaS5ub19pbnRlcm5ldF9jb25uZWN0aW9uKSwgUjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFByb3Bvc2FsSWQodD8uaWQpO1xuICAgICAgfSBjYXRjaCAoUikge1xuICAgICAgICB0aHJvdyB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoYGFwcHJvdmUoKSAtPiBwcm9wb3NhbC5nZXQoJHt0Py5pZH0pIGZhaWxlZGApLCBvLnNldEVycm9yKFRpLnByb3Bvc2FsX25vdF9mb3VuZCksIFI7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmlzVmFsaWRBcHByb3ZlKHQpO1xuICAgICAgfSBjYXRjaCAoUikge1xuICAgICAgICB0aHJvdyB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoXCJhcHByb3ZlKCkgLT4gaXNWYWxpZEFwcHJvdmUoKSBmYWlsZWRcIiksIG8uc2V0RXJyb3IoVGkuc2Vzc2lvbl9hcHByb3ZlX25hbWVzcGFjZV92YWxpZGF0aW9uX2ZhaWx1cmUpLCBSO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBpZDogZiwgcmVsYXlQcm90b2NvbDogaCwgbmFtZXNwYWNlczogZCwgc2Vzc2lvblByb3BlcnRpZXM6IHYsIHNlc3Npb25Db25maWc6IHcgfSA9IHQsIEEgPSB0aGlzLmNsaWVudC5wcm9wb3NhbC5nZXQoZik7XG4gICAgICB0aGlzLmNsaWVudC5jb3JlLmV2ZW50Q2xpZW50LmRlbGV0ZUV2ZW50KHsgZXZlbnRJZDogby5ldmVudElkIH0pO1xuICAgICAgY29uc3QgeyBwYWlyaW5nVG9waWM6IEksIHByb3Bvc2VyOiBELCByZXF1aXJlZE5hbWVzcGFjZXM6IE4sIG9wdGlvbmFsTmFtZXNwYWNlczogayB9ID0gQTtcbiAgICAgIGxldCBqID0gKG4gPSB0aGlzLmNsaWVudC5jb3JlLmV2ZW50Q2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogbi5nZXRFdmVudCh7IHRvcGljOiBJIH0pO1xuICAgICAgaiB8fCAoaiA9IChzID0gdGhpcy5jbGllbnQuY29yZS5ldmVudENsaWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHMuY3JlYXRlRXZlbnQoeyB0eXBlOiB4ci5zZXNzaW9uX2FwcHJvdmVfc3RhcnRlZCwgcHJvcGVydGllczogeyB0b3BpYzogSSwgdHJhY2U6IFt4ci5zZXNzaW9uX2FwcHJvdmVfc3RhcnRlZCwgeHIuc2Vzc2lvbl9uYW1lc3BhY2VzX3ZhbGlkYXRpb25fc3VjY2Vzc10gfSB9KSk7XG4gICAgICBjb25zdCBUID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZ2VuZXJhdGVLZXlQYWlyKCksIEsgPSBELnB1YmxpY0tleSwgJCA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmdlbmVyYXRlU2hhcmVkS2V5KFQsIEspLCB6ID0gbHQobHQoeyByZWxheTogeyBwcm90b2NvbDogaCA/PyBcImlyblwiIH0sIG5hbWVzcGFjZXM6IGQsIGNvbnRyb2xsZXI6IHsgcHVibGljS2V5OiBULCBtZXRhZGF0YTogdGhpcy5jbGllbnQubWV0YWRhdGEgfSwgZXhwaXJ5OiBtdChzbikgfSwgdiAmJiB7IHNlc3Npb25Qcm9wZXJ0aWVzOiB2IH0pLCB3ICYmIHsgc2Vzc2lvbkNvbmZpZzogdyB9KSwgQiA9IGF0LnJlbGF5O1xuICAgICAgai5hZGRUcmFjZSh4ci5zdWJzY3JpYmluZ19zZXNzaW9uX3RvcGljKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5zdWJzY3JpYmUoJCwgeyB0cmFuc3BvcnRUeXBlOiBCIH0pO1xuICAgICAgfSBjYXRjaCAoUikge1xuICAgICAgICB0aHJvdyBqLnNldEVycm9yKFRpLnN1YnNjcmliZV9zZXNzaW9uX3RvcGljX2ZhaWx1cmUpLCBSO1xuICAgICAgfVxuICAgICAgai5hZGRUcmFjZSh4ci5zdWJzY3JpYmVfc2Vzc2lvbl90b3BpY19zdWNjZXNzKTtcbiAgICAgIGNvbnN0IF8gPSBFcihsdCh7fSwgeiksIHsgdG9waWM6ICQsIHJlcXVpcmVkTmFtZXNwYWNlczogTiwgb3B0aW9uYWxOYW1lc3BhY2VzOiBrLCBwYWlyaW5nVG9waWM6IEksIGFja25vd2xlZGdlZDogITEsIHNlbGY6IHouY29udHJvbGxlciwgcGVlcjogeyBwdWJsaWNLZXk6IEQucHVibGljS2V5LCBtZXRhZGF0YTogRC5tZXRhZGF0YSB9LCBjb250cm9sbGVyOiBULCB0cmFuc3BvcnRUeXBlOiBhdC5yZWxheSB9KTtcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24uc2V0KCQsIF8pLCBqLmFkZFRyYWNlKHhyLnN0b3JlX3Nlc3Npb24pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgai5hZGRUcmFjZSh4ci5wdWJsaXNoaW5nX3Nlc3Npb25fc2V0dGxlKSwgYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCh7IHRvcGljOiAkLCBtZXRob2Q6IFwid2Nfc2Vzc2lvblNldHRsZVwiLCBwYXJhbXM6IHosIHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCB9KS5jYXRjaCgoUikgPT4ge1xuICAgICAgICAgIHRocm93IGo/LnNldEVycm9yKFRpLnNlc3Npb25fc2V0dGxlX3B1Ymxpc2hfZmFpbHVyZSksIFI7XG4gICAgICAgIH0pLCBqLmFkZFRyYWNlKHhyLnNlc3Npb25fc2V0dGxlX3B1Ymxpc2hfc3VjY2VzcyksIGouYWRkVHJhY2UoeHIucHVibGlzaGluZ19zZXNzaW9uX2FwcHJvdmUpLCBhd2FpdCB0aGlzLnNlbmRSZXN1bHQoeyBpZDogZiwgdG9waWM6IEksIHJlc3VsdDogeyByZWxheTogeyBwcm90b2NvbDogaCA/PyBcImlyblwiIH0sIHJlc3BvbmRlclB1YmxpY0tleTogVCB9LCB0aHJvd09uRmFpbGVkUHVibGlzaDogITAgfSkuY2F0Y2goKFIpID0+IHtcbiAgICAgICAgICB0aHJvdyBqPy5zZXRFcnJvcihUaS5zZXNzaW9uX2FwcHJvdmVfcHVibGlzaF9mYWlsdXJlKSwgUjtcbiAgICAgICAgfSksIGouYWRkVHJhY2UoeHIuc2Vzc2lvbl9hcHByb3ZlX3B1Ymxpc2hfc3VjY2Vzcyk7XG4gICAgICB9IGNhdGNoIChSKSB7XG4gICAgICAgIHRocm93IHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihSKSwgdGhpcy5jbGllbnQuc2Vzc2lvbi5kZWxldGUoJCwgc3QoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci51bnN1YnNjcmliZSgkKSwgUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jb3JlLmV2ZW50Q2xpZW50LmRlbGV0ZUV2ZW50KHsgZXZlbnRJZDogai5ldmVudElkIH0pLCBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcudXBkYXRlTWV0YWRhdGEoeyB0b3BpYzogSSwgbWV0YWRhdGE6IEQubWV0YWRhdGEgfSksIGF3YWl0IHRoaXMuY2xpZW50LnByb3Bvc2FsLmRlbGV0ZShmLCBzdChcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSwgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLmFjdGl2YXRlKHsgdG9waWM6IEkgfSksIGF3YWl0IHRoaXMuc2V0RXhwaXJ5KCQsIG10KHNuKSksIHsgdG9waWM6ICQsIGFja25vd2xlZGdlZDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KCQpKSB9O1xuICAgIH0sIHRoaXMucmVqZWN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmNvbmZpcm1PbmxpbmVTdGF0ZU9yVGhyb3coKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFJlamVjdCh0KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKFwicmVqZWN0KCkgLT4gaXNWYWxpZFJlamVjdCgpIGZhaWxlZFwiKSwgbztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgaWQ6IGksIHJlYXNvbjogbiB9ID0gdDtcbiAgICAgIGxldCBzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcyA9IHRoaXMuY2xpZW50LnByb3Bvc2FsLmdldChpKS5wYWlyaW5nVG9waWM7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIHRocm93IHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihgcmVqZWN0KCkgLT4gcHJvcG9zYWwuZ2V0KCR7aX0pIGZhaWxlZGApLCBvO1xuICAgICAgfVxuICAgICAgcyAmJiAoYXdhaXQgdGhpcy5zZW5kRXJyb3IoeyBpZDogaSwgdG9waWM6IHMsIGVycm9yOiBuLCBycGNPcHRzOiBfdC53Y19zZXNzaW9uUHJvcG9zZS5yZWplY3QgfSksIGF3YWl0IHRoaXMuY2xpZW50LnByb3Bvc2FsLmRlbGV0ZShpLCBzdChcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSk7XG4gICAgfSwgdGhpcy51cGRhdGUgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuY29uZmlybU9ubGluZVN0YXRlT3JUaHJvdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkVXBkYXRlKHQpO1xuICAgICAgfSBjYXRjaCAodykge1xuICAgICAgICB0aHJvdyB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoXCJ1cGRhdGUoKSAtPiBpc1ZhbGlkVXBkYXRlKCkgZmFpbGVkXCIpLCB3O1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogaSwgbmFtZXNwYWNlczogbiB9ID0gdCwgeyBkb25lOiBzLCByZXNvbHZlOiBvLCByZWplY3Q6IGYgfSA9IExpKCksIGggPSBvaSgpLCBkID0gemkoKS50b1N0cmluZygpLCB2ID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQoaSkubmFtZXNwYWNlcztcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50cy5vbmNlKFhlKFwic2Vzc2lvbl91cGRhdGVcIiwgaCksICh7IGVycm9yOiB3IH0pID0+IHtcbiAgICAgICAgdyA/IGYodykgOiBvKCk7XG4gICAgICB9KSwgYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi51cGRhdGUoaSwgeyBuYW1lc3BhY2VzOiBuIH0pLCBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHsgdG9waWM6IGksIG1ldGhvZDogXCJ3Y19zZXNzaW9uVXBkYXRlXCIsIHBhcmFtczogeyBuYW1lc3BhY2VzOiBuIH0sIHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCwgY2xpZW50UnBjSWQ6IGgsIHJlbGF5UnBjSWQ6IGQgfSkuY2F0Y2goKHcpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKHcpLCB0aGlzLmNsaWVudC5zZXNzaW9uLnVwZGF0ZShpLCB7IG5hbWVzcGFjZXM6IHYgfSksIGYodyk7XG4gICAgICB9KSwgeyBhY2tub3dsZWRnZWQ6IHMgfTtcbiAgICB9LCB0aGlzLmV4dGVuZCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5jb25maXJtT25saW5lU3RhdGVPclRocm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmlzVmFsaWRFeHRlbmQodCk7XG4gICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgIHRocm93IHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihcImV4dGVuZCgpIC0+IGlzVmFsaWRFeHRlbmQoKSBmYWlsZWRcIiksIGg7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBpIH0gPSB0LCBuID0gb2koKSwgeyBkb25lOiBzLCByZXNvbHZlOiBvLCByZWplY3Q6IGYgfSA9IExpKCk7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudHMub25jZShYZShcInNlc3Npb25fZXh0ZW5kXCIsIG4pLCAoeyBlcnJvcjogaCB9KSA9PiB7XG4gICAgICAgIGggPyBmKGgpIDogbygpO1xuICAgICAgfSksIGF3YWl0IHRoaXMuc2V0RXhwaXJ5KGksIG10KHNuKSksIHRoaXMuc2VuZFJlcXVlc3QoeyB0b3BpYzogaSwgbWV0aG9kOiBcIndjX3Nlc3Npb25FeHRlbmRcIiwgcGFyYW1zOiB7fSwgY2xpZW50UnBjSWQ6IG4sIHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCB9KS5jYXRjaCgoaCkgPT4ge1xuICAgICAgICBmKGgpO1xuICAgICAgfSksIHsgYWNrbm93bGVkZ2VkOiBzIH07XG4gICAgfSwgdGhpcy5yZXF1ZXN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkUmVxdWVzdCh0KTtcbiAgICAgIH0gY2F0Y2ggKEQpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKFwicmVxdWVzdCgpIC0+IGlzVmFsaWRSZXF1ZXN0KCkgZmFpbGVkXCIpLCBEO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBjaGFpbklkOiBpLCByZXF1ZXN0OiBuLCB0b3BpYzogcywgZXhwaXJ5OiBvID0gX3Qud2Nfc2Vzc2lvblJlcXVlc3QucmVxLnR0bCB9ID0gdCwgZiA9IHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KHMpO1xuICAgICAgZj8udHJhbnNwb3J0VHlwZSA9PT0gYXQucmVsYXkgJiYgYXdhaXQgdGhpcy5jb25maXJtT25saW5lU3RhdGVPclRocm93KCk7XG4gICAgICBjb25zdCBoID0gb2koKSwgZCA9IHppKCkudG9TdHJpbmcoKSwgeyBkb25lOiB2LCByZXNvbHZlOiB3LCByZWplY3Q6IEEgfSA9IExpKG8sIFwiUmVxdWVzdCBleHBpcmVkLiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgICAgIHRoaXMuZXZlbnRzLm9uY2UoWGUoXCJzZXNzaW9uX3JlcXVlc3RcIiwgaCksICh7IGVycm9yOiBELCByZXN1bHQ6IE4gfSkgPT4ge1xuICAgICAgICBEID8gQShEKSA6IHcoTik7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IEkgPSB0aGlzLmdldEFwcExpbmtJZkVuYWJsZWQoZi5wZWVyLm1ldGFkYXRhLCBmLnRyYW5zcG9ydFR5cGUpO1xuICAgICAgcmV0dXJuIEkgPyAoYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCh7IGNsaWVudFJwY0lkOiBoLCByZWxheVJwY0lkOiBkLCB0b3BpYzogcywgbWV0aG9kOiBcIndjX3Nlc3Npb25SZXF1ZXN0XCIsIHBhcmFtczogeyByZXF1ZXN0OiBFcihsdCh7fSwgbiksIHsgZXhwaXJ5VGltZXN0YW1wOiBtdChvKSB9KSwgY2hhaW5JZDogaSB9LCBleHBpcnk6IG8sIHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCwgYXBwTGluazogSSB9KS5jYXRjaCgoRCkgPT4gQShEKSksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9yZXF1ZXN0X3NlbnRcIiwgeyB0b3BpYzogcywgcmVxdWVzdDogbiwgY2hhaW5JZDogaSwgaWQ6IGggfSksIGF3YWl0IHYoKSkgOiBhd2FpdCBQcm9taXNlLmFsbChbbmV3IFByb21pc2UoYXN5bmMgKEQpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCh7IGNsaWVudFJwY0lkOiBoLCByZWxheVJwY0lkOiBkLCB0b3BpYzogcywgbWV0aG9kOiBcIndjX3Nlc3Npb25SZXF1ZXN0XCIsIHBhcmFtczogeyByZXF1ZXN0OiBFcihsdCh7fSwgbiksIHsgZXhwaXJ5VGltZXN0YW1wOiBtdChvKSB9KSwgY2hhaW5JZDogaSB9LCBleHBpcnk6IG8sIHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCB9KS5jYXRjaCgoTikgPT4gQShOKSksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9yZXF1ZXN0X3NlbnRcIiwgeyB0b3BpYzogcywgcmVxdWVzdDogbiwgY2hhaW5JZDogaSwgaWQ6IGggfSksIEQoKTtcbiAgICAgIH0pLCBuZXcgUHJvbWlzZShhc3luYyAoRCkgPT4ge1xuICAgICAgICB2YXIgTjtcbiAgICAgICAgaWYgKCEoKE4gPSBmLnNlc3Npb25Db25maWcpICE9IG51bGwgJiYgTi5kaXNhYmxlRGVlcExpbmspKSB7XG4gICAgICAgICAgY29uc3QgayA9IGF3YWl0IGN5KHRoaXMuY2xpZW50LmNvcmUuc3RvcmFnZSwgSWgpO1xuICAgICAgICAgIGF3YWl0IG95KHsgaWQ6IGgsIHRvcGljOiBzLCB3Y0RlZXBMaW5rOiBrIH0pO1xuICAgICAgICB9XG4gICAgICAgIEQoKTtcbiAgICAgIH0pLCB2KCldKS50aGVuKChEKSA9PiBEWzJdKTtcbiAgICB9LCB0aGlzLnJlc3BvbmQgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuaXNWYWxpZFJlc3BvbmQodCk7XG4gICAgICBjb25zdCB7IHRvcGljOiBpLCByZXNwb25zZTogbiB9ID0gdCwgeyBpZDogcyB9ID0gbiwgbyA9IHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KGkpO1xuICAgICAgby50cmFuc3BvcnRUeXBlID09PSBhdC5yZWxheSAmJiBhd2FpdCB0aGlzLmNvbmZpcm1PbmxpbmVTdGF0ZU9yVGhyb3coKTtcbiAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEFwcExpbmtJZkVuYWJsZWQoby5wZWVyLm1ldGFkYXRhLCBvLnRyYW5zcG9ydFR5cGUpO1xuICAgICAgUnIobikgPyBhd2FpdCB0aGlzLnNlbmRSZXN1bHQoeyBpZDogcywgdG9waWM6IGksIHJlc3VsdDogbi5yZXN1bHQsIHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCwgYXBwTGluazogZiB9KSA6IGRyKG4pICYmIGF3YWl0IHRoaXMuc2VuZEVycm9yKHsgaWQ6IHMsIHRvcGljOiBpLCBlcnJvcjogbi5lcnJvciwgYXBwTGluazogZiB9KSwgdGhpcy5jbGVhbnVwQWZ0ZXJSZXNwb25zZSh0KTtcbiAgICB9LCB0aGlzLnBpbmcgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuY29uZmlybU9ubGluZVN0YXRlT3JUaHJvdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkUGluZyh0KTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKFwicGluZygpIC0+IGlzVmFsaWRQaW5nKCkgZmFpbGVkXCIpLCBuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogaSB9ID0gdDtcbiAgICAgIGlmICh0aGlzLmNsaWVudC5zZXNzaW9uLmtleXMuaW5jbHVkZXMoaSkpIHtcbiAgICAgICAgY29uc3QgbiA9IG9pKCksIHMgPSB6aSgpLnRvU3RyaW5nKCksIHsgZG9uZTogbywgcmVzb2x2ZTogZiwgcmVqZWN0OiBoIH0gPSBMaSgpO1xuICAgICAgICB0aGlzLmV2ZW50cy5vbmNlKFhlKFwic2Vzc2lvbl9waW5nXCIsIG4pLCAoeyBlcnJvcjogZCB9KSA9PiB7XG4gICAgICAgICAgZCA/IGgoZCkgOiBmKCk7XG4gICAgICAgIH0pLCBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5zZW5kUmVxdWVzdCh7IHRvcGljOiBpLCBtZXRob2Q6IFwid2Nfc2Vzc2lvblBpbmdcIiwgcGFyYW1zOiB7fSwgdGhyb3dPbkZhaWxlZFB1Ymxpc2g6ICEwLCBjbGllbnRScGNJZDogbiwgcmVsYXlScGNJZDogcyB9KSwgbygpXSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXJpbmdzLmtleXMuaW5jbHVkZXMoaSkgJiYgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBpbmcoeyB0b3BpYzogaSB9KTtcbiAgICB9LCB0aGlzLmVtaXQgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuY29uZmlybU9ubGluZVN0YXRlT3JUaHJvdygpLCBhd2FpdCB0aGlzLmlzVmFsaWRFbWl0KHQpO1xuICAgICAgY29uc3QgeyB0b3BpYzogaSwgZXZlbnQ6IG4sIGNoYWluSWQ6IHMgfSA9IHQsIG8gPSB6aSgpLnRvU3RyaW5nKCksIGYgPSBvaSgpO1xuICAgICAgYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCh7IHRvcGljOiBpLCBtZXRob2Q6IFwid2Nfc2Vzc2lvbkV2ZW50XCIsIHBhcmFtczogeyBldmVudDogbiwgY2hhaW5JZDogcyB9LCB0aHJvd09uRmFpbGVkUHVibGlzaDogITAsIHJlbGF5UnBjSWQ6IG8sIGNsaWVudFJwY0lkOiBmIH0pO1xuICAgIH0sIHRoaXMuZGlzY29ubmVjdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5jb25maXJtT25saW5lU3RhdGVPclRocm93KCksIGF3YWl0IHRoaXMuaXNWYWxpZERpc2Nvbm5lY3QodCk7XG4gICAgICBjb25zdCB7IHRvcGljOiBpIH0gPSB0O1xuICAgICAgaWYgKHRoaXMuY2xpZW50LnNlc3Npb24ua2V5cy5pbmNsdWRlcyhpKSlcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCh7IHRvcGljOiBpLCBtZXRob2Q6IFwid2Nfc2Vzc2lvbkRlbGV0ZVwiLCBwYXJhbXM6IHN0KFwiVVNFUl9ESVNDT05ORUNURURcIiksIHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCB9KSwgYXdhaXQgdGhpcy5kZWxldGVTZXNzaW9uKHsgdG9waWM6IGksIGVtaXRFdmVudDogITEgfSk7XG4gICAgICBlbHNlIGlmICh0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyhpKSlcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLmRpc2Nvbm5lY3QoeyB0b3BpYzogaSB9KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IGFlKFwiTUlTTUFUQ0hFRF9UT1BJQ1wiLCBgU2Vzc2lvbiBvciBwYWlyaW5nIHRvcGljIG5vdCBmb3VuZDogJHtpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5maW5kID0gKHQpID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXRBbGwoKS5maWx0ZXIoKGkpID0+IGhtKGksIHQpKSksIHRoaXMuZ2V0UGVuZGluZ1Nlc3Npb25SZXF1ZXN0cyA9ICgpID0+IHRoaXMuY2xpZW50LnBlbmRpbmdSZXF1ZXN0LmdldEFsbCgpLCB0aGlzLmF1dGhlbnRpY2F0ZSA9IGFzeW5jICh0LCBpKSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmlzVmFsaWRBdXRoZW50aWNhdGUodCk7XG4gICAgICBjb25zdCBzID0gaSAmJiB0aGlzLmNsaWVudC5jb3JlLmxpbmtNb2RlU3VwcG9ydGVkQXBwcy5pbmNsdWRlcyhpKSAmJiAoKG4gPSB0aGlzLmNsaWVudC5tZXRhZGF0YS5yZWRpcmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IG4ubGlua01vZGUpLCBvID0gcyA/IGF0LmxpbmtfbW9kZSA6IGF0LnJlbGF5O1xuICAgICAgbyA9PT0gYXQucmVsYXkgJiYgYXdhaXQgdGhpcy5jb25maXJtT25saW5lU3RhdGVPclRocm93KCk7XG4gICAgICBjb25zdCB7IGNoYWluczogZiwgc3RhdGVtZW50OiBoID0gXCJcIiwgdXJpOiBkLCBkb21haW46IHYsIG5vbmNlOiB3LCB0eXBlOiBBLCBleHA6IEksIG5iZjogRCwgbWV0aG9kczogTiA9IFtdLCBleHBpcnk6IGsgfSA9IHQsIGogPSBbLi4udC5yZXNvdXJjZXMgfHwgW11dLCB7IHRvcGljOiBULCB1cmk6IEsgfSA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5jcmVhdGUoeyBtZXRob2RzOiBbXCJ3Y19zZXNzaW9uQXV0aGVudGljYXRlXCJdLCB0cmFuc3BvcnRUeXBlOiBvIH0pO1xuICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oeyBtZXNzYWdlOiBcIkdlbmVyYXRlZCBuZXcgcGFpcmluZ1wiLCBwYWlyaW5nOiB7IHRvcGljOiBULCB1cmk6IEsgfSB9KTtcbiAgICAgIGNvbnN0ICQgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5nZW5lcmF0ZUtleVBhaXIoKSwgeiA9IENzKCQpO1xuICAgICAgaWYgKGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmNsaWVudC5hdXRoLmF1dGhLZXlzLnNldCgkcywgeyByZXNwb25zZVRvcGljOiB6LCBwdWJsaWNLZXk6ICQgfSksIHRoaXMuY2xpZW50LmF1dGgucGFpcmluZ1RvcGljcy5zZXQoeiwgeyB0b3BpYzogeiwgcGFpcmluZ1RvcGljOiBUIH0pXSksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5zdWJzY3JpYmUoeiwgeyB0cmFuc3BvcnRUeXBlOiBvIH0pLCB0aGlzLmNsaWVudC5sb2dnZXIuaW5mbyhgc2VuZGluZyByZXF1ZXN0IHRvIG5ldyBwYWlyaW5nIHRvcGljOiAke1R9YCksIE4ubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB7IG5hbWVzcGFjZTogUyB9ID0gTnMoZlswXSk7XG4gICAgICAgIGxldCB4ID0gUnkoUywgXCJyZXF1ZXN0XCIsIE4pO1xuICAgICAgICBUcyhqKSAmJiAoeCA9IFR5KHgsIGoucG9wKCkpKSwgai5wdXNoKHgpO1xuICAgICAgfVxuICAgICAgY29uc3QgQiA9IGsgJiYgayA+IF90LndjX3Nlc3Npb25BdXRoZW50aWNhdGUucmVxLnR0bCA/IGsgOiBfdC53Y19zZXNzaW9uQXV0aGVudGljYXRlLnJlcS50dGwsIF8gPSB7IGF1dGhQYXlsb2FkOiB7IHR5cGU6IEEgPz8gXCJjYWlwMTIyXCIsIGNoYWluczogZiwgc3RhdGVtZW50OiBoLCBhdWQ6IGQsIGRvbWFpbjogdiwgdmVyc2lvbjogXCIxXCIsIG5vbmNlOiB3LCBpYXQ6ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKSwgZXhwOiBJLCBuYmY6IEQsIHJlc291cmNlczogaiB9LCByZXF1ZXN0ZXI6IHsgcHVibGljS2V5OiAkLCBtZXRhZGF0YTogdGhpcy5jbGllbnQubWV0YWRhdGEgfSwgZXhwaXJ5VGltZXN0YW1wOiBtdChCKSB9LCBSID0geyBlaXAxNTU6IHsgY2hhaW5zOiBmLCBtZXRob2RzOiBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wicGVyc29uYWxfc2lnblwiLCAuLi5OXSldLCBldmVudHM6IFtcImNoYWluQ2hhbmdlZFwiLCBcImFjY291bnRzQ2hhbmdlZFwiXSB9IH0sIEogPSB7IHJlcXVpcmVkTmFtZXNwYWNlczoge30sIG9wdGlvbmFsTmFtZXNwYWNlczogUiwgcmVsYXlzOiBbeyBwcm90b2NvbDogXCJpcm5cIiB9XSwgcGFpcmluZ1RvcGljOiBULCBwcm9wb3NlcjogeyBwdWJsaWNLZXk6ICQsIG1ldGFkYXRhOiB0aGlzLmNsaWVudC5tZXRhZGF0YSB9LCBleHBpcnlUaW1lc3RhbXA6IG10KF90LndjX3Nlc3Npb25Qcm9wb3NlLnJlcS50dGwpIH0sIHsgZG9uZTogUSwgcmVzb2x2ZTogTywgcmVqZWN0OiBwIH0gPSBMaShCLCBcIlJlcXVlc3QgZXhwaXJlZFwiKSwgbCA9IGFzeW5jICh7IGVycm9yOiBTLCBzZXNzaW9uOiB4IH0pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLm9mZihYZShcInNlc3Npb25fcmVxdWVzdFwiLCBjKSwgYSksIFMpXG4gICAgICAgICAgcChTKTtcbiAgICAgICAgZWxzZSBpZiAoeCkge1xuICAgICAgICAgIHguc2VsZi5wdWJsaWNLZXkgPSAkLCBhd2FpdCB0aGlzLmNsaWVudC5zZXNzaW9uLnNldCh4LnRvcGljLCB4KSwgYXdhaXQgdGhpcy5zZXRFeHBpcnkoeC50b3BpYywgeC5leHBpcnkpLCBUICYmIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy51cGRhdGVNZXRhZGF0YSh7IHRvcGljOiBULCBtZXRhZGF0YTogeC5wZWVyLm1ldGFkYXRhIH0pO1xuICAgICAgICAgIGNvbnN0IHUgPSB0aGlzLmNsaWVudC5zZXNzaW9uLmdldCh4LnRvcGljKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLmRlbGV0ZVByb3Bvc2FsKGIpLCBPKHsgc2Vzc2lvbjogdSB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgYSA9IGFzeW5jIChTKSA9PiB7XG4gICAgICAgIHZhciB4LCB1LCBtO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5kZWxldGVQZW5kaW5nQXV0aFJlcXVlc3QoYywgeyBtZXNzYWdlOiBcImZ1bGZpbGxlZFwiLCBjb2RlOiAwIH0pLCBTLmVycm9yKSB7XG4gICAgICAgICAgY29uc3QgcSA9IHN0KFwiV0NfTUVUSE9EX1VOU1VQUE9SVEVEXCIsIFwid2Nfc2Vzc2lvbkF1dGhlbnRpY2F0ZVwiKTtcbiAgICAgICAgICByZXR1cm4gUy5lcnJvci5jb2RlID09PSBxLmNvZGUgPyB2b2lkIDAgOiAodGhpcy5ldmVudHMub2ZmKFhlKFwic2Vzc2lvbl9jb25uZWN0XCIpLCBsKSwgcChTLmVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmRlbGV0ZVByb3Bvc2FsKGIpLCB0aGlzLmV2ZW50cy5vZmYoWGUoXCJzZXNzaW9uX2Nvbm5lY3RcIiksIGwpO1xuICAgICAgICBjb25zdCB7IGNhY2FvczogZywgcmVzcG9uZGVyOiBQIH0gPSBTLnJlc3VsdCwgRyA9IFtdLCBNID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcSBvZiBnKSB7XG4gICAgICAgICAgYXdhaXQgUmMoeyBjYWNhbzogcSwgcHJvamVjdElkOiB0aGlzLmNsaWVudC5jb3JlLnByb2plY3RJZCB9KSB8fCAodGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKHEsIFwiU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWRcIiksIHAoc3QoXCJTRVNTSU9OX1NFVFRMRU1FTlRfRkFJTEVEXCIsIFwiU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWRcIikpKTtcbiAgICAgICAgICBjb25zdCB7IHA6IEwgfSA9IHEsIHkgPSBUcyhMLnJlc291cmNlcyksIEYgPSBbSW8oTC5pc3MpXSwgVyA9IEpzKEwuaXNzKTtcbiAgICAgICAgICBpZiAoeSkge1xuICAgICAgICAgICAgY29uc3QgWSA9IE5jKHkpLCBYID0gVGMoeSk7XG4gICAgICAgICAgICBHLnB1c2goLi4uWSksIEYucHVzaCguLi5YKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBZIG9mIEYpXG4gICAgICAgICAgICBNLnB1c2goYCR7WX06JHtXfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEggPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5nZW5lcmF0ZVNoYXJlZEtleSgkLCBQLnB1YmxpY0tleSk7XG4gICAgICAgIGxldCBDO1xuICAgICAgICBHLmxlbmd0aCA+IDAgJiYgKEMgPSB7IHRvcGljOiBILCBhY2tub3dsZWRnZWQ6ICEwLCBzZWxmOiB7IHB1YmxpY0tleTogJCwgbWV0YWRhdGE6IHRoaXMuY2xpZW50Lm1ldGFkYXRhIH0sIHBlZXI6IFAsIGNvbnRyb2xsZXI6IFAucHVibGljS2V5LCBleHBpcnk6IG10KHNuKSwgcmVxdWlyZWROYW1lc3BhY2VzOiB7fSwgb3B0aW9uYWxOYW1lc3BhY2VzOiB7fSwgcmVsYXk6IHsgcHJvdG9jb2w6IFwiaXJuXCIgfSwgcGFpcmluZ1RvcGljOiBULCBuYW1lc3BhY2VzOiBrYyhbLi4ubmV3IFNldChHKV0sIFsuLi5uZXcgU2V0KE0pXSksIHRyYW5zcG9ydFR5cGU6IG8gfSwgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLnN1YnNjcmliZShILCB7IHRyYW5zcG9ydFR5cGU6IG8gfSksIGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24uc2V0KEgsIEMpLCBUICYmIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy51cGRhdGVNZXRhZGF0YSh7IHRvcGljOiBULCBtZXRhZGF0YTogUC5tZXRhZGF0YSB9KSwgQyA9IHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KEgpKSwgKHggPSB0aGlzLmNsaWVudC5tZXRhZGF0YS5yZWRpcmVjdCkgIT0gbnVsbCAmJiB4LmxpbmtNb2RlICYmICh1ID0gUC5tZXRhZGF0YS5yZWRpcmVjdCkgIT0gbnVsbCAmJiB1LmxpbmtNb2RlICYmIChtID0gUC5tZXRhZGF0YS5yZWRpcmVjdCkgIT0gbnVsbCAmJiBtLnVuaXZlcnNhbCAmJiBpICYmICh0aGlzLmNsaWVudC5jb3JlLmFkZExpbmtNb2RlU3VwcG9ydGVkQXBwKFAubWV0YWRhdGEucmVkaXJlY3QudW5pdmVyc2FsKSwgdGhpcy5jbGllbnQuc2Vzc2lvbi51cGRhdGUoSCwgeyB0cmFuc3BvcnRUeXBlOiBhdC5saW5rX21vZGUgfSkpLCBPKHsgYXV0aHM6IGcsIHNlc3Npb246IEMgfSk7XG4gICAgICB9LCBjID0gb2koKSwgYiA9IG9pKCk7XG4gICAgICB0aGlzLmV2ZW50cy5vbmNlKFhlKFwic2Vzc2lvbl9jb25uZWN0XCIpLCBsKSwgdGhpcy5ldmVudHMub25jZShYZShcInNlc3Npb25fcmVxdWVzdFwiLCBjKSwgYSk7XG4gICAgICBsZXQgRTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgY29uc3QgUyA9IEJpKFwid2Nfc2Vzc2lvbkF1dGhlbnRpY2F0ZVwiLCBfLCBjKTtcbiAgICAgICAgICB0aGlzLmNsaWVudC5jb3JlLmhpc3Rvcnkuc2V0KFQsIFMpO1xuICAgICAgICAgIGNvbnN0IHggPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5lbmNvZGUoXCJcIiwgUywgeyB0eXBlOiBkcywgZW5jb2Rpbmc6IExuIH0pO1xuICAgICAgICAgIEUgPSBFcyhpLCBULCB4KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMuc2VuZFJlcXVlc3QoeyB0b3BpYzogVCwgbWV0aG9kOiBcIndjX3Nlc3Npb25BdXRoZW50aWNhdGVcIiwgcGFyYW1zOiBfLCBleHBpcnk6IHQuZXhwaXJ5LCB0aHJvd09uRmFpbGVkUHVibGlzaDogITAsIGNsaWVudFJwY0lkOiBjIH0pLCB0aGlzLnNlbmRSZXF1ZXN0KHsgdG9waWM6IFQsIG1ldGhvZDogXCJ3Y19zZXNzaW9uUHJvcG9zZVwiLCBwYXJhbXM6IEosIGV4cGlyeTogX3Qud2Nfc2Vzc2lvblByb3Bvc2UucmVxLnR0bCwgdGhyb3dPbkZhaWxlZFB1Ymxpc2g6ICEwLCBjbGllbnRScGNJZDogYiB9KV0pO1xuICAgICAgfSBjYXRjaCAoUykge1xuICAgICAgICB0aHJvdyB0aGlzLmV2ZW50cy5vZmYoWGUoXCJzZXNzaW9uX2Nvbm5lY3RcIiksIGwpLCB0aGlzLmV2ZW50cy5vZmYoWGUoXCJzZXNzaW9uX3JlcXVlc3RcIiwgYyksIGEpLCBTO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0UHJvcG9zYWwoYiwgbHQoeyBpZDogYiB9LCBKKSksIGF3YWl0IHRoaXMuc2V0QXV0aFJlcXVlc3QoYywgeyByZXF1ZXN0OiBFcihsdCh7fSwgXyksIHsgdmVyaWZ5Q29udGV4dDoge30gfSksIHBhaXJpbmdUb3BpYzogVCwgdHJhbnNwb3J0VHlwZTogbyB9KSwgeyB1cmk6IEUgPz8gSywgcmVzcG9uc2U6IFEgfTtcbiAgICB9LCB0aGlzLmFwcHJvdmVTZXNzaW9uQXV0aGVudGljYXRlID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IGksIGF1dGhzOiBuIH0gPSB0LCBzID0gdGhpcy5jbGllbnQuY29yZS5ldmVudENsaWVudC5jcmVhdGVFdmVudCh7IHByb3BlcnRpZXM6IHsgdG9waWM6IGkudG9TdHJpbmcoKSwgdHJhY2U6IFtDaS5hdXRoZW50aWNhdGVkX3Nlc3Npb25fYXBwcm92ZV9zdGFydGVkXSB9IH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICB9IGNhdGNoIChrKSB7XG4gICAgICAgIHRocm93IHMuc2V0RXJyb3IoVW4ubm9faW50ZXJuZXRfY29ubmVjdGlvbiksIGs7XG4gICAgICB9XG4gICAgICBjb25zdCBvID0gdGhpcy5nZXRQZW5kaW5nQXV0aFJlcXVlc3QoaSk7XG4gICAgICBpZiAoIW8pXG4gICAgICAgIHRocm93IHMuc2V0RXJyb3IoVW4uYXV0aGVudGljYXRlZF9zZXNzaW9uX3BlbmRpbmdfcmVxdWVzdF9ub3RfZm91bmQpLCBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHBlbmRpbmcgYXV0aCByZXF1ZXN0IHdpdGggaWQgJHtpfWApO1xuICAgICAgY29uc3QgZiA9IG8udHJhbnNwb3J0VHlwZSB8fCBhdC5yZWxheTtcbiAgICAgIGYgPT09IGF0LnJlbGF5ICYmIGF3YWl0IHRoaXMuY29uZmlybU9ubGluZVN0YXRlT3JUaHJvdygpO1xuICAgICAgY29uc3QgaCA9IG8ucmVxdWVzdGVyLnB1YmxpY0tleSwgZCA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmdlbmVyYXRlS2V5UGFpcigpLCB2ID0gQ3MoaCksIHcgPSB7IHR5cGU6IGhpLCByZWNlaXZlclB1YmxpY0tleTogaCwgc2VuZGVyUHVibGljS2V5OiBkIH0sIEEgPSBbXSwgSSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrIG9mIG4pIHtcbiAgICAgICAgaWYgKCFhd2FpdCBSYyh7IGNhY2FvOiBrLCBwcm9qZWN0SWQ6IHRoaXMuY2xpZW50LmNvcmUucHJvamVjdElkIH0pKSB7XG4gICAgICAgICAgcy5zZXRFcnJvcihVbi5pbnZhbGlkX2NhY2FvKTtcbiAgICAgICAgICBjb25zdCB6ID0gc3QoXCJTRVNTSU9OX1NFVFRMRU1FTlRfRkFJTEVEXCIsIFwiU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWRcIik7XG4gICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5zZW5kRXJyb3IoeyBpZDogaSwgdG9waWM6IHYsIGVycm9yOiB6LCBlbmNvZGVPcHRzOiB3IH0pLCBuZXcgRXJyb3Ioei5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBzLmFkZFRyYWNlKENpLmNhY2Fvc192ZXJpZmllZCk7XG4gICAgICAgIGNvbnN0IHsgcDogaiB9ID0gaywgVCA9IFRzKGoucmVzb3VyY2VzKSwgSyA9IFtJbyhqLmlzcyldLCAkID0gSnMoai5pc3MpO1xuICAgICAgICBpZiAoVCkge1xuICAgICAgICAgIGNvbnN0IHogPSBOYyhUKSwgQiA9IFRjKFQpO1xuICAgICAgICAgIEEucHVzaCguLi56KSwgSy5wdXNoKC4uLkIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgeiBvZiBLKVxuICAgICAgICAgIEkucHVzaChgJHt6fTokeyR9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBEID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZ2VuZXJhdGVTaGFyZWRLZXkoZCwgaCk7XG4gICAgICBzLmFkZFRyYWNlKENpLmNyZWF0ZV9hdXRoZW50aWNhdGVkX3Nlc3Npb25fdG9waWMpO1xuICAgICAgbGV0IE47XG4gICAgICBpZiAoQT8ubGVuZ3RoID4gMCkge1xuICAgICAgICBOID0geyB0b3BpYzogRCwgYWNrbm93bGVkZ2VkOiAhMCwgc2VsZjogeyBwdWJsaWNLZXk6IGQsIG1ldGFkYXRhOiB0aGlzLmNsaWVudC5tZXRhZGF0YSB9LCBwZWVyOiB7IHB1YmxpY0tleTogaCwgbWV0YWRhdGE6IG8ucmVxdWVzdGVyLm1ldGFkYXRhIH0sIGNvbnRyb2xsZXI6IGgsIGV4cGlyeTogbXQoc24pLCBhdXRoZW50aWNhdGlvbjogbiwgcmVxdWlyZWROYW1lc3BhY2VzOiB7fSwgb3B0aW9uYWxOYW1lc3BhY2VzOiB7fSwgcmVsYXk6IHsgcHJvdG9jb2w6IFwiaXJuXCIgfSwgcGFpcmluZ1RvcGljOiBvLnBhaXJpbmdUb3BpYywgbmFtZXNwYWNlczoga2MoWy4uLm5ldyBTZXQoQSldLCBbLi4ubmV3IFNldChJKV0pLCB0cmFuc3BvcnRUeXBlOiBmIH0sIHMuYWRkVHJhY2UoQ2kuc3Vic2NyaWJpbmdfYXV0aGVudGljYXRlZF9zZXNzaW9uX3RvcGljKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnJlbGF5ZXIuc3Vic2NyaWJlKEQsIHsgdHJhbnNwb3J0VHlwZTogZiB9KTtcbiAgICAgICAgfSBjYXRjaCAoaykge1xuICAgICAgICAgIHRocm93IHMuc2V0RXJyb3IoVW4uc3Vic2NyaWJlX2F1dGhlbnRpY2F0ZWRfc2Vzc2lvbl90b3BpY19mYWlsdXJlKSwgaztcbiAgICAgICAgfVxuICAgICAgICBzLmFkZFRyYWNlKENpLnN1YnNjcmliZV9hdXRoZW50aWNhdGVkX3Nlc3Npb25fdG9waWNfc3VjY2VzcyksIGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24uc2V0KEQsIE4pLCBzLmFkZFRyYWNlKENpLnN0b3JlX2F1dGhlbnRpY2F0ZWRfc2Vzc2lvbiksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy51cGRhdGVNZXRhZGF0YSh7IHRvcGljOiBvLnBhaXJpbmdUb3BpYywgbWV0YWRhdGE6IG8ucmVxdWVzdGVyLm1ldGFkYXRhIH0pO1xuICAgICAgfVxuICAgICAgcy5hZGRUcmFjZShDaS5wdWJsaXNoaW5nX2F1dGhlbnRpY2F0ZWRfc2Vzc2lvbl9hcHByb3ZlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFJlc3VsdCh7IHRvcGljOiB2LCBpZDogaSwgcmVzdWx0OiB7IGNhY2FvczogbiwgcmVzcG9uZGVyOiB7IHB1YmxpY0tleTogZCwgbWV0YWRhdGE6IHRoaXMuY2xpZW50Lm1ldGFkYXRhIH0gfSwgZW5jb2RlT3B0czogdywgdGhyb3dPbkZhaWxlZFB1Ymxpc2g6ICEwLCBhcHBMaW5rOiB0aGlzLmdldEFwcExpbmtJZkVuYWJsZWQoby5yZXF1ZXN0ZXIubWV0YWRhdGEsIGYpIH0pO1xuICAgICAgfSBjYXRjaCAoaykge1xuICAgICAgICB0aHJvdyBzLnNldEVycm9yKFVuLmF1dGhlbnRpY2F0ZWRfc2Vzc2lvbl9hcHByb3ZlX3B1Ymxpc2hfZmFpbHVyZSksIGs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuYXV0aC5yZXF1ZXN0cy5kZWxldGUoaSwgeyBtZXNzYWdlOiBcImZ1bGZpbGxlZFwiLCBjb2RlOiAwIH0pLCBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcuYWN0aXZhdGUoeyB0b3BpYzogby5wYWlyaW5nVG9waWMgfSksIHRoaXMuY2xpZW50LmNvcmUuZXZlbnRDbGllbnQuZGVsZXRlRXZlbnQoeyBldmVudElkOiBzLmV2ZW50SWQgfSksIHsgc2Vzc2lvbjogTiB9O1xuICAgIH0sIHRoaXMucmVqZWN0U2Vzc2lvbkF1dGhlbnRpY2F0ZSA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IHsgaWQ6IGksIHJlYXNvbjogbiB9ID0gdCwgcyA9IHRoaXMuZ2V0UGVuZGluZ0F1dGhSZXF1ZXN0KGkpO1xuICAgICAgaWYgKCFzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHBlbmRpbmcgYXV0aCByZXF1ZXN0IHdpdGggaWQgJHtpfWApO1xuICAgICAgcy50cmFuc3BvcnRUeXBlID09PSBhdC5yZWxheSAmJiBhd2FpdCB0aGlzLmNvbmZpcm1PbmxpbmVTdGF0ZU9yVGhyb3coKTtcbiAgICAgIGNvbnN0IG8gPSBzLnJlcXVlc3Rlci5wdWJsaWNLZXksIGYgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5nZW5lcmF0ZUtleVBhaXIoKSwgaCA9IENzKG8pLCBkID0geyB0eXBlOiBoaSwgcmVjZWl2ZXJQdWJsaWNLZXk6IG8sIHNlbmRlclB1YmxpY0tleTogZiB9O1xuICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IoeyBpZDogaSwgdG9waWM6IGgsIGVycm9yOiBuLCBlbmNvZGVPcHRzOiBkLCBycGNPcHRzOiBfdC53Y19zZXNzaW9uQXV0aGVudGljYXRlLnJlamVjdCwgYXBwTGluazogdGhpcy5nZXRBcHBMaW5rSWZFbmFibGVkKHMucmVxdWVzdGVyLm1ldGFkYXRhLCBzLnRyYW5zcG9ydFR5cGUpIH0pLCBhd2FpdCB0aGlzLmNsaWVudC5hdXRoLnJlcXVlc3RzLmRlbGV0ZShpLCB7IG1lc3NhZ2U6IFwicmVqZWN0ZWRcIiwgY29kZTogMCB9KSwgYXdhaXQgdGhpcy5jbGllbnQucHJvcG9zYWwuZGVsZXRlKGksIHN0KFwiVVNFUl9ESVNDT05ORUNURURcIikpO1xuICAgIH0sIHRoaXMuZm9ybWF0QXV0aE1lc3NhZ2UgPSAodCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCB7IHJlcXVlc3Q6IGksIGlzczogbiB9ID0gdDtcbiAgICAgIHJldHVybiBmZChpLCBuKTtcbiAgICB9LCB0aGlzLnByb2Nlc3NSZWxheU1lc3NhZ2VDYWNoZSA9ICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5yZWxheU1lc3NhZ2VDYWNoZS5sZW5ndGggIT09IDApXG4gICAgICAgICAgZm9yICg7IHRoaXMucmVsYXlNZXNzYWdlQ2FjaGUubGVuZ3RoID4gMDsgKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMucmVsYXlNZXNzYWdlQ2FjaGUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgdCAmJiBhd2FpdCB0aGlzLm9uUmVsYXlNZXNzYWdlKHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IodCk7XG4gICAgICAgICAgICB9XG4gICAgICB9LCA1MCk7XG4gICAgfSwgdGhpcy5jbGVhbnVwRHVwbGljYXRlUGFpcmluZ3MgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKHQucGFpcmluZ1RvcGljKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGFpcmluZ3MuZ2V0KHQucGFpcmluZ1RvcGljKSwgbiA9IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyaW5ncy5nZXRBbGwoKS5maWx0ZXIoKHMpID0+IHtcbiAgICAgICAgICAgIHZhciBvLCBmO1xuICAgICAgICAgICAgcmV0dXJuICgobyA9IHMucGVlck1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogby51cmwpICYmICgoZiA9IHMucGVlck1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogZi51cmwpID09PSB0LnBlZXIubWV0YWRhdGEudXJsICYmIHMudG9waWMgJiYgcy50b3BpYyAhPT0gaS50b3BpYztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobi5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oYENsZWFuaW5nIHVwICR7bi5sZW5ndGh9IGR1cGxpY2F0ZSBwYWlyaW5nKHMpYCksIGF3YWl0IFByb21pc2UuYWxsKG4ubWFwKChzKSA9PiB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcuZGlzY29ubmVjdCh7IHRvcGljOiBzLnRvcGljIH0pKSksIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKFwiRHVwbGljYXRlIHBhaXJpbmdzIGNsZWFuIHVwIGZpbmlzaGVkXCIpO1xuICAgICAgICB9IGNhdGNoIChpKSB7XG4gICAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKGkpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcy5kZWxldGVTZXNzaW9uID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHZhciBpO1xuICAgICAgY29uc3QgeyB0b3BpYzogbiwgZXhwaXJlckhhc0RlbGV0ZWQ6IHMgPSAhMSwgZW1pdEV2ZW50OiBvID0gITAsIGlkOiBmID0gMCB9ID0gdCwgeyBzZWxmOiBoIH0gPSB0aGlzLmNsaWVudC5zZXNzaW9uLmdldChuKTtcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci51bnN1YnNjcmliZShuKSwgYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi5kZWxldGUobiwgc3QoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSksIHRoaXMuYWRkVG9SZWNlbnRseURlbGV0ZWQobiwgXCJzZXNzaW9uXCIpLCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5rZXljaGFpbi5oYXMoaC5wdWJsaWNLZXkpICYmIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmRlbGV0ZUtleVBhaXIoaC5wdWJsaWNLZXkpLCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5rZXljaGFpbi5oYXMobikgJiYgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZGVsZXRlU3ltS2V5KG4pLCBzIHx8IHRoaXMuY2xpZW50LmNvcmUuZXhwaXJlci5kZWwobiksIHRoaXMuY2xpZW50LmNvcmUuc3RvcmFnZS5yZW1vdmVJdGVtKEloKS5jYXRjaCgoZCkgPT4gdGhpcy5jbGllbnQubG9nZ2VyLndhcm4oZCkpLCB0aGlzLmdldFBlbmRpbmdTZXNzaW9uUmVxdWVzdHMoKS5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGQudG9waWMgPT09IG4gJiYgdGhpcy5kZWxldGVQZW5kaW5nU2Vzc2lvblJlcXVlc3QoZC5pZCwgc3QoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSk7XG4gICAgICB9KSwgbiA9PT0gKChpID0gdGhpcy5zZXNzaW9uUmVxdWVzdFF1ZXVlLnF1ZXVlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogaS50b3BpYykgJiYgKHRoaXMuc2Vzc2lvblJlcXVlc3RRdWV1ZS5zdGF0ZSA9IFByLmlkbGUpLCBvICYmIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9kZWxldGVcIiwgeyBpZDogZiwgdG9waWM6IG4gfSk7XG4gICAgfSwgdGhpcy5kZWxldGVQcm9wb3NhbCA9IGFzeW5jICh0LCBpKSA9PiB7XG4gICAgICBpZiAoaSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBuID0gdGhpcy5jbGllbnQucHJvcG9zYWwuZ2V0KHQpO1xuICAgICAgICAgIHRoaXMuY2xpZW50LmNvcmUuZXZlbnRDbGllbnQuZ2V0RXZlbnQoeyB0b3BpYzogbi5wYWlyaW5nVG9waWMgfSk/LnNldEVycm9yKFRpLnByb3Bvc2FsX2V4cGlyZWQpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMuY2xpZW50LnByb3Bvc2FsLmRlbGV0ZSh0LCBzdChcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSwgaSA/IFByb21pc2UucmVzb2x2ZSgpIDogdGhpcy5jbGllbnQuY29yZS5leHBpcmVyLmRlbCh0KV0pLCB0aGlzLmFkZFRvUmVjZW50bHlEZWxldGVkKHQsIFwicHJvcG9zYWxcIik7XG4gICAgfSwgdGhpcy5kZWxldGVQZW5kaW5nU2Vzc2lvblJlcXVlc3QgPSBhc3luYyAodCwgaSwgbiA9ICExKSA9PiB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5jbGllbnQucGVuZGluZ1JlcXVlc3QuZGVsZXRlKHQsIGkpLCBuID8gUHJvbWlzZS5yZXNvbHZlKCkgOiB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuZGVsKHQpXSksIHRoaXMuYWRkVG9SZWNlbnRseURlbGV0ZWQodCwgXCJyZXF1ZXN0XCIpLCB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUucXVldWUgPSB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUucXVldWUuZmlsdGVyKChzKSA9PiBzLmlkICE9PSB0KSwgbiAmJiAodGhpcy5zZXNzaW9uUmVxdWVzdFF1ZXVlLnN0YXRlID0gUHIuaWRsZSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX3JlcXVlc3RfZXhwaXJlXCIsIHsgaWQ6IHQgfSkpO1xuICAgIH0sIHRoaXMuZGVsZXRlUGVuZGluZ0F1dGhSZXF1ZXN0ID0gYXN5bmMgKHQsIGksIG4gPSAhMSkgPT4ge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMuY2xpZW50LmF1dGgucmVxdWVzdHMuZGVsZXRlKHQsIGkpLCBuID8gUHJvbWlzZS5yZXNvbHZlKCkgOiB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuZGVsKHQpXSk7XG4gICAgfSwgdGhpcy5zZXRFeHBpcnkgPSBhc3luYyAodCwgaSkgPT4ge1xuICAgICAgdGhpcy5jbGllbnQuc2Vzc2lvbi5rZXlzLmluY2x1ZGVzKHQpICYmICh0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuc2V0KHQsIGkpLCBhd2FpdCB0aGlzLmNsaWVudC5zZXNzaW9uLnVwZGF0ZSh0LCB7IGV4cGlyeTogaSB9KSk7XG4gICAgfSwgdGhpcy5zZXRQcm9wb3NhbCA9IGFzeW5jICh0LCBpKSA9PiB7XG4gICAgICB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuc2V0KHQsIG10KF90LndjX3Nlc3Npb25Qcm9wb3NlLnJlcS50dGwpKSwgYXdhaXQgdGhpcy5jbGllbnQucHJvcG9zYWwuc2V0KHQsIGkpO1xuICAgIH0sIHRoaXMuc2V0QXV0aFJlcXVlc3QgPSBhc3luYyAodCwgaSkgPT4ge1xuICAgICAgY29uc3QgeyByZXF1ZXN0OiBuLCBwYWlyaW5nVG9waWM6IHMsIHRyYW5zcG9ydFR5cGU6IG8gPSBhdC5yZWxheSB9ID0gaTtcbiAgICAgIHRoaXMuY2xpZW50LmNvcmUuZXhwaXJlci5zZXQodCwgbi5leHBpcnlUaW1lc3RhbXApLCBhd2FpdCB0aGlzLmNsaWVudC5hdXRoLnJlcXVlc3RzLnNldCh0LCB7IGF1dGhQYXlsb2FkOiBuLmF1dGhQYXlsb2FkLCByZXF1ZXN0ZXI6IG4ucmVxdWVzdGVyLCBleHBpcnlUaW1lc3RhbXA6IG4uZXhwaXJ5VGltZXN0YW1wLCBpZDogdCwgcGFpcmluZ1RvcGljOiBzLCB2ZXJpZnlDb250ZXh0OiBuLnZlcmlmeUNvbnRleHQsIHRyYW5zcG9ydFR5cGU6IG8gfSk7XG4gICAgfSwgdGhpcy5zZXRQZW5kaW5nU2Vzc2lvblJlcXVlc3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgY29uc3QgeyBpZDogaSwgdG9waWM6IG4sIHBhcmFtczogcywgdmVyaWZ5Q29udGV4dDogbyB9ID0gdCwgZiA9IHMucmVxdWVzdC5leHBpcnlUaW1lc3RhbXAgfHwgbXQoX3Qud2Nfc2Vzc2lvblJlcXVlc3QucmVxLnR0bCk7XG4gICAgICB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuc2V0KGksIGYpLCBhd2FpdCB0aGlzLmNsaWVudC5wZW5kaW5nUmVxdWVzdC5zZXQoaSwgeyBpZDogaSwgdG9waWM6IG4sIHBhcmFtczogcywgdmVyaWZ5Q29udGV4dDogbyB9KTtcbiAgICB9LCB0aGlzLnNlbmRSZXF1ZXN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IGksIG1ldGhvZDogbiwgcGFyYW1zOiBzLCBleHBpcnk6IG8sIHJlbGF5UnBjSWQ6IGYsIGNsaWVudFJwY0lkOiBoLCB0aHJvd09uRmFpbGVkUHVibGlzaDogZCwgYXBwTGluazogdiB9ID0gdCwgdyA9IEJpKG4sIHMsIGgpO1xuICAgICAgbGV0IEE7XG4gICAgICBjb25zdCBJID0gISF2O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgayA9IEkgPyBMbiA6IHdpO1xuICAgICAgICBBID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZW5jb2RlKGksIHcsIHsgZW5jb2Rpbmc6IGsgfSk7XG4gICAgICB9IGNhdGNoIChrKSB7XG4gICAgICAgIHRocm93IGF3YWl0IHRoaXMuY2xlYW51cCgpLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoYHNlbmRSZXF1ZXN0KCkgLT4gY29yZS5jcnlwdG8uZW5jb2RlKCkgZm9yIHRvcGljICR7aX0gZmFpbGVkYCksIGs7XG4gICAgICB9XG4gICAgICBsZXQgRDtcbiAgICAgIGlmICh0NS5pbmNsdWRlcyhuKSkge1xuICAgICAgICBjb25zdCBrID0gZmkoSlNPTi5zdHJpbmdpZnkodykpLCBqID0gZmkoQSk7XG4gICAgICAgIEQgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnZlcmlmeS5yZWdpc3Rlcih7IGlkOiBqLCBkZWNyeXB0ZWRJZDogayB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IE4gPSBfdFtuXS5yZXE7XG4gICAgICBpZiAoTi5hdHRlc3RhdGlvbiA9IEQsIG8gJiYgKE4udHRsID0gbyksIGYgJiYgKE4uaWQgPSBmKSwgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LnNldChpLCB3KSwgSSkge1xuICAgICAgICBjb25zdCBrID0gRXModiwgaSwgQSk7XG4gICAgICAgIGF3YWl0IGdsb2JhbC5MaW5raW5nLm9wZW5VUkwoaywgdGhpcy5jbGllbnQubmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrID0gX3Rbbl0ucmVxO1xuICAgICAgICBvICYmIChrLnR0bCA9IG8pLCBmICYmIChrLmlkID0gZiksIGQgPyAoay5pbnRlcm5hbCA9IEVyKGx0KHt9LCBrLmludGVybmFsKSwgeyB0aHJvd09uRmFpbGVkUHVibGlzaDogITAgfSksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5wdWJsaXNoKGksIEEsIGspKSA6IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5wdWJsaXNoKGksIEEsIGspLmNhdGNoKChqKSA9PiB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoaikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHcuaWQ7XG4gICAgfSwgdGhpcy5zZW5kUmVzdWx0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IGksIHRvcGljOiBuLCByZXN1bHQ6IHMsIHRocm93T25GYWlsZWRQdWJsaXNoOiBvLCBlbmNvZGVPcHRzOiBmLCBhcHBMaW5rOiBoIH0gPSB0LCBkID0gTWEoaSwgcyk7XG4gICAgICBsZXQgdjtcbiAgICAgIGNvbnN0IHcgPSBoICYmIHR5cGVvZiAoZ2xvYmFsID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWwuTGlua2luZykgPCBcInVcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IEkgPSB3ID8gTG4gOiB3aTtcbiAgICAgICAgdiA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmVuY29kZShuLCBkLCBFcihsdCh7fSwgZiB8fCB7fSksIHsgZW5jb2Rpbmc6IEkgfSkpO1xuICAgICAgfSBjYXRjaCAoSSkge1xuICAgICAgICB0aHJvdyBhd2FpdCB0aGlzLmNsZWFudXAoKSwgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKGBzZW5kUmVzdWx0KCkgLT4gY29yZS5jcnlwdG8uZW5jb2RlKCkgZm9yIHRvcGljICR7bn0gZmFpbGVkYCksIEk7XG4gICAgICB9XG4gICAgICBsZXQgQTtcbiAgICAgIHRyeSB7XG4gICAgICAgIEEgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmhpc3RvcnkuZ2V0KG4sIGkpO1xuICAgICAgfSBjYXRjaCAoSSkge1xuICAgICAgICB0aHJvdyB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoYHNlbmRSZXN1bHQoKSAtPiBoaXN0b3J5LmdldCgke259LCAke2l9KSBmYWlsZWRgKSwgSTtcbiAgICAgIH1cbiAgICAgIGlmICh3KSB7XG4gICAgICAgIGNvbnN0IEkgPSBFcyhoLCBuLCB2KTtcbiAgICAgICAgYXdhaXQgZ2xvYmFsLkxpbmtpbmcub3BlblVSTChJLCB0aGlzLmNsaWVudC5uYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IEkgPSBfdFtBLnJlcXVlc3QubWV0aG9kXS5yZXM7XG4gICAgICAgIG8gPyAoSS5pbnRlcm5hbCA9IEVyKGx0KHt9LCBJLmludGVybmFsKSwgeyB0aHJvd09uRmFpbGVkUHVibGlzaDogITAgfSksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5wdWJsaXNoKG4sIHYsIEkpKSA6IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5wdWJsaXNoKG4sIHYsIEkpLmNhdGNoKChEKSA9PiB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoRCkpO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LnJlc29sdmUoZCk7XG4gICAgfSwgdGhpcy5zZW5kRXJyb3IgPSBhc3luYyAodCkgPT4ge1xuICAgICAgY29uc3QgeyBpZDogaSwgdG9waWM6IG4sIGVycm9yOiBzLCBlbmNvZGVPcHRzOiBvLCBycGNPcHRzOiBmLCBhcHBMaW5rOiBoIH0gPSB0LCBkID0gSWEoaSwgcyk7XG4gICAgICBsZXQgdjtcbiAgICAgIGNvbnN0IHcgPSBoICYmIHR5cGVvZiAoZ2xvYmFsID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWwuTGlua2luZykgPCBcInVcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IEkgPSB3ID8gTG4gOiB3aTtcbiAgICAgICAgdiA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmVuY29kZShuLCBkLCBFcihsdCh7fSwgbyB8fCB7fSksIHsgZW5jb2Rpbmc6IEkgfSkpO1xuICAgICAgfSBjYXRjaCAoSSkge1xuICAgICAgICB0aHJvdyBhd2FpdCB0aGlzLmNsZWFudXAoKSwgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKGBzZW5kRXJyb3IoKSAtPiBjb3JlLmNyeXB0by5lbmNvZGUoKSBmb3IgdG9waWMgJHtufSBmYWlsZWRgKSwgSTtcbiAgICAgIH1cbiAgICAgIGxldCBBO1xuICAgICAgdHJ5IHtcbiAgICAgICAgQSA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuaGlzdG9yeS5nZXQobiwgaSk7XG4gICAgICB9IGNhdGNoIChJKSB7XG4gICAgICAgIHRocm93IHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihgc2VuZEVycm9yKCkgLT4gaGlzdG9yeS5nZXQoJHtufSwgJHtpfSkgZmFpbGVkYCksIEk7XG4gICAgICB9XG4gICAgICBpZiAodykge1xuICAgICAgICBjb25zdCBJID0gRXMoaCwgbiwgdik7XG4gICAgICAgIGF3YWl0IGdsb2JhbC5MaW5raW5nLm9wZW5VUkwoSSwgdGhpcy5jbGllbnQubmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBJID0gZiB8fCBfdFtBLnJlcXVlc3QubWV0aG9kXS5yZXM7XG4gICAgICAgIHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5wdWJsaXNoKG4sIHYsIEkpO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LnJlc29sdmUoZCk7XG4gICAgfSwgdGhpcy5jbGVhbnVwID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IFtdLCBpID0gW107XG4gICAgICB0aGlzLmNsaWVudC5zZXNzaW9uLmdldEFsbCgpLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgbGV0IHMgPSAhMTtcbiAgICAgICAgZ2kobi5leHBpcnkpICYmIChzID0gITApLCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5rZXljaGFpbi5oYXMobi50b3BpYykgfHwgKHMgPSAhMCksIHMgJiYgdC5wdXNoKG4udG9waWMpO1xuICAgICAgfSksIHRoaXMuY2xpZW50LnByb3Bvc2FsLmdldEFsbCgpLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgZ2kobi5leHBpcnlUaW1lc3RhbXApICYmIGkucHVzaChuLmlkKTtcbiAgICAgIH0pLCBhd2FpdCBQcm9taXNlLmFsbChbLi4udC5tYXAoKG4pID0+IHRoaXMuZGVsZXRlU2Vzc2lvbih7IHRvcGljOiBuIH0pKSwgLi4uaS5tYXAoKG4pID0+IHRoaXMuZGVsZXRlUHJvcG9zYWwobikpXSk7XG4gICAgfSwgdGhpcy5vblJlbGF5RXZlbnRSZXF1ZXN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLnF1ZXVlLnB1c2godCksIGF3YWl0IHRoaXMucHJvY2Vzc1JlcXVlc3RzUXVldWUoKTtcbiAgICB9LCB0aGlzLnByb2Nlc3NSZXF1ZXN0c1F1ZXVlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVxdWVzdFF1ZXVlLnN0YXRlID09PSBQci5hY3RpdmUpIHtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oXCJSZXF1ZXN0IHF1ZXVlIGFscmVhZHkgYWN0aXZlLCBza2lwcGluZy4uLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh0aGlzLmNsaWVudC5sb2dnZXIuaW5mbyhgUmVxdWVzdCBxdWV1ZSBzdGFydGluZyB3aXRoICR7dGhpcy5yZXF1ZXN0UXVldWUucXVldWUubGVuZ3RofSByZXF1ZXN0c2ApOyB0aGlzLnJlcXVlc3RRdWV1ZS5xdWV1ZS5sZW5ndGggPiAwOyApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuc3RhdGUgPSBQci5hY3RpdmU7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLnJlcXVlc3RRdWV1ZS5xdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAodClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzUmVxdWVzdCh0KTtcbiAgICAgICAgICB9IGNhdGNoIChpKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIud2FybihpKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5zdGF0ZSA9IFByLmlkbGU7XG4gICAgfSwgdGhpcy5wcm9jZXNzUmVxdWVzdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiBpLCBwYXlsb2FkOiBuLCBhdHRlc3RhdGlvbjogcywgdHJhbnNwb3J0VHlwZTogbywgZW5jcnlwdGVkSWQ6IGYgfSA9IHQsIGggPSBuLm1ldGhvZDtcbiAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVQYWlyaW5nUmVxdWVzdCh7IHRvcGljOiBpLCByZXF1ZXN0TWV0aG9kOiBoIH0pKVxuICAgICAgICBzd2l0Y2ggKGgpIHtcbiAgICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblByb3Bvc2VcIjpcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uU2Vzc2lvblByb3Bvc2VSZXF1ZXN0KHsgdG9waWM6IGksIHBheWxvYWQ6IG4sIGF0dGVzdGF0aW9uOiBzLCBlbmNyeXB0ZWRJZDogZiB9KTtcbiAgICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblNldHRsZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub25TZXNzaW9uU2V0dGxlUmVxdWVzdChpLCBuKTtcbiAgICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblVwZGF0ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub25TZXNzaW9uVXBkYXRlUmVxdWVzdChpLCBuKTtcbiAgICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvbkV4dGVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub25TZXNzaW9uRXh0ZW5kUmVxdWVzdChpLCBuKTtcbiAgICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblBpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uU2Vzc2lvblBpbmdSZXF1ZXN0KGksIG4pO1xuICAgICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uRGVsZXRlXCI6XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vblNlc3Npb25EZWxldGVSZXF1ZXN0KGksIG4pO1xuICAgICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uUmVxdWVzdFwiOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub25TZXNzaW9uUmVxdWVzdCh7IHRvcGljOiBpLCBwYXlsb2FkOiBuLCBhdHRlc3RhdGlvbjogcywgZW5jcnlwdGVkSWQ6IGYsIHRyYW5zcG9ydFR5cGU6IG8gfSk7XG4gICAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25FdmVudFwiOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub25TZXNzaW9uRXZlbnRSZXF1ZXN0KGksIG4pO1xuICAgICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uQXV0aGVudGljYXRlXCI6XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vblNlc3Npb25BdXRoZW50aWNhdGVSZXF1ZXN0KHsgdG9waWM6IGksIHBheWxvYWQ6IG4sIGF0dGVzdGF0aW9uOiBzLCBlbmNyeXB0ZWRJZDogZiwgdHJhbnNwb3J0VHlwZTogbyB9KTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKGBVbnN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZCAke2h9YCk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzLm9uUmVsYXlFdmVudFJlc3BvbnNlID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IGksIHBheWxvYWQ6IG4sIHRyYW5zcG9ydFR5cGU6IHMgfSA9IHQsIG8gPSAoYXdhaXQgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LmdldChpLCBuLmlkKSkucmVxdWVzdC5tZXRob2Q7XG4gICAgICBzd2l0Y2ggKG8pIHtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25Qcm9wb3NlXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlKGksIG4sIHMpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblNldHRsZVwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblNldHRsZVJlc3BvbnNlKGksIG4pO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblVwZGF0ZVwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblVwZGF0ZVJlc3BvbnNlKGksIG4pO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvbkV4dGVuZFwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvbkV4dGVuZFJlc3BvbnNlKGksIG4pO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblBpbmdcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25QaW5nUmVzcG9uc2UoaSwgbik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uUmVxdWVzdFwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblJlcXVlc3RSZXNwb25zZShpLCBuKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25BdXRoZW50aWNhdGVcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25BdXRoZW50aWNhdGVSZXNwb25zZShpLCBuKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oYFVuc3VwcG9ydGVkIHJlc3BvbnNlIG1ldGhvZCAke299YCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblJlbGF5RXZlbnRVbmtub3duUGF5bG9hZCA9ICh0KSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiBpIH0gPSB0LCB7IG1lc3NhZ2U6IG4gfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBEZWNvZGVkIHBheWxvYWQgb24gdG9waWMgJHtpfSBpcyBub3QgaWRlbnRpZmlhYmxlIGFzIGEgSlNPTi1SUEMgcmVxdWVzdCBvciBhIHJlc3BvbnNlLmApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG4pO1xuICAgIH0sIHRoaXMuc2hvdWxkSWdub3JlUGFpcmluZ1JlcXVlc3QgPSAodCkgPT4ge1xuICAgICAgY29uc3QgeyB0b3BpYzogaSwgcmVxdWVzdE1ldGhvZDogbiB9ID0gdCwgcyA9IHRoaXMuZXhwZWN0ZWRQYWlyaW5nTWV0aG9kTWFwLmdldChpKTtcbiAgICAgIHJldHVybiAhcyB8fCBzLmluY2x1ZGVzKG4pID8gITEgOiAhIShzLmluY2x1ZGVzKFwid2Nfc2Vzc2lvbkF1dGhlbnRpY2F0ZVwiKSAmJiB0aGlzLmNsaWVudC5ldmVudHMubGlzdGVuZXJDb3VudChcInNlc3Npb25fYXV0aGVudGljYXRlXCIpID4gMCk7XG4gICAgfSwgdGhpcy5vblNlc3Npb25Qcm9wb3NlUmVxdWVzdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiBpLCBwYXlsb2FkOiBuLCBhdHRlc3RhdGlvbjogcywgZW5jcnlwdGVkSWQ6IG8gfSA9IHQsIHsgcGFyYW1zOiBmLCBpZDogaCB9ID0gbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmNsaWVudC5jb3JlLmV2ZW50Q2xpZW50LmdldEV2ZW50KHsgdG9waWM6IGkgfSk7XG4gICAgICAgIHRoaXMuY2xpZW50LmV2ZW50cy5saXN0ZW5lckNvdW50KFwic2Vzc2lvbl9wcm9wb3NhbFwiKSA9PT0gMCAmJiAoY29uc29sZS53YXJuKFwiTm8gbGlzdGVuZXIgZm9yIHNlc3Npb25fcHJvcG9zYWwgZXZlbnRcIiksIGQ/LnNldEVycm9yKGFpLnByb3Bvc2FsX2xpc3RlbmVyX25vdF9mb3VuZCkpLCB0aGlzLmlzVmFsaWRDb25uZWN0KGx0KHt9LCBuLnBhcmFtcykpO1xuICAgICAgICBjb25zdCB2ID0gZi5leHBpcnlUaW1lc3RhbXAgfHwgbXQoX3Qud2Nfc2Vzc2lvblByb3Bvc2UucmVxLnR0bCksIHcgPSBsdCh7IGlkOiBoLCBwYWlyaW5nVG9waWM6IGksIGV4cGlyeVRpbWVzdGFtcDogdiB9LCBmKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRQcm9wb3NhbChoLCB3KTtcbiAgICAgICAgY29uc3QgQSA9IGF3YWl0IHRoaXMuZ2V0VmVyaWZ5Q29udGV4dCh7IGF0dGVzdGF0aW9uSWQ6IHMsIGhhc2g6IGZpKEpTT04uc3RyaW5naWZ5KG4pKSwgZW5jcnlwdGVkSWQ6IG8sIG1ldGFkYXRhOiB3LnByb3Bvc2VyLm1ldGFkYXRhIH0pO1xuICAgICAgICBkPy5hZGRUcmFjZShPci5lbWl0X3Nlc3Npb25fcHJvcG9zYWwpLCB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInNlc3Npb25fcHJvcG9zYWxcIiwgeyBpZDogaCwgcGFyYW1zOiB3LCB2ZXJpZnlDb250ZXh0OiBBIH0pO1xuICAgICAgfSBjYXRjaCAoZCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcih7IGlkOiBoLCB0b3BpYzogaSwgZXJyb3I6IGQsIHJwY09wdHM6IF90LndjX3Nlc3Npb25Qcm9wb3NlLmF1dG9SZWplY3QgfSksIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihkKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uU2Vzc2lvblByb3Bvc2VSZXNwb25zZSA9IGFzeW5jICh0LCBpLCBuKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiBzIH0gPSBpO1xuICAgICAgaWYgKFJyKGkpKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0OiBvIH0gPSBpO1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwib25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlXCIsIHJlc3VsdDogbyB9KTtcbiAgICAgICAgY29uc3QgZiA9IHRoaXMuY2xpZW50LnByb3Bvc2FsLmdldChzKTtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcIm9uU2Vzc2lvblByb3Bvc2VSZXNwb25zZVwiLCBwcm9wb3NhbDogZiB9KTtcbiAgICAgICAgY29uc3QgaCA9IGYucHJvcG9zZXIucHVibGljS2V5O1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwib25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlXCIsIHNlbGZQdWJsaWNLZXk6IGggfSk7XG4gICAgICAgIGNvbnN0IGQgPSBvLnJlc3BvbmRlclB1YmxpY0tleTtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcIm9uU2Vzc2lvblByb3Bvc2VSZXNwb25zZVwiLCBwZWVyUHVibGljS2V5OiBkIH0pO1xuICAgICAgICBjb25zdCB2ID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZ2VuZXJhdGVTaGFyZWRLZXkoaCwgZCk7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJvblNlc3Npb25Qcm9wb3NlUmVzcG9uc2VcIiwgc2Vzc2lvblRvcGljOiB2IH0pO1xuICAgICAgICBjb25zdCB3ID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLnN1YnNjcmliZSh2LCB7IHRyYW5zcG9ydFR5cGU6IG4gfSk7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJvblNlc3Npb25Qcm9wb3NlUmVzcG9uc2VcIiwgc3Vic2NyaXB0aW9uSWQ6IHcgfSksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5hY3RpdmF0ZSh7IHRvcGljOiB0IH0pO1xuICAgICAgfSBlbHNlIGlmIChkcihpKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5wcm9wb3NhbC5kZWxldGUocywgc3QoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSk7XG4gICAgICAgIGNvbnN0IG8gPSBYZShcInNlc3Npb25fY29ubmVjdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmxpc3RlbmVyQ291bnQobykgPT09IDApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbWl0dGluZyAke299IHdpdGhvdXQgYW55IGxpc3RlbmVycywgOTU0YCk7XG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoWGUoXCJzZXNzaW9uX2Nvbm5lY3RcIiksIHsgZXJyb3I6IGkuZXJyb3IgfSk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblNlc3Npb25TZXR0bGVSZXF1ZXN0ID0gYXN5bmMgKHQsIGkpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IG4sIHBhcmFtczogcyB9ID0gaTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZFNlc3Npb25TZXR0bGVSZXF1ZXN0KHMpO1xuICAgICAgICBjb25zdCB7IHJlbGF5OiBvLCBjb250cm9sbGVyOiBmLCBleHBpcnk6IGgsIG5hbWVzcGFjZXM6IGQsIHNlc3Npb25Qcm9wZXJ0aWVzOiB2LCBzZXNzaW9uQ29uZmlnOiB3IH0gPSBpLnBhcmFtcywgQSA9IEVyKGx0KGx0KHsgdG9waWM6IHQsIHJlbGF5OiBvLCBleHBpcnk6IGgsIG5hbWVzcGFjZXM6IGQsIGFja25vd2xlZGdlZDogITAsIHBhaXJpbmdUb3BpYzogXCJcIiwgcmVxdWlyZWROYW1lc3BhY2VzOiB7fSwgb3B0aW9uYWxOYW1lc3BhY2VzOiB7fSwgY29udHJvbGxlcjogZi5wdWJsaWNLZXksIHNlbGY6IHsgcHVibGljS2V5OiBcIlwiLCBtZXRhZGF0YTogdGhpcy5jbGllbnQubWV0YWRhdGEgfSwgcGVlcjogeyBwdWJsaWNLZXk6IGYucHVibGljS2V5LCBtZXRhZGF0YTogZi5tZXRhZGF0YSB9IH0sIHYgJiYgeyBzZXNzaW9uUHJvcGVydGllczogdiB9KSwgdyAmJiB7IHNlc3Npb25Db25maWc6IHcgfSksIHsgdHJhbnNwb3J0VHlwZTogYXQucmVsYXkgfSksIEkgPSBYZShcInNlc3Npb25fY29ubmVjdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmxpc3RlbmVyQ291bnQoSSkgPT09IDApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbWl0dGluZyAke0l9IHdpdGhvdXQgYW55IGxpc3RlbmVycyA5OTdgKTtcbiAgICAgICAgdGhpcy5ldmVudHMuZW1pdChYZShcInNlc3Npb25fY29ubmVjdFwiKSwgeyBzZXNzaW9uOiBBIH0pLCBhd2FpdCB0aGlzLnNlbmRSZXN1bHQoeyBpZDogaS5pZCwgdG9waWM6IHQsIHJlc3VsdDogITAsIHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IoeyBpZDogbiwgdG9waWM6IHQsIGVycm9yOiBvIH0pLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iobyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblNlc3Npb25TZXR0bGVSZXNwb25zZSA9IGFzeW5jICh0LCBpKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiBuIH0gPSBpO1xuICAgICAgUnIoaSkgPyAoYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi51cGRhdGUodCwgeyBhY2tub3dsZWRnZWQ6ICEwIH0pLCB0aGlzLmV2ZW50cy5lbWl0KFhlKFwic2Vzc2lvbl9hcHByb3ZlXCIsIG4pLCB7fSkpIDogZHIoaSkgJiYgKGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24uZGVsZXRlKHQsIHN0KFwiVVNFUl9ESVNDT05ORUNURURcIikpLCB0aGlzLmV2ZW50cy5lbWl0KFhlKFwic2Vzc2lvbl9hcHByb3ZlXCIsIG4pLCB7IGVycm9yOiBpLmVycm9yIH0pKTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvblVwZGF0ZVJlcXVlc3QgPSBhc3luYyAodCwgaSkgPT4ge1xuICAgICAgY29uc3QgeyBwYXJhbXM6IG4sIGlkOiBzIH0gPSBpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbyA9IGAke3R9X3Nlc3Npb25fdXBkYXRlYCwgZiA9IEZuLmdldChvKTtcbiAgICAgICAgaWYgKGYgJiYgdGhpcy5pc1JlcXVlc3RPdXRPZlN5bmMoZiwgcykpIHtcbiAgICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIud2FybihgRGlzY2FyZGluZyBvdXQgb2Ygc3luYyByZXF1ZXN0IC0gJHtzfWApLCB0aGlzLnNlbmRFcnJvcih7IGlkOiBzLCB0b3BpYzogdCwgZXJyb3I6IHN0KFwiSU5WQUxJRF9VUERBVEVfUkVRVUVTVFwiKSB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1ZhbGlkVXBkYXRlKGx0KHsgdG9waWM6IHQgfSwgbikpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZuLnNldChvLCBzKSwgYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi51cGRhdGUodCwgeyBuYW1lc3BhY2VzOiBuLm5hbWVzcGFjZXMgfSksIGF3YWl0IHRoaXMuc2VuZFJlc3VsdCh7IGlkOiBzLCB0b3BpYzogdCwgcmVzdWx0OiAhMCwgdGhyb3dPbkZhaWxlZFB1Ymxpc2g6ICEwIH0pO1xuICAgICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgICAgdGhyb3cgRm4uZGVsZXRlKG8pLCBoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl91cGRhdGVcIiwgeyBpZDogcywgdG9waWM6IHQsIHBhcmFtczogbiB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IoeyBpZDogcywgdG9waWM6IHQsIGVycm9yOiBvIH0pLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iobyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc1JlcXVlc3RPdXRPZlN5bmMgPSAodCwgaSkgPT4gaS50b1N0cmluZygpLnNsaWNlKDAsIC0zKSA8IHQudG9TdHJpbmcoKS5zbGljZSgwLCAtMyksIHRoaXMub25TZXNzaW9uVXBkYXRlUmVzcG9uc2UgPSAodCwgaSkgPT4ge1xuICAgICAgY29uc3QgeyBpZDogbiB9ID0gaSwgcyA9IFhlKFwic2Vzc2lvbl91cGRhdGVcIiwgbik7XG4gICAgICBpZiAodGhpcy5ldmVudHMubGlzdGVuZXJDb3VudChzKSA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbWl0dGluZyAke3N9IHdpdGhvdXQgYW55IGxpc3RlbmVyc2ApO1xuICAgICAgUnIoaSkgPyB0aGlzLmV2ZW50cy5lbWl0KFhlKFwic2Vzc2lvbl91cGRhdGVcIiwgbiksIHt9KSA6IGRyKGkpICYmIHRoaXMuZXZlbnRzLmVtaXQoWGUoXCJzZXNzaW9uX3VwZGF0ZVwiLCBuKSwgeyBlcnJvcjogaS5lcnJvciB9KTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvbkV4dGVuZFJlcXVlc3QgPSBhc3luYyAodCwgaSkgPT4ge1xuICAgICAgY29uc3QgeyBpZDogbiB9ID0gaTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZEV4dGVuZCh7IHRvcGljOiB0IH0pLCBhd2FpdCB0aGlzLnNldEV4cGlyeSh0LCBtdChzbikpLCBhd2FpdCB0aGlzLnNlbmRSZXN1bHQoeyBpZDogbiwgdG9waWM6IHQsIHJlc3VsdDogITAsIHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCB9KSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX2V4dGVuZFwiLCB7IGlkOiBuLCB0b3BpYzogdCB9KTtcbiAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IoeyBpZDogbiwgdG9waWM6IHQsIGVycm9yOiBzIH0pLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iocyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblNlc3Npb25FeHRlbmRSZXNwb25zZSA9ICh0LCBpKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiBuIH0gPSBpLCBzID0gWGUoXCJzZXNzaW9uX2V4dGVuZFwiLCBuKTtcbiAgICAgIGlmICh0aGlzLmV2ZW50cy5saXN0ZW5lckNvdW50KHMpID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVtaXR0aW5nICR7c30gd2l0aG91dCBhbnkgbGlzdGVuZXJzYCk7XG4gICAgICBScihpKSA/IHRoaXMuZXZlbnRzLmVtaXQoWGUoXCJzZXNzaW9uX2V4dGVuZFwiLCBuKSwge30pIDogZHIoaSkgJiYgdGhpcy5ldmVudHMuZW1pdChYZShcInNlc3Npb25fZXh0ZW5kXCIsIG4pLCB7IGVycm9yOiBpLmVycm9yIH0pO1xuICAgIH0sIHRoaXMub25TZXNzaW9uUGluZ1JlcXVlc3QgPSBhc3luYyAodCwgaSkgPT4ge1xuICAgICAgY29uc3QgeyBpZDogbiB9ID0gaTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZFBpbmcoeyB0b3BpYzogdCB9KSwgYXdhaXQgdGhpcy5zZW5kUmVzdWx0KHsgaWQ6IG4sIHRvcGljOiB0LCByZXN1bHQ6ICEwLCB0aHJvd09uRmFpbGVkUHVibGlzaDogITAgfSksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9waW5nXCIsIHsgaWQ6IG4sIHRvcGljOiB0IH0pO1xuICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcih7IGlkOiBuLCB0b3BpYzogdCwgZXJyb3I6IHMgfSksIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihzKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uU2Vzc2lvblBpbmdSZXNwb25zZSA9ICh0LCBpKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiBuIH0gPSBpLCBzID0gWGUoXCJzZXNzaW9uX3BpbmdcIiwgbik7XG4gICAgICBpZiAodGhpcy5ldmVudHMubGlzdGVuZXJDb3VudChzKSA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbWl0dGluZyAke3N9IHdpdGhvdXQgYW55IGxpc3RlbmVyc2ApO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIFJyKGkpID8gdGhpcy5ldmVudHMuZW1pdChYZShcInNlc3Npb25fcGluZ1wiLCBuKSwge30pIDogZHIoaSkgJiYgdGhpcy5ldmVudHMuZW1pdChYZShcInNlc3Npb25fcGluZ1wiLCBuKSwgeyBlcnJvcjogaS5lcnJvciB9KTtcbiAgICAgIH0sIDUwMCk7XG4gICAgfSwgdGhpcy5vblNlc3Npb25EZWxldGVSZXF1ZXN0ID0gYXN5bmMgKHQsIGkpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IG4gfSA9IGk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWREaXNjb25uZWN0KHsgdG9waWM6IHQsIHJlYXNvbjogaS5wYXJhbXMgfSksIFByb21pc2UuYWxsKFtuZXcgUHJvbWlzZSgocykgPT4ge1xuICAgICAgICAgIHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5vbmNlKEV0LnB1Ymxpc2gsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHMoYXdhaXQgdGhpcy5kZWxldGVTZXNzaW9uKHsgdG9waWM6IHQsIGlkOiBuIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIHRoaXMuc2VuZFJlc3VsdCh7IGlkOiBuLCB0b3BpYzogdCwgcmVzdWx0OiAhMCwgdGhyb3dPbkZhaWxlZFB1Ymxpc2g6ICEwIH0pLCB0aGlzLmNsZWFudXBQZW5kaW5nU2VudFJlcXVlc3RzRm9yVG9waWMoeyB0b3BpYzogdCwgZXJyb3I6IHN0KFwiVVNFUl9ESVNDT05ORUNURURcIikgfSldKS5jYXRjaCgocykgPT4gdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKHMpKTtcbiAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKHMpO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25TZXNzaW9uUmVxdWVzdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB2YXIgaSwgbiwgcztcbiAgICAgIGNvbnN0IHsgdG9waWM6IG8sIHBheWxvYWQ6IGYsIGF0dGVzdGF0aW9uOiBoLCBlbmNyeXB0ZWRJZDogZCwgdHJhbnNwb3J0VHlwZTogdiB9ID0gdCwgeyBpZDogdywgcGFyYW1zOiBBIH0gPSBmO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkUmVxdWVzdChsdCh7IHRvcGljOiBvIH0sIEEpKTtcbiAgICAgICAgY29uc3QgSSA9IHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KG8pLCBEID0gYXdhaXQgdGhpcy5nZXRWZXJpZnlDb250ZXh0KHsgYXR0ZXN0YXRpb25JZDogaCwgaGFzaDogZmkoSlNPTi5zdHJpbmdpZnkoQmkoXCJ3Y19zZXNzaW9uUmVxdWVzdFwiLCBBLCB3KSkpLCBlbmNyeXB0ZWRJZDogZCwgbWV0YWRhdGE6IEkucGVlci5tZXRhZGF0YSwgdHJhbnNwb3J0VHlwZTogdiB9KSwgTiA9IHsgaWQ6IHcsIHRvcGljOiBvLCBwYXJhbXM6IEEsIHZlcmlmeUNvbnRleHQ6IEQgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRQZW5kaW5nU2Vzc2lvblJlcXVlc3QoTiksIHYgPT09IGF0LmxpbmtfbW9kZSAmJiAoaSA9IEkucGVlci5tZXRhZGF0YS5yZWRpcmVjdCkgIT0gbnVsbCAmJiBpLnVuaXZlcnNhbCAmJiB0aGlzLmNsaWVudC5jb3JlLmFkZExpbmtNb2RlU3VwcG9ydGVkQXBwKChuID0gSS5wZWVyLm1ldGFkYXRhLnJlZGlyZWN0KSA9PSBudWxsID8gdm9pZCAwIDogbi51bml2ZXJzYWwpLCAocyA9IHRoaXMuY2xpZW50LnNpZ25Db25maWcpICE9IG51bGwgJiYgcy5kaXNhYmxlUmVxdWVzdFF1ZXVlID8gdGhpcy5lbWl0U2Vzc2lvblJlcXVlc3QoTikgOiAodGhpcy5hZGRTZXNzaW9uUmVxdWVzdFRvU2Vzc2lvblJlcXVlc3RRdWV1ZShOKSwgdGhpcy5wcm9jZXNzU2Vzc2lvblJlcXVlc3RRdWV1ZSgpKTtcbiAgICAgIH0gY2F0Y2ggKEkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IoeyBpZDogdywgdG9waWM6IG8sIGVycm9yOiBJIH0pLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoSSk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblNlc3Npb25SZXF1ZXN0UmVzcG9uc2UgPSAodCwgaSkgPT4ge1xuICAgICAgY29uc3QgeyBpZDogbiB9ID0gaSwgcyA9IFhlKFwic2Vzc2lvbl9yZXF1ZXN0XCIsIG4pO1xuICAgICAgaWYgKHRoaXMuZXZlbnRzLmxpc3RlbmVyQ291bnQocykgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZW1pdHRpbmcgJHtzfSB3aXRob3V0IGFueSBsaXN0ZW5lcnNgKTtcbiAgICAgIFJyKGkpID8gdGhpcy5ldmVudHMuZW1pdChYZShcInNlc3Npb25fcmVxdWVzdFwiLCBuKSwgeyByZXN1bHQ6IGkucmVzdWx0IH0pIDogZHIoaSkgJiYgdGhpcy5ldmVudHMuZW1pdChYZShcInNlc3Npb25fcmVxdWVzdFwiLCBuKSwgeyBlcnJvcjogaS5lcnJvciB9KTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvbkV2ZW50UmVxdWVzdCA9IGFzeW5jICh0LCBpKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiBuLCBwYXJhbXM6IHMgfSA9IGk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvID0gYCR7dH1fc2Vzc2lvbl9ldmVudF8ke3MuZXZlbnQubmFtZX1gLCBmID0gRm4uZ2V0KG8pO1xuICAgICAgICBpZiAoZiAmJiB0aGlzLmlzUmVxdWVzdE91dE9mU3luYyhmLCBuKSkge1xuICAgICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKGBEaXNjYXJkaW5nIG91dCBvZiBzeW5jIHJlcXVlc3QgLSAke259YCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNWYWxpZEVtaXQobHQoeyB0b3BpYzogdCB9LCBzKSksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9ldmVudFwiLCB7IGlkOiBuLCB0b3BpYzogdCwgcGFyYW1zOiBzIH0pLCBGbi5zZXQobywgbik7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKHsgaWQ6IG4sIHRvcGljOiB0LCBlcnJvcjogbyB9KSwgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG8pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25TZXNzaW9uQXV0aGVudGljYXRlUmVzcG9uc2UgPSAodCwgaSkgPT4ge1xuICAgICAgY29uc3QgeyBpZDogbiB9ID0gaTtcbiAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJvblNlc3Npb25BdXRoZW50aWNhdGVSZXNwb25zZVwiLCB0b3BpYzogdCwgcGF5bG9hZDogaSB9KSwgUnIoaSkgPyB0aGlzLmV2ZW50cy5lbWl0KFhlKFwic2Vzc2lvbl9yZXF1ZXN0XCIsIG4pLCB7IHJlc3VsdDogaS5yZXN1bHQgfSkgOiBkcihpKSAmJiB0aGlzLmV2ZW50cy5lbWl0KFhlKFwic2Vzc2lvbl9yZXF1ZXN0XCIsIG4pLCB7IGVycm9yOiBpLmVycm9yIH0pO1xuICAgIH0sIHRoaXMub25TZXNzaW9uQXV0aGVudGljYXRlUmVxdWVzdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB2YXIgaTtcbiAgICAgIGNvbnN0IHsgdG9waWM6IG4sIHBheWxvYWQ6IHMsIGF0dGVzdGF0aW9uOiBvLCBlbmNyeXB0ZWRJZDogZiwgdHJhbnNwb3J0VHlwZTogaCB9ID0gdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgcmVxdWVzdGVyOiBkLCBhdXRoUGF5bG9hZDogdiwgZXhwaXJ5VGltZXN0YW1wOiB3IH0gPSBzLnBhcmFtcywgQSA9IGF3YWl0IHRoaXMuZ2V0VmVyaWZ5Q29udGV4dCh7IGF0dGVzdGF0aW9uSWQ6IG8sIGhhc2g6IGZpKEpTT04uc3RyaW5naWZ5KHMpKSwgZW5jcnlwdGVkSWQ6IGYsIG1ldGFkYXRhOiBkLm1ldGFkYXRhLCB0cmFuc3BvcnRUeXBlOiBoIH0pLCBJID0geyByZXF1ZXN0ZXI6IGQsIHBhaXJpbmdUb3BpYzogbiwgaWQ6IHMuaWQsIGF1dGhQYXlsb2FkOiB2LCB2ZXJpZnlDb250ZXh0OiBBLCBleHBpcnlUaW1lc3RhbXA6IHcgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRBdXRoUmVxdWVzdChzLmlkLCB7IHJlcXVlc3Q6IEksIHBhaXJpbmdUb3BpYzogbiwgdHJhbnNwb3J0VHlwZTogaCB9KSwgaCA9PT0gYXQubGlua19tb2RlICYmIChpID0gZC5tZXRhZGF0YS5yZWRpcmVjdCkgIT0gbnVsbCAmJiBpLnVuaXZlcnNhbCAmJiB0aGlzLmNsaWVudC5jb3JlLmFkZExpbmtNb2RlU3VwcG9ydGVkQXBwKGQubWV0YWRhdGEucmVkaXJlY3QudW5pdmVyc2FsKSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX2F1dGhlbnRpY2F0ZVwiLCB7IHRvcGljOiBuLCBwYXJhbXM6IHMucGFyYW1zLCBpZDogcy5pZCwgdmVyaWZ5Q29udGV4dDogQSB9KTtcbiAgICAgIH0gY2F0Y2ggKGQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKGQpO1xuICAgICAgICBjb25zdCB2ID0gcy5wYXJhbXMucmVxdWVzdGVyLnB1YmxpY0tleSwgdyA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmdlbmVyYXRlS2V5UGFpcigpLCBBID0gdGhpcy5nZXRBcHBMaW5rSWZFbmFibGVkKHMucGFyYW1zLnJlcXVlc3Rlci5tZXRhZGF0YSwgaCksIEkgPSB7IHR5cGU6IGhpLCByZWNlaXZlclB1YmxpY0tleTogdiwgc2VuZGVyUHVibGljS2V5OiB3IH07XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKHsgaWQ6IHMuaWQsIHRvcGljOiBuLCBlcnJvcjogZCwgZW5jb2RlT3B0czogSSwgcnBjT3B0czogX3Qud2Nfc2Vzc2lvbkF1dGhlbnRpY2F0ZS5hdXRvUmVqZWN0LCBhcHBMaW5rOiBBIH0pO1xuICAgICAgfVxuICAgIH0sIHRoaXMuYWRkU2Vzc2lvblJlcXVlc3RUb1Nlc3Npb25SZXF1ZXN0UXVldWUgPSAodCkgPT4ge1xuICAgICAgdGhpcy5zZXNzaW9uUmVxdWVzdFF1ZXVlLnF1ZXVlLnB1c2godCk7XG4gICAgfSwgdGhpcy5jbGVhbnVwQWZ0ZXJSZXNwb25zZSA9ICh0KSA9PiB7XG4gICAgICB0aGlzLmRlbGV0ZVBlbmRpbmdTZXNzaW9uUmVxdWVzdCh0LnJlc3BvbnNlLmlkLCB7IG1lc3NhZ2U6IFwiZnVsZmlsbGVkXCIsIGNvZGU6IDAgfSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUuc3RhdGUgPSBQci5pZGxlLCB0aGlzLnByb2Nlc3NTZXNzaW9uUmVxdWVzdFF1ZXVlKCk7XG4gICAgICB9LCBpZS50b01pbGlzZWNvbmRzKHRoaXMucmVxdWVzdFF1ZXVlRGVsYXkpKTtcbiAgICB9LCB0aGlzLmNsZWFudXBQZW5kaW5nU2VudFJlcXVlc3RzRm9yVG9waWMgPSAoeyB0b3BpYzogdCwgZXJyb3I6IGkgfSkgPT4ge1xuICAgICAgY29uc3QgbiA9IHRoaXMuY2xpZW50LmNvcmUuaGlzdG9yeS5wZW5kaW5nO1xuICAgICAgbi5sZW5ndGggPiAwICYmIG4uZmlsdGVyKChzKSA9PiBzLnRvcGljID09PSB0ICYmIHMucmVxdWVzdC5tZXRob2QgPT09IFwid2Nfc2Vzc2lvblJlcXVlc3RcIikuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICBjb25zdCBvID0gcy5yZXF1ZXN0LmlkLCBmID0gWGUoXCJzZXNzaW9uX3JlcXVlc3RcIiwgbyk7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50cy5saXN0ZW5lckNvdW50KGYpID09PSAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZW1pdHRpbmcgJHtmfSB3aXRob3V0IGFueSBsaXN0ZW5lcnNgKTtcbiAgICAgICAgdGhpcy5ldmVudHMuZW1pdChYZShcInNlc3Npb25fcmVxdWVzdFwiLCBzLnJlcXVlc3QuaWQpLCB7IGVycm9yOiBpIH0pO1xuICAgICAgfSk7XG4gICAgfSwgdGhpcy5wcm9jZXNzU2Vzc2lvblJlcXVlc3RRdWV1ZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUuc3RhdGUgPT09IFByLmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIuaW5mbyhcInNlc3Npb24gcmVxdWVzdCBxdWV1ZSBpcyBhbHJlYWR5IGFjdGl2ZS5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUucXVldWVbMF07XG4gICAgICBpZiAoIXQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oXCJzZXNzaW9uIHJlcXVlc3QgcXVldWUgaXMgZW1wdHkuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUuc3RhdGUgPSBQci5hY3RpdmUsIHRoaXMuZW1pdFNlc3Npb25SZXF1ZXN0KHQpO1xuICAgICAgfSBjYXRjaCAoaSkge1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoaSk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5lbWl0U2Vzc2lvblJlcXVlc3QgPSAodCkgPT4ge1xuICAgICAgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX3JlcXVlc3RcIiwgdCk7XG4gICAgfSwgdGhpcy5vblBhaXJpbmdDcmVhdGVkID0gKHQpID0+IHtcbiAgICAgIGlmICh0Lm1ldGhvZHMgJiYgdGhpcy5leHBlY3RlZFBhaXJpbmdNZXRob2RNYXAuc2V0KHQudG9waWMsIHQubWV0aG9kcyksIHQuYWN0aXZlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBpID0gdGhpcy5jbGllbnQucHJvcG9zYWwuZ2V0QWxsKCkuZmluZCgobikgPT4gbi5wYWlyaW5nVG9waWMgPT09IHQudG9waWMpO1xuICAgICAgaSAmJiB0aGlzLm9uU2Vzc2lvblByb3Bvc2VSZXF1ZXN0KHsgdG9waWM6IHQudG9waWMsIHBheWxvYWQ6IEJpKFwid2Nfc2Vzc2lvblByb3Bvc2VcIiwgeyByZXF1aXJlZE5hbWVzcGFjZXM6IGkucmVxdWlyZWROYW1lc3BhY2VzLCBvcHRpb25hbE5hbWVzcGFjZXM6IGkub3B0aW9uYWxOYW1lc3BhY2VzLCByZWxheXM6IGkucmVsYXlzLCBwcm9wb3NlcjogaS5wcm9wb3Nlciwgc2Vzc2lvblByb3BlcnRpZXM6IGkuc2Vzc2lvblByb3BlcnRpZXMgfSwgaS5pZCkgfSk7XG4gICAgfSwgdGhpcy5pc1ZhbGlkQ29ubmVjdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIUd0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogaCB9ID0gYWUoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGNvbm5lY3QoKSBwYXJhbXM6ICR7SlNPTi5zdHJpbmdpZnkodCl9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgcGFpcmluZ1RvcGljOiBpLCByZXF1aXJlZE5hbWVzcGFjZXM6IG4sIG9wdGlvbmFsTmFtZXNwYWNlczogcywgc2Vzc2lvblByb3BlcnRpZXM6IG8sIHJlbGF5czogZiB9ID0gdDtcbiAgICAgIGlmICh6dChpKSB8fCBhd2FpdCB0aGlzLmlzVmFsaWRQYWlyaW5nVG9waWMoaSksICF4bShmLCAhMCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBoIH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgY29ubmVjdCgpIHJlbGF5czogJHtmfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaCk7XG4gICAgICB9XG4gICAgICAhenQobikgJiYgWHMobikgIT09IDAgJiYgdGhpcy52YWxpZGF0ZU5hbWVzcGFjZXMobiwgXCJyZXF1aXJlZE5hbWVzcGFjZXNcIiksICF6dChzKSAmJiBYcyhzKSAhPT0gMCAmJiB0aGlzLnZhbGlkYXRlTmFtZXNwYWNlcyhzLCBcIm9wdGlvbmFsTmFtZXNwYWNlc1wiKSwgenQobykgfHwgdGhpcy52YWxpZGF0ZVNlc3Npb25Qcm9wcyhvLCBcInNlc3Npb25Qcm9wZXJ0aWVzXCIpO1xuICAgIH0sIHRoaXMudmFsaWRhdGVOYW1lc3BhY2VzID0gKHQsIGkpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBfbSh0LCBcImNvbm5lY3QoKVwiLCBpKTtcbiAgICAgIGlmIChuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobi5tZXNzYWdlKTtcbiAgICB9LCB0aGlzLmlzVmFsaWRBcHByb3ZlID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghR3QodCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgYXBwcm92ZSgpIHBhcmFtczogJHt0fWApLm1lc3NhZ2UpO1xuICAgICAgY29uc3QgeyBpZDogaSwgbmFtZXNwYWNlczogbiwgcmVsYXlQcm90b2NvbDogcywgc2Vzc2lvblByb3BlcnRpZXM6IG8gfSA9IHQ7XG4gICAgICB0aGlzLmNoZWNrUmVjZW50bHlEZWxldGVkKGkpLCBhd2FpdCB0aGlzLmlzVmFsaWRQcm9wb3NhbElkKGkpO1xuICAgICAgY29uc3QgZiA9IHRoaXMuY2xpZW50LnByb3Bvc2FsLmdldChpKSwgaCA9IGVvKG4sIFwiYXBwcm92ZSgpXCIpO1xuICAgICAgaWYgKGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihoLm1lc3NhZ2UpO1xuICAgICAgY29uc3QgZCA9IEhjKGYucmVxdWlyZWROYW1lc3BhY2VzLCBuLCBcImFwcHJvdmUoKVwiKTtcbiAgICAgIGlmIChkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZC5tZXNzYWdlKTtcbiAgICAgIGlmICghYnQocywgITApKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdiB9ID0gYWUoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGFwcHJvdmUoKSByZWxheVByb3RvY29sOiAke3N9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih2KTtcbiAgICAgIH1cbiAgICAgIHp0KG8pIHx8IHRoaXMudmFsaWRhdGVTZXNzaW9uUHJvcHMobywgXCJzZXNzaW9uUHJvcGVydGllc1wiKTtcbiAgICB9LCB0aGlzLmlzVmFsaWRSZWplY3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFHdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHMgfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZWplY3QoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHMpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBpZDogaSwgcmVhc29uOiBuIH0gPSB0O1xuICAgICAgaWYgKHRoaXMuY2hlY2tSZWNlbnRseURlbGV0ZWQoaSksIGF3YWl0IHRoaXMuaXNWYWxpZFByb3Bvc2FsSWQoaSksICFTbShuKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHMgfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZWplY3QoKSByZWFzb246ICR7SlNPTi5zdHJpbmdpZnkobil9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihzKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmlzVmFsaWRTZXNzaW9uU2V0dGxlUmVxdWVzdCA9ICh0KSA9PiB7XG4gICAgICBpZiAoIUd0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogZCB9ID0gYWUoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYG9uU2Vzc2lvblNldHRsZVJlcXVlc3QoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGQpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyByZWxheTogaSwgY29udHJvbGxlcjogbiwgbmFtZXNwYWNlczogcywgZXhwaXJ5OiBvIH0gPSB0O1xuICAgICAgaWYgKCFiZChpKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGQgfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIFwib25TZXNzaW9uU2V0dGxlUmVxdWVzdCgpIHJlbGF5IHByb3RvY29sIHNob3VsZCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGQpO1xuICAgICAgfVxuICAgICAgY29uc3QgZiA9IHZtKG4sIFwib25TZXNzaW9uU2V0dGxlUmVxdWVzdCgpXCIpO1xuICAgICAgaWYgKGYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmLm1lc3NhZ2UpO1xuICAgICAgY29uc3QgaCA9IGVvKHMsIFwib25TZXNzaW9uU2V0dGxlUmVxdWVzdCgpXCIpO1xuICAgICAgaWYgKGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihoLm1lc3NhZ2UpO1xuICAgICAgaWYgKGdpKG8pKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogZCB9ID0gYWUoXCJFWFBJUkVEXCIsIFwib25TZXNzaW9uU2V0dGxlUmVxdWVzdCgpXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc1ZhbGlkVXBkYXRlID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghR3QodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBoIH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgdXBkYXRlKCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IGksIG5hbWVzcGFjZXM6IG4gfSA9IHQ7XG4gICAgICB0aGlzLmNoZWNrUmVjZW50bHlEZWxldGVkKGkpLCBhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uVG9waWMoaSk7XG4gICAgICBjb25zdCBzID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQoaSksIG8gPSBlbyhuLCBcInVwZGF0ZSgpXCIpO1xuICAgICAgaWYgKG8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihvLm1lc3NhZ2UpO1xuICAgICAgY29uc3QgZiA9IEhjKHMucmVxdWlyZWROYW1lc3BhY2VzLCBuLCBcInVwZGF0ZSgpXCIpO1xuICAgICAgaWYgKGYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmLm1lc3NhZ2UpO1xuICAgIH0sIHRoaXMuaXNWYWxpZEV4dGVuZCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIUd0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbiB9ID0gYWUoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGV4dGVuZCgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBpIH0gPSB0O1xuICAgICAgdGhpcy5jaGVja1JlY2VudGx5RGVsZXRlZChpKSwgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvblRvcGljKGkpO1xuICAgIH0sIHRoaXMuaXNWYWxpZFJlcXVlc3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFHdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGggfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZXF1ZXN0KCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IGksIHJlcXVlc3Q6IG4sIGNoYWluSWQ6IHMsIGV4cGlyeTogbyB9ID0gdDtcbiAgICAgIHRoaXMuY2hlY2tSZWNlbnRseURlbGV0ZWQoaSksIGF3YWl0IHRoaXMuaXNWYWxpZFNlc3Npb25Ub3BpYyhpKTtcbiAgICAgIGNvbnN0IHsgbmFtZXNwYWNlczogZiB9ID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQoaSk7XG4gICAgICBpZiAoIUtjKGYsIHMpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogaCB9ID0gYWUoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlcXVlc3QoKSBjaGFpbklkOiAke3N9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihoKTtcbiAgICAgIH1cbiAgICAgIGlmICghTW0obikpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBoIH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVxdWVzdCgpICR7SlNPTi5zdHJpbmdpZnkobil9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihoKTtcbiAgICAgIH1cbiAgICAgIGlmICghRG0oZiwgcywgbi5tZXRob2QpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogaCB9ID0gYWUoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlcXVlc3QoKSBtZXRob2Q6ICR7bi5tZXRob2R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihoKTtcbiAgICAgIH1cbiAgICAgIGlmIChvICYmICFObShvLCBzbykpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBoIH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVxdWVzdCgpIGV4cGlyeTogJHtvfS4gRXhwaXJ5IG11c3QgYmUgYSBudW1iZXIgKGluIHNlY29uZHMpIGJldHdlZW4gJHtzby5taW59IGFuZCAke3NvLm1heH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaXNWYWxpZFJlc3BvbmQgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdmFyIGk7XG4gICAgICBpZiAoIUd0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbyB9ID0gYWUoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlc3BvbmQoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG8pO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogbiwgcmVzcG9uc2U6IHMgfSA9IHQ7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uVG9waWMobik7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIHRocm93IChpID0gdD8ucmVzcG9uc2UpICE9IG51bGwgJiYgaS5pZCAmJiB0aGlzLmNsZWFudXBBZnRlclJlc3BvbnNlKHQpLCBvO1xuICAgICAgfVxuICAgICAgaWYgKCFJbShzKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG8gfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZXNwb25kKCkgcmVzcG9uc2U6ICR7SlNPTi5zdHJpbmdpZnkocyl9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmlzVmFsaWRQaW5nID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghR3QodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcGluZygpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBpIH0gPSB0O1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvbk9yUGFpcmluZ1RvcGljKGkpO1xuICAgIH0sIHRoaXMuaXNWYWxpZEVtaXQgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFHdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGYgfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBlbWl0KCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IGksIGV2ZW50OiBuLCBjaGFpbklkOiBzIH0gPSB0O1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvblRvcGljKGkpO1xuICAgICAgY29uc3QgeyBuYW1lc3BhY2VzOiBvIH0gPSB0aGlzLmNsaWVudC5zZXNzaW9uLmdldChpKTtcbiAgICAgIGlmICghS2MobywgcykpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBmIH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZW1pdCgpIGNoYWluSWQ6ICR7c31gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGYpO1xuICAgICAgfVxuICAgICAgaWYgKCFBbShuKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGYgfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBlbWl0KCkgZXZlbnQ6ICR7SlNPTi5zdHJpbmdpZnkobil9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmKTtcbiAgICAgIH1cbiAgICAgIGlmICghUG0obywgcywgbi5uYW1lKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGYgfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBlbWl0KCkgZXZlbnQ6ICR7SlNPTi5zdHJpbmdpZnkobil9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmlzVmFsaWREaXNjb25uZWN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghR3QodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZGlzY29ubmVjdCgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBpIH0gPSB0O1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvbk9yUGFpcmluZ1RvcGljKGkpO1xuICAgIH0sIHRoaXMuaXNWYWxpZEF1dGhlbnRpY2F0ZSA9ICh0KSA9PiB7XG4gICAgICBjb25zdCB7IGNoYWluczogaSwgdXJpOiBuLCBkb21haW46IHMsIG5vbmNlOiBvIH0gPSB0O1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGkpIHx8IGkubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGFpbnMgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYSBub24tZW1wdHkgYXJyYXlcIik7XG4gICAgICBpZiAoIWJ0KG4sICExKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXJpIGlzIHJlcXVpcmVkIHBhcmFtZXRlclwiKTtcbiAgICAgIGlmICghYnQocywgITEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkb21haW4gaXMgcmVxdWlyZWQgcGFyYW1ldGVyXCIpO1xuICAgICAgaWYgKCFidChvLCAhMSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vbmNlIGlzIHJlcXVpcmVkIHBhcmFtZXRlclwiKTtcbiAgICAgIGlmIChbLi4ubmV3IFNldChpLm1hcCgoaCkgPT4gTnMoaCkubmFtZXNwYWNlKSldLmxlbmd0aCA+IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpLW5hbWVzcGFjZSByZXF1ZXN0cyBhcmUgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHJlcXVlc3Qgc2luZ2xlIG5hbWVzcGFjZSBvbmx5LlwiKTtcbiAgICAgIGNvbnN0IHsgbmFtZXNwYWNlOiBmIH0gPSBOcyhpWzBdKTtcbiAgICAgIGlmIChmICE9PSBcImVpcDE1NVwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IGVpcDE1NSBuYW1lc3BhY2UgaXMgc3VwcG9ydGVkIGZvciBhdXRoZW50aWNhdGVkIHNlc3Npb25zLiBQbGVhc2UgdXNlIC5jb25uZWN0KCkgZm9yIG5vbi1laXAxNTUgY2hhaW5zLlwiKTtcbiAgICB9LCB0aGlzLmdldFZlcmlmeUNvbnRleHQgPSBhc3luYyAodCkgPT4ge1xuICAgICAgY29uc3QgeyBhdHRlc3RhdGlvbklkOiBpLCBoYXNoOiBuLCBlbmNyeXB0ZWRJZDogcywgbWV0YWRhdGE6IG8sIHRyYW5zcG9ydFR5cGU6IGYgfSA9IHQsIGggPSB7IHZlcmlmaWVkOiB7IHZlcmlmeVVybDogby52ZXJpZnlVcmwgfHwgVm4sIHZhbGlkYXRpb246IFwiVU5LTk9XTlwiLCBvcmlnaW46IG8udXJsIHx8IFwiXCIgfSB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGYgPT09IGF0LmxpbmtfbW9kZSkge1xuICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLmdldEFwcExpbmtJZkVuYWJsZWQobywgZik7XG4gICAgICAgICAgcmV0dXJuIGgudmVyaWZpZWQudmFsaWRhdGlvbiA9IHYgJiYgbmV3IFVSTCh2KS5vcmlnaW4gPT09IG5ldyBVUkwoby51cmwpLm9yaWdpbiA/IFwiVkFMSURcIiA6IFwiSU5WQUxJRFwiLCBoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGQgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnZlcmlmeS5yZXNvbHZlKHsgYXR0ZXN0YXRpb25JZDogaSwgaGFzaDogbiwgZW5jcnlwdGVkSWQ6IHMsIHZlcmlmeVVybDogby52ZXJpZnlVcmwgfSk7XG4gICAgICAgIGQgJiYgKGgudmVyaWZpZWQub3JpZ2luID0gZC5vcmlnaW4sIGgudmVyaWZpZWQuaXNTY2FtID0gZC5pc1NjYW0sIGgudmVyaWZpZWQudmFsaWRhdGlvbiA9IGQub3JpZ2luID09PSBuZXcgVVJMKG8udXJsKS5vcmlnaW4gPyBcIlZBTElEXCIgOiBcIklOVkFMSURcIik7XG4gICAgICB9IGNhdGNoIChkKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci53YXJuKGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlci5kZWJ1ZyhgVmVyaWZ5IGNvbnRleHQ6ICR7SlNPTi5zdHJpbmdpZnkoaCl9YCksIGg7XG4gICAgfSwgdGhpcy52YWxpZGF0ZVNlc3Npb25Qcm9wcyA9ICh0LCBpKSA9PiB7XG4gICAgICBPYmplY3QudmFsdWVzKHQpLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgaWYgKCFidChuLCAhMSkpIHtcbiAgICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHMgfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGAke2l9IG11c3QgYmUgaW4gUmVjb3JkPHN0cmluZywgc3RyaW5nPiBmb3JtYXQuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KG4pfWApO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgdGhpcy5nZXRQZW5kaW5nQXV0aFJlcXVlc3QgPSAodCkgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuY2xpZW50LmF1dGgucmVxdWVzdHMuZ2V0KHQpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBpID09IFwib2JqZWN0XCIgPyBpIDogdm9pZCAwO1xuICAgIH0sIHRoaXMuYWRkVG9SZWNlbnRseURlbGV0ZWQgPSAodCwgaSkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVjZW50bHlEZWxldGVkTWFwLnNldCh0LCBpKSwgdGhpcy5yZWNlbnRseURlbGV0ZWRNYXAuc2l6ZSA+PSB0aGlzLnJlY2VudGx5RGVsZXRlZExpbWl0KSB7XG4gICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMucmVjZW50bHlEZWxldGVkTGltaXQgLyAyO1xuICAgICAgICBmb3IgKGNvbnN0IG8gb2YgdGhpcy5yZWNlbnRseURlbGV0ZWRNYXAua2V5cygpKSB7XG4gICAgICAgICAgaWYgKG4rKyA+PSBzKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgdGhpcy5yZWNlbnRseURlbGV0ZWRNYXAuZGVsZXRlKG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcy5jaGVja1JlY2VudGx5RGVsZXRlZCA9ICh0KSA9PiB7XG4gICAgICBjb25zdCBpID0gdGhpcy5yZWNlbnRseURlbGV0ZWRNYXAuZ2V0KHQpO1xuICAgICAgaWYgKGkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgUmVjb3JkIHdhcyByZWNlbnRseSBkZWxldGVkIC0gJHtpfTogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc0xpbmtNb2RlRW5hYmxlZCA9ICh0LCBpKSA9PiB7XG4gICAgICB2YXIgbiwgcywgbywgZiwgaCwgZCwgdiwgdywgQTtcbiAgICAgIHJldHVybiAhdCB8fCBpICE9PSBhdC5saW5rX21vZGUgPyAhMSA6ICgocyA9IChuID0gdGhpcy5jbGllbnQubWV0YWRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBuLnJlZGlyZWN0KSA9PSBudWxsID8gdm9pZCAwIDogcy5saW5rTW9kZSkgPT09ICEwICYmICgoZiA9IChvID0gdGhpcy5jbGllbnQubWV0YWRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBvLnJlZGlyZWN0KSA9PSBudWxsID8gdm9pZCAwIDogZi51bml2ZXJzYWwpICE9PSB2b2lkIDAgJiYgKChkID0gKGggPSB0aGlzLmNsaWVudC5tZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IGgucmVkaXJlY3QpID09IG51bGwgPyB2b2lkIDAgOiBkLnVuaXZlcnNhbCkgIT09IFwiXCIgJiYgKCh2ID0gdD8ucmVkaXJlY3QpID09IG51bGwgPyB2b2lkIDAgOiB2LnVuaXZlcnNhbCkgIT09IHZvaWQgMCAmJiAoKHcgPSB0Py5yZWRpcmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IHcudW5pdmVyc2FsKSAhPT0gXCJcIiAmJiAoKEEgPSB0Py5yZWRpcmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IEEubGlua01vZGUpID09PSAhMCAmJiB0aGlzLmNsaWVudC5jb3JlLmxpbmtNb2RlU3VwcG9ydGVkQXBwcy5pbmNsdWRlcyh0LnJlZGlyZWN0LnVuaXZlcnNhbCkgJiYgdHlwZW9mIChnbG9iYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbC5MaW5raW5nKSA8IFwidVwiO1xuICAgIH0sIHRoaXMuZ2V0QXBwTGlua0lmRW5hYmxlZCA9ICh0LCBpKSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIHJldHVybiB0aGlzLmlzTGlua01vZGVFbmFibGVkKHQsIGkpID8gKG4gPSB0Py5yZWRpcmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IG4udW5pdmVyc2FsIDogdm9pZCAwO1xuICAgIH0sIHRoaXMuaGFuZGxlTGlua01vZGVNZXNzYWdlID0gKHsgdXJsOiB0IH0pID0+IHtcbiAgICAgIGlmICghdCB8fCAhdC5pbmNsdWRlcyhcIndjX2V2XCIpIHx8ICF0LmluY2x1ZGVzKFwidG9waWNcIikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGkgPSBBYyh0LCBcInRvcGljXCIpIHx8IFwiXCIsIG4gPSBkZWNvZGVVUklDb21wb25lbnQoQWModCwgXCJ3Y19ldlwiKSB8fCBcIlwiKSwgcyA9IHRoaXMuY2xpZW50LnNlc3Npb24ua2V5cy5pbmNsdWRlcyhpKTtcbiAgICAgIHMgJiYgdGhpcy5jbGllbnQuc2Vzc2lvbi51cGRhdGUoaSwgeyB0cmFuc3BvcnRUeXBlOiBhdC5saW5rX21vZGUgfSksIHRoaXMuY2xpZW50LmNvcmUuZGlzcGF0Y2hFbnZlbG9wZSh7IHRvcGljOiBpLCBtZXNzYWdlOiBuLCBzZXNzaW9uRXhpc3RzOiBzIH0pO1xuICAgIH0sIHRoaXMucmVnaXN0ZXJMaW5rTW9kZUxpc3RlbmVycyA9IGFzeW5jICgpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgaWYgKHJmKCkgfHwgQWkoKSAmJiAodCA9IHRoaXMuY2xpZW50Lm1ldGFkYXRhLnJlZGlyZWN0KSAhPSBudWxsICYmIHQubGlua01vZGUpIHtcbiAgICAgICAgY29uc3QgaSA9IGdsb2JhbCA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsLkxpbmtpbmc7XG4gICAgICAgIGlmICh0eXBlb2YgaSA8IFwidVwiKSB7XG4gICAgICAgICAgaS5hZGRFdmVudExpc3RlbmVyKFwidXJsXCIsIHRoaXMuaGFuZGxlTGlua01vZGVNZXNzYWdlLCB0aGlzLmNsaWVudC5uYW1lKTtcbiAgICAgICAgICBjb25zdCBuID0gYXdhaXQgaS5nZXRJbml0aWFsVVJMKCk7XG4gICAgICAgICAgbiAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTGlua01vZGVNZXNzYWdlKHsgdXJsOiBuIH0pO1xuICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gYWUoXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY29uZmlybU9ubGluZVN0YXRlT3JUaHJvdygpIHtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnJlbGF5ZXIuY29uZmlybU9ubGluZVN0YXRlT3JUaHJvdygpO1xuICB9XG4gIHJlZ2lzdGVyUmVsYXllckV2ZW50cygpIHtcbiAgICB0aGlzLmNsaWVudC5jb3JlLnJlbGF5ZXIub24oRXQubWVzc2FnZSwgKGUpID0+IHtcbiAgICAgICF0aGlzLmluaXRpYWxpemVkIHx8IHRoaXMucmVsYXlNZXNzYWdlQ2FjaGUubGVuZ3RoID4gMCA/IHRoaXMucmVsYXlNZXNzYWdlQ2FjaGUucHVzaChlKSA6IHRoaXMub25SZWxheU1lc3NhZ2UoZSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgb25SZWxheU1lc3NhZ2UoZSkge1xuICAgIGNvbnN0IHsgdG9waWM6IHQsIG1lc3NhZ2U6IGksIGF0dGVzdGF0aW9uOiBuLCB0cmFuc3BvcnRUeXBlOiBzIH0gPSBlLCB7IHB1YmxpY0tleTogbyB9ID0gdGhpcy5jbGllbnQuYXV0aC5hdXRoS2V5cy5rZXlzLmluY2x1ZGVzKCRzKSA/IHRoaXMuY2xpZW50LmF1dGguYXV0aEtleXMuZ2V0KCRzKSA6IHsgcmVzcG9uc2VUb3BpYzogdm9pZCAwLCBwdWJsaWNLZXk6IHZvaWQgMCB9LCBmID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZGVjb2RlKHQsIGksIHsgcmVjZWl2ZXJQdWJsaWNLZXk6IG8sIGVuY29kaW5nOiBzID09PSBhdC5saW5rX21vZGUgPyBMbiA6IHdpIH0pO1xuICAgIHRyeSB7XG4gICAgICBmZihmKSA/ICh0aGlzLmNsaWVudC5jb3JlLmhpc3Rvcnkuc2V0KHQsIGYpLCB0aGlzLm9uUmVsYXlFdmVudFJlcXVlc3QoeyB0b3BpYzogdCwgcGF5bG9hZDogZiwgYXR0ZXN0YXRpb246IG4sIHRyYW5zcG9ydFR5cGU6IHMsIGVuY3J5cHRlZElkOiBmaShpKSB9KSkgOiBBYShmKSA/IChhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmhpc3RvcnkucmVzb2x2ZShmKSwgYXdhaXQgdGhpcy5vblJlbGF5RXZlbnRSZXNwb25zZSh7IHRvcGljOiB0LCBwYXlsb2FkOiBmLCB0cmFuc3BvcnRUeXBlOiBzIH0pLCB0aGlzLmNsaWVudC5jb3JlLmhpc3RvcnkuZGVsZXRlKHQsIGYuaWQpKSA6IHRoaXMub25SZWxheUV2ZW50VW5rbm93blBheWxvYWQoeyB0b3BpYzogdCwgcGF5bG9hZDogZiwgdHJhbnNwb3J0VHlwZTogcyB9KTtcbiAgICB9IGNhdGNoIChoKSB7XG4gICAgICB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3IoaCk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyRXhwaXJlckV2ZW50cygpIHtcbiAgICB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIub24odXIuZXhwaXJlZCwgYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHQsIGlkOiBpIH0gPSBhZChlLnRhcmdldCk7XG4gICAgICBpZiAoaSAmJiB0aGlzLmNsaWVudC5wZW5kaW5nUmVxdWVzdC5rZXlzLmluY2x1ZGVzKGkpKVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kZWxldGVQZW5kaW5nU2Vzc2lvblJlcXVlc3QoaSwgYWUoXCJFWFBJUkVEXCIpLCAhMCk7XG4gICAgICBpZiAoaSAmJiB0aGlzLmNsaWVudC5hdXRoLnJlcXVlc3RzLmtleXMuaW5jbHVkZXMoaSkpXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRlbGV0ZVBlbmRpbmdBdXRoUmVxdWVzdChpLCBhZShcIkVYUElSRURcIiksICEwKTtcbiAgICAgIHQgPyB0aGlzLmNsaWVudC5zZXNzaW9uLmtleXMuaW5jbHVkZXModCkgJiYgKGF3YWl0IHRoaXMuZGVsZXRlU2Vzc2lvbih7IHRvcGljOiB0LCBleHBpcmVySGFzRGVsZXRlZDogITAgfSksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9leHBpcmVcIiwgeyB0b3BpYzogdCB9KSkgOiBpICYmIChhd2FpdCB0aGlzLmRlbGV0ZVByb3Bvc2FsKGksICEwKSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJwcm9wb3NhbF9leHBpcmVcIiwgeyBpZDogaSB9KSk7XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJQYWlyaW5nRXZlbnRzKCkge1xuICAgIHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5ldmVudHMub24ocWkuY3JlYXRlLCAoZSkgPT4gdGhpcy5vblBhaXJpbmdDcmVhdGVkKGUpKSwgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLmV2ZW50cy5vbihxaS5kZWxldGUsIChlKSA9PiB7XG4gICAgICB0aGlzLmFkZFRvUmVjZW50bHlEZWxldGVkKGUudG9waWMsIFwicGFpcmluZ1wiKTtcbiAgICB9KTtcbiAgfVxuICBpc1ZhbGlkUGFpcmluZ1RvcGljKGUpIHtcbiAgICBpZiAoIWJ0KGUsICExKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcGFpcmluZyB0b3BpYyBzaG91bGQgYmUgYSBzdHJpbmc6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyhlKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBhZShcIk5PX01BVENISU5HX0tFWVwiLCBgcGFpcmluZyB0b3BpYyBkb2Vzbid0IGV4aXN0OiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICAgIGlmIChnaSh0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGFpcmluZ3MuZ2V0KGUpLmV4cGlyeSkpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gYWUoXCJFWFBJUkVEXCIsIGBwYWlyaW5nIHRvcGljOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGlzVmFsaWRTZXNzaW9uVG9waWMoZSkge1xuICAgIGlmICghYnQoZSwgITEpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBzZXNzaW9uIHRvcGljIHNob3VsZCBiZSBhIHN0cmluZzogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGVja1JlY2VudGx5RGVsZXRlZChlKSwgIXRoaXMuY2xpZW50LnNlc3Npb24ua2V5cy5pbmNsdWRlcyhlKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBhZShcIk5PX01BVENISU5HX0tFWVwiLCBgc2Vzc2lvbiB0b3BpYyBkb2Vzbid0IGV4aXN0OiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICAgIGlmIChnaSh0aGlzLmNsaWVudC5zZXNzaW9uLmdldChlKS5leHBpcnkpKSB7XG4gICAgICBhd2FpdCB0aGlzLmRlbGV0ZVNlc3Npb24oeyB0b3BpYzogZSB9KTtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gYWUoXCJFWFBJUkVEXCIsIGBzZXNzaW9uIHRvcGljOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jbGllbnQuY29yZS5jcnlwdG8ua2V5Y2hhaW4uaGFzKGUpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IGFlKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBzZXNzaW9uIHRvcGljIGRvZXMgbm90IGV4aXN0IGluIGtleWNoYWluOiAke2V9YCk7XG4gICAgICB0aHJvdyBhd2FpdCB0aGlzLmRlbGV0ZVNlc3Npb24oeyB0b3BpYzogZSB9KSwgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBpc1ZhbGlkU2Vzc2lvbk9yUGFpcmluZ1RvcGljKGUpIHtcbiAgICBpZiAodGhpcy5jaGVja1JlY2VudGx5RGVsZXRlZChlKSwgdGhpcy5jbGllbnQuc2Vzc2lvbi5rZXlzLmluY2x1ZGVzKGUpKVxuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvblRvcGljKGUpO1xuICAgIGVsc2UgaWYgKHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKGUpKVxuICAgICAgdGhpcy5pc1ZhbGlkUGFpcmluZ1RvcGljKGUpO1xuICAgIGVsc2UgaWYgKGJ0KGUsICExKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBhZShcIk5PX01BVENISU5HX0tFWVwiLCBgc2Vzc2lvbiBvciBwYWlyaW5nIHRvcGljIGRvZXNuJ3QgZXhpc3Q6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgc2Vzc2lvbiBvciBwYWlyaW5nIHRvcGljIHNob3VsZCBiZSBhIHN0cmluZzogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBpc1ZhbGlkUHJvcG9zYWxJZChlKSB7XG4gICAgaWYgKCFFbShlKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBhZShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcHJvcG9zYWwgaWQgc2hvdWxkIGJlIGEgbnVtYmVyOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jbGllbnQucHJvcG9zYWwua2V5cy5pbmNsdWRlcyhlKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBhZShcIk5PX01BVENISU5HX0tFWVwiLCBgcHJvcG9zYWwgaWQgZG9lc24ndCBleGlzdDogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgICBpZiAoZ2kodGhpcy5jbGllbnQucHJvcG9zYWwuZ2V0KGUpLmV4cGlyeVRpbWVzdGFtcCkpIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVsZXRlUHJvcG9zYWwoZSk7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IGFlKFwiRVhQSVJFRFwiLCBgcHJvcG9zYWwgaWQ6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIGw1IGV4dGVuZHMgUWkge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCwgWXcsIGNmKSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59XG5jbGFzcyBwNSBleHRlbmRzIFFpIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQsIFp3LCBjZiksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdDtcbiAgfVxufVxuY2xhc3MgdjUgZXh0ZW5kcyBRaSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0LCBlNSwgY2YsIChpKSA9PiBpLmlkKSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59XG5jbGFzcyBiNSBleHRlbmRzIFFpIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQsIG41LCBQYSwgKCkgPT4gJHMpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQ7XG4gIH1cbn1cbmNsYXNzIGc1IGV4dGVuZHMgUWkge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCwgczUsIFBhKSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59XG5jbGFzcyB5NSBleHRlbmRzIFFpIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQsIGE1LCBQYSwgKGkpID0+IGkuaWQpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQ7XG4gIH1cbn1cbmNsYXNzIG01IHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5hdXRoS2V5cyA9IG5ldyBiNSh0aGlzLmNvcmUsIHRoaXMubG9nZ2VyKSwgdGhpcy5wYWlyaW5nVG9waWNzID0gbmV3IGc1KHRoaXMuY29yZSwgdGhpcy5sb2dnZXIpLCB0aGlzLnJlcXVlc3RzID0gbmV3IHk1KHRoaXMuY29yZSwgdGhpcy5sb2dnZXIpO1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgYXdhaXQgdGhpcy5hdXRoS2V5cy5pbml0KCksIGF3YWl0IHRoaXMucGFpcmluZ1RvcGljcy5pbml0KCksIGF3YWl0IHRoaXMucmVxdWVzdHMuaW5pdCgpO1xuICB9XG59XG5jbGFzcyBPYSBleHRlbmRzIHBwIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLnByb3RvY29sID0gVWQsIHRoaXMudmVyc2lvbiA9IHpkLCB0aGlzLm5hbWUgPSBuby5uYW1lLCB0aGlzLmV2ZW50cyA9IG5ldyBpci5FdmVudEVtaXR0ZXIoKSwgdGhpcy5vbiA9IChpLCBuKSA9PiB0aGlzLmV2ZW50cy5vbihpLCBuKSwgdGhpcy5vbmNlID0gKGksIG4pID0+IHRoaXMuZXZlbnRzLm9uY2UoaSwgbiksIHRoaXMub2ZmID0gKGksIG4pID0+IHRoaXMuZXZlbnRzLm9mZihpLCBuKSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChpLCBuKSA9PiB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihpLCBuKSwgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSAoaSkgPT4gdGhpcy5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKGkpLCB0aGlzLmNvbm5lY3QgPSBhc3luYyAoaSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLmNvbm5lY3QoaSk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKG4ubWVzc2FnZSksIG47XG4gICAgICB9XG4gICAgfSwgdGhpcy5wYWlyID0gYXN5bmMgKGkpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5wYWlyKGkpO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihuLm1lc3NhZ2UpLCBuO1xuICAgICAgfVxuICAgIH0sIHRoaXMuYXBwcm92ZSA9IGFzeW5jIChpKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUuYXBwcm92ZShpKTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Iobi5tZXNzYWdlKSwgbjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnJlamVjdCA9IGFzeW5jIChpKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUucmVqZWN0KGkpO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihuLm1lc3NhZ2UpLCBuO1xuICAgICAgfVxuICAgIH0sIHRoaXMudXBkYXRlID0gYXN5bmMgKGkpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS51cGRhdGUoaSk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKG4ubWVzc2FnZSksIG47XG4gICAgICB9XG4gICAgfSwgdGhpcy5leHRlbmQgPSBhc3luYyAoaSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLmV4dGVuZChpKTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Iobi5tZXNzYWdlKSwgbjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnJlcXVlc3QgPSBhc3luYyAoaSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLnJlcXVlc3QoaSk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKG4ubWVzc2FnZSksIG47XG4gICAgICB9XG4gICAgfSwgdGhpcy5yZXNwb25kID0gYXN5bmMgKGkpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5yZXNwb25kKGkpO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihuLm1lc3NhZ2UpLCBuO1xuICAgICAgfVxuICAgIH0sIHRoaXMucGluZyA9IGFzeW5jIChpKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUucGluZyhpKTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Iobi5tZXNzYWdlKSwgbjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmVtaXQgPSBhc3luYyAoaSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLmVtaXQoaSk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKG4ubWVzc2FnZSksIG47XG4gICAgICB9XG4gICAgfSwgdGhpcy5kaXNjb25uZWN0ID0gYXN5bmMgKGkpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5kaXNjb25uZWN0KGkpO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihuLm1lc3NhZ2UpLCBuO1xuICAgICAgfVxuICAgIH0sIHRoaXMuZmluZCA9IChpKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUuZmluZChpKTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Iobi5tZXNzYWdlKSwgbjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmdldFBlbmRpbmdTZXNzaW9uUmVxdWVzdHMgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUuZ2V0UGVuZGluZ1Nlc3Npb25SZXF1ZXN0cygpO1xuICAgICAgfSBjYXRjaCAoaSkge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihpLm1lc3NhZ2UpLCBpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuYXV0aGVudGljYXRlID0gYXN5bmMgKGksIG4pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5hdXRoZW50aWNhdGUoaSwgbik7XG4gICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHMubWVzc2FnZSksIHM7XG4gICAgICB9XG4gICAgfSwgdGhpcy5mb3JtYXRBdXRoTWVzc2FnZSA9IChpKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUuZm9ybWF0QXV0aE1lc3NhZ2UoaSk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKG4ubWVzc2FnZSksIG47XG4gICAgICB9XG4gICAgfSwgdGhpcy5hcHByb3ZlU2Vzc2lvbkF1dGhlbnRpY2F0ZSA9IGFzeW5jIChpKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUuYXBwcm92ZVNlc3Npb25BdXRoZW50aWNhdGUoaSk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKG4ubWVzc2FnZSksIG47XG4gICAgICB9XG4gICAgfSwgdGhpcy5yZWplY3RTZXNzaW9uQXV0aGVudGljYXRlID0gYXN5bmMgKGkpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5yZWplY3RTZXNzaW9uQXV0aGVudGljYXRlKGkpO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihuLm1lc3NhZ2UpLCBuO1xuICAgICAgfVxuICAgIH0sIHRoaXMubmFtZSA9IGU/Lm5hbWUgfHwgbm8ubmFtZSwgdGhpcy5tZXRhZGF0YSA9IGU/Lm1ldGFkYXRhIHx8IHRkKCksIHRoaXMuc2lnbkNvbmZpZyA9IGU/LnNpZ25Db25maWc7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBlPy5sb2dnZXIgPCBcInVcIiAmJiB0eXBlb2YgZT8ubG9nZ2VyICE9IFwic3RyaW5nXCIgPyBlLmxvZ2dlciA6IG5hKFRvKHsgbGV2ZWw6IGU/LmxvZ2dlciB8fCBuby5sb2dnZXIgfSkpO1xuICAgIHRoaXMuY29yZSA9IGU/LmNvcmUgfHwgbmV3IEp3KGUpLCB0aGlzLmxvZ2dlciA9IGt0KHQsIHRoaXMubmFtZSksIHRoaXMuc2Vzc2lvbiA9IG5ldyBwNSh0aGlzLmNvcmUsIHRoaXMubG9nZ2VyKSwgdGhpcy5wcm9wb3NhbCA9IG5ldyBsNSh0aGlzLmNvcmUsIHRoaXMubG9nZ2VyKSwgdGhpcy5wZW5kaW5nUmVxdWVzdCA9IG5ldyB2NSh0aGlzLmNvcmUsIHRoaXMubG9nZ2VyKSwgdGhpcy5lbmdpbmUgPSBuZXcgZDUodGhpcyksIHRoaXMuYXV0aCA9IG5ldyBtNSh0aGlzLmNvcmUsIHRoaXMubG9nZ2VyKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgaW5pdChlKSB7XG4gICAgY29uc3QgdCA9IG5ldyBPYShlKTtcbiAgICByZXR1cm4gYXdhaXQgdC5pbml0aWFsaXplKCksIHQ7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIFp0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgcGFpcmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb3JlLnBhaXJpbmcucGFpcmluZ3M7XG4gIH1cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmxvZ2dlci50cmFjZShcIkluaXRpYWxpemVkXCIpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmNvcmUuc3RhcnQoKSwgYXdhaXQgdGhpcy5zZXNzaW9uLmluaXQoKSwgYXdhaXQgdGhpcy5wcm9wb3NhbC5pbml0KCksIGF3YWl0IHRoaXMucGVuZGluZ1JlcXVlc3QuaW5pdCgpLCBhd2FpdCB0aGlzLmF1dGguaW5pdCgpLCBhd2FpdCB0aGlzLmVuZ2luZS5pbml0KCksIHRoaXMubG9nZ2VyLmluZm8oXCJTaWduQ2xpZW50IEluaXRpYWxpemF0aW9uIFN1Y2Nlc3NcIiksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmVuZ2luZS5wcm9jZXNzUmVsYXlNZXNzYWdlQ2FjaGUoKTtcbiAgICAgIH0sIGllLnRvTWlsaXNlY29uZHMoaWUuT05FX1NFQ09ORCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IHRoaXMubG9nZ2VyLmluZm8oXCJTaWduQ2xpZW50IEluaXRpYWxpemF0aW9uIEZhaWx1cmVcIiksIHRoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSksIGU7XG4gICAgfVxuICB9XG59XG5jb25zdCB3NSA9ICgpID0+IHtcbiAgY29uc3QgZSA9IGN1KCk/Lm9zPy50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gZT8uaW5jbHVkZXMoXCJhbmRyb2lkXCIpID8gXCJhbmRyb2lkXCIgOiBlPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiaW9zXCIpIHx8IGU/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJtYWNcIikgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMSA/IFwiaW9zXCIgOiBcImRlc2t0b3BcIjtcbn0sIFNzID0gdzUoKSwgXzUgPSB7XG4gIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gIHRvcDogXCIwXCIsXG4gIGxlZnQ6IFwiMFwiLFxuICByaWdodDogXCIwXCIsXG4gIGJvdHRvbTogXCIwXCIsXG4gIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDAsMCwwLDAuOClcIixcbiAgYmFja2Ryb3BGaWx0ZXI6IFwiYmx1cigxMHB4KVwiLFxuICB6SW5kZXg6IFwiOTk5OVwiLFxuICBkaXNwbGF5OiBcImZsZXhcIixcbiAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gIGNvbG9yOiBcIndoaXRlXCIsXG4gIGZvbnRXZWlnaHQ6IFwiNTAwXCIsXG4gIGZvbnRGYW1pbHk6IFwiJ0JhcmxvdycsIHNhbnMtc2VyaWZcIlxufSwgeDUgPSB7XG4gIHdpZHRoOiBcIjg0MHB4XCIsXG4gIGhlaWdodDogXCI1NDBweFwiLFxuICB6SW5kZXg6IFwiOTk5OTlcIixcbiAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCIsXG4gIGJvcmRlcjogXCJub25lXCIsXG4gIG91dGxpbmU6IFwibm9uZVwiLFxuICBib3JkZXJSYWRpdXM6IFwiNDBweFwiLFxuICBib3hTaGFkb3c6IFwiMHB4IDRweCA0MHB4IDBweCByZ2IoMCAwIDApLCAwcHggNHB4IDhweCAwcHggcmdiKDAgMCAwIC8gMjUlKVwiLFxuICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICB0b3A6IFwiNTAlXCIsXG4gIGxlZnQ6IFwiNTAlXCIsXG4gIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTUwJSwtNTAlKVwiXG59LCBFNSA9IGBcbiAgPGRpdiBpZD1cImFyZ2VudC1tb2JpbGUtbW9kYWwtY29udGFpbmVyXCIgc3R5bGU9XCJwb3NpdGlvbjogcmVsYXRpdmVcIj5cbiAgICA8aWZyYW1lIGNsYXNzPVwiYXJnZW50LWlmcmFtZVwiIGFsbG93PVwiY2xpcGJvYXJkLXdyaXRlXCI+PC9pZnJhbWU+XG4gICAgPGRpdiBjbGFzcz1cImFyZ2VudC1jbG9zZS1idXR0b25cIiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAyNHB4OyByaWdodDogMjRweDsgY3Vyc29yOiBwb2ludGVyO1wiPlxuICAgICAgPHN2ZyB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgICAgIDxjaXJjbGUgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTZcIiBmaWxsPVwiI0Y1RjNGMFwiLz5cbiAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTIyLjI0NjIgOS43NTM4MkMyMi43MDE4IDEwLjIwOTQgMjIuNzAxOCAxMC45NDgxIDIyLjI0NjIgMTEuNDAzN0wxNy42NDk5IDE2TDIyLjI0NjIgMjAuNTk2M0MyMi43MDE4IDIxLjA1MTkgMjIuNzAxOCAyMS43OTA2IDIyLjI0NjIgMjIuMjQ2MkMyMS43OTA1IDIyLjcwMTggMjEuMDUxOSAyMi43MDE4IDIwLjU5NjIgMjIuMjQ2MkwxNiAxNy42NDk5TDExLjQwMzkgMjIuMjQ2QzEwLjk0ODIgMjIuNzAxNyAxMC4yMDk2IDIyLjcwMTcgOS43NTM5NCAyMi4yNDZDOS4yOTgzMyAyMS43OTA0IDkuMjk4MzMgMjEuMDUxNyA5Ljc1Mzk0IDIwLjU5NjFMMTQuMzUwMSAxNkw5Ljc1Mzk0IDExLjQwMzlDOS4yOTgzMyAxMC45NDgzIDkuMjk4MzMgMTAuMjA5NiA5Ljc1Mzk0IDkuNzUzOTZDMTAuMjA5NiA5LjI5ODM1IDEwLjk0ODIgOS4yOTgzNSAxMS40MDM5IDkuNzUzOTZMMTYgMTQuMzUwMUwyMC41OTYyIDkuNzUzODJDMjEuMDUxOSA5LjI5ODIxIDIxLjc5MDUgOS4yOTgyMSAyMi4yNDYyIDkuNzUzODJaXCIgZmlsbD1cIiMzMzMzMzJcIi8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5gO1xuY2xhc3MgUzUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBIZSh0aGlzLCBcImJyaWRnZVVybFwiLCBcImh0dHBzOi8vbG9naW4uYXJnZW50Lnh5elwiKTtcbiAgICBIZSh0aGlzLCBcIm1vYmlsZVVybFwiLCBcImFyZ2VudDovL1wiKTtcbiAgICBIZSh0aGlzLCBcInR5cGVcIiwgXCJvdmVybGF5XCIpO1xuICAgIEhlKHRoaXMsIFwid2NVcmlcIik7XG4gICAgSGUodGhpcywgXCJvdmVybGF5XCIpO1xuICAgIEhlKHRoaXMsIFwicG9wdXBXaW5kb3dcIik7XG4gICAgSGUodGhpcywgXCJjbG9zaW5nVGltZW91dFwiKTtcbiAgICBIZSh0aGlzLCBcImNsb3NlXCIsICgpID0+IHtcbiAgICAgIHRoaXMub3ZlcmxheT8ucmVtb3ZlKCksIHRoaXMucG9wdXBXaW5kb3c/LmNsb3NlKCksIHRoaXMub3ZlcmxheSA9IHZvaWQgMCwgdGhpcy5wb3B1cFdpbmRvdyA9IHZvaWQgMDtcbiAgICB9KTtcbiAgfVxuICBzaG93Q29ubmVjdGlvbk1vZGFsKGUpIHtcbiAgICBjb25zdCB0ID0gZW5jb2RlVVJJQ29tcG9uZW50KGUpLCBpID0gZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB0aGlzLnNob3dNb2RhbCh7XG4gICAgICBkZXNrdG9wOiBgJHt0aGlzLmJyaWRnZVVybH0/d2M9JHt0fSZocmVmPSR7aX0mZGV2aWNlPWRlc2t0b3BgLFxuICAgICAgaW9zOiBgJHt0aGlzLm1vYmlsZVVybH1hcHAvd2M/dXJpPSR7dH0maHJlZj0ke2l9JmRldmljZT1tb2JpbGVgLFxuICAgICAgYW5kcm9pZDogYCR7dGhpcy5tb2JpbGVVcmx9YXBwL3djP3VyaT0ke3R9JmhyZWY9JHtpfSZkZXZpY2U9bW9iaWxlYFxuICAgIH0pO1xuICB9XG4gIHNob3dBcHByb3ZhbE1vZGFsKGUpIHtcbiAgICBpZiAoU3MgPT09IFwiZGVza3RvcFwiKSB7XG4gICAgICB0aGlzLnNob3dNb2RhbCh7XG4gICAgICAgIGRlc2t0b3A6IGAke3RoaXMuYnJpZGdlVXJsfT9hY3Rpb249c2lnbmAsXG4gICAgICAgIGlvczogXCJcIixcbiAgICAgICAgYW5kcm9pZDogXCJcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHQgPSBlbmNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIHRoaXMuc2hvd01vZGFsKHtcbiAgICAgIGRlc2t0b3A6IGAke3RoaXMuYnJpZGdlVXJsfT9hY3Rpb249c2lnbiZkZXZpY2U9ZGVza3RvcCZocmVmPSR7dH1gLFxuICAgICAgaW9zOiBgJHt0aGlzLm1vYmlsZVVybH1hcHAvd2MvcmVxdWVzdD9ocmVmPSR7dH0mZGV2aWNlPW1vYmlsZWAsXG4gICAgICBhbmRyb2lkOiBgJHt0aGlzLm1vYmlsZVVybH1hcHAvd2MvcmVxdWVzdD9ocmVmPSR7dH0mZGV2aWNlPW1vYmlsZWBcbiAgICB9KTtcbiAgfVxuICBjbG9zZU1vZGFsKGUpIHtcbiAgICBlID8gKHRoaXMub3ZlcmxheT8ucXVlcnlTZWxlY3RvcihcImlmcmFtZVwiKT8uY29udGVudFdpbmRvdz8ucG9zdE1lc3NhZ2UoXCJhcmdlbnQtbG9naW4uc3VjY2Vzc1wiLCBcIipcIiksIHRoaXMucG9wdXBXaW5kb3c/LnBvc3RNZXNzYWdlKFwiYXJnZW50LWxvZ2luLnN1Y2Nlc3NcIiwgXCIqXCIpLCB0aGlzLmNsb3NpbmdUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNsb3NlLCAzNDAwKSkgOiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgc2hvd01vZGFsKGUpIHtcbiAgICBpZiAoY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2luZ1RpbWVvdXQpLCAodGhpcy5vdmVybGF5IHx8IHRoaXMucG9wdXBXaW5kb3cpICYmIHRoaXMuY2xvc2UoKSwgU3MgPT09IFwiYW5kcm9pZFwiIHx8IFNzID09PSBcImlvc1wiKSB7XG4gICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgIHMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCBzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZVtTc107XG4gICAgICB9KSwgcy5jbGljaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50eXBlID09PSBcIndpbmRvd1wiKSB7XG4gICAgICBjb25zdCBzID0gXCJtZW51YmFyPW5vLGxvY2F0aW9uPW5vLHJlc2l6YWJsZT1ubyxzY3JvbGxiYXJzPW5vLHN0YXR1cz1ubyx3aWR0aD04NDAsaGVpZ2h0PTU0MFwiO1xuICAgICAgdGhpcy5wb3B1cFdpbmRvdyA9IHdpbmRvdy5vcGVuKGUuZGVza3RvcCwgXCJfYmxhbmtcIiwgcykgfHwgdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0LmlubmVySFRNTCA9IEU1LCB0LmlkID0gXCJhcmdlbnQtbW9iaWxlLW1vZGFsLW92ZXJsYXlcIjtcbiAgICBmb3IgKGNvbnN0IFtzLCBvXSBvZiBPYmplY3QuZW50cmllcyhfNSkpXG4gICAgICB0LnN0eWxlW3NdID0gbztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLmNsb3NlTW9kYWwoKSksIHRoaXMub3ZlcmxheSA9IHQ7XG4gICAgY29uc3QgaSA9IHQucXVlcnlTZWxlY3RvcihcImlmcmFtZVwiKTtcbiAgICBpLnNldEF0dHJpYnV0ZShcInNyY1wiLCBlLmRlc2t0b3ApO1xuICAgIGZvciAoY29uc3QgW3MsIG9dIG9mIE9iamVjdC5lbnRyaWVzKHg1KSlcbiAgICAgIGkuc3R5bGVbc10gPSBvO1xuICAgIHQucXVlcnlTZWxlY3RvcihcbiAgICAgIFwiLmFyZ2VudC1jbG9zZS1idXR0b25cIlxuICAgICkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuY2xvc2VNb2RhbCgpKTtcbiAgfVxufVxuY29uc3QgTnIgPSBuZXcgUzUoKSwgdGEgPSAkaS5OZXR3b3JrTmFtZSwgTTUgPSBhc3luYyAoe1xuICBwcm9qZWN0SWQ6IHIsXG4gIGNoYWluSWQ6IGUsXG4gIG5hbWU6IHQsXG4gIGRlc2NyaXB0aW9uOiBpLFxuICBycGNVcmw6IG4sXG4gIGJyaWRnZVVybDogcyA9IEk1KGUpLFxuICBtb2JpbGVVcmw6IG8gPSBBNShlKSxcbiAgbW9kYWxUeXBlOiBmID0gXCJvdmVybGF5XCIsXG4gIHVybDogaCxcbiAgaWNvbnM6IGQsXG4gIHdhbGxldENvbm5lY3Q6IHZcbn0sIHcpID0+IHtcbiAgaWYgKCFzKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJyaWRnZVVybCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKCFvKVxuICAgIHRocm93IG5ldyBFcnJvcihcIm1vYmlsZVVybCBpcyByZXF1aXJlZFwiKTtcbiAgTnIuYnJpZGdlVXJsID0gcywgTnIubW9iaWxlVXJsID0gbywgTnIudHlwZSA9IGY7XG4gIGNvbnN0IEEgPSB7XG4gICAgcHJvamVjdElkOiByLFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICBuYW1lOiB0ID8/IFwiVW5rbm93biBkYXBwXCIsXG4gICAgICBkZXNjcmlwdGlvbjogaSA/PyBcIlVua25vd24gZGFwcCBkZXNjcmlwdGlvblwiLFxuICAgICAgdXJsOiBoID8/IFwiI1wiLFxuICAgICAgaWNvbnM6IGQgPz8gW10sXG4gICAgICAuLi52Py5tZXRhZGF0YVxuICAgIH1cbiAgfSwgSSA9IGF3YWl0IE9hLmluaXQoQSksIEQgPSBuZXcgUmgoeyBub2RlVXJsOiBuIH0pLCBOID0gbmV3IHcoeyBjbGllbnQ6IEksIGNoYWluSWQ6IGUsIHJwY1VybDogbiwgcHJvdmlkZXI6IEQgfSk7XG4gIEkub24oXCJzZXNzaW9uX2V2ZW50XCIsIChrKSA9PiB7XG4gIH0pLCBJLm9uKFwic2Vzc2lvbl91cGRhdGVcIiwgKHsgdG9waWM6IGssIHBhcmFtczogaiB9KSA9PiB7XG4gICAgY29uc3QgeyBuYW1lc3BhY2VzOiBUIH0gPSBqLCBLID0gSS5zZXNzaW9uLmdldChrKTtcbiAgICBOLnVwZGF0ZVNlc3Npb24oeyAuLi5LLCBuYW1lc3BhY2VzOiBUIH0pO1xuICB9KSwgSS5vbihcInNlc3Npb25fZGVsZXRlXCIsICgpID0+IHtcbiAgfSk7XG4gIHRyeSB7XG4gICAgY29uc3QgayA9IEkuc2Vzc2lvbi5nZXRBbGwoKS5maW5kKE4uaXNWYWxpZFNlc3Npb24pO1xuICAgIGlmIChrKVxuICAgICAgcmV0dXJuIE4udXBkYXRlU2Vzc2lvbihrKSwgTjtcbiAgICBjb25zdCBqID0geyByZXF1aXJlZE5hbWVzcGFjZXM6IE4uZ2V0UmVxdWlyZWROYW1lc3BhY2VzKCkgfTtcbiAgICBkbCgpLCBhd2FpdCBuZXcgUHJvbWlzZSgoJCkgPT4gc2V0VGltZW91dCgkLCAyMDApKTtcbiAgICBjb25zdCB7IHVyaTogVCwgYXBwcm92YWw6IEsgfSA9IGF3YWl0IEkuY29ubmVjdChqKTtcbiAgICBpZiAoVCkge1xuICAgICAgTnIuc2hvd0Nvbm5lY3Rpb25Nb2RhbChUKSwgTnIud2NVcmkgPSBUO1xuICAgICAgY29uc3QgJCA9IGF3YWl0IEsoKTtcbiAgICAgIE4udXBkYXRlU2Vzc2lvbigkKSwgTnIuY2xvc2VNb2RhbChcImFuaW1hdGVTdWNjZXNzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJAYXJnZW50L2xvZ2luOjplcnJvclwiKSwgTnIuY2xvc2VNb2RhbCgpLCBudWxsO1xuICB9XG59LCBJNSA9IChyKSA9PiB7XG4gIGlmICghcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVW5rbm93biBvciB1bnN1cHBvcnRlZCBjaGFpbklkICgke3J9KSwgZWl0aGVyIHNwZWNpZnkgYSBzdXBwb3J0ZWQgY2hhaW4gb3Igc2V0IGJyaWRnZVVybC5gXG4gICAgKTtcbiAgY29uc3QgZSA9IHBhcnNlSW50KGAke3J9YCk7XG4gIGlmIChTdHJpbmcocikuc3RhcnRzV2l0aCh0YS5TTl9TRVBPTElBKSB8fCBlID09PSAxMTE1NTExMSlcbiAgICByZXR1cm4gXCJodHRwczovL21vYmlsZS1sb2dpbi5oeWRyb2dlbi5hcmdlbnQ0Ny5uZXRcIjtcbiAgaWYgKFN0cmluZyhyKS5zdGFydHNXaXRoKHRhLlNOX01BSU4pIHx8IGUgPT09IDEpXG4gICAgcmV0dXJuIFwiaHR0cHM6Ly9sb2dpbi5hcmdlbnQueHl6XCI7XG59LCBBNSA9IChyKSA9PiB7XG4gIGlmICghcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVW5rbm93biBvciB1bnN1cHBvcnRlZCBjaGFpbklkICgke3J9KSwgZWl0aGVyIHNwZWNpZnkgYSBzdXBwb3J0ZWQgY2hhaW4gb3Igc2V0IG1vYmlsZVVybC5gXG4gICAgKTtcbiAgY29uc3QgZSA9IHBhcnNlSW50KGAke3J9YCk7XG4gIGlmIChTdHJpbmcocikuc3RhcnRzV2l0aCh0YS5TTl9TRVBPTElBKSB8fCBlID09PSAxMTE1NTExMSlcbiAgICByZXR1cm4gXCJhcmdlbnQtZGV2Oi8vXCI7XG4gIGlmIChTdHJpbmcocikuc3RhcnRzV2l0aCh0YS5TTl9NQUlOKSB8fCBlID09PSAxKVxuICAgIHJldHVybiBcImFyZ2VudDovL1wiO1xufTtcbmZ1bmN0aW9uIEQ1KHIpIHtcbiAgcmV0dXJuIHR5cGVvZiByIDwgXCJ1XCIgJiYgdHlwZW9mIHIuY29udGV4dCA8IFwidVwiO1xufVxuY29uc3QgVHIgPSB7IGluaXQ6IFwic2lnbmVyX2luaXRcIiwgdXJpOiBcInNpZ25lcl91cmlcIiwgY3JlYXRlZDogXCJzaWduZXJfY3JlYXRlZFwiLCB1cGRhdGVkOiBcInNpZ25lcl91cGRhdGVkXCIsIGRlbGV0ZWQ6IFwic2lnbmVyX2RlbGV0ZWRcIiwgZXZlbnQ6IFwic2lnbmVyX2V2ZW50XCIgfTtcbmNsYXNzIFA1IGV4dGVuZHMgWW0ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5ldmVudHMgPSBuZXcgaXIuRXZlbnRFbWl0dGVyKCksIHRoaXMucGVuZGluZyA9ICExLCB0aGlzLmluaXRpYWxpemluZyA9ICExLCB0aGlzLnJlcXVpcmVkTmFtZXNwYWNlcyA9IGU/LnJlcXVpcmVkTmFtZXNwYWNlcyB8fCB7fSwgdGhpcy5vcHRzID0gZT8uY2xpZW50O1xuICB9XG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnNlc3Npb24gPCBcInVcIjtcbiAgfVxuICBnZXQgY29ubmVjdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nO1xuICB9XG4gIGdldCBjaGFpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbiA/IGVkKHRoaXMuc2Vzc2lvbi5uYW1lc3BhY2VzKSA6IFYyKHRoaXMucmVxdWlyZWROYW1lc3BhY2VzKTtcbiAgfVxuICBnZXQgYWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbiA/IFF1KHRoaXMuc2Vzc2lvbi5uYW1lc3BhY2VzKSA6IFtdO1xuICB9XG4gIG9uKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vbihlLCB0KTtcbiAgfVxuICBvbmNlKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vbmNlKGUsIHQpO1xuICB9XG4gIG9mZihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHMub2ZmKGUsIHQpO1xuICB9XG4gIHJlbW92ZUxpc3RlbmVyKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihlLCB0KTtcbiAgfVxuICBhc3luYyBvcGVuKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmcpXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGUsIHQpID0+IHtcbiAgICAgICAgdGhpcy5ldmVudHMub25jZShcIm9wZW5cIiwgKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5vbmNlKFwib3Blbl9lcnJvclwiLCAoaSkgPT4ge1xuICAgICAgICAgICAgdChpKTtcbiAgICAgICAgICB9KSwgdHlwZW9mIHRoaXMuY2xpZW50ID4gXCJ1XCIpXG4gICAgICAgICAgICByZXR1cm4gdChuZXcgRXJyb3IoXCJTaWduIENsaWVudCBub3QgaW5pdGlhbGl6ZWRcIikpO1xuICAgICAgICAgIGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5wZW5kaW5nID0gITA7XG4gICAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5yZWdpc3RlcigpLCB0ID0gZS5maW5kKHsgcmVxdWlyZWROYW1lc3BhY2VzOiB0aGlzLnJlcXVpcmVkTmFtZXNwYWNlcyB9KTtcbiAgICAgIGlmICh0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHRoaXMub25PcGVuKHRbMF0pO1xuICAgICAgY29uc3QgeyB1cmk6IGksIGFwcHJvdmFsOiBuIH0gPSBhd2FpdCBlLmNvbm5lY3QoeyByZXF1aXJlZE5hbWVzcGFjZXM6IHRoaXMucmVxdWlyZWROYW1lc3BhY2VzIH0pO1xuICAgICAgdGhpcy5ldmVudHMuZW1pdChUci51cmksIHsgdXJpOiBpIH0pLCB0aGlzLnNlc3Npb24gPSBhd2FpdCBuKCksIHRoaXMuZXZlbnRzLmVtaXQoVHIuY3JlYXRlZCwgdGhpcy5zZXNzaW9uKSwgdGhpcy5vbk9wZW4oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyB0aGlzLmV2ZW50cy5lbWl0KFwib3Blbl9lcnJvclwiLCBlKSwgZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgdHlwZW9mIHRoaXMuc2Vzc2lvbiA+IFwidVwiIHx8IChhd2FpdCAoYXdhaXQgdGhpcy5yZWdpc3RlcigpKS5kaXNjb25uZWN0KHsgdG9waWM6IHRoaXMuc2Vzc2lvbi50b3BpYywgcmVhc29uOiBzdChcIlVTRVJfRElTQ09OTkVDVEVEXCIpIH0pLCB0aGlzLm9uQ2xvc2UoKSk7XG4gIH1cbiAgYXN5bmMgc2VuZChlLCB0KSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmNsaWVudCA+IFwidVwiICYmICh0aGlzLmNsaWVudCA9IGF3YWl0IHRoaXMucmVnaXN0ZXIoKSwgdGhpcy5jb25uZWN0ZWQgfHwgYXdhaXQgdGhpcy5vcGVuKCkpLCB0eXBlb2YgdGhpcy5zZXNzaW9uID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduZXIgY29ubmVjdGlvbiBpcyBtaXNzaW5nIHNlc3Npb25cIik7XG4gICAgdGhpcy5jbGllbnQucmVxdWVzdCh7IHRvcGljOiB0aGlzLnNlc3Npb24udG9waWMsIHJlcXVlc3Q6IGUsIGNoYWluSWQ6IHQ/LmNoYWluSWQgfSkudGhlbigoaSkgPT4gdGhpcy5ldmVudHMuZW1pdChcInBheWxvYWRcIiwgTWEoZS5pZCwgaSkpKS5jYXRjaCgoaSkgPT4gdGhpcy5ldmVudHMuZW1pdChcInBheWxvYWRcIiwgSWEoZS5pZCwgaS5tZXNzYWdlKSkpO1xuICB9XG4gIGFzeW5jIHJlZ2lzdGVyKGUgPSB0aGlzLm9wdHMpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuY2xpZW50IDwgXCJ1XCIpXG4gICAgICByZXR1cm4gdGhpcy5jbGllbnQ7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6aW5nKVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCh0LCBpKSA9PiB7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uY2UoXCJyZWdpc3Rlcl9lcnJvclwiLCAobikgPT4ge1xuICAgICAgICAgIGkobik7XG4gICAgICAgIH0pLCB0aGlzLmV2ZW50cy5vbmNlKFRyLmluaXQsICgpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2xpZW50ID4gXCJ1XCIpXG4gICAgICAgICAgICByZXR1cm4gaShuZXcgRXJyb3IoXCJTaWduIENsaWVudCBub3QgaW5pdGlhbGl6ZWRcIikpO1xuICAgICAgICAgIHQodGhpcy5jbGllbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIGlmIChENShlKSlcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudCA9IGUsIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCB0aGlzLmNsaWVudDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6aW5nID0gITAsIHRoaXMuY2xpZW50ID0gYXdhaXQgT2EuaW5pdChlKSwgdGhpcy5pbml0aWFsaXppbmcgPSAhMSwgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCksIHRoaXMuZXZlbnRzLmVtaXQoVHIuaW5pdCksIHRoaXMuY2xpZW50O1xuICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgIHRocm93IHRoaXMuZXZlbnRzLmVtaXQoXCJyZWdpc3Rlcl9lcnJvclwiLCB0KSwgdDtcbiAgICB9XG4gIH1cbiAgb25PcGVuKGUpIHtcbiAgICB0aGlzLnBlbmRpbmcgPSAhMSwgZSAmJiAodGhpcy5zZXNzaW9uID0gZSksIHRoaXMuZXZlbnRzLmVtaXQoXCJvcGVuXCIpO1xuICB9XG4gIG9uQ2xvc2UoKSB7XG4gICAgdGhpcy5wZW5kaW5nID0gITEsIHRoaXMuY2xpZW50ICYmICh0aGlzLmNsaWVudCA9IHZvaWQgMCksIHRoaXMuZXZlbnRzLmVtaXQoXCJjbG9zZVwiKTtcbiAgfVxuICByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHR5cGVvZiB0aGlzLmNsaWVudCA8IFwidVwiICYmICh0aGlzLmNsaWVudC5vbihcInNlc3Npb25fZXZlbnRcIiwgKGUpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgdGhpcy5zZXNzaW9uICYmICgodCA9IHRoaXMuc2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IHQudG9waWMpICE9PSBlLnRvcGljIHx8IHRoaXMuZXZlbnRzLmVtaXQoVHIuZXZlbnQsIGUucGFyYW1zKTtcbiAgICB9KSwgdGhpcy5jbGllbnQub24oXCJzZXNzaW9uX3VwZGF0ZVwiLCAoZSkgPT4ge1xuICAgICAgdmFyIHQ7XG4gICAgICB0eXBlb2YgdGhpcy5jbGllbnQgPCBcInVcIiAmJiAodGhpcy5zZXNzaW9uICYmICgodCA9IHRoaXMuc2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IHQudG9waWMpICE9PSBlLnRvcGljIHx8ICh0aGlzLnNlc3Npb24gPSB0aGlzLmNsaWVudC5zZXNzaW9uLmdldChlLnRvcGljKSwgdGhpcy5ldmVudHMuZW1pdChUci51cGRhdGVkLCB0aGlzLnNlc3Npb24pKSk7XG4gICAgfSksIHRoaXMuY2xpZW50Lm9uKFwic2Vzc2lvbl9kZWxldGVcIiwgKGUpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgdGhpcy5zZXNzaW9uICYmICh0aGlzLnNlc3Npb24gJiYgKCh0ID0gdGhpcy5zZXNzaW9uKSA9PSBudWxsID8gdm9pZCAwIDogdC50b3BpYykgIT09IGUudG9waWMgfHwgKHRoaXMub25DbG9zZSgpLCB0aGlzLmV2ZW50cy5lbWl0KFRyLmRlbGV0ZWQsIHRoaXMuc2Vzc2lvbiksIHRoaXMuc2Vzc2lvbiA9IHZvaWQgMCkpO1xuICAgIH0pKTtcbiAgfVxufVxuY2xhc3MgTzUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBIZSh0aGlzLCBcImFjY291bnRzXCIsIFtdKTtcbiAgICBIZSh0aGlzLCBcImV2ZW50RW1pdHRlclwiLCBuZXcgaXIuRXZlbnRFbWl0dGVyKCkpO1xuICAgIEhlKHRoaXMsIFwidXBkYXRlU2Vzc2lvblwiLCAoZSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRTZXNzaW9uKGUpKVxuICAgICAgICB0aHJvdyBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJ1cGRhdGVTZXNzaW9uIGluY29tcGF0aWJsZSBzZXNzaW9uXCIsXG4gICAgICAgICAgZSxcbiAgICAgICAgICBcImZvciBhZGFwdGVyXCIsXG4gICAgICAgICAgdGhpcy5mb3JtYXRDaGFpbklkKHRoaXMuY2hhaW5JZClcbiAgICAgICAgKSwgbmV3IEVycm9yKFwiSW52YWxpZCBzZXNzaW9uXCIpO1xuICAgICAgdGhpcy5zZXNzaW9uID0gZTtcbiAgICAgIGNvbnN0IHQgPSBlZChlLm5hbWVzcGFjZXMsIFt0aGlzLm5hbWVzcGFjZV0pO1xuICAgICAgdGhpcy5zZXRDaGFpbklkcyh0KTtcbiAgICAgIGNvbnN0IGkgPSBRdShlLm5hbWVzcGFjZXMsIFtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VcbiAgICAgIF0pO1xuICAgICAgdGhpcy5zZXRBY2NvdW50cyhpKTtcbiAgICB9KTtcbiAgICBIZSh0aGlzLCBcImlzVmFsaWRTZXNzaW9uXCIsICh7XG4gICAgICBuYW1lc3BhY2VzOiBlLFxuICAgICAgcmVxdWlyZWROYW1lc3BhY2VzOiB0XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuZm9ybWF0Q2hhaW5JZCh0aGlzLmNoYWluSWQpO1xuICAgICAgcmV0dXJuIHQgPyAhIXRbdGhpcy5uYW1lc3BhY2VdPy5jaGFpbnM/LmluY2x1ZGVzKGkpIDogISFlPy5bdGhpcy5uYW1lc3BhY2VdPy5hY2NvdW50cy5zb21lKFxuICAgICAgICAobikgPT4gbi5zdGFydHNXaXRoKGkpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGdldFJlcXVpcmVkTmFtZXNwYWNlcygpIHtcbiAgICBjb25zdCBlID0gW3RoaXMuZm9ybWF0Q2hhaW5JZCh0aGlzLmNoYWluSWQpXTtcbiAgICByZXR1cm4ge1xuICAgICAgW3RoaXMubmFtZXNwYWNlXTogeyBjaGFpbnM6IGUsIG1ldGhvZHM6IHRoaXMubWV0aG9kcywgZXZlbnRzOiB0aGlzLmV2ZW50cyB9XG4gICAgfTtcbiAgfVxuICBpc0NvbXBhdGlibGVDaGFpbklkKGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUuc3RhcnRzV2l0aChgJHt0aGlzLm5hbWVzcGFjZX06YCkgOiAhMTtcbiAgfVxuICBzZXRDaGFpbklkcyhlKSB7XG4gICAgY29uc3QgaSA9IGUuZmlsdGVyKChuKSA9PiB0aGlzLmlzQ29tcGF0aWJsZUNoYWluSWQobikpLm1hcCgobikgPT4gdGhpcy5wYXJzZUNoYWluSWQobikpLmZpbHRlcigobikgPT4gbiAhPT0gdGhpcy5jaGFpbklkKTtcbiAgICBpLmxlbmd0aCAmJiAodGhpcy5jaGFpbklkID0gaVswXSwgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdChcImNoYWluQ2hhbmdlZFwiLCB0aGlzLmNoYWluSWQpKTtcbiAgfVxuICBzZXRDaGFpbklkKGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbXBhdGlibGVDaGFpbklkKGUpKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5wYXJzZUNoYWluSWQoZSk7XG4gICAgICB0aGlzLmNoYWluSWQgPSB0LCB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiY2hhaW5DaGFuZ2VkXCIsIHRoaXMuY2hhaW5JZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlQWNjb3VudElkKGUpIHtcbiAgICBjb25zdCBbdCwgaSwgbl0gPSBlLnNwbGl0KFwiOlwiKTtcbiAgICByZXR1cm4geyBjaGFpbklkOiBgJHt0fToke2l9YCwgYWRkcmVzczogbiB9O1xuICB9XG4gIGdldFNpZ25lckNvbm5lY3Rpb24oZSkge1xuICAgIHJldHVybiBuZXcgUDUoe1xuICAgICAgcmVxdWlyZWROYW1lc3BhY2VzOiB7XG4gICAgICAgIFt0aGlzLm5hbWVzcGFjZV06IHtcbiAgICAgICAgICBjaGFpbnM6IHRoaXMucnBjLmNoYWlucyxcbiAgICAgICAgICBtZXRob2RzOiB0aGlzLnJwYy5tZXRob2RzLFxuICAgICAgICAgIGV2ZW50czogdGhpcy5ycGMuZXZlbnRzXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbGllbnQ6IGVcbiAgICB9KTtcbiAgfVxuICByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMucnBjUHJvdmlkZXIub24oXCJjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgY2hhaW5zOiBlLCBhY2NvdW50czogdCB9ID0gdGhpcy5zaWduZXJDb25uZWN0aW9uO1xuICAgICAgZT8ubGVuZ3RoICYmIHRoaXMuc2V0Q2hhaW5JZHMoZSksIHQ/Lmxlbmd0aCAmJiB0aGlzLnNldEFjY291bnRzKHQpO1xuICAgIH0pLCB0aGlzLnNpZ25lckNvbm5lY3Rpb24ub24oVHIuY3JlYXRlZCwgdGhpcy51cGRhdGVTZXNzaW9uKSwgdGhpcy5zaWduZXJDb25uZWN0aW9uLm9uKFRyLnVwZGF0ZWQsIHRoaXMudXBkYXRlU2Vzc2lvbiksIHRoaXMuc2lnbmVyQ29ubmVjdGlvbi5vbihUci5ldmVudCwgKGUpID0+IHtcbiAgICAgIGlmICghdGhpcy5ycGMuY2hhaW5zLmluY2x1ZGVzKGUuY2hhaW5JZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHsgZXZlbnQ6IHQgfSA9IGU7XG4gICAgICB0Lm5hbWUgPT09IFwiYWNjb3VudHNDaGFuZ2VkXCIgPyAodGhpcy5hY2NvdW50cyA9IHQuZGF0YSwgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdChcImFjY291bnRzQ2hhbmdlZFwiLCB0aGlzLmFjY291bnRzKSkgOiB0Lm5hbWUgPT09IFwiY2hhaW5DaGFuZ2VkXCIgPyB0aGlzLnNldENoYWluSWQodC5kYXRhKSA6IHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQodC5uYW1lLCB0LmRhdGEpO1xuICAgIH0pLCB0aGlzLnJwY1Byb3ZpZGVyLm9uKFwiZGlzY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiZGlzY29ubmVjdFwiKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgUGggZXh0ZW5kcyB1bCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIGksIG4pIHtcbiAgICBzdXBlcihlLCB0LCBpKSwgdGhpcy53YWxsZXQgPSBuO1xuICB9XG4gIGFzeW5jIGV4ZWN1dGUoZSwgdCwgaSA9IHt9KSB7XG4gICAgY29uc3QgbiA9IEFycmF5LmlzQXJyYXkoZSkgPyBlIDogW2VdLCBzID0gdCA9PT0gdm9pZCAwIHx8IEFycmF5LmlzQXJyYXkodCkgPyBpIDogdDtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy53YWxsZXQud2FsbGV0X3JlcXVlc3RBZGRJbnZva2VUcmFuc2FjdGlvbih7XG4gICAgICBhY2NvdW50QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgZXhlY3V0aW9uUmVxdWVzdDogeyBjYWxsczogbiwgaW52b2NhdGlvbkRldGFpbHM6IHMgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRlY2xhcmUoZSwgdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQgdmlhIEFyZ2VudCBMb2dpblwiKTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50KGUsIHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIHZpYSBBcmdlbnQgTG9naW5cIik7XG4gIH1cbn1cbmNsYXNzIFI1IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMud2FsbGV0ID0gZTtcbiAgfVxuICBhc3luYyBnZXRQdWJLZXkoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCB2aWEgQXJnZW50IExvZ2luXCIpO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKGUsIHQpIHtcbiAgICBjb25zdCB7IHNpZ25hdHVyZTogaSB9ID0gYXdhaXQgdGhpcy53YWxsZXQud2FsbGV0X3NpZ25UeXBlZERhdGEoe1xuICAgICAgYWNjb3VudEFkZHJlc3M6IHQsXG4gICAgICB0eXBlZERhdGE6IGVcbiAgICB9KTtcbiAgICByZXR1cm4gaTtcbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24oZSwgdCwgaSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQgdmlhIEFyZ2VudCBMb2dpblwiKTtcbiAgfVxuICBhc3luYyBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIHZpYSBBcmdlbnQgTG9naW5cIik7XG4gIH1cbiAgYXN5bmMgc2lnbkRlY2xhcmVUcmFuc2FjdGlvbihlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCB2aWEgQXJnZW50IExvZ2luXCIpO1xuICB9XG59XG5jb25zdCBONSA9IChyKSA9PiByLnJlcGxhY2UoL15TTl8vLCBcIlNOXCIpLCBUNSA9IChyKSA9PiByLnJlcGxhY2UoL15TTi8sIFwiU05fXCIpO1xuY2xhc3MgQzUgZXh0ZW5kcyBPNSB7XG4gIC8vIFRPRE86IGltcHJvdmUgdHlwaW5nXG4gIGNvbnN0cnVjdG9yKHsgY2xpZW50OiB0LCBjaGFpbklkOiBpLCBycGNVcmw6IG4sIHByb3ZpZGVyOiBzIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIEhlKHRoaXMsIFwiaWRcIiwgXCJhcmdlbnRNb2JpbGVcIik7XG4gICAgSGUodGhpcywgXCJuYW1lXCIsIFwiQXJnZW50IE1vYmlsZVwiKTtcbiAgICBIZSh0aGlzLCBcInZlcnNpb25cIiwgXCIwLjEuMFwiKTtcbiAgICBIZSh0aGlzLCBcImljb25cIiwgXCJcIik7XG4gICAgSGUodGhpcywgXCJwcm92aWRlclwiKTtcbiAgICBIZSh0aGlzLCBcInNpZ25lclwiKTtcbiAgICBIZSh0aGlzLCBcImFjY291bnRcIik7XG4gICAgSGUodGhpcywgXCJzZWxlY3RlZEFkZHJlc3NcIiwgXCJcIik7XG4gICAgLy8gTmFtZXNwYWNlQWRhcHRlclxuICAgIEhlKHRoaXMsIFwibmFtZXNwYWNlXCIsIFwic3RhcmtuZXRcIik7XG4gICAgSGUodGhpcywgXCJtZXRob2RzXCIsIFtcbiAgICAgIFwic3RhcmtuZXRfc3VwcG9ydGVkU3BlY3NcIixcbiAgICAgIFwic3RhcmtuZXRfc2lnblR5cGVkRGF0YVwiLFxuICAgICAgXCJzdGFya25ldF9yZXF1ZXN0QWRkSW52b2tlVHJhbnNhY3Rpb25cIixcbiAgICAgIFwid2FsbGV0X3N1cHBvcnRlZFNwZWNzXCIsXG4gICAgICBcIndhbGxldF9zaWduVHlwZWREYXRhXCIsXG4gICAgICBcIndhbGxldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiXG4gICAgXSk7XG4gICAgSGUodGhpcywgXCJldmVudHNcIiwgW1wiY2hhaW5DaGFuZ2VkXCIsIFwiYWNjb3VudHNDaGFuZ2VkXCJdKTtcbiAgICBIZSh0aGlzLCBcInJlbW90ZVNpZ25lclwiKTtcbiAgICBIZSh0aGlzLCBcInNpZ25lckNvbm5lY3Rpb25cIik7XG4gICAgSGUodGhpcywgXCJycGNQcm92aWRlclwiKTtcbiAgICBIZSh0aGlzLCBcImNoYWluSWRcIik7XG4gICAgSGUodGhpcywgXCJjbGllbnRcIik7XG4gICAgSGUodGhpcywgXCJzZXNzaW9uXCIpO1xuICAgIEhlKHRoaXMsIFwicnBjXCIpO1xuICAgIEhlKHRoaXMsIFwid2FsbGV0UnBjXCIpO1xuICAgIEhlKHRoaXMsIFwiaGFuZGxlUmVxdWVzdFwiKTtcbiAgICAvLyBTdGFya25ldFdpbmRvd09iamVjdFxuICAgIEhlKHRoaXMsIFwicmVxdWVzdFwiLCBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnNlc3Npb24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNlc3Npb25cIik7XG4gICAgICBsZXQgaSA9IHQudHlwZTtcbiAgICAgIChpID09PSBcIndhbGxldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiIHx8IGkgPT09IFwid2FsbGV0X3N1cHBvcnRlZFNwZWNzXCIgfHwgaSA9PT0gXCJ3YWxsZXRfc2lnblR5cGVkRGF0YVwiKSAmJiAoaSA9IGkucmVwbGFjZShcIndhbGxldF9cIiwgXCJzdGFya25ldF9cIikpO1xuICAgICAgY29uc3QgbiA9IHRoaXMuaGFuZGxlUmVxdWVzdFtpXTtcbiAgICAgIGlmIChuKVxuICAgICAgICByZXR1cm4gbih0LnBhcmFtcyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBpbXBsZW1lbnRlZDogLnJlcXVlc3QoKSBmb3IgJHt0LnR5cGV9YCk7XG4gICAgfSk7XG4gICAgSGUodGhpcywgXCJvblwiLCAodCwgaSkgPT4ge1xuICAgICAgdGhpcy5ldmVudEVtaXR0ZXIub24odCwgaSk7XG4gICAgfSk7XG4gICAgSGUodGhpcywgXCJvZmZcIiwgKHQsIGkpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLm9mZih0LCBpKTtcbiAgICB9KTtcbiAgICBIZSh0aGlzLCBcImhhbmRsZVJlcXVlc3RDaGFpbklkXCIsICgpID0+IHRoaXMuY2hhaW5JZCA9PT0gJGkuTmV0d29ya05hbWUuU05fU0VQT0xJQSA/ICRpLlN0YXJrbmV0Q2hhaW5JZC5TTl9TRVBPTElBIDogJGkuU3RhcmtuZXRDaGFpbklkLlNOX01BSU4pO1xuICAgIEhlKHRoaXMsIFwiaGFuZGxlUmVxdWVzdEFjY291bnRzXCIsICgpID0+IHRoaXMuYWNjb3VudHMpO1xuICAgIEhlKHRoaXMsIFwiaGFuZGxlR2V0UGVybWlzc2lvbnNcIiwgYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5pc1ByZWF1dGhvcml6ZWQoKSA/IFtcImFjY291bnRzXCJdIDogW10pO1xuICAgIEhlKHRoaXMsIFwiaGFuZGxlQWRkSW52b2tlVHJhbnNhY3Rpb25cIiwgYXN5bmMgKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgY2FsbHM6IGkgfSA9IHQ7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0V2FsbGV0KHtcbiAgICAgICAgbWV0aG9kOiBcInN0YXJrbmV0X3JlcXVlc3RBZGRJbnZva2VUcmFuc2FjdGlvblwiLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBhY2NvdW50QWRkcmVzczogdGhpcy5hY2NvdW50LmFkZHJlc3MsXG4gICAgICAgICAgZXhlY3V0aW9uUmVxdWVzdDoge1xuICAgICAgICAgICAgLy8gd2lsbCBiZSByZW1vdmVkIHdoZW4gYXJnZW50IG1vYmlsZSB3aWxsIHN1cHBvcnQgZW50cnlfcG9pbnQgYW5kIGNvbnRyYWN0X2FkZHJlc3NcbiAgICAgICAgICAgIGNhbGxzOiBpPy5tYXAoKHsgY29udHJhY3RfYWRkcmVzczogbiwgZW50cnlfcG9pbnQ6IHMsIC4uLm8gfSkgPT4gKHtcbiAgICAgICAgICAgICAgLi4ubyxcbiAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBuLFxuICAgICAgICAgICAgICBlbnRyeXBvaW50OiBzXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIEhlKHRoaXMsIFwiaGFuZGxlU2lnblR5cGVkRGF0YVwiLCBhc3luYyAodCkgPT4ge1xuICAgICAgY29uc3QgaSA9IHtcbiAgICAgICAgYWNjb3VudEFkZHJlc3M6IHRoaXMuYWNjb3VudC5hZGRyZXNzLFxuICAgICAgICB0eXBlZERhdGE6IHRcbiAgICAgIH0sIG4gPSBhd2FpdCB0aGlzLnJlcXVlc3RXYWxsZXQoe1xuICAgICAgICBtZXRob2Q6IFwic3RhcmtuZXRfc2lnblR5cGVkRGF0YVwiLFxuICAgICAgICBwYXJhbXM6IGlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFwic2lnbmF0dXJlXCIgaW4gbiA/IG4uc2lnbmF0dXJlIDogbjtcbiAgICB9KTtcbiAgICBIZSh0aGlzLCBcImhhbmRsZVN1cHBvcnRlZFNwZWNzXCIsIGFzeW5jICgpID0+IGF3YWl0IHRoaXMucmVxdWVzdFdhbGxldCh7XG4gICAgICBtZXRob2Q6IFwic3RhcmtuZXRfc3VwcG9ydGVkU3BlY3NcIixcbiAgICAgIHBhcmFtczoge31cbiAgICB9KSk7XG4gICAgdGhpcy5jaGFpbklkID0gU3RyaW5nKGkgPz8gJGkuTmV0d29ya05hbWUuU05fTUFJTiksIHRoaXMucnBjID0ge1xuICAgICAgY2hhaW5zOiBpID8gW3RoaXMuZm9ybWF0Q2hhaW5JZCh0aGlzLmNoYWluSWQpXSA6IFtdLFxuICAgICAgbWV0aG9kczogdGhpcy5tZXRob2RzLFxuICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50c1xuICAgIH0sIHRoaXMuc2lnbmVyQ29ubmVjdGlvbiA9IHRoaXMuZ2V0U2lnbmVyQ29ubmVjdGlvbih0KSwgdGhpcy5ycGNQcm92aWRlciA9IG5ldyB4ZCh0aGlzLnNpZ25lckNvbm5lY3Rpb24pLCB0aGlzLmNsaWVudCA9IHQsIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCB0aGlzLndhbGxldFJwYyA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgZ2V0OiAobywgZikgPT4gKGgpID0+IHRoaXMucmVxdWVzdFdhbGxldCh7IG1ldGhvZDogZiwgcGFyYW1zOiBoIH0pXG4gICAgfSksIHRoaXMucmVtb3RlU2lnbmVyID0gbmV3IFI1KHRoaXMud2FsbGV0UnBjKSwgdGhpcy5wcm92aWRlciA9IHMgfHwgbmV3IFJoKHsgbm9kZVVybDogbiB9KSwgdGhpcy5hY2NvdW50ID0gbmV3IFBoKFxuICAgICAgdGhpcy5wcm92aWRlcixcbiAgICAgIFwiXCIsXG4gICAgICB0aGlzLnJlbW90ZVNpZ25lcixcbiAgICAgIHRoaXMud2FsbGV0UnBjXG4gICAgKSwgdGhpcy5oYW5kbGVSZXF1ZXN0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICB3YWxsZXRfcmVxdWVzdENoYWluSWQ6IHRoaXMuaGFuZGxlUmVxdWVzdENoYWluSWQsXG4gICAgICB3YWxsZXRfcmVxdWVzdEFjY291bnRzOiB0aGlzLmhhbmRsZVJlcXVlc3RBY2NvdW50cyxcbiAgICAgIHdhbGxldF9nZXRQZXJtaXNzaW9uczogdGhpcy5oYW5kbGVHZXRQZXJtaXNzaW9ucyxcbiAgICAgIHN0YXJrbmV0X2FkZEludm9rZVRyYW5zYWN0aW9uOiB0aGlzLmhhbmRsZUFkZEludm9rZVRyYW5zYWN0aW9uLFxuICAgICAgc3RhcmtuZXRfc2lnblR5cGVkRGF0YTogdGhpcy5oYW5kbGVTaWduVHlwZWREYXRhLFxuICAgICAgc3RhcmtuZXRfc3VwcG9ydGVkU3BlY3M6IHRoaXMuaGFuZGxlU3VwcG9ydGVkU3BlY3MsXG4gICAgICB3YWxsZXRfYWRkSW52b2tlVHJhbnNhY3Rpb246IHRoaXMuaGFuZGxlQWRkSW52b2tlVHJhbnNhY3Rpb24sXG4gICAgICB3YWxsZXRfc2lnblR5cGVkRGF0YTogdGhpcy5oYW5kbGVTaWduVHlwZWREYXRhLFxuICAgICAgd2FsbGV0X3N1cHBvcnRlZFNwZWNzOiB0aGlzLmhhbmRsZVN1cHBvcnRlZFNwZWNzXG4gICAgfSk7XG4gIH1cbiAgZ2V0TmV0d29ya05hbWUodCkge1xuICAgIGlmICh0ID09PSBcIlNOX1NFUE9MSUFcIilcbiAgICAgIHJldHVybiAkaS5OZXR3b3JrTmFtZS5TTl9TRVBPTElBO1xuICAgIGlmICh0ID09PSBcIlNOX01BSU5cIilcbiAgICAgIHJldHVybiAkaS5OZXR3b3JrTmFtZS5TTl9NQUlOO1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdGFya25ldC5qcyBuZXR3b3JrIG5hbWUgZm9yIGNoYWluSWQgJHt0fWApO1xuICB9XG4gIGFzeW5jIGVuYWJsZSgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5ycGNQcm92aWRlci5jb25uZWN0KCksIHRoaXMuYWNjb3VudHM7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIGdldCBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgYXN5bmMgaXNQcmVhdXRob3JpemVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuY2xpZW50LnNlc3Npb24uZ2V0QWxsKCkuZmluZCh0aGlzLmlzVmFsaWRTZXNzaW9uKTtcbiAgfVxuICBhc3luYyByZXF1ZXN0V2FsbGV0KHQpIHtcbiAgICBpZiAoIXRoaXMuc2Vzc2lvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNlc3Npb25cIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IGkgfSA9IHRoaXMuc2Vzc2lvbiwgbiA9IHRoaXMuZm9ybWF0Q2hhaW5JZCh0aGlzLmNoYWluSWQpO1xuICAgICAgTnIuc2hvd0FwcHJvdmFsTW9kYWwodCk7XG4gICAgICBjb25zdCBzID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7IHRvcGljOiBpLCBjaGFpbklkOiBuLCByZXF1ZXN0OiB0IH0pO1xuICAgICAgcmV0dXJuIE5yLmNsb3NlTW9kYWwoXCJhbmltYXRlU3VjY2Vzc1wiKSwgcztcbiAgICB9IGNhdGNoIChpKSB7XG4gICAgICB0aHJvdyBOci5jbG9zZU1vZGFsKCksIGkgaW5zdGFuY2VvZiBFcnJvciB8fCBpICYmIGkubWVzc2FnZSAhPT0gdm9pZCAwID8gbmV3IEVycm9yKGkubWVzc2FnZSkgOiBuZXcgRXJyb3IoXCJVbmtub3duIGVycm9yIG9uIHJlcXVlc3RXYWxsZXRcIik7XG4gICAgfVxuICB9XG4gIC8vIE5hbWVzcGFjZUFkYXB0ZXJcbiAgZ2V0IGlzQ29ubmVjdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduZXJDb25uZWN0aW9uLmNvbm5lY3Rpbmc7XG4gIH1cbiAgYXN5bmMgZGlzYWJsZSgpIHtcbiAgICBhd2FpdCB0aGlzLnJwY1Byb3ZpZGVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBnZXQgaXNXYWxsZXRDb25uZWN0KCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvLyBOYW1lc3BhY2VBZGFwdGVyIHByaXZhdGUgbWV0aG9kc1xuICByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHN1cGVyLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5ldmVudEVtaXR0ZXIub24oXCJjaGFpbkNoYW5nZWRcIiwgKHQpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZDogY2hhaW5DaGFuZ2VkXCIpO1xuICAgIH0pO1xuICB9XG4gIGZvcm1hdENoYWluSWQodCkge1xuICAgIHJldHVybiBgJHt0aGlzLm5hbWVzcGFjZX06JHtONSh0KX1gO1xuICB9XG4gIHBhcnNlQ2hhaW5JZCh0KSB7XG4gICAgcmV0dXJuIFQ1KHQuc3BsaXQoXCI6XCIpWzFdKTtcbiAgfVxuICBzZXRBY2NvdW50cyh0KSB7XG4gICAgdGhpcy5hY2NvdW50cyA9IHQuZmlsdGVyKFxuICAgICAgKHMpID0+IHRoaXMucGFyc2VDaGFpbklkKHRoaXMucGFyc2VBY2NvdW50SWQocykuY2hhaW5JZCkgPT09IHRoaXMuY2hhaW5JZFxuICAgICkubWFwKChzKSA9PiB0aGlzLnBhcnNlQWNjb3VudElkKHMpLmFkZHJlc3MpO1xuICAgIGNvbnN0IHsgYWRkcmVzczogaSB9ID0gdGhpcy5wYXJzZUFjY291bnRJZCh0WzBdKSwgbiA9IGkuc3RhcnRzV2l0aChcIjB4XCIpID8gaSA6IGAweCR7aX1gO1xuICAgIHRoaXMuYWNjb3VudCA9IG5ldyBQaChcbiAgICAgIHRoaXMucHJvdmlkZXIsXG4gICAgICBuLFxuICAgICAgdGhpcy5yZW1vdGVTaWduZXIsXG4gICAgICB0aGlzLndhbGxldFJwY1xuICAgICksIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXCJhY2NvdW50c0NoYW5nZWRcIiwgdGhpcy5hY2NvdW50cyksIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gbjtcbiAgfVxufVxuY29uc3QgbzQgPSBhc3luYyAocikgPT4gTTUociwgQzUpO1xuZXhwb3J0IHtcbiAgbzQgYXMgZ2V0U3RhcmtuZXRXaW5kb3dPYmplY3Rcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-1c1d2b10.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-8edbd361.js":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-8edbd361.js ***!
  \***************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ Ln),\n/* harmony export */   D: () => (/* binding */ Tr),\n/* harmony export */   W: () => (/* binding */ bo),\n/* harmony export */   a: () => (/* binding */ En),\n/* harmony export */   b: () => (/* binding */ $n),\n/* harmony export */   h: () => (/* binding */ wo)\n/* harmony export */ });\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! starknet */ \"(ssr)/./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lastConnected-e9351912.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/lastConnected-e9351912.js\");\n/* harmony import */ var _getStarknetChainId_7c4b3163_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getStarknetChainId-7c4b3163.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/getStarknetChainId-7c4b3163.js\");\nvar On = Object.defineProperty;\nvar Sn = (t, e, r) => e in t ? On(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;\nvar Te = (t, e, r) => (Sn(t, typeof e != \"symbol\" ? e + \"\" : e, r), r);\n\n\n\nconst Tr = \"https://web.argent.xyz\", rr = `<svg\n    width=\"32\"\n    height=\"28\"\n    viewBox=\"0 0 18 14\"\n    fill=\"none\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      fill-rule=\"evenodd\"\n      clip-rule=\"evenodd\"\n      d=\"M1.5 0.4375C0.982233 0.4375 0.5625 0.857233 0.5625 1.375V12C0.5625 12.4144 0.72712 12.8118 1.02015 13.1049C1.31317 13.3979 1.7106 13.5625 2.125 13.5625H15.875C16.2894 13.5625 16.6868 13.3979 16.9799 13.1049C17.2729 12.8118 17.4375 12.4144 17.4375 12V1.375C17.4375 0.857233 17.0178 0.4375 16.5 0.4375H1.5ZM2.4375 3.50616V11.6875H15.5625V3.50616L9.63349 8.94108C9.27507 9.26964 8.72493 9.26964 8.36651 8.94108L2.4375 3.50616ZM14.0899 2.3125H3.91013L9 6.97822L14.0899 2.3125Z\"\n      fill=\"currentColor\"\n    />\n  </svg>`, In = \"https://static.hydrogen.argent47.net/webwallet/iframe_whitelist_testnet.json\", jn = \"https://static.argent.net/webwallet/iframe_whitelist_mainnet.json\";\nclass Ln extends Error {\n  constructor(r, n) {\n    super(r);\n    Te(this, \"code\");\n    this.name = \"ConnectAndSignSessionError\", this.code = n;\n  }\n}\nclass $n extends Error {\n  constructor(r, n) {\n    super(r);\n    Te(this, \"code\");\n    this.name = \"WebwalletError\", this.code = n;\n  }\n}\nconst Q = starknet__WEBPACK_IMPORTED_MODULE_0__.constants.NetworkName, Mn = Q.SN_SEPOLIA;\nfunction Dn(t) {\n  try {\n    const { origin: e } = new URL(t);\n    if (e.includes(\"localhost\") || e.includes(\"127.0.0.1\"))\n      return Mn;\n    if (e.includes(\"hydrogen\") || e.includes(\"sepolia-web.staging\"))\n      return Q.SN_SEPOLIA;\n    if (e.includes(\"staging\"))\n      return Q.SN_MAIN;\n    if (e.includes(\"dev\") || e.includes(\"sepolia-web.argent.xyz\"))\n      return Q.SN_SEPOLIA;\n    if (e.includes(\"argent.xyz\"))\n      return Q.SN_MAIN;\n  } catch {\n    console.warn(\n      \"Could not determine network from target URL, defaulting to mainnet-alpha\"\n    );\n  }\n  return Q.SN_MAIN;\n}\nconst Zn = 385, Un = 775, Wn = 385, qn = 440, zn = 420, Bn = 438;\nfunction Vn(t) {\n  return t;\n}\nfunction Fn(t) {\n  return t.length === 0 ? Vn : t.length === 1 ? t[0] : function(r) {\n    return t.reduce((n, s) => s(n), r);\n  };\n}\nfunction Hn(t) {\n  return typeof t == \"object\" && t !== null && \"subscribe\" in t;\n}\nfunction nt(t) {\n  const e = {\n    subscribe(r) {\n      let n = null, s = !1, a = !1, i = !1;\n      function o() {\n        if (n === null) {\n          i = !0;\n          return;\n        }\n        a || (a = !0, typeof n == \"function\" ? n() : n && n.unsubscribe());\n      }\n      return n = t({\n        next(c) {\n          s || r.next?.(c);\n        },\n        error(c) {\n          s || (s = !0, r.error?.(c), o());\n        },\n        complete() {\n          s || (s = !0, r.complete?.(), o());\n        }\n      }), i && o(), {\n        unsubscribe: o\n      };\n    },\n    pipe(...r) {\n      return Fn(r)(e);\n    }\n  };\n  return e;\n}\nfunction Er(t) {\n  return (e) => {\n    let r = 0, n = null;\n    const s = [];\n    function a() {\n      n || (n = e.subscribe({\n        next(o) {\n          for (const c of s)\n            c.next?.(o);\n        },\n        error(o) {\n          for (const c of s)\n            c.error?.(o);\n        },\n        complete() {\n          for (const o of s)\n            o.complete?.();\n        }\n      }));\n    }\n    function i() {\n      if (r === 0 && n) {\n        const o = n;\n        n = null, o.unsubscribe();\n      }\n    }\n    return {\n      subscribe(o) {\n        return r++, s.push(o), a(), {\n          unsubscribe() {\n            r--, i();\n            const c = s.findIndex((u) => u === o);\n            c > -1 && s.splice(c, 1);\n          }\n        };\n      }\n    };\n  };\n}\nfunction Gn(t) {\n  return (e) => ({\n    subscribe(r) {\n      let n = 0;\n      return e.subscribe({\n        next(a) {\n          r.next?.(t(a, n++));\n        },\n        error(a) {\n          r.error?.(a);\n        },\n        complete() {\n          r.complete?.();\n        }\n      });\n    }\n  });\n}\nfunction Cr(t) {\n  return (e) => ({\n    subscribe(r) {\n      return e.subscribe({\n        next(n) {\n          t.next?.(n), r.next?.(n);\n        },\n        error(n) {\n          t.error?.(n), r.error?.(n);\n        },\n        complete() {\n          t.complete?.(), r.complete?.();\n        }\n      });\n    }\n  });\n}\nlet Jn = class Rr extends Error {\n  constructor(e) {\n    super(e), this.name = \"ObservableAbortError\", Object.setPrototypeOf(this, Rr.prototype);\n  }\n};\nfunction Or(t) {\n  let e;\n  return {\n    promise: new Promise((n, s) => {\n      let a = !1;\n      function i() {\n        a || (a = !0, s(new Jn(\"This operation was aborted.\")), o.unsubscribe());\n      }\n      const o = t.subscribe({\n        next(c) {\n          a = !0, n(c), i();\n        },\n        error(c) {\n          a = !0, s(c), i();\n        },\n        complete() {\n          a = !0, i();\n        }\n      });\n      e = i;\n    }),\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    abort: e\n  };\n}\nconst Yn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  isObservable: Hn,\n  map: Gn,\n  observable: nt,\n  observableToPromise: Or,\n  share: Er,\n  tap: Cr\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction Sr(t) {\n  return nt((e) => {\n    function r(s = 0, a = t.op) {\n      const i = t.links[s];\n      if (!i)\n        throw new Error(\"No more links to execute - did you forget to add an ending link?\");\n      return i({\n        op: a,\n        next(c) {\n          return r(s + 1, c);\n        }\n      });\n    }\n    return r().subscribe(e);\n  });\n}\nfunction nr(t) {\n  return Array.isArray(t) ? t : [\n    t\n  ];\n}\nfunction Xn(t) {\n  return (e) => {\n    const r = nr(t.true).map((s) => s(e)), n = nr(t.false).map((s) => s(e));\n    return (s) => nt((a) => {\n      const i = t.condition(s.op) ? r : n;\n      return Sr({\n        op: s.op,\n        links: i\n      }).subscribe(a);\n    });\n  };\n}\nfunction Pr(t) {\n  const e = /* @__PURE__ */ Object.create(null);\n  for (const r in t) {\n    const n = t[r];\n    e[n] = r;\n  }\n  return e;\n}\nconst st = {\n  /**\n  * Invalid JSON was received by the server.\n  * An error occurred on the server while parsing the JSON text.\n  */\n  PARSE_ERROR: -32700,\n  /**\n  * The JSON sent is not a valid Request object.\n  */\n  BAD_REQUEST: -32600,\n  // Internal JSON-RPC error\n  INTERNAL_SERVER_ERROR: -32603,\n  NOT_IMPLEMENTED: -32603,\n  // Implementation specific errors\n  UNAUTHORIZED: -32001,\n  FORBIDDEN: -32003,\n  NOT_FOUND: -32004,\n  METHOD_NOT_SUPPORTED: -32005,\n  TIMEOUT: -32008,\n  CONFLICT: -32009,\n  PRECONDITION_FAILED: -32012,\n  PAYLOAD_TOO_LARGE: -32013,\n  UNPROCESSABLE_CONTENT: -32022,\n  TOO_MANY_REQUESTS: -32029,\n  CLIENT_CLOSED_REQUEST: -32099\n};\nPr(st);\nPr(st);\nconst Qn = {\n  PARSE_ERROR: 400,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  METHOD_NOT_SUPPORTED: 405,\n  TIMEOUT: 408,\n  CONFLICT: 409,\n  PRECONDITION_FAILED: 412,\n  PAYLOAD_TOO_LARGE: 413,\n  UNPROCESSABLE_CONTENT: 422,\n  TOO_MANY_REQUESTS: 429,\n  CLIENT_CLOSED_REQUEST: 499,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501\n};\nfunction Kn(t) {\n  return Qn[t] ?? 500;\n}\nfunction Ar(t) {\n  return Kn(t.code);\n}\nconst Nr = () => {\n};\nfunction Ir(t, e) {\n  return new Proxy(Nr, {\n    get(n, s) {\n      if (!(typeof s != \"string\" || s === \"then\"))\n        return Ir(t, [\n          ...e,\n          s\n        ]);\n    },\n    apply(n, s, a) {\n      const i = e[e.length - 1] === \"apply\";\n      return t({\n        args: i ? a.length >= 2 ? a[1] : [] : a,\n        path: i ? e.slice(0, -1) : e\n      });\n    }\n  });\n}\nconst Zt = (t) => Ir(t, []), Ut = (t) => new Proxy(Nr, {\n  get(e, r) {\n    if (!(typeof r != \"string\" || r === \"then\"))\n      return t(r);\n  }\n});\nfunction es(t) {\n  const { path: e, error: r, config: n } = t, { code: s } = t.error, a = {\n    message: r.message,\n    code: st[s],\n    data: {\n      code: s,\n      httpStatus: Ar(r)\n    }\n  };\n  return n.isDev && typeof t.error.stack == \"string\" && (a.data.stack = t.error.stack), typeof e == \"string\" && (a.data.path = e), n.errorFormatter({\n    ...t,\n    shape: a\n  });\n}\nfunction sr(t, e) {\n  return \"error\" in e ? {\n    ...e,\n    error: t.transformer.output.serialize(e.error)\n  } : \"data\" in e.result ? {\n    ...e,\n    result: {\n      ...e.result,\n      data: t.transformer.output.serialize(e.result.data)\n    }\n  } : e;\n}\nfunction ts(t, e) {\n  return Array.isArray(e) ? e.map((r) => sr(t, r)) : sr(t, e);\n}\nfunction rs(t) {\n  return !!t && !Array.isArray(t) && typeof t == \"object\";\n}\nclass ns extends Error {\n}\nfunction Wt(t) {\n  if (t instanceof Error)\n    return t;\n  const e = typeof t;\n  if (!(e === \"undefined\" || e === \"function\" || t === null)) {\n    if (e !== \"object\")\n      return new Error(String(t));\n    if (rs(t)) {\n      const r = new ns();\n      for (const n in t)\n        r[n] = t[n];\n      return r;\n    }\n  }\n}\nconst ss = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  createFlatProxy: Ut,\n  createRecursiveProxy: Zt,\n  getCauseFromUnknown: Wt,\n  getErrorShape: es,\n  transformTRPCResponse: ts\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction ar(t) {\n  return !!t && !Array.isArray(t) && typeof t == \"object\";\n}\nfunction as(t) {\n  return t instanceof jr || /**\n  * @deprecated\n  * Delete in next major\n  */\n  t instanceof Error && t.name === \"TRPCClientError\";\n}\nfunction is(t) {\n  return ar(t) && ar(t.error) && typeof t.error.code == \"number\" && typeof t.error.message == \"string\";\n}\nlet jr = class Ee extends Error {\n  static from(e, r = {}) {\n    const n = e;\n    return as(n) ? (r.meta && (n.meta = {\n      ...n.meta,\n      ...r.meta\n    }), n) : is(n) ? new Ee(n.error.message, {\n      ...r,\n      result: n\n    }) : n instanceof Error ? new Ee(n.message, {\n      ...r,\n      cause: Wt(n)\n    }) : new Ee(\"Unknown error\", {\n      ...r,\n      cause: n\n    });\n  }\n  constructor(e, r) {\n    const n = r?.cause;\n    super(e, {\n      cause: n\n    }), this.meta = r?.meta, this.cause = n, this.shape = r?.result?.error, this.data = r?.result?.error.data, this.name = \"TRPCClientError\", Object.setPrototypeOf(this, Ee.prototype);\n  }\n};\nfunction os(t) {\n  return typeof FormData > \"u\" ? !1 : t instanceof FormData;\n}\nconst mt = {\n  css: {\n    query: [\n      \"72e3ff\",\n      \"3fb0d8\"\n    ],\n    mutation: [\n      \"c5a3fc\",\n      \"904dfc\"\n    ],\n    subscription: [\n      \"ff49e1\",\n      \"d83fbe\"\n    ]\n  },\n  ansi: {\n    regular: {\n      // Cyan background, black and white text respectively\n      query: [\n        \"\\x1B[30;46m\",\n        \"\\x1B[97;46m\"\n      ],\n      // Magenta background, black and white text respectively\n      mutation: [\n        \"\\x1B[30;45m\",\n        \"\\x1B[97;45m\"\n      ],\n      // Green background, black and white text respectively\n      subscription: [\n        \"\\x1B[30;42m\",\n        \"\\x1B[97;42m\"\n      ]\n    },\n    bold: {\n      query: [\n        \"\\x1B[1;30;46m\",\n        \"\\x1B[1;97;46m\"\n      ],\n      mutation: [\n        \"\\x1B[1;30;45m\",\n        \"\\x1B[1;97;45m\"\n      ],\n      subscription: [\n        \"\\x1B[1;30;42m\",\n        \"\\x1B[1;97;42m\"\n      ]\n    }\n  }\n};\nfunction cs(t) {\n  const { direction: e, type: r, path: n, id: s, input: a } = t, i = [], o = [];\n  if (t.colorMode === \"ansi\") {\n    const [h, y] = mt.ansi.regular[r], [k, T] = mt.ansi.bold[r], A = \"\\x1B[0m\";\n    return i.push(e === \"up\" ? h : y, e === \"up\" ? \">>\" : \"<<\", r, e === \"up\" ? k : T, `#${s}`, n, A), e === \"up\" ? o.push({\n      input: t.input\n    }) : o.push({\n      input: t.input,\n      // strip context from result cause it's too noisy in terminal wihtout collapse mode\n      result: \"result\" in t.result ? t.result.result : t.result,\n      elapsedMs: t.elapsedMs\n    }), {\n      parts: i,\n      args: o\n    };\n  }\n  const [c, u] = mt.css[r], d = `\n    background-color: #${e === \"up\" ? c : u}; \n    color: ${e === \"up\" ? \"black\" : \"white\"};\n    padding: 2px;\n  `;\n  return i.push(\"%c\", e === \"up\" ? \">>\" : \"<<\", r, `#${s}`, `%c${n}%c`, \"%O\"), o.push(d, `${d}; font-weight: bold;`, `${d}; font-weight: normal;`), e === \"up\" ? o.push({\n    input: a,\n    context: t.context\n  }) : o.push({\n    input: a,\n    result: t.result,\n    elapsedMs: t.elapsedMs,\n    context: t.context\n  }), {\n    parts: i,\n    args: o\n  };\n}\nconst us = ({ c: t = console, colorMode: e = \"css\" }) => (r) => {\n  const n = r.input, s = os(n) ? Object.fromEntries(n) : n, { parts: a, args: i } = cs({\n    ...r,\n    colorMode: e,\n    input: s\n  }), o = r.direction === \"down\" && r.result && (r.result instanceof Error || \"error\" in r.result.result) ? \"error\" : \"log\";\n  t[o].apply(null, [\n    a.join(\" \")\n  ].concat(i));\n};\nfunction ls(t = {}) {\n  const { enabled: e = () => !0 } = t, r = t.colorMode ?? (typeof window > \"u\" ? \"ansi\" : \"css\"), { logger: n = us({\n    c: t.console,\n    colorMode: r\n  }) } = t;\n  return () => ({ op: s, next: a }) => nt((i) => {\n    e({\n      ...s,\n      direction: \"up\"\n    }) && n({\n      ...s,\n      direction: \"up\"\n    });\n    const o = Date.now();\n    function c(u) {\n      const d = Date.now() - o;\n      e({\n        ...s,\n        direction: \"down\",\n        result: u\n      }) && n({\n        ...s,\n        direction: \"down\",\n        elapsedMs: d,\n        result: u\n      });\n    }\n    return a(s).pipe(Cr({\n      next(u) {\n        c(u);\n      },\n      error(u) {\n        c(u);\n      }\n    })).subscribe(i);\n  });\n}\nlet ds = class {\n  $request({ type: e, input: r, path: n, context: s = {} }) {\n    return Sr({\n      links: this.links,\n      op: {\n        id: ++this.requestId,\n        type: e,\n        path: n,\n        input: r,\n        context: s\n      }\n    }).pipe(Er());\n  }\n  requestAsPromise(e) {\n    const r = this.$request(e), { promise: n, abort: s } = Or(r);\n    return new Promise((i, o) => {\n      e.signal?.addEventListener(\"abort\", s), n.then((c) => {\n        i(c.result.data);\n      }).catch((c) => {\n        o(jr.from(c));\n      });\n    });\n  }\n  query(e, r, n) {\n    return this.requestAsPromise({\n      type: \"query\",\n      path: e,\n      input: r,\n      context: n?.context,\n      signal: n?.signal\n    });\n  }\n  mutation(e, r, n) {\n    return this.requestAsPromise({\n      type: \"mutation\",\n      path: e,\n      input: r,\n      context: n?.context,\n      signal: n?.signal\n    });\n  }\n  subscription(e, r, n) {\n    return this.$request({\n      type: \"subscription\",\n      path: e,\n      input: r,\n      context: n?.context\n    }).subscribe({\n      next(a) {\n        a.result.type === \"started\" ? n.onStarted?.() : a.result.type === \"stopped\" ? n.onStopped?.() : n.onData?.(a.result.data);\n      },\n      error(a) {\n        n.onError?.(a);\n      },\n      complete() {\n        n.onComplete?.();\n      }\n    });\n  }\n  constructor(e) {\n    this.requestId = 0;\n    const r = (() => {\n      const n = e.transformer;\n      return n ? \"input\" in n ? e.transformer : {\n        input: n,\n        output: n\n      } : {\n        input: {\n          serialize: (s) => s,\n          deserialize: (s) => s\n        },\n        output: {\n          serialize: (s) => s,\n          deserialize: (s) => s\n        }\n      };\n    })();\n    this.runtime = {\n      transformer: {\n        serialize: (n) => r.input.serialize(n),\n        deserialize: (n) => r.output.deserialize(n)\n      },\n      combinedTransformer: r\n    }, this.links = e.links.map((n) => n(this.runtime));\n  }\n};\nconst fs = {\n  query: \"query\",\n  mutate: \"mutation\",\n  subscribe: \"subscription\"\n}, ps = (t) => fs[t];\nfunction hs(t) {\n  return Ut((e) => t.hasOwnProperty(e) ? t[e] : e === \"__untypedClient\" ? t : Zt(({ path: r, args: n }) => {\n    const s = [\n      e,\n      ...r\n    ], a = ps(s.pop()), i = s.join(\".\");\n    return t[a](i, ...n);\n  }));\n}\nfunction ms(t) {\n  const e = new ds(t);\n  return hs(e);\n}\nfunction ys(t) {\n  if (t instanceof ye || t instanceof Error && t.name === \"TRPCError\")\n    return t;\n  const e = new ye({\n    code: \"INTERNAL_SERVER_ERROR\",\n    cause: t\n  });\n  return t instanceof Error && t.stack && (e.stack = t.stack), e;\n}\nclass ye extends Error {\n  constructor(e) {\n    const r = Wt(e.cause), n = e.message ?? r?.message ?? e.code;\n    super(n, {\n      cause: r\n    }), this.code = e.code, this.name = \"TRPCError\", this.cause || (this.cause = r);\n  }\n}\nfunction gs(t) {\n  return \"input\" in t ? t : {\n    input: t,\n    output: t\n  };\n}\nconst Se = {\n  _default: !0,\n  input: {\n    serialize: (t) => t,\n    deserialize: (t) => t\n  },\n  output: {\n    serialize: (t) => t,\n    deserialize: (t) => t\n  }\n}, Pe = ({ shape: t }) => t;\nfunction _s(t) {\n  return Object.assign(/* @__PURE__ */ Object.create(null), t);\n}\nconst vs = [\n  \"query\",\n  \"mutation\",\n  \"subscription\"\n];\nfunction bs(t) {\n  return \"router\" in t._def;\n}\nconst ws = {\n  _ctx: null,\n  _errorShape: null,\n  _meta: null,\n  queries: {},\n  mutations: {},\n  subscriptions: {},\n  errorFormatter: Pe,\n  transformer: Se\n}, xs = [\n  /**\n  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy\n  * since JS will think that `.then` is something that exists\n  */\n  \"then\"\n];\nfunction Lr(t) {\n  return function(r) {\n    const n = new Set(Object.keys(r).filter((c) => xs.includes(c)));\n    if (n.size > 0)\n      throw new Error(\"Reserved words used in `router({})` call: \" + Array.from(n).join(\", \"));\n    const s = _s({});\n    function a(c, u = \"\") {\n      for (const [d, h] of Object.entries(c ?? {})) {\n        const y = `${u}${d}`;\n        if (bs(h)) {\n          a(h._def.procedures, `${y}.`);\n          continue;\n        }\n        if (s[y])\n          throw new Error(`Duplicate key: ${y}`);\n        s[y] = h;\n      }\n    }\n    a(r);\n    const i = {\n      _config: t,\n      router: !0,\n      procedures: s,\n      ...ws,\n      record: r,\n      queries: Object.entries(s).filter((c) => c[1]._def.query).reduce((c, [u, d]) => ({\n        ...c,\n        [u]: d\n      }), {}),\n      mutations: Object.entries(s).filter((c) => c[1]._def.mutation).reduce((c, [u, d]) => ({\n        ...c,\n        [u]: d\n      }), {}),\n      subscriptions: Object.entries(s).filter((c) => c[1]._def.subscription).reduce((c, [u, d]) => ({\n        ...c,\n        [u]: d\n      }), {})\n    }, o = {\n      ...r,\n      _def: i,\n      createCaller(c) {\n        return $r()(o)(c);\n      },\n      getErrorShape(c) {\n        const { path: u, error: d } = c, { code: h } = c.error, y = {\n          message: d.message,\n          code: st[h],\n          data: {\n            code: h,\n            httpStatus: Ar(d)\n          }\n        };\n        return t.isDev && typeof c.error.stack == \"string\" && (y.data.stack = c.error.stack), typeof u == \"string\" && (y.data.path = u), this._def._config.errorFormatter({\n          ...c,\n          shape: y\n        });\n      }\n    };\n    return o;\n  };\n}\nfunction ks(t) {\n  const { type: e, path: r } = t;\n  if (!(r in t.procedures) || !t.procedures[r]?._def[e])\n    throw new ye({\n      code: \"NOT_FOUND\",\n      message: `No \"${e}\"-procedure on path \"${r}\"`\n    });\n  const n = t.procedures[r];\n  return n(t);\n}\nfunction $r() {\n  return function(e) {\n    const r = e._def;\n    return function(s) {\n      return Zt(({ path: i, args: o }) => {\n        if (i.length === 1 && vs.includes(i[0]))\n          return ks({\n            procedures: r.procedures,\n            path: o[0],\n            rawInput: o[1],\n            ctx: s,\n            type: i[0]\n          });\n        const c = i.join(\".\"), u = r.procedures[c];\n        let d = \"query\";\n        return u._def.mutation ? d = \"mutation\" : u._def.subscription && (d = \"subscription\"), u({\n          path: c,\n          rawInput: o[0],\n          ctx: s,\n          type: d\n        });\n      });\n    };\n  };\n}\nconst ir = typeof window > \"u\" || \"Deno\" in window || globalThis.process?.env?.NODE_ENV === \"test\" || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;\nfunction or(t) {\n  const e = t;\n  if (typeof e == \"function\")\n    return e;\n  if (typeof e.parseAsync == \"function\")\n    return e.parseAsync.bind(e);\n  if (typeof e.parse == \"function\")\n    return e.parse.bind(e);\n  if (typeof e.validateSync == \"function\")\n    return e.validateSync.bind(e);\n  if (typeof e.create == \"function\")\n    return e.create.bind(e);\n  if (typeof e.assert == \"function\")\n    return (r) => (e.assert(r), r);\n  throw new Error(\"Could not find a validator fn\");\n}\nfunction Mr(t, ...e) {\n  const r = Object.assign(/* @__PURE__ */ Object.create(null), t);\n  for (const n of e)\n    for (const s in n) {\n      if (s in r && r[s] !== n[s])\n        throw new Error(`Duplicate key ${s}`);\n      r[s] = n[s];\n    }\n  return r;\n}\nfunction Ts() {\n  function t(r) {\n    return {\n      _middlewares: r,\n      unstable_pipe(n) {\n        const s = \"_middlewares\" in n ? n._middlewares : [\n          n\n        ];\n        return t([\n          ...r,\n          ...s\n        ]);\n      }\n    };\n  }\n  function e(r) {\n    return t([\n      r\n    ]);\n  }\n  return e;\n}\nfunction cr(t) {\n  return t && typeof t == \"object\" && !Array.isArray(t);\n}\nfunction Es(t) {\n  const e = async ({ next: r, rawInput: n, input: s }) => {\n    let a;\n    try {\n      a = await t(n);\n    } catch (o) {\n      throw new ye({\n        code: \"BAD_REQUEST\",\n        cause: o\n      });\n    }\n    const i = cr(s) && cr(a) ? {\n      ...s,\n      ...a\n    } : a;\n    return r({\n      input: i\n    });\n  };\n  return e._type = \"input\", e;\n}\nfunction Cs(t) {\n  const e = async ({ next: r }) => {\n    const n = await r();\n    if (!n.ok)\n      return n;\n    try {\n      const s = await t(n.data);\n      return {\n        ...n,\n        data: s\n      };\n    } catch (s) {\n      throw new ye({\n        message: \"Output validation failed\",\n        code: \"INTERNAL_SERVER_ERROR\",\n        cause: s\n      });\n    }\n  };\n  return e._type = \"output\", e;\n}\nconst Dr = \"middlewareMarker\";\nfunction fe(t, e) {\n  const { middlewares: r = [], inputs: n, meta: s, ...a } = e;\n  return Zr({\n    ...Mr(t, a),\n    inputs: [\n      ...t.inputs,\n      ...n ?? []\n    ],\n    middlewares: [\n      ...t.middlewares,\n      ...r\n    ],\n    meta: t.meta && s ? {\n      ...t.meta,\n      ...s\n    } : s ?? t.meta\n  });\n}\nfunction Zr(t = {}) {\n  const e = {\n    inputs: [],\n    middlewares: [],\n    ...t\n  };\n  return {\n    _def: e,\n    input(r) {\n      const n = or(r);\n      return fe(e, {\n        inputs: [\n          r\n        ],\n        middlewares: [\n          Es(n)\n        ]\n      });\n    },\n    output(r) {\n      const n = or(r);\n      return fe(e, {\n        output: r,\n        middlewares: [\n          Cs(n)\n        ]\n      });\n    },\n    meta(r) {\n      return fe(e, {\n        meta: r\n      });\n    },\n    /**\n    * @deprecated\n    * This functionality is deprecated and will be removed in the next major version.\n    */\n    unstable_concat(r) {\n      return fe(e, r._def);\n    },\n    use(r) {\n      const n = \"_middlewares\" in r ? r._middlewares : [\n        r\n      ];\n      return fe(e, {\n        middlewares: n\n      });\n    },\n    query(r) {\n      return yt({\n        ...e,\n        query: !0\n      }, r);\n    },\n    mutation(r) {\n      return yt({\n        ...e,\n        mutation: !0\n      }, r);\n    },\n    subscription(r) {\n      return yt({\n        ...e,\n        subscription: !0\n      }, r);\n    }\n  };\n}\nfunction yt(t, e) {\n  const r = fe(t, {\n    resolver: e,\n    middlewares: [\n      async function(s) {\n        const a = await e(s);\n        return {\n          marker: Dr,\n          ok: !0,\n          data: a,\n          ctx: s.ctx\n        };\n      }\n    ]\n  });\n  return Os(r._def);\n}\nconst Rs = `\nThis is a client-only function.\nIf you want to call this function on the server, see https://trpc.io/docs/server/server-side-calls\n`.trim();\nfunction Os(t) {\n  const e = async function(n) {\n    if (!n || !(\"rawInput\" in n))\n      throw new Error(Rs);\n    const s = async (i = {\n      index: 0,\n      ctx: n.ctx\n    }) => {\n      try {\n        const o = t.middlewares[i.index];\n        return await o({\n          ctx: i.ctx,\n          type: n.type,\n          path: n.path,\n          rawInput: i.rawInput ?? n.rawInput,\n          meta: t.meta,\n          input: i.input,\n          next(u) {\n            const d = u;\n            return s({\n              index: i.index + 1,\n              ctx: d && \"ctx\" in d ? {\n                ...i.ctx,\n                ...d.ctx\n              } : i.ctx,\n              input: d && \"input\" in d ? d.input : i.input,\n              rawInput: d && \"rawInput\" in d ? d.rawInput : i.rawInput\n            });\n          }\n        });\n      } catch (o) {\n        return {\n          ok: !1,\n          error: ys(o),\n          marker: Dr\n        };\n      }\n    }, a = await s();\n    if (!a)\n      throw new ye({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"No result from middlewares - did you forget to `return next()`?\"\n      });\n    if (!a.ok)\n      throw a.error;\n    return a.data;\n  };\n  return e._def = t, e.meta = t.meta, e;\n}\nfunction Ss(...t) {\n  const e = Mr({}, ...t.map((a) => a._def.record)), r = t.reduce((a, i) => {\n    if (i._def._config.errorFormatter && i._def._config.errorFormatter !== Pe) {\n      if (a !== Pe && a !== i._def._config.errorFormatter)\n        throw new Error(\"You seem to have several error formatters\");\n      return i._def._config.errorFormatter;\n    }\n    return a;\n  }, Pe), n = t.reduce((a, i) => {\n    if (i._def._config.transformer && i._def._config.transformer !== Se) {\n      if (a !== Se && a !== i._def._config.transformer)\n        throw new Error(\"You seem to have several transformers\");\n      return i._def._config.transformer;\n    }\n    return a;\n  }, Se);\n  return Lr({\n    errorFormatter: r,\n    transformer: n,\n    isDev: t.some((a) => a._def._config.isDev),\n    allowOutsideOfServer: t.some((a) => a._def._config.allowOutsideOfServer),\n    isServer: t.some((a) => a._def._config.isServer),\n    $types: t[0]?._def._config.$types\n  })(e);\n}\nclass Je {\n  context() {\n    return new Je();\n  }\n  meta() {\n    return new Je();\n  }\n  create(e) {\n    return As()(e);\n  }\n}\nconst Ps = new Je();\nfunction As() {\n  return function(e) {\n    const r = e?.errorFormatter ?? Pe, s = {\n      transformer: gs(e?.transformer ?? Se),\n      isDev: e?.isDev ?? globalThis.process?.env?.NODE_ENV !== \"production\",\n      allowOutsideOfServer: e?.allowOutsideOfServer ?? !1,\n      errorFormatter: r,\n      isServer: e?.isServer ?? ir,\n      /**\n      * @internal\n      */\n      $types: Ut((a) => {\n        throw new Error(`Tried to access \"$types.${a}\" which is not available at runtime`);\n      })\n    };\n    if (!(e?.isServer ?? ir) && e?.allowOutsideOfServer !== !0)\n      throw new Error(\"You're trying to use @trpc/server in a non-server environment. This is not supported by default.\");\n    return {\n      /**\n      * These are just types, they can't be used\n      * @internal\n      */\n      _config: s,\n      /**\n      * Builder object for creating procedures\n      * @see https://trpc.io/docs/server/procedures\n      */\n      procedure: Zr({\n        meta: e?.defaultMeta\n      }),\n      /**\n      * Create reusable middlewares\n      * @see https://trpc.io/docs/server/middlewares\n      */\n      middleware: Ts(),\n      /**\n      * Create a router\n      * @see https://trpc.io/docs/server/routers\n      */\n      router: Lr(s),\n      /**\n      * Merge Routers\n      * @see https://trpc.io/docs/server/merging-routers\n      */\n      mergeRouters: Ss,\n      /**\n      * Create a server-side caller for a router\n      * @see https://trpc.io/docs/server/server-side-calls\n      */\n      createCallerFactory: $r()\n    };\n  };\n}\nvar Rt = {}, at = {}, be = {}, S = {};\nconst we = /* @__PURE__ */ (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.g)(Yn);\nvar qt = {}, Ur = we;\nfunction Wr(t) {\n  return Ur.observable((e) => {\n    function r(s = 0, a = t.op) {\n      const i = t.links[s];\n      if (!i)\n        throw new Error(\"No more links to execute - did you forget to add an ending link?\");\n      return i({\n        op: a,\n        next(c) {\n          return r(s + 1, c);\n        }\n      });\n    }\n    return r().subscribe(e);\n  });\n}\nfunction ur(t) {\n  return Array.isArray(t) ? t : [\n    t\n  ];\n}\nfunction Ns(t) {\n  return (e) => {\n    const r = ur(t.true).map((s) => s(e)), n = ur(t.false).map((s) => s(e));\n    return (s) => Ur.observable((a) => {\n      const i = t.condition(s.op) ? r : n;\n      return Wr({\n        op: s.op,\n        links: i\n      }).subscribe(a);\n    });\n  };\n}\nqt.createChain = Wr;\nqt.splitLink = Ns;\nvar xe = {};\nconst qr = /* @__PURE__ */ (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.g)(ss);\nvar ke = {};\nfunction Ot(t) {\n  return !!t && !Array.isArray(t) && typeof t == \"object\";\n}\nfunction Is(t, e) {\n  if (\"error\" in t) {\n    const n = e.transformer.deserialize(t.error);\n    return {\n      ok: !1,\n      error: {\n        ...t,\n        error: n\n      }\n    };\n  }\n  return {\n    ok: !0,\n    result: {\n      ...t.result,\n      ...(!t.result.type || t.result.type === \"data\") && {\n        type: \"data\",\n        data: e.transformer.deserialize(t.result.data)\n      }\n    }\n  };\n}\nclass gt extends Error {\n  constructor() {\n    super(\"Unable to transform response from server\");\n  }\n}\nfunction js(t, e) {\n  let r;\n  try {\n    r = Is(t, e);\n  } catch {\n    throw new gt();\n  }\n  if (!r.ok && (!Ot(r.error.error) || typeof r.error.error.code != \"number\"))\n    throw new gt();\n  if (r.ok && !Ot(r.result))\n    throw new gt();\n  return r;\n}\nke.isObject = Ot;\nke.transformResult = js;\nvar Ls = qr, lr = ke;\nfunction $s(t) {\n  return t instanceof zr || /**\n  * @deprecated\n  * Delete in next major\n  */\n  t instanceof Error && t.name === \"TRPCClientError\";\n}\nfunction Ms(t) {\n  return lr.isObject(t) && lr.isObject(t.error) && typeof t.error.code == \"number\" && typeof t.error.message == \"string\";\n}\nlet zr = class Ce extends Error {\n  static from(e, r = {}) {\n    const n = e;\n    return $s(n) ? (r.meta && (n.meta = {\n      ...n.meta,\n      ...r.meta\n    }), n) : Ms(n) ? new Ce(n.error.message, {\n      ...r,\n      result: n\n    }) : n instanceof Error ? new Ce(n.message, {\n      ...r,\n      cause: Ls.getCauseFromUnknown(n)\n    }) : new Ce(\"Unknown error\", {\n      ...r,\n      cause: n\n    });\n  }\n  constructor(e, r) {\n    const n = r?.cause;\n    super(e, {\n      cause: n\n    }), this.meta = r?.meta, this.cause = n, this.shape = r?.result?.error, this.data = r?.result?.error.data, this.name = \"TRPCClientError\", Object.setPrototypeOf(this, Ce.prototype);\n  }\n};\nxe.TRPCClientError = zr;\nvar F = {}, Ds = xe;\nconst dr = (t) => typeof t == \"function\";\nfunction Br(t) {\n  if (t)\n    return t;\n  if (typeof window < \"u\" && dr(window.fetch))\n    return window.fetch;\n  if (typeof globalThis < \"u\" && dr(globalThis.fetch))\n    return globalThis.fetch;\n  throw new Error(\"No fetch implementation found\");\n}\nfunction Zs(t) {\n  return t || (typeof window < \"u\" && window.AbortController ? window.AbortController : typeof globalThis < \"u\" && globalThis.AbortController ? globalThis.AbortController : null);\n}\nfunction Us(t) {\n  return {\n    url: t.url.toString().replace(/\\/$/, \"\"),\n    fetch: t.fetch,\n    AbortController: Zs(t.AbortController)\n  };\n}\nfunction Ws(t) {\n  const e = {};\n  for (let r = 0; r < t.length; r++) {\n    const n = t[r];\n    e[r] = n;\n  }\n  return e;\n}\nconst qs = {\n  query: \"GET\",\n  mutation: \"POST\"\n};\nfunction Vr(t) {\n  return \"input\" in t ? t.runtime.transformer.serialize(t.input) : Ws(t.inputs.map((e) => t.runtime.transformer.serialize(e)));\n}\nconst Fr = (t) => {\n  let e = t.url + \"/\" + t.path;\n  const r = [];\n  if (\"inputs\" in t && r.push(\"batch=1\"), t.type === \"query\") {\n    const n = Vr(t);\n    n !== void 0 && r.push(`input=${encodeURIComponent(JSON.stringify(n))}`);\n  }\n  return r.length && (e += \"?\" + r.join(\"&\")), e;\n}, Hr = (t) => {\n  if (t.type === \"query\")\n    return;\n  const e = Vr(t);\n  return e !== void 0 ? JSON.stringify(e) : void 0;\n}, zs = (t) => Jr({\n  ...t,\n  contentTypeHeader: \"application/json\",\n  getUrl: Fr,\n  getBody: Hr\n});\nasync function Gr(t, e) {\n  const r = t.getUrl(t), n = t.getBody(t), { type: s } = t, a = await t.headers();\n  /* istanbul ignore if -- @preserve */\n  if (s === \"subscription\")\n    throw new Error(\"Subscriptions should use wsLink\");\n  const i = {\n    ...t.contentTypeHeader ? {\n      \"content-type\": t.contentTypeHeader\n    } : {},\n    ...t.batchModeHeader ? {\n      \"trpc-batch-mode\": t.batchModeHeader\n    } : {},\n    ...a\n  };\n  return Br(t.fetch)(r, {\n    method: qs[s],\n    signal: e?.signal,\n    body: n,\n    headers: i\n  });\n}\nfunction Jr(t) {\n  const e = t.AbortController ? new t.AbortController() : null, r = {};\n  let n = !1;\n  return {\n    promise: new Promise((i, o) => {\n      Gr(t, e).then((c) => (r.response = c, n = !0, c.json())).then((c) => {\n        r.responseJSON = c, i({\n          json: c,\n          meta: r\n        });\n      }).catch((c) => {\n        n = !0, o(Ds.TRPCClientError.from(c, {\n          meta: r\n        }));\n      });\n    }),\n    cancel: () => {\n      n || e?.abort();\n    }\n  };\n}\nF.fetchHTTPResponse = Gr;\nF.getBody = Hr;\nF.getFetch = Br;\nF.getUrl = Fr;\nF.httpRequest = Jr;\nF.jsonHttpRequester = zs;\nF.resolveHTTPLinkOptions = Us;\nvar zt = {}, Bs = we, Vs = ke, fr = xe, St = F;\nconst _t = () => {\n  throw new Error(\"Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new\");\n};\nfunction vt(t) {\n  let e = null, r = null;\n  const n = () => {\n    clearTimeout(r), r = null, e = null;\n  };\n  function s(o) {\n    const c = [\n      []\n    ];\n    let u = 0;\n    for (; ; ) {\n      const d = o[u];\n      if (!d)\n        break;\n      const h = c[c.length - 1];\n      if (d.aborted) {\n        d.reject?.(new Error(\"Aborted\")), u++;\n        continue;\n      }\n      if (t.validate(h.concat(d).map((k) => k.key))) {\n        h.push(d), u++;\n        continue;\n      }\n      if (h.length === 0) {\n        d.reject?.(new Error(\"Input is too big for a single dispatch\")), u++;\n        continue;\n      }\n      c.push([]);\n    }\n    return c;\n  }\n  function a() {\n    const o = s(e);\n    n();\n    for (const c of o) {\n      if (!c.length)\n        continue;\n      const u = {\n        items: c,\n        cancel: _t\n      };\n      for (const k of c)\n        k.batch = u;\n      const d = (k, T) => {\n        const A = u.items[k];\n        A.resolve?.(T), A.batch = null, A.reject = null, A.resolve = null;\n      }, { promise: h, cancel: y } = t.fetch(u.items.map((k) => k.key), d);\n      u.cancel = y, h.then((k) => {\n        for (let T = 0; T < k.length; T++) {\n          const A = k[T];\n          d(T, A);\n        }\n        for (const T of u.items)\n          T.reject?.(new Error(\"Missing result\")), T.batch = null;\n      }).catch((k) => {\n        for (const T of u.items)\n          T.reject?.(k), T.batch = null;\n      });\n    }\n  }\n  function i(o) {\n    const c = {\n      aborted: !1,\n      key: o,\n      batch: null,\n      resolve: _t,\n      reject: _t\n    }, u = new Promise((h, y) => {\n      c.reject = y, c.resolve = h, e || (e = []), e.push(c);\n    });\n    return r || (r = setTimeout(a)), {\n      promise: u,\n      cancel: () => {\n        c.aborted = !0, c.batch?.items.every((h) => h.aborted) && (c.batch.cancel(), c.batch = null);\n      }\n    };\n  }\n  return {\n    load: i\n  };\n}\nfunction Yr(t) {\n  return function(r) {\n    const n = St.resolveHTTPLinkOptions(r), s = r.maxURLLength ?? 1 / 0;\n    return (a) => {\n      const i = (h) => {\n        const y = (T) => {\n          if (s === 1 / 0)\n            return !0;\n          const A = T.map((H) => H.path).join(\",\"), le = T.map((H) => H.input);\n          return St.getUrl({\n            ...n,\n            runtime: a,\n            type: h,\n            path: A,\n            inputs: le\n          }).length <= s;\n        }, k = t({\n          ...n,\n          runtime: a,\n          type: h,\n          opts: r\n        });\n        return {\n          validate: y,\n          fetch: k\n        };\n      }, o = vt(i(\"query\")), c = vt(i(\"mutation\")), u = vt(i(\"subscription\")), d = {\n        query: o,\n        subscription: u,\n        mutation: c\n      };\n      return ({ op: h }) => Bs.observable((y) => {\n        const k = d[h.type], { promise: T, cancel: A } = k.load(h);\n        let le;\n        return T.then(($) => {\n          le = $;\n          const H = Vs.transformResult($.json, a);\n          if (!H.ok) {\n            y.error(fr.TRPCClientError.from(H.error, {\n              meta: $.meta\n            }));\n            return;\n          }\n          y.next({\n            context: $.meta,\n            result: H.result\n          }), y.complete();\n        }).catch(($) => {\n          y.error(fr.TRPCClientError.from($, {\n            meta: le?.meta\n          }));\n        }), () => {\n          A();\n        };\n      });\n    };\n  };\n}\nconst Fs = (t) => (e) => {\n  const r = e.map((i) => i.path).join(\",\"), n = e.map((i) => i.input), { promise: s, cancel: a } = St.jsonHttpRequester({\n    ...t,\n    path: r,\n    inputs: n,\n    headers() {\n      return t.opts.headers ? typeof t.opts.headers == \"function\" ? t.opts.headers({\n        opList: e\n      }) : t.opts.headers : {};\n    }\n  });\n  return {\n    promise: s.then((i) => (Array.isArray(i.json) ? i.json : e.map(() => i.json)).map((u) => ({\n      meta: i.meta,\n      json: u\n    }))),\n    cancel: a\n  };\n}, Hs = Yr(Fs);\nzt.createHTTPBatchLink = Yr;\nzt.httpBatchLink = Hs;\nvar it = {};\nObject.defineProperty(it, \"__esModule\", { value: !0 });\nvar Gs = we, Js = ke, pr = xe, Xr = F;\nfunction Qr(t) {\n  return (e) => {\n    const r = Xr.resolveHTTPLinkOptions(e);\n    return (n) => ({ op: s }) => Gs.observable((a) => {\n      const { path: i, input: o, type: c } = s, { promise: u, cancel: d } = t.requester({\n        ...r,\n        runtime: n,\n        type: c,\n        path: i,\n        input: o,\n        headers() {\n          return e.headers ? typeof e.headers == \"function\" ? e.headers({\n            op: s\n          }) : e.headers : {};\n        }\n      });\n      let h;\n      return u.then((y) => {\n        h = y.meta;\n        const k = Js.transformResult(y.json, n);\n        if (!k.ok) {\n          a.error(pr.TRPCClientError.from(k.error, {\n            meta: h\n          }));\n          return;\n        }\n        a.next({\n          context: y.meta,\n          result: k.result\n        }), a.complete();\n      }).catch((y) => {\n        a.error(pr.TRPCClientError.from(y, {\n          meta: h\n        }));\n      }), () => {\n        d();\n      };\n    });\n  };\n}\nconst Ys = Qr({\n  requester: Xr.jsonHttpRequester\n});\nit.httpLink = Ys;\nit.httpLinkFactory = Qr;\nvar Bt = {};\nObject.defineProperty(Bt, \"__esModule\", { value: !0 });\nvar hr = we;\nfunction Xs(t) {\n  return typeof FormData > \"u\" ? !1 : t instanceof FormData;\n}\nconst bt = {\n  css: {\n    query: [\n      \"72e3ff\",\n      \"3fb0d8\"\n    ],\n    mutation: [\n      \"c5a3fc\",\n      \"904dfc\"\n    ],\n    subscription: [\n      \"ff49e1\",\n      \"d83fbe\"\n    ]\n  },\n  ansi: {\n    regular: {\n      // Cyan background, black and white text respectively\n      query: [\n        \"\\x1B[30;46m\",\n        \"\\x1B[97;46m\"\n      ],\n      // Magenta background, black and white text respectively\n      mutation: [\n        \"\\x1B[30;45m\",\n        \"\\x1B[97;45m\"\n      ],\n      // Green background, black and white text respectively\n      subscription: [\n        \"\\x1B[30;42m\",\n        \"\\x1B[97;42m\"\n      ]\n    },\n    bold: {\n      query: [\n        \"\\x1B[1;30;46m\",\n        \"\\x1B[1;97;46m\"\n      ],\n      mutation: [\n        \"\\x1B[1;30;45m\",\n        \"\\x1B[1;97;45m\"\n      ],\n      subscription: [\n        \"\\x1B[1;30;42m\",\n        \"\\x1B[1;97;42m\"\n      ]\n    }\n  }\n};\nfunction Qs(t) {\n  const { direction: e, type: r, path: n, id: s, input: a } = t, i = [], o = [];\n  if (t.colorMode === \"ansi\") {\n    const [h, y] = bt.ansi.regular[r], [k, T] = bt.ansi.bold[r], A = \"\\x1B[0m\";\n    return i.push(e === \"up\" ? h : y, e === \"up\" ? \">>\" : \"<<\", r, e === \"up\" ? k : T, `#${s}`, n, A), e === \"up\" ? o.push({\n      input: t.input\n    }) : o.push({\n      input: t.input,\n      // strip context from result cause it's too noisy in terminal wihtout collapse mode\n      result: \"result\" in t.result ? t.result.result : t.result,\n      elapsedMs: t.elapsedMs\n    }), {\n      parts: i,\n      args: o\n    };\n  }\n  const [c, u] = bt.css[r], d = `\n    background-color: #${e === \"up\" ? c : u}; \n    color: ${e === \"up\" ? \"black\" : \"white\"};\n    padding: 2px;\n  `;\n  return i.push(\"%c\", e === \"up\" ? \">>\" : \"<<\", r, `#${s}`, `%c${n}%c`, \"%O\"), o.push(d, `${d}; font-weight: bold;`, `${d}; font-weight: normal;`), e === \"up\" ? o.push({\n    input: a,\n    context: t.context\n  }) : o.push({\n    input: a,\n    result: t.result,\n    elapsedMs: t.elapsedMs,\n    context: t.context\n  }), {\n    parts: i,\n    args: o\n  };\n}\nconst Ks = ({ c: t = console, colorMode: e = \"css\" }) => (r) => {\n  const n = r.input, s = Xs(n) ? Object.fromEntries(n) : n, { parts: a, args: i } = Qs({\n    ...r,\n    colorMode: e,\n    input: s\n  }), o = r.direction === \"down\" && r.result && (r.result instanceof Error || \"error\" in r.result.result) ? \"error\" : \"log\";\n  t[o].apply(null, [\n    a.join(\" \")\n  ].concat(i));\n};\nfunction ea(t = {}) {\n  const { enabled: e = () => !0 } = t, r = t.colorMode ?? (typeof window > \"u\" ? \"ansi\" : \"css\"), { logger: n = Ks({\n    c: t.console,\n    colorMode: r\n  }) } = t;\n  return () => ({ op: s, next: a }) => hr.observable((i) => {\n    e({\n      ...s,\n      direction: \"up\"\n    }) && n({\n      ...s,\n      direction: \"up\"\n    });\n    const o = Date.now();\n    function c(u) {\n      const d = Date.now() - o;\n      e({\n        ...s,\n        direction: \"down\",\n        result: u\n      }) && n({\n        ...s,\n        direction: \"down\",\n        elapsedMs: d,\n        result: u\n      });\n    }\n    return a(s).pipe(hr.tap({\n      next(u) {\n        c(u);\n      },\n      error(u) {\n        c(u);\n      }\n    })).subscribe(i);\n  });\n}\nBt.loggerLink = ea;\nvar ot = {};\nObject.defineProperty(ot, \"__esModule\", { value: !0 });\nvar ta = we, ra = ke, Kr = xe;\n/* istanbul ignore next -- @preserve */\nconst na = (t) => t === 0 ? 0 : Math.min(1e3 * 2 ** t, 3e4);\nfunction sa(t) {\n  const { url: e, WebSocket: r = WebSocket, retryDelayMs: n = na, onOpen: s, onClose: a } = t;\n  /* istanbul ignore next -- @preserve */\n  if (!r)\n    throw new Error(\"No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill\");\n  let i = [];\n  const o = /* @__PURE__ */ Object.create(null);\n  let c = 0, u = null, d = null, h = Qt(), y = \"connecting\";\n  function k() {\n    y !== \"open\" || u || (u = setTimeout(() => {\n      u = null, i.length === 1 ? h.send(JSON.stringify(i.pop())) : h.send(JSON.stringify(i)), i = [];\n    }));\n  }\n  function T() {\n    if (d !== null || y === \"closed\")\n      return;\n    const R = n(c++);\n    le(R);\n  }\n  function A() {\n    y = \"connecting\";\n    const R = h;\n    h = Qt(), $(R);\n  }\n  function le(R) {\n    d || (y = \"connecting\", d = setTimeout(A, R));\n  }\n  function $(R) {\n    Object.values(o).some((de) => de.ws === R) || R.close();\n  }\n  function H() {\n    Object.values(o).forEach((R) => {\n      R.type === \"subscription\" && R.callbacks.complete();\n    });\n  }\n  function Xt(R) {\n    i.some((P) => P.id === R.op.id) || Kt(R.op, R.callbacks);\n  }\n  function Qt() {\n    const R = typeof e == \"function\" ? e() : e, P = new r(R);\n    clearTimeout(d), d = null, P.addEventListener(\"open\", () => {\n      /* istanbul ignore next -- @preserve */\n      P === h && (c = 0, y = \"open\", s?.(), k());\n    }), P.addEventListener(\"error\", () => {\n      P === h && T();\n    });\n    const de = (j) => {\n      if (j.method === \"reconnect\" && P === h) {\n        y === \"open\" && a?.(), A();\n        for (const E of Object.values(o))\n          E.type === \"subscription\" && Xt(E);\n      }\n    }, pt = (j) => {\n      const E = j.id !== null && o[j.id];\n      if (E) {\n        if (E.callbacks.next?.(j), E.ws !== h && P === h) {\n          const G = E.ws;\n          E.ws = h, $(G);\n        }\n        \"result\" in j && j.result.type === \"stopped\" && P === h && E.callbacks.complete();\n      }\n    };\n    return P.addEventListener(\"message\", ({ data: j }) => {\n      const E = JSON.parse(j);\n      \"method\" in E ? de(E) : pt(E), (P !== h || y === \"closed\") && $(P);\n    }), P.addEventListener(\"close\", ({ code: j }) => {\n      y === \"open\" && a?.({\n        code: j\n      }), h === P && T();\n      for (const [E, G] of Object.entries(o))\n        if (G.ws === P) {\n          if (y === \"closed\") {\n            delete o[E], G.callbacks.complete?.();\n            continue;\n          }\n          G.type === \"subscription\" ? Xt(G) : (delete o[E], G.callbacks.error?.(Kr.TRPCClientError.from(new Vt(\"WebSocket closed prematurely\"))));\n        }\n    }), P;\n  }\n  function Kt(R, P) {\n    const { type: de, input: pt, path: j, id: E } = R, G = {\n      id: E,\n      method: de,\n      params: {\n        input: pt,\n        path: j\n      }\n    };\n    return o[E] = {\n      ws: h,\n      type: de,\n      callbacks: P,\n      op: R\n    }, i.push(G), k(), () => {\n      const Cn = o[E]?.callbacks;\n      delete o[E], i = i.filter((Rn) => Rn.id !== E), Cn?.complete?.(), h.readyState === r.OPEN && R.type === \"subscription\" && (i.push({\n        id: E,\n        method: \"subscription.stop\"\n      }), k());\n    };\n  }\n  return {\n    close: () => {\n      y = \"closed\", a?.(), H(), $(h), clearTimeout(d), d = null;\n    },\n    request: Kt,\n    getConnection() {\n      return h;\n    }\n  };\n}\nclass Vt extends Error {\n  constructor(e) {\n    super(e), this.name = \"TRPCWebSocketClosedError\", Object.setPrototypeOf(this, Vt.prototype);\n  }\n}\nfunction aa(t) {\n  return (e) => {\n    const { client: r } = t;\n    return ({ op: n }) => ta.observable((s) => {\n      const { type: a, path: i, id: o, context: c } = n, u = e.transformer.serialize(n.input), d = r.request({\n        type: a,\n        path: i,\n        input: u,\n        id: o,\n        context: c\n      }, {\n        error(h) {\n          s.error(h), d();\n        },\n        complete() {\n          s.complete();\n        },\n        next(h) {\n          const y = ra.transformResult(h, e);\n          if (!y.ok) {\n            s.error(Kr.TRPCClientError.from(y.error));\n            return;\n          }\n          s.next({\n            result: y.result\n          }), n.type !== \"subscription\" && (d(), s.complete());\n        }\n      });\n      return () => {\n        d();\n      };\n    });\n  };\n}\not.createWSClient = sa;\not.wsLink = aa;\nObject.defineProperty(S, \"__esModule\", { value: !0 });\nvar mr = we, en = qt, tn = xe, yr = qr, Ae = F, rn = zt, Ft = it, ia = Bt, nn = ot;\nclass ct {\n  $request({ type: e, input: r, path: n, context: s = {} }) {\n    return en.createChain({\n      links: this.links,\n      op: {\n        id: ++this.requestId,\n        type: e,\n        path: n,\n        input: r,\n        context: s\n      }\n    }).pipe(mr.share());\n  }\n  requestAsPromise(e) {\n    const r = this.$request(e), { promise: n, abort: s } = mr.observableToPromise(r);\n    return new Promise((i, o) => {\n      e.signal?.addEventListener(\"abort\", s), n.then((c) => {\n        i(c.result.data);\n      }).catch((c) => {\n        o(tn.TRPCClientError.from(c));\n      });\n    });\n  }\n  query(e, r, n) {\n    return this.requestAsPromise({\n      type: \"query\",\n      path: e,\n      input: r,\n      context: n?.context,\n      signal: n?.signal\n    });\n  }\n  mutation(e, r, n) {\n    return this.requestAsPromise({\n      type: \"mutation\",\n      path: e,\n      input: r,\n      context: n?.context,\n      signal: n?.signal\n    });\n  }\n  subscription(e, r, n) {\n    return this.$request({\n      type: \"subscription\",\n      path: e,\n      input: r,\n      context: n?.context\n    }).subscribe({\n      next(a) {\n        a.result.type === \"started\" ? n.onStarted?.() : a.result.type === \"stopped\" ? n.onStopped?.() : n.onData?.(a.result.data);\n      },\n      error(a) {\n        n.onError?.(a);\n      },\n      complete() {\n        n.onComplete?.();\n      }\n    });\n  }\n  constructor(e) {\n    this.requestId = 0;\n    const r = (() => {\n      const n = e.transformer;\n      return n ? \"input\" in n ? e.transformer : {\n        input: n,\n        output: n\n      } : {\n        input: {\n          serialize: (s) => s,\n          deserialize: (s) => s\n        },\n        output: {\n          serialize: (s) => s,\n          deserialize: (s) => s\n        }\n      };\n    })();\n    this.runtime = {\n      transformer: {\n        serialize: (n) => r.input.serialize(n),\n        deserialize: (n) => r.output.deserialize(n)\n      },\n      combinedTransformer: r\n    }, this.links = e.links.map((n) => n(this.runtime));\n  }\n}\nfunction oa(t) {\n  return new ct(t);\n}\nfunction ca(t) {\n  return new ct(t);\n}\nconst ua = {\n  query: \"query\",\n  mutate: \"mutation\",\n  subscribe: \"subscription\"\n}, sn = (t) => ua[t];\nfunction an(t) {\n  return yr.createFlatProxy((e) => t.hasOwnProperty(e) ? t[e] : e === \"__untypedClient\" ? t : yr.createRecursiveProxy(({ path: r, args: n }) => {\n    const s = [\n      e,\n      ...r\n    ], a = sn(s.pop()), i = s.join(\".\");\n    return t[a](i, ...n);\n  }));\n}\nfunction la(t) {\n  const e = new ct(t);\n  return an(e);\n}\nfunction da(t) {\n  return t.__untypedClient;\n}\nfunction fa(t) {\n  if (t)\n    return t;\n  if (typeof window < \"u\" && window.TextDecoder)\n    return new window.TextDecoder();\n  if (typeof globalThis < \"u\" && globalThis.TextDecoder)\n    return new globalThis.TextDecoder();\n  throw new Error(\"No TextDecoder implementation found\");\n}\nasync function pa(t) {\n  const e = t.parse ?? JSON.parse, r = (n) => {\n    if (t.signal?.aborted || !n || n === \"}\")\n      return;\n    const s = n.indexOf(\":\"), a = n.substring(2, s - 1), i = n.substring(s + 1);\n    t.onSingle(Number(a), e(i));\n  };\n  await ha(t.readableStream, r, t.textDecoder);\n}\nasync function ha(t, e, r) {\n  let n = \"\";\n  const s = (a) => {\n    const o = r.decode(a).split(`\n`);\n    if (o.length === 1)\n      n += o[0];\n    else if (o.length > 1) {\n      e(n + o[0]);\n      for (let c = 1; c < o.length - 1; c++)\n        e(o[c]);\n      n = o[o.length - 1];\n    }\n  };\n  \"getReader\" in t ? await ya(t, s) : await ma(t, s), e(n);\n}\nfunction ma(t, e) {\n  return new Promise((r) => {\n    t.on(\"data\", e), t.on(\"end\", r);\n  });\n}\nasync function ya(t, e) {\n  const r = t.getReader();\n  let n = await r.read();\n  for (; !n.done; )\n    e(n.value), n = await r.read();\n}\nconst ga = (t, e) => {\n  const r = t.AbortController ? new t.AbortController() : null, n = Ae.fetchHTTPResponse({\n    ...t,\n    contentTypeHeader: \"application/json\",\n    batchModeHeader: \"stream\",\n    getUrl: Ae.getUrl,\n    getBody: Ae.getBody\n  }, r), s = () => r?.abort(), a = n.then(async (i) => {\n    if (!i.body)\n      throw new Error(\"Received response without body\");\n    const o = {\n      response: i\n    };\n    return pa({\n      readableStream: i.body,\n      onSingle: e,\n      parse: (c) => ({\n        json: JSON.parse(c),\n        meta: o\n      }),\n      signal: r?.signal,\n      textDecoder: t.textDecoder\n    });\n  });\n  return {\n    cancel: s,\n    promise: a\n  };\n}, _a = (t) => {\n  const e = fa(t.opts.textDecoder);\n  return (r, n) => {\n    const s = r.map((c) => c.path).join(\",\"), a = r.map((c) => c.input), { cancel: i, promise: o } = ga({\n      ...t,\n      textDecoder: e,\n      path: s,\n      inputs: a,\n      headers() {\n        return t.opts.headers ? typeof t.opts.headers == \"function\" ? t.opts.headers({\n          opList: r\n        }) : t.opts.headers : {};\n      }\n    }, (c, u) => {\n      n(c, u);\n    });\n    return {\n      /**\n      * return an empty array because the batchLoader expects an array of results\n      * but we've already called the `unitResolver` for each of them, there's\n      * nothing left to do here.\n      */\n      promise: o.then(() => []),\n      cancel: i\n    };\n  };\n}, va = rn.createHTTPBatchLink(_a), ba = (t) => {\n  if (\"input\" in t) {\n    if (!(t.input instanceof FormData))\n      throw new Error(\"Input is not FormData\");\n    return t.input;\n  }\n}, wa = (t) => {\n  if (t.type !== \"mutation\")\n    throw new Error(\"We only handle mutations with formdata\");\n  return Ae.httpRequest({\n    ...t,\n    getUrl() {\n      return `${t.url}/${t.path}`;\n    },\n    getBody: ba\n  });\n}, xa = Ft.httpLinkFactory({\n  requester: wa\n});\nS.splitLink = en.splitLink;\nS.TRPCClientError = tn.TRPCClientError;\nS.getFetch = Ae.getFetch;\nS.httpBatchLink = rn.httpBatchLink;\nS.httpLink = Ft.httpLink;\nS.httpLinkFactory = Ft.httpLinkFactory;\nS.loggerLink = ia.loggerLink;\nS.createWSClient = nn.createWSClient;\nS.wsLink = nn.wsLink;\nS.TRPCUntypedClient = ct;\nS.clientCallTypeToProcedureType = sn;\nS.createTRPCClient = ca;\nS.createTRPCClientProxy = an;\nS.createTRPCProxyClient = la;\nS.createTRPCUntypedClient = oa;\nS.experimental_formDataLink = xa;\nS.getUntypedClient = da;\nS.unstable_httpBatchStreamLink = va;\nvar ne = {}, Ht = {};\nfunction ka(t) {\n  return t;\n}\nfunction Ta(t) {\n  return t.length === 0 ? ka : t.length === 1 ? t[0] : function(r) {\n    return t.reduce((n, s) => s(n), r);\n  };\n}\nfunction Ea(t) {\n  return typeof t == \"object\" && t !== null && \"subscribe\" in t;\n}\nfunction Ca(t) {\n  const e = {\n    subscribe(r) {\n      let n = null, s = !1, a = !1, i = !1;\n      function o() {\n        if (n === null) {\n          i = !0;\n          return;\n        }\n        a || (a = !0, typeof n == \"function\" ? n() : n && n.unsubscribe());\n      }\n      return n = t({\n        next(c) {\n          s || r.next?.(c);\n        },\n        error(c) {\n          s || (s = !0, r.error?.(c), o());\n        },\n        complete() {\n          s || (s = !0, r.complete?.(), o());\n        }\n      }), i && o(), {\n        unsubscribe: o\n      };\n    },\n    pipe(...r) {\n      return Ta(r)(e);\n    }\n  };\n  return e;\n}\nHt.isObservable = Ea;\nHt.observable = Ca;\nObject.defineProperty(ne, \"__esModule\", { value: !0 });\nvar on = Ht;\nfunction Ra(t) {\n  return (e) => {\n    let r = 0, n = null;\n    const s = [];\n    function a() {\n      n || (n = e.subscribe({\n        next(o) {\n          for (const c of s)\n            c.next?.(o);\n        },\n        error(o) {\n          for (const c of s)\n            c.error?.(o);\n        },\n        complete() {\n          for (const o of s)\n            o.complete?.();\n        }\n      }));\n    }\n    function i() {\n      if (r === 0 && n) {\n        const o = n;\n        n = null, o.unsubscribe();\n      }\n    }\n    return {\n      subscribe(o) {\n        return r++, s.push(o), a(), {\n          unsubscribe() {\n            r--, i();\n            const c = s.findIndex((u) => u === o);\n            c > -1 && s.splice(c, 1);\n          }\n        };\n      }\n    };\n  };\n}\nfunction Oa(t) {\n  return (e) => ({\n    subscribe(r) {\n      let n = 0;\n      return e.subscribe({\n        next(a) {\n          r.next?.(t(a, n++));\n        },\n        error(a) {\n          r.error?.(a);\n        },\n        complete() {\n          r.complete?.();\n        }\n      });\n    }\n  });\n}\nfunction Sa(t) {\n  return (e) => ({\n    subscribe(r) {\n      return e.subscribe({\n        next(n) {\n          t.next?.(n), r.next?.(n);\n        },\n        error(n) {\n          t.error?.(n), r.error?.(n);\n        },\n        complete() {\n          t.complete?.(), r.complete?.();\n        }\n      });\n    }\n  });\n}\nclass Gt extends Error {\n  constructor(e) {\n    super(e), this.name = \"ObservableAbortError\", Object.setPrototypeOf(this, Gt.prototype);\n  }\n}\nfunction Pa(t) {\n  let e;\n  return {\n    promise: new Promise((n, s) => {\n      let a = !1;\n      function i() {\n        a || (a = !0, s(new Gt(\"This operation was aborted.\")), o.unsubscribe());\n      }\n      const o = t.subscribe({\n        next(c) {\n          a = !0, n(c), i();\n        },\n        error(c) {\n          a = !0, s(c), i();\n        },\n        complete() {\n          a = !0, i();\n        }\n      });\n      e = i;\n    }),\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    abort: e\n  };\n}\nne.isObservable = on.isObservable;\nne.observable = on.observable;\nne.map = Oa;\nne.observableToPromise = Pa;\nne.share = Ra;\nne.tap = Sa;\nvar q = {};\nObject.defineProperty(q, \"__esModule\", { value: !0 });\nq.isTRPCRequestWithId = q.isTRPCRequest = q.isTRPCResponse = q.isTRPCMessage = void 0;\nfunction gr(t) {\n  return typeof t == \"object\" && t !== null && !Array.isArray(t);\n}\nfunction Aa(t) {\n  return t == null;\n}\nfunction cn(t) {\n  return !!(gr(t) && \"trpc\" in t && gr(t.trpc));\n}\nq.isTRPCMessage = cn;\nfunction Jt(t) {\n  return cn(t) && \"id\" in t.trpc && !Aa(t.trpc.id);\n}\nfunction Na(t) {\n  return Jt(t) && (\"error\" in t.trpc || \"result\" in t.trpc);\n}\nq.isTRPCResponse = Na;\nfunction un(t) {\n  return Jt(t) && \"method\" in t.trpc;\n}\nq.isTRPCRequest = un;\nfunction Ia(t) {\n  return un(t) && Jt(t);\n}\nq.isTRPCRequestWithId = Ia;\nObject.defineProperty(be, \"__esModule\", { value: !0 });\nbe.createBaseLink = void 0;\nconst wt = S, ja = ne, La = q, $a = (t) => (e) => ({ op: r }) => (0, ja.observable)((n) => {\n  const s = [], { id: a, type: i, path: o } = r;\n  try {\n    const c = e.transformer.serialize(r.input), u = () => {\n      n.error(new wt.TRPCClientError(\"Port disconnected prematurely\"));\n    };\n    t.addCloseListener(u), s.push(() => t.removeCloseListener(u));\n    const d = (h) => {\n      if (!(0, La.isTRPCResponse)(h))\n        return;\n      const { trpc: y } = h;\n      if (a === y.id) {\n        if (\"error\" in y)\n          return n.error(wt.TRPCClientError.from(y));\n        n.next({\n          result: Object.assign(Object.assign({}, y.result), (!y.result.type || y.result.type === \"data\") && {\n            type: \"data\",\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            data: e.transformer.deserialize(y.result.data)\n          })\n        }), (i !== \"subscription\" || y.result.type === \"stopped\") && n.complete();\n      }\n    };\n    t.addMessageListener(d), s.push(() => t.removeMessageListener(d)), t.postMessage({\n      trpc: {\n        id: a,\n        jsonrpc: void 0,\n        method: i,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        params: { path: o, input: c }\n      }\n    });\n  } catch (c) {\n    n.error(new wt.TRPCClientError(c instanceof Error ? c.message : \"Unknown error\"));\n  }\n  return () => {\n    i === \"subscription\" && t.postMessage({\n      trpc: {\n        id: a,\n        jsonrpc: void 0,\n        method: \"subscription.stop\"\n      }\n    }), s.forEach((c) => c());\n  };\n});\nbe.createBaseLink = $a;\nObject.defineProperty(at, \"__esModule\", { value: !0 });\nat.chromeLink = void 0;\nconst Ma = be, Da = (t) => (0, Ma.createBaseLink)({\n  postMessage(e) {\n    t.port.postMessage(e);\n  },\n  addMessageListener(e) {\n    t.port.onMessage.addListener(e);\n  },\n  removeMessageListener(e) {\n    t.port.onMessage.removeListener(e);\n  },\n  addCloseListener(e) {\n    t.port.onDisconnect.addListener(e);\n  },\n  removeCloseListener(e) {\n    t.port.onDisconnect.removeListener(e);\n  }\n});\nat.chromeLink = Da;\nvar ut = {};\nObject.defineProperty(ut, \"__esModule\", { value: !0 });\nut.windowLink = void 0;\nconst Za = be, Ua = (t) => {\n  var e;\n  const r = /* @__PURE__ */ new Map(), n = t.window, s = (e = t.postWindow) !== null && e !== void 0 ? e : n;\n  return (0, Za.createBaseLink)({\n    postMessage(a) {\n      s.postMessage(a, {\n        targetOrigin: t.postOrigin\n      });\n    },\n    addMessageListener(a) {\n      const i = (o) => {\n        a(o.data);\n      };\n      r.set(a, i), n.addEventListener(\"message\", i);\n    },\n    removeMessageListener(a) {\n      const i = r.get(a);\n      i && n.removeEventListener(\"message\", i);\n    },\n    addCloseListener(a) {\n      n.addEventListener(\"beforeunload\", a);\n    },\n    removeCloseListener(a) {\n      n.removeEventListener(\"beforeunload\", a);\n    }\n  });\n};\nut.windowLink = Ua;\nvar lt = {}, dt = {};\nObject.defineProperty(dt, \"__esModule\", { value: !0 });\ndt.TRPC_BROWSER_LOADED_EVENT = void 0;\ndt.TRPC_BROWSER_LOADED_EVENT = \"TRPC_BROWSER::POPUP_LOADED\";\nObject.defineProperty(lt, \"__esModule\", { value: !0 });\nlt.popupLink = void 0;\nconst Wa = dt, qa = be, za = (t) => {\n  const e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set();\n  let n = null;\n  async function s(a) {\n    if (!n || n.closed) {\n      n = t.createPopup(), await Promise.race([\n        // wait til window is loaded (same origin)\n        new Promise((i) => {\n          var o;\n          try {\n            (o = n?.addEventListener) === null || o === void 0 || o.call(n, \"load\", i);\n          } catch {\n          }\n        }),\n        // this is needed for cross-origin popups as they don't have a load event\n        new Promise((i) => {\n          a.addEventListener(\"message\", (o) => {\n            o.data === Wa.TRPC_BROWSER_LOADED_EVENT && i();\n          });\n        }),\n        // expect the popup to load after 15s max, in case non of the above events fire\n        new Promise((i) => {\n          console.warn(\"Could not detect if popup loading succeeded after 15s timeout, continuing anyway\"), setTimeout(i, 15e3);\n        })\n      ]);\n      try {\n        if (!n.addEventListener)\n          throw new Error(\"popupWindow.addEventListener is not a function\");\n        n.addEventListener(\"beforeunload\", () => {\n          n = null;\n        });\n      } catch {\n        const o = setInterval(() => {\n          n && n.closed && (n = null, r.forEach((c) => {\n            c();\n          }), clearInterval(o));\n        }, 1e3);\n      }\n    }\n    return n;\n  }\n  return (0, qa.createBaseLink)({\n    async postMessage(a) {\n      return (await s(t.listenWindow)).postMessage(a, {\n        targetOrigin: t.postOrigin\n      });\n    },\n    addMessageListener(a) {\n      const i = (o) => {\n        a(o.data);\n      };\n      e.set(a, i), t.listenWindow.addEventListener(\"message\", i);\n    },\n    removeMessageListener(a) {\n      const i = e.get(a);\n      i && t.listenWindow.removeEventListener(\"message\", i);\n    },\n    addCloseListener(a) {\n      t.listenWindow.addEventListener(\"beforeunload\", a), r.add(a);\n    },\n    removeCloseListener(a) {\n      t.listenWindow.removeEventListener(\"beforeunload\", a), r.delete(a);\n    }\n  });\n};\nlt.popupLink = za;\n(function(t) {\n  var e = _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.c && _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.c.__createBinding || (Object.create ? function(n, s, a, i) {\n    i === void 0 && (i = a);\n    var o = Object.getOwnPropertyDescriptor(s, a);\n    (!o || (\"get\" in o ? !s.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {\n      return s[a];\n    } }), Object.defineProperty(n, i, o);\n  } : function(n, s, a, i) {\n    i === void 0 && (i = a), n[i] = s[a];\n  }), r = _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.c && _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.c.__exportStar || function(n, s) {\n    for (var a in n)\n      a !== \"default\" && !Object.prototype.hasOwnProperty.call(s, a) && e(s, n, a);\n  };\n  Object.defineProperty(t, \"__esModule\", { value: !0 }), r(at, t), r(ut, t), r(lt, t);\n})(Rt);\nvar x;\n(function(t) {\n  t.assertEqual = (s) => s;\n  function e(s) {\n  }\n  t.assertIs = e;\n  function r(s) {\n    throw new Error();\n  }\n  t.assertNever = r, t.arrayToEnum = (s) => {\n    const a = {};\n    for (const i of s)\n      a[i] = i;\n    return a;\n  }, t.getValidEnumValues = (s) => {\n    const a = t.objectKeys(s).filter((o) => typeof s[s[o]] != \"number\"), i = {};\n    for (const o of a)\n      i[o] = s[o];\n    return t.objectValues(i);\n  }, t.objectValues = (s) => t.objectKeys(s).map(function(a) {\n    return s[a];\n  }), t.objectKeys = typeof Object.keys == \"function\" ? (s) => Object.keys(s) : (s) => {\n    const a = [];\n    for (const i in s)\n      Object.prototype.hasOwnProperty.call(s, i) && a.push(i);\n    return a;\n  }, t.find = (s, a) => {\n    for (const i of s)\n      if (a(i))\n        return i;\n  }, t.isInteger = typeof Number.isInteger == \"function\" ? (s) => Number.isInteger(s) : (s) => typeof s == \"number\" && isFinite(s) && Math.floor(s) === s;\n  function n(s, a = \" | \") {\n    return s.map((i) => typeof i == \"string\" ? `'${i}'` : i).join(a);\n  }\n  t.joinValues = n, t.jsonStringifyReplacer = (s, a) => typeof a == \"bigint\" ? a.toString() : a;\n})(x || (x = {}));\nvar Pt;\n(function(t) {\n  t.mergeShapes = (e, r) => ({\n    ...e,\n    ...r\n    // second overwrites first\n  });\n})(Pt || (Pt = {}));\nconst m = x.arrayToEnum([\n  \"string\",\n  \"nan\",\n  \"number\",\n  \"integer\",\n  \"float\",\n  \"boolean\",\n  \"date\",\n  \"bigint\",\n  \"symbol\",\n  \"function\",\n  \"undefined\",\n  \"null\",\n  \"array\",\n  \"object\",\n  \"unknown\",\n  \"promise\",\n  \"void\",\n  \"never\",\n  \"map\",\n  \"set\"\n]), Y = (t) => {\n  switch (typeof t) {\n    case \"undefined\":\n      return m.undefined;\n    case \"string\":\n      return m.string;\n    case \"number\":\n      return isNaN(t) ? m.nan : m.number;\n    case \"boolean\":\n      return m.boolean;\n    case \"function\":\n      return m.function;\n    case \"bigint\":\n      return m.bigint;\n    case \"symbol\":\n      return m.symbol;\n    case \"object\":\n      return Array.isArray(t) ? m.array : t === null ? m.null : t.then && typeof t.then == \"function\" && t.catch && typeof t.catch == \"function\" ? m.promise : typeof Map < \"u\" && t instanceof Map ? m.map : typeof Set < \"u\" && t instanceof Set ? m.set : typeof Date < \"u\" && t instanceof Date ? m.date : m.object;\n    default:\n      return m.unknown;\n  }\n}, f = x.arrayToEnum([\n  \"invalid_type\",\n  \"invalid_literal\",\n  \"custom\",\n  \"invalid_union\",\n  \"invalid_union_discriminator\",\n  \"invalid_enum_value\",\n  \"unrecognized_keys\",\n  \"invalid_arguments\",\n  \"invalid_return_type\",\n  \"invalid_date\",\n  \"invalid_string\",\n  \"too_small\",\n  \"too_big\",\n  \"invalid_intersection_types\",\n  \"not_multiple_of\",\n  \"not_finite\"\n]), Ba = (t) => JSON.stringify(t, null, 2).replace(/\"([^\"]+)\":/g, \"$1:\");\nclass L extends Error {\n  get errors() {\n    return this.issues;\n  }\n  constructor(e) {\n    super(), this.issues = [], this.addIssue = (n) => {\n      this.issues = [...this.issues, n];\n    }, this.addIssues = (n = []) => {\n      this.issues = [...this.issues, ...n];\n    };\n    const r = new.target.prototype;\n    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = \"ZodError\", this.issues = e;\n  }\n  format(e) {\n    const r = e || function(a) {\n      return a.message;\n    }, n = { _errors: [] }, s = (a) => {\n      for (const i of a.issues)\n        if (i.code === \"invalid_union\")\n          i.unionErrors.map(s);\n        else if (i.code === \"invalid_return_type\")\n          s(i.returnTypeError);\n        else if (i.code === \"invalid_arguments\")\n          s(i.argumentsError);\n        else if (i.path.length === 0)\n          n._errors.push(r(i));\n        else {\n          let o = n, c = 0;\n          for (; c < i.path.length; ) {\n            const u = i.path[c];\n            c === i.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(r(i))) : o[u] = o[u] || { _errors: [] }, o = o[u], c++;\n          }\n        }\n    };\n    return s(this), n;\n  }\n  static assert(e) {\n    if (!(e instanceof L))\n      throw new Error(`Not a ZodError: ${e}`);\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, x.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(e = (r) => r.message) {\n    const r = {}, n = [];\n    for (const s of this.issues)\n      s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [], r[s.path[0]].push(e(s))) : n.push(e(s));\n    return { formErrors: n, fieldErrors: r };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n}\nL.create = (t) => new L(t);\nconst ge = (t, e) => {\n  let r;\n  switch (t.code) {\n    case f.invalid_type:\n      t.received === m.undefined ? r = \"Required\" : r = `Expected ${t.expected}, received ${t.received}`;\n      break;\n    case f.invalid_literal:\n      r = `Invalid literal value, expected ${JSON.stringify(t.expected, x.jsonStringifyReplacer)}`;\n      break;\n    case f.unrecognized_keys:\n      r = `Unrecognized key(s) in object: ${x.joinValues(t.keys, \", \")}`;\n      break;\n    case f.invalid_union:\n      r = \"Invalid input\";\n      break;\n    case f.invalid_union_discriminator:\n      r = `Invalid discriminator value. Expected ${x.joinValues(t.options)}`;\n      break;\n    case f.invalid_enum_value:\n      r = `Invalid enum value. Expected ${x.joinValues(t.options)}, received '${t.received}'`;\n      break;\n    case f.invalid_arguments:\n      r = \"Invalid function arguments\";\n      break;\n    case f.invalid_return_type:\n      r = \"Invalid function return type\";\n      break;\n    case f.invalid_date:\n      r = \"Invalid date\";\n      break;\n    case f.invalid_string:\n      typeof t.validation == \"object\" ? \"includes\" in t.validation ? (r = `Invalid input: must include \"${t.validation.includes}\"`, typeof t.validation.position == \"number\" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : \"startsWith\" in t.validation ? r = `Invalid input: must start with \"${t.validation.startsWith}\"` : \"endsWith\" in t.validation ? r = `Invalid input: must end with \"${t.validation.endsWith}\"` : x.assertNever(t.validation) : t.validation !== \"regex\" ? r = `Invalid ${t.validation}` : r = \"Invalid\";\n      break;\n    case f.too_small:\n      t.type === \"array\" ? r = `Array must contain ${t.exact ? \"exactly\" : t.inclusive ? \"at least\" : \"more than\"} ${t.minimum} element(s)` : t.type === \"string\" ? r = `String must contain ${t.exact ? \"exactly\" : t.inclusive ? \"at least\" : \"over\"} ${t.minimum} character(s)` : t.type === \"number\" ? r = `Number must be ${t.exact ? \"exactly equal to \" : t.inclusive ? \"greater than or equal to \" : \"greater than \"}${t.minimum}` : t.type === \"date\" ? r = `Date must be ${t.exact ? \"exactly equal to \" : t.inclusive ? \"greater than or equal to \" : \"greater than \"}${new Date(Number(t.minimum))}` : r = \"Invalid input\";\n      break;\n    case f.too_big:\n      t.type === \"array\" ? r = `Array must contain ${t.exact ? \"exactly\" : t.inclusive ? \"at most\" : \"less than\"} ${t.maximum} element(s)` : t.type === \"string\" ? r = `String must contain ${t.exact ? \"exactly\" : t.inclusive ? \"at most\" : \"under\"} ${t.maximum} character(s)` : t.type === \"number\" ? r = `Number must be ${t.exact ? \"exactly\" : t.inclusive ? \"less than or equal to\" : \"less than\"} ${t.maximum}` : t.type === \"bigint\" ? r = `BigInt must be ${t.exact ? \"exactly\" : t.inclusive ? \"less than or equal to\" : \"less than\"} ${t.maximum}` : t.type === \"date\" ? r = `Date must be ${t.exact ? \"exactly\" : t.inclusive ? \"smaller than or equal to\" : \"smaller than\"} ${new Date(Number(t.maximum))}` : r = \"Invalid input\";\n      break;\n    case f.custom:\n      r = \"Invalid input\";\n      break;\n    case f.invalid_intersection_types:\n      r = \"Intersection results could not be merged\";\n      break;\n    case f.not_multiple_of:\n      r = `Number must be a multiple of ${t.multipleOf}`;\n      break;\n    case f.not_finite:\n      r = \"Number must be finite\";\n      break;\n    default:\n      r = e.defaultError, x.assertNever(t);\n  }\n  return { message: r };\n};\nlet ln = ge;\nfunction Va(t) {\n  ln = t;\n}\nfunction Ye() {\n  return ln;\n}\nconst Xe = (t) => {\n  const { data: e, path: r, errorMaps: n, issueData: s } = t, a = [...r, ...s.path || []], i = {\n    ...s,\n    path: a\n  };\n  if (s.message !== void 0)\n    return {\n      ...s,\n      path: a,\n      message: s.message\n    };\n  let o = \"\";\n  const c = n.filter((u) => !!u).slice().reverse();\n  for (const u of c)\n    o = u(i, { data: e, defaultError: o }).message;\n  return {\n    ...s,\n    path: a,\n    message: o\n  };\n}, Fa = [];\nfunction p(t, e) {\n  const r = Ye(), n = Xe({\n    issueData: e,\n    data: t.data,\n    path: t.path,\n    errorMaps: [\n      t.common.contextualErrorMap,\n      // contextual error map is first priority\n      t.schemaErrorMap,\n      // then schema-bound map if available\n      r,\n      // then global override map\n      r === ge ? void 0 : ge\n      // then global default map\n    ].filter((s) => !!s)\n  });\n  t.common.issues.push(n);\n}\nclass N {\n  constructor() {\n    this.value = \"valid\";\n  }\n  dirty() {\n    this.value === \"valid\" && (this.value = \"dirty\");\n  }\n  abort() {\n    this.value !== \"aborted\" && (this.value = \"aborted\");\n  }\n  static mergeArray(e, r) {\n    const n = [];\n    for (const s of r) {\n      if (s.status === \"aborted\")\n        return v;\n      s.status === \"dirty\" && e.dirty(), n.push(s.value);\n    }\n    return { status: e.value, value: n };\n  }\n  static async mergeObjectAsync(e, r) {\n    const n = [];\n    for (const s of r) {\n      const a = await s.key, i = await s.value;\n      n.push({\n        key: a,\n        value: i\n      });\n    }\n    return N.mergeObjectSync(e, n);\n  }\n  static mergeObjectSync(e, r) {\n    const n = {};\n    for (const s of r) {\n      const { key: a, value: i } = s;\n      if (a.status === \"aborted\" || i.status === \"aborted\")\n        return v;\n      a.status === \"dirty\" && e.dirty(), i.status === \"dirty\" && e.dirty(), a.value !== \"__proto__\" && (typeof i.value < \"u\" || s.alwaysSet) && (n[a.value] = i.value);\n    }\n    return { status: e.value, value: n };\n  }\n}\nconst v = Object.freeze({\n  status: \"aborted\"\n}), he = (t) => ({ status: \"dirty\", value: t }), I = (t) => ({ status: \"valid\", value: t }), At = (t) => t.status === \"aborted\", Nt = (t) => t.status === \"dirty\", oe = (t) => t.status === \"valid\", Ne = (t) => typeof Promise < \"u\" && t instanceof Promise;\nfunction Qe(t, e, r, n) {\n  if (r === \"a\" && !n)\n    throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof e == \"function\" ? t !== e || !n : !e.has(t))\n    throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return r === \"m\" ? n : r === \"a\" ? n.call(t) : n ? n.value : e.get(t);\n}\nfunction dn(t, e, r, n, s) {\n  if (n === \"m\")\n    throw new TypeError(\"Private method is not writable\");\n  if (n === \"a\" && !s)\n    throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof e == \"function\" ? t !== e || !s : !e.has(t))\n    throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return n === \"a\" ? s.call(t, r) : s ? s.value = r : e.set(t, r), r;\n}\nvar g;\n(function(t) {\n  t.errToObj = (e) => typeof e == \"string\" ? { message: e } : e || {}, t.toString = (e) => typeof e == \"string\" ? e : e?.message;\n})(g || (g = {}));\nvar Re, Oe;\nclass B {\n  constructor(e, r, n, s) {\n    this._cachedPath = [], this.parent = e, this.data = r, this._path = n, this._key = s;\n  }\n  get path() {\n    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;\n  }\n}\nconst _r = (t, e) => {\n  if (oe(e))\n    return { success: !0, data: e.value };\n  if (!t.common.issues.length)\n    throw new Error(\"Validation failed but no issues detected.\");\n  return {\n    success: !1,\n    get error() {\n      if (this._error)\n        return this._error;\n      const r = new L(t.common.issues);\n      return this._error = r, this._error;\n    }\n  };\n};\nfunction b(t) {\n  if (!t)\n    return {};\n  const { errorMap: e, invalid_type_error: r, required_error: n, description: s } = t;\n  if (e && (r || n))\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  return e ? { errorMap: e, description: s } : { errorMap: (i, o) => {\n    var c, u;\n    const { message: d } = t;\n    return i.code === \"invalid_enum_value\" ? { message: d ?? o.defaultError } : typeof o.data > \"u\" ? { message: (c = d ?? n) !== null && c !== void 0 ? c : o.defaultError } : i.code !== \"invalid_type\" ? { message: o.defaultError } : { message: (u = d ?? r) !== null && u !== void 0 ? u : o.defaultError };\n  }, description: s };\n}\nclass w {\n  get description() {\n    return this._def.description;\n  }\n  _getType(e) {\n    return Y(e.data);\n  }\n  _getOrReturnCtx(e, r) {\n    return r || {\n      common: e.parent.common,\n      data: e.data,\n      parsedType: Y(e.data),\n      schemaErrorMap: this._def.errorMap,\n      path: e.path,\n      parent: e.parent\n    };\n  }\n  _processInputParams(e) {\n    return {\n      status: new N(),\n      ctx: {\n        common: e.parent.common,\n        data: e.data,\n        parsedType: Y(e.data),\n        schemaErrorMap: this._def.errorMap,\n        path: e.path,\n        parent: e.parent\n      }\n    };\n  }\n  _parseSync(e) {\n    const r = this._parse(e);\n    if (Ne(r))\n      throw new Error(\"Synchronous parse encountered promise.\");\n    return r;\n  }\n  _parseAsync(e) {\n    const r = this._parse(e);\n    return Promise.resolve(r);\n  }\n  parse(e, r) {\n    const n = this.safeParse(e, r);\n    if (n.success)\n      return n.data;\n    throw n.error;\n  }\n  safeParse(e, r) {\n    var n;\n    const s = {\n      common: {\n        issues: [],\n        async: (n = r?.async) !== null && n !== void 0 ? n : !1,\n        contextualErrorMap: r?.errorMap\n      },\n      path: r?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data: e,\n      parsedType: Y(e)\n    }, a = this._parseSync({ data: e, path: s.path, parent: s });\n    return _r(s, a);\n  }\n  \"~validate\"(e) {\n    var r, n;\n    const s = {\n      common: {\n        issues: [],\n        async: !!this[\"~standard\"].async\n      },\n      path: [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data: e,\n      parsedType: Y(e)\n    };\n    if (!this[\"~standard\"].async)\n      try {\n        const a = this._parseSync({ data: e, path: [], parent: s });\n        return oe(a) ? {\n          value: a.value\n        } : {\n          issues: s.common.issues\n        };\n      } catch (a) {\n        !((n = (r = a?.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || n === void 0) && n.includes(\"encountered\") && (this[\"~standard\"].async = !0), s.common = {\n          issues: [],\n          async: !0\n        };\n      }\n    return this._parseAsync({ data: e, path: [], parent: s }).then((a) => oe(a) ? {\n      value: a.value\n    } : {\n      issues: s.common.issues\n    });\n  }\n  async parseAsync(e, r) {\n    const n = await this.safeParseAsync(e, r);\n    if (n.success)\n      return n.data;\n    throw n.error;\n  }\n  async safeParseAsync(e, r) {\n    const n = {\n      common: {\n        issues: [],\n        contextualErrorMap: r?.errorMap,\n        async: !0\n      },\n      path: r?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data: e,\n      parsedType: Y(e)\n    }, s = this._parse({ data: e, path: n.path, parent: n }), a = await (Ne(s) ? s : Promise.resolve(s));\n    return _r(n, a);\n  }\n  refine(e, r) {\n    const n = (s) => typeof r == \"string\" || typeof r > \"u\" ? { message: r } : typeof r == \"function\" ? r(s) : r;\n    return this._refinement((s, a) => {\n      const i = e(s), o = () => a.addIssue({\n        code: f.custom,\n        ...n(s)\n      });\n      return typeof Promise < \"u\" && i instanceof Promise ? i.then((c) => c ? !0 : (o(), !1)) : i ? !0 : (o(), !1);\n    });\n  }\n  refinement(e, r) {\n    return this._refinement((n, s) => e(n) ? !0 : (s.addIssue(typeof r == \"function\" ? r(n, s) : r), !1));\n  }\n  _refinement(e) {\n    return new W({\n      schema: this,\n      typeName: _.ZodEffects,\n      effect: { type: \"refinement\", refinement: e }\n    });\n  }\n  superRefine(e) {\n    return this._refinement(e);\n  }\n  constructor(e) {\n    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this[\"~standard\"] = {\n      version: 1,\n      vendor: \"zod\",\n      validate: (r) => this[\"~validate\"](r)\n    };\n  }\n  optional() {\n    return z.create(this, this._def);\n  }\n  nullable() {\n    return re.create(this, this._def);\n  }\n  nullish() {\n    return this.nullable().optional();\n  }\n  array() {\n    return U.create(this);\n  }\n  promise() {\n    return ve.create(this, this._def);\n  }\n  or(e) {\n    return $e.create([this, e], this._def);\n  }\n  and(e) {\n    return Me.create(this, e, this._def);\n  }\n  transform(e) {\n    return new W({\n      ...b(this._def),\n      schema: this,\n      typeName: _.ZodEffects,\n      effect: { type: \"transform\", transform: e }\n    });\n  }\n  default(e) {\n    const r = typeof e == \"function\" ? e : () => e;\n    return new qe({\n      ...b(this._def),\n      innerType: this,\n      defaultValue: r,\n      typeName: _.ZodDefault\n    });\n  }\n  brand() {\n    return new Yt({\n      typeName: _.ZodBranded,\n      type: this,\n      ...b(this._def)\n    });\n  }\n  catch(e) {\n    const r = typeof e == \"function\" ? e : () => e;\n    return new ze({\n      ...b(this._def),\n      innerType: this,\n      catchValue: r,\n      typeName: _.ZodCatch\n    });\n  }\n  describe(e) {\n    const r = this.constructor;\n    return new r({\n      ...this._def,\n      description: e\n    });\n  }\n  pipe(e) {\n    return Fe.create(this, e);\n  }\n  readonly() {\n    return Be.create(this);\n  }\n  isOptional() {\n    return this.safeParse(void 0).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n}\nconst Ha = /^c[^\\s-]{8,}$/i, Ga = /^[0-9a-z]+$/, Ja = /^[0-9A-HJKMNP-TV-Z]{26}$/i, Ya = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i, Xa = /^[a-z0-9_-]{21}$/i, Qa = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/, Ka = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/, ei = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i, ti = \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\";\nlet xt;\nconst ri = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ni = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/, si = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, ai = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, ii = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, oi = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, fn = \"((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))\", ci = new RegExp(`^${fn}$`);\nfunction pn(t) {\n  let e = \"([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d\";\n  return t.precision ? e = `${e}\\\\.\\\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\\\.\\\\d+)?`), e;\n}\nfunction ui(t) {\n  return new RegExp(`^${pn(t)}$`);\n}\nfunction hn(t) {\n  let e = `${fn}T${pn(t)}`;\n  const r = [];\n  return r.push(t.local ? \"Z?\" : \"Z\"), t.offset && r.push(\"([+-]\\\\d{2}:?\\\\d{2})\"), e = `${e}(${r.join(\"|\")})`, new RegExp(`^${e}$`);\n}\nfunction li(t, e) {\n  return !!((e === \"v4\" || !e) && ri.test(t) || (e === \"v6\" || !e) && si.test(t));\n}\nfunction di(t, e) {\n  if (!Qa.test(t))\n    return !1;\n  try {\n    const [r] = t.split(\".\"), n = r.replace(/-/g, \"+\").replace(/_/g, \"/\").padEnd(r.length + (4 - r.length % 4) % 4, \"=\"), s = JSON.parse(atob(n));\n    return !(typeof s != \"object\" || s === null || !s.typ || !s.alg || e && s.alg !== e);\n  } catch {\n    return !1;\n  }\n}\nfunction fi(t, e) {\n  return !!((e === \"v4\" || !e) && ni.test(t) || (e === \"v6\" || !e) && ai.test(t));\n}\nclass Z extends w {\n  _parse(e) {\n    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== m.string) {\n      const a = this._getOrReturnCtx(e);\n      return p(a, {\n        code: f.invalid_type,\n        expected: m.string,\n        received: a.parsedType\n      }), v;\n    }\n    const n = new N();\n    let s;\n    for (const a of this._def.checks)\n      if (a.kind === \"min\")\n        e.data.length < a.value && (s = this._getOrReturnCtx(e, s), p(s, {\n          code: f.too_small,\n          minimum: a.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !1,\n          message: a.message\n        }), n.dirty());\n      else if (a.kind === \"max\")\n        e.data.length > a.value && (s = this._getOrReturnCtx(e, s), p(s, {\n          code: f.too_big,\n          maximum: a.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !1,\n          message: a.message\n        }), n.dirty());\n      else if (a.kind === \"length\") {\n        const i = e.data.length > a.value, o = e.data.length < a.value;\n        (i || o) && (s = this._getOrReturnCtx(e, s), i ? p(s, {\n          code: f.too_big,\n          maximum: a.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !0,\n          message: a.message\n        }) : o && p(s, {\n          code: f.too_small,\n          minimum: a.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !0,\n          message: a.message\n        }), n.dirty());\n      } else if (a.kind === \"email\")\n        ei.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"email\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty());\n      else if (a.kind === \"emoji\")\n        xt || (xt = new RegExp(ti, \"u\")), xt.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"emoji\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty());\n      else if (a.kind === \"uuid\")\n        Ya.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"uuid\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty());\n      else if (a.kind === \"nanoid\")\n        Xa.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"nanoid\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty());\n      else if (a.kind === \"cuid\")\n        Ha.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"cuid\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty());\n      else if (a.kind === \"cuid2\")\n        Ga.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"cuid2\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty());\n      else if (a.kind === \"ulid\")\n        Ja.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"ulid\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty());\n      else if (a.kind === \"url\")\n        try {\n          new URL(e.data);\n        } catch {\n          s = this._getOrReturnCtx(e, s), p(s, {\n            validation: \"url\",\n            code: f.invalid_string,\n            message: a.message\n          }), n.dirty();\n        }\n      else\n        a.kind === \"regex\" ? (a.regex.lastIndex = 0, a.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"regex\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty())) : a.kind === \"trim\" ? e.data = e.data.trim() : a.kind === \"includes\" ? e.data.includes(a.value, a.position) || (s = this._getOrReturnCtx(e, s), p(s, {\n          code: f.invalid_string,\n          validation: { includes: a.value, position: a.position },\n          message: a.message\n        }), n.dirty()) : a.kind === \"toLowerCase\" ? e.data = e.data.toLowerCase() : a.kind === \"toUpperCase\" ? e.data = e.data.toUpperCase() : a.kind === \"startsWith\" ? e.data.startsWith(a.value) || (s = this._getOrReturnCtx(e, s), p(s, {\n          code: f.invalid_string,\n          validation: { startsWith: a.value },\n          message: a.message\n        }), n.dirty()) : a.kind === \"endsWith\" ? e.data.endsWith(a.value) || (s = this._getOrReturnCtx(e, s), p(s, {\n          code: f.invalid_string,\n          validation: { endsWith: a.value },\n          message: a.message\n        }), n.dirty()) : a.kind === \"datetime\" ? hn(a).test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          code: f.invalid_string,\n          validation: \"datetime\",\n          message: a.message\n        }), n.dirty()) : a.kind === \"date\" ? ci.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          code: f.invalid_string,\n          validation: \"date\",\n          message: a.message\n        }), n.dirty()) : a.kind === \"time\" ? ui(a).test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          code: f.invalid_string,\n          validation: \"time\",\n          message: a.message\n        }), n.dirty()) : a.kind === \"duration\" ? Ka.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"duration\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty()) : a.kind === \"ip\" ? li(e.data, a.version) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"ip\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty()) : a.kind === \"jwt\" ? di(e.data, a.alg) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"jwt\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty()) : a.kind === \"cidr\" ? fi(e.data, a.version) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"cidr\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty()) : a.kind === \"base64\" ? ii.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"base64\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty()) : a.kind === \"base64url\" ? oi.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {\n          validation: \"base64url\",\n          code: f.invalid_string,\n          message: a.message\n        }), n.dirty()) : x.assertNever(a);\n    return { status: n.value, value: e.data };\n  }\n  _regex(e, r, n) {\n    return this.refinement((s) => e.test(s), {\n      validation: r,\n      code: f.invalid_string,\n      ...g.errToObj(n)\n    });\n  }\n  _addCheck(e) {\n    return new Z({\n      ...this._def,\n      checks: [...this._def.checks, e]\n    });\n  }\n  email(e) {\n    return this._addCheck({ kind: \"email\", ...g.errToObj(e) });\n  }\n  url(e) {\n    return this._addCheck({ kind: \"url\", ...g.errToObj(e) });\n  }\n  emoji(e) {\n    return this._addCheck({ kind: \"emoji\", ...g.errToObj(e) });\n  }\n  uuid(e) {\n    return this._addCheck({ kind: \"uuid\", ...g.errToObj(e) });\n  }\n  nanoid(e) {\n    return this._addCheck({ kind: \"nanoid\", ...g.errToObj(e) });\n  }\n  cuid(e) {\n    return this._addCheck({ kind: \"cuid\", ...g.errToObj(e) });\n  }\n  cuid2(e) {\n    return this._addCheck({ kind: \"cuid2\", ...g.errToObj(e) });\n  }\n  ulid(e) {\n    return this._addCheck({ kind: \"ulid\", ...g.errToObj(e) });\n  }\n  base64(e) {\n    return this._addCheck({ kind: \"base64\", ...g.errToObj(e) });\n  }\n  base64url(e) {\n    return this._addCheck({\n      kind: \"base64url\",\n      ...g.errToObj(e)\n    });\n  }\n  jwt(e) {\n    return this._addCheck({ kind: \"jwt\", ...g.errToObj(e) });\n  }\n  ip(e) {\n    return this._addCheck({ kind: \"ip\", ...g.errToObj(e) });\n  }\n  cidr(e) {\n    return this._addCheck({ kind: \"cidr\", ...g.errToObj(e) });\n  }\n  datetime(e) {\n    var r, n;\n    return typeof e == \"string\" ? this._addCheck({\n      kind: \"datetime\",\n      precision: null,\n      offset: !1,\n      local: !1,\n      message: e\n    }) : this._addCheck({\n      kind: \"datetime\",\n      precision: typeof e?.precision > \"u\" ? null : e?.precision,\n      offset: (r = e?.offset) !== null && r !== void 0 ? r : !1,\n      local: (n = e?.local) !== null && n !== void 0 ? n : !1,\n      ...g.errToObj(e?.message)\n    });\n  }\n  date(e) {\n    return this._addCheck({ kind: \"date\", message: e });\n  }\n  time(e) {\n    return typeof e == \"string\" ? this._addCheck({\n      kind: \"time\",\n      precision: null,\n      message: e\n    }) : this._addCheck({\n      kind: \"time\",\n      precision: typeof e?.precision > \"u\" ? null : e?.precision,\n      ...g.errToObj(e?.message)\n    });\n  }\n  duration(e) {\n    return this._addCheck({ kind: \"duration\", ...g.errToObj(e) });\n  }\n  regex(e, r) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex: e,\n      ...g.errToObj(r)\n    });\n  }\n  includes(e, r) {\n    return this._addCheck({\n      kind: \"includes\",\n      value: e,\n      position: r?.position,\n      ...g.errToObj(r?.message)\n    });\n  }\n  startsWith(e, r) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value: e,\n      ...g.errToObj(r)\n    });\n  }\n  endsWith(e, r) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value: e,\n      ...g.errToObj(r)\n    });\n  }\n  min(e, r) {\n    return this._addCheck({\n      kind: \"min\",\n      value: e,\n      ...g.errToObj(r)\n    });\n  }\n  max(e, r) {\n    return this._addCheck({\n      kind: \"max\",\n      value: e,\n      ...g.errToObj(r)\n    });\n  }\n  length(e, r) {\n    return this._addCheck({\n      kind: \"length\",\n      value: e,\n      ...g.errToObj(r)\n    });\n  }\n  /**\n   * Equivalent to `.min(1)`\n   */\n  nonempty(e) {\n    return this.min(1, g.errToObj(e));\n  }\n  trim() {\n    return new Z({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"trim\" }]\n    });\n  }\n  toLowerCase() {\n    return new Z({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toLowerCase\" }]\n    });\n  }\n  toUpperCase() {\n    return new Z({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toUpperCase\" }]\n    });\n  }\n  get isDatetime() {\n    return !!this._def.checks.find((e) => e.kind === \"datetime\");\n  }\n  get isDate() {\n    return !!this._def.checks.find((e) => e.kind === \"date\");\n  }\n  get isTime() {\n    return !!this._def.checks.find((e) => e.kind === \"time\");\n  }\n  get isDuration() {\n    return !!this._def.checks.find((e) => e.kind === \"duration\");\n  }\n  get isEmail() {\n    return !!this._def.checks.find((e) => e.kind === \"email\");\n  }\n  get isURL() {\n    return !!this._def.checks.find((e) => e.kind === \"url\");\n  }\n  get isEmoji() {\n    return !!this._def.checks.find((e) => e.kind === \"emoji\");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((e) => e.kind === \"uuid\");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find((e) => e.kind === \"nanoid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((e) => e.kind === \"cuid\");\n  }\n  get isCUID2() {\n    return !!this._def.checks.find((e) => e.kind === \"cuid2\");\n  }\n  get isULID() {\n    return !!this._def.checks.find((e) => e.kind === \"ulid\");\n  }\n  get isIP() {\n    return !!this._def.checks.find((e) => e.kind === \"ip\");\n  }\n  get isCIDR() {\n    return !!this._def.checks.find((e) => e.kind === \"cidr\");\n  }\n  get isBase64() {\n    return !!this._def.checks.find((e) => e.kind === \"base64\");\n  }\n  get isBase64url() {\n    return !!this._def.checks.find((e) => e.kind === \"base64url\");\n  }\n  get minLength() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"min\" && (e === null || r.value > e) && (e = r.value);\n    return e;\n  }\n  get maxLength() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"max\" && (e === null || r.value < e) && (e = r.value);\n    return e;\n  }\n}\nZ.create = (t) => {\n  var e;\n  return new Z({\n    checks: [],\n    typeName: _.ZodString,\n    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,\n    ...b(t)\n  });\n};\nfunction pi(t, e) {\n  const r = (t.toString().split(\".\")[1] || \"\").length, n = (e.toString().split(\".\")[1] || \"\").length, s = r > n ? r : n, a = parseInt(t.toFixed(s).replace(\".\", \"\")), i = parseInt(e.toFixed(s).replace(\".\", \"\"));\n  return a % i / Math.pow(10, s);\n}\nclass K extends w {\n  constructor() {\n    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;\n  }\n  _parse(e) {\n    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== m.number) {\n      const a = this._getOrReturnCtx(e);\n      return p(a, {\n        code: f.invalid_type,\n        expected: m.number,\n        received: a.parsedType\n      }), v;\n    }\n    let n;\n    const s = new N();\n    for (const a of this._def.checks)\n      a.kind === \"int\" ? x.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), p(n, {\n        code: f.invalid_type,\n        expected: \"integer\",\n        received: \"float\",\n        message: a.message\n      }), s.dirty()) : a.kind === \"min\" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n = this._getOrReturnCtx(e, n), p(n, {\n        code: f.too_small,\n        minimum: a.value,\n        type: \"number\",\n        inclusive: a.inclusive,\n        exact: !1,\n        message: a.message\n      }), s.dirty()) : a.kind === \"max\" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n = this._getOrReturnCtx(e, n), p(n, {\n        code: f.too_big,\n        maximum: a.value,\n        type: \"number\",\n        inclusive: a.inclusive,\n        exact: !1,\n        message: a.message\n      }), s.dirty()) : a.kind === \"multipleOf\" ? pi(e.data, a.value) !== 0 && (n = this._getOrReturnCtx(e, n), p(n, {\n        code: f.not_multiple_of,\n        multipleOf: a.value,\n        message: a.message\n      }), s.dirty()) : a.kind === \"finite\" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), p(n, {\n        code: f.not_finite,\n        message: a.message\n      }), s.dirty()) : x.assertNever(a);\n    return { status: s.value, value: e.data };\n  }\n  gte(e, r) {\n    return this.setLimit(\"min\", e, !0, g.toString(r));\n  }\n  gt(e, r) {\n    return this.setLimit(\"min\", e, !1, g.toString(r));\n  }\n  lte(e, r) {\n    return this.setLimit(\"max\", e, !0, g.toString(r));\n  }\n  lt(e, r) {\n    return this.setLimit(\"max\", e, !1, g.toString(r));\n  }\n  setLimit(e, r, n, s) {\n    return new K({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind: e,\n          value: r,\n          inclusive: n,\n          message: g.toString(s)\n        }\n      ]\n    });\n  }\n  _addCheck(e) {\n    return new K({\n      ...this._def,\n      checks: [...this._def.checks, e]\n    });\n  }\n  int(e) {\n    return this._addCheck({\n      kind: \"int\",\n      message: g.toString(e)\n    });\n  }\n  positive(e) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: !1,\n      message: g.toString(e)\n    });\n  }\n  negative(e) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: !1,\n      message: g.toString(e)\n    });\n  }\n  nonpositive(e) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: !0,\n      message: g.toString(e)\n    });\n  }\n  nonnegative(e) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: !0,\n      message: g.toString(e)\n    });\n  }\n  multipleOf(e, r) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value: e,\n      message: g.toString(r)\n    });\n  }\n  finite(e) {\n    return this._addCheck({\n      kind: \"finite\",\n      message: g.toString(e)\n    });\n  }\n  safe(e) {\n    return this._addCheck({\n      kind: \"min\",\n      inclusive: !0,\n      value: Number.MIN_SAFE_INTEGER,\n      message: g.toString(e)\n    })._addCheck({\n      kind: \"max\",\n      inclusive: !0,\n      value: Number.MAX_SAFE_INTEGER,\n      message: g.toString(e)\n    });\n  }\n  get minValue() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"min\" && (e === null || r.value > e) && (e = r.value);\n    return e;\n  }\n  get maxValue() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"max\" && (e === null || r.value < e) && (e = r.value);\n    return e;\n  }\n  get isInt() {\n    return !!this._def.checks.find((e) => e.kind === \"int\" || e.kind === \"multipleOf\" && x.isInteger(e.value));\n  }\n  get isFinite() {\n    let e = null, r = null;\n    for (const n of this._def.checks) {\n      if (n.kind === \"finite\" || n.kind === \"int\" || n.kind === \"multipleOf\")\n        return !0;\n      n.kind === \"min\" ? (r === null || n.value > r) && (r = n.value) : n.kind === \"max\" && (e === null || n.value < e) && (e = n.value);\n    }\n    return Number.isFinite(r) && Number.isFinite(e);\n  }\n}\nK.create = (t) => new K({\n  checks: [],\n  typeName: _.ZodNumber,\n  coerce: t?.coerce || !1,\n  ...b(t)\n});\nclass ee extends w {\n  constructor() {\n    super(...arguments), this.min = this.gte, this.max = this.lte;\n  }\n  _parse(e) {\n    if (this._def.coerce)\n      try {\n        e.data = BigInt(e.data);\n      } catch {\n        return this._getInvalidInput(e);\n      }\n    if (this._getType(e) !== m.bigint)\n      return this._getInvalidInput(e);\n    let n;\n    const s = new N();\n    for (const a of this._def.checks)\n      a.kind === \"min\" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n = this._getOrReturnCtx(e, n), p(n, {\n        code: f.too_small,\n        type: \"bigint\",\n        minimum: a.value,\n        inclusive: a.inclusive,\n        message: a.message\n      }), s.dirty()) : a.kind === \"max\" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n = this._getOrReturnCtx(e, n), p(n, {\n        code: f.too_big,\n        type: \"bigint\",\n        maximum: a.value,\n        inclusive: a.inclusive,\n        message: a.message\n      }), s.dirty()) : a.kind === \"multipleOf\" ? e.data % a.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), p(n, {\n        code: f.not_multiple_of,\n        multipleOf: a.value,\n        message: a.message\n      }), s.dirty()) : x.assertNever(a);\n    return { status: s.value, value: e.data };\n  }\n  _getInvalidInput(e) {\n    const r = this._getOrReturnCtx(e);\n    return p(r, {\n      code: f.invalid_type,\n      expected: m.bigint,\n      received: r.parsedType\n    }), v;\n  }\n  gte(e, r) {\n    return this.setLimit(\"min\", e, !0, g.toString(r));\n  }\n  gt(e, r) {\n    return this.setLimit(\"min\", e, !1, g.toString(r));\n  }\n  lte(e, r) {\n    return this.setLimit(\"max\", e, !0, g.toString(r));\n  }\n  lt(e, r) {\n    return this.setLimit(\"max\", e, !1, g.toString(r));\n  }\n  setLimit(e, r, n, s) {\n    return new ee({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind: e,\n          value: r,\n          inclusive: n,\n          message: g.toString(s)\n        }\n      ]\n    });\n  }\n  _addCheck(e) {\n    return new ee({\n      ...this._def,\n      checks: [...this._def.checks, e]\n    });\n  }\n  positive(e) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: !1,\n      message: g.toString(e)\n    });\n  }\n  negative(e) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: !1,\n      message: g.toString(e)\n    });\n  }\n  nonpositive(e) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: !0,\n      message: g.toString(e)\n    });\n  }\n  nonnegative(e) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: !0,\n      message: g.toString(e)\n    });\n  }\n  multipleOf(e, r) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value: e,\n      message: g.toString(r)\n    });\n  }\n  get minValue() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"min\" && (e === null || r.value > e) && (e = r.value);\n    return e;\n  }\n  get maxValue() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"max\" && (e === null || r.value < e) && (e = r.value);\n    return e;\n  }\n}\nee.create = (t) => {\n  var e;\n  return new ee({\n    checks: [],\n    typeName: _.ZodBigInt,\n    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,\n    ...b(t)\n  });\n};\nclass Ie extends w {\n  _parse(e) {\n    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== m.boolean) {\n      const n = this._getOrReturnCtx(e);\n      return p(n, {\n        code: f.invalid_type,\n        expected: m.boolean,\n        received: n.parsedType\n      }), v;\n    }\n    return I(e.data);\n  }\n}\nIe.create = (t) => new Ie({\n  typeName: _.ZodBoolean,\n  coerce: t?.coerce || !1,\n  ...b(t)\n});\nclass ce extends w {\n  _parse(e) {\n    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== m.date) {\n      const a = this._getOrReturnCtx(e);\n      return p(a, {\n        code: f.invalid_type,\n        expected: m.date,\n        received: a.parsedType\n      }), v;\n    }\n    if (isNaN(e.data.getTime())) {\n      const a = this._getOrReturnCtx(e);\n      return p(a, {\n        code: f.invalid_date\n      }), v;\n    }\n    const n = new N();\n    let s;\n    for (const a of this._def.checks)\n      a.kind === \"min\" ? e.data.getTime() < a.value && (s = this._getOrReturnCtx(e, s), p(s, {\n        code: f.too_small,\n        message: a.message,\n        inclusive: !0,\n        exact: !1,\n        minimum: a.value,\n        type: \"date\"\n      }), n.dirty()) : a.kind === \"max\" ? e.data.getTime() > a.value && (s = this._getOrReturnCtx(e, s), p(s, {\n        code: f.too_big,\n        message: a.message,\n        inclusive: !0,\n        exact: !1,\n        maximum: a.value,\n        type: \"date\"\n      }), n.dirty()) : x.assertNever(a);\n    return {\n      status: n.value,\n      value: new Date(e.data.getTime())\n    };\n  }\n  _addCheck(e) {\n    return new ce({\n      ...this._def,\n      checks: [...this._def.checks, e]\n    });\n  }\n  min(e, r) {\n    return this._addCheck({\n      kind: \"min\",\n      value: e.getTime(),\n      message: g.toString(r)\n    });\n  }\n  max(e, r) {\n    return this._addCheck({\n      kind: \"max\",\n      value: e.getTime(),\n      message: g.toString(r)\n    });\n  }\n  get minDate() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"min\" && (e === null || r.value > e) && (e = r.value);\n    return e != null ? new Date(e) : null;\n  }\n  get maxDate() {\n    let e = null;\n    for (const r of this._def.checks)\n      r.kind === \"max\" && (e === null || r.value < e) && (e = r.value);\n    return e != null ? new Date(e) : null;\n  }\n}\nce.create = (t) => new ce({\n  checks: [],\n  coerce: t?.coerce || !1,\n  typeName: _.ZodDate,\n  ...b(t)\n});\nclass Ke extends w {\n  _parse(e) {\n    if (this._getType(e) !== m.symbol) {\n      const n = this._getOrReturnCtx(e);\n      return p(n, {\n        code: f.invalid_type,\n        expected: m.symbol,\n        received: n.parsedType\n      }), v;\n    }\n    return I(e.data);\n  }\n}\nKe.create = (t) => new Ke({\n  typeName: _.ZodSymbol,\n  ...b(t)\n});\nclass je extends w {\n  _parse(e) {\n    if (this._getType(e) !== m.undefined) {\n      const n = this._getOrReturnCtx(e);\n      return p(n, {\n        code: f.invalid_type,\n        expected: m.undefined,\n        received: n.parsedType\n      }), v;\n    }\n    return I(e.data);\n  }\n}\nje.create = (t) => new je({\n  typeName: _.ZodUndefined,\n  ...b(t)\n});\nclass Le extends w {\n  _parse(e) {\n    if (this._getType(e) !== m.null) {\n      const n = this._getOrReturnCtx(e);\n      return p(n, {\n        code: f.invalid_type,\n        expected: m.null,\n        received: n.parsedType\n      }), v;\n    }\n    return I(e.data);\n  }\n}\nLe.create = (t) => new Le({\n  typeName: _.ZodNull,\n  ...b(t)\n});\nclass _e extends w {\n  constructor() {\n    super(...arguments), this._any = !0;\n  }\n  _parse(e) {\n    return I(e.data);\n  }\n}\n_e.create = (t) => new _e({\n  typeName: _.ZodAny,\n  ...b(t)\n});\nclass ie extends w {\n  constructor() {\n    super(...arguments), this._unknown = !0;\n  }\n  _parse(e) {\n    return I(e.data);\n  }\n}\nie.create = (t) => new ie({\n  typeName: _.ZodUnknown,\n  ...b(t)\n});\nclass X extends w {\n  _parse(e) {\n    const r = this._getOrReturnCtx(e);\n    return p(r, {\n      code: f.invalid_type,\n      expected: m.never,\n      received: r.parsedType\n    }), v;\n  }\n}\nX.create = (t) => new X({\n  typeName: _.ZodNever,\n  ...b(t)\n});\nclass et extends w {\n  _parse(e) {\n    if (this._getType(e) !== m.undefined) {\n      const n = this._getOrReturnCtx(e);\n      return p(n, {\n        code: f.invalid_type,\n        expected: m.void,\n        received: n.parsedType\n      }), v;\n    }\n    return I(e.data);\n  }\n}\net.create = (t) => new et({\n  typeName: _.ZodVoid,\n  ...b(t)\n});\nclass U extends w {\n  _parse(e) {\n    const { ctx: r, status: n } = this._processInputParams(e), s = this._def;\n    if (r.parsedType !== m.array)\n      return p(r, {\n        code: f.invalid_type,\n        expected: m.array,\n        received: r.parsedType\n      }), v;\n    if (s.exactLength !== null) {\n      const i = r.data.length > s.exactLength.value, o = r.data.length < s.exactLength.value;\n      (i || o) && (p(r, {\n        code: i ? f.too_big : f.too_small,\n        minimum: o ? s.exactLength.value : void 0,\n        maximum: i ? s.exactLength.value : void 0,\n        type: \"array\",\n        inclusive: !0,\n        exact: !0,\n        message: s.exactLength.message\n      }), n.dirty());\n    }\n    if (s.minLength !== null && r.data.length < s.minLength.value && (p(r, {\n      code: f.too_small,\n      minimum: s.minLength.value,\n      type: \"array\",\n      inclusive: !0,\n      exact: !1,\n      message: s.minLength.message\n    }), n.dirty()), s.maxLength !== null && r.data.length > s.maxLength.value && (p(r, {\n      code: f.too_big,\n      maximum: s.maxLength.value,\n      type: \"array\",\n      inclusive: !0,\n      exact: !1,\n      message: s.maxLength.message\n    }), n.dirty()), r.common.async)\n      return Promise.all([...r.data].map((i, o) => s.type._parseAsync(new B(r, i, r.path, o)))).then((i) => N.mergeArray(n, i));\n    const a = [...r.data].map((i, o) => s.type._parseSync(new B(r, i, r.path, o)));\n    return N.mergeArray(n, a);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(e, r) {\n    return new U({\n      ...this._def,\n      minLength: { value: e, message: g.toString(r) }\n    });\n  }\n  max(e, r) {\n    return new U({\n      ...this._def,\n      maxLength: { value: e, message: g.toString(r) }\n    });\n  }\n  length(e, r) {\n    return new U({\n      ...this._def,\n      exactLength: { value: e, message: g.toString(r) }\n    });\n  }\n  nonempty(e) {\n    return this.min(1, e);\n  }\n}\nU.create = (t, e) => new U({\n  type: t,\n  minLength: null,\n  maxLength: null,\n  exactLength: null,\n  typeName: _.ZodArray,\n  ...b(e)\n});\nfunction pe(t) {\n  if (t instanceof C) {\n    const e = {};\n    for (const r in t.shape) {\n      const n = t.shape[r];\n      e[r] = z.create(pe(n));\n    }\n    return new C({\n      ...t._def,\n      shape: () => e\n    });\n  } else\n    return t instanceof U ? new U({\n      ...t._def,\n      type: pe(t.element)\n    }) : t instanceof z ? z.create(pe(t.unwrap())) : t instanceof re ? re.create(pe(t.unwrap())) : t instanceof V ? V.create(t.items.map((e) => pe(e))) : t;\n}\nclass C extends w {\n  constructor() {\n    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;\n  }\n  _getCached() {\n    if (this._cached !== null)\n      return this._cached;\n    const e = this._def.shape(), r = x.objectKeys(e);\n    return this._cached = { shape: e, keys: r };\n  }\n  _parse(e) {\n    if (this._getType(e) !== m.object) {\n      const u = this._getOrReturnCtx(e);\n      return p(u, {\n        code: f.invalid_type,\n        expected: m.object,\n        received: u.parsedType\n      }), v;\n    }\n    const { status: n, ctx: s } = this._processInputParams(e), { shape: a, keys: i } = this._getCached(), o = [];\n    if (!(this._def.catchall instanceof X && this._def.unknownKeys === \"strip\"))\n      for (const u in s.data)\n        i.includes(u) || o.push(u);\n    const c = [];\n    for (const u of i) {\n      const d = a[u], h = s.data[u];\n      c.push({\n        key: { status: \"valid\", value: u },\n        value: d._parse(new B(s, h, s.path, u)),\n        alwaysSet: u in s.data\n      });\n    }\n    if (this._def.catchall instanceof X) {\n      const u = this._def.unknownKeys;\n      if (u === \"passthrough\")\n        for (const d of o)\n          c.push({\n            key: { status: \"valid\", value: d },\n            value: { status: \"valid\", value: s.data[d] }\n          });\n      else if (u === \"strict\")\n        o.length > 0 && (p(s, {\n          code: f.unrecognized_keys,\n          keys: o\n        }), n.dirty());\n      else if (u !== \"strip\")\n        throw new Error(\"Internal ZodObject error: invalid unknownKeys value.\");\n    } else {\n      const u = this._def.catchall;\n      for (const d of o) {\n        const h = s.data[d];\n        c.push({\n          key: { status: \"valid\", value: d },\n          value: u._parse(\n            new B(s, h, s.path, d)\n            //, ctx.child(key), value, getParsedType(value)\n          ),\n          alwaysSet: d in s.data\n        });\n      }\n    }\n    return s.common.async ? Promise.resolve().then(async () => {\n      const u = [];\n      for (const d of c) {\n        const h = await d.key, y = await d.value;\n        u.push({\n          key: h,\n          value: y,\n          alwaysSet: d.alwaysSet\n        });\n      }\n      return u;\n    }).then((u) => N.mergeObjectSync(n, u)) : N.mergeObjectSync(n, c);\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(e) {\n    return g.errToObj, new C({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...e !== void 0 ? {\n        errorMap: (r, n) => {\n          var s, a, i, o;\n          const c = (i = (a = (s = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(s, r, n).message) !== null && i !== void 0 ? i : n.defaultError;\n          return r.code === \"unrecognized_keys\" ? {\n            message: (o = g.errToObj(e).message) !== null && o !== void 0 ? o : c\n          } : {\n            message: c\n          };\n        }\n      } : {}\n    });\n  }\n  strip() {\n    return new C({\n      ...this._def,\n      unknownKeys: \"strip\"\n    });\n  }\n  passthrough() {\n    return new C({\n      ...this._def,\n      unknownKeys: \"passthrough\"\n    });\n  }\n  // const AugmentFactory =\n  //   <Def extends ZodObjectDef>(def: Def) =>\n  //   <Augmentation extends ZodRawShape>(\n  //     augmentation: Augmentation\n  //   ): ZodObject<\n  //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n  //     Def[\"unknownKeys\"],\n  //     Def[\"catchall\"]\n  //   > => {\n  //     return new ZodObject({\n  //       ...def,\n  //       shape: () => ({\n  //         ...def.shape(),\n  //         ...augmentation,\n  //       }),\n  //     }) as any;\n  //   };\n  extend(e) {\n    return new C({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...e\n      })\n    });\n  }\n  /**\n   * Prior to zod@1.0.12 there was a bug in the\n   * inferred type of merged objects. Please\n   * upgrade if you are experiencing issues.\n   */\n  merge(e) {\n    return new C({\n      unknownKeys: e._def.unknownKeys,\n      catchall: e._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...e._def.shape()\n      }),\n      typeName: _.ZodObject\n    });\n  }\n  // merge<\n  //   Incoming extends AnyZodObject,\n  //   Augmentation extends Incoming[\"shape\"],\n  //   NewOutput extends {\n  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_output\"]\n  //       : k extends keyof Output\n  //       ? Output[k]\n  //       : never;\n  //   },\n  //   NewInput extends {\n  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_input\"]\n  //       : k extends keyof Input\n  //       ? Input[k]\n  //       : never;\n  //   }\n  // >(\n  //   merging: Incoming\n  // ): ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"],\n  //   NewOutput,\n  //   NewInput\n  // > {\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  setKey(e, r) {\n    return this.augment({ [e]: r });\n  }\n  // merge<Incoming extends AnyZodObject>(\n  //   merging: Incoming\n  // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n  // ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"]\n  // > {\n  //   // const mergedShape = objectUtil.mergeShapes(\n  //   //   this._def.shape(),\n  //   //   merging._def.shape()\n  //   // );\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  catchall(e) {\n    return new C({\n      ...this._def,\n      catchall: e\n    });\n  }\n  pick(e) {\n    const r = {};\n    return x.objectKeys(e).forEach((n) => {\n      e[n] && this.shape[n] && (r[n] = this.shape[n]);\n    }), new C({\n      ...this._def,\n      shape: () => r\n    });\n  }\n  omit(e) {\n    const r = {};\n    return x.objectKeys(this.shape).forEach((n) => {\n      e[n] || (r[n] = this.shape[n]);\n    }), new C({\n      ...this._def,\n      shape: () => r\n    });\n  }\n  /**\n   * @deprecated\n   */\n  deepPartial() {\n    return pe(this);\n  }\n  partial(e) {\n    const r = {};\n    return x.objectKeys(this.shape).forEach((n) => {\n      const s = this.shape[n];\n      e && !e[n] ? r[n] = s : r[n] = s.optional();\n    }), new C({\n      ...this._def,\n      shape: () => r\n    });\n  }\n  required(e) {\n    const r = {};\n    return x.objectKeys(this.shape).forEach((n) => {\n      if (e && !e[n])\n        r[n] = this.shape[n];\n      else {\n        let a = this.shape[n];\n        for (; a instanceof z; )\n          a = a._def.innerType;\n        r[n] = a;\n      }\n    }), new C({\n      ...this._def,\n      shape: () => r\n    });\n  }\n  keyof() {\n    return mn(x.objectKeys(this.shape));\n  }\n}\nC.create = (t, e) => new C({\n  shape: () => t,\n  unknownKeys: \"strip\",\n  catchall: X.create(),\n  typeName: _.ZodObject,\n  ...b(e)\n});\nC.strictCreate = (t, e) => new C({\n  shape: () => t,\n  unknownKeys: \"strict\",\n  catchall: X.create(),\n  typeName: _.ZodObject,\n  ...b(e)\n});\nC.lazycreate = (t, e) => new C({\n  shape: t,\n  unknownKeys: \"strip\",\n  catchall: X.create(),\n  typeName: _.ZodObject,\n  ...b(e)\n});\nclass $e extends w {\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e), n = this._def.options;\n    function s(a) {\n      for (const o of a)\n        if (o.result.status === \"valid\")\n          return o.result;\n      for (const o of a)\n        if (o.result.status === \"dirty\")\n          return r.common.issues.push(...o.ctx.common.issues), o.result;\n      const i = a.map((o) => new L(o.ctx.common.issues));\n      return p(r, {\n        code: f.invalid_union,\n        unionErrors: i\n      }), v;\n    }\n    if (r.common.async)\n      return Promise.all(n.map(async (a) => {\n        const i = {\n          ...r,\n          common: {\n            ...r.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await a._parseAsync({\n            data: r.data,\n            path: r.path,\n            parent: i\n          }),\n          ctx: i\n        };\n      })).then(s);\n    {\n      let a;\n      const i = [];\n      for (const c of n) {\n        const u = {\n          ...r,\n          common: {\n            ...r.common,\n            issues: []\n          },\n          parent: null\n        }, d = c._parseSync({\n          data: r.data,\n          path: r.path,\n          parent: u\n        });\n        if (d.status === \"valid\")\n          return d;\n        d.status === \"dirty\" && !a && (a = { result: d, ctx: u }), u.common.issues.length && i.push(u.common.issues);\n      }\n      if (a)\n        return r.common.issues.push(...a.ctx.common.issues), a.result;\n      const o = i.map((c) => new L(c));\n      return p(r, {\n        code: f.invalid_union,\n        unionErrors: o\n      }), v;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n}\n$e.create = (t, e) => new $e({\n  options: t,\n  typeName: _.ZodUnion,\n  ...b(e)\n});\nconst J = (t) => t instanceof Ze ? J(t.schema) : t instanceof W ? J(t.innerType()) : t instanceof Ue ? [t.value] : t instanceof te ? t.options : t instanceof We ? x.objectValues(t.enum) : t instanceof qe ? J(t._def.innerType) : t instanceof je ? [void 0] : t instanceof Le ? [null] : t instanceof z ? [void 0, ...J(t.unwrap())] : t instanceof re ? [null, ...J(t.unwrap())] : t instanceof Yt || t instanceof Be ? J(t.unwrap()) : t instanceof ze ? J(t._def.innerType) : [];\nclass ft extends w {\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e);\n    if (r.parsedType !== m.object)\n      return p(r, {\n        code: f.invalid_type,\n        expected: m.object,\n        received: r.parsedType\n      }), v;\n    const n = this.discriminator, s = r.data[n], a = this.optionsMap.get(s);\n    return a ? r.common.async ? a._parseAsync({\n      data: r.data,\n      path: r.path,\n      parent: r\n    }) : a._parseSync({\n      data: r.data,\n      path: r.path,\n      parent: r\n    }) : (p(r, {\n      code: f.invalid_union_discriminator,\n      options: Array.from(this.optionsMap.keys()),\n      path: [n]\n    }), v);\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get options() {\n    return this._def.options;\n  }\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n  /**\n   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n   * have a different value for each object in the union.\n   * @param discriminator the name of the discriminator property\n   * @param types an array of object schemas\n   * @param params\n   */\n  static create(e, r, n) {\n    const s = /* @__PURE__ */ new Map();\n    for (const a of r) {\n      const i = J(a.shape[e]);\n      if (!i.length)\n        throw new Error(`A discriminator value for key \\`${e}\\` could not be extracted from all schema options`);\n      for (const o of i) {\n        if (s.has(o))\n          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);\n        s.set(o, a);\n      }\n    }\n    return new ft({\n      typeName: _.ZodDiscriminatedUnion,\n      discriminator: e,\n      options: r,\n      optionsMap: s,\n      ...b(n)\n    });\n  }\n}\nfunction It(t, e) {\n  const r = Y(t), n = Y(e);\n  if (t === e)\n    return { valid: !0, data: t };\n  if (r === m.object && n === m.object) {\n    const s = x.objectKeys(e), a = x.objectKeys(t).filter((o) => s.indexOf(o) !== -1), i = { ...t, ...e };\n    for (const o of a) {\n      const c = It(t[o], e[o]);\n      if (!c.valid)\n        return { valid: !1 };\n      i[o] = c.data;\n    }\n    return { valid: !0, data: i };\n  } else if (r === m.array && n === m.array) {\n    if (t.length !== e.length)\n      return { valid: !1 };\n    const s = [];\n    for (let a = 0; a < t.length; a++) {\n      const i = t[a], o = e[a], c = It(i, o);\n      if (!c.valid)\n        return { valid: !1 };\n      s.push(c.data);\n    }\n    return { valid: !0, data: s };\n  } else\n    return r === m.date && n === m.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };\n}\nclass Me extends w {\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e), s = (a, i) => {\n      if (At(a) || At(i))\n        return v;\n      const o = It(a.value, i.value);\n      return o.valid ? ((Nt(a) || Nt(i)) && r.dirty(), { status: r.value, value: o.data }) : (p(n, {\n        code: f.invalid_intersection_types\n      }), v);\n    };\n    return n.common.async ? Promise.all([\n      this._def.left._parseAsync({\n        data: n.data,\n        path: n.path,\n        parent: n\n      }),\n      this._def.right._parseAsync({\n        data: n.data,\n        path: n.path,\n        parent: n\n      })\n    ]).then(([a, i]) => s(a, i)) : s(this._def.left._parseSync({\n      data: n.data,\n      path: n.path,\n      parent: n\n    }), this._def.right._parseSync({\n      data: n.data,\n      path: n.path,\n      parent: n\n    }));\n  }\n}\nMe.create = (t, e, r) => new Me({\n  left: t,\n  right: e,\n  typeName: _.ZodIntersection,\n  ...b(r)\n});\nclass V extends w {\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e);\n    if (n.parsedType !== m.array)\n      return p(n, {\n        code: f.invalid_type,\n        expected: m.array,\n        received: n.parsedType\n      }), v;\n    if (n.data.length < this._def.items.length)\n      return p(n, {\n        code: f.too_small,\n        minimum: this._def.items.length,\n        inclusive: !0,\n        exact: !1,\n        type: \"array\"\n      }), v;\n    !this._def.rest && n.data.length > this._def.items.length && (p(n, {\n      code: f.too_big,\n      maximum: this._def.items.length,\n      inclusive: !0,\n      exact: !1,\n      type: \"array\"\n    }), r.dirty());\n    const a = [...n.data].map((i, o) => {\n      const c = this._def.items[o] || this._def.rest;\n      return c ? c._parse(new B(n, i, n.path, o)) : null;\n    }).filter((i) => !!i);\n    return n.common.async ? Promise.all(a).then((i) => N.mergeArray(r, i)) : N.mergeArray(r, a);\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(e) {\n    return new V({\n      ...this._def,\n      rest: e\n    });\n  }\n}\nV.create = (t, e) => {\n  if (!Array.isArray(t))\n    throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n  return new V({\n    items: t,\n    typeName: _.ZodTuple,\n    rest: null,\n    ...b(e)\n  });\n};\nclass De extends w {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e);\n    if (n.parsedType !== m.object)\n      return p(n, {\n        code: f.invalid_type,\n        expected: m.object,\n        received: n.parsedType\n      }), v;\n    const s = [], a = this._def.keyType, i = this._def.valueType;\n    for (const o in n.data)\n      s.push({\n        key: a._parse(new B(n, o, n.path, o)),\n        value: i._parse(new B(n, n.data[o], n.path, o)),\n        alwaysSet: o in n.data\n      });\n    return n.common.async ? N.mergeObjectAsync(r, s) : N.mergeObjectSync(r, s);\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(e, r, n) {\n    return r instanceof w ? new De({\n      keyType: e,\n      valueType: r,\n      typeName: _.ZodRecord,\n      ...b(n)\n    }) : new De({\n      keyType: Z.create(),\n      valueType: e,\n      typeName: _.ZodRecord,\n      ...b(r)\n    });\n  }\n}\nclass tt extends w {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e);\n    if (n.parsedType !== m.map)\n      return p(n, {\n        code: f.invalid_type,\n        expected: m.map,\n        received: n.parsedType\n      }), v;\n    const s = this._def.keyType, a = this._def.valueType, i = [...n.data.entries()].map(([o, c], u) => ({\n      key: s._parse(new B(n, o, n.path, [u, \"key\"])),\n      value: a._parse(new B(n, c, n.path, [u, \"value\"]))\n    }));\n    if (n.common.async) {\n      const o = /* @__PURE__ */ new Map();\n      return Promise.resolve().then(async () => {\n        for (const c of i) {\n          const u = await c.key, d = await c.value;\n          if (u.status === \"aborted\" || d.status === \"aborted\")\n            return v;\n          (u.status === \"dirty\" || d.status === \"dirty\") && r.dirty(), o.set(u.value, d.value);\n        }\n        return { status: r.value, value: o };\n      });\n    } else {\n      const o = /* @__PURE__ */ new Map();\n      for (const c of i) {\n        const u = c.key, d = c.value;\n        if (u.status === \"aborted\" || d.status === \"aborted\")\n          return v;\n        (u.status === \"dirty\" || d.status === \"dirty\") && r.dirty(), o.set(u.value, d.value);\n      }\n      return { status: r.value, value: o };\n    }\n  }\n}\ntt.create = (t, e, r) => new tt({\n  valueType: e,\n  keyType: t,\n  typeName: _.ZodMap,\n  ...b(r)\n});\nclass ue extends w {\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e);\n    if (n.parsedType !== m.set)\n      return p(n, {\n        code: f.invalid_type,\n        expected: m.set,\n        received: n.parsedType\n      }), v;\n    const s = this._def;\n    s.minSize !== null && n.data.size < s.minSize.value && (p(n, {\n      code: f.too_small,\n      minimum: s.minSize.value,\n      type: \"set\",\n      inclusive: !0,\n      exact: !1,\n      message: s.minSize.message\n    }), r.dirty()), s.maxSize !== null && n.data.size > s.maxSize.value && (p(n, {\n      code: f.too_big,\n      maximum: s.maxSize.value,\n      type: \"set\",\n      inclusive: !0,\n      exact: !1,\n      message: s.maxSize.message\n    }), r.dirty());\n    const a = this._def.valueType;\n    function i(c) {\n      const u = /* @__PURE__ */ new Set();\n      for (const d of c) {\n        if (d.status === \"aborted\")\n          return v;\n        d.status === \"dirty\" && r.dirty(), u.add(d.value);\n      }\n      return { status: r.value, value: u };\n    }\n    const o = [...n.data.values()].map((c, u) => a._parse(new B(n, c, n.path, u)));\n    return n.common.async ? Promise.all(o).then((c) => i(c)) : i(o);\n  }\n  min(e, r) {\n    return new ue({\n      ...this._def,\n      minSize: { value: e, message: g.toString(r) }\n    });\n  }\n  max(e, r) {\n    return new ue({\n      ...this._def,\n      maxSize: { value: e, message: g.toString(r) }\n    });\n  }\n  size(e, r) {\n    return this.min(e, r).max(e, r);\n  }\n  nonempty(e) {\n    return this.min(1, e);\n  }\n}\nue.create = (t, e) => new ue({\n  valueType: t,\n  minSize: null,\n  maxSize: null,\n  typeName: _.ZodSet,\n  ...b(e)\n});\nclass me extends w {\n  constructor() {\n    super(...arguments), this.validate = this.implement;\n  }\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e);\n    if (r.parsedType !== m.function)\n      return p(r, {\n        code: f.invalid_type,\n        expected: m.function,\n        received: r.parsedType\n      }), v;\n    function n(o, c) {\n      return Xe({\n        data: o,\n        path: r.path,\n        errorMaps: [\n          r.common.contextualErrorMap,\n          r.schemaErrorMap,\n          Ye(),\n          ge\n        ].filter((u) => !!u),\n        issueData: {\n          code: f.invalid_arguments,\n          argumentsError: c\n        }\n      });\n    }\n    function s(o, c) {\n      return Xe({\n        data: o,\n        path: r.path,\n        errorMaps: [\n          r.common.contextualErrorMap,\n          r.schemaErrorMap,\n          Ye(),\n          ge\n        ].filter((u) => !!u),\n        issueData: {\n          code: f.invalid_return_type,\n          returnTypeError: c\n        }\n      });\n    }\n    const a = { errorMap: r.common.contextualErrorMap }, i = r.data;\n    if (this._def.returns instanceof ve) {\n      const o = this;\n      return I(async function(...c) {\n        const u = new L([]), d = await o._def.args.parseAsync(c, a).catch((k) => {\n          throw u.addIssue(n(c, k)), u;\n        }), h = await Reflect.apply(i, this, d);\n        return await o._def.returns._def.type.parseAsync(h, a).catch((k) => {\n          throw u.addIssue(s(h, k)), u;\n        });\n      });\n    } else {\n      const o = this;\n      return I(function(...c) {\n        const u = o._def.args.safeParse(c, a);\n        if (!u.success)\n          throw new L([n(c, u.error)]);\n        const d = Reflect.apply(i, this, u.data), h = o._def.returns.safeParse(d, a);\n        if (!h.success)\n          throw new L([s(d, h.error)]);\n        return h.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...e) {\n    return new me({\n      ...this._def,\n      args: V.create(e).rest(ie.create())\n    });\n  }\n  returns(e) {\n    return new me({\n      ...this._def,\n      returns: e\n    });\n  }\n  implement(e) {\n    return this.parse(e);\n  }\n  strictImplement(e) {\n    return this.parse(e);\n  }\n  static create(e, r, n) {\n    return new me({\n      args: e || V.create([]).rest(ie.create()),\n      returns: r || ie.create(),\n      typeName: _.ZodFunction,\n      ...b(n)\n    });\n  }\n}\nclass Ze extends w {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e);\n    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });\n  }\n}\nZe.create = (t, e) => new Ze({\n  getter: t,\n  typeName: _.ZodLazy,\n  ...b(e)\n});\nclass Ue extends w {\n  _parse(e) {\n    if (e.data !== this._def.value) {\n      const r = this._getOrReturnCtx(e);\n      return p(r, {\n        received: r.data,\n        code: f.invalid_literal,\n        expected: this._def.value\n      }), v;\n    }\n    return { status: \"valid\", value: e.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n}\nUe.create = (t, e) => new Ue({\n  value: t,\n  typeName: _.ZodLiteral,\n  ...b(e)\n});\nfunction mn(t, e) {\n  return new te({\n    values: t,\n    typeName: _.ZodEnum,\n    ...b(e)\n  });\n}\nclass te extends w {\n  constructor() {\n    super(...arguments), Re.set(this, void 0);\n  }\n  _parse(e) {\n    if (typeof e.data != \"string\") {\n      const r = this._getOrReturnCtx(e), n = this._def.values;\n      return p(r, {\n        expected: x.joinValues(n),\n        received: r.parsedType,\n        code: f.invalid_type\n      }), v;\n    }\n    if (Qe(this, Re, \"f\") || dn(this, Re, new Set(this._def.values), \"f\"), !Qe(this, Re, \"f\").has(e.data)) {\n      const r = this._getOrReturnCtx(e), n = this._def.values;\n      return p(r, {\n        received: r.data,\n        code: f.invalid_enum_value,\n        options: n\n      }), v;\n    }\n    return I(e.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const e = {};\n    for (const r of this._def.values)\n      e[r] = r;\n    return e;\n  }\n  get Values() {\n    const e = {};\n    for (const r of this._def.values)\n      e[r] = r;\n    return e;\n  }\n  get Enum() {\n    const e = {};\n    for (const r of this._def.values)\n      e[r] = r;\n    return e;\n  }\n  extract(e, r = this._def) {\n    return te.create(e, {\n      ...this._def,\n      ...r\n    });\n  }\n  exclude(e, r = this._def) {\n    return te.create(this.options.filter((n) => !e.includes(n)), {\n      ...this._def,\n      ...r\n    });\n  }\n}\nRe = /* @__PURE__ */ new WeakMap();\nte.create = mn;\nclass We extends w {\n  constructor() {\n    super(...arguments), Oe.set(this, void 0);\n  }\n  _parse(e) {\n    const r = x.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);\n    if (n.parsedType !== m.string && n.parsedType !== m.number) {\n      const s = x.objectValues(r);\n      return p(n, {\n        expected: x.joinValues(s),\n        received: n.parsedType,\n        code: f.invalid_type\n      }), v;\n    }\n    if (Qe(this, Oe, \"f\") || dn(this, Oe, new Set(x.getValidEnumValues(this._def.values)), \"f\"), !Qe(this, Oe, \"f\").has(e.data)) {\n      const s = x.objectValues(r);\n      return p(n, {\n        received: n.data,\n        code: f.invalid_enum_value,\n        options: s\n      }), v;\n    }\n    return I(e.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n}\nOe = /* @__PURE__ */ new WeakMap();\nWe.create = (t, e) => new We({\n  values: t,\n  typeName: _.ZodNativeEnum,\n  ...b(e)\n});\nclass ve extends w {\n  unwrap() {\n    return this._def.type;\n  }\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e);\n    if (r.parsedType !== m.promise && r.common.async === !1)\n      return p(r, {\n        code: f.invalid_type,\n        expected: m.promise,\n        received: r.parsedType\n      }), v;\n    const n = r.parsedType === m.promise ? r.data : Promise.resolve(r.data);\n    return I(n.then((s) => this._def.type.parseAsync(s, {\n      path: r.path,\n      errorMap: r.common.contextualErrorMap\n    })));\n  }\n}\nve.create = (t, e) => new ve({\n  type: t,\n  typeName: _.ZodPromise,\n  ...b(e)\n});\nclass W extends w {\n  innerType() {\n    return this._def.schema;\n  }\n  sourceType() {\n    return this._def.schema._def.typeName === _.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n  }\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e), s = this._def.effect || null, a = {\n      addIssue: (i) => {\n        p(n, i), i.fatal ? r.abort() : r.dirty();\n      },\n      get path() {\n        return n.path;\n      }\n    };\n    if (a.addIssue = a.addIssue.bind(a), s.type === \"preprocess\") {\n      const i = s.transform(n.data, a);\n      if (n.common.async)\n        return Promise.resolve(i).then(async (o) => {\n          if (r.value === \"aborted\")\n            return v;\n          const c = await this._def.schema._parseAsync({\n            data: o,\n            path: n.path,\n            parent: n\n          });\n          return c.status === \"aborted\" ? v : c.status === \"dirty\" || r.value === \"dirty\" ? he(c.value) : c;\n        });\n      {\n        if (r.value === \"aborted\")\n          return v;\n        const o = this._def.schema._parseSync({\n          data: i,\n          path: n.path,\n          parent: n\n        });\n        return o.status === \"aborted\" ? v : o.status === \"dirty\" || r.value === \"dirty\" ? he(o.value) : o;\n      }\n    }\n    if (s.type === \"refinement\") {\n      const i = (o) => {\n        const c = s.refinement(o, a);\n        if (n.common.async)\n          return Promise.resolve(c);\n        if (c instanceof Promise)\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        return o;\n      };\n      if (n.common.async === !1) {\n        const o = this._def.schema._parseSync({\n          data: n.data,\n          path: n.path,\n          parent: n\n        });\n        return o.status === \"aborted\" ? v : (o.status === \"dirty\" && r.dirty(), i(o.value), { status: r.value, value: o.value });\n      } else\n        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === \"aborted\" ? v : (o.status === \"dirty\" && r.dirty(), i(o.value).then(() => ({ status: r.value, value: o.value }))));\n    }\n    if (s.type === \"transform\")\n      if (n.common.async === !1) {\n        const i = this._def.schema._parseSync({\n          data: n.data,\n          path: n.path,\n          parent: n\n        });\n        if (!oe(i))\n          return i;\n        const o = s.transform(i.value, a);\n        if (o instanceof Promise)\n          throw new Error(\"Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.\");\n        return { status: r.value, value: o };\n      } else\n        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((i) => oe(i) ? Promise.resolve(s.transform(i.value, a)).then((o) => ({ status: r.value, value: o })) : i);\n    x.assertNever(s);\n  }\n}\nW.create = (t, e, r) => new W({\n  schema: t,\n  typeName: _.ZodEffects,\n  effect: e,\n  ...b(r)\n});\nW.createWithPreprocess = (t, e, r) => new W({\n  schema: e,\n  effect: { type: \"preprocess\", transform: t },\n  typeName: _.ZodEffects,\n  ...b(r)\n});\nclass z extends w {\n  _parse(e) {\n    return this._getType(e) === m.undefined ? I(void 0) : this._def.innerType._parse(e);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nz.create = (t, e) => new z({\n  innerType: t,\n  typeName: _.ZodOptional,\n  ...b(e)\n});\nclass re extends w {\n  _parse(e) {\n    return this._getType(e) === m.null ? I(null) : this._def.innerType._parse(e);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nre.create = (t, e) => new re({\n  innerType: t,\n  typeName: _.ZodNullable,\n  ...b(e)\n});\nclass qe extends w {\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e);\n    let n = r.data;\n    return r.parsedType === m.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({\n      data: n,\n      path: r.path,\n      parent: r\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n}\nqe.create = (t, e) => new qe({\n  innerType: t,\n  typeName: _.ZodDefault,\n  defaultValue: typeof e.default == \"function\" ? e.default : () => e.default,\n  ...b(e)\n});\nclass ze extends w {\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e), n = {\n      ...r,\n      common: {\n        ...r.common,\n        issues: []\n      }\n    }, s = this._def.innerType._parse({\n      data: n.data,\n      path: n.path,\n      parent: {\n        ...n\n      }\n    });\n    return Ne(s) ? s.then((a) => ({\n      status: \"valid\",\n      value: a.status === \"valid\" ? a.value : this._def.catchValue({\n        get error() {\n          return new L(n.common.issues);\n        },\n        input: n.data\n      })\n    })) : {\n      status: \"valid\",\n      value: s.status === \"valid\" ? s.value : this._def.catchValue({\n        get error() {\n          return new L(n.common.issues);\n        },\n        input: n.data\n      })\n    };\n  }\n  removeCatch() {\n    return this._def.innerType;\n  }\n}\nze.create = (t, e) => new ze({\n  innerType: t,\n  typeName: _.ZodCatch,\n  catchValue: typeof e.catch == \"function\" ? e.catch : () => e.catch,\n  ...b(e)\n});\nclass rt extends w {\n  _parse(e) {\n    if (this._getType(e) !== m.nan) {\n      const n = this._getOrReturnCtx(e);\n      return p(n, {\n        code: f.invalid_type,\n        expected: m.nan,\n        received: n.parsedType\n      }), v;\n    }\n    return { status: \"valid\", value: e.data };\n  }\n}\nrt.create = (t) => new rt({\n  typeName: _.ZodNaN,\n  ...b(t)\n});\nconst hi = Symbol(\"zod_brand\");\nclass Yt extends w {\n  _parse(e) {\n    const { ctx: r } = this._processInputParams(e), n = r.data;\n    return this._def.type._parse({\n      data: n,\n      path: r.path,\n      parent: r\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n}\nclass Fe extends w {\n  _parse(e) {\n    const { status: r, ctx: n } = this._processInputParams(e);\n    if (n.common.async)\n      return (async () => {\n        const a = await this._def.in._parseAsync({\n          data: n.data,\n          path: n.path,\n          parent: n\n        });\n        return a.status === \"aborted\" ? v : a.status === \"dirty\" ? (r.dirty(), he(a.value)) : this._def.out._parseAsync({\n          data: a.value,\n          path: n.path,\n          parent: n\n        });\n      })();\n    {\n      const s = this._def.in._parseSync({\n        data: n.data,\n        path: n.path,\n        parent: n\n      });\n      return s.status === \"aborted\" ? v : s.status === \"dirty\" ? (r.dirty(), {\n        status: \"dirty\",\n        value: s.value\n      }) : this._def.out._parseSync({\n        data: s.value,\n        path: n.path,\n        parent: n\n      });\n    }\n  }\n  static create(e, r) {\n    return new Fe({\n      in: e,\n      out: r,\n      typeName: _.ZodPipeline\n    });\n  }\n}\nclass Be extends w {\n  _parse(e) {\n    const r = this._def.innerType._parse(e), n = (s) => (oe(s) && (s.value = Object.freeze(s.value)), s);\n    return Ne(r) ? r.then((s) => n(s)) : n(r);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nBe.create = (t, e) => new Be({\n  innerType: t,\n  typeName: _.ZodReadonly,\n  ...b(e)\n});\nfunction yn(t, e = {}, r) {\n  return t ? _e.create().superRefine((n, s) => {\n    var a, i;\n    if (!t(n)) {\n      const o = typeof e == \"function\" ? e(n) : typeof e == \"string\" ? { message: e } : e, c = (i = (a = o.fatal) !== null && a !== void 0 ? a : r) !== null && i !== void 0 ? i : !0, u = typeof o == \"string\" ? { message: o } : o;\n      s.addIssue({ code: \"custom\", ...u, fatal: c });\n    }\n  }) : _e.create();\n}\nconst mi = {\n  object: C.lazycreate\n};\nvar _;\n(function(t) {\n  t.ZodString = \"ZodString\", t.ZodNumber = \"ZodNumber\", t.ZodNaN = \"ZodNaN\", t.ZodBigInt = \"ZodBigInt\", t.ZodBoolean = \"ZodBoolean\", t.ZodDate = \"ZodDate\", t.ZodSymbol = \"ZodSymbol\", t.ZodUndefined = \"ZodUndefined\", t.ZodNull = \"ZodNull\", t.ZodAny = \"ZodAny\", t.ZodUnknown = \"ZodUnknown\", t.ZodNever = \"ZodNever\", t.ZodVoid = \"ZodVoid\", t.ZodArray = \"ZodArray\", t.ZodObject = \"ZodObject\", t.ZodUnion = \"ZodUnion\", t.ZodDiscriminatedUnion = \"ZodDiscriminatedUnion\", t.ZodIntersection = \"ZodIntersection\", t.ZodTuple = \"ZodTuple\", t.ZodRecord = \"ZodRecord\", t.ZodMap = \"ZodMap\", t.ZodSet = \"ZodSet\", t.ZodFunction = \"ZodFunction\", t.ZodLazy = \"ZodLazy\", t.ZodLiteral = \"ZodLiteral\", t.ZodEnum = \"ZodEnum\", t.ZodEffects = \"ZodEffects\", t.ZodNativeEnum = \"ZodNativeEnum\", t.ZodOptional = \"ZodOptional\", t.ZodNullable = \"ZodNullable\", t.ZodDefault = \"ZodDefault\", t.ZodCatch = \"ZodCatch\", t.ZodPromise = \"ZodPromise\", t.ZodBranded = \"ZodBranded\", t.ZodPipeline = \"ZodPipeline\", t.ZodReadonly = \"ZodReadonly\";\n})(_ || (_ = {}));\nconst yi = (t, e = {\n  message: `Input not instance of ${t.name}`\n}) => yn((r) => r instanceof t, e), gn = Z.create, _n = K.create, gi = rt.create, _i = ee.create, vn = Ie.create, vi = ce.create, bi = Ke.create, wi = je.create, xi = Le.create, ki = _e.create, Ti = ie.create, Ei = X.create, Ci = et.create, Ri = U.create, Oi = C.create, Si = C.strictCreate, Pi = $e.create, Ai = ft.create, Ni = Me.create, Ii = V.create, ji = De.create, Li = tt.create, $i = ue.create, Mi = me.create, Di = Ze.create, Zi = Ue.create, Ui = te.create, Wi = We.create, qi = ve.create, vr = W.create, zi = z.create, Bi = re.create, Vi = W.createWithPreprocess, Fi = Fe.create, Hi = () => gn().optional(), Gi = () => _n().optional(), Ji = () => vn().optional(), Yi = {\n  string: (t) => Z.create({ ...t, coerce: !0 }),\n  number: (t) => K.create({ ...t, coerce: !0 }),\n  boolean: (t) => Ie.create({\n    ...t,\n    coerce: !0\n  }),\n  bigint: (t) => ee.create({ ...t, coerce: !0 }),\n  date: (t) => ce.create({ ...t, coerce: !0 })\n}, Xi = v;\nvar l = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  defaultErrorMap: ge,\n  setErrorMap: Va,\n  getErrorMap: Ye,\n  makeIssue: Xe,\n  EMPTY_PATH: Fa,\n  addIssueToContext: p,\n  ParseStatus: N,\n  INVALID: v,\n  DIRTY: he,\n  OK: I,\n  isAborted: At,\n  isDirty: Nt,\n  isValid: oe,\n  isAsync: Ne,\n  get util() {\n    return x;\n  },\n  get objectUtil() {\n    return Pt;\n  },\n  ZodParsedType: m,\n  getParsedType: Y,\n  ZodType: w,\n  datetimeRegex: hn,\n  ZodString: Z,\n  ZodNumber: K,\n  ZodBigInt: ee,\n  ZodBoolean: Ie,\n  ZodDate: ce,\n  ZodSymbol: Ke,\n  ZodUndefined: je,\n  ZodNull: Le,\n  ZodAny: _e,\n  ZodUnknown: ie,\n  ZodNever: X,\n  ZodVoid: et,\n  ZodArray: U,\n  ZodObject: C,\n  ZodUnion: $e,\n  ZodDiscriminatedUnion: ft,\n  ZodIntersection: Me,\n  ZodTuple: V,\n  ZodRecord: De,\n  ZodMap: tt,\n  ZodSet: ue,\n  ZodFunction: me,\n  ZodLazy: Ze,\n  ZodLiteral: Ue,\n  ZodEnum: te,\n  ZodNativeEnum: We,\n  ZodPromise: ve,\n  ZodEffects: W,\n  ZodTransformer: W,\n  ZodOptional: z,\n  ZodNullable: re,\n  ZodDefault: qe,\n  ZodCatch: ze,\n  ZodNaN: rt,\n  BRAND: hi,\n  ZodBranded: Yt,\n  ZodPipeline: Fe,\n  ZodReadonly: Be,\n  custom: yn,\n  Schema: w,\n  ZodSchema: w,\n  late: mi,\n  get ZodFirstPartyTypeKind() {\n    return _;\n  },\n  coerce: Yi,\n  any: ki,\n  array: Ri,\n  bigint: _i,\n  boolean: vn,\n  date: vi,\n  discriminatedUnion: Ai,\n  effect: vr,\n  enum: Ui,\n  function: Mi,\n  instanceof: yi,\n  intersection: Ni,\n  lazy: Di,\n  literal: Zi,\n  map: Li,\n  nan: gi,\n  nativeEnum: Wi,\n  never: Ei,\n  null: xi,\n  nullable: Bi,\n  number: _n,\n  object: Oi,\n  oboolean: Ji,\n  onumber: Gi,\n  optional: zi,\n  ostring: Hi,\n  pipeline: Fi,\n  preprocess: Vi,\n  promise: qi,\n  record: ji,\n  set: $i,\n  strictObject: Si,\n  string: gn,\n  symbol: bi,\n  transformer: vr,\n  tuple: Ii,\n  undefined: wi,\n  union: Pi,\n  unknown: Ti,\n  void: Ci,\n  NEVER: Xi,\n  ZodIssueCode: f,\n  quotelessJson: Ba,\n  ZodError: L\n});\nconst bn = /^0x[0-9a-f]+$/i, wn = /^\\d+$/, Qi = l.string().min(1, \"The short string cannot be empty\").max(31, \"The short string cannot exceed 31 characters\").refine(\n  (t) => !bn.test(t),\n  \"The shortString should not be a hex string\"\n).refine(\n  (t) => !wn.test(t),\n  \"The shortString should not be an integer string\"\n), M = l.union([\n  l.string().regex(\n    bn,\n    \"Only hex, integers and bigint are supported in calldata\"\n  ),\n  l.string().regex(\n    wn,\n    \"Only hex, integers and bigint are supported in calldata\"\n  ),\n  Qi,\n  l.number().int(\"Only hex, integers and bigint are supported in calldata\"),\n  l.bigint()\n]), Ve = l.object({\n  contractAddress: l.string(),\n  entrypoint: l.string(),\n  calldata: l.array(M.or(l.array(M))).optional()\n}), jt = l.array(Ve).nonempty(), xn = l.object({\n  types: l.record(\n    l.array(\n      l.union([\n        l.object({\n          name: l.string(),\n          type: l.literal(\"merkletree\"),\n          contains: l.string()\n        }),\n        l.object({\n          name: l.string(),\n          type: l.literal(\"enum\"),\n          contains: l.string()\n        }),\n        l.object({\n          name: l.string(),\n          type: l.string()\n        })\n      ])\n    )\n  ),\n  primaryType: l.string(),\n  domain: l.record(l.unknown()),\n  message: l.record(l.unknown()).or(l.object({}))\n}), Lt = l.object({\n  type: l.literal(\"ERC20\"),\n  options: l.object({\n    address: l.string(),\n    symbol: l.string().optional(),\n    decimals: l.number().optional(),\n    image: l.string().optional(),\n    name: l.string().optional()\n  })\n}), Ki = l.union([\n  l.object({\n    id: l.string(),\n    chain_id: l.string(),\n    chain_name: l.string(),\n    rpc_urls: l.array(l.string()).optional(),\n    native_currency: Lt.optional(),\n    block_explorer_url: l.array(l.string()).optional()\n  }),\n  l.object({\n    id: l.string(),\n    chainId: l.string(),\n    chainName: l.string(),\n    rpcUrls: l.array(l.string()).optional(),\n    nativeCurrency: Lt.optional(),\n    blockExplorerUrl: l.array(l.string()).optional()\n  }).transform((t) => ({\n    id: t.id,\n    chain_id: t.chainId,\n    chain_name: t.chainName,\n    rpc_urls: t.rpcUrls,\n    native_currency: t.nativeCurrency,\n    block_explorer_url: t.blockExplorerUrl\n  }))\n]), kt = {\n  enable: l.tuple([\n    l.object({\n      starknetVersion: l.union([l.literal(\"v3\"), l.literal(\"v4\"), l.literal(\"v5\")]).optional()\n    }).optional()\n  ]).or(l.tuple([])),\n  addStarknetChain: l.tuple([Ki]),\n  switchStarknetChain: l.tuple([\n    l.object({\n      chainId: l.string()\n    })\n  ]),\n  watchAsset: l.tuple([Lt]),\n  requestAccounts: l.tuple([\n    l.object({\n      silent_mode: l.boolean().optional()\n    })\n  ]),\n  execute: l.tuple([\n    jt.or(Ve),\n    l.object({\n      nonce: M.optional(),\n      maxFee: M.optional(),\n      version: M.optional()\n    }).optional()\n  ]),\n  signMessage: l.tuple([xn])\n};\nl.tuple([\n  jt.or(Ve),\n  l.object({\n    nonce: M.optional(),\n    maxFee: M.optional(),\n    version: M.optional()\n  }).optional()\n]).or(\n  l.tuple([\n    jt.or(Ve),\n    l.array(l.any()).optional(),\n    l.object({\n      nonce: M.optional(),\n      maxFee: M.optional(),\n      version: M.optional()\n    }).optional()\n  ])\n);\nconst kn = l.object({\n  contract_address: l.string(),\n  entry_point: l.string(),\n  calldata: l.array(M).optional()\n}).transform(({ contract_address: t, entry_point: e, calldata: r }) => ({\n  contractAddress: t,\n  entrypoint: e,\n  calldata: r || []\n})), eo = l.array(kn).nonempty(), to = {\n  ZERO: 0,\n  ONE: 1\n}, ro = l.object({\n  address: l.string(),\n  class_hash: l.string(),\n  salt: l.string(),\n  calldata: l.array(l.string()),\n  sigdata: l.array(l.string()).optional(),\n  //version: z.literal([0, 1]),\n  version: l.nativeEnum(to)\n  // allow only 0 | 1, workaround since zod doesn't support literals as numbers\n}), no = l.object({\n  callbackData: l.string().optional(),\n  approvalRequests: l.array(\n    l.object({\n      tokenAddress: l.string(),\n      amount: l.string(),\n      spender: l.string()\n    })\n  ),\n  sessionTypedData: xn\n}), so = l.object({\n  account: l.string().array().optional(),\n  chainId: l.string().optional(),\n  signature: l.string().array().optional(),\n  approvalTransactionHash: l.string().optional(),\n  deploymentPayload: l.any().optional(),\n  approvalRequestsCalls: l.array(Ve).optional(),\n  errorCode: l.enum([\n    \"USER_REJECTED\",\n    \"ACCOUNT_NOT_DEPLOYED\",\n    \"NOT_ENOUGH_BALANCE\",\n    \"NOT_ENOUGH_BALANCE_DEPLOYMENT\",\n    \"GENERIC_ERROR\"\n  ]).optional()\n}), O = Ps.create({\n  isServer: !1,\n  allowOutsideOfServer: !0\n});\nlet $t = Tr, Mt = \"\", Tn = \"\";\nconst Dt = ({\n  width: t = 775,\n  height: e = 385,\n  origin: r,\n  location: n,\n  atLeftBottom: s = !1\n}) => {\n  const a = window?.outerWidth ?? window?.innerWidth ?? window?.screen.width ?? 0, i = window?.outerHeight ?? window?.innerHeight ?? window?.screen.height ?? 0, o = window?.screenLeft ?? window?.screenX ?? 0, c = window?.screenTop ?? window?.screenY ?? 0, u = s ? 0 : o + a / 2 - t / 2, d = s ? window.screen.availHeight + 10 : c + i / 2 - e / 2;\n  $t = r ?? $t, Mt = n ?? Mt, Tn = `width=${t},height=${e},top=${d},left=${u},toolbar=no,menubar=no,scrollbars=no,location=no,status=no,popup=1`;\n};\nO.router({\n  authorize: O.procedure.output(l.boolean()).mutation(async () => !0),\n  connect: O.procedure.mutation(async () => \"\"),\n  connectWebwallet: O.procedure.input(\n    l.object({\n      theme: l.enum([\"light\", \"dark\", \"auto\"]).optional()\n    })\n  ).output(\n    l.object({\n      account: l.string().array().optional(),\n      chainId: l.string().optional()\n    })\n  ).mutation(async () => ({})),\n  connectWebwalletSSO: O.procedure.input(\n    l.object({ token: l.string(), authorizedPartyId: l.string().optional() })\n  ).output(\n    l.object({\n      account: l.string().array().optional(),\n      chainId: l.string().optional()\n    })\n  ).mutation(async () => ({})),\n  connectAndSignSession: O.procedure.input(no).output(so).mutation(async () => ({})),\n  enable: O.procedure.output(l.string()).mutation(async () => \"\"),\n  execute: O.procedure.input(kt.execute).output(l.string()).mutation(async () => \"\"),\n  signMessage: O.procedure.input(kt.signMessage).output(l.string().array()).mutation(async () => []),\n  getLoginStatus: O.procedure.output(\n    l.object({\n      isLoggedIn: l.boolean(),\n      hasSession: l.boolean().optional(),\n      isPreauthorized: l.boolean().optional()\n    })\n  ).mutation(async () => ({\n    isLoggedIn: !0\n  })),\n  // RPC Messages\n  requestAccounts: O.procedure.input(l.object({ silent_mode: l.boolean().optional() })).output(l.string().array()).mutation(async () => []),\n  requestChainId: O.procedure.output(l.string()).mutation(async () => \"\"),\n  signTypedData: O.procedure.input(kt.signMessage).output(l.string().array()).mutation(async () => []),\n  getPermissions: O.procedure.output(l.array(l.enum([_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.P.ACCOUNTS]))).mutation(async () => [_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.P.ACCOUNTS]),\n  addInvokeTransaction: O.procedure.input(kn.or(eo)).output(l.string()).mutation(async (t) => \"\"),\n  addStarknetChain: O.procedure.mutation((t) => {\n    throw Error(\"not implemented\");\n  }),\n  switchStarknetChain: O.procedure.mutation((t) => {\n    throw Error(\"not implemented\");\n  }),\n  watchAsset: O.procedure.mutation((t) => {\n    throw Error(\"not implemented\");\n  }),\n  updateModal: O.procedure.subscription(async () => {\n  }),\n  deploymentData: O.procedure.output(ro).mutation(async () => ({\n    address: \"\",\n    calldata: [],\n    version: 0,\n    class_hash: \"\",\n    salt: \"\"\n  }))\n});\nconst Tt = ({\n  iframe: t\n}) => ms({\n  links: [\n    ls({\n      enabled: (e) =>  true && typeof window < \"u\" ||  true && e.direction === \"down\" && e.result instanceof Error\n    }),\n    Xn({\n      condition(e) {\n        if (!t && e.type === \"subscription\")\n          throw new Error(\n            \"subscription is not supported without an iframe window\"\n          );\n        return !!t;\n      },\n      true: Rt.windowLink({\n        window,\n        postWindow: t,\n        postOrigin: \"*\"\n      }),\n      false: Rt.popupLink({\n        listenWindow: window,\n        createPopup: () => {\n          let e = null;\n          const r = document.createElement(\"button\");\n          if (r.style.display = \"none\", r.addEventListener(\"click\", () => {\n            e = window.open(\n              `${$t}${Mt}`,\n              \"popup\",\n              Tn\n            );\n          }), r.click(), (async () => {\n            for (; !e; )\n              await new Promise((n) => setTimeout(n, 100));\n          })(), !e)\n            throw new Error(\"Could not open popup\");\n          return e;\n        },\n        postOrigin: \"*\"\n      })\n    })\n  ]\n}), Ge = [], ao = (t, e) => ({\n  ...t,\n  getLoginStatus: () => e.getLoginStatus.mutate(),\n  connectWebwallet: (n = {}) => {\n    const { theme: s } = n;\n    return e.connectWebwallet.mutate({\n      theme: s\n    });\n  },\n  connectAndSignSession: (n) => e.connectAndSignSession.mutate(n),\n  connectWebwalletSSO: (n, s) => e.connectWebwalletSSO.mutate({ token: n, authorizedPartyId: s }),\n  async request(n) {\n    switch (n.type) {\n      case \"wallet_requestAccounts\":\n        return e.requestAccounts.mutate(n.params);\n      case \"wallet_signTypedData\": {\n        const s = n.params, a = s?.primaryType === \"Session\" && s?.domain.name === \"SessionAccount.session\";\n        Dt({\n          width: Wn,\n          height: qn,\n          location: a ? \"/signSessionKeys\" : \"/signMessage\"\n        });\n        const i = Array.isArray(n.params) ? n.params : [n.params];\n        return e.signTypedData.mutate(i);\n      }\n      case \"wallet_getPermissions\":\n        return e.getPermissions.mutate();\n      case \"wallet_addInvokeTransaction\": {\n        const s = n.params.calls;\n        return Dt({\n          width: Zn,\n          height: Un,\n          location: \"/review\"\n        }), { transaction_hash: await e.addInvokeTransaction.mutate(s) };\n      }\n      case \"wallet_requestChainId\":\n        return await e.requestChainId.mutate();\n      case \"wallet_addStarknetChain\":\n        return e.addStarknetChain.mutate(n.params);\n      case \"wallet_switchStarknetChain\":\n        return e.switchStarknetChain.mutate(n.params);\n      case \"wallet_watchAsset\":\n        return e.watchAsset.mutate();\n      case \"wallet_deploymentData\":\n        return e.deploymentData.mutate();\n      default:\n        throw new Error(\"not implemented\");\n    }\n  },\n  on: (n, s) => {\n    if (n === \"accountsChanged\")\n      Ge.push({\n        type: n,\n        handler: s\n      });\n    else if (n === \"networkChanged\")\n      Ge.push({\n        type: n,\n        handler: s\n      });\n    else\n      throw new Error(`Unknwown event: ${n}`);\n  },\n  off: (n, s) => {\n    if (n !== \"accountsChanged\" && n !== \"networkChanged\")\n      throw new Error(`Unknwown event: ${n}`);\n    const a = Ge.findIndex(\n      (i) => i.type === n && i.handler === s\n    );\n    a >= 0 && Ge.splice(a, 1);\n  }\n}), io = (t) => {\n  t.style.display = \"none\", t.style.borderRadius = \"40px\", t.style.inset = \"0\", t.style.position = \"fixed\", t.style.top = \"50%\", t.style.left = \"50%\", t.style.transform = \"translate(-50%, -50%)\", t.style.backgroundColor = \"transparent\", t.style.zIndex = \"999999\", t.style.height = `${Bn}px`, t.style.width = `${zn}px`;\n}, oo = (t, e) => {\n  t.style.display = \"block\", e.style.display = \"block\";\n}, co = (t, e) => {\n  t.style.display = \"none\", e.style.display = \"none\";\n}, uo = (t, e, r) => {\n  t.style.width = `${e}px`, t.style.height = `${r}px`;\n}, br = \"argent-webwallet-iframe\", lo = async (t, e) => {\n  const r = \"argent-webwallet-backdrop\", n = new URL(t);\n  n.pathname = \"/iframes/comms\", t = n.toString();\n  const s = document.createElement(\"iframe\");\n  s.src = t, s.loading = \"eager\", s.sandbox.add(\n    \"allow-scripts\",\n    \"allow-same-origin\",\n    \"allow-forms\",\n    \"allow-top-navigation\",\n    \"allow-popups\"\n  ), s.allow = \"clipboard-write\", s.id = br, s.setAttribute(\"allowtransparency\", \"true\"), s.setAttribute(\"transparent\", \"true\"), io(s), s.style.display = e ? \"block\" : \"none\";\n  const a = document.createElement(\"div\");\n  a.id = r, a.style.position = \"fixed\", a.style.inset = \"0\", a.style.backgroundColor = \"rgba(0,0,0,0.5)\", a.style.zIndex = \"999998\", a.style.width = \"100dvw\", a.style.height = \"100dvh\", a.style.backdropFilter = \"blur(4px)\";\n  const i = document.getElementById(br);\n  return i && (i.remove(), document.getElementById(r)?.remove()), window.document.body.appendChild(s), await new Promise((o, c) => {\n    const u = setTimeout(\n      () => c(new Error(\"Timeout while loading an iframe\")),\n      2e4\n    );\n    s.addEventListener(\"load\", async () => {\n      clearTimeout(u), o();\n    });\n  }), window.document.body.appendChild(a), { iframe: s, backdrop: a };\n}, Et = async (t, e, r) => {\n  const n = typeof window < \"u\" ? window : void 0;\n  if (!n)\n    throw new Error(\"window is not defined\");\n  const s = ao(\n    {\n      host: n.location.origin,\n      id: \"argentWebWallet\",\n      icon: \"https://www.argent.xyz/favicon.ico\",\n      name: \"Argent Web Wallet\",\n      version: \"1.0.0\"\n    },\n    e\n  );\n  if (r) {\n    const { iframe: a, backdrop: i } = r;\n    e.updateModal.subscribe(void 0, {\n      onData(o) {\n        switch (o.action) {\n          case \"show\":\n            oo(a, i);\n            break;\n          case \"hide\":\n            co(a, i);\n            break;\n          case \"updateSize\":\n            uo(a, o.width, o.height);\n            break;\n        }\n      }\n    });\n  }\n  return s;\n}, wr = \"allowed-dapps\", fo = async (t) => {\n  const e = t === starknet__WEBPACK_IMPORTED_MODULE_0__.constants.NetworkName.SN_MAIN ? jn : In;\n  try {\n    const n = await (await caches.open(wr)).match(e);\n    if (n) {\n      const u = parseInt(\n        n.headers.get(\"X-Cache-Timestamp\") ?? \"0\",\n        10\n      );\n      if (((/* @__PURE__ */ new Date()).getTime() - u) / (1e3 * 60 * 60) < 24)\n        return n.json();\n    }\n    const s = await fetch(e), a = new Headers(s.headers);\n    a.set(\"X-Cache-Timestamp\", (/* @__PURE__ */ new Date()).getTime().toString());\n    const i = await s.json(), o = new Response(JSON.stringify(i), {\n      status: s.status,\n      statusText: s.statusText,\n      headers: a\n    });\n    return await (await caches.open(wr)).put(e, o), i;\n  } catch (r) {\n    throw new Error(r);\n  }\n}, po = async (t) => new Promise((e) => {\n  if (!t)\n    return e(!1);\n  try {\n    navigator.webkitTemporaryStorage.queryUsageAndQuota(\n      (n, s) => {\n        e(\n          Math.round(s / (1024 * 1024)) < Math.round(\n            (performance?.memory?.jsHeapSizeLimit ?? 1073741824) / (1024 * 1024)\n          ) * 2\n        );\n      },\n      () => e(!1)\n    );\n  } catch {\n    e(!1);\n  }\n}), ho = async (t) => {\n  const { userAgent: e } = navigator, r = !!(navigator.vendor && navigator.vendor.indexOf(\"Google\") === 0 && navigator.brave === void 0 && !e.match(/Edg/) && !e.match(/OPR/)), n = await po(r);\n  if (!r || n) {\n    const i = Tt({});\n    return await Et(\n      t,\n      i,\n      void 0\n    );\n  }\n  const s = Dn(t), { allowedDapps: a } = await fo(s);\n  if (a.includes(window.location.hostname)) {\n    const i = \"argent-webwallet-backdrop\", o = \"argent-webwallet-iframe\", c = document.getElementById(i), u = document.getElementById(o);\n    u && u && c && (u.remove(), c.remove());\n    const { iframe: d, backdrop: h } = await lo(t, !1), y = Tt({\n      iframe: d.contentWindow ?? void 0\n    });\n    return await Et(\n      t,\n      y,\n      { iframe: d, backdrop: h }\n    );\n  } else {\n    const i = Tt({});\n    return await Et(\n      t,\n      i,\n      void 0\n    );\n  }\n}, En = \"webwallet_logout\";\nlet D = null, ae = null;\nclass bo extends _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.C {\n  constructor(r = {}) {\n    super();\n    Te(this, \"_wallet\", null);\n    Te(this, \"_options\");\n    this._options = r;\n  }\n  available() {\n    return !0;\n  }\n  async ready() {\n    if (this._wallet || await this.ensureWallet(), this._wallet)\n      try {\n        return (await this._wallet.request({\n          type: \"wallet_getPermissions\"\n        })).includes(_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.P.ACCOUNTS);\n      } catch {\n        return !1;\n      }\n    else\n      return this._wallet = null, ae = null, !1;\n  }\n  get id() {\n    return this._wallet = D, this._wallet?.id || \"argentWebWallet\";\n  }\n  get name() {\n    return this._wallet = D, this._wallet?.name || \"Argent Web Wallet\";\n  }\n  get icon() {\n    return {\n      light: rr,\n      dark: rr\n    };\n  }\n  get wallet() {\n    if (!this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.a();\n    return this._wallet;\n  }\n  get title() {\n    return \"Email\";\n  }\n  get subtitle() {\n    return \"Powered by Argent\";\n  }\n  async connectAndSignSession({\n    callbackData: r,\n    approvalRequests: n,\n    sessionTypedData: s\n  }) {\n    if (this._wallet || await this.ensureWallet(), !this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.b();\n    try {\n      return await this._wallet.connectAndSignSession({\n        callbackData: r,\n        approvalRequests: n,\n        sessionTypedData: s,\n        theme: this._options.theme\n      });\n    } catch (a) {\n      if (a instanceof Error && (a.constructor.name === \"TRPCClientError\" || a.name === \"TRPCClientError\")) {\n        const i = a, o = i.shape.data.webwalletErrorMessage || i.message, c = i.shape.data.webwalletErrorCode || i.shape.message;\n        throw new Ln(o, c);\n      }\n      throw new Error(a instanceof Error ? a.message : String(a));\n    }\n  }\n  async connect(r = {}) {\n    if (this._wallet || await this.ensureWallet(), !this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.b();\n    try {\n      let n, s;\n      if (this._options.ssoToken) {\n        const i = await this._wallet.connectWebwalletSSO(\n          this._options.ssoToken,\n          this._options.authorizedPartyId\n        );\n        n = i.account, s = i.chainId;\n      } else {\n        const i = await this._wallet.connectWebwallet({\n          theme: this._options.theme\n        });\n        n = i.account, s = i.chainId;\n      }\n      if (!n || !s)\n        return {};\n      const a = (0,_getStarknetChainId_7c4b3163_js__WEBPACK_IMPORTED_MODULE_2__.g)(s);\n      return ae = n[0], {\n        account: n[0],\n        chainId: BigInt(a)\n      };\n    } catch {\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.U();\n    }\n  }\n  async request(r) {\n    if (this._wallet || await this.ensureWallet(), !this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.a();\n    try {\n      return await this._wallet.request(r);\n    } catch (n) {\n      if (n instanceof Error && (n.constructor.name === \"TRPCClientError\" || n.name === \"TRPCClientError\")) {\n        const s = n, a = s.shape.data.webwalletErrorMessage || s.message, i = s.shape.data.webwalletErrorCode || s.shape.message;\n        throw i === \"USER_LOGGED_OUT\" && (D = null, ae = null, this._wallet = null, document.dispatchEvent(new Event(En))), new $n(a, i);\n      }\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.U();\n    }\n  }\n  async disconnect() {\n    if (!this.available() && !this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.b();\n    D = null, ae = null, this._wallet = D, (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.r)();\n  }\n  async account(r) {\n    if (this._wallet = D, !this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.a();\n    if (!ae)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.a();\n    return new starknet__WEBPACK_IMPORTED_MODULE_0__.WalletAccount(r, this._wallet, void 0, ae);\n  }\n  async chainId() {\n    if (!this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.a();\n    const r = await this._wallet.request({\n      type: \"wallet_requestChainId\"\n    }), n = (0,_getStarknetChainId_7c4b3163_js__WEBPACK_IMPORTED_MODULE_2__.g)(r);\n    return BigInt(n);\n  }\n  async initEventListener(r) {\n    if (this._wallet = D, !this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.a();\n    this._wallet.on(\"accountsChanged\", r);\n  }\n  async removeEventListener(r) {\n    if (this._wallet = D, !this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.a();\n    this._wallet.off(\"accountsChanged\", r), D = null, ae = null, this._wallet = null;\n  }\n  async ensureWallet() {\n    const r = this._options.url || Tr;\n    Dt({\n      origin: r,\n      location: \"/interstitialLogin\"\n    }), D = await ho(r) ?? null, this._wallet = D;\n  }\n}\nconst wo = (t) => {\n  document.addEventListener(En, () => {\n    t();\n  });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9pbmRleC04ZWRiZDM2MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDZ0U7QUFDcUQ7QUFDMUQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtDQUFFO0FBQ1o7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0ZBQW9GLGtCQUFrQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVMsU0FBUztBQUM3QiwyQkFBMkIsNkRBQUU7QUFDN0IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZEQUFFO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FB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R0FBRztBQUNILENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsWUFBWSxvQkFBb0IsaUNBQWlDLG9CQUFvQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxxQkFBcUI7QUFDckIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2Q0FBNkMsbUJBQW1CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEVBQUU7QUFDN0Q7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFFO0FBQ2xCO0FBQ0E7QUFDQSxLQUFLLE9BQU8sa0VBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBUUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdGFya25ldGtpdEAyLjEwLjRfYnVmZmVydXRpbEA0LjAuOV9zdGFya25ldEA2LjI0LjFfZW5jb2RpbmdAMC4xLjEzX190eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDYuMC41X3pvZEAzLjI1LjUwL25vZGVfbW9kdWxlcy9zdGFya25ldGtpdC9kaXN0L2luZGV4LThlZGJkMzYxLmpzPzE0NzgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIE9uID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIFNuID0gKHQsIGUsIHIpID0+IGUgaW4gdCA/IE9uKHQsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHIgfSkgOiB0W2VdID0gcjtcbnZhciBUZSA9ICh0LCBlLCByKSA9PiAoU24odCwgdHlwZW9mIGUgIT0gXCJzeW1ib2xcIiA/IGUgKyBcIlwiIDogZSwgciksIHIpO1xuaW1wb3J0IHsgY29uc3RhbnRzIGFzIHhyLCBXYWxsZXRBY2NvdW50IGFzIFBuIH0gZnJvbSBcInN0YXJrbmV0XCI7XG5pbXBvcnQgeyBnIGFzIGtyLCBjIGFzIEhlLCBQIGFzIEN0LCBDIGFzIEFuLCBhIGFzIHNlLCBiIGFzIGh0LCBVIGFzIGVyLCByIGFzIE5uIH0gZnJvbSBcIi4vbGFzdENvbm5lY3RlZC1lOTM1MTkxMi5qc1wiO1xuaW1wb3J0IHsgZyBhcyB0ciB9IGZyb20gXCIuL2dldFN0YXJrbmV0Q2hhaW5JZC03YzRiMzE2My5qc1wiO1xuY29uc3QgVHIgPSBcImh0dHBzOi8vd2ViLmFyZ2VudC54eXpcIiwgcnIgPSBgPHN2Z1xuICAgIHdpZHRoPVwiMzJcIlxuICAgIGhlaWdodD1cIjI4XCJcbiAgICB2aWV3Qm94PVwiMCAwIDE4IDE0XCJcbiAgICBmaWxsPVwibm9uZVwiXG4gICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gID5cbiAgICA8cGF0aFxuICAgICAgZmlsbC1ydWxlPVwiZXZlbm9kZFwiXG4gICAgICBjbGlwLXJ1bGU9XCJldmVub2RkXCJcbiAgICAgIGQ9XCJNMS41IDAuNDM3NUMwLjk4MjIzMyAwLjQzNzUgMC41NjI1IDAuODU3MjMzIDAuNTYyNSAxLjM3NVYxMkMwLjU2MjUgMTIuNDE0NCAwLjcyNzEyIDEyLjgxMTggMS4wMjAxNSAxMy4xMDQ5QzEuMzEzMTcgMTMuMzk3OSAxLjcxMDYgMTMuNTYyNSAyLjEyNSAxMy41NjI1SDE1Ljg3NUMxNi4yODk0IDEzLjU2MjUgMTYuNjg2OCAxMy4zOTc5IDE2Ljk3OTkgMTMuMTA0OUMxNy4yNzI5IDEyLjgxMTggMTcuNDM3NSAxMi40MTQ0IDE3LjQzNzUgMTJWMS4zNzVDMTcuNDM3NSAwLjg1NzIzMyAxNy4wMTc4IDAuNDM3NSAxNi41IDAuNDM3NUgxLjVaTTIuNDM3NSAzLjUwNjE2VjExLjY4NzVIMTUuNTYyNVYzLjUwNjE2TDkuNjMzNDkgOC45NDEwOEM5LjI3NTA3IDkuMjY5NjQgOC43MjQ5MyA5LjI2OTY0IDguMzY2NTEgOC45NDEwOEwyLjQzNzUgMy41MDYxNlpNMTQuMDg5OSAyLjMxMjVIMy45MTAxM0w5IDYuOTc4MjJMMTQuMDg5OSAyLjMxMjVaXCJcbiAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgIC8+XG4gIDwvc3ZnPmAsIEluID0gXCJodHRwczovL3N0YXRpYy5oeWRyb2dlbi5hcmdlbnQ0Ny5uZXQvd2Vid2FsbGV0L2lmcmFtZV93aGl0ZWxpc3RfdGVzdG5ldC5qc29uXCIsIGpuID0gXCJodHRwczovL3N0YXRpYy5hcmdlbnQubmV0L3dlYndhbGxldC9pZnJhbWVfd2hpdGVsaXN0X21haW5uZXQuanNvblwiO1xuY2xhc3MgTG4gZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHIsIG4pIHtcbiAgICBzdXBlcihyKTtcbiAgICBUZSh0aGlzLCBcImNvZGVcIik7XG4gICAgdGhpcy5uYW1lID0gXCJDb25uZWN0QW5kU2lnblNlc3Npb25FcnJvclwiLCB0aGlzLmNvZGUgPSBuO1xuICB9XG59XG5jbGFzcyAkbiBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Iociwgbikge1xuICAgIHN1cGVyKHIpO1xuICAgIFRlKHRoaXMsIFwiY29kZVwiKTtcbiAgICB0aGlzLm5hbWUgPSBcIldlYndhbGxldEVycm9yXCIsIHRoaXMuY29kZSA9IG47XG4gIH1cbn1cbmNvbnN0IFEgPSB4ci5OZXR3b3JrTmFtZSwgTW4gPSBRLlNOX1NFUE9MSUE7XG5mdW5jdGlvbiBEbih0KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBvcmlnaW46IGUgfSA9IG5ldyBVUkwodCk7XG4gICAgaWYgKGUuaW5jbHVkZXMoXCJsb2NhbGhvc3RcIikgfHwgZS5pbmNsdWRlcyhcIjEyNy4wLjAuMVwiKSlcbiAgICAgIHJldHVybiBNbjtcbiAgICBpZiAoZS5pbmNsdWRlcyhcImh5ZHJvZ2VuXCIpIHx8IGUuaW5jbHVkZXMoXCJzZXBvbGlhLXdlYi5zdGFnaW5nXCIpKVxuICAgICAgcmV0dXJuIFEuU05fU0VQT0xJQTtcbiAgICBpZiAoZS5pbmNsdWRlcyhcInN0YWdpbmdcIikpXG4gICAgICByZXR1cm4gUS5TTl9NQUlOO1xuICAgIGlmIChlLmluY2x1ZGVzKFwiZGV2XCIpIHx8IGUuaW5jbHVkZXMoXCJzZXBvbGlhLXdlYi5hcmdlbnQueHl6XCIpKVxuICAgICAgcmV0dXJuIFEuU05fU0VQT0xJQTtcbiAgICBpZiAoZS5pbmNsdWRlcyhcImFyZ2VudC54eXpcIikpXG4gICAgICByZXR1cm4gUS5TTl9NQUlOO1xuICB9IGNhdGNoIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIkNvdWxkIG5vdCBkZXRlcm1pbmUgbmV0d29yayBmcm9tIHRhcmdldCBVUkwsIGRlZmF1bHRpbmcgdG8gbWFpbm5ldC1hbHBoYVwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gUS5TTl9NQUlOO1xufVxuY29uc3QgWm4gPSAzODUsIFVuID0gNzc1LCBXbiA9IDM4NSwgcW4gPSA0NDAsIHpuID0gNDIwLCBCbiA9IDQzODtcbmZ1bmN0aW9uIFZuKHQpIHtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBGbih0KSB7XG4gIHJldHVybiB0Lmxlbmd0aCA9PT0gMCA/IFZuIDogdC5sZW5ndGggPT09IDEgPyB0WzBdIDogZnVuY3Rpb24ocikge1xuICAgIHJldHVybiB0LnJlZHVjZSgobiwgcykgPT4gcyhuKSwgcik7XG4gIH07XG59XG5mdW5jdGlvbiBIbih0KSB7XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgIT09IG51bGwgJiYgXCJzdWJzY3JpYmVcIiBpbiB0O1xufVxuZnVuY3Rpb24gbnQodCkge1xuICBjb25zdCBlID0ge1xuICAgIHN1YnNjcmliZShyKSB7XG4gICAgICBsZXQgbiA9IG51bGwsIHMgPSAhMSwgYSA9ICExLCBpID0gITE7XG4gICAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgICAgIGkgPSAhMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYSB8fCAoYSA9ICEwLCB0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIgPyBuKCkgOiBuICYmIG4udW5zdWJzY3JpYmUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbiA9IHQoe1xuICAgICAgICBuZXh0KGMpIHtcbiAgICAgICAgICBzIHx8IHIubmV4dD8uKGMpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcihjKSB7XG4gICAgICAgICAgcyB8fCAocyA9ICEwLCByLmVycm9yPy4oYyksIG8oKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICAgIHMgfHwgKHMgPSAhMCwgci5jb21wbGV0ZT8uKCksIG8oKSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBpICYmIG8oKSwge1xuICAgICAgICB1bnN1YnNjcmliZTogb1xuICAgICAgfTtcbiAgICB9LFxuICAgIHBpcGUoLi4ucikge1xuICAgICAgcmV0dXJuIEZuKHIpKGUpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBFcih0KSB7XG4gIHJldHVybiAoZSkgPT4ge1xuICAgIGxldCByID0gMCwgbiA9IG51bGw7XG4gICAgY29uc3QgcyA9IFtdO1xuICAgIGZ1bmN0aW9uIGEoKSB7XG4gICAgICBuIHx8IChuID0gZS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0KG8pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgcylcbiAgICAgICAgICAgIGMubmV4dD8uKG8pO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcihvKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBjIG9mIHMpXG4gICAgICAgICAgICBjLmVycm9yPy4obyk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICAgIGZvciAoY29uc3QgbyBvZiBzKVxuICAgICAgICAgICAgby5jb21wbGV0ZT8uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgIGlmIChyID09PSAwICYmIG4pIHtcbiAgICAgICAgY29uc3QgbyA9IG47XG4gICAgICAgIG4gPSBudWxsLCBvLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWJzY3JpYmUobykge1xuICAgICAgICByZXR1cm4gcisrLCBzLnB1c2gobyksIGEoKSwge1xuICAgICAgICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgci0tLCBpKCk7XG4gICAgICAgICAgICBjb25zdCBjID0gcy5maW5kSW5kZXgoKHUpID0+IHUgPT09IG8pO1xuICAgICAgICAgICAgYyA+IC0xICYmIHMuc3BsaWNlKGMsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gR24odCkge1xuICByZXR1cm4gKGUpID0+ICh7XG4gICAgc3Vic2NyaWJlKHIpIHtcbiAgICAgIGxldCBuID0gMDtcbiAgICAgIHJldHVybiBlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQoYSkge1xuICAgICAgICAgIHIubmV4dD8uKHQoYSwgbisrKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yKGEpIHtcbiAgICAgICAgICByLmVycm9yPy4oYSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICAgIHIuY29tcGxldGU/LigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gQ3IodCkge1xuICByZXR1cm4gKGUpID0+ICh7XG4gICAgc3Vic2NyaWJlKHIpIHtcbiAgICAgIHJldHVybiBlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQobikge1xuICAgICAgICAgIHQubmV4dD8uKG4pLCByLm5leHQ/LihuKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3Iobikge1xuICAgICAgICAgIHQuZXJyb3I/LihuKSwgci5lcnJvcj8uKG4pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgICB0LmNvbXBsZXRlPy4oKSwgci5jb21wbGV0ZT8uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5sZXQgSm4gPSBjbGFzcyBSciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLm5hbWUgPSBcIk9ic2VydmFibGVBYm9ydEVycm9yXCIsIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBSci5wcm90b3R5cGUpO1xuICB9XG59O1xuZnVuY3Rpb24gT3IodCkge1xuICBsZXQgZTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlOiBuZXcgUHJvbWlzZSgobiwgcykgPT4ge1xuICAgICAgbGV0IGEgPSAhMTtcbiAgICAgIGZ1bmN0aW9uIGkoKSB7XG4gICAgICAgIGEgfHwgKGEgPSAhMCwgcyhuZXcgSm4oXCJUaGlzIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIikpLCBvLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgfVxuICAgICAgY29uc3QgbyA9IHQuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dChjKSB7XG4gICAgICAgICAgYSA9ICEwLCBuKGMpLCBpKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yKGMpIHtcbiAgICAgICAgICBhID0gITAsIHMoYyksIGkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGUoKSB7XG4gICAgICAgICAgYSA9ICEwLCBpKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZSA9IGk7XG4gICAgfSksXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBhYm9ydDogZVxuICB9O1xufVxuY29uc3QgWW4gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBpc09ic2VydmFibGU6IEhuLFxuICBtYXA6IEduLFxuICBvYnNlcnZhYmxlOiBudCxcbiAgb2JzZXJ2YWJsZVRvUHJvbWlzZTogT3IsXG4gIHNoYXJlOiBFcixcbiAgdGFwOiBDclxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbmZ1bmN0aW9uIFNyKHQpIHtcbiAgcmV0dXJuIG50KChlKSA9PiB7XG4gICAgZnVuY3Rpb24gcihzID0gMCwgYSA9IHQub3ApIHtcbiAgICAgIGNvbnN0IGkgPSB0LmxpbmtzW3NdO1xuICAgICAgaWYgKCFpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtb3JlIGxpbmtzIHRvIGV4ZWN1dGUgLSBkaWQgeW91IGZvcmdldCB0byBhZGQgYW4gZW5kaW5nIGxpbms/XCIpO1xuICAgICAgcmV0dXJuIGkoe1xuICAgICAgICBvcDogYSxcbiAgICAgICAgbmV4dChjKSB7XG4gICAgICAgICAgcmV0dXJuIHIocyArIDEsIGMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHIoKS5zdWJzY3JpYmUoZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gbnIodCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSA/IHQgOiBbXG4gICAgdFxuICBdO1xufVxuZnVuY3Rpb24gWG4odCkge1xuICByZXR1cm4gKGUpID0+IHtcbiAgICBjb25zdCByID0gbnIodC50cnVlKS5tYXAoKHMpID0+IHMoZSkpLCBuID0gbnIodC5mYWxzZSkubWFwKChzKSA9PiBzKGUpKTtcbiAgICByZXR1cm4gKHMpID0+IG50KChhKSA9PiB7XG4gICAgICBjb25zdCBpID0gdC5jb25kaXRpb24ocy5vcCkgPyByIDogbjtcbiAgICAgIHJldHVybiBTcih7XG4gICAgICAgIG9wOiBzLm9wLFxuICAgICAgICBsaW5rczogaVxuICAgICAgfSkuc3Vic2NyaWJlKGEpO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gUHIodCkge1xuICBjb25zdCBlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgciBpbiB0KSB7XG4gICAgY29uc3QgbiA9IHRbcl07XG4gICAgZVtuXSA9IHI7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5jb25zdCBzdCA9IHtcbiAgLyoqXG4gICogSW52YWxpZCBKU09OIHdhcyByZWNlaXZlZCBieSB0aGUgc2VydmVyLlxuICAqIEFuIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXIgd2hpbGUgcGFyc2luZyB0aGUgSlNPTiB0ZXh0LlxuICAqL1xuICBQQVJTRV9FUlJPUjogLTMyNzAwLFxuICAvKipcbiAgKiBUaGUgSlNPTiBzZW50IGlzIG5vdCBhIHZhbGlkIFJlcXVlc3Qgb2JqZWN0LlxuICAqL1xuICBCQURfUkVRVUVTVDogLTMyNjAwLFxuICAvLyBJbnRlcm5hbCBKU09OLVJQQyBlcnJvclxuICBJTlRFUk5BTF9TRVJWRVJfRVJST1I6IC0zMjYwMyxcbiAgTk9UX0lNUExFTUVOVEVEOiAtMzI2MDMsXG4gIC8vIEltcGxlbWVudGF0aW9uIHNwZWNpZmljIGVycm9yc1xuICBVTkFVVEhPUklaRUQ6IC0zMjAwMSxcbiAgRk9SQklEREVOOiAtMzIwMDMsXG4gIE5PVF9GT1VORDogLTMyMDA0LFxuICBNRVRIT0RfTk9UX1NVUFBPUlRFRDogLTMyMDA1LFxuICBUSU1FT1VUOiAtMzIwMDgsXG4gIENPTkZMSUNUOiAtMzIwMDksXG4gIFBSRUNPTkRJVElPTl9GQUlMRUQ6IC0zMjAxMixcbiAgUEFZTE9BRF9UT09fTEFSR0U6IC0zMjAxMyxcbiAgVU5QUk9DRVNTQUJMRV9DT05URU5UOiAtMzIwMjIsXG4gIFRPT19NQU5ZX1JFUVVFU1RTOiAtMzIwMjksXG4gIENMSUVOVF9DTE9TRURfUkVRVUVTVDogLTMyMDk5XG59O1xuUHIoc3QpO1xuUHIoc3QpO1xuY29uc3QgUW4gPSB7XG4gIFBBUlNFX0VSUk9SOiA0MDAsXG4gIEJBRF9SRVFVRVNUOiA0MDAsXG4gIFVOQVVUSE9SSVpFRDogNDAxLFxuICBOT1RfRk9VTkQ6IDQwNCxcbiAgRk9SQklEREVOOiA0MDMsXG4gIE1FVEhPRF9OT1RfU1VQUE9SVEVEOiA0MDUsXG4gIFRJTUVPVVQ6IDQwOCxcbiAgQ09ORkxJQ1Q6IDQwOSxcbiAgUFJFQ09ORElUSU9OX0ZBSUxFRDogNDEyLFxuICBQQVlMT0FEX1RPT19MQVJHRTogNDEzLFxuICBVTlBST0NFU1NBQkxFX0NPTlRFTlQ6IDQyMixcbiAgVE9PX01BTllfUkVRVUVTVFM6IDQyOSxcbiAgQ0xJRU5UX0NMT1NFRF9SRVFVRVNUOiA0OTksXG4gIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogNTAwLFxuICBOT1RfSU1QTEVNRU5URUQ6IDUwMVxufTtcbmZ1bmN0aW9uIEtuKHQpIHtcbiAgcmV0dXJuIFFuW3RdID8/IDUwMDtcbn1cbmZ1bmN0aW9uIEFyKHQpIHtcbiAgcmV0dXJuIEtuKHQuY29kZSk7XG59XG5jb25zdCBOciA9ICgpID0+IHtcbn07XG5mdW5jdGlvbiBJcih0LCBlKSB7XG4gIHJldHVybiBuZXcgUHJveHkoTnIsIHtcbiAgICBnZXQobiwgcykge1xuICAgICAgaWYgKCEodHlwZW9mIHMgIT0gXCJzdHJpbmdcIiB8fCBzID09PSBcInRoZW5cIikpXG4gICAgICAgIHJldHVybiBJcih0LCBbXG4gICAgICAgICAgLi4uZSxcbiAgICAgICAgICBzXG4gICAgICAgIF0pO1xuICAgIH0sXG4gICAgYXBwbHkobiwgcywgYSkge1xuICAgICAgY29uc3QgaSA9IGVbZS5sZW5ndGggLSAxXSA9PT0gXCJhcHBseVwiO1xuICAgICAgcmV0dXJuIHQoe1xuICAgICAgICBhcmdzOiBpID8gYS5sZW5ndGggPj0gMiA/IGFbMV0gOiBbXSA6IGEsXG4gICAgICAgIHBhdGg6IGkgPyBlLnNsaWNlKDAsIC0xKSA6IGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBadCA9ICh0KSA9PiBJcih0LCBbXSksIFV0ID0gKHQpID0+IG5ldyBQcm94eShOciwge1xuICBnZXQoZSwgcikge1xuICAgIGlmICghKHR5cGVvZiByICE9IFwic3RyaW5nXCIgfHwgciA9PT0gXCJ0aGVuXCIpKVxuICAgICAgcmV0dXJuIHQocik7XG4gIH1cbn0pO1xuZnVuY3Rpb24gZXModCkge1xuICBjb25zdCB7IHBhdGg6IGUsIGVycm9yOiByLCBjb25maWc6IG4gfSA9IHQsIHsgY29kZTogcyB9ID0gdC5lcnJvciwgYSA9IHtcbiAgICBtZXNzYWdlOiByLm1lc3NhZ2UsXG4gICAgY29kZTogc3Rbc10sXG4gICAgZGF0YToge1xuICAgICAgY29kZTogcyxcbiAgICAgIGh0dHBTdGF0dXM6IEFyKHIpXG4gICAgfVxuICB9O1xuICByZXR1cm4gbi5pc0RldiAmJiB0eXBlb2YgdC5lcnJvci5zdGFjayA9PSBcInN0cmluZ1wiICYmIChhLmRhdGEuc3RhY2sgPSB0LmVycm9yLnN0YWNrKSwgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiAoYS5kYXRhLnBhdGggPSBlKSwgbi5lcnJvckZvcm1hdHRlcih7XG4gICAgLi4udCxcbiAgICBzaGFwZTogYVxuICB9KTtcbn1cbmZ1bmN0aW9uIHNyKHQsIGUpIHtcbiAgcmV0dXJuIFwiZXJyb3JcIiBpbiBlID8ge1xuICAgIC4uLmUsXG4gICAgZXJyb3I6IHQudHJhbnNmb3JtZXIub3V0cHV0LnNlcmlhbGl6ZShlLmVycm9yKVxuICB9IDogXCJkYXRhXCIgaW4gZS5yZXN1bHQgPyB7XG4gICAgLi4uZSxcbiAgICByZXN1bHQ6IHtcbiAgICAgIC4uLmUucmVzdWx0LFxuICAgICAgZGF0YTogdC50cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplKGUucmVzdWx0LmRhdGEpXG4gICAgfVxuICB9IDogZTtcbn1cbmZ1bmN0aW9uIHRzKHQsIGUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZSkgPyBlLm1hcCgocikgPT4gc3IodCwgcikpIDogc3IodCwgZSk7XG59XG5mdW5jdGlvbiBycyh0KSB7XG4gIHJldHVybiAhIXQgJiYgIUFycmF5LmlzQXJyYXkodCkgJiYgdHlwZW9mIHQgPT0gXCJvYmplY3RcIjtcbn1cbmNsYXNzIG5zIGV4dGVuZHMgRXJyb3Ige1xufVxuZnVuY3Rpb24gV3QodCkge1xuICBpZiAodCBpbnN0YW5jZW9mIEVycm9yKVxuICAgIHJldHVybiB0O1xuICBjb25zdCBlID0gdHlwZW9mIHQ7XG4gIGlmICghKGUgPT09IFwidW5kZWZpbmVkXCIgfHwgZSA9PT0gXCJmdW5jdGlvblwiIHx8IHQgPT09IG51bGwpKSB7XG4gICAgaWYgKGUgIT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gbmV3IEVycm9yKFN0cmluZyh0KSk7XG4gICAgaWYgKHJzKHQpKSB7XG4gICAgICBjb25zdCByID0gbmV3IG5zKCk7XG4gICAgICBmb3IgKGNvbnN0IG4gaW4gdClcbiAgICAgICAgcltuXSA9IHRbbl07XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IHNzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgY3JlYXRlRmxhdFByb3h5OiBVdCxcbiAgY3JlYXRlUmVjdXJzaXZlUHJveHk6IFp0LFxuICBnZXRDYXVzZUZyb21Vbmtub3duOiBXdCxcbiAgZ2V0RXJyb3JTaGFwZTogZXMsXG4gIHRyYW5zZm9ybVRSUENSZXNwb25zZTogdHNcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG5mdW5jdGlvbiBhcih0KSB7XG4gIHJldHVybiAhIXQgJiYgIUFycmF5LmlzQXJyYXkodCkgJiYgdHlwZW9mIHQgPT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGFzKHQpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBqciB8fCAvKipcbiAgKiBAZGVwcmVjYXRlZFxuICAqIERlbGV0ZSBpbiBuZXh0IG1ham9yXG4gICovXG4gIHQgaW5zdGFuY2VvZiBFcnJvciAmJiB0Lm5hbWUgPT09IFwiVFJQQ0NsaWVudEVycm9yXCI7XG59XG5mdW5jdGlvbiBpcyh0KSB7XG4gIHJldHVybiBhcih0KSAmJiBhcih0LmVycm9yKSAmJiB0eXBlb2YgdC5lcnJvci5jb2RlID09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHQuZXJyb3IubWVzc2FnZSA9PSBcInN0cmluZ1wiO1xufVxubGV0IGpyID0gY2xhc3MgRWUgZXh0ZW5kcyBFcnJvciB7XG4gIHN0YXRpYyBmcm9tKGUsIHIgPSB7fSkge1xuICAgIGNvbnN0IG4gPSBlO1xuICAgIHJldHVybiBhcyhuKSA/IChyLm1ldGEgJiYgKG4ubWV0YSA9IHtcbiAgICAgIC4uLm4ubWV0YSxcbiAgICAgIC4uLnIubWV0YVxuICAgIH0pLCBuKSA6IGlzKG4pID8gbmV3IEVlKG4uZXJyb3IubWVzc2FnZSwge1xuICAgICAgLi4ucixcbiAgICAgIHJlc3VsdDogblxuICAgIH0pIDogbiBpbnN0YW5jZW9mIEVycm9yID8gbmV3IEVlKG4ubWVzc2FnZSwge1xuICAgICAgLi4ucixcbiAgICAgIGNhdXNlOiBXdChuKVxuICAgIH0pIDogbmV3IEVlKFwiVW5rbm93biBlcnJvclwiLCB7XG4gICAgICAuLi5yLFxuICAgICAgY2F1c2U6IG5cbiAgICB9KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihlLCByKSB7XG4gICAgY29uc3QgbiA9IHI/LmNhdXNlO1xuICAgIHN1cGVyKGUsIHtcbiAgICAgIGNhdXNlOiBuXG4gICAgfSksIHRoaXMubWV0YSA9IHI/Lm1ldGEsIHRoaXMuY2F1c2UgPSBuLCB0aGlzLnNoYXBlID0gcj8ucmVzdWx0Py5lcnJvciwgdGhpcy5kYXRhID0gcj8ucmVzdWx0Py5lcnJvci5kYXRhLCB0aGlzLm5hbWUgPSBcIlRSUENDbGllbnRFcnJvclwiLCBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRWUucHJvdG90eXBlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIG9zKHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBGb3JtRGF0YSA+IFwidVwiID8gITEgOiB0IGluc3RhbmNlb2YgRm9ybURhdGE7XG59XG5jb25zdCBtdCA9IHtcbiAgY3NzOiB7XG4gICAgcXVlcnk6IFtcbiAgICAgIFwiNzJlM2ZmXCIsXG4gICAgICBcIjNmYjBkOFwiXG4gICAgXSxcbiAgICBtdXRhdGlvbjogW1xuICAgICAgXCJjNWEzZmNcIixcbiAgICAgIFwiOTA0ZGZjXCJcbiAgICBdLFxuICAgIHN1YnNjcmlwdGlvbjogW1xuICAgICAgXCJmZjQ5ZTFcIixcbiAgICAgIFwiZDgzZmJlXCJcbiAgICBdXG4gIH0sXG4gIGFuc2k6IHtcbiAgICByZWd1bGFyOiB7XG4gICAgICAvLyBDeWFuIGJhY2tncm91bmQsIGJsYWNrIGFuZCB3aGl0ZSB0ZXh0IHJlc3BlY3RpdmVseVxuICAgICAgcXVlcnk6IFtcbiAgICAgICAgXCJcXHgxQlszMDs0Nm1cIixcbiAgICAgICAgXCJcXHgxQls5Nzs0Nm1cIlxuICAgICAgXSxcbiAgICAgIC8vIE1hZ2VudGEgYmFja2dyb3VuZCwgYmxhY2sgYW5kIHdoaXRlIHRleHQgcmVzcGVjdGl2ZWx5XG4gICAgICBtdXRhdGlvbjogW1xuICAgICAgICBcIlxceDFCWzMwOzQ1bVwiLFxuICAgICAgICBcIlxceDFCWzk3OzQ1bVwiXG4gICAgICBdLFxuICAgICAgLy8gR3JlZW4gYmFja2dyb3VuZCwgYmxhY2sgYW5kIHdoaXRlIHRleHQgcmVzcGVjdGl2ZWx5XG4gICAgICBzdWJzY3JpcHRpb246IFtcbiAgICAgICAgXCJcXHgxQlszMDs0Mm1cIixcbiAgICAgICAgXCJcXHgxQls5Nzs0Mm1cIlxuICAgICAgXVxuICAgIH0sXG4gICAgYm9sZDoge1xuICAgICAgcXVlcnk6IFtcbiAgICAgICAgXCJcXHgxQlsxOzMwOzQ2bVwiLFxuICAgICAgICBcIlxceDFCWzE7OTc7NDZtXCJcbiAgICAgIF0sXG4gICAgICBtdXRhdGlvbjogW1xuICAgICAgICBcIlxceDFCWzE7MzA7NDVtXCIsXG4gICAgICAgIFwiXFx4MUJbMTs5Nzs0NW1cIlxuICAgICAgXSxcbiAgICAgIHN1YnNjcmlwdGlvbjogW1xuICAgICAgICBcIlxceDFCWzE7MzA7NDJtXCIsXG4gICAgICAgIFwiXFx4MUJbMTs5Nzs0Mm1cIlxuICAgICAgXVxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGNzKHQpIHtcbiAgY29uc3QgeyBkaXJlY3Rpb246IGUsIHR5cGU6IHIsIHBhdGg6IG4sIGlkOiBzLCBpbnB1dDogYSB9ID0gdCwgaSA9IFtdLCBvID0gW107XG4gIGlmICh0LmNvbG9yTW9kZSA9PT0gXCJhbnNpXCIpIHtcbiAgICBjb25zdCBbaCwgeV0gPSBtdC5hbnNpLnJlZ3VsYXJbcl0sIFtrLCBUXSA9IG10LmFuc2kuYm9sZFtyXSwgQSA9IFwiXFx4MUJbMG1cIjtcbiAgICByZXR1cm4gaS5wdXNoKGUgPT09IFwidXBcIiA/IGggOiB5LCBlID09PSBcInVwXCIgPyBcIj4+XCIgOiBcIjw8XCIsIHIsIGUgPT09IFwidXBcIiA/IGsgOiBULCBgIyR7c31gLCBuLCBBKSwgZSA9PT0gXCJ1cFwiID8gby5wdXNoKHtcbiAgICAgIGlucHV0OiB0LmlucHV0XG4gICAgfSkgOiBvLnB1c2goe1xuICAgICAgaW5wdXQ6IHQuaW5wdXQsXG4gICAgICAvLyBzdHJpcCBjb250ZXh0IGZyb20gcmVzdWx0IGNhdXNlIGl0J3MgdG9vIG5vaXN5IGluIHRlcm1pbmFsIHdpaHRvdXQgY29sbGFwc2UgbW9kZVxuICAgICAgcmVzdWx0OiBcInJlc3VsdFwiIGluIHQucmVzdWx0ID8gdC5yZXN1bHQucmVzdWx0IDogdC5yZXN1bHQsXG4gICAgICBlbGFwc2VkTXM6IHQuZWxhcHNlZE1zXG4gICAgfSksIHtcbiAgICAgIHBhcnRzOiBpLFxuICAgICAgYXJnczogb1xuICAgIH07XG4gIH1cbiAgY29uc3QgW2MsIHVdID0gbXQuY3NzW3JdLCBkID0gYFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMke2UgPT09IFwidXBcIiA/IGMgOiB1fTsgXG4gICAgY29sb3I6ICR7ZSA9PT0gXCJ1cFwiID8gXCJibGFja1wiIDogXCJ3aGl0ZVwifTtcbiAgICBwYWRkaW5nOiAycHg7XG4gIGA7XG4gIHJldHVybiBpLnB1c2goXCIlY1wiLCBlID09PSBcInVwXCIgPyBcIj4+XCIgOiBcIjw8XCIsIHIsIGAjJHtzfWAsIGAlYyR7bn0lY2AsIFwiJU9cIiksIG8ucHVzaChkLCBgJHtkfTsgZm9udC13ZWlnaHQ6IGJvbGQ7YCwgYCR7ZH07IGZvbnQtd2VpZ2h0OiBub3JtYWw7YCksIGUgPT09IFwidXBcIiA/IG8ucHVzaCh7XG4gICAgaW5wdXQ6IGEsXG4gICAgY29udGV4dDogdC5jb250ZXh0XG4gIH0pIDogby5wdXNoKHtcbiAgICBpbnB1dDogYSxcbiAgICByZXN1bHQ6IHQucmVzdWx0LFxuICAgIGVsYXBzZWRNczogdC5lbGFwc2VkTXMsXG4gICAgY29udGV4dDogdC5jb250ZXh0XG4gIH0pLCB7XG4gICAgcGFydHM6IGksXG4gICAgYXJnczogb1xuICB9O1xufVxuY29uc3QgdXMgPSAoeyBjOiB0ID0gY29uc29sZSwgY29sb3JNb2RlOiBlID0gXCJjc3NcIiB9KSA9PiAocikgPT4ge1xuICBjb25zdCBuID0gci5pbnB1dCwgcyA9IG9zKG4pID8gT2JqZWN0LmZyb21FbnRyaWVzKG4pIDogbiwgeyBwYXJ0czogYSwgYXJnczogaSB9ID0gY3Moe1xuICAgIC4uLnIsXG4gICAgY29sb3JNb2RlOiBlLFxuICAgIGlucHV0OiBzXG4gIH0pLCBvID0gci5kaXJlY3Rpb24gPT09IFwiZG93blwiICYmIHIucmVzdWx0ICYmIChyLnJlc3VsdCBpbnN0YW5jZW9mIEVycm9yIHx8IFwiZXJyb3JcIiBpbiByLnJlc3VsdC5yZXN1bHQpID8gXCJlcnJvclwiIDogXCJsb2dcIjtcbiAgdFtvXS5hcHBseShudWxsLCBbXG4gICAgYS5qb2luKFwiIFwiKVxuICBdLmNvbmNhdChpKSk7XG59O1xuZnVuY3Rpb24gbHModCA9IHt9KSB7XG4gIGNvbnN0IHsgZW5hYmxlZDogZSA9ICgpID0+ICEwIH0gPSB0LCByID0gdC5jb2xvck1vZGUgPz8gKHR5cGVvZiB3aW5kb3cgPiBcInVcIiA/IFwiYW5zaVwiIDogXCJjc3NcIiksIHsgbG9nZ2VyOiBuID0gdXMoe1xuICAgIGM6IHQuY29uc29sZSxcbiAgICBjb2xvck1vZGU6IHJcbiAgfSkgfSA9IHQ7XG4gIHJldHVybiAoKSA9PiAoeyBvcDogcywgbmV4dDogYSB9KSA9PiBudCgoaSkgPT4ge1xuICAgIGUoe1xuICAgICAgLi4ucyxcbiAgICAgIGRpcmVjdGlvbjogXCJ1cFwiXG4gICAgfSkgJiYgbih7XG4gICAgICAuLi5zLFxuICAgICAgZGlyZWN0aW9uOiBcInVwXCJcbiAgICB9KTtcbiAgICBjb25zdCBvID0gRGF0ZS5ub3coKTtcbiAgICBmdW5jdGlvbiBjKHUpIHtcbiAgICAgIGNvbnN0IGQgPSBEYXRlLm5vdygpIC0gbztcbiAgICAgIGUoe1xuICAgICAgICAuLi5zLFxuICAgICAgICBkaXJlY3Rpb246IFwiZG93blwiLFxuICAgICAgICByZXN1bHQ6IHVcbiAgICAgIH0pICYmIG4oe1xuICAgICAgICAuLi5zLFxuICAgICAgICBkaXJlY3Rpb246IFwiZG93blwiLFxuICAgICAgICBlbGFwc2VkTXM6IGQsXG4gICAgICAgIHJlc3VsdDogdVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhKHMpLnBpcGUoQ3Ioe1xuICAgICAgbmV4dCh1KSB7XG4gICAgICAgIGModSk7XG4gICAgICB9LFxuICAgICAgZXJyb3IodSkge1xuICAgICAgICBjKHUpO1xuICAgICAgfVxuICAgIH0pKS5zdWJzY3JpYmUoaSk7XG4gIH0pO1xufVxubGV0IGRzID0gY2xhc3Mge1xuICAkcmVxdWVzdCh7IHR5cGU6IGUsIGlucHV0OiByLCBwYXRoOiBuLCBjb250ZXh0OiBzID0ge30gfSkge1xuICAgIHJldHVybiBTcih7XG4gICAgICBsaW5rczogdGhpcy5saW5rcyxcbiAgICAgIG9wOiB7XG4gICAgICAgIGlkOiArK3RoaXMucmVxdWVzdElkLFxuICAgICAgICB0eXBlOiBlLFxuICAgICAgICBwYXRoOiBuLFxuICAgICAgICBpbnB1dDogcixcbiAgICAgICAgY29udGV4dDogc1xuICAgICAgfVxuICAgIH0pLnBpcGUoRXIoKSk7XG4gIH1cbiAgcmVxdWVzdEFzUHJvbWlzZShlKSB7XG4gICAgY29uc3QgciA9IHRoaXMuJHJlcXVlc3QoZSksIHsgcHJvbWlzZTogbiwgYWJvcnQ6IHMgfSA9IE9yKHIpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoaSwgbykgPT4ge1xuICAgICAgZS5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBzKSwgbi50aGVuKChjKSA9PiB7XG4gICAgICAgIGkoYy5yZXN1bHQuZGF0YSk7XG4gICAgICB9KS5jYXRjaCgoYykgPT4ge1xuICAgICAgICBvKGpyLmZyb20oYykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcXVlcnkoZSwgciwgbikge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc1Byb21pc2Uoe1xuICAgICAgdHlwZTogXCJxdWVyeVwiLFxuICAgICAgcGF0aDogZSxcbiAgICAgIGlucHV0OiByLFxuICAgICAgY29udGV4dDogbj8uY29udGV4dCxcbiAgICAgIHNpZ25hbDogbj8uc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgbXV0YXRpb24oZSwgciwgbikge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc1Byb21pc2Uoe1xuICAgICAgdHlwZTogXCJtdXRhdGlvblwiLFxuICAgICAgcGF0aDogZSxcbiAgICAgIGlucHV0OiByLFxuICAgICAgY29udGV4dDogbj8uY29udGV4dCxcbiAgICAgIHNpZ25hbDogbj8uc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgc3Vic2NyaXB0aW9uKGUsIHIsIG4pIHtcbiAgICByZXR1cm4gdGhpcy4kcmVxdWVzdCh7XG4gICAgICB0eXBlOiBcInN1YnNjcmlwdGlvblwiLFxuICAgICAgcGF0aDogZSxcbiAgICAgIGlucHV0OiByLFxuICAgICAgY29udGV4dDogbj8uY29udGV4dFxuICAgIH0pLnN1YnNjcmliZSh7XG4gICAgICBuZXh0KGEpIHtcbiAgICAgICAgYS5yZXN1bHQudHlwZSA9PT0gXCJzdGFydGVkXCIgPyBuLm9uU3RhcnRlZD8uKCkgOiBhLnJlc3VsdC50eXBlID09PSBcInN0b3BwZWRcIiA/IG4ub25TdG9wcGVkPy4oKSA6IG4ub25EYXRhPy4oYS5yZXN1bHQuZGF0YSk7XG4gICAgICB9LFxuICAgICAgZXJyb3IoYSkge1xuICAgICAgICBuLm9uRXJyb3I/LihhKTtcbiAgICAgIH0sXG4gICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgbi5vbkNvbXBsZXRlPy4oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSAwO1xuICAgIGNvbnN0IHIgPSAoKCkgPT4ge1xuICAgICAgY29uc3QgbiA9IGUudHJhbnNmb3JtZXI7XG4gICAgICByZXR1cm4gbiA/IFwiaW5wdXRcIiBpbiBuID8gZS50cmFuc2Zvcm1lciA6IHtcbiAgICAgICAgaW5wdXQ6IG4sXG4gICAgICAgIG91dHB1dDogblxuICAgICAgfSA6IHtcbiAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICBzZXJpYWxpemU6IChzKSA9PiBzLFxuICAgICAgICAgIGRlc2VyaWFsaXplOiAocykgPT4gc1xuICAgICAgICB9LFxuICAgICAgICBvdXRwdXQ6IHtcbiAgICAgICAgICBzZXJpYWxpemU6IChzKSA9PiBzLFxuICAgICAgICAgIGRlc2VyaWFsaXplOiAocykgPT4gc1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgdGhpcy5ydW50aW1lID0ge1xuICAgICAgdHJhbnNmb3JtZXI6IHtcbiAgICAgICAgc2VyaWFsaXplOiAobikgPT4gci5pbnB1dC5zZXJpYWxpemUobiksXG4gICAgICAgIGRlc2VyaWFsaXplOiAobikgPT4gci5vdXRwdXQuZGVzZXJpYWxpemUobilcbiAgICAgIH0sXG4gICAgICBjb21iaW5lZFRyYW5zZm9ybWVyOiByXG4gICAgfSwgdGhpcy5saW5rcyA9IGUubGlua3MubWFwKChuKSA9PiBuKHRoaXMucnVudGltZSkpO1xuICB9XG59O1xuY29uc3QgZnMgPSB7XG4gIHF1ZXJ5OiBcInF1ZXJ5XCIsXG4gIG11dGF0ZTogXCJtdXRhdGlvblwiLFxuICBzdWJzY3JpYmU6IFwic3Vic2NyaXB0aW9uXCJcbn0sIHBzID0gKHQpID0+IGZzW3RdO1xuZnVuY3Rpb24gaHModCkge1xuICByZXR1cm4gVXQoKGUpID0+IHQuaGFzT3duUHJvcGVydHkoZSkgPyB0W2VdIDogZSA9PT0gXCJfX3VudHlwZWRDbGllbnRcIiA/IHQgOiBadCgoeyBwYXRoOiByLCBhcmdzOiBuIH0pID0+IHtcbiAgICBjb25zdCBzID0gW1xuICAgICAgZSxcbiAgICAgIC4uLnJcbiAgICBdLCBhID0gcHMocy5wb3AoKSksIGkgPSBzLmpvaW4oXCIuXCIpO1xuICAgIHJldHVybiB0W2FdKGksIC4uLm4pO1xuICB9KSk7XG59XG5mdW5jdGlvbiBtcyh0KSB7XG4gIGNvbnN0IGUgPSBuZXcgZHModCk7XG4gIHJldHVybiBocyhlKTtcbn1cbmZ1bmN0aW9uIHlzKHQpIHtcbiAgaWYgKHQgaW5zdGFuY2VvZiB5ZSB8fCB0IGluc3RhbmNlb2YgRXJyb3IgJiYgdC5uYW1lID09PSBcIlRSUENFcnJvclwiKVxuICAgIHJldHVybiB0O1xuICBjb25zdCBlID0gbmV3IHllKHtcbiAgICBjb2RlOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuICAgIGNhdXNlOiB0XG4gIH0pO1xuICByZXR1cm4gdCBpbnN0YW5jZW9mIEVycm9yICYmIHQuc3RhY2sgJiYgKGUuc3RhY2sgPSB0LnN0YWNrKSwgZTtcbn1cbmNsYXNzIHllIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgY29uc3QgciA9IFd0KGUuY2F1c2UpLCBuID0gZS5tZXNzYWdlID8/IHI/Lm1lc3NhZ2UgPz8gZS5jb2RlO1xuICAgIHN1cGVyKG4sIHtcbiAgICAgIGNhdXNlOiByXG4gICAgfSksIHRoaXMuY29kZSA9IGUuY29kZSwgdGhpcy5uYW1lID0gXCJUUlBDRXJyb3JcIiwgdGhpcy5jYXVzZSB8fCAodGhpcy5jYXVzZSA9IHIpO1xuICB9XG59XG5mdW5jdGlvbiBncyh0KSB7XG4gIHJldHVybiBcImlucHV0XCIgaW4gdCA/IHQgOiB7XG4gICAgaW5wdXQ6IHQsXG4gICAgb3V0cHV0OiB0XG4gIH07XG59XG5jb25zdCBTZSA9IHtcbiAgX2RlZmF1bHQ6ICEwLFxuICBpbnB1dDoge1xuICAgIHNlcmlhbGl6ZTogKHQpID0+IHQsXG4gICAgZGVzZXJpYWxpemU6ICh0KSA9PiB0XG4gIH0sXG4gIG91dHB1dDoge1xuICAgIHNlcmlhbGl6ZTogKHQpID0+IHQsXG4gICAgZGVzZXJpYWxpemU6ICh0KSA9PiB0XG4gIH1cbn0sIFBlID0gKHsgc2hhcGU6IHQgfSkgPT4gdDtcbmZ1bmN0aW9uIF9zKHQpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHQpO1xufVxuY29uc3QgdnMgPSBbXG4gIFwicXVlcnlcIixcbiAgXCJtdXRhdGlvblwiLFxuICBcInN1YnNjcmlwdGlvblwiXG5dO1xuZnVuY3Rpb24gYnModCkge1xuICByZXR1cm4gXCJyb3V0ZXJcIiBpbiB0Ll9kZWY7XG59XG5jb25zdCB3cyA9IHtcbiAgX2N0eDogbnVsbCxcbiAgX2Vycm9yU2hhcGU6IG51bGwsXG4gIF9tZXRhOiBudWxsLFxuICBxdWVyaWVzOiB7fSxcbiAgbXV0YXRpb25zOiB7fSxcbiAgc3Vic2NyaXB0aW9uczoge30sXG4gIGVycm9yRm9ybWF0dGVyOiBQZSxcbiAgdHJhbnNmb3JtZXI6IFNlXG59LCB4cyA9IFtcbiAgLyoqXG4gICogVGhlbiBpcyBhIHJlc2VydmVkIHdvcmQgYmVjYXVzZSBvdGhlcndpc2Ugd2UgY2FuJ3QgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJldHVybnMgYSBQcm94eVxuICAqIHNpbmNlIEpTIHdpbGwgdGhpbmsgdGhhdCBgLnRoZW5gIGlzIHNvbWV0aGluZyB0aGF0IGV4aXN0c1xuICAqL1xuICBcInRoZW5cIlxuXTtcbmZ1bmN0aW9uIExyKHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICBjb25zdCBuID0gbmV3IFNldChPYmplY3Qua2V5cyhyKS5maWx0ZXIoKGMpID0+IHhzLmluY2x1ZGVzKGMpKSk7XG4gICAgaWYgKG4uc2l6ZSA+IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNlcnZlZCB3b3JkcyB1c2VkIGluIGByb3V0ZXIoe30pYCBjYWxsOiBcIiArIEFycmF5LmZyb20obikuam9pbihcIiwgXCIpKTtcbiAgICBjb25zdCBzID0gX3Moe30pO1xuICAgIGZ1bmN0aW9uIGEoYywgdSA9IFwiXCIpIHtcbiAgICAgIGZvciAoY29uc3QgW2QsIGhdIG9mIE9iamVjdC5lbnRyaWVzKGMgPz8ge30pKSB7XG4gICAgICAgIGNvbnN0IHkgPSBgJHt1fSR7ZH1gO1xuICAgICAgICBpZiAoYnMoaCkpIHtcbiAgICAgICAgICBhKGguX2RlZi5wcm9jZWR1cmVzLCBgJHt5fS5gKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc1t5XSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBrZXk6ICR7eX1gKTtcbiAgICAgICAgc1t5XSA9IGg7XG4gICAgICB9XG4gICAgfVxuICAgIGEocik7XG4gICAgY29uc3QgaSA9IHtcbiAgICAgIF9jb25maWc6IHQsXG4gICAgICByb3V0ZXI6ICEwLFxuICAgICAgcHJvY2VkdXJlczogcyxcbiAgICAgIC4uLndzLFxuICAgICAgcmVjb3JkOiByLFxuICAgICAgcXVlcmllczogT2JqZWN0LmVudHJpZXMocykuZmlsdGVyKChjKSA9PiBjWzFdLl9kZWYucXVlcnkpLnJlZHVjZSgoYywgW3UsIGRdKSA9PiAoe1xuICAgICAgICAuLi5jLFxuICAgICAgICBbdV06IGRcbiAgICAgIH0pLCB7fSksXG4gICAgICBtdXRhdGlvbnM6IE9iamVjdC5lbnRyaWVzKHMpLmZpbHRlcigoYykgPT4gY1sxXS5fZGVmLm11dGF0aW9uKS5yZWR1Y2UoKGMsIFt1LCBkXSkgPT4gKHtcbiAgICAgICAgLi4uYyxcbiAgICAgICAgW3VdOiBkXG4gICAgICB9KSwge30pLFxuICAgICAgc3Vic2NyaXB0aW9uczogT2JqZWN0LmVudHJpZXMocykuZmlsdGVyKChjKSA9PiBjWzFdLl9kZWYuc3Vic2NyaXB0aW9uKS5yZWR1Y2UoKGMsIFt1LCBkXSkgPT4gKHtcbiAgICAgICAgLi4uYyxcbiAgICAgICAgW3VdOiBkXG4gICAgICB9KSwge30pXG4gICAgfSwgbyA9IHtcbiAgICAgIC4uLnIsXG4gICAgICBfZGVmOiBpLFxuICAgICAgY3JlYXRlQ2FsbGVyKGMpIHtcbiAgICAgICAgcmV0dXJuICRyKCkobykoYyk7XG4gICAgICB9LFxuICAgICAgZ2V0RXJyb3JTaGFwZShjKSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aDogdSwgZXJyb3I6IGQgfSA9IGMsIHsgY29kZTogaCB9ID0gYy5lcnJvciwgeSA9IHtcbiAgICAgICAgICBtZXNzYWdlOiBkLm1lc3NhZ2UsXG4gICAgICAgICAgY29kZTogc3RbaF0sXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgY29kZTogaCxcbiAgICAgICAgICAgIGh0dHBTdGF0dXM6IEFyKGQpXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdC5pc0RldiAmJiB0eXBlb2YgYy5lcnJvci5zdGFjayA9PSBcInN0cmluZ1wiICYmICh5LmRhdGEuc3RhY2sgPSBjLmVycm9yLnN0YWNrKSwgdHlwZW9mIHUgPT0gXCJzdHJpbmdcIiAmJiAoeS5kYXRhLnBhdGggPSB1KSwgdGhpcy5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXIoe1xuICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgc2hhcGU6IHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbztcbiAgfTtcbn1cbmZ1bmN0aW9uIGtzKHQpIHtcbiAgY29uc3QgeyB0eXBlOiBlLCBwYXRoOiByIH0gPSB0O1xuICBpZiAoIShyIGluIHQucHJvY2VkdXJlcykgfHwgIXQucHJvY2VkdXJlc1tyXT8uX2RlZltlXSlcbiAgICB0aHJvdyBuZXcgeWUoe1xuICAgICAgY29kZTogXCJOT1RfRk9VTkRcIixcbiAgICAgIG1lc3NhZ2U6IGBObyBcIiR7ZX1cIi1wcm9jZWR1cmUgb24gcGF0aCBcIiR7cn1cImBcbiAgICB9KTtcbiAgY29uc3QgbiA9IHQucHJvY2VkdXJlc1tyXTtcbiAgcmV0dXJuIG4odCk7XG59XG5mdW5jdGlvbiAkcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICBjb25zdCByID0gZS5fZGVmO1xuICAgIHJldHVybiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gWnQoKHsgcGF0aDogaSwgYXJnczogbyB9KSA9PiB7XG4gICAgICAgIGlmIChpLmxlbmd0aCA9PT0gMSAmJiB2cy5pbmNsdWRlcyhpWzBdKSlcbiAgICAgICAgICByZXR1cm4ga3Moe1xuICAgICAgICAgICAgcHJvY2VkdXJlczogci5wcm9jZWR1cmVzLFxuICAgICAgICAgICAgcGF0aDogb1swXSxcbiAgICAgICAgICAgIHJhd0lucHV0OiBvWzFdLFxuICAgICAgICAgICAgY3R4OiBzLFxuICAgICAgICAgICAgdHlwZTogaVswXVxuICAgICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjID0gaS5qb2luKFwiLlwiKSwgdSA9IHIucHJvY2VkdXJlc1tjXTtcbiAgICAgICAgbGV0IGQgPSBcInF1ZXJ5XCI7XG4gICAgICAgIHJldHVybiB1Ll9kZWYubXV0YXRpb24gPyBkID0gXCJtdXRhdGlvblwiIDogdS5fZGVmLnN1YnNjcmlwdGlvbiAmJiAoZCA9IFwic3Vic2NyaXB0aW9uXCIpLCB1KHtcbiAgICAgICAgICBwYXRoOiBjLFxuICAgICAgICAgIHJhd0lucHV0OiBvWzBdLFxuICAgICAgICAgIGN0eDogcyxcbiAgICAgICAgICB0eXBlOiBkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cbmNvbnN0IGlyID0gdHlwZW9mIHdpbmRvdyA+IFwidVwiIHx8IFwiRGVub1wiIGluIHdpbmRvdyB8fCBnbG9iYWxUaGlzLnByb2Nlc3M/LmVudj8uTk9ERV9FTlYgPT09IFwidGVzdFwiIHx8ICEhZ2xvYmFsVGhpcy5wcm9jZXNzPy5lbnY/LkpFU1RfV09SS0VSX0lEIHx8ICEhZ2xvYmFsVGhpcy5wcm9jZXNzPy5lbnY/LlZJVEVTVF9XT1JLRVJfSUQ7XG5mdW5jdGlvbiBvcih0KSB7XG4gIGNvbnN0IGUgPSB0O1xuICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBlO1xuICBpZiAodHlwZW9mIGUucGFyc2VBc3luYyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIGUucGFyc2VBc3luYy5iaW5kKGUpO1xuICBpZiAodHlwZW9mIGUucGFyc2UgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBlLnBhcnNlLmJpbmQoZSk7XG4gIGlmICh0eXBlb2YgZS52YWxpZGF0ZVN5bmMgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBlLnZhbGlkYXRlU3luYy5iaW5kKGUpO1xuICBpZiAodHlwZW9mIGUuY3JlYXRlID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gZS5jcmVhdGUuYmluZChlKTtcbiAgaWYgKHR5cGVvZiBlLmFzc2VydCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIChyKSA9PiAoZS5hc3NlcnQociksIHIpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhIHZhbGlkYXRvciBmblwiKTtcbn1cbmZ1bmN0aW9uIE1yKHQsIC4uLmUpIHtcbiAgY29uc3QgciA9IE9iamVjdC5hc3NpZ24oLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHQpO1xuICBmb3IgKGNvbnN0IG4gb2YgZSlcbiAgICBmb3IgKGNvbnN0IHMgaW4gbikge1xuICAgICAgaWYgKHMgaW4gciAmJiByW3NdICE9PSBuW3NdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBrZXkgJHtzfWApO1xuICAgICAgcltzXSA9IG5bc107XG4gICAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIFRzKCkge1xuICBmdW5jdGlvbiB0KHIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX21pZGRsZXdhcmVzOiByLFxuICAgICAgdW5zdGFibGVfcGlwZShuKSB7XG4gICAgICAgIGNvbnN0IHMgPSBcIl9taWRkbGV3YXJlc1wiIGluIG4gPyBuLl9taWRkbGV3YXJlcyA6IFtcbiAgICAgICAgICBuXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiB0KFtcbiAgICAgICAgICAuLi5yLFxuICAgICAgICAgIC4uLnNcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBlKHIpIHtcbiAgICByZXR1cm4gdChbXG4gICAgICByXG4gICAgXSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBjcih0KSB7XG4gIHJldHVybiB0ICYmIHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodCk7XG59XG5mdW5jdGlvbiBFcyh0KSB7XG4gIGNvbnN0IGUgPSBhc3luYyAoeyBuZXh0OiByLCByYXdJbnB1dDogbiwgaW5wdXQ6IHMgfSkgPT4ge1xuICAgIGxldCBhO1xuICAgIHRyeSB7XG4gICAgICBhID0gYXdhaXQgdChuKTtcbiAgICB9IGNhdGNoIChvKSB7XG4gICAgICB0aHJvdyBuZXcgeWUoe1xuICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgIGNhdXNlOiBvXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgaSA9IGNyKHMpICYmIGNyKGEpID8ge1xuICAgICAgLi4ucyxcbiAgICAgIC4uLmFcbiAgICB9IDogYTtcbiAgICByZXR1cm4gcih7XG4gICAgICBpbnB1dDogaVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gZS5fdHlwZSA9IFwiaW5wdXRcIiwgZTtcbn1cbmZ1bmN0aW9uIENzKHQpIHtcbiAgY29uc3QgZSA9IGFzeW5jICh7IG5leHQ6IHIgfSkgPT4ge1xuICAgIGNvbnN0IG4gPSBhd2FpdCByKCk7XG4gICAgaWYgKCFuLm9rKVxuICAgICAgcmV0dXJuIG47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHMgPSBhd2FpdCB0KG4uZGF0YSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5uLFxuICAgICAgICBkYXRhOiBzXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIHRocm93IG5ldyB5ZSh7XG4gICAgICAgIG1lc3NhZ2U6IFwiT3V0cHV0IHZhbGlkYXRpb24gZmFpbGVkXCIsXG4gICAgICAgIGNvZGU6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG4gICAgICAgIGNhdXNlOiBzXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlLl90eXBlID0gXCJvdXRwdXRcIiwgZTtcbn1cbmNvbnN0IERyID0gXCJtaWRkbGV3YXJlTWFya2VyXCI7XG5mdW5jdGlvbiBmZSh0LCBlKSB7XG4gIGNvbnN0IHsgbWlkZGxld2FyZXM6IHIgPSBbXSwgaW5wdXRzOiBuLCBtZXRhOiBzLCAuLi5hIH0gPSBlO1xuICByZXR1cm4gWnIoe1xuICAgIC4uLk1yKHQsIGEpLFxuICAgIGlucHV0czogW1xuICAgICAgLi4udC5pbnB1dHMsXG4gICAgICAuLi5uID8/IFtdXG4gICAgXSxcbiAgICBtaWRkbGV3YXJlczogW1xuICAgICAgLi4udC5taWRkbGV3YXJlcyxcbiAgICAgIC4uLnJcbiAgICBdLFxuICAgIG1ldGE6IHQubWV0YSAmJiBzID8ge1xuICAgICAgLi4udC5tZXRhLFxuICAgICAgLi4uc1xuICAgIH0gOiBzID8/IHQubWV0YVxuICB9KTtcbn1cbmZ1bmN0aW9uIFpyKHQgPSB7fSkge1xuICBjb25zdCBlID0ge1xuICAgIGlucHV0czogW10sXG4gICAgbWlkZGxld2FyZXM6IFtdLFxuICAgIC4uLnRcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBfZGVmOiBlLFxuICAgIGlucHV0KHIpIHtcbiAgICAgIGNvbnN0IG4gPSBvcihyKTtcbiAgICAgIHJldHVybiBmZShlLCB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgIHJcbiAgICAgICAgXSxcbiAgICAgICAgbWlkZGxld2FyZXM6IFtcbiAgICAgICAgICBFcyhuKVxuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB9LFxuICAgIG91dHB1dChyKSB7XG4gICAgICBjb25zdCBuID0gb3Iocik7XG4gICAgICByZXR1cm4gZmUoZSwge1xuICAgICAgICBvdXRwdXQ6IHIsXG4gICAgICAgIG1pZGRsZXdhcmVzOiBbXG4gICAgICAgICAgQ3MobilcbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBtZXRhKHIpIHtcbiAgICAgIHJldHVybiBmZShlLCB7XG4gICAgICAgIG1ldGE6IHJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBAZGVwcmVjYXRlZFxuICAgICogVGhpcyBmdW5jdGlvbmFsaXR5IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgICovXG4gICAgdW5zdGFibGVfY29uY2F0KHIpIHtcbiAgICAgIHJldHVybiBmZShlLCByLl9kZWYpO1xuICAgIH0sXG4gICAgdXNlKHIpIHtcbiAgICAgIGNvbnN0IG4gPSBcIl9taWRkbGV3YXJlc1wiIGluIHIgPyByLl9taWRkbGV3YXJlcyA6IFtcbiAgICAgICAgclxuICAgICAgXTtcbiAgICAgIHJldHVybiBmZShlLCB7XG4gICAgICAgIG1pZGRsZXdhcmVzOiBuXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHF1ZXJ5KHIpIHtcbiAgICAgIHJldHVybiB5dCh7XG4gICAgICAgIC4uLmUsXG4gICAgICAgIHF1ZXJ5OiAhMFxuICAgICAgfSwgcik7XG4gICAgfSxcbiAgICBtdXRhdGlvbihyKSB7XG4gICAgICByZXR1cm4geXQoe1xuICAgICAgICAuLi5lLFxuICAgICAgICBtdXRhdGlvbjogITBcbiAgICAgIH0sIHIpO1xuICAgIH0sXG4gICAgc3Vic2NyaXB0aW9uKHIpIHtcbiAgICAgIHJldHVybiB5dCh7XG4gICAgICAgIC4uLmUsXG4gICAgICAgIHN1YnNjcmlwdGlvbjogITBcbiAgICAgIH0sIHIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHl0KHQsIGUpIHtcbiAgY29uc3QgciA9IGZlKHQsIHtcbiAgICByZXNvbHZlcjogZSxcbiAgICBtaWRkbGV3YXJlczogW1xuICAgICAgYXN5bmMgZnVuY3Rpb24ocykge1xuICAgICAgICBjb25zdCBhID0gYXdhaXQgZShzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXJrZXI6IERyLFxuICAgICAgICAgIG9rOiAhMCxcbiAgICAgICAgICBkYXRhOiBhLFxuICAgICAgICAgIGN0eDogcy5jdHhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBdXG4gIH0pO1xuICByZXR1cm4gT3Moci5fZGVmKTtcbn1cbmNvbnN0IFJzID0gYFxuVGhpcyBpcyBhIGNsaWVudC1vbmx5IGZ1bmN0aW9uLlxuSWYgeW91IHdhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBzZXJ2ZXIsIHNlZSBodHRwczovL3RycGMuaW8vZG9jcy9zZXJ2ZXIvc2VydmVyLXNpZGUtY2FsbHNcbmAudHJpbSgpO1xuZnVuY3Rpb24gT3ModCkge1xuICBjb25zdCBlID0gYXN5bmMgZnVuY3Rpb24obikge1xuICAgIGlmICghbiB8fCAhKFwicmF3SW5wdXRcIiBpbiBuKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihScyk7XG4gICAgY29uc3QgcyA9IGFzeW5jIChpID0ge1xuICAgICAgaW5kZXg6IDAsXG4gICAgICBjdHg6IG4uY3R4XG4gICAgfSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbyA9IHQubWlkZGxld2FyZXNbaS5pbmRleF07XG4gICAgICAgIHJldHVybiBhd2FpdCBvKHtcbiAgICAgICAgICBjdHg6IGkuY3R4LFxuICAgICAgICAgIHR5cGU6IG4udHlwZSxcbiAgICAgICAgICBwYXRoOiBuLnBhdGgsXG4gICAgICAgICAgcmF3SW5wdXQ6IGkucmF3SW5wdXQgPz8gbi5yYXdJbnB1dCxcbiAgICAgICAgICBtZXRhOiB0Lm1ldGEsXG4gICAgICAgICAgaW5wdXQ6IGkuaW5wdXQsXG4gICAgICAgICAgbmV4dCh1KSB7XG4gICAgICAgICAgICBjb25zdCBkID0gdTtcbiAgICAgICAgICAgIHJldHVybiBzKHtcbiAgICAgICAgICAgICAgaW5kZXg6IGkuaW5kZXggKyAxLFxuICAgICAgICAgICAgICBjdHg6IGQgJiYgXCJjdHhcIiBpbiBkID8ge1xuICAgICAgICAgICAgICAgIC4uLmkuY3R4LFxuICAgICAgICAgICAgICAgIC4uLmQuY3R4XG4gICAgICAgICAgICAgIH0gOiBpLmN0eCxcbiAgICAgICAgICAgICAgaW5wdXQ6IGQgJiYgXCJpbnB1dFwiIGluIGQgPyBkLmlucHV0IDogaS5pbnB1dCxcbiAgICAgICAgICAgICAgcmF3SW5wdXQ6IGQgJiYgXCJyYXdJbnB1dFwiIGluIGQgPyBkLnJhd0lucHV0IDogaS5yYXdJbnB1dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvazogITEsXG4gICAgICAgICAgZXJyb3I6IHlzKG8pLFxuICAgICAgICAgIG1hcmtlcjogRHJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBhID0gYXdhaXQgcygpO1xuICAgIGlmICghYSlcbiAgICAgIHRocm93IG5ldyB5ZSh7XG4gICAgICAgIGNvZGU6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG4gICAgICAgIG1lc3NhZ2U6IFwiTm8gcmVzdWx0IGZyb20gbWlkZGxld2FyZXMgLSBkaWQgeW91IGZvcmdldCB0byBgcmV0dXJuIG5leHQoKWA/XCJcbiAgICAgIH0pO1xuICAgIGlmICghYS5vaylcbiAgICAgIHRocm93IGEuZXJyb3I7XG4gICAgcmV0dXJuIGEuZGF0YTtcbiAgfTtcbiAgcmV0dXJuIGUuX2RlZiA9IHQsIGUubWV0YSA9IHQubWV0YSwgZTtcbn1cbmZ1bmN0aW9uIFNzKC4uLnQpIHtcbiAgY29uc3QgZSA9IE1yKHt9LCAuLi50Lm1hcCgoYSkgPT4gYS5fZGVmLnJlY29yZCkpLCByID0gdC5yZWR1Y2UoKGEsIGkpID0+IHtcbiAgICBpZiAoaS5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXIgJiYgaS5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXIgIT09IFBlKSB7XG4gICAgICBpZiAoYSAhPT0gUGUgJiYgYSAhPT0gaS5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBzZWVtIHRvIGhhdmUgc2V2ZXJhbCBlcnJvciBmb3JtYXR0ZXJzXCIpO1xuICAgICAgcmV0dXJuIGkuX2RlZi5fY29uZmlnLmVycm9yRm9ybWF0dGVyO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfSwgUGUpLCBuID0gdC5yZWR1Y2UoKGEsIGkpID0+IHtcbiAgICBpZiAoaS5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIgJiYgaS5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIgIT09IFNlKSB7XG4gICAgICBpZiAoYSAhPT0gU2UgJiYgYSAhPT0gaS5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBzZWVtIHRvIGhhdmUgc2V2ZXJhbCB0cmFuc2Zvcm1lcnNcIik7XG4gICAgICByZXR1cm4gaS5fZGVmLl9jb25maWcudHJhbnNmb3JtZXI7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9LCBTZSk7XG4gIHJldHVybiBMcih7XG4gICAgZXJyb3JGb3JtYXR0ZXI6IHIsXG4gICAgdHJhbnNmb3JtZXI6IG4sXG4gICAgaXNEZXY6IHQuc29tZSgoYSkgPT4gYS5fZGVmLl9jb25maWcuaXNEZXYpLFxuICAgIGFsbG93T3V0c2lkZU9mU2VydmVyOiB0LnNvbWUoKGEpID0+IGEuX2RlZi5fY29uZmlnLmFsbG93T3V0c2lkZU9mU2VydmVyKSxcbiAgICBpc1NlcnZlcjogdC5zb21lKChhKSA9PiBhLl9kZWYuX2NvbmZpZy5pc1NlcnZlciksXG4gICAgJHR5cGVzOiB0WzBdPy5fZGVmLl9jb25maWcuJHR5cGVzXG4gIH0pKGUpO1xufVxuY2xhc3MgSmUge1xuICBjb250ZXh0KCkge1xuICAgIHJldHVybiBuZXcgSmUoKTtcbiAgfVxuICBtZXRhKCkge1xuICAgIHJldHVybiBuZXcgSmUoKTtcbiAgfVxuICBjcmVhdGUoZSkge1xuICAgIHJldHVybiBBcygpKGUpO1xuICB9XG59XG5jb25zdCBQcyA9IG5ldyBKZSgpO1xuZnVuY3Rpb24gQXMoKSB7XG4gIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgY29uc3QgciA9IGU/LmVycm9yRm9ybWF0dGVyID8/IFBlLCBzID0ge1xuICAgICAgdHJhbnNmb3JtZXI6IGdzKGU/LnRyYW5zZm9ybWVyID8/IFNlKSxcbiAgICAgIGlzRGV2OiBlPy5pc0RldiA/PyBnbG9iYWxUaGlzLnByb2Nlc3M/LmVudj8uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiLFxuICAgICAgYWxsb3dPdXRzaWRlT2ZTZXJ2ZXI6IGU/LmFsbG93T3V0c2lkZU9mU2VydmVyID8/ICExLFxuICAgICAgZXJyb3JGb3JtYXR0ZXI6IHIsXG4gICAgICBpc1NlcnZlcjogZT8uaXNTZXJ2ZXIgPz8gaXIsXG4gICAgICAvKipcbiAgICAgICogQGludGVybmFsXG4gICAgICAqL1xuICAgICAgJHR5cGVzOiBVdCgoYSkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyaWVkIHRvIGFjY2VzcyBcIiR0eXBlcy4ke2F9XCIgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBhdCBydW50aW1lYCk7XG4gICAgICB9KVxuICAgIH07XG4gICAgaWYgKCEoZT8uaXNTZXJ2ZXIgPz8gaXIpICYmIGU/LmFsbG93T3V0c2lkZU9mU2VydmVyICE9PSAhMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSdyZSB0cnlpbmcgdG8gdXNlIEB0cnBjL3NlcnZlciBpbiBhIG5vbi1zZXJ2ZXIgZW52aXJvbm1lbnQuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBieSBkZWZhdWx0LlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAqIFRoZXNlIGFyZSBqdXN0IHR5cGVzLCB0aGV5IGNhbid0IGJlIHVzZWRcbiAgICAgICogQGludGVybmFsXG4gICAgICAqL1xuICAgICAgX2NvbmZpZzogcyxcbiAgICAgIC8qKlxuICAgICAgKiBCdWlsZGVyIG9iamVjdCBmb3IgY3JlYXRpbmcgcHJvY2VkdXJlc1xuICAgICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3NlcnZlci9wcm9jZWR1cmVzXG4gICAgICAqL1xuICAgICAgcHJvY2VkdXJlOiBacih7XG4gICAgICAgIG1ldGE6IGU/LmRlZmF1bHRNZXRhXG4gICAgICB9KSxcbiAgICAgIC8qKlxuICAgICAgKiBDcmVhdGUgcmV1c2FibGUgbWlkZGxld2FyZXNcbiAgICAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy9zZXJ2ZXIvbWlkZGxld2FyZXNcbiAgICAgICovXG4gICAgICBtaWRkbGV3YXJlOiBUcygpLFxuICAgICAgLyoqXG4gICAgICAqIENyZWF0ZSBhIHJvdXRlclxuICAgICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3NlcnZlci9yb3V0ZXJzXG4gICAgICAqL1xuICAgICAgcm91dGVyOiBMcihzKSxcbiAgICAgIC8qKlxuICAgICAgKiBNZXJnZSBSb3V0ZXJzXG4gICAgICAqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3Mvc2VydmVyL21lcmdpbmctcm91dGVyc1xuICAgICAgKi9cbiAgICAgIG1lcmdlUm91dGVyczogU3MsXG4gICAgICAvKipcbiAgICAgICogQ3JlYXRlIGEgc2VydmVyLXNpZGUgY2FsbGVyIGZvciBhIHJvdXRlclxuICAgICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3NlcnZlci9zZXJ2ZXItc2lkZS1jYWxsc1xuICAgICAgKi9cbiAgICAgIGNyZWF0ZUNhbGxlckZhY3Rvcnk6ICRyKClcbiAgICB9O1xuICB9O1xufVxudmFyIFJ0ID0ge30sIGF0ID0ge30sIGJlID0ge30sIFMgPSB7fTtcbmNvbnN0IHdlID0gLyogQF9fUFVSRV9fICovIGtyKFluKTtcbnZhciBxdCA9IHt9LCBVciA9IHdlO1xuZnVuY3Rpb24gV3IodCkge1xuICByZXR1cm4gVXIub2JzZXJ2YWJsZSgoZSkgPT4ge1xuICAgIGZ1bmN0aW9uIHIocyA9IDAsIGEgPSB0Lm9wKSB7XG4gICAgICBjb25zdCBpID0gdC5saW5rc1tzXTtcbiAgICAgIGlmICghaSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbW9yZSBsaW5rcyB0byBleGVjdXRlIC0gZGlkIHlvdSBmb3JnZXQgdG8gYWRkIGFuIGVuZGluZyBsaW5rP1wiKTtcbiAgICAgIHJldHVybiBpKHtcbiAgICAgICAgb3A6IGEsXG4gICAgICAgIG5leHQoYykge1xuICAgICAgICAgIHJldHVybiByKHMgKyAxLCBjKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByKCkuc3Vic2NyaWJlKGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVyKHQpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0IDogW1xuICAgIHRcbiAgXTtcbn1cbmZ1bmN0aW9uIE5zKHQpIHtcbiAgcmV0dXJuIChlKSA9PiB7XG4gICAgY29uc3QgciA9IHVyKHQudHJ1ZSkubWFwKChzKSA9PiBzKGUpKSwgbiA9IHVyKHQuZmFsc2UpLm1hcCgocykgPT4gcyhlKSk7XG4gICAgcmV0dXJuIChzKSA9PiBVci5vYnNlcnZhYmxlKChhKSA9PiB7XG4gICAgICBjb25zdCBpID0gdC5jb25kaXRpb24ocy5vcCkgPyByIDogbjtcbiAgICAgIHJldHVybiBXcih7XG4gICAgICAgIG9wOiBzLm9wLFxuICAgICAgICBsaW5rczogaVxuICAgICAgfSkuc3Vic2NyaWJlKGEpO1xuICAgIH0pO1xuICB9O1xufVxucXQuY3JlYXRlQ2hhaW4gPSBXcjtcbnF0LnNwbGl0TGluayA9IE5zO1xudmFyIHhlID0ge307XG5jb25zdCBxciA9IC8qIEBfX1BVUkVfXyAqLyBrcihzcyk7XG52YXIga2UgPSB7fTtcbmZ1bmN0aW9uIE90KHQpIHtcbiAgcmV0dXJuICEhdCAmJiAhQXJyYXkuaXNBcnJheSh0KSAmJiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gSXModCwgZSkge1xuICBpZiAoXCJlcnJvclwiIGluIHQpIHtcbiAgICBjb25zdCBuID0gZS50cmFuc2Zvcm1lci5kZXNlcmlhbGl6ZSh0LmVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgb2s6ICExLFxuICAgICAgZXJyb3I6IHtcbiAgICAgICAgLi4udCxcbiAgICAgICAgZXJyb3I6IG5cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgb2s6ICEwLFxuICAgIHJlc3VsdDoge1xuICAgICAgLi4udC5yZXN1bHQsXG4gICAgICAuLi4oIXQucmVzdWx0LnR5cGUgfHwgdC5yZXN1bHQudHlwZSA9PT0gXCJkYXRhXCIpICYmIHtcbiAgICAgICAgdHlwZTogXCJkYXRhXCIsXG4gICAgICAgIGRhdGE6IGUudHJhbnNmb3JtZXIuZGVzZXJpYWxpemUodC5yZXN1bHQuZGF0YSlcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5jbGFzcyBndCBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJVbmFibGUgdG8gdHJhbnNmb3JtIHJlc3BvbnNlIGZyb20gc2VydmVyXCIpO1xuICB9XG59XG5mdW5jdGlvbiBqcyh0LCBlKSB7XG4gIGxldCByO1xuICB0cnkge1xuICAgIHIgPSBJcyh0LCBlKTtcbiAgfSBjYXRjaCB7XG4gICAgdGhyb3cgbmV3IGd0KCk7XG4gIH1cbiAgaWYgKCFyLm9rICYmICghT3Qoci5lcnJvci5lcnJvcikgfHwgdHlwZW9mIHIuZXJyb3IuZXJyb3IuY29kZSAhPSBcIm51bWJlclwiKSlcbiAgICB0aHJvdyBuZXcgZ3QoKTtcbiAgaWYgKHIub2sgJiYgIU90KHIucmVzdWx0KSlcbiAgICB0aHJvdyBuZXcgZ3QoKTtcbiAgcmV0dXJuIHI7XG59XG5rZS5pc09iamVjdCA9IE90O1xua2UudHJhbnNmb3JtUmVzdWx0ID0ganM7XG52YXIgTHMgPSBxciwgbHIgPSBrZTtcbmZ1bmN0aW9uICRzKHQpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiB6ciB8fCAvKipcbiAgKiBAZGVwcmVjYXRlZFxuICAqIERlbGV0ZSBpbiBuZXh0IG1ham9yXG4gICovXG4gIHQgaW5zdGFuY2VvZiBFcnJvciAmJiB0Lm5hbWUgPT09IFwiVFJQQ0NsaWVudEVycm9yXCI7XG59XG5mdW5jdGlvbiBNcyh0KSB7XG4gIHJldHVybiBsci5pc09iamVjdCh0KSAmJiBsci5pc09iamVjdCh0LmVycm9yKSAmJiB0eXBlb2YgdC5lcnJvci5jb2RlID09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHQuZXJyb3IubWVzc2FnZSA9PSBcInN0cmluZ1wiO1xufVxubGV0IHpyID0gY2xhc3MgQ2UgZXh0ZW5kcyBFcnJvciB7XG4gIHN0YXRpYyBmcm9tKGUsIHIgPSB7fSkge1xuICAgIGNvbnN0IG4gPSBlO1xuICAgIHJldHVybiAkcyhuKSA/IChyLm1ldGEgJiYgKG4ubWV0YSA9IHtcbiAgICAgIC4uLm4ubWV0YSxcbiAgICAgIC4uLnIubWV0YVxuICAgIH0pLCBuKSA6IE1zKG4pID8gbmV3IENlKG4uZXJyb3IubWVzc2FnZSwge1xuICAgICAgLi4ucixcbiAgICAgIHJlc3VsdDogblxuICAgIH0pIDogbiBpbnN0YW5jZW9mIEVycm9yID8gbmV3IENlKG4ubWVzc2FnZSwge1xuICAgICAgLi4ucixcbiAgICAgIGNhdXNlOiBMcy5nZXRDYXVzZUZyb21Vbmtub3duKG4pXG4gICAgfSkgOiBuZXcgQ2UoXCJVbmtub3duIGVycm9yXCIsIHtcbiAgICAgIC4uLnIsXG4gICAgICBjYXVzZTogblxuICAgIH0pO1xuICB9XG4gIGNvbnN0cnVjdG9yKGUsIHIpIHtcbiAgICBjb25zdCBuID0gcj8uY2F1c2U7XG4gICAgc3VwZXIoZSwge1xuICAgICAgY2F1c2U6IG5cbiAgICB9KSwgdGhpcy5tZXRhID0gcj8ubWV0YSwgdGhpcy5jYXVzZSA9IG4sIHRoaXMuc2hhcGUgPSByPy5yZXN1bHQ/LmVycm9yLCB0aGlzLmRhdGEgPSByPy5yZXN1bHQ/LmVycm9yLmRhdGEsIHRoaXMubmFtZSA9IFwiVFJQQ0NsaWVudEVycm9yXCIsIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBDZS5wcm90b3R5cGUpO1xuICB9XG59O1xueGUuVFJQQ0NsaWVudEVycm9yID0genI7XG52YXIgRiA9IHt9LCBEcyA9IHhlO1xuY29uc3QgZHIgPSAodCkgPT4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiO1xuZnVuY3Rpb24gQnIodCkge1xuICBpZiAodClcbiAgICByZXR1cm4gdDtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiBkcih3aW5kb3cuZmV0Y2gpKVxuICAgIHJldHVybiB3aW5kb3cuZmV0Y2g7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiICYmIGRyKGdsb2JhbFRoaXMuZmV0Y2gpKVxuICAgIHJldHVybiBnbG9iYWxUaGlzLmZldGNoO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmZXRjaCBpbXBsZW1lbnRhdGlvbiBmb3VuZFwiKTtcbn1cbmZ1bmN0aW9uIFpzKHQpIHtcbiAgcmV0dXJuIHQgfHwgKHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cuQWJvcnRDb250cm9sbGVyID8gd2luZG93LkFib3J0Q29udHJvbGxlciA6IHR5cGVvZiBnbG9iYWxUaGlzIDwgXCJ1XCIgJiYgZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIgPyBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlciA6IG51bGwpO1xufVxuZnVuY3Rpb24gVXModCkge1xuICByZXR1cm4ge1xuICAgIHVybDogdC51cmwudG9TdHJpbmcoKS5yZXBsYWNlKC9cXC8kLywgXCJcIiksXG4gICAgZmV0Y2g6IHQuZmV0Y2gsXG4gICAgQWJvcnRDb250cm9sbGVyOiBacyh0LkFib3J0Q29udHJvbGxlcilcbiAgfTtcbn1cbmZ1bmN0aW9uIFdzKHQpIHtcbiAgY29uc3QgZSA9IHt9O1xuICBmb3IgKGxldCByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICBjb25zdCBuID0gdFtyXTtcbiAgICBlW3JdID0gbjtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmNvbnN0IHFzID0ge1xuICBxdWVyeTogXCJHRVRcIixcbiAgbXV0YXRpb246IFwiUE9TVFwiXG59O1xuZnVuY3Rpb24gVnIodCkge1xuICByZXR1cm4gXCJpbnB1dFwiIGluIHQgPyB0LnJ1bnRpbWUudHJhbnNmb3JtZXIuc2VyaWFsaXplKHQuaW5wdXQpIDogV3ModC5pbnB1dHMubWFwKChlKSA9PiB0LnJ1bnRpbWUudHJhbnNmb3JtZXIuc2VyaWFsaXplKGUpKSk7XG59XG5jb25zdCBGciA9ICh0KSA9PiB7XG4gIGxldCBlID0gdC51cmwgKyBcIi9cIiArIHQucGF0aDtcbiAgY29uc3QgciA9IFtdO1xuICBpZiAoXCJpbnB1dHNcIiBpbiB0ICYmIHIucHVzaChcImJhdGNoPTFcIiksIHQudHlwZSA9PT0gXCJxdWVyeVwiKSB7XG4gICAgY29uc3QgbiA9IFZyKHQpO1xuICAgIG4gIT09IHZvaWQgMCAmJiByLnB1c2goYGlucHV0PSR7ZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KG4pKX1gKTtcbiAgfVxuICByZXR1cm4gci5sZW5ndGggJiYgKGUgKz0gXCI/XCIgKyByLmpvaW4oXCImXCIpKSwgZTtcbn0sIEhyID0gKHQpID0+IHtcbiAgaWYgKHQudHlwZSA9PT0gXCJxdWVyeVwiKVxuICAgIHJldHVybjtcbiAgY29uc3QgZSA9IFZyKHQpO1xuICByZXR1cm4gZSAhPT0gdm9pZCAwID8gSlNPTi5zdHJpbmdpZnkoZSkgOiB2b2lkIDA7XG59LCB6cyA9ICh0KSA9PiBKcih7XG4gIC4uLnQsXG4gIGNvbnRlbnRUeXBlSGVhZGVyOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgZ2V0VXJsOiBGcixcbiAgZ2V0Qm9keTogSHJcbn0pO1xuYXN5bmMgZnVuY3Rpb24gR3IodCwgZSkge1xuICBjb25zdCByID0gdC5nZXRVcmwodCksIG4gPSB0LmdldEJvZHkodCksIHsgdHlwZTogcyB9ID0gdCwgYSA9IGF3YWl0IHQuaGVhZGVycygpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLS0gQHByZXNlcnZlICovXG4gIGlmIChzID09PSBcInN1YnNjcmlwdGlvblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlN1YnNjcmlwdGlvbnMgc2hvdWxkIHVzZSB3c0xpbmtcIik7XG4gIGNvbnN0IGkgPSB7XG4gICAgLi4udC5jb250ZW50VHlwZUhlYWRlciA/IHtcbiAgICAgIFwiY29udGVudC10eXBlXCI6IHQuY29udGVudFR5cGVIZWFkZXJcbiAgICB9IDoge30sXG4gICAgLi4udC5iYXRjaE1vZGVIZWFkZXIgPyB7XG4gICAgICBcInRycGMtYmF0Y2gtbW9kZVwiOiB0LmJhdGNoTW9kZUhlYWRlclxuICAgIH0gOiB7fSxcbiAgICAuLi5hXG4gIH07XG4gIHJldHVybiBCcih0LmZldGNoKShyLCB7XG4gICAgbWV0aG9kOiBxc1tzXSxcbiAgICBzaWduYWw6IGU/LnNpZ25hbCxcbiAgICBib2R5OiBuLFxuICAgIGhlYWRlcnM6IGlcbiAgfSk7XG59XG5mdW5jdGlvbiBKcih0KSB7XG4gIGNvbnN0IGUgPSB0LkFib3J0Q29udHJvbGxlciA/IG5ldyB0LkFib3J0Q29udHJvbGxlcigpIDogbnVsbCwgciA9IHt9O1xuICBsZXQgbiA9ICExO1xuICByZXR1cm4ge1xuICAgIHByb21pc2U6IG5ldyBQcm9taXNlKChpLCBvKSA9PiB7XG4gICAgICBHcih0LCBlKS50aGVuKChjKSA9PiAoci5yZXNwb25zZSA9IGMsIG4gPSAhMCwgYy5qc29uKCkpKS50aGVuKChjKSA9PiB7XG4gICAgICAgIHIucmVzcG9uc2VKU09OID0gYywgaSh7XG4gICAgICAgICAganNvbjogYyxcbiAgICAgICAgICBtZXRhOiByXG4gICAgICAgIH0pO1xuICAgICAgfSkuY2F0Y2goKGMpID0+IHtcbiAgICAgICAgbiA9ICEwLCBvKERzLlRSUENDbGllbnRFcnJvci5mcm9tKGMsIHtcbiAgICAgICAgICBtZXRhOiByXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgbiB8fCBlPy5hYm9ydCgpO1xuICAgIH1cbiAgfTtcbn1cbkYuZmV0Y2hIVFRQUmVzcG9uc2UgPSBHcjtcbkYuZ2V0Qm9keSA9IEhyO1xuRi5nZXRGZXRjaCA9IEJyO1xuRi5nZXRVcmwgPSBGcjtcbkYuaHR0cFJlcXVlc3QgPSBKcjtcbkYuanNvbkh0dHBSZXF1ZXN0ZXIgPSB6cztcbkYucmVzb2x2ZUhUVFBMaW5rT3B0aW9ucyA9IFVzO1xudmFyIHp0ID0ge30sIEJzID0gd2UsIFZzID0ga2UsIGZyID0geGUsIFN0ID0gRjtcbmNvbnN0IF90ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJTb21ldGhpbmcgd2VudCB3cm9uZy4gUGxlYXNlIHN1Ym1pdCBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vdHJwYy90cnBjL2lzc3Vlcy9uZXdcIik7XG59O1xuZnVuY3Rpb24gdnQodCkge1xuICBsZXQgZSA9IG51bGwsIHIgPSBudWxsO1xuICBjb25zdCBuID0gKCkgPT4ge1xuICAgIGNsZWFyVGltZW91dChyKSwgciA9IG51bGwsIGUgPSBudWxsO1xuICB9O1xuICBmdW5jdGlvbiBzKG8pIHtcbiAgICBjb25zdCBjID0gW1xuICAgICAgW11cbiAgICBdO1xuICAgIGxldCB1ID0gMDtcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGNvbnN0IGQgPSBvW3VdO1xuICAgICAgaWYgKCFkKVxuICAgICAgICBicmVhaztcbiAgICAgIGNvbnN0IGggPSBjW2MubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoZC5hYm9ydGVkKSB7XG4gICAgICAgIGQucmVqZWN0Py4obmV3IEVycm9yKFwiQWJvcnRlZFwiKSksIHUrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodC52YWxpZGF0ZShoLmNvbmNhdChkKS5tYXAoKGspID0+IGsua2V5KSkpIHtcbiAgICAgICAgaC5wdXNoKGQpLCB1Kys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGQucmVqZWN0Py4obmV3IEVycm9yKFwiSW5wdXQgaXMgdG9vIGJpZyBmb3IgYSBzaW5nbGUgZGlzcGF0Y2hcIikpLCB1Kys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYy5wdXNoKFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH1cbiAgZnVuY3Rpb24gYSgpIHtcbiAgICBjb25zdCBvID0gcyhlKTtcbiAgICBuKCk7XG4gICAgZm9yIChjb25zdCBjIG9mIG8pIHtcbiAgICAgIGlmICghYy5sZW5ndGgpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdSA9IHtcbiAgICAgICAgaXRlbXM6IGMsXG4gICAgICAgIGNhbmNlbDogX3RcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGsgb2YgYylcbiAgICAgICAgay5iYXRjaCA9IHU7XG4gICAgICBjb25zdCBkID0gKGssIFQpID0+IHtcbiAgICAgICAgY29uc3QgQSA9IHUuaXRlbXNba107XG4gICAgICAgIEEucmVzb2x2ZT8uKFQpLCBBLmJhdGNoID0gbnVsbCwgQS5yZWplY3QgPSBudWxsLCBBLnJlc29sdmUgPSBudWxsO1xuICAgICAgfSwgeyBwcm9taXNlOiBoLCBjYW5jZWw6IHkgfSA9IHQuZmV0Y2godS5pdGVtcy5tYXAoKGspID0+IGsua2V5KSwgZCk7XG4gICAgICB1LmNhbmNlbCA9IHksIGgudGhlbigoaykgPT4ge1xuICAgICAgICBmb3IgKGxldCBUID0gMDsgVCA8IGsubGVuZ3RoOyBUKyspIHtcbiAgICAgICAgICBjb25zdCBBID0ga1tUXTtcbiAgICAgICAgICBkKFQsIEEpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgVCBvZiB1Lml0ZW1zKVxuICAgICAgICAgIFQucmVqZWN0Py4obmV3IEVycm9yKFwiTWlzc2luZyByZXN1bHRcIikpLCBULmJhdGNoID0gbnVsbDtcbiAgICAgIH0pLmNhdGNoKChrKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgVCBvZiB1Lml0ZW1zKVxuICAgICAgICAgIFQucmVqZWN0Py4oayksIFQuYmF0Y2ggPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGkobykge1xuICAgIGNvbnN0IGMgPSB7XG4gICAgICBhYm9ydGVkOiAhMSxcbiAgICAgIGtleTogbyxcbiAgICAgIGJhdGNoOiBudWxsLFxuICAgICAgcmVzb2x2ZTogX3QsXG4gICAgICByZWplY3Q6IF90XG4gICAgfSwgdSA9IG5ldyBQcm9taXNlKChoLCB5KSA9PiB7XG4gICAgICBjLnJlamVjdCA9IHksIGMucmVzb2x2ZSA9IGgsIGUgfHwgKGUgPSBbXSksIGUucHVzaChjKTtcbiAgICB9KTtcbiAgICByZXR1cm4gciB8fCAociA9IHNldFRpbWVvdXQoYSkpLCB7XG4gICAgICBwcm9taXNlOiB1LFxuICAgICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICAgIGMuYWJvcnRlZCA9ICEwLCBjLmJhdGNoPy5pdGVtcy5ldmVyeSgoaCkgPT4gaC5hYm9ydGVkKSAmJiAoYy5iYXRjaC5jYW5jZWwoKSwgYy5iYXRjaCA9IG51bGwpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsb2FkOiBpXG4gIH07XG59XG5mdW5jdGlvbiBZcih0KSB7XG4gIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgY29uc3QgbiA9IFN0LnJlc29sdmVIVFRQTGlua09wdGlvbnMociksIHMgPSByLm1heFVSTExlbmd0aCA/PyAxIC8gMDtcbiAgICByZXR1cm4gKGEpID0+IHtcbiAgICAgIGNvbnN0IGkgPSAoaCkgPT4ge1xuICAgICAgICBjb25zdCB5ID0gKFQpID0+IHtcbiAgICAgICAgICBpZiAocyA9PT0gMSAvIDApXG4gICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgY29uc3QgQSA9IFQubWFwKChIKSA9PiBILnBhdGgpLmpvaW4oXCIsXCIpLCBsZSA9IFQubWFwKChIKSA9PiBILmlucHV0KTtcbiAgICAgICAgICByZXR1cm4gU3QuZ2V0VXJsKHtcbiAgICAgICAgICAgIC4uLm4sXG4gICAgICAgICAgICBydW50aW1lOiBhLFxuICAgICAgICAgICAgdHlwZTogaCxcbiAgICAgICAgICAgIHBhdGg6IEEsXG4gICAgICAgICAgICBpbnB1dHM6IGxlXG4gICAgICAgICAgfSkubGVuZ3RoIDw9IHM7XG4gICAgICAgIH0sIGsgPSB0KHtcbiAgICAgICAgICAuLi5uLFxuICAgICAgICAgIHJ1bnRpbWU6IGEsXG4gICAgICAgICAgdHlwZTogaCxcbiAgICAgICAgICBvcHRzOiByXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkYXRlOiB5LFxuICAgICAgICAgIGZldGNoOiBrXG4gICAgICAgIH07XG4gICAgICB9LCBvID0gdnQoaShcInF1ZXJ5XCIpKSwgYyA9IHZ0KGkoXCJtdXRhdGlvblwiKSksIHUgPSB2dChpKFwic3Vic2NyaXB0aW9uXCIpKSwgZCA9IHtcbiAgICAgICAgcXVlcnk6IG8sXG4gICAgICAgIHN1YnNjcmlwdGlvbjogdSxcbiAgICAgICAgbXV0YXRpb246IGNcbiAgICAgIH07XG4gICAgICByZXR1cm4gKHsgb3A6IGggfSkgPT4gQnMub2JzZXJ2YWJsZSgoeSkgPT4ge1xuICAgICAgICBjb25zdCBrID0gZFtoLnR5cGVdLCB7IHByb21pc2U6IFQsIGNhbmNlbDogQSB9ID0gay5sb2FkKGgpO1xuICAgICAgICBsZXQgbGU7XG4gICAgICAgIHJldHVybiBULnRoZW4oKCQpID0+IHtcbiAgICAgICAgICBsZSA9ICQ7XG4gICAgICAgICAgY29uc3QgSCA9IFZzLnRyYW5zZm9ybVJlc3VsdCgkLmpzb24sIGEpO1xuICAgICAgICAgIGlmICghSC5vaykge1xuICAgICAgICAgICAgeS5lcnJvcihmci5UUlBDQ2xpZW50RXJyb3IuZnJvbShILmVycm9yLCB7XG4gICAgICAgICAgICAgIG1ldGE6ICQubWV0YVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5Lm5leHQoe1xuICAgICAgICAgICAgY29udGV4dDogJC5tZXRhLFxuICAgICAgICAgICAgcmVzdWx0OiBILnJlc3VsdFxuICAgICAgICAgIH0pLCB5LmNvbXBsZXRlKCk7XG4gICAgICAgIH0pLmNhdGNoKCgkKSA9PiB7XG4gICAgICAgICAgeS5lcnJvcihmci5UUlBDQ2xpZW50RXJyb3IuZnJvbSgkLCB7XG4gICAgICAgICAgICBtZXRhOiBsZT8ubWV0YVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSksICgpID0+IHtcbiAgICAgICAgICBBKCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufVxuY29uc3QgRnMgPSAodCkgPT4gKGUpID0+IHtcbiAgY29uc3QgciA9IGUubWFwKChpKSA9PiBpLnBhdGgpLmpvaW4oXCIsXCIpLCBuID0gZS5tYXAoKGkpID0+IGkuaW5wdXQpLCB7IHByb21pc2U6IHMsIGNhbmNlbDogYSB9ID0gU3QuanNvbkh0dHBSZXF1ZXN0ZXIoe1xuICAgIC4uLnQsXG4gICAgcGF0aDogcixcbiAgICBpbnB1dHM6IG4sXG4gICAgaGVhZGVycygpIHtcbiAgICAgIHJldHVybiB0Lm9wdHMuaGVhZGVycyA/IHR5cGVvZiB0Lm9wdHMuaGVhZGVycyA9PSBcImZ1bmN0aW9uXCIgPyB0Lm9wdHMuaGVhZGVycyh7XG4gICAgICAgIG9wTGlzdDogZVxuICAgICAgfSkgOiB0Lm9wdHMuaGVhZGVycyA6IHt9O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZTogcy50aGVuKChpKSA9PiAoQXJyYXkuaXNBcnJheShpLmpzb24pID8gaS5qc29uIDogZS5tYXAoKCkgPT4gaS5qc29uKSkubWFwKCh1KSA9PiAoe1xuICAgICAgbWV0YTogaS5tZXRhLFxuICAgICAganNvbjogdVxuICAgIH0pKSksXG4gICAgY2FuY2VsOiBhXG4gIH07XG59LCBIcyA9IFlyKEZzKTtcbnp0LmNyZWF0ZUhUVFBCYXRjaExpbmsgPSBZcjtcbnp0Lmh0dHBCYXRjaExpbmsgPSBIcztcbnZhciBpdCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgR3MgPSB3ZSwgSnMgPSBrZSwgcHIgPSB4ZSwgWHIgPSBGO1xuZnVuY3Rpb24gUXIodCkge1xuICByZXR1cm4gKGUpID0+IHtcbiAgICBjb25zdCByID0gWHIucmVzb2x2ZUhUVFBMaW5rT3B0aW9ucyhlKTtcbiAgICByZXR1cm4gKG4pID0+ICh7IG9wOiBzIH0pID0+IEdzLm9ic2VydmFibGUoKGEpID0+IHtcbiAgICAgIGNvbnN0IHsgcGF0aDogaSwgaW5wdXQ6IG8sIHR5cGU6IGMgfSA9IHMsIHsgcHJvbWlzZTogdSwgY2FuY2VsOiBkIH0gPSB0LnJlcXVlc3Rlcih7XG4gICAgICAgIC4uLnIsXG4gICAgICAgIHJ1bnRpbWU6IG4sXG4gICAgICAgIHR5cGU6IGMsXG4gICAgICAgIHBhdGg6IGksXG4gICAgICAgIGlucHV0OiBvLFxuICAgICAgICBoZWFkZXJzKCkge1xuICAgICAgICAgIHJldHVybiBlLmhlYWRlcnMgPyB0eXBlb2YgZS5oZWFkZXJzID09IFwiZnVuY3Rpb25cIiA/IGUuaGVhZGVycyh7XG4gICAgICAgICAgICBvcDogc1xuICAgICAgICAgIH0pIDogZS5oZWFkZXJzIDoge307XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGV0IGg7XG4gICAgICByZXR1cm4gdS50aGVuKCh5KSA9PiB7XG4gICAgICAgIGggPSB5Lm1ldGE7XG4gICAgICAgIGNvbnN0IGsgPSBKcy50cmFuc2Zvcm1SZXN1bHQoeS5qc29uLCBuKTtcbiAgICAgICAgaWYgKCFrLm9rKSB7XG4gICAgICAgICAgYS5lcnJvcihwci5UUlBDQ2xpZW50RXJyb3IuZnJvbShrLmVycm9yLCB7XG4gICAgICAgICAgICBtZXRhOiBoXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhLm5leHQoe1xuICAgICAgICAgIGNvbnRleHQ6IHkubWV0YSxcbiAgICAgICAgICByZXN1bHQ6IGsucmVzdWx0XG4gICAgICAgIH0pLCBhLmNvbXBsZXRlKCk7XG4gICAgICB9KS5jYXRjaCgoeSkgPT4ge1xuICAgICAgICBhLmVycm9yKHByLlRSUENDbGllbnRFcnJvci5mcm9tKHksIHtcbiAgICAgICAgICBtZXRhOiBoXG4gICAgICAgIH0pKTtcbiAgICAgIH0pLCAoKSA9PiB7XG4gICAgICAgIGQoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG59XG5jb25zdCBZcyA9IFFyKHtcbiAgcmVxdWVzdGVyOiBYci5qc29uSHR0cFJlcXVlc3RlclxufSk7XG5pdC5odHRwTGluayA9IFlzO1xuaXQuaHR0cExpbmtGYWN0b3J5ID0gUXI7XG52YXIgQnQgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGhyID0gd2U7XG5mdW5jdGlvbiBYcyh0KSB7XG4gIHJldHVybiB0eXBlb2YgRm9ybURhdGEgPiBcInVcIiA/ICExIDogdCBpbnN0YW5jZW9mIEZvcm1EYXRhO1xufVxuY29uc3QgYnQgPSB7XG4gIGNzczoge1xuICAgIHF1ZXJ5OiBbXG4gICAgICBcIjcyZTNmZlwiLFxuICAgICAgXCIzZmIwZDhcIlxuICAgIF0sXG4gICAgbXV0YXRpb246IFtcbiAgICAgIFwiYzVhM2ZjXCIsXG4gICAgICBcIjkwNGRmY1wiXG4gICAgXSxcbiAgICBzdWJzY3JpcHRpb246IFtcbiAgICAgIFwiZmY0OWUxXCIsXG4gICAgICBcImQ4M2ZiZVwiXG4gICAgXVxuICB9LFxuICBhbnNpOiB7XG4gICAgcmVndWxhcjoge1xuICAgICAgLy8gQ3lhbiBiYWNrZ3JvdW5kLCBibGFjayBhbmQgd2hpdGUgdGV4dCByZXNwZWN0aXZlbHlcbiAgICAgIHF1ZXJ5OiBbXG4gICAgICAgIFwiXFx4MUJbMzA7NDZtXCIsXG4gICAgICAgIFwiXFx4MUJbOTc7NDZtXCJcbiAgICAgIF0sXG4gICAgICAvLyBNYWdlbnRhIGJhY2tncm91bmQsIGJsYWNrIGFuZCB3aGl0ZSB0ZXh0IHJlc3BlY3RpdmVseVxuICAgICAgbXV0YXRpb246IFtcbiAgICAgICAgXCJcXHgxQlszMDs0NW1cIixcbiAgICAgICAgXCJcXHgxQls5Nzs0NW1cIlxuICAgICAgXSxcbiAgICAgIC8vIEdyZWVuIGJhY2tncm91bmQsIGJsYWNrIGFuZCB3aGl0ZSB0ZXh0IHJlc3BlY3RpdmVseVxuICAgICAgc3Vic2NyaXB0aW9uOiBbXG4gICAgICAgIFwiXFx4MUJbMzA7NDJtXCIsXG4gICAgICAgIFwiXFx4MUJbOTc7NDJtXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIGJvbGQ6IHtcbiAgICAgIHF1ZXJ5OiBbXG4gICAgICAgIFwiXFx4MUJbMTszMDs0Nm1cIixcbiAgICAgICAgXCJcXHgxQlsxOzk3OzQ2bVwiXG4gICAgICBdLFxuICAgICAgbXV0YXRpb246IFtcbiAgICAgICAgXCJcXHgxQlsxOzMwOzQ1bVwiLFxuICAgICAgICBcIlxceDFCWzE7OTc7NDVtXCJcbiAgICAgIF0sXG4gICAgICBzdWJzY3JpcHRpb246IFtcbiAgICAgICAgXCJcXHgxQlsxOzMwOzQybVwiLFxuICAgICAgICBcIlxceDFCWzE7OTc7NDJtXCJcbiAgICAgIF1cbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBRcyh0KSB7XG4gIGNvbnN0IHsgZGlyZWN0aW9uOiBlLCB0eXBlOiByLCBwYXRoOiBuLCBpZDogcywgaW5wdXQ6IGEgfSA9IHQsIGkgPSBbXSwgbyA9IFtdO1xuICBpZiAodC5jb2xvck1vZGUgPT09IFwiYW5zaVwiKSB7XG4gICAgY29uc3QgW2gsIHldID0gYnQuYW5zaS5yZWd1bGFyW3JdLCBbaywgVF0gPSBidC5hbnNpLmJvbGRbcl0sIEEgPSBcIlxceDFCWzBtXCI7XG4gICAgcmV0dXJuIGkucHVzaChlID09PSBcInVwXCIgPyBoIDogeSwgZSA9PT0gXCJ1cFwiID8gXCI+PlwiIDogXCI8PFwiLCByLCBlID09PSBcInVwXCIgPyBrIDogVCwgYCMke3N9YCwgbiwgQSksIGUgPT09IFwidXBcIiA/IG8ucHVzaCh7XG4gICAgICBpbnB1dDogdC5pbnB1dFxuICAgIH0pIDogby5wdXNoKHtcbiAgICAgIGlucHV0OiB0LmlucHV0LFxuICAgICAgLy8gc3RyaXAgY29udGV4dCBmcm9tIHJlc3VsdCBjYXVzZSBpdCdzIHRvbyBub2lzeSBpbiB0ZXJtaW5hbCB3aWh0b3V0IGNvbGxhcHNlIG1vZGVcbiAgICAgIHJlc3VsdDogXCJyZXN1bHRcIiBpbiB0LnJlc3VsdCA/IHQucmVzdWx0LnJlc3VsdCA6IHQucmVzdWx0LFxuICAgICAgZWxhcHNlZE1zOiB0LmVsYXBzZWRNc1xuICAgIH0pLCB7XG4gICAgICBwYXJ0czogaSxcbiAgICAgIGFyZ3M6IG9cbiAgICB9O1xuICB9XG4gIGNvbnN0IFtjLCB1XSA9IGJ0LmNzc1tyXSwgZCA9IGBcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjJHtlID09PSBcInVwXCIgPyBjIDogdX07IFxuICAgIGNvbG9yOiAke2UgPT09IFwidXBcIiA/IFwiYmxhY2tcIiA6IFwid2hpdGVcIn07XG4gICAgcGFkZGluZzogMnB4O1xuICBgO1xuICByZXR1cm4gaS5wdXNoKFwiJWNcIiwgZSA9PT0gXCJ1cFwiID8gXCI+PlwiIDogXCI8PFwiLCByLCBgIyR7c31gLCBgJWMke259JWNgLCBcIiVPXCIpLCBvLnB1c2goZCwgYCR7ZH07IGZvbnQtd2VpZ2h0OiBib2xkO2AsIGAke2R9OyBmb250LXdlaWdodDogbm9ybWFsO2ApLCBlID09PSBcInVwXCIgPyBvLnB1c2goe1xuICAgIGlucHV0OiBhLFxuICAgIGNvbnRleHQ6IHQuY29udGV4dFxuICB9KSA6IG8ucHVzaCh7XG4gICAgaW5wdXQ6IGEsXG4gICAgcmVzdWx0OiB0LnJlc3VsdCxcbiAgICBlbGFwc2VkTXM6IHQuZWxhcHNlZE1zLFxuICAgIGNvbnRleHQ6IHQuY29udGV4dFxuICB9KSwge1xuICAgIHBhcnRzOiBpLFxuICAgIGFyZ3M6IG9cbiAgfTtcbn1cbmNvbnN0IEtzID0gKHsgYzogdCA9IGNvbnNvbGUsIGNvbG9yTW9kZTogZSA9IFwiY3NzXCIgfSkgPT4gKHIpID0+IHtcbiAgY29uc3QgbiA9IHIuaW5wdXQsIHMgPSBYcyhuKSA/IE9iamVjdC5mcm9tRW50cmllcyhuKSA6IG4sIHsgcGFydHM6IGEsIGFyZ3M6IGkgfSA9IFFzKHtcbiAgICAuLi5yLFxuICAgIGNvbG9yTW9kZTogZSxcbiAgICBpbnB1dDogc1xuICB9KSwgbyA9IHIuZGlyZWN0aW9uID09PSBcImRvd25cIiAmJiByLnJlc3VsdCAmJiAoci5yZXN1bHQgaW5zdGFuY2VvZiBFcnJvciB8fCBcImVycm9yXCIgaW4gci5yZXN1bHQucmVzdWx0KSA/IFwiZXJyb3JcIiA6IFwibG9nXCI7XG4gIHRbb10uYXBwbHkobnVsbCwgW1xuICAgIGEuam9pbihcIiBcIilcbiAgXS5jb25jYXQoaSkpO1xufTtcbmZ1bmN0aW9uIGVhKHQgPSB7fSkge1xuICBjb25zdCB7IGVuYWJsZWQ6IGUgPSAoKSA9PiAhMCB9ID0gdCwgciA9IHQuY29sb3JNb2RlID8/ICh0eXBlb2Ygd2luZG93ID4gXCJ1XCIgPyBcImFuc2lcIiA6IFwiY3NzXCIpLCB7IGxvZ2dlcjogbiA9IEtzKHtcbiAgICBjOiB0LmNvbnNvbGUsXG4gICAgY29sb3JNb2RlOiByXG4gIH0pIH0gPSB0O1xuICByZXR1cm4gKCkgPT4gKHsgb3A6IHMsIG5leHQ6IGEgfSkgPT4gaHIub2JzZXJ2YWJsZSgoaSkgPT4ge1xuICAgIGUoe1xuICAgICAgLi4ucyxcbiAgICAgIGRpcmVjdGlvbjogXCJ1cFwiXG4gICAgfSkgJiYgbih7XG4gICAgICAuLi5zLFxuICAgICAgZGlyZWN0aW9uOiBcInVwXCJcbiAgICB9KTtcbiAgICBjb25zdCBvID0gRGF0ZS5ub3coKTtcbiAgICBmdW5jdGlvbiBjKHUpIHtcbiAgICAgIGNvbnN0IGQgPSBEYXRlLm5vdygpIC0gbztcbiAgICAgIGUoe1xuICAgICAgICAuLi5zLFxuICAgICAgICBkaXJlY3Rpb246IFwiZG93blwiLFxuICAgICAgICByZXN1bHQ6IHVcbiAgICAgIH0pICYmIG4oe1xuICAgICAgICAuLi5zLFxuICAgICAgICBkaXJlY3Rpb246IFwiZG93blwiLFxuICAgICAgICBlbGFwc2VkTXM6IGQsXG4gICAgICAgIHJlc3VsdDogdVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhKHMpLnBpcGUoaHIudGFwKHtcbiAgICAgIG5leHQodSkge1xuICAgICAgICBjKHUpO1xuICAgICAgfSxcbiAgICAgIGVycm9yKHUpIHtcbiAgICAgICAgYyh1KTtcbiAgICAgIH1cbiAgICB9KSkuc3Vic2NyaWJlKGkpO1xuICB9KTtcbn1cbkJ0LmxvZ2dlckxpbmsgPSBlYTtcbnZhciBvdCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KG90LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgdGEgPSB3ZSwgcmEgPSBrZSwgS3IgPSB4ZTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0tIEBwcmVzZXJ2ZSAqL1xuY29uc3QgbmEgPSAodCkgPT4gdCA9PT0gMCA/IDAgOiBNYXRoLm1pbigxZTMgKiAyICoqIHQsIDNlNCk7XG5mdW5jdGlvbiBzYSh0KSB7XG4gIGNvbnN0IHsgdXJsOiBlLCBXZWJTb2NrZXQ6IHIgPSBXZWJTb2NrZXQsIHJldHJ5RGVsYXlNczogbiA9IG5hLCBvbk9wZW46IHMsIG9uQ2xvc2U6IGEgfSA9IHQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0tIEBwcmVzZXJ2ZSAqL1xuICBpZiAoIXIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIGZvdW5kIC0geW91IHByb2JhYmx5IGRvbid0IHdhbnQgdG8gdXNlIHRoaXMgb24gdGhlIHNlcnZlciwgYnV0IGlmIHlvdSBkbyB5b3UgbmVlZCB0byBwYXNzIGEgYFdlYlNvY2tldGAtcG9ueWZpbGxcIik7XG4gIGxldCBpID0gW107XG4gIGNvbnN0IG8gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IGMgPSAwLCB1ID0gbnVsbCwgZCA9IG51bGwsIGggPSBRdCgpLCB5ID0gXCJjb25uZWN0aW5nXCI7XG4gIGZ1bmN0aW9uIGsoKSB7XG4gICAgeSAhPT0gXCJvcGVuXCIgfHwgdSB8fCAodSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdSA9IG51bGwsIGkubGVuZ3RoID09PSAxID8gaC5zZW5kKEpTT04uc3RyaW5naWZ5KGkucG9wKCkpKSA6IGguc2VuZChKU09OLnN0cmluZ2lmeShpKSksIGkgPSBbXTtcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gVCgpIHtcbiAgICBpZiAoZCAhPT0gbnVsbCB8fCB5ID09PSBcImNsb3NlZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IFIgPSBuKGMrKyk7XG4gICAgbGUoUik7XG4gIH1cbiAgZnVuY3Rpb24gQSgpIHtcbiAgICB5ID0gXCJjb25uZWN0aW5nXCI7XG4gICAgY29uc3QgUiA9IGg7XG4gICAgaCA9IFF0KCksICQoUik7XG4gIH1cbiAgZnVuY3Rpb24gbGUoUikge1xuICAgIGQgfHwgKHkgPSBcImNvbm5lY3RpbmdcIiwgZCA9IHNldFRpbWVvdXQoQSwgUikpO1xuICB9XG4gIGZ1bmN0aW9uICQoUikge1xuICAgIE9iamVjdC52YWx1ZXMobykuc29tZSgoZGUpID0+IGRlLndzID09PSBSKSB8fCBSLmNsb3NlKCk7XG4gIH1cbiAgZnVuY3Rpb24gSCgpIHtcbiAgICBPYmplY3QudmFsdWVzKG8pLmZvckVhY2goKFIpID0+IHtcbiAgICAgIFIudHlwZSA9PT0gXCJzdWJzY3JpcHRpb25cIiAmJiBSLmNhbGxiYWNrcy5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIFh0KFIpIHtcbiAgICBpLnNvbWUoKFApID0+IFAuaWQgPT09IFIub3AuaWQpIHx8IEt0KFIub3AsIFIuY2FsbGJhY2tzKTtcbiAgfVxuICBmdW5jdGlvbiBRdCgpIHtcbiAgICBjb25zdCBSID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSgpIDogZSwgUCA9IG5ldyByKFIpO1xuICAgIGNsZWFyVGltZW91dChkKSwgZCA9IG51bGwsIFAuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLS0gQHByZXNlcnZlICovXG4gICAgICBQID09PSBoICYmIChjID0gMCwgeSA9IFwib3BlblwiLCBzPy4oKSwgaygpKTtcbiAgICB9KSwgUC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgUCA9PT0gaCAmJiBUKCk7XG4gICAgfSk7XG4gICAgY29uc3QgZGUgPSAoaikgPT4ge1xuICAgICAgaWYgKGoubWV0aG9kID09PSBcInJlY29ubmVjdFwiICYmIFAgPT09IGgpIHtcbiAgICAgICAgeSA9PT0gXCJvcGVuXCIgJiYgYT8uKCksIEEoKTtcbiAgICAgICAgZm9yIChjb25zdCBFIG9mIE9iamVjdC52YWx1ZXMobykpXG4gICAgICAgICAgRS50eXBlID09PSBcInN1YnNjcmlwdGlvblwiICYmIFh0KEUpO1xuICAgICAgfVxuICAgIH0sIHB0ID0gKGopID0+IHtcbiAgICAgIGNvbnN0IEUgPSBqLmlkICE9PSBudWxsICYmIG9bai5pZF07XG4gICAgICBpZiAoRSkge1xuICAgICAgICBpZiAoRS5jYWxsYmFja3MubmV4dD8uKGopLCBFLndzICE9PSBoICYmIFAgPT09IGgpIHtcbiAgICAgICAgICBjb25zdCBHID0gRS53cztcbiAgICAgICAgICBFLndzID0gaCwgJChHKTtcbiAgICAgICAgfVxuICAgICAgICBcInJlc3VsdFwiIGluIGogJiYgai5yZXN1bHQudHlwZSA9PT0gXCJzdG9wcGVkXCIgJiYgUCA9PT0gaCAmJiBFLmNhbGxiYWNrcy5jb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFAuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKHsgZGF0YTogaiB9KSA9PiB7XG4gICAgICBjb25zdCBFID0gSlNPTi5wYXJzZShqKTtcbiAgICAgIFwibWV0aG9kXCIgaW4gRSA/IGRlKEUpIDogcHQoRSksIChQICE9PSBoIHx8IHkgPT09IFwiY2xvc2VkXCIpICYmICQoUCk7XG4gICAgfSksIFAuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsICh7IGNvZGU6IGogfSkgPT4ge1xuICAgICAgeSA9PT0gXCJvcGVuXCIgJiYgYT8uKHtcbiAgICAgICAgY29kZTogalxuICAgICAgfSksIGggPT09IFAgJiYgVCgpO1xuICAgICAgZm9yIChjb25zdCBbRSwgR10gb2YgT2JqZWN0LmVudHJpZXMobykpXG4gICAgICAgIGlmIChHLndzID09PSBQKSB7XG4gICAgICAgICAgaWYgKHkgPT09IFwiY2xvc2VkXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvW0VdLCBHLmNhbGxiYWNrcy5jb21wbGV0ZT8uKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgRy50eXBlID09PSBcInN1YnNjcmlwdGlvblwiID8gWHQoRykgOiAoZGVsZXRlIG9bRV0sIEcuY2FsbGJhY2tzLmVycm9yPy4oS3IuVFJQQ0NsaWVudEVycm9yLmZyb20obmV3IFZ0KFwiV2ViU29ja2V0IGNsb3NlZCBwcmVtYXR1cmVseVwiKSkpKTtcbiAgICAgICAgfVxuICAgIH0pLCBQO1xuICB9XG4gIGZ1bmN0aW9uIEt0KFIsIFApIHtcbiAgICBjb25zdCB7IHR5cGU6IGRlLCBpbnB1dDogcHQsIHBhdGg6IGosIGlkOiBFIH0gPSBSLCBHID0ge1xuICAgICAgaWQ6IEUsXG4gICAgICBtZXRob2Q6IGRlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGlucHV0OiBwdCxcbiAgICAgICAgcGF0aDogalxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG9bRV0gPSB7XG4gICAgICB3czogaCxcbiAgICAgIHR5cGU6IGRlLFxuICAgICAgY2FsbGJhY2tzOiBQLFxuICAgICAgb3A6IFJcbiAgICB9LCBpLnB1c2goRyksIGsoKSwgKCkgPT4ge1xuICAgICAgY29uc3QgQ24gPSBvW0VdPy5jYWxsYmFja3M7XG4gICAgICBkZWxldGUgb1tFXSwgaSA9IGkuZmlsdGVyKChSbikgPT4gUm4uaWQgIT09IEUpLCBDbj8uY29tcGxldGU/LigpLCBoLnJlYWR5U3RhdGUgPT09IHIuT1BFTiAmJiBSLnR5cGUgPT09IFwic3Vic2NyaXB0aW9uXCIgJiYgKGkucHVzaCh7XG4gICAgICAgIGlkOiBFLFxuICAgICAgICBtZXRob2Q6IFwic3Vic2NyaXB0aW9uLnN0b3BcIlxuICAgICAgfSksIGsoKSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICB5ID0gXCJjbG9zZWRcIiwgYT8uKCksIEgoKSwgJChoKSwgY2xlYXJUaW1lb3V0KGQpLCBkID0gbnVsbDtcbiAgICB9LFxuICAgIHJlcXVlc3Q6IEt0LFxuICAgIGdldENvbm5lY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaDtcbiAgICB9XG4gIH07XG59XG5jbGFzcyBWdCBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLm5hbWUgPSBcIlRSUENXZWJTb2NrZXRDbG9zZWRFcnJvclwiLCBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVnQucHJvdG90eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gYWEodCkge1xuICByZXR1cm4gKGUpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudDogciB9ID0gdDtcbiAgICByZXR1cm4gKHsgb3A6IG4gfSkgPT4gdGEub2JzZXJ2YWJsZSgocykgPT4ge1xuICAgICAgY29uc3QgeyB0eXBlOiBhLCBwYXRoOiBpLCBpZDogbywgY29udGV4dDogYyB9ID0gbiwgdSA9IGUudHJhbnNmb3JtZXIuc2VyaWFsaXplKG4uaW5wdXQpLCBkID0gci5yZXF1ZXN0KHtcbiAgICAgICAgdHlwZTogYSxcbiAgICAgICAgcGF0aDogaSxcbiAgICAgICAgaW5wdXQ6IHUsXG4gICAgICAgIGlkOiBvLFxuICAgICAgICBjb250ZXh0OiBjXG4gICAgICB9LCB7XG4gICAgICAgIGVycm9yKGgpIHtcbiAgICAgICAgICBzLmVycm9yKGgpLCBkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICAgIHMuY29tcGxldGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dChoKSB7XG4gICAgICAgICAgY29uc3QgeSA9IHJhLnRyYW5zZm9ybVJlc3VsdChoLCBlKTtcbiAgICAgICAgICBpZiAoIXkub2spIHtcbiAgICAgICAgICAgIHMuZXJyb3IoS3IuVFJQQ0NsaWVudEVycm9yLmZyb20oeS5lcnJvcikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzLm5leHQoe1xuICAgICAgICAgICAgcmVzdWx0OiB5LnJlc3VsdFxuICAgICAgICAgIH0pLCBuLnR5cGUgIT09IFwic3Vic2NyaXB0aW9uXCIgJiYgKGQoKSwgcy5jb21wbGV0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkKCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xufVxub3QuY3JlYXRlV1NDbGllbnQgPSBzYTtcbm90LndzTGluayA9IGFhO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnZhciBtciA9IHdlLCBlbiA9IHF0LCB0biA9IHhlLCB5ciA9IHFyLCBBZSA9IEYsIHJuID0genQsIEZ0ID0gaXQsIGlhID0gQnQsIG5uID0gb3Q7XG5jbGFzcyBjdCB7XG4gICRyZXF1ZXN0KHsgdHlwZTogZSwgaW5wdXQ6IHIsIHBhdGg6IG4sIGNvbnRleHQ6IHMgPSB7fSB9KSB7XG4gICAgcmV0dXJuIGVuLmNyZWF0ZUNoYWluKHtcbiAgICAgIGxpbmtzOiB0aGlzLmxpbmtzLFxuICAgICAgb3A6IHtcbiAgICAgICAgaWQ6ICsrdGhpcy5yZXF1ZXN0SWQsXG4gICAgICAgIHR5cGU6IGUsXG4gICAgICAgIHBhdGg6IG4sXG4gICAgICAgIGlucHV0OiByLFxuICAgICAgICBjb250ZXh0OiBzXG4gICAgICB9XG4gICAgfSkucGlwZShtci5zaGFyZSgpKTtcbiAgfVxuICByZXF1ZXN0QXNQcm9taXNlKGUpIHtcbiAgICBjb25zdCByID0gdGhpcy4kcmVxdWVzdChlKSwgeyBwcm9taXNlOiBuLCBhYm9ydDogcyB9ID0gbXIub2JzZXJ2YWJsZVRvUHJvbWlzZShyKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGksIG8pID0+IHtcbiAgICAgIGUuc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgcyksIG4udGhlbigoYykgPT4ge1xuICAgICAgICBpKGMucmVzdWx0LmRhdGEpO1xuICAgICAgfSkuY2F0Y2goKGMpID0+IHtcbiAgICAgICAgbyh0bi5UUlBDQ2xpZW50RXJyb3IuZnJvbShjKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBxdWVyeShlLCByLCBuKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdEFzUHJvbWlzZSh7XG4gICAgICB0eXBlOiBcInF1ZXJ5XCIsXG4gICAgICBwYXRoOiBlLFxuICAgICAgaW5wdXQ6IHIsXG4gICAgICBjb250ZXh0OiBuPy5jb250ZXh0LFxuICAgICAgc2lnbmFsOiBuPy5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBtdXRhdGlvbihlLCByLCBuKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdEFzUHJvbWlzZSh7XG4gICAgICB0eXBlOiBcIm11dGF0aW9uXCIsXG4gICAgICBwYXRoOiBlLFxuICAgICAgaW5wdXQ6IHIsXG4gICAgICBjb250ZXh0OiBuPy5jb250ZXh0LFxuICAgICAgc2lnbmFsOiBuPy5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBzdWJzY3JpcHRpb24oZSwgciwgbikge1xuICAgIHJldHVybiB0aGlzLiRyZXF1ZXN0KHtcbiAgICAgIHR5cGU6IFwic3Vic2NyaXB0aW9uXCIsXG4gICAgICBwYXRoOiBlLFxuICAgICAgaW5wdXQ6IHIsXG4gICAgICBjb250ZXh0OiBuPy5jb250ZXh0XG4gICAgfSkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQoYSkge1xuICAgICAgICBhLnJlc3VsdC50eXBlID09PSBcInN0YXJ0ZWRcIiA/IG4ub25TdGFydGVkPy4oKSA6IGEucmVzdWx0LnR5cGUgPT09IFwic3RvcHBlZFwiID8gbi5vblN0b3BwZWQ/LigpIDogbi5vbkRhdGE/LihhLnJlc3VsdC5kYXRhKTtcbiAgICAgIH0sXG4gICAgICBlcnJvcihhKSB7XG4gICAgICAgIG4ub25FcnJvcj8uKGEpO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICBuLm9uQ29tcGxldGU/LigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IDA7XG4gICAgY29uc3QgciA9ICgoKSA9PiB7XG4gICAgICBjb25zdCBuID0gZS50cmFuc2Zvcm1lcjtcbiAgICAgIHJldHVybiBuID8gXCJpbnB1dFwiIGluIG4gPyBlLnRyYW5zZm9ybWVyIDoge1xuICAgICAgICBpbnB1dDogbixcbiAgICAgICAgb3V0cHV0OiBuXG4gICAgICB9IDoge1xuICAgICAgICBpbnB1dDoge1xuICAgICAgICAgIHNlcmlhbGl6ZTogKHMpID0+IHMsXG4gICAgICAgICAgZGVzZXJpYWxpemU6IChzKSA9PiBzXG4gICAgICAgIH0sXG4gICAgICAgIG91dHB1dDoge1xuICAgICAgICAgIHNlcmlhbGl6ZTogKHMpID0+IHMsXG4gICAgICAgICAgZGVzZXJpYWxpemU6IChzKSA9PiBzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICB0aGlzLnJ1bnRpbWUgPSB7XG4gICAgICB0cmFuc2Zvcm1lcjoge1xuICAgICAgICBzZXJpYWxpemU6IChuKSA9PiByLmlucHV0LnNlcmlhbGl6ZShuKSxcbiAgICAgICAgZGVzZXJpYWxpemU6IChuKSA9PiByLm91dHB1dC5kZXNlcmlhbGl6ZShuKVxuICAgICAgfSxcbiAgICAgIGNvbWJpbmVkVHJhbnNmb3JtZXI6IHJcbiAgICB9LCB0aGlzLmxpbmtzID0gZS5saW5rcy5tYXAoKG4pID0+IG4odGhpcy5ydW50aW1lKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9hKHQpIHtcbiAgcmV0dXJuIG5ldyBjdCh0KTtcbn1cbmZ1bmN0aW9uIGNhKHQpIHtcbiAgcmV0dXJuIG5ldyBjdCh0KTtcbn1cbmNvbnN0IHVhID0ge1xuICBxdWVyeTogXCJxdWVyeVwiLFxuICBtdXRhdGU6IFwibXV0YXRpb25cIixcbiAgc3Vic2NyaWJlOiBcInN1YnNjcmlwdGlvblwiXG59LCBzbiA9ICh0KSA9PiB1YVt0XTtcbmZ1bmN0aW9uIGFuKHQpIHtcbiAgcmV0dXJuIHlyLmNyZWF0ZUZsYXRQcm94eSgoZSkgPT4gdC5oYXNPd25Qcm9wZXJ0eShlKSA/IHRbZV0gOiBlID09PSBcIl9fdW50eXBlZENsaWVudFwiID8gdCA6IHlyLmNyZWF0ZVJlY3Vyc2l2ZVByb3h5KCh7IHBhdGg6IHIsIGFyZ3M6IG4gfSkgPT4ge1xuICAgIGNvbnN0IHMgPSBbXG4gICAgICBlLFxuICAgICAgLi4uclxuICAgIF0sIGEgPSBzbihzLnBvcCgpKSwgaSA9IHMuam9pbihcIi5cIik7XG4gICAgcmV0dXJuIHRbYV0oaSwgLi4ubik7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGxhKHQpIHtcbiAgY29uc3QgZSA9IG5ldyBjdCh0KTtcbiAgcmV0dXJuIGFuKGUpO1xufVxuZnVuY3Rpb24gZGEodCkge1xuICByZXR1cm4gdC5fX3VudHlwZWRDbGllbnQ7XG59XG5mdW5jdGlvbiBmYSh0KSB7XG4gIGlmICh0KVxuICAgIHJldHVybiB0O1xuICBpZiAodHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5UZXh0RGVjb2RlcilcbiAgICByZXR1cm4gbmV3IHdpbmRvdy5UZXh0RGVjb2RlcigpO1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPCBcInVcIiAmJiBnbG9iYWxUaGlzLlRleHREZWNvZGVyKVxuICAgIHJldHVybiBuZXcgZ2xvYmFsVGhpcy5UZXh0RGVjb2RlcigpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJObyBUZXh0RGVjb2RlciBpbXBsZW1lbnRhdGlvbiBmb3VuZFwiKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBhKHQpIHtcbiAgY29uc3QgZSA9IHQucGFyc2UgPz8gSlNPTi5wYXJzZSwgciA9IChuKSA9PiB7XG4gICAgaWYgKHQuc2lnbmFsPy5hYm9ydGVkIHx8ICFuIHx8IG4gPT09IFwifVwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHMgPSBuLmluZGV4T2YoXCI6XCIpLCBhID0gbi5zdWJzdHJpbmcoMiwgcyAtIDEpLCBpID0gbi5zdWJzdHJpbmcocyArIDEpO1xuICAgIHQub25TaW5nbGUoTnVtYmVyKGEpLCBlKGkpKTtcbiAgfTtcbiAgYXdhaXQgaGEodC5yZWFkYWJsZVN0cmVhbSwgciwgdC50ZXh0RGVjb2Rlcik7XG59XG5hc3luYyBmdW5jdGlvbiBoYSh0LCBlLCByKSB7XG4gIGxldCBuID0gXCJcIjtcbiAgY29uc3QgcyA9IChhKSA9PiB7XG4gICAgY29uc3QgbyA9IHIuZGVjb2RlKGEpLnNwbGl0KGBcbmApO1xuICAgIGlmIChvLmxlbmd0aCA9PT0gMSlcbiAgICAgIG4gKz0gb1swXTtcbiAgICBlbHNlIGlmIChvLmxlbmd0aCA+IDEpIHtcbiAgICAgIGUobiArIG9bMF0pO1xuICAgICAgZm9yIChsZXQgYyA9IDE7IGMgPCBvLmxlbmd0aCAtIDE7IGMrKylcbiAgICAgICAgZShvW2NdKTtcbiAgICAgIG4gPSBvW28ubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9O1xuICBcImdldFJlYWRlclwiIGluIHQgPyBhd2FpdCB5YSh0LCBzKSA6IGF3YWl0IG1hKHQsIHMpLCBlKG4pO1xufVxuZnVuY3Rpb24gbWEodCwgZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHIpID0+IHtcbiAgICB0Lm9uKFwiZGF0YVwiLCBlKSwgdC5vbihcImVuZFwiLCByKTtcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiB5YSh0LCBlKSB7XG4gIGNvbnN0IHIgPSB0LmdldFJlYWRlcigpO1xuICBsZXQgbiA9IGF3YWl0IHIucmVhZCgpO1xuICBmb3IgKDsgIW4uZG9uZTsgKVxuICAgIGUobi52YWx1ZSksIG4gPSBhd2FpdCByLnJlYWQoKTtcbn1cbmNvbnN0IGdhID0gKHQsIGUpID0+IHtcbiAgY29uc3QgciA9IHQuQWJvcnRDb250cm9sbGVyID8gbmV3IHQuQWJvcnRDb250cm9sbGVyKCkgOiBudWxsLCBuID0gQWUuZmV0Y2hIVFRQUmVzcG9uc2Uoe1xuICAgIC4uLnQsXG4gICAgY29udGVudFR5cGVIZWFkZXI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGJhdGNoTW9kZUhlYWRlcjogXCJzdHJlYW1cIixcbiAgICBnZXRVcmw6IEFlLmdldFVybCxcbiAgICBnZXRCb2R5OiBBZS5nZXRCb2R5XG4gIH0sIHIpLCBzID0gKCkgPT4gcj8uYWJvcnQoKSwgYSA9IG4udGhlbihhc3luYyAoaSkgPT4ge1xuICAgIGlmICghaS5ib2R5KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjZWl2ZWQgcmVzcG9uc2Ugd2l0aG91dCBib2R5XCIpO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICByZXNwb25zZTogaVxuICAgIH07XG4gICAgcmV0dXJuIHBhKHtcbiAgICAgIHJlYWRhYmxlU3RyZWFtOiBpLmJvZHksXG4gICAgICBvblNpbmdsZTogZSxcbiAgICAgIHBhcnNlOiAoYykgPT4gKHtcbiAgICAgICAganNvbjogSlNPTi5wYXJzZShjKSxcbiAgICAgICAgbWV0YTogb1xuICAgICAgfSksXG4gICAgICBzaWduYWw6IHI/LnNpZ25hbCxcbiAgICAgIHRleHREZWNvZGVyOiB0LnRleHREZWNvZGVyXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNhbmNlbDogcyxcbiAgICBwcm9taXNlOiBhXG4gIH07XG59LCBfYSA9ICh0KSA9PiB7XG4gIGNvbnN0IGUgPSBmYSh0Lm9wdHMudGV4dERlY29kZXIpO1xuICByZXR1cm4gKHIsIG4pID0+IHtcbiAgICBjb25zdCBzID0gci5tYXAoKGMpID0+IGMucGF0aCkuam9pbihcIixcIiksIGEgPSByLm1hcCgoYykgPT4gYy5pbnB1dCksIHsgY2FuY2VsOiBpLCBwcm9taXNlOiBvIH0gPSBnYSh7XG4gICAgICAuLi50LFxuICAgICAgdGV4dERlY29kZXI6IGUsXG4gICAgICBwYXRoOiBzLFxuICAgICAgaW5wdXRzOiBhLFxuICAgICAgaGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHQub3B0cy5oZWFkZXJzID8gdHlwZW9mIHQub3B0cy5oZWFkZXJzID09IFwiZnVuY3Rpb25cIiA/IHQub3B0cy5oZWFkZXJzKHtcbiAgICAgICAgICBvcExpc3Q6IHJcbiAgICAgICAgfSkgOiB0Lm9wdHMuaGVhZGVycyA6IHt9O1xuICAgICAgfVxuICAgIH0sIChjLCB1KSA9PiB7XG4gICAgICBuKGMsIHUpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICogcmV0dXJuIGFuIGVtcHR5IGFycmF5IGJlY2F1c2UgdGhlIGJhdGNoTG9hZGVyIGV4cGVjdHMgYW4gYXJyYXkgb2YgcmVzdWx0c1xuICAgICAgKiBidXQgd2UndmUgYWxyZWFkeSBjYWxsZWQgdGhlIGB1bml0UmVzb2x2ZXJgIGZvciBlYWNoIG9mIHRoZW0sIHRoZXJlJ3NcbiAgICAgICogbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gICAgICAqL1xuICAgICAgcHJvbWlzZTogby50aGVuKCgpID0+IFtdKSxcbiAgICAgIGNhbmNlbDogaVxuICAgIH07XG4gIH07XG59LCB2YSA9IHJuLmNyZWF0ZUhUVFBCYXRjaExpbmsoX2EpLCBiYSA9ICh0KSA9PiB7XG4gIGlmIChcImlucHV0XCIgaW4gdCkge1xuICAgIGlmICghKHQuaW5wdXQgaW5zdGFuY2VvZiBGb3JtRGF0YSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBub3QgRm9ybURhdGFcIik7XG4gICAgcmV0dXJuIHQuaW5wdXQ7XG4gIH1cbn0sIHdhID0gKHQpID0+IHtcbiAgaWYgKHQudHlwZSAhPT0gXCJtdXRhdGlvblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIldlIG9ubHkgaGFuZGxlIG11dGF0aW9ucyB3aXRoIGZvcm1kYXRhXCIpO1xuICByZXR1cm4gQWUuaHR0cFJlcXVlc3Qoe1xuICAgIC4uLnQsXG4gICAgZ2V0VXJsKCkge1xuICAgICAgcmV0dXJuIGAke3QudXJsfS8ke3QucGF0aH1gO1xuICAgIH0sXG4gICAgZ2V0Qm9keTogYmFcbiAgfSk7XG59LCB4YSA9IEZ0Lmh0dHBMaW5rRmFjdG9yeSh7XG4gIHJlcXVlc3Rlcjogd2Fcbn0pO1xuUy5zcGxpdExpbmsgPSBlbi5zcGxpdExpbms7XG5TLlRSUENDbGllbnRFcnJvciA9IHRuLlRSUENDbGllbnRFcnJvcjtcblMuZ2V0RmV0Y2ggPSBBZS5nZXRGZXRjaDtcblMuaHR0cEJhdGNoTGluayA9IHJuLmh0dHBCYXRjaExpbms7XG5TLmh0dHBMaW5rID0gRnQuaHR0cExpbms7XG5TLmh0dHBMaW5rRmFjdG9yeSA9IEZ0Lmh0dHBMaW5rRmFjdG9yeTtcblMubG9nZ2VyTGluayA9IGlhLmxvZ2dlckxpbms7XG5TLmNyZWF0ZVdTQ2xpZW50ID0gbm4uY3JlYXRlV1NDbGllbnQ7XG5TLndzTGluayA9IG5uLndzTGluaztcblMuVFJQQ1VudHlwZWRDbGllbnQgPSBjdDtcblMuY2xpZW50Q2FsbFR5cGVUb1Byb2NlZHVyZVR5cGUgPSBzbjtcblMuY3JlYXRlVFJQQ0NsaWVudCA9IGNhO1xuUy5jcmVhdGVUUlBDQ2xpZW50UHJveHkgPSBhbjtcblMuY3JlYXRlVFJQQ1Byb3h5Q2xpZW50ID0gbGE7XG5TLmNyZWF0ZVRSUENVbnR5cGVkQ2xpZW50ID0gb2E7XG5TLmV4cGVyaW1lbnRhbF9mb3JtRGF0YUxpbmsgPSB4YTtcblMuZ2V0VW50eXBlZENsaWVudCA9IGRhO1xuUy51bnN0YWJsZV9odHRwQmF0Y2hTdHJlYW1MaW5rID0gdmE7XG52YXIgbmUgPSB7fSwgSHQgPSB7fTtcbmZ1bmN0aW9uIGthKHQpIHtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBUYSh0KSB7XG4gIHJldHVybiB0Lmxlbmd0aCA9PT0gMCA/IGthIDogdC5sZW5ndGggPT09IDEgPyB0WzBdIDogZnVuY3Rpb24ocikge1xuICAgIHJldHVybiB0LnJlZHVjZSgobiwgcykgPT4gcyhuKSwgcik7XG4gIH07XG59XG5mdW5jdGlvbiBFYSh0KSB7XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgIT09IG51bGwgJiYgXCJzdWJzY3JpYmVcIiBpbiB0O1xufVxuZnVuY3Rpb24gQ2EodCkge1xuICBjb25zdCBlID0ge1xuICAgIHN1YnNjcmliZShyKSB7XG4gICAgICBsZXQgbiA9IG51bGwsIHMgPSAhMSwgYSA9ICExLCBpID0gITE7XG4gICAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgICAgIGkgPSAhMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYSB8fCAoYSA9ICEwLCB0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIgPyBuKCkgOiBuICYmIG4udW5zdWJzY3JpYmUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbiA9IHQoe1xuICAgICAgICBuZXh0KGMpIHtcbiAgICAgICAgICBzIHx8IHIubmV4dD8uKGMpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcihjKSB7XG4gICAgICAgICAgcyB8fCAocyA9ICEwLCByLmVycm9yPy4oYyksIG8oKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICAgIHMgfHwgKHMgPSAhMCwgci5jb21wbGV0ZT8uKCksIG8oKSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBpICYmIG8oKSwge1xuICAgICAgICB1bnN1YnNjcmliZTogb1xuICAgICAgfTtcbiAgICB9LFxuICAgIHBpcGUoLi4ucikge1xuICAgICAgcmV0dXJuIFRhKHIpKGUpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGU7XG59XG5IdC5pc09ic2VydmFibGUgPSBFYTtcbkh0Lm9ic2VydmFibGUgPSBDYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIG9uID0gSHQ7XG5mdW5jdGlvbiBSYSh0KSB7XG4gIHJldHVybiAoZSkgPT4ge1xuICAgIGxldCByID0gMCwgbiA9IG51bGw7XG4gICAgY29uc3QgcyA9IFtdO1xuICAgIGZ1bmN0aW9uIGEoKSB7XG4gICAgICBuIHx8IChuID0gZS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0KG8pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgcylcbiAgICAgICAgICAgIGMubmV4dD8uKG8pO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcihvKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBjIG9mIHMpXG4gICAgICAgICAgICBjLmVycm9yPy4obyk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICAgIGZvciAoY29uc3QgbyBvZiBzKVxuICAgICAgICAgICAgby5jb21wbGV0ZT8uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgIGlmIChyID09PSAwICYmIG4pIHtcbiAgICAgICAgY29uc3QgbyA9IG47XG4gICAgICAgIG4gPSBudWxsLCBvLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWJzY3JpYmUobykge1xuICAgICAgICByZXR1cm4gcisrLCBzLnB1c2gobyksIGEoKSwge1xuICAgICAgICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgci0tLCBpKCk7XG4gICAgICAgICAgICBjb25zdCBjID0gcy5maW5kSW5kZXgoKHUpID0+IHUgPT09IG8pO1xuICAgICAgICAgICAgYyA+IC0xICYmIHMuc3BsaWNlKGMsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gT2EodCkge1xuICByZXR1cm4gKGUpID0+ICh7XG4gICAgc3Vic2NyaWJlKHIpIHtcbiAgICAgIGxldCBuID0gMDtcbiAgICAgIHJldHVybiBlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQoYSkge1xuICAgICAgICAgIHIubmV4dD8uKHQoYSwgbisrKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yKGEpIHtcbiAgICAgICAgICByLmVycm9yPy4oYSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICAgIHIuY29tcGxldGU/LigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gU2EodCkge1xuICByZXR1cm4gKGUpID0+ICh7XG4gICAgc3Vic2NyaWJlKHIpIHtcbiAgICAgIHJldHVybiBlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQobikge1xuICAgICAgICAgIHQubmV4dD8uKG4pLCByLm5leHQ/LihuKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3Iobikge1xuICAgICAgICAgIHQuZXJyb3I/LihuKSwgci5lcnJvcj8uKG4pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgICB0LmNvbXBsZXRlPy4oKSwgci5jb21wbGV0ZT8uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5jbGFzcyBHdCBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLm5hbWUgPSBcIk9ic2VydmFibGVBYm9ydEVycm9yXCIsIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBHdC5wcm90b3R5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBQYSh0KSB7XG4gIGxldCBlO1xuICByZXR1cm4ge1xuICAgIHByb21pc2U6IG5ldyBQcm9taXNlKChuLCBzKSA9PiB7XG4gICAgICBsZXQgYSA9ICExO1xuICAgICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgYSB8fCAoYSA9ICEwLCBzKG5ldyBHdChcIlRoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiKSksIG8udW5zdWJzY3JpYmUoKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvID0gdC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0KGMpIHtcbiAgICAgICAgICBhID0gITAsIG4oYyksIGkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IoYykge1xuICAgICAgICAgIGEgPSAhMCwgcyhjKSwgaSgpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgICBhID0gITAsIGkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlID0gaTtcbiAgICB9KSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGFib3J0OiBlXG4gIH07XG59XG5uZS5pc09ic2VydmFibGUgPSBvbi5pc09ic2VydmFibGU7XG5uZS5vYnNlcnZhYmxlID0gb24ub2JzZXJ2YWJsZTtcbm5lLm1hcCA9IE9hO1xubmUub2JzZXJ2YWJsZVRvUHJvbWlzZSA9IFBhO1xubmUuc2hhcmUgPSBSYTtcbm5lLnRhcCA9IFNhO1xudmFyIHEgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShxLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5xLmlzVFJQQ1JlcXVlc3RXaXRoSWQgPSBxLmlzVFJQQ1JlcXVlc3QgPSBxLmlzVFJQQ1Jlc3BvbnNlID0gcS5pc1RSUENNZXNzYWdlID0gdm9pZCAwO1xuZnVuY3Rpb24gZ3IodCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHQpO1xufVxuZnVuY3Rpb24gQWEodCkge1xuICByZXR1cm4gdCA9PSBudWxsO1xufVxuZnVuY3Rpb24gY24odCkge1xuICByZXR1cm4gISEoZ3IodCkgJiYgXCJ0cnBjXCIgaW4gdCAmJiBncih0LnRycGMpKTtcbn1cbnEuaXNUUlBDTWVzc2FnZSA9IGNuO1xuZnVuY3Rpb24gSnQodCkge1xuICByZXR1cm4gY24odCkgJiYgXCJpZFwiIGluIHQudHJwYyAmJiAhQWEodC50cnBjLmlkKTtcbn1cbmZ1bmN0aW9uIE5hKHQpIHtcbiAgcmV0dXJuIEp0KHQpICYmIChcImVycm9yXCIgaW4gdC50cnBjIHx8IFwicmVzdWx0XCIgaW4gdC50cnBjKTtcbn1cbnEuaXNUUlBDUmVzcG9uc2UgPSBOYTtcbmZ1bmN0aW9uIHVuKHQpIHtcbiAgcmV0dXJuIEp0KHQpICYmIFwibWV0aG9kXCIgaW4gdC50cnBjO1xufVxucS5pc1RSUENSZXF1ZXN0ID0gdW47XG5mdW5jdGlvbiBJYSh0KSB7XG4gIHJldHVybiB1bih0KSAmJiBKdCh0KTtcbn1cbnEuaXNUUlBDUmVxdWVzdFdpdGhJZCA9IElhO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGJlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5iZS5jcmVhdGVCYXNlTGluayA9IHZvaWQgMDtcbmNvbnN0IHd0ID0gUywgamEgPSBuZSwgTGEgPSBxLCAkYSA9ICh0KSA9PiAoZSkgPT4gKHsgb3A6IHIgfSkgPT4gKDAsIGphLm9ic2VydmFibGUpKChuKSA9PiB7XG4gIGNvbnN0IHMgPSBbXSwgeyBpZDogYSwgdHlwZTogaSwgcGF0aDogbyB9ID0gcjtcbiAgdHJ5IHtcbiAgICBjb25zdCBjID0gZS50cmFuc2Zvcm1lci5zZXJpYWxpemUoci5pbnB1dCksIHUgPSAoKSA9PiB7XG4gICAgICBuLmVycm9yKG5ldyB3dC5UUlBDQ2xpZW50RXJyb3IoXCJQb3J0IGRpc2Nvbm5lY3RlZCBwcmVtYXR1cmVseVwiKSk7XG4gICAgfTtcbiAgICB0LmFkZENsb3NlTGlzdGVuZXIodSksIHMucHVzaCgoKSA9PiB0LnJlbW92ZUNsb3NlTGlzdGVuZXIodSkpO1xuICAgIGNvbnN0IGQgPSAoaCkgPT4ge1xuICAgICAgaWYgKCEoMCwgTGEuaXNUUlBDUmVzcG9uc2UpKGgpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IHRycGM6IHkgfSA9IGg7XG4gICAgICBpZiAoYSA9PT0geS5pZCkge1xuICAgICAgICBpZiAoXCJlcnJvclwiIGluIHkpXG4gICAgICAgICAgcmV0dXJuIG4uZXJyb3Iod3QuVFJQQ0NsaWVudEVycm9yLmZyb20oeSkpO1xuICAgICAgICBuLm5leHQoe1xuICAgICAgICAgIHJlc3VsdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB5LnJlc3VsdCksICgheS5yZXN1bHQudHlwZSB8fCB5LnJlc3VsdC50eXBlID09PSBcImRhdGFcIikgJiYge1xuICAgICAgICAgICAgdHlwZTogXCJkYXRhXCIsXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICBkYXRhOiBlLnRyYW5zZm9ybWVyLmRlc2VyaWFsaXplKHkucmVzdWx0LmRhdGEpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksIChpICE9PSBcInN1YnNjcmlwdGlvblwiIHx8IHkucmVzdWx0LnR5cGUgPT09IFwic3RvcHBlZFwiKSAmJiBuLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0LmFkZE1lc3NhZ2VMaXN0ZW5lcihkKSwgcy5wdXNoKCgpID0+IHQucmVtb3ZlTWVzc2FnZUxpc3RlbmVyKGQpKSwgdC5wb3N0TWVzc2FnZSh7XG4gICAgICB0cnBjOiB7XG4gICAgICAgIGlkOiBhLFxuICAgICAgICBqc29ucnBjOiB2b2lkIDAsXG4gICAgICAgIG1ldGhvZDogaSxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICBwYXJhbXM6IHsgcGF0aDogbywgaW5wdXQ6IGMgfVxuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChjKSB7XG4gICAgbi5lcnJvcihuZXcgd3QuVFJQQ0NsaWVudEVycm9yKGMgaW5zdGFuY2VvZiBFcnJvciA/IGMubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiKSk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBpID09PSBcInN1YnNjcmlwdGlvblwiICYmIHQucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHJwYzoge1xuICAgICAgICBpZDogYSxcbiAgICAgICAganNvbnJwYzogdm9pZCAwLFxuICAgICAgICBtZXRob2Q6IFwic3Vic2NyaXB0aW9uLnN0b3BcIlxuICAgICAgfVxuICAgIH0pLCBzLmZvckVhY2goKGMpID0+IGMoKSk7XG4gIH07XG59KTtcbmJlLmNyZWF0ZUJhc2VMaW5rID0gJGE7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoYXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmF0LmNocm9tZUxpbmsgPSB2b2lkIDA7XG5jb25zdCBNYSA9IGJlLCBEYSA9ICh0KSA9PiAoMCwgTWEuY3JlYXRlQmFzZUxpbmspKHtcbiAgcG9zdE1lc3NhZ2UoZSkge1xuICAgIHQucG9ydC5wb3N0TWVzc2FnZShlKTtcbiAgfSxcbiAgYWRkTWVzc2FnZUxpc3RlbmVyKGUpIHtcbiAgICB0LnBvcnQub25NZXNzYWdlLmFkZExpc3RlbmVyKGUpO1xuICB9LFxuICByZW1vdmVNZXNzYWdlTGlzdGVuZXIoZSkge1xuICAgIHQucG9ydC5vbk1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIoZSk7XG4gIH0sXG4gIGFkZENsb3NlTGlzdGVuZXIoZSkge1xuICAgIHQucG9ydC5vbkRpc2Nvbm5lY3QuYWRkTGlzdGVuZXIoZSk7XG4gIH0sXG4gIHJlbW92ZUNsb3NlTGlzdGVuZXIoZSkge1xuICAgIHQucG9ydC5vbkRpc2Nvbm5lY3QucmVtb3ZlTGlzdGVuZXIoZSk7XG4gIH1cbn0pO1xuYXQuY2hyb21lTGluayA9IERhO1xudmFyIHV0ID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkodXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnV0LndpbmRvd0xpbmsgPSB2b2lkIDA7XG5jb25zdCBaYSA9IGJlLCBVYSA9ICh0KSA9PiB7XG4gIHZhciBlO1xuICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgbiA9IHQud2luZG93LCBzID0gKGUgPSB0LnBvc3RXaW5kb3cpICE9PSBudWxsICYmIGUgIT09IHZvaWQgMCA/IGUgOiBuO1xuICByZXR1cm4gKDAsIFphLmNyZWF0ZUJhc2VMaW5rKSh7XG4gICAgcG9zdE1lc3NhZ2UoYSkge1xuICAgICAgcy5wb3N0TWVzc2FnZShhLCB7XG4gICAgICAgIHRhcmdldE9yaWdpbjogdC5wb3N0T3JpZ2luXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGFkZE1lc3NhZ2VMaXN0ZW5lcihhKSB7XG4gICAgICBjb25zdCBpID0gKG8pID0+IHtcbiAgICAgICAgYShvLmRhdGEpO1xuICAgICAgfTtcbiAgICAgIHIuc2V0KGEsIGkpLCBuLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGkpO1xuICAgIH0sXG4gICAgcmVtb3ZlTWVzc2FnZUxpc3RlbmVyKGEpIHtcbiAgICAgIGNvbnN0IGkgPSByLmdldChhKTtcbiAgICAgIGkgJiYgbi5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBpKTtcbiAgICB9LFxuICAgIGFkZENsb3NlTGlzdGVuZXIoYSkge1xuICAgICAgbi5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGEpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2xvc2VMaXN0ZW5lcihhKSB7XG4gICAgICBuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgYSk7XG4gICAgfVxuICB9KTtcbn07XG51dC53aW5kb3dMaW5rID0gVWE7XG52YXIgbHQgPSB7fSwgZHQgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuZHQuVFJQQ19CUk9XU0VSX0xPQURFRF9FVkVOVCA9IHZvaWQgMDtcbmR0LlRSUENfQlJPV1NFUl9MT0FERURfRVZFTlQgPSBcIlRSUENfQlJPV1NFUjo6UE9QVVBfTE9BREVEXCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkobHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmx0LnBvcHVwTGluayA9IHZvaWQgMDtcbmNvbnN0IFdhID0gZHQsIHFhID0gYmUsIHphID0gKHQpID0+IHtcbiAgY29uc3QgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgbiA9IG51bGw7XG4gIGFzeW5jIGZ1bmN0aW9uIHMoYSkge1xuICAgIGlmICghbiB8fCBuLmNsb3NlZCkge1xuICAgICAgbiA9IHQuY3JlYXRlUG9wdXAoKSwgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgLy8gd2FpdCB0aWwgd2luZG93IGlzIGxvYWRlZCAoc2FtZSBvcmlnaW4pXG4gICAgICAgIG5ldyBQcm9taXNlKChpKSA9PiB7XG4gICAgICAgICAgdmFyIG87XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIChvID0gbj8uYWRkRXZlbnRMaXN0ZW5lcikgPT09IG51bGwgfHwgbyA9PT0gdm9pZCAwIHx8IG8uY2FsbChuLCBcImxvYWRcIiwgaSk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgLy8gdGhpcyBpcyBuZWVkZWQgZm9yIGNyb3NzLW9yaWdpbiBwb3B1cHMgYXMgdGhleSBkb24ndCBoYXZlIGEgbG9hZCBldmVudFxuICAgICAgICBuZXcgUHJvbWlzZSgoaSkgPT4ge1xuICAgICAgICAgIGEuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKG8pID0+IHtcbiAgICAgICAgICAgIG8uZGF0YSA9PT0gV2EuVFJQQ19CUk9XU0VSX0xPQURFRF9FVkVOVCAmJiBpKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICAvLyBleHBlY3QgdGhlIHBvcHVwIHRvIGxvYWQgYWZ0ZXIgMTVzIG1heCwgaW4gY2FzZSBub24gb2YgdGhlIGFib3ZlIGV2ZW50cyBmaXJlXG4gICAgICAgIG5ldyBQcm9taXNlKChpKSA9PiB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGRldGVjdCBpZiBwb3B1cCBsb2FkaW5nIHN1Y2NlZWRlZCBhZnRlciAxNXMgdGltZW91dCwgY29udGludWluZyBhbnl3YXlcIiksIHNldFRpbWVvdXQoaSwgMTVlMyk7XG4gICAgICAgIH0pXG4gICAgICBdKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbi5hZGRFdmVudExpc3RlbmVyKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBvcHVwV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgICAgIG4uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgbiA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIGNvbnN0IG8gPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgbiAmJiBuLmNsb3NlZCAmJiAobiA9IG51bGwsIHIuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgYygpO1xuICAgICAgICAgIH0pLCBjbGVhckludGVydmFsKG8pKTtcbiAgICAgICAgfSwgMWUzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgcmV0dXJuICgwLCBxYS5jcmVhdGVCYXNlTGluaykoe1xuICAgIGFzeW5jIHBvc3RNZXNzYWdlKGEpIHtcbiAgICAgIHJldHVybiAoYXdhaXQgcyh0Lmxpc3RlbldpbmRvdykpLnBvc3RNZXNzYWdlKGEsIHtcbiAgICAgICAgdGFyZ2V0T3JpZ2luOiB0LnBvc3RPcmlnaW5cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYWRkTWVzc2FnZUxpc3RlbmVyKGEpIHtcbiAgICAgIGNvbnN0IGkgPSAobykgPT4ge1xuICAgICAgICBhKG8uZGF0YSk7XG4gICAgICB9O1xuICAgICAgZS5zZXQoYSwgaSksIHQubGlzdGVuV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGkpO1xuICAgIH0sXG4gICAgcmVtb3ZlTWVzc2FnZUxpc3RlbmVyKGEpIHtcbiAgICAgIGNvbnN0IGkgPSBlLmdldChhKTtcbiAgICAgIGkgJiYgdC5saXN0ZW5XaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaSk7XG4gICAgfSxcbiAgICBhZGRDbG9zZUxpc3RlbmVyKGEpIHtcbiAgICAgIHQubGlzdGVuV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgYSksIHIuYWRkKGEpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2xvc2VMaXN0ZW5lcihhKSB7XG4gICAgICB0Lmxpc3RlbldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGEpLCByLmRlbGV0ZShhKTtcbiAgICB9XG4gIH0pO1xufTtcbmx0LnBvcHVwTGluayA9IHphO1xuKGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSBIZSAmJiBIZS5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbihuLCBzLCBhLCBpKSB7XG4gICAgaSA9PT0gdm9pZCAwICYmIChpID0gYSk7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHMsIGEpO1xuICAgICghbyB8fCAoXCJnZXRcIiBpbiBvID8gIXMuX19lc01vZHVsZSA6IG8ud3JpdGFibGUgfHwgby5jb25maWd1cmFibGUpKSAmJiAobyA9IHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc1thXTtcbiAgICB9IH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaSwgbyk7XG4gIH0gOiBmdW5jdGlvbihuLCBzLCBhLCBpKSB7XG4gICAgaSA9PT0gdm9pZCAwICYmIChpID0gYSksIG5baV0gPSBzW2FdO1xuICB9KSwgciA9IEhlICYmIEhlLl9fZXhwb3J0U3RhciB8fCBmdW5jdGlvbihuLCBzKSB7XG4gICAgZm9yICh2YXIgYSBpbiBuKVxuICAgICAgYSAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBhKSAmJiBlKHMsIG4sIGEpO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCByKGF0LCB0KSwgcih1dCwgdCksIHIobHQsIHQpO1xufSkoUnQpO1xudmFyIHg7XG4oZnVuY3Rpb24odCkge1xuICB0LmFzc2VydEVxdWFsID0gKHMpID0+IHM7XG4gIGZ1bmN0aW9uIGUocykge1xuICB9XG4gIHQuYXNzZXJ0SXMgPSBlO1xuICBmdW5jdGlvbiByKHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfVxuICB0LmFzc2VydE5ldmVyID0gciwgdC5hcnJheVRvRW51bSA9IChzKSA9PiB7XG4gICAgY29uc3QgYSA9IHt9O1xuICAgIGZvciAoY29uc3QgaSBvZiBzKVxuICAgICAgYVtpXSA9IGk7XG4gICAgcmV0dXJuIGE7XG4gIH0sIHQuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKHMpID0+IHtcbiAgICBjb25zdCBhID0gdC5vYmplY3RLZXlzKHMpLmZpbHRlcigobykgPT4gdHlwZW9mIHNbc1tvXV0gIT0gXCJudW1iZXJcIiksIGkgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG8gb2YgYSlcbiAgICAgIGlbb10gPSBzW29dO1xuICAgIHJldHVybiB0Lm9iamVjdFZhbHVlcyhpKTtcbiAgfSwgdC5vYmplY3RWYWx1ZXMgPSAocykgPT4gdC5vYmplY3RLZXlzKHMpLm1hcChmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIHNbYV07XG4gIH0pLCB0Lm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT0gXCJmdW5jdGlvblwiID8gKHMpID0+IE9iamVjdC5rZXlzKHMpIDogKHMpID0+IHtcbiAgICBjb25zdCBhID0gW107XG4gICAgZm9yIChjb25zdCBpIGluIHMpXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgaSkgJiYgYS5wdXNoKGkpO1xuICAgIHJldHVybiBhO1xuICB9LCB0LmZpbmQgPSAocywgYSkgPT4ge1xuICAgIGZvciAoY29uc3QgaSBvZiBzKVxuICAgICAgaWYgKGEoaSkpXG4gICAgICAgIHJldHVybiBpO1xuICB9LCB0LmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09IFwiZnVuY3Rpb25cIiA/IChzKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHMpIDogKHMpID0+IHR5cGVvZiBzID09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUocykgJiYgTWF0aC5mbG9vcihzKSA9PT0gcztcbiAgZnVuY3Rpb24gbihzLCBhID0gXCIgfCBcIikge1xuICAgIHJldHVybiBzLm1hcCgoaSkgPT4gdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IGAnJHtpfSdgIDogaSkuam9pbihhKTtcbiAgfVxuICB0LmpvaW5WYWx1ZXMgPSBuLCB0Lmpzb25TdHJpbmdpZnlSZXBsYWNlciA9IChzLCBhKSA9PiB0eXBlb2YgYSA9PSBcImJpZ2ludFwiID8gYS50b1N0cmluZygpIDogYTtcbn0pKHggfHwgKHggPSB7fSkpO1xudmFyIFB0O1xuKGZ1bmN0aW9uKHQpIHtcbiAgdC5tZXJnZVNoYXBlcyA9IChlLCByKSA9PiAoe1xuICAgIC4uLmUsXG4gICAgLi4uclxuICAgIC8vIHNlY29uZCBvdmVyd3JpdGVzIGZpcnN0XG4gIH0pO1xufSkoUHQgfHwgKFB0ID0ge30pKTtcbmNvbnN0IG0gPSB4LmFycmF5VG9FbnVtKFtcbiAgXCJzdHJpbmdcIixcbiAgXCJuYW5cIixcbiAgXCJudW1iZXJcIixcbiAgXCJpbnRlZ2VyXCIsXG4gIFwiZmxvYXRcIixcbiAgXCJib29sZWFuXCIsXG4gIFwiZGF0ZVwiLFxuICBcImJpZ2ludFwiLFxuICBcInN5bWJvbFwiLFxuICBcImZ1bmN0aW9uXCIsXG4gIFwidW5kZWZpbmVkXCIsXG4gIFwibnVsbFwiLFxuICBcImFycmF5XCIsXG4gIFwib2JqZWN0XCIsXG4gIFwidW5rbm93blwiLFxuICBcInByb21pc2VcIixcbiAgXCJ2b2lkXCIsXG4gIFwibmV2ZXJcIixcbiAgXCJtYXBcIixcbiAgXCJzZXRcIlxuXSksIFkgPSAodCkgPT4ge1xuICBzd2l0Y2ggKHR5cGVvZiB0KSB7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIG0udW5kZWZpbmVkO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBtLnN0cmluZztcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gaXNOYU4odCkgPyBtLm5hbiA6IG0ubnVtYmVyO1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gbS5ib29sZWFuO1xuICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgcmV0dXJuIG0uZnVuY3Rpb247XG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuIG0uYmlnaW50O1xuICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgIHJldHVybiBtLnN5bWJvbDtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSA/IG0uYXJyYXkgOiB0ID09PSBudWxsID8gbS5udWxsIDogdC50aGVuICYmIHR5cGVvZiB0LnRoZW4gPT0gXCJmdW5jdGlvblwiICYmIHQuY2F0Y2ggJiYgdHlwZW9mIHQuY2F0Y2ggPT0gXCJmdW5jdGlvblwiID8gbS5wcm9taXNlIDogdHlwZW9mIE1hcCA8IFwidVwiICYmIHQgaW5zdGFuY2VvZiBNYXAgPyBtLm1hcCA6IHR5cGVvZiBTZXQgPCBcInVcIiAmJiB0IGluc3RhbmNlb2YgU2V0ID8gbS5zZXQgOiB0eXBlb2YgRGF0ZSA8IFwidVwiICYmIHQgaW5zdGFuY2VvZiBEYXRlID8gbS5kYXRlIDogbS5vYmplY3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBtLnVua25vd247XG4gIH1cbn0sIGYgPSB4LmFycmF5VG9FbnVtKFtcbiAgXCJpbnZhbGlkX3R5cGVcIixcbiAgXCJpbnZhbGlkX2xpdGVyYWxcIixcbiAgXCJjdXN0b21cIixcbiAgXCJpbnZhbGlkX3VuaW9uXCIsXG4gIFwiaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yXCIsXG4gIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsXG4gIFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgXCJpbnZhbGlkX2FyZ3VtZW50c1wiLFxuICBcImludmFsaWRfcmV0dXJuX3R5cGVcIixcbiAgXCJpbnZhbGlkX2RhdGVcIixcbiAgXCJpbnZhbGlkX3N0cmluZ1wiLFxuICBcInRvb19zbWFsbFwiLFxuICBcInRvb19iaWdcIixcbiAgXCJpbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlc1wiLFxuICBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICBcIm5vdF9maW5pdGVcIlxuXSksIEJhID0gKHQpID0+IEpTT04uc3RyaW5naWZ5KHQsIG51bGwsIDIpLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XG5jbGFzcyBMIGV4dGVuZHMgRXJyb3Ige1xuICBnZXQgZXJyb3JzKCkge1xuICAgIHJldHVybiB0aGlzLmlzc3VlcztcbiAgfVxuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5pc3N1ZXMgPSBbXSwgdGhpcy5hZGRJc3N1ZSA9IChuKSA9PiB7XG4gICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3Vlcywgbl07XG4gICAgfSwgdGhpcy5hZGRJc3N1ZXMgPSAobiA9IFtdKSA9PiB7XG4gICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3VlcywgLi4ubl07XG4gICAgfTtcbiAgICBjb25zdCByID0gbmV3LnRhcmdldC5wcm90b3R5cGU7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIHIpIDogdGhpcy5fX3Byb3RvX18gPSByLCB0aGlzLm5hbWUgPSBcIlpvZEVycm9yXCIsIHRoaXMuaXNzdWVzID0gZTtcbiAgfVxuICBmb3JtYXQoZSkge1xuICAgIGNvbnN0IHIgPSBlIHx8IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBhLm1lc3NhZ2U7XG4gICAgfSwgbiA9IHsgX2Vycm9yczogW10gfSwgcyA9IChhKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGkgb2YgYS5pc3N1ZXMpXG4gICAgICAgIGlmIChpLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKVxuICAgICAgICAgIGkudW5pb25FcnJvcnMubWFwKHMpO1xuICAgICAgICBlbHNlIGlmIChpLmNvZGUgPT09IFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiKVxuICAgICAgICAgIHMoaS5yZXR1cm5UeXBlRXJyb3IpO1xuICAgICAgICBlbHNlIGlmIChpLmNvZGUgPT09IFwiaW52YWxpZF9hcmd1bWVudHNcIilcbiAgICAgICAgICBzKGkuYXJndW1lbnRzRXJyb3IpO1xuICAgICAgICBlbHNlIGlmIChpLnBhdGgubGVuZ3RoID09PSAwKVxuICAgICAgICAgIG4uX2Vycm9ycy5wdXNoKHIoaSkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsZXQgbyA9IG4sIGMgPSAwO1xuICAgICAgICAgIGZvciAoOyBjIDwgaS5wYXRoLmxlbmd0aDsgKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaS5wYXRoW2NdO1xuICAgICAgICAgICAgYyA9PT0gaS5wYXRoLmxlbmd0aCAtIDEgPyAob1t1XSA9IG9bdV0gfHwgeyBfZXJyb3JzOiBbXSB9LCBvW3VdLl9lcnJvcnMucHVzaChyKGkpKSkgOiBvW3VdID0gb1t1XSB8fCB7IF9lcnJvcnM6IFtdIH0sIG8gPSBvW3VdLCBjKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcyh0aGlzKSwgbjtcbiAgfVxuICBzdGF0aWMgYXNzZXJ0KGUpIHtcbiAgICBpZiAoIShlIGluc3RhbmNlb2YgTCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIFpvZEVycm9yOiAke2V9YCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgfVxuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIHguanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgfVxuICBnZXQgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICB9XG4gIGZsYXR0ZW4oZSA9IChyKSA9PiByLm1lc3NhZ2UpIHtcbiAgICBjb25zdCByID0ge30sIG4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5pc3N1ZXMpXG4gICAgICBzLnBhdGgubGVuZ3RoID4gMCA/IChyW3MucGF0aFswXV0gPSByW3MucGF0aFswXV0gfHwgW10sIHJbcy5wYXRoWzBdXS5wdXNoKGUocykpKSA6IG4ucHVzaChlKHMpKTtcbiAgICByZXR1cm4geyBmb3JtRXJyb3JzOiBuLCBmaWVsZEVycm9yczogciB9O1xuICB9XG4gIGdldCBmb3JtRXJyb3JzKCkge1xuICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKTtcbiAgfVxufVxuTC5jcmVhdGUgPSAodCkgPT4gbmV3IEwodCk7XG5jb25zdCBnZSA9ICh0LCBlKSA9PiB7XG4gIGxldCByO1xuICBzd2l0Y2ggKHQuY29kZSkge1xuICAgIGNhc2UgZi5pbnZhbGlkX3R5cGU6XG4gICAgICB0LnJlY2VpdmVkID09PSBtLnVuZGVmaW5lZCA/IHIgPSBcIlJlcXVpcmVkXCIgOiByID0gYEV4cGVjdGVkICR7dC5leHBlY3RlZH0sIHJlY2VpdmVkICR7dC5yZWNlaXZlZH1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmLmludmFsaWRfbGl0ZXJhbDpcbiAgICAgIHIgPSBgSW52YWxpZCBsaXRlcmFsIHZhbHVlLCBleHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KHQuZXhwZWN0ZWQsIHguanNvblN0cmluZ2lmeVJlcGxhY2VyKX1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmLnVucmVjb2duaXplZF9rZXlzOlxuICAgICAgciA9IGBVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogJHt4LmpvaW5WYWx1ZXModC5rZXlzLCBcIiwgXCIpfWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGYuaW52YWxpZF91bmlvbjpcbiAgICAgIHIgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZi5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3I6XG4gICAgICByID0gYEludmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZS4gRXhwZWN0ZWQgJHt4LmpvaW5WYWx1ZXModC5vcHRpb25zKX1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmLmludmFsaWRfZW51bV92YWx1ZTpcbiAgICAgIHIgPSBgSW52YWxpZCBlbnVtIHZhbHVlLiBFeHBlY3RlZCAke3guam9pblZhbHVlcyh0Lm9wdGlvbnMpfSwgcmVjZWl2ZWQgJyR7dC5yZWNlaXZlZH0nYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZi5pbnZhbGlkX2FyZ3VtZW50czpcbiAgICAgIHIgPSBcIkludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGYuaW52YWxpZF9yZXR1cm5fdHlwZTpcbiAgICAgIHIgPSBcIkludmFsaWQgZnVuY3Rpb24gcmV0dXJuIHR5cGVcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZi5pbnZhbGlkX2RhdGU6XG4gICAgICByID0gXCJJbnZhbGlkIGRhdGVcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZi5pbnZhbGlkX3N0cmluZzpcbiAgICAgIHR5cGVvZiB0LnZhbGlkYXRpb24gPT0gXCJvYmplY3RcIiA/IFwiaW5jbHVkZXNcIiBpbiB0LnZhbGlkYXRpb24gPyAociA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGluY2x1ZGUgXCIke3QudmFsaWRhdGlvbi5pbmNsdWRlc31cImAsIHR5cGVvZiB0LnZhbGlkYXRpb24ucG9zaXRpb24gPT0gXCJudW1iZXJcIiAmJiAociA9IGAke3J9IGF0IG9uZSBvciBtb3JlIHBvc2l0aW9ucyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHt0LnZhbGlkYXRpb24ucG9zaXRpb259YCkpIDogXCJzdGFydHNXaXRoXCIgaW4gdC52YWxpZGF0aW9uID8gciA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke3QudmFsaWRhdGlvbi5zdGFydHNXaXRofVwiYCA6IFwiZW5kc1dpdGhcIiBpbiB0LnZhbGlkYXRpb24gPyByID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke3QudmFsaWRhdGlvbi5lbmRzV2l0aH1cImAgOiB4LmFzc2VydE5ldmVyKHQudmFsaWRhdGlvbikgOiB0LnZhbGlkYXRpb24gIT09IFwicmVnZXhcIiA/IHIgPSBgSW52YWxpZCAke3QudmFsaWRhdGlvbn1gIDogciA9IFwiSW52YWxpZFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmLnRvb19zbWFsbDpcbiAgICAgIHQudHlwZSA9PT0gXCJhcnJheVwiID8gciA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHt0LmV4YWN0ID8gXCJleGFjdGx5XCIgOiB0LmluY2x1c2l2ZSA/IFwiYXQgbGVhc3RcIiA6IFwibW9yZSB0aGFuXCJ9ICR7dC5taW5pbXVtfSBlbGVtZW50KHMpYCA6IHQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IHIgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke3QuZXhhY3QgPyBcImV4YWN0bHlcIiA6IHQuaW5jbHVzaXZlID8gXCJhdCBsZWFzdFwiIDogXCJvdmVyXCJ9ICR7dC5taW5pbXVtfSBjaGFyYWN0ZXIocylgIDogdC50eXBlID09PSBcIm51bWJlclwiID8gciA9IGBOdW1iZXIgbXVzdCBiZSAke3QuZXhhY3QgPyBcImV4YWN0bHkgZXF1YWwgdG8gXCIgOiB0LmluY2x1c2l2ZSA/IFwiZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFwiIDogXCJncmVhdGVyIHRoYW4gXCJ9JHt0Lm1pbmltdW19YCA6IHQudHlwZSA9PT0gXCJkYXRlXCIgPyByID0gYERhdGUgbXVzdCBiZSAke3QuZXhhY3QgPyBcImV4YWN0bHkgZXF1YWwgdG8gXCIgOiB0LmluY2x1c2l2ZSA/IFwiZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFwiIDogXCJncmVhdGVyIHRoYW4gXCJ9JHtuZXcgRGF0ZShOdW1iZXIodC5taW5pbXVtKSl9YCA6IHIgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZi50b29fYmlnOlxuICAgICAgdC50eXBlID09PSBcImFycmF5XCIgPyByID0gYEFycmF5IG11c3QgY29udGFpbiAke3QuZXhhY3QgPyBcImV4YWN0bHlcIiA6IHQuaW5jbHVzaXZlID8gXCJhdCBtb3N0XCIgOiBcImxlc3MgdGhhblwifSAke3QubWF4aW11bX0gZWxlbWVudChzKWAgOiB0LnR5cGUgPT09IFwic3RyaW5nXCIgPyByID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHt0LmV4YWN0ID8gXCJleGFjdGx5XCIgOiB0LmluY2x1c2l2ZSA/IFwiYXQgbW9zdFwiIDogXCJ1bmRlclwifSAke3QubWF4aW11bX0gY2hhcmFjdGVyKHMpYCA6IHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHIgPSBgTnVtYmVyIG11c3QgYmUgJHt0LmV4YWN0ID8gXCJleGFjdGx5XCIgOiB0LmluY2x1c2l2ZSA/IFwibGVzcyB0aGFuIG9yIGVxdWFsIHRvXCIgOiBcImxlc3MgdGhhblwifSAke3QubWF4aW11bX1gIDogdC50eXBlID09PSBcImJpZ2ludFwiID8gciA9IGBCaWdJbnQgbXVzdCBiZSAke3QuZXhhY3QgPyBcImV4YWN0bHlcIiA6IHQuaW5jbHVzaXZlID8gXCJsZXNzIHRoYW4gb3IgZXF1YWwgdG9cIiA6IFwibGVzcyB0aGFuXCJ9ICR7dC5tYXhpbXVtfWAgOiB0LnR5cGUgPT09IFwiZGF0ZVwiID8gciA9IGBEYXRlIG11c3QgYmUgJHt0LmV4YWN0ID8gXCJleGFjdGx5XCIgOiB0LmluY2x1c2l2ZSA/IFwic21hbGxlciB0aGFuIG9yIGVxdWFsIHRvXCIgOiBcInNtYWxsZXIgdGhhblwifSAke25ldyBEYXRlKE51bWJlcih0Lm1heGltdW0pKX1gIDogciA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmLmN1c3RvbTpcbiAgICAgIHIgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZi5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlczpcbiAgICAgIHIgPSBcIkludGVyc2VjdGlvbiByZXN1bHRzIGNvdWxkIG5vdCBiZSBtZXJnZWRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZi5ub3RfbXVsdGlwbGVfb2Y6XG4gICAgICByID0gYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHt0Lm11bHRpcGxlT2Z9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZi5ub3RfZmluaXRlOlxuICAgICAgciA9IFwiTnVtYmVyIG11c3QgYmUgZmluaXRlXCI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgciA9IGUuZGVmYXVsdEVycm9yLCB4LmFzc2VydE5ldmVyKHQpO1xuICB9XG4gIHJldHVybiB7IG1lc3NhZ2U6IHIgfTtcbn07XG5sZXQgbG4gPSBnZTtcbmZ1bmN0aW9uIFZhKHQpIHtcbiAgbG4gPSB0O1xufVxuZnVuY3Rpb24gWWUoKSB7XG4gIHJldHVybiBsbjtcbn1cbmNvbnN0IFhlID0gKHQpID0+IHtcbiAgY29uc3QgeyBkYXRhOiBlLCBwYXRoOiByLCBlcnJvck1hcHM6IG4sIGlzc3VlRGF0YTogcyB9ID0gdCwgYSA9IFsuLi5yLCAuLi5zLnBhdGggfHwgW11dLCBpID0ge1xuICAgIC4uLnMsXG4gICAgcGF0aDogYVxuICB9O1xuICBpZiAocy5tZXNzYWdlICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnMsXG4gICAgICBwYXRoOiBhLFxuICAgICAgbWVzc2FnZTogcy5tZXNzYWdlXG4gICAgfTtcbiAgbGV0IG8gPSBcIlwiO1xuICBjb25zdCBjID0gbi5maWx0ZXIoKHUpID0+ICEhdSkuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIGZvciAoY29uc3QgdSBvZiBjKVxuICAgIG8gPSB1KGksIHsgZGF0YTogZSwgZGVmYXVsdEVycm9yOiBvIH0pLm1lc3NhZ2U7XG4gIHJldHVybiB7XG4gICAgLi4ucyxcbiAgICBwYXRoOiBhLFxuICAgIG1lc3NhZ2U6IG9cbiAgfTtcbn0sIEZhID0gW107XG5mdW5jdGlvbiBwKHQsIGUpIHtcbiAgY29uc3QgciA9IFllKCksIG4gPSBYZSh7XG4gICAgaXNzdWVEYXRhOiBlLFxuICAgIGRhdGE6IHQuZGF0YSxcbiAgICBwYXRoOiB0LnBhdGgsXG4gICAgZXJyb3JNYXBzOiBbXG4gICAgICB0LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAvLyBjb250ZXh0dWFsIGVycm9yIG1hcCBpcyBmaXJzdCBwcmlvcml0eVxuICAgICAgdC5zY2hlbWFFcnJvck1hcCxcbiAgICAgIC8vIHRoZW4gc2NoZW1hLWJvdW5kIG1hcCBpZiBhdmFpbGFibGVcbiAgICAgIHIsXG4gICAgICAvLyB0aGVuIGdsb2JhbCBvdmVycmlkZSBtYXBcbiAgICAgIHIgPT09IGdlID8gdm9pZCAwIDogZ2VcbiAgICAgIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgXS5maWx0ZXIoKHMpID0+ICEhcylcbiAgfSk7XG4gIHQuY29tbW9uLmlzc3Vlcy5wdXNoKG4pO1xufVxuY2xhc3MgTiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudmFsdWUgPSBcInZhbGlkXCI7XG4gIH1cbiAgZGlydHkoKSB7XG4gICAgdGhpcy52YWx1ZSA9PT0gXCJ2YWxpZFwiICYmICh0aGlzLnZhbHVlID0gXCJkaXJ0eVwiKTtcbiAgfVxuICBhYm9ydCgpIHtcbiAgICB0aGlzLnZhbHVlICE9PSBcImFib3J0ZWRcIiAmJiAodGhpcy52YWx1ZSA9IFwiYWJvcnRlZFwiKTtcbiAgfVxuICBzdGF0aWMgbWVyZ2VBcnJheShlLCByKSB7XG4gICAgY29uc3QgbiA9IFtdO1xuICAgIGZvciAoY29uc3QgcyBvZiByKSB7XG4gICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gdjtcbiAgICAgIHMuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgZS5kaXJ0eSgpLCBuLnB1c2gocy52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogZS52YWx1ZSwgdmFsdWU6IG4gfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgbWVyZ2VPYmplY3RBc3luYyhlLCByKSB7XG4gICAgY29uc3QgbiA9IFtdO1xuICAgIGZvciAoY29uc3QgcyBvZiByKSB7XG4gICAgICBjb25zdCBhID0gYXdhaXQgcy5rZXksIGkgPSBhd2FpdCBzLnZhbHVlO1xuICAgICAgbi5wdXNoKHtcbiAgICAgICAga2V5OiBhLFxuICAgICAgICB2YWx1ZTogaVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBOLm1lcmdlT2JqZWN0U3luYyhlLCBuKTtcbiAgfVxuICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKGUsIHIpIHtcbiAgICBjb25zdCBuID0ge307XG4gICAgZm9yIChjb25zdCBzIG9mIHIpIHtcbiAgICAgIGNvbnN0IHsga2V5OiBhLCB2YWx1ZTogaSB9ID0gcztcbiAgICAgIGlmIChhLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgaS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gdjtcbiAgICAgIGEuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgZS5kaXJ0eSgpLCBpLnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmIGUuZGlydHkoKSwgYS52YWx1ZSAhPT0gXCJfX3Byb3RvX19cIiAmJiAodHlwZW9mIGkudmFsdWUgPCBcInVcIiB8fCBzLmFsd2F5c1NldCkgJiYgKG5bYS52YWx1ZV0gPSBpLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBlLnZhbHVlLCB2YWx1ZTogbiB9O1xuICB9XG59XG5jb25zdCB2ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHN0YXR1czogXCJhYm9ydGVkXCJcbn0pLCBoZSA9ICh0KSA9PiAoeyBzdGF0dXM6IFwiZGlydHlcIiwgdmFsdWU6IHQgfSksIEkgPSAodCkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiB0IH0pLCBBdCA9ICh0KSA9PiB0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIsIE50ID0gKHQpID0+IHQuc3RhdHVzID09PSBcImRpcnR5XCIsIG9lID0gKHQpID0+IHQuc3RhdHVzID09PSBcInZhbGlkXCIsIE5lID0gKHQpID0+IHR5cGVvZiBQcm9taXNlIDwgXCJ1XCIgJiYgdCBpbnN0YW5jZW9mIFByb21pc2U7XG5mdW5jdGlvbiBRZSh0LCBlLCByLCBuKSB7XG4gIGlmIChyID09PSBcImFcIiAmJiAhbilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gdCAhPT0gZSB8fCAhbiA6ICFlLmhhcyh0KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gciA9PT0gXCJtXCIgPyBuIDogciA9PT0gXCJhXCIgPyBuLmNhbGwodCkgOiBuID8gbi52YWx1ZSA6IGUuZ2V0KHQpO1xufVxuZnVuY3Rpb24gZG4odCwgZSwgciwgbiwgcykge1xuICBpZiAobiA9PT0gXCJtXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgaWYgKG4gPT09IFwiYVwiICYmICFzKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyB0ICE9PSBlIHx8ICFzIDogIWUuaGFzKHQpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIG4gPT09IFwiYVwiID8gcy5jYWxsKHQsIHIpIDogcyA/IHMudmFsdWUgPSByIDogZS5zZXQodCwgciksIHI7XG59XG52YXIgZztcbihmdW5jdGlvbih0KSB7XG4gIHQuZXJyVG9PYmogPSAoZSkgPT4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogZSB9IDogZSB8fCB7fSwgdC50b1N0cmluZyA9IChlKSA9PiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZSA6IGU/Lm1lc3NhZ2U7XG59KShnIHx8IChnID0ge30pKTtcbnZhciBSZSwgT2U7XG5jbGFzcyBCIHtcbiAgY29uc3RydWN0b3IoZSwgciwgbiwgcykge1xuICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXSwgdGhpcy5wYXJlbnQgPSBlLCB0aGlzLmRhdGEgPSByLCB0aGlzLl9wYXRoID0gbiwgdGhpcy5fa2V5ID0gcztcbiAgfVxuICBnZXQgcGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkUGF0aC5sZW5ndGggfHwgKHRoaXMuX2tleSBpbnN0YW5jZW9mIEFycmF5ID8gdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSkgOiB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KSksIHRoaXMuX2NhY2hlZFBhdGg7XG4gIH1cbn1cbmNvbnN0IF9yID0gKHQsIGUpID0+IHtcbiAgaWYgKG9lKGUpKVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6ICEwLCBkYXRhOiBlLnZhbHVlIH07XG4gIGlmICghdC5jb21tb24uaXNzdWVzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW9uIGZhaWxlZCBidXQgbm8gaXNzdWVzIGRldGVjdGVkLlwiKTtcbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiAhMSxcbiAgICBnZXQgZXJyb3IoKSB7XG4gICAgICBpZiAodGhpcy5fZXJyb3IpXG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgIGNvbnN0IHIgPSBuZXcgTCh0LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yID0gciwgdGhpcy5fZXJyb3I7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGIodCkge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIHt9O1xuICBjb25zdCB7IGVycm9yTWFwOiBlLCBpbnZhbGlkX3R5cGVfZXJyb3I6IHIsIHJlcXVpcmVkX2Vycm9yOiBuLCBkZXNjcmlwdGlvbjogcyB9ID0gdDtcbiAgaWYgKGUgJiYgKHIgfHwgbikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xuICByZXR1cm4gZSA/IHsgZXJyb3JNYXA6IGUsIGRlc2NyaXB0aW9uOiBzIH0gOiB7IGVycm9yTWFwOiAoaSwgbykgPT4ge1xuICAgIHZhciBjLCB1O1xuICAgIGNvbnN0IHsgbWVzc2FnZTogZCB9ID0gdDtcbiAgICByZXR1cm4gaS5jb2RlID09PSBcImludmFsaWRfZW51bV92YWx1ZVwiID8geyBtZXNzYWdlOiBkID8/IG8uZGVmYXVsdEVycm9yIH0gOiB0eXBlb2Ygby5kYXRhID4gXCJ1XCIgPyB7IG1lc3NhZ2U6IChjID0gZCA/PyBuKSAhPT0gbnVsbCAmJiBjICE9PSB2b2lkIDAgPyBjIDogby5kZWZhdWx0RXJyb3IgfSA6IGkuY29kZSAhPT0gXCJpbnZhbGlkX3R5cGVcIiA/IHsgbWVzc2FnZTogby5kZWZhdWx0RXJyb3IgfSA6IHsgbWVzc2FnZTogKHUgPSBkID8/IHIpICE9PSBudWxsICYmIHUgIT09IHZvaWQgMCA/IHUgOiBvLmRlZmF1bHRFcnJvciB9O1xuICB9LCBkZXNjcmlwdGlvbjogcyB9O1xufVxuY2xhc3MgdyB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmRlc2NyaXB0aW9uO1xuICB9XG4gIF9nZXRUeXBlKGUpIHtcbiAgICByZXR1cm4gWShlLmRhdGEpO1xuICB9XG4gIF9nZXRPclJldHVybkN0eChlLCByKSB7XG4gICAgcmV0dXJuIHIgfHwge1xuICAgICAgY29tbW9uOiBlLnBhcmVudC5jb21tb24sXG4gICAgICBkYXRhOiBlLmRhdGEsXG4gICAgICBwYXJzZWRUeXBlOiBZKGUuZGF0YSksXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGF0aDogZS5wYXRoLFxuICAgICAgcGFyZW50OiBlLnBhcmVudFxuICAgIH07XG4gIH1cbiAgX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogbmV3IE4oKSxcbiAgICAgIGN0eDoge1xuICAgICAgICBjb21tb246IGUucGFyZW50LmNvbW1vbixcbiAgICAgICAgZGF0YTogZS5kYXRhLFxuICAgICAgICBwYXJzZWRUeXBlOiBZKGUuZGF0YSksXG4gICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgIHBhdGg6IGUucGF0aCxcbiAgICAgICAgcGFyZW50OiBlLnBhcmVudFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgX3BhcnNlU3luYyhlKSB7XG4gICAgY29uc3QgciA9IHRoaXMuX3BhcnNlKGUpO1xuICAgIGlmIChOZShyKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIHBhcnNlIGVuY291bnRlcmVkIHByb21pc2UuXCIpO1xuICAgIHJldHVybiByO1xuICB9XG4gIF9wYXJzZUFzeW5jKGUpIHtcbiAgICBjb25zdCByID0gdGhpcy5fcGFyc2UoZSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyKTtcbiAgfVxuICBwYXJzZShlLCByKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuc2FmZVBhcnNlKGUsIHIpO1xuICAgIGlmIChuLnN1Y2Nlc3MpXG4gICAgICByZXR1cm4gbi5kYXRhO1xuICAgIHRocm93IG4uZXJyb3I7XG4gIH1cbiAgc2FmZVBhcnNlKGUsIHIpIHtcbiAgICB2YXIgbjtcbiAgICBjb25zdCBzID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGFzeW5jOiAobiA9IHI/LmFzeW5jKSAhPT0gbnVsbCAmJiBuICE9PSB2b2lkIDAgPyBuIDogITEsXG4gICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcj8uZXJyb3JNYXBcbiAgICAgIH0sXG4gICAgICBwYXRoOiByPy5wYXRoIHx8IFtdLFxuICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgIGRhdGE6IGUsXG4gICAgICBwYXJzZWRUeXBlOiBZKGUpXG4gICAgfSwgYSA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGE6IGUsIHBhdGg6IHMucGF0aCwgcGFyZW50OiBzIH0pO1xuICAgIHJldHVybiBfcihzLCBhKTtcbiAgfVxuICBcIn52YWxpZGF0ZVwiKGUpIHtcbiAgICB2YXIgciwgbjtcbiAgICBjb25zdCBzID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGFzeW5jOiAhIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmNcbiAgICAgIH0sXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICBkYXRhOiBlLFxuICAgICAgcGFyc2VkVHlwZTogWShlKVxuICAgIH07XG4gICAgaWYgKCF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGE6IGUsIHBhdGg6IFtdLCBwYXJlbnQ6IHMgfSk7XG4gICAgICAgIHJldHVybiBvZShhKSA/IHtcbiAgICAgICAgICB2YWx1ZTogYS52YWx1ZVxuICAgICAgICB9IDoge1xuICAgICAgICAgIGlzc3Vlczogcy5jb21tb24uaXNzdWVzXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChhKSB7XG4gICAgICAgICEoKG4gPSAociA9IGE/Lm1lc3NhZ2UpID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIudG9Mb3dlckNhc2UoKSkgPT09IG51bGwgfHwgbiA9PT0gdm9pZCAwKSAmJiBuLmluY2x1ZGVzKFwiZW5jb3VudGVyZWRcIikgJiYgKHRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMgPSAhMCksIHMuY29tbW9uID0ge1xuICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgYXN5bmM6ICEwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlQXN5bmMoeyBkYXRhOiBlLCBwYXRoOiBbXSwgcGFyZW50OiBzIH0pLnRoZW4oKGEpID0+IG9lKGEpID8ge1xuICAgICAgdmFsdWU6IGEudmFsdWVcbiAgICB9IDoge1xuICAgICAgaXNzdWVzOiBzLmNvbW1vbi5pc3N1ZXNcbiAgICB9KTtcbiAgfVxuICBhc3luYyBwYXJzZUFzeW5jKGUsIHIpIHtcbiAgICBjb25zdCBuID0gYXdhaXQgdGhpcy5zYWZlUGFyc2VBc3luYyhlLCByKTtcbiAgICBpZiAobi5zdWNjZXNzKVxuICAgICAgcmV0dXJuIG4uZGF0YTtcbiAgICB0aHJvdyBuLmVycm9yO1xuICB9XG4gIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGUsIHIpIHtcbiAgICBjb25zdCBuID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcj8uZXJyb3JNYXAsXG4gICAgICAgIGFzeW5jOiAhMFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHI/LnBhdGggfHwgW10sXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgZGF0YTogZSxcbiAgICAgIHBhcnNlZFR5cGU6IFkoZSlcbiAgICB9LCBzID0gdGhpcy5fcGFyc2UoeyBkYXRhOiBlLCBwYXRoOiBuLnBhdGgsIHBhcmVudDogbiB9KSwgYSA9IGF3YWl0IChOZShzKSA/IHMgOiBQcm9taXNlLnJlc29sdmUocykpO1xuICAgIHJldHVybiBfcihuLCBhKTtcbiAgfVxuICByZWZpbmUoZSwgcikge1xuICAgIGNvbnN0IG4gPSAocykgPT4gdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgciA+IFwidVwiID8geyBtZXNzYWdlOiByIH0gOiB0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgPyByKHMpIDogcjtcbiAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgocywgYSkgPT4ge1xuICAgICAgY29uc3QgaSA9IGUocyksIG8gPSAoKSA9PiBhLmFkZElzc3VlKHtcbiAgICAgICAgY29kZTogZi5jdXN0b20sXG4gICAgICAgIC4uLm4ocylcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHR5cGVvZiBQcm9taXNlIDwgXCJ1XCIgJiYgaSBpbnN0YW5jZW9mIFByb21pc2UgPyBpLnRoZW4oKGMpID0+IGMgPyAhMCA6IChvKCksICExKSkgOiBpID8gITAgOiAobygpLCAhMSk7XG4gICAgfSk7XG4gIH1cbiAgcmVmaW5lbWVudChlLCByKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKG4sIHMpID0+IGUobikgPyAhMCA6IChzLmFkZElzc3VlKHR5cGVvZiByID09IFwiZnVuY3Rpb25cIiA/IHIobiwgcykgOiByKSwgITEpKTtcbiAgfVxuICBfcmVmaW5lbWVudChlKSB7XG4gICAgcmV0dXJuIG5ldyBXKHtcbiAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgIHR5cGVOYW1lOiBfLlpvZEVmZmVjdHMsXG4gICAgICBlZmZlY3Q6IHsgdHlwZTogXCJyZWZpbmVtZW50XCIsIHJlZmluZW1lbnQ6IGUgfVxuICAgIH0pO1xuICB9XG4gIHN1cGVyUmVmaW5lKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudChlKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLCB0aGlzLl9kZWYgPSBlLCB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpLCB0aGlzLnNhZmVQYXJzZSA9IHRoaXMuc2FmZVBhcnNlLmJpbmQodGhpcyksIHRoaXMucGFyc2VBc3luYyA9IHRoaXMucGFyc2VBc3luYy5iaW5kKHRoaXMpLCB0aGlzLnNhZmVQYXJzZUFzeW5jID0gdGhpcy5zYWZlUGFyc2VBc3luYy5iaW5kKHRoaXMpLCB0aGlzLnNwYSA9IHRoaXMuc3BhLmJpbmQodGhpcyksIHRoaXMucmVmaW5lID0gdGhpcy5yZWZpbmUuYmluZCh0aGlzKSwgdGhpcy5yZWZpbmVtZW50ID0gdGhpcy5yZWZpbmVtZW50LmJpbmQodGhpcyksIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLnN1cGVyUmVmaW5lLmJpbmQodGhpcyksIHRoaXMub3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLmJpbmQodGhpcyksIHRoaXMubnVsbGFibGUgPSB0aGlzLm51bGxhYmxlLmJpbmQodGhpcyksIHRoaXMubnVsbGlzaCA9IHRoaXMubnVsbGlzaC5iaW5kKHRoaXMpLCB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5iaW5kKHRoaXMpLCB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuYmluZCh0aGlzKSwgdGhpcy5vciA9IHRoaXMub3IuYmluZCh0aGlzKSwgdGhpcy5hbmQgPSB0aGlzLmFuZC5iaW5kKHRoaXMpLCB0aGlzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyksIHRoaXMuYnJhbmQgPSB0aGlzLmJyYW5kLmJpbmQodGhpcyksIHRoaXMuZGVmYXVsdCA9IHRoaXMuZGVmYXVsdC5iaW5kKHRoaXMpLCB0aGlzLmNhdGNoID0gdGhpcy5jYXRjaC5iaW5kKHRoaXMpLCB0aGlzLmRlc2NyaWJlID0gdGhpcy5kZXNjcmliZS5iaW5kKHRoaXMpLCB0aGlzLnBpcGUgPSB0aGlzLnBpcGUuYmluZCh0aGlzKSwgdGhpcy5yZWFkb25seSA9IHRoaXMucmVhZG9ubHkuYmluZCh0aGlzKSwgdGhpcy5pc051bGxhYmxlID0gdGhpcy5pc051bGxhYmxlLmJpbmQodGhpcyksIHRoaXMuaXNPcHRpb25hbCA9IHRoaXMuaXNPcHRpb25hbC5iaW5kKHRoaXMpLCB0aGlzW1wifnN0YW5kYXJkXCJdID0ge1xuICAgICAgdmVyc2lvbjogMSxcbiAgICAgIHZlbmRvcjogXCJ6b2RcIixcbiAgICAgIHZhbGlkYXRlOiAocikgPT4gdGhpc1tcIn52YWxpZGF0ZVwiXShyKVxuICAgIH07XG4gIH1cbiAgb3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIHouY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gIH1cbiAgbnVsbGFibGUoKSB7XG4gICAgcmV0dXJuIHJlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICB9XG4gIG51bGxpc2goKSB7XG4gICAgcmV0dXJuIHRoaXMubnVsbGFibGUoKS5vcHRpb25hbCgpO1xuICB9XG4gIGFycmF5KCkge1xuICAgIHJldHVybiBVLmNyZWF0ZSh0aGlzKTtcbiAgfVxuICBwcm9taXNlKCkge1xuICAgIHJldHVybiB2ZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBvcihlKSB7XG4gICAgcmV0dXJuICRlLmNyZWF0ZShbdGhpcywgZV0sIHRoaXMuX2RlZik7XG4gIH1cbiAgYW5kKGUpIHtcbiAgICByZXR1cm4gTWUuY3JlYXRlKHRoaXMsIGUsIHRoaXMuX2RlZik7XG4gIH1cbiAgdHJhbnNmb3JtKGUpIHtcbiAgICByZXR1cm4gbmV3IFcoe1xuICAgICAgLi4uYih0aGlzLl9kZWYpLFxuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdHlwZU5hbWU6IF8uWm9kRWZmZWN0cyxcbiAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm06IGUgfVxuICAgIH0pO1xuICB9XG4gIGRlZmF1bHQoZSkge1xuICAgIGNvbnN0IHIgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogKCkgPT4gZTtcbiAgICByZXR1cm4gbmV3IHFlKHtcbiAgICAgIC4uLmIodGhpcy5fZGVmKSxcbiAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogcixcbiAgICAgIHR5cGVOYW1lOiBfLlpvZERlZmF1bHRcbiAgICB9KTtcbiAgfVxuICBicmFuZCgpIHtcbiAgICByZXR1cm4gbmV3IFl0KHtcbiAgICAgIHR5cGVOYW1lOiBfLlpvZEJyYW5kZWQsXG4gICAgICB0eXBlOiB0aGlzLFxuICAgICAgLi4uYih0aGlzLl9kZWYpXG4gICAgfSk7XG4gIH1cbiAgY2F0Y2goZSkge1xuICAgIGNvbnN0IHIgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogKCkgPT4gZTtcbiAgICByZXR1cm4gbmV3IHplKHtcbiAgICAgIC4uLmIodGhpcy5fZGVmKSxcbiAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgIGNhdGNoVmFsdWU6IHIsXG4gICAgICB0eXBlTmFtZTogXy5ab2RDYXRjaFxuICAgIH0pO1xuICB9XG4gIGRlc2NyaWJlKGUpIHtcbiAgICBjb25zdCByID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gbmV3IHIoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgZGVzY3JpcHRpb246IGVcbiAgICB9KTtcbiAgfVxuICBwaXBlKGUpIHtcbiAgICByZXR1cm4gRmUuY3JlYXRlKHRoaXMsIGUpO1xuICB9XG4gIHJlYWRvbmx5KCkge1xuICAgIHJldHVybiBCZS5jcmVhdGUodGhpcyk7XG4gIH1cbiAgaXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2Uodm9pZCAwKS5zdWNjZXNzO1xuICB9XG4gIGlzTnVsbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gIH1cbn1cbmNvbnN0IEhhID0gL15jW15cXHMtXXs4LH0kL2ksIEdhID0gL15bMC05YS16XSskLywgSmEgPSAvXlswLTlBLUhKS01OUC1UVi1aXXsyNn0kL2ksIFlhID0gL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kL2ksIFhhID0gL15bYS16MC05Xy1dezIxfSQvaSwgUWEgPSAvXltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dKiQvLCBLYSA9IC9eWy0rXT9QKD8hJCkoPzooPzpbLStdP1xcZCtZKXwoPzpbLStdP1xcZCtbLixdXFxkK1kkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/Oig/OlstK10/XFxkK1cpfCg/OlstK10/XFxkK1suLF1cXGQrVyQpKT8oPzooPzpbLStdP1xcZCtEKXwoPzpbLStdP1xcZCtbLixdXFxkK0QkKSk/KD86VCg/PVtcXGQrLV0pKD86KD86Wy0rXT9cXGQrSCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtIJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzpbLStdP1xcZCsoPzpbLixdXFxkKyk/Uyk/KT8/JC8sIGVpID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaSwgdGkgPSBcIl4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskXCI7XG5sZXQgeHQ7XG5jb25zdCByaSA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC8sIG5pID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC8oM1swLTJdfFsxMl0/WzAtOV0pJC8sIHNpID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpJC8sIGFpID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpXFwvKDEyWzAtOF18MVswMV1bMC05XXxbMS05XT9bMC05XSkkLywgaWkgPSAvXihbMC05YS16QS1aKy9dezR9KSooKFswLTlhLXpBLVorL117Mn09PSl8KFswLTlhLXpBLVorL117M309KSk/JC8sIG9pID0gL14oWzAtOWEtekEtWi1fXXs0fSkqKChbMC05YS16QS1aLV9dezJ9KD09KT8pfChbMC05YS16QS1aLV9dezN9KD0pPykpPyQvLCBmbiA9IFwiKChcXFxcZFxcXFxkWzI0NjhdWzA0OF18XFxcXGRcXFxcZFsxMzU3OV1bMjZdfFxcXFxkXFxcXGQwWzQ4XXxbMDI0NjhdWzA0OF0wMHxbMTM1NzldWzI2XTAwKS0wMi0yOXxcXFxcZHs0fS0oKDBbMTM1NzhdfDFbMDJdKS0oMFsxLTldfFsxMl1cXFxcZHwzWzAxXSl8KDBbNDY5XXwxMSktKDBbMS05XXxbMTJdXFxcXGR8MzApfCgwMiktKDBbMS05XXwxXFxcXGR8MlswLThdKSkpXCIsIGNpID0gbmV3IFJlZ0V4cChgXiR7Zm59JGApO1xuZnVuY3Rpb24gcG4odCkge1xuICBsZXQgZSA9IFwiKFswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGQ6WzAtNV1cXFxcZFwiO1xuICByZXR1cm4gdC5wcmVjaXNpb24gPyBlID0gYCR7ZX1cXFxcLlxcXFxkeyR7dC5wcmVjaXNpb259fWAgOiB0LnByZWNpc2lvbiA9PSBudWxsICYmIChlID0gYCR7ZX0oXFxcXC5cXFxcZCspP2ApLCBlO1xufVxuZnVuY3Rpb24gdWkodCkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7cG4odCl9JGApO1xufVxuZnVuY3Rpb24gaG4odCkge1xuICBsZXQgZSA9IGAke2ZufVQke3BuKHQpfWA7XG4gIGNvbnN0IHIgPSBbXTtcbiAgcmV0dXJuIHIucHVzaCh0LmxvY2FsID8gXCJaP1wiIDogXCJaXCIpLCB0Lm9mZnNldCAmJiByLnB1c2goXCIoWystXVxcXFxkezJ9Oj9cXFxcZHsyfSlcIiksIGUgPSBgJHtlfSgke3Iuam9pbihcInxcIil9KWAsIG5ldyBSZWdFeHAoYF4ke2V9JGApO1xufVxuZnVuY3Rpb24gbGkodCwgZSkge1xuICByZXR1cm4gISEoKGUgPT09IFwidjRcIiB8fCAhZSkgJiYgcmkudGVzdCh0KSB8fCAoZSA9PT0gXCJ2NlwiIHx8ICFlKSAmJiBzaS50ZXN0KHQpKTtcbn1cbmZ1bmN0aW9uIGRpKHQsIGUpIHtcbiAgaWYgKCFRYS50ZXN0KHQpKVxuICAgIHJldHVybiAhMTtcbiAgdHJ5IHtcbiAgICBjb25zdCBbcl0gPSB0LnNwbGl0KFwiLlwiKSwgbiA9IHIucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIikucGFkRW5kKHIubGVuZ3RoICsgKDQgLSByLmxlbmd0aCAlIDQpICUgNCwgXCI9XCIpLCBzID0gSlNPTi5wYXJzZShhdG9iKG4pKTtcbiAgICByZXR1cm4gISh0eXBlb2YgcyAhPSBcIm9iamVjdFwiIHx8IHMgPT09IG51bGwgfHwgIXMudHlwIHx8ICFzLmFsZyB8fCBlICYmIHMuYWxnICE9PSBlKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBmaSh0LCBlKSB7XG4gIHJldHVybiAhISgoZSA9PT0gXCJ2NFwiIHx8ICFlKSAmJiBuaS50ZXN0KHQpIHx8IChlID09PSBcInY2XCIgfHwgIWUpICYmIGFpLnRlc3QodCkpO1xufVxuY2xhc3MgWiBleHRlbmRzIHcge1xuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlICYmIChlLmRhdGEgPSBTdHJpbmcoZS5kYXRhKSksIHRoaXMuX2dldFR5cGUoZSkgIT09IG0uc3RyaW5nKSB7XG4gICAgICBjb25zdCBhID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gcChhLCB7XG4gICAgICAgIGNvZGU6IGYuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbS5zdHJpbmcsXG4gICAgICAgIHJlY2VpdmVkOiBhLnBhcnNlZFR5cGVcbiAgICAgIH0pLCB2O1xuICAgIH1cbiAgICBjb25zdCBuID0gbmV3IE4oKTtcbiAgICBsZXQgcztcbiAgICBmb3IgKGNvbnN0IGEgb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIGlmIChhLmtpbmQgPT09IFwibWluXCIpXG4gICAgICAgIGUuZGF0YS5sZW5ndGggPCBhLnZhbHVlICYmIChzID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgcyksIHAocywge1xuICAgICAgICAgIGNvZGU6IGYudG9vX3NtYWxsLFxuICAgICAgICAgIG1pbmltdW06IGEudmFsdWUsXG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgICAgIGV4YWN0OiAhMSxcbiAgICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgICAgfSksIG4uZGlydHkoKSk7XG4gICAgICBlbHNlIGlmIChhLmtpbmQgPT09IFwibWF4XCIpXG4gICAgICAgIGUuZGF0YS5sZW5ndGggPiBhLnZhbHVlICYmIChzID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgcyksIHAocywge1xuICAgICAgICAgIGNvZGU6IGYudG9vX2JpZyxcbiAgICAgICAgICBtYXhpbXVtOiBhLnZhbHVlLFxuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgICBleGFjdDogITEsXG4gICAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoYS5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgIGNvbnN0IGkgPSBlLmRhdGEubGVuZ3RoID4gYS52YWx1ZSwgbyA9IGUuZGF0YS5sZW5ndGggPCBhLnZhbHVlO1xuICAgICAgICAoaSB8fCBvKSAmJiAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBpID8gcChzLCB7XG4gICAgICAgICAgY29kZTogZi50b29fYmlnLFxuICAgICAgICAgIG1heGltdW06IGEudmFsdWUsXG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgICAgIGV4YWN0OiAhMCxcbiAgICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgICAgfSkgOiBvICYmIHAocywge1xuICAgICAgICAgIGNvZGU6IGYudG9vX3NtYWxsLFxuICAgICAgICAgIG1pbmltdW06IGEudmFsdWUsXG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgICAgIGV4YWN0OiAhMCxcbiAgICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgICAgfSksIG4uZGlydHkoKSk7XG4gICAgICB9IGVsc2UgaWYgKGEua2luZCA9PT0gXCJlbWFpbFwiKVxuICAgICAgICBlaS50ZXN0KGUuZGF0YSkgfHwgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgcChzLCB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgIGNvZGU6IGYuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoYS5raW5kID09PSBcImVtb2ppXCIpXG4gICAgICAgIHh0IHx8ICh4dCA9IG5ldyBSZWdFeHAodGksIFwidVwiKSksIHh0LnRlc3QoZS5kYXRhKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBwKHMsIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgY29kZTogZi5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgICAgfSksIG4uZGlydHkoKSk7XG4gICAgICBlbHNlIGlmIChhLmtpbmQgPT09IFwidXVpZFwiKVxuICAgICAgICBZYS50ZXN0KGUuZGF0YSkgfHwgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgcChzLCB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgY29kZTogZi5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgICAgfSksIG4uZGlydHkoKSk7XG4gICAgICBlbHNlIGlmIChhLmtpbmQgPT09IFwibmFub2lkXCIpXG4gICAgICAgIFhhLnRlc3QoZS5kYXRhKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBwKHMsIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcIm5hbm9pZFwiLFxuICAgICAgICAgIGNvZGU6IGYuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoYS5raW5kID09PSBcImN1aWRcIilcbiAgICAgICAgSGEudGVzdChlLmRhdGEpIHx8IChzID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgcyksIHAocywge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZFwiLFxuICAgICAgICAgIGNvZGU6IGYuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoYS5raW5kID09PSBcImN1aWQyXCIpXG4gICAgICAgIEdhLnRlc3QoZS5kYXRhKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBwKHMsIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgY29kZTogZi5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgICAgfSksIG4uZGlydHkoKSk7XG4gICAgICBlbHNlIGlmIChhLmtpbmQgPT09IFwidWxpZFwiKVxuICAgICAgICBKYS50ZXN0KGUuZGF0YSkgfHwgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgcChzLCB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJ1bGlkXCIsXG4gICAgICAgICAgY29kZTogZi5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgICAgfSksIG4uZGlydHkoKSk7XG4gICAgICBlbHNlIGlmIChhLmtpbmQgPT09IFwidXJsXCIpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3IFVSTChlLmRhdGEpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBzID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgcyksIHAocywge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgIGNvZGU6IGYuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgICAgICB9KSwgbi5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIGEua2luZCA9PT0gXCJyZWdleFwiID8gKGEucmVnZXgubGFzdEluZGV4ID0gMCwgYS5yZWdleC50ZXN0KGUuZGF0YSkgfHwgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgcChzLCB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJyZWdleFwiLFxuICAgICAgICAgIGNvZGU6IGYuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpKSA6IGEua2luZCA9PT0gXCJ0cmltXCIgPyBlLmRhdGEgPSBlLmRhdGEudHJpbSgpIDogYS5raW5kID09PSBcImluY2x1ZGVzXCIgPyBlLmRhdGEuaW5jbHVkZXMoYS52YWx1ZSwgYS5wb3NpdGlvbikgfHwgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgcChzLCB7XG4gICAgICAgICAgY29kZTogZi5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBhLnZhbHVlLCBwb3NpdGlvbjogYS5wb3NpdGlvbiB9LFxuICAgICAgICAgIG1lc3NhZ2U6IGEubWVzc2FnZVxuICAgICAgICB9KSwgbi5kaXJ0eSgpKSA6IGEua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiID8gZS5kYXRhID0gZS5kYXRhLnRvTG93ZXJDYXNlKCkgOiBhLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIiA/IGUuZGF0YSA9IGUuZGF0YS50b1VwcGVyQ2FzZSgpIDogYS5raW5kID09PSBcInN0YXJ0c1dpdGhcIiA/IGUuZGF0YS5zdGFydHNXaXRoKGEudmFsdWUpIHx8IChzID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgcyksIHAocywge1xuICAgICAgICAgIGNvZGU6IGYuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBhLnZhbHVlIH0sXG4gICAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpIDogYS5raW5kID09PSBcImVuZHNXaXRoXCIgPyBlLmRhdGEuZW5kc1dpdGgoYS52YWx1ZSkgfHwgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgcChzLCB7XG4gICAgICAgICAgY29kZTogZi5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBhLnZhbHVlIH0sXG4gICAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpIDogYS5raW5kID09PSBcImRhdGV0aW1lXCIgPyBobihhKS50ZXN0KGUuZGF0YSkgfHwgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgcChzLCB7XG4gICAgICAgICAgY29kZTogZi5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpIDogYS5raW5kID09PSBcImRhdGVcIiA/IGNpLnRlc3QoZS5kYXRhKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBwKHMsIHtcbiAgICAgICAgICBjb2RlOiBmLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZVwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGEubWVzc2FnZVxuICAgICAgICB9KSwgbi5kaXJ0eSgpKSA6IGEua2luZCA9PT0gXCJ0aW1lXCIgPyB1aShhKS50ZXN0KGUuZGF0YSkgfHwgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgcChzLCB7XG4gICAgICAgICAgY29kZTogZi5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcInRpbWVcIixcbiAgICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgICAgfSksIG4uZGlydHkoKSkgOiBhLmtpbmQgPT09IFwiZHVyYXRpb25cIiA/IEthLnRlc3QoZS5kYXRhKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBwKHMsIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImR1cmF0aW9uXCIsXG4gICAgICAgICAgY29kZTogZi5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgICAgfSksIG4uZGlydHkoKSkgOiBhLmtpbmQgPT09IFwiaXBcIiA/IGxpKGUuZGF0YSwgYS52ZXJzaW9uKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBwKHMsIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwXCIsXG4gICAgICAgICAgY29kZTogZi5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgICAgfSksIG4uZGlydHkoKSkgOiBhLmtpbmQgPT09IFwiand0XCIgPyBkaShlLmRhdGEsIGEuYWxnKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBwKHMsIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImp3dFwiLFxuICAgICAgICAgIGNvZGU6IGYuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpIDogYS5raW5kID09PSBcImNpZHJcIiA/IGZpKGUuZGF0YSwgYS52ZXJzaW9uKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBwKHMsIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImNpZHJcIixcbiAgICAgICAgICBjb2RlOiBmLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgIG1lc3NhZ2U6IGEubWVzc2FnZVxuICAgICAgICB9KSwgbi5kaXJ0eSgpKSA6IGEua2luZCA9PT0gXCJiYXNlNjRcIiA/IGlpLnRlc3QoZS5kYXRhKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBwKHMsIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NFwiLFxuICAgICAgICAgIGNvZGU6IGYuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICAgIH0pLCBuLmRpcnR5KCkpIDogYS5raW5kID09PSBcImJhc2U2NHVybFwiID8gb2kudGVzdChlLmRhdGEpIHx8IChzID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgcyksIHAocywge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgY29kZTogZi5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgICAgfSksIG4uZGlydHkoKSkgOiB4LmFzc2VydE5ldmVyKGEpO1xuICAgIHJldHVybiB7IHN0YXR1czogbi52YWx1ZSwgdmFsdWU6IGUuZGF0YSB9O1xuICB9XG4gIF9yZWdleChlLCByLCBuKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmaW5lbWVudCgocykgPT4gZS50ZXN0KHMpLCB7XG4gICAgICB2YWxpZGF0aW9uOiByLFxuICAgICAgY29kZTogZi5pbnZhbGlkX3N0cmluZyxcbiAgICAgIC4uLmcuZXJyVG9PYmoobilcbiAgICB9KTtcbiAgfVxuICBfYWRkQ2hlY2soZSkge1xuICAgIHJldHVybiBuZXcgWih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBlXVxuICAgIH0pO1xuICB9XG4gIGVtYWlsKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmcuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgdXJsKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVybFwiLCAuLi5nLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIGVtb2ppKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtb2ppXCIsIC4uLmcuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgdXVpZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmcuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgbmFub2lkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcIm5hbm9pZFwiLCAuLi5nLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIGN1aWQoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZFwiLCAuLi5nLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIGN1aWQyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmcuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgdWxpZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1bGlkXCIsIC4uLmcuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgYmFzZTY0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImJhc2U2NFwiLCAuLi5nLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIGJhc2U2NHVybChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiYmFzZTY0dXJsXCIsXG4gICAgICAuLi5nLmVyclRvT2JqKGUpXG4gICAgfSk7XG4gIH1cbiAgand0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImp3dFwiLCAuLi5nLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIGlwKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmcuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgY2lkcihlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjaWRyXCIsIC4uLmcuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgZGF0ZXRpbWUoZSkge1xuICAgIHZhciByLCBuO1xuICAgIHJldHVybiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgb2Zmc2V0OiAhMSxcbiAgICAgIGxvY2FsOiAhMSxcbiAgICAgIG1lc3NhZ2U6IGVcbiAgICB9KSA6IHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgIHByZWNpc2lvbjogdHlwZW9mIGU/LnByZWNpc2lvbiA+IFwidVwiID8gbnVsbCA6IGU/LnByZWNpc2lvbixcbiAgICAgIG9mZnNldDogKHIgPSBlPy5vZmZzZXQpICE9PSBudWxsICYmIHIgIT09IHZvaWQgMCA/IHIgOiAhMSxcbiAgICAgIGxvY2FsOiAobiA9IGU/LmxvY2FsKSAhPT0gbnVsbCAmJiBuICE9PSB2b2lkIDAgPyBuIDogITEsXG4gICAgICAuLi5nLmVyclRvT2JqKGU/Lm1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZGF0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkYXRlXCIsIG1lc3NhZ2U6IGUgfSk7XG4gIH1cbiAgdGltZShlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgIG1lc3NhZ2U6IGVcbiAgICB9KSA6IHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgZT8ucHJlY2lzaW9uID4gXCJ1XCIgPyBudWxsIDogZT8ucHJlY2lzaW9uLFxuICAgICAgLi4uZy5lcnJUb09iaihlPy5tZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGR1cmF0aW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImR1cmF0aW9uXCIsIC4uLmcuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgcmVnZXgoZSwgcikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcInJlZ2V4XCIsXG4gICAgICByZWdleDogZSxcbiAgICAgIC4uLmcuZXJyVG9PYmoocilcbiAgICB9KTtcbiAgfVxuICBpbmNsdWRlcyhlLCByKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiaW5jbHVkZXNcIixcbiAgICAgIHZhbHVlOiBlLFxuICAgICAgcG9zaXRpb246IHI/LnBvc2l0aW9uLFxuICAgICAgLi4uZy5lcnJUb09iaihyPy5tZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIHN0YXJ0c1dpdGgoZSwgcikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcInN0YXJ0c1dpdGhcIixcbiAgICAgIHZhbHVlOiBlLFxuICAgICAgLi4uZy5lcnJUb09iaihyKVxuICAgIH0pO1xuICB9XG4gIGVuZHNXaXRoKGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJlbmRzV2l0aFwiLFxuICAgICAgdmFsdWU6IGUsXG4gICAgICAuLi5nLmVyclRvT2JqKHIpXG4gICAgfSk7XG4gIH1cbiAgbWluKGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiBlLFxuICAgICAgLi4uZy5lcnJUb09iaihyKVxuICAgIH0pO1xuICB9XG4gIG1heChlLCByKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogZSxcbiAgICAgIC4uLmcuZXJyVG9PYmoocilcbiAgICB9KTtcbiAgfVxuICBsZW5ndGgoZSwgcikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcImxlbmd0aFwiLFxuICAgICAgdmFsdWU6IGUsXG4gICAgICAuLi5nLmVyclRvT2JqKHIpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVxdWl2YWxlbnQgdG8gYC5taW4oMSlgXG4gICAqL1xuICBub25lbXB0eShlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIGcuZXJyVG9PYmooZSkpO1xuICB9XG4gIHRyaW0oKSB7XG4gICAgcmV0dXJuIG5ldyBaKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV1cbiAgICB9KTtcbiAgfVxuICB0b0xvd2VyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IFooe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV1cbiAgICB9KTtcbiAgfVxuICB0b1VwcGVyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IFooe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV1cbiAgICB9KTtcbiAgfVxuICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJkYXRldGltZVwiKTtcbiAgfVxuICBnZXQgaXNEYXRlKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImRhdGVcIik7XG4gIH1cbiAgZ2V0IGlzVGltZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJ0aW1lXCIpO1xuICB9XG4gIGdldCBpc0R1cmF0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImR1cmF0aW9uXCIpO1xuICB9XG4gIGdldCBpc0VtYWlsKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImVtYWlsXCIpO1xuICB9XG4gIGdldCBpc1VSTCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJ1cmxcIik7XG4gIH1cbiAgZ2V0IGlzRW1vamkoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwiZW1vamlcIik7XG4gIH1cbiAgZ2V0IGlzVVVJRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJ1dWlkXCIpO1xuICB9XG4gIGdldCBpc05BTk9JRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJuYW5vaWRcIik7XG4gIH1cbiAgZ2V0IGlzQ1VJRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJjdWlkXCIpO1xuICB9XG4gIGdldCBpc0NVSUQyKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImN1aWQyXCIpO1xuICB9XG4gIGdldCBpc1VMSUQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwidWxpZFwiKTtcbiAgfVxuICBnZXQgaXNJUCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJpcFwiKTtcbiAgfVxuICBnZXQgaXNDSURSKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImNpZHJcIik7XG4gIH1cbiAgZ2V0IGlzQmFzZTY0KCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImJhc2U2NFwiKTtcbiAgfVxuICBnZXQgaXNCYXNlNjR1cmwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpO1xuICB9XG4gIGdldCBtaW5MZW5ndGgoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgciBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgci5raW5kID09PSBcIm1pblwiICYmIChlID09PSBudWxsIHx8IHIudmFsdWUgPiBlKSAmJiAoZSA9IHIudmFsdWUpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgciBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgci5raW5kID09PSBcIm1heFwiICYmIChlID09PSBudWxsIHx8IHIudmFsdWUgPCBlKSAmJiAoZSA9IHIudmFsdWUpO1xuICAgIHJldHVybiBlO1xuICB9XG59XG5aLmNyZWF0ZSA9ICh0KSA9PiB7XG4gIHZhciBlO1xuICByZXR1cm4gbmV3IFooe1xuICAgIGNoZWNrczogW10sXG4gICAgdHlwZU5hbWU6IF8uWm9kU3RyaW5nLFxuICAgIGNvZXJjZTogKGUgPSB0Py5jb2VyY2UpICE9PSBudWxsICYmIGUgIT09IHZvaWQgMCA/IGUgOiAhMSxcbiAgICAuLi5iKHQpXG4gIH0pO1xufTtcbmZ1bmN0aW9uIHBpKHQsIGUpIHtcbiAgY29uc3QgciA9ICh0LnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aCwgbiA9IChlLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aCwgcyA9IHIgPiBuID8gciA6IG4sIGEgPSBwYXJzZUludCh0LnRvRml4ZWQocykucmVwbGFjZShcIi5cIiwgXCJcIikpLCBpID0gcGFyc2VJbnQoZS50b0ZpeGVkKHMpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgcmV0dXJuIGEgJSBpIC8gTWF0aC5wb3coMTAsIHMpO1xufVxuY2xhc3MgSyBleHRlbmRzIHcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLm1pbiA9IHRoaXMuZ3RlLCB0aGlzLm1heCA9IHRoaXMubHRlLCB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSAmJiAoZS5kYXRhID0gTnVtYmVyKGUuZGF0YSkpLCB0aGlzLl9nZXRUeXBlKGUpICE9PSBtLm51bWJlcikge1xuICAgICAgY29uc3QgYSA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIHAoYSwge1xuICAgICAgICBjb2RlOiBmLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IG0ubnVtYmVyLFxuICAgICAgICByZWNlaXZlZDogYS5wYXJzZWRUeXBlXG4gICAgICB9KSwgdjtcbiAgICB9XG4gICAgbGV0IG47XG4gICAgY29uc3QgcyA9IG5ldyBOKCk7XG4gICAgZm9yIChjb25zdCBhIG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICBhLmtpbmQgPT09IFwiaW50XCIgPyB4LmlzSW50ZWdlcihlLmRhdGEpIHx8IChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIHAobiwge1xuICAgICAgICBjb2RlOiBmLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICByZWNlaXZlZDogXCJmbG9hdFwiLFxuICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgIH0pLCBzLmRpcnR5KCkpIDogYS5raW5kID09PSBcIm1pblwiID8gKGEuaW5jbHVzaXZlID8gZS5kYXRhIDwgYS52YWx1ZSA6IGUuZGF0YSA8PSBhLnZhbHVlKSAmJiAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBwKG4sIHtcbiAgICAgICAgY29kZTogZi50b29fc21hbGwsXG4gICAgICAgIG1pbmltdW06IGEudmFsdWUsXG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIGluY2x1c2l2ZTogYS5pbmNsdXNpdmUsXG4gICAgICAgIGV4YWN0OiAhMSxcbiAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICB9KSwgcy5kaXJ0eSgpKSA6IGEua2luZCA9PT0gXCJtYXhcIiA/IChhLmluY2x1c2l2ZSA/IGUuZGF0YSA+IGEudmFsdWUgOiBlLmRhdGEgPj0gYS52YWx1ZSkgJiYgKG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBuKSwgcChuLCB7XG4gICAgICAgIGNvZGU6IGYudG9vX2JpZyxcbiAgICAgICAgbWF4aW11bTogYS52YWx1ZSxcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgaW5jbHVzaXZlOiBhLmluY2x1c2l2ZSxcbiAgICAgICAgZXhhY3Q6ICExLFxuICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgIH0pLCBzLmRpcnR5KCkpIDogYS5raW5kID09PSBcIm11bHRpcGxlT2ZcIiA/IHBpKGUuZGF0YSwgYS52YWx1ZSkgIT09IDAgJiYgKG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBuKSwgcChuLCB7XG4gICAgICAgIGNvZGU6IGYubm90X211bHRpcGxlX29mLFxuICAgICAgICBtdWx0aXBsZU9mOiBhLnZhbHVlLFxuICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgIH0pLCBzLmRpcnR5KCkpIDogYS5raW5kID09PSBcImZpbml0ZVwiID8gTnVtYmVyLmlzRmluaXRlKGUuZGF0YSkgfHwgKG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBuKSwgcChuLCB7XG4gICAgICAgIGNvZGU6IGYubm90X2Zpbml0ZSxcbiAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICB9KSwgcy5kaXJ0eSgpKSA6IHguYXNzZXJ0TmV2ZXIoYSk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBzLnZhbHVlLCB2YWx1ZTogZS5kYXRhIH07XG4gIH1cbiAgZ3RlKGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCBlLCAhMCwgZy50b1N0cmluZyhyKSk7XG4gIH1cbiAgZ3QoZSwgcikge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIGUsICExLCBnLnRvU3RyaW5nKHIpKTtcbiAgfVxuICBsdGUoZSwgcikge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIGUsICEwLCBnLnRvU3RyaW5nKHIpKTtcbiAgfVxuICBsdChlLCByKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgZSwgITEsIGcudG9TdHJpbmcocikpO1xuICB9XG4gIHNldExpbWl0KGUsIHIsIG4sIHMpIHtcbiAgICByZXR1cm4gbmV3IEsoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbXG4gICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgIHtcbiAgICAgICAgICBraW5kOiBlLFxuICAgICAgICAgIHZhbHVlOiByLFxuICAgICAgICAgIGluY2x1c2l2ZTogbixcbiAgICAgICAgICBtZXNzYWdlOiBnLnRvU3RyaW5nKHMpXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuICBfYWRkQ2hlY2soZSkge1xuICAgIHJldHVybiBuZXcgSyh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBlXVxuICAgIH0pO1xuICB9XG4gIGludChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICBtZXNzYWdlOiBnLnRvU3RyaW5nKGUpXG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6ICExLFxuICAgICAgbWVzc2FnZTogZy50b1N0cmluZyhlKVxuICAgIH0pO1xuICB9XG4gIG5lZ2F0aXZlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtYXhcIixcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgaW5jbHVzaXZlOiAhMSxcbiAgICAgIG1lc3NhZ2U6IGcudG9TdHJpbmcoZSlcbiAgICB9KTtcbiAgfVxuICBub25wb3NpdGl2ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBtZXNzYWdlOiBnLnRvU3RyaW5nKGUpXG4gICAgfSk7XG4gIH1cbiAgbm9ubmVnYXRpdmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgbWVzc2FnZTogZy50b1N0cmluZyhlKVxuICAgIH0pO1xuICB9XG4gIG11bHRpcGxlT2YoZSwgcikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgIHZhbHVlOiBlLFxuICAgICAgbWVzc2FnZTogZy50b1N0cmluZyhyKVxuICAgIH0pO1xuICB9XG4gIGZpbml0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICBtZXNzYWdlOiBnLnRvU3RyaW5nKGUpXG4gICAgfSk7XG4gIH1cbiAgc2FmZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgdmFsdWU6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICAgICAgbWVzc2FnZTogZy50b1N0cmluZyhlKVxuICAgIH0pLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgIG1lc3NhZ2U6IGcudG9TdHJpbmcoZSlcbiAgICB9KTtcbiAgfVxuICBnZXQgbWluVmFsdWUoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgciBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgci5raW5kID09PSBcIm1pblwiICYmIChlID09PSBudWxsIHx8IHIudmFsdWUgPiBlKSAmJiAoZSA9IHIudmFsdWUpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBtYXhWYWx1ZSgpIHtcbiAgICBsZXQgZSA9IG51bGw7XG4gICAgZm9yIChjb25zdCByIG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICByLmtpbmQgPT09IFwibWF4XCIgJiYgKGUgPT09IG51bGwgfHwgci52YWx1ZSA8IGUpICYmIChlID0gci52YWx1ZSk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0IGlzSW50KCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImludFwiIHx8IGUua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIgJiYgeC5pc0ludGVnZXIoZS52YWx1ZSkpO1xuICB9XG4gIGdldCBpc0Zpbml0ZSgpIHtcbiAgICBsZXQgZSA9IG51bGwsIHIgPSBudWxsO1xuICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAobi5raW5kID09PSBcImZpbml0ZVwiIHx8IG4ua2luZCA9PT0gXCJpbnRcIiB8fCBuLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBuLmtpbmQgPT09IFwibWluXCIgPyAociA9PT0gbnVsbCB8fCBuLnZhbHVlID4gcikgJiYgKHIgPSBuLnZhbHVlKSA6IG4ua2luZCA9PT0gXCJtYXhcIiAmJiAoZSA9PT0gbnVsbCB8fCBuLnZhbHVlIDwgZSkgJiYgKGUgPSBuLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShyKSAmJiBOdW1iZXIuaXNGaW5pdGUoZSk7XG4gIH1cbn1cbksuY3JlYXRlID0gKHQpID0+IG5ldyBLKHtcbiAgY2hlY2tzOiBbXSxcbiAgdHlwZU5hbWU6IF8uWm9kTnVtYmVyLFxuICBjb2VyY2U6IHQ/LmNvZXJjZSB8fCAhMSxcbiAgLi4uYih0KVxufSk7XG5jbGFzcyBlZSBleHRlbmRzIHcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLm1pbiA9IHRoaXMuZ3RlLCB0aGlzLm1heCA9IHRoaXMubHRlO1xuICB9XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpXG4gICAgICB0cnkge1xuICAgICAgICBlLmRhdGEgPSBCaWdJbnQoZS5kYXRhKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW52YWxpZElucHV0KGUpO1xuICAgICAgfVxuICAgIGlmICh0aGlzLl9nZXRUeXBlKGUpICE9PSBtLmJpZ2ludClcbiAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoZSk7XG4gICAgbGV0IG47XG4gICAgY29uc3QgcyA9IG5ldyBOKCk7XG4gICAgZm9yIChjb25zdCBhIG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICBhLmtpbmQgPT09IFwibWluXCIgPyAoYS5pbmNsdXNpdmUgPyBlLmRhdGEgPCBhLnZhbHVlIDogZS5kYXRhIDw9IGEudmFsdWUpICYmIChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIHAobiwge1xuICAgICAgICBjb2RlOiBmLnRvb19zbWFsbCxcbiAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgbWluaW11bTogYS52YWx1ZSxcbiAgICAgICAgaW5jbHVzaXZlOiBhLmluY2x1c2l2ZSxcbiAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICB9KSwgcy5kaXJ0eSgpKSA6IGEua2luZCA9PT0gXCJtYXhcIiA/IChhLmluY2x1c2l2ZSA/IGUuZGF0YSA+IGEudmFsdWUgOiBlLmRhdGEgPj0gYS52YWx1ZSkgJiYgKG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBuKSwgcChuLCB7XG4gICAgICAgIGNvZGU6IGYudG9vX2JpZyxcbiAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgbWF4aW11bTogYS52YWx1ZSxcbiAgICAgICAgaW5jbHVzaXZlOiBhLmluY2x1c2l2ZSxcbiAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlXG4gICAgICB9KSwgcy5kaXJ0eSgpKSA6IGEua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIgPyBlLmRhdGEgJSBhLnZhbHVlICE9PSBCaWdJbnQoMCkgJiYgKG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBuKSwgcChuLCB7XG4gICAgICAgIGNvZGU6IGYubm90X211bHRpcGxlX29mLFxuICAgICAgICBtdWx0aXBsZU9mOiBhLnZhbHVlLFxuICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2VcbiAgICAgIH0pLCBzLmRpcnR5KCkpIDogeC5hc3NlcnROZXZlcihhKTtcbiAgICByZXR1cm4geyBzdGF0dXM6IHMudmFsdWUsIHZhbHVlOiBlLmRhdGEgfTtcbiAgfVxuICBfZ2V0SW52YWxpZElucHV0KGUpIHtcbiAgICBjb25zdCByID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgcmV0dXJuIHAociwge1xuICAgICAgY29kZTogZi5pbnZhbGlkX3R5cGUsXG4gICAgICBleHBlY3RlZDogbS5iaWdpbnQsXG4gICAgICByZWNlaXZlZDogci5wYXJzZWRUeXBlXG4gICAgfSksIHY7XG4gIH1cbiAgZ3RlKGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCBlLCAhMCwgZy50b1N0cmluZyhyKSk7XG4gIH1cbiAgZ3QoZSwgcikge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIGUsICExLCBnLnRvU3RyaW5nKHIpKTtcbiAgfVxuICBsdGUoZSwgcikge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIGUsICEwLCBnLnRvU3RyaW5nKHIpKTtcbiAgfVxuICBsdChlLCByKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgZSwgITEsIGcudG9TdHJpbmcocikpO1xuICB9XG4gIHNldExpbWl0KGUsIHIsIG4sIHMpIHtcbiAgICByZXR1cm4gbmV3IGVlKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogW1xuICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICB7XG4gICAgICAgICAga2luZDogZSxcbiAgICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgICBpbmNsdXNpdmU6IG4sXG4gICAgICAgICAgbWVzc2FnZTogZy50b1N0cmluZyhzKVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbiAgX2FkZENoZWNrKGUpIHtcbiAgICByZXR1cm4gbmV3IGVlKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGVdXG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogITEsXG4gICAgICBtZXNzYWdlOiBnLnRvU3RyaW5nKGUpXG4gICAgfSk7XG4gIH1cbiAgbmVnYXRpdmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogITEsXG4gICAgICBtZXNzYWdlOiBnLnRvU3RyaW5nKGUpXG4gICAgfSk7XG4gIH1cbiAgbm9ucG9zaXRpdmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBtZXNzYWdlOiBnLnRvU3RyaW5nKGUpXG4gICAgfSk7XG4gIH1cbiAgbm9ubmVnYXRpdmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBtZXNzYWdlOiBnLnRvU3RyaW5nKGUpXG4gICAgfSk7XG4gIH1cbiAgbXVsdGlwbGVPZihlLCByKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgdmFsdWU6IGUsXG4gICAgICBtZXNzYWdlOiBnLnRvU3RyaW5nKHIpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pblZhbHVlKCkge1xuICAgIGxldCBlID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIHIua2luZCA9PT0gXCJtaW5cIiAmJiAoZSA9PT0gbnVsbCB8fCByLnZhbHVlID4gZSkgJiYgKGUgPSByLnZhbHVlKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgciBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgci5raW5kID09PSBcIm1heFwiICYmIChlID09PSBudWxsIHx8IHIudmFsdWUgPCBlKSAmJiAoZSA9IHIudmFsdWUpO1xuICAgIHJldHVybiBlO1xuICB9XG59XG5lZS5jcmVhdGUgPSAodCkgPT4ge1xuICB2YXIgZTtcbiAgcmV0dXJuIG5ldyBlZSh7XG4gICAgY2hlY2tzOiBbXSxcbiAgICB0eXBlTmFtZTogXy5ab2RCaWdJbnQsXG4gICAgY29lcmNlOiAoZSA9IHQ/LmNvZXJjZSkgIT09IG51bGwgJiYgZSAhPT0gdm9pZCAwID8gZSA6ICExLFxuICAgIC4uLmIodClcbiAgfSk7XG59O1xuY2xhc3MgSWUgZXh0ZW5kcyB3IHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSAmJiAoZS5kYXRhID0gISFlLmRhdGEpLCB0aGlzLl9nZXRUeXBlKGUpICE9PSBtLmJvb2xlYW4pIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBwKG4sIHtcbiAgICAgICAgY29kZTogZi5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtLmJvb2xlYW4sXG4gICAgICAgIHJlY2VpdmVkOiBuLnBhcnNlZFR5cGVcbiAgICAgIH0pLCB2O1xuICAgIH1cbiAgICByZXR1cm4gSShlLmRhdGEpO1xuICB9XG59XG5JZS5jcmVhdGUgPSAodCkgPT4gbmV3IEllKHtcbiAgdHlwZU5hbWU6IF8uWm9kQm9vbGVhbixcbiAgY29lcmNlOiB0Py5jb2VyY2UgfHwgITEsXG4gIC4uLmIodClcbn0pO1xuY2xhc3MgY2UgZXh0ZW5kcyB3IHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSAmJiAoZS5kYXRhID0gbmV3IERhdGUoZS5kYXRhKSksIHRoaXMuX2dldFR5cGUoZSkgIT09IG0uZGF0ZSkge1xuICAgICAgY29uc3QgYSA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIHAoYSwge1xuICAgICAgICBjb2RlOiBmLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IG0uZGF0ZSxcbiAgICAgICAgcmVjZWl2ZWQ6IGEucGFyc2VkVHlwZVxuICAgICAgfSksIHY7XG4gICAgfVxuICAgIGlmIChpc05hTihlLmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgY29uc3QgYSA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIHAoYSwge1xuICAgICAgICBjb2RlOiBmLmludmFsaWRfZGF0ZVxuICAgICAgfSksIHY7XG4gICAgfVxuICAgIGNvbnN0IG4gPSBuZXcgTigpO1xuICAgIGxldCBzO1xuICAgIGZvciAoY29uc3QgYSBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgYS5raW5kID09PSBcIm1pblwiID8gZS5kYXRhLmdldFRpbWUoKSA8IGEudmFsdWUgJiYgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgcChzLCB7XG4gICAgICAgIGNvZGU6IGYudG9vX3NtYWxsLFxuICAgICAgICBtZXNzYWdlOiBhLm1lc3NhZ2UsXG4gICAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICAgIGV4YWN0OiAhMSxcbiAgICAgICAgbWluaW11bTogYS52YWx1ZSxcbiAgICAgICAgdHlwZTogXCJkYXRlXCJcbiAgICAgIH0pLCBuLmRpcnR5KCkpIDogYS5raW5kID09PSBcIm1heFwiID8gZS5kYXRhLmdldFRpbWUoKSA+IGEudmFsdWUgJiYgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgcChzLCB7XG4gICAgICAgIGNvZGU6IGYudG9vX2JpZyxcbiAgICAgICAgbWVzc2FnZTogYS5tZXNzYWdlLFxuICAgICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgICBleGFjdDogITEsXG4gICAgICAgIG1heGltdW06IGEudmFsdWUsXG4gICAgICAgIHR5cGU6IFwiZGF0ZVwiXG4gICAgICB9KSwgbi5kaXJ0eSgpKSA6IHguYXNzZXJ0TmV2ZXIoYSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogbi52YWx1ZSxcbiAgICAgIHZhbHVlOiBuZXcgRGF0ZShlLmRhdGEuZ2V0VGltZSgpKVxuICAgIH07XG4gIH1cbiAgX2FkZENoZWNrKGUpIHtcbiAgICByZXR1cm4gbmV3IGNlKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGVdXG4gICAgfSk7XG4gIH1cbiAgbWluKGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiBlLmdldFRpbWUoKSxcbiAgICAgIG1lc3NhZ2U6IGcudG9TdHJpbmcocilcbiAgICB9KTtcbiAgfVxuICBtYXgoZSwgcikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IGUuZ2V0VGltZSgpLFxuICAgICAgbWVzc2FnZTogZy50b1N0cmluZyhyKVxuICAgIH0pO1xuICB9XG4gIGdldCBtaW5EYXRlKCkge1xuICAgIGxldCBlID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIHIua2luZCA9PT0gXCJtaW5cIiAmJiAoZSA9PT0gbnVsbCB8fCByLnZhbHVlID4gZSkgJiYgKGUgPSByLnZhbHVlKTtcbiAgICByZXR1cm4gZSAhPSBudWxsID8gbmV3IERhdGUoZSkgOiBudWxsO1xuICB9XG4gIGdldCBtYXhEYXRlKCkge1xuICAgIGxldCBlID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIHIua2luZCA9PT0gXCJtYXhcIiAmJiAoZSA9PT0gbnVsbCB8fCByLnZhbHVlIDwgZSkgJiYgKGUgPSByLnZhbHVlKTtcbiAgICByZXR1cm4gZSAhPSBudWxsID8gbmV3IERhdGUoZSkgOiBudWxsO1xuICB9XG59XG5jZS5jcmVhdGUgPSAodCkgPT4gbmV3IGNlKHtcbiAgY2hlY2tzOiBbXSxcbiAgY29lcmNlOiB0Py5jb2VyY2UgfHwgITEsXG4gIHR5cGVOYW1lOiBfLlpvZERhdGUsXG4gIC4uLmIodClcbn0pO1xuY2xhc3MgS2UgZXh0ZW5kcyB3IHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZ2V0VHlwZShlKSAhPT0gbS5zeW1ib2wpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBwKG4sIHtcbiAgICAgICAgY29kZTogZi5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtLnN5bWJvbCxcbiAgICAgICAgcmVjZWl2ZWQ6IG4ucGFyc2VkVHlwZVxuICAgICAgfSksIHY7XG4gICAgfVxuICAgIHJldHVybiBJKGUuZGF0YSk7XG4gIH1cbn1cbktlLmNyZWF0ZSA9ICh0KSA9PiBuZXcgS2Uoe1xuICB0eXBlTmFtZTogXy5ab2RTeW1ib2wsXG4gIC4uLmIodClcbn0pO1xuY2xhc3MgamUgZXh0ZW5kcyB3IHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZ2V0VHlwZShlKSAhPT0gbS51bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBwKG4sIHtcbiAgICAgICAgY29kZTogZi5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtLnVuZGVmaW5lZCxcbiAgICAgICAgcmVjZWl2ZWQ6IG4ucGFyc2VkVHlwZVxuICAgICAgfSksIHY7XG4gICAgfVxuICAgIHJldHVybiBJKGUuZGF0YSk7XG4gIH1cbn1cbmplLmNyZWF0ZSA9ICh0KSA9PiBuZXcgamUoe1xuICB0eXBlTmFtZTogXy5ab2RVbmRlZmluZWQsXG4gIC4uLmIodClcbn0pO1xuY2xhc3MgTGUgZXh0ZW5kcyB3IHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZ2V0VHlwZShlKSAhPT0gbS5udWxsKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gcChuLCB7XG4gICAgICAgIGNvZGU6IGYuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbS5udWxsLFxuICAgICAgICByZWNlaXZlZDogbi5wYXJzZWRUeXBlXG4gICAgICB9KSwgdjtcbiAgICB9XG4gICAgcmV0dXJuIEkoZS5kYXRhKTtcbiAgfVxufVxuTGUuY3JlYXRlID0gKHQpID0+IG5ldyBMZSh7XG4gIHR5cGVOYW1lOiBfLlpvZE51bGwsXG4gIC4uLmIodClcbn0pO1xuY2xhc3MgX2UgZXh0ZW5kcyB3IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5fYW55ID0gITA7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICByZXR1cm4gSShlLmRhdGEpO1xuICB9XG59XG5fZS5jcmVhdGUgPSAodCkgPT4gbmV3IF9lKHtcbiAgdHlwZU5hbWU6IF8uWm9kQW55LFxuICAuLi5iKHQpXG59KTtcbmNsYXNzIGllIGV4dGVuZHMgdyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuX3Vua25vd24gPSAhMDtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIHJldHVybiBJKGUuZGF0YSk7XG4gIH1cbn1cbmllLmNyZWF0ZSA9ICh0KSA9PiBuZXcgaWUoe1xuICB0eXBlTmFtZTogXy5ab2RVbmtub3duLFxuICAuLi5iKHQpXG59KTtcbmNsYXNzIFggZXh0ZW5kcyB3IHtcbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCByID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgcmV0dXJuIHAociwge1xuICAgICAgY29kZTogZi5pbnZhbGlkX3R5cGUsXG4gICAgICBleHBlY3RlZDogbS5uZXZlcixcbiAgICAgIHJlY2VpdmVkOiByLnBhcnNlZFR5cGVcbiAgICB9KSwgdjtcbiAgfVxufVxuWC5jcmVhdGUgPSAodCkgPT4gbmV3IFgoe1xuICB0eXBlTmFtZTogXy5ab2ROZXZlcixcbiAgLi4uYih0KVxufSk7XG5jbGFzcyBldCBleHRlbmRzIHcge1xuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9nZXRUeXBlKGUpICE9PSBtLnVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIHAobiwge1xuICAgICAgICBjb2RlOiBmLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IG0udm9pZCxcbiAgICAgICAgcmVjZWl2ZWQ6IG4ucGFyc2VkVHlwZVxuICAgICAgfSksIHY7XG4gICAgfVxuICAgIHJldHVybiBJKGUuZGF0YSk7XG4gIH1cbn1cbmV0LmNyZWF0ZSA9ICh0KSA9PiBuZXcgZXQoe1xuICB0eXBlTmFtZTogXy5ab2RWb2lkLFxuICAuLi5iKHQpXG59KTtcbmNsYXNzIFUgZXh0ZW5kcyB3IHtcbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IGN0eDogciwgc3RhdHVzOiBuIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSksIHMgPSB0aGlzLl9kZWY7XG4gICAgaWYgKHIucGFyc2VkVHlwZSAhPT0gbS5hcnJheSlcbiAgICAgIHJldHVybiBwKHIsIHtcbiAgICAgICAgY29kZTogZi5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtLmFycmF5LFxuICAgICAgICByZWNlaXZlZDogci5wYXJzZWRUeXBlXG4gICAgICB9KSwgdjtcbiAgICBpZiAocy5leGFjdExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgaSA9IHIuZGF0YS5sZW5ndGggPiBzLmV4YWN0TGVuZ3RoLnZhbHVlLCBvID0gci5kYXRhLmxlbmd0aCA8IHMuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICAoaSB8fCBvKSAmJiAocChyLCB7XG4gICAgICAgIGNvZGU6IGkgPyBmLnRvb19iaWcgOiBmLnRvb19zbWFsbCxcbiAgICAgICAgbWluaW11bTogbyA/IHMuZXhhY3RMZW5ndGgudmFsdWUgOiB2b2lkIDAsXG4gICAgICAgIG1heGltdW06IGkgPyBzLmV4YWN0TGVuZ3RoLnZhbHVlIDogdm9pZCAwLFxuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICAgIGV4YWN0OiAhMCxcbiAgICAgICAgbWVzc2FnZTogcy5leGFjdExlbmd0aC5tZXNzYWdlXG4gICAgICB9KSwgbi5kaXJ0eSgpKTtcbiAgICB9XG4gICAgaWYgKHMubWluTGVuZ3RoICE9PSBudWxsICYmIHIuZGF0YS5sZW5ndGggPCBzLm1pbkxlbmd0aC52YWx1ZSAmJiAocChyLCB7XG4gICAgICBjb2RlOiBmLnRvb19zbWFsbCxcbiAgICAgIG1pbmltdW06IHMubWluTGVuZ3RoLnZhbHVlLFxuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgIGV4YWN0OiAhMSxcbiAgICAgIG1lc3NhZ2U6IHMubWluTGVuZ3RoLm1lc3NhZ2VcbiAgICB9KSwgbi5kaXJ0eSgpKSwgcy5tYXhMZW5ndGggIT09IG51bGwgJiYgci5kYXRhLmxlbmd0aCA+IHMubWF4TGVuZ3RoLnZhbHVlICYmIChwKHIsIHtcbiAgICAgIGNvZGU6IGYudG9vX2JpZyxcbiAgICAgIG1heGltdW06IHMubWF4TGVuZ3RoLnZhbHVlLFxuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgIGV4YWN0OiAhMSxcbiAgICAgIG1lc3NhZ2U6IHMubWF4TGVuZ3RoLm1lc3NhZ2VcbiAgICB9KSwgbi5kaXJ0eSgpKSwgci5jb21tb24uYXN5bmMpXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoWy4uLnIuZGF0YV0ubWFwKChpLCBvKSA9PiBzLnR5cGUuX3BhcnNlQXN5bmMobmV3IEIociwgaSwgci5wYXRoLCBvKSkpKS50aGVuKChpKSA9PiBOLm1lcmdlQXJyYXkobiwgaSkpO1xuICAgIGNvbnN0IGEgPSBbLi4uci5kYXRhXS5tYXAoKGksIG8pID0+IHMudHlwZS5fcGFyc2VTeW5jKG5ldyBCKHIsIGksIHIucGF0aCwgbykpKTtcbiAgICByZXR1cm4gTi5tZXJnZUFycmF5KG4sIGEpO1xuICB9XG4gIGdldCBlbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgfVxuICBtaW4oZSwgcikge1xuICAgIHJldHVybiBuZXcgVSh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IGUsIG1lc3NhZ2U6IGcudG9TdHJpbmcocikgfVxuICAgIH0pO1xuICB9XG4gIG1heChlLCByKSB7XG4gICAgcmV0dXJuIG5ldyBVKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1heExlbmd0aDogeyB2YWx1ZTogZSwgbWVzc2FnZTogZy50b1N0cmluZyhyKSB9XG4gICAgfSk7XG4gIH1cbiAgbGVuZ3RoKGUsIHIpIHtcbiAgICByZXR1cm4gbmV3IFUoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGUsIG1lc3NhZ2U6IGcudG9TdHJpbmcocikgfVxuICAgIH0pO1xuICB9XG4gIG5vbmVtcHR5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5taW4oMSwgZSk7XG4gIH1cbn1cblUuY3JlYXRlID0gKHQsIGUpID0+IG5ldyBVKHtcbiAgdHlwZTogdCxcbiAgbWluTGVuZ3RoOiBudWxsLFxuICBtYXhMZW5ndGg6IG51bGwsXG4gIGV4YWN0TGVuZ3RoOiBudWxsLFxuICB0eXBlTmFtZTogXy5ab2RBcnJheSxcbiAgLi4uYihlKVxufSk7XG5mdW5jdGlvbiBwZSh0KSB7XG4gIGlmICh0IGluc3RhbmNlb2YgQykge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHIgaW4gdC5zaGFwZSkge1xuICAgICAgY29uc3QgbiA9IHQuc2hhcGVbcl07XG4gICAgICBlW3JdID0gei5jcmVhdGUocGUobikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEMoe1xuICAgICAgLi4udC5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IGVcbiAgICB9KTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBVID8gbmV3IFUoe1xuICAgICAgLi4udC5fZGVmLFxuICAgICAgdHlwZTogcGUodC5lbGVtZW50KVxuICAgIH0pIDogdCBpbnN0YW5jZW9mIHogPyB6LmNyZWF0ZShwZSh0LnVud3JhcCgpKSkgOiB0IGluc3RhbmNlb2YgcmUgPyByZS5jcmVhdGUocGUodC51bndyYXAoKSkpIDogdCBpbnN0YW5jZW9mIFYgPyBWLmNyZWF0ZSh0Lml0ZW1zLm1hcCgoZSkgPT4gcGUoZSkpKSA6IHQ7XG59XG5jbGFzcyBDIGV4dGVuZHMgdyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuX2NhY2hlZCA9IG51bGwsIHRoaXMubm9uc3RyaWN0ID0gdGhpcy5wYXNzdGhyb3VnaCwgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XG4gIH1cbiAgX2dldENhY2hlZCgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkICE9PSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcbiAgICBjb25zdCBlID0gdGhpcy5fZGVmLnNoYXBlKCksIHIgPSB4Lm9iamVjdEtleXMoZSk7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZCA9IHsgc2hhcGU6IGUsIGtleXM6IHIgfTtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9nZXRUeXBlKGUpICE9PSBtLm9iamVjdCkge1xuICAgICAgY29uc3QgdSA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIHAodSwge1xuICAgICAgICBjb2RlOiBmLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IG0ub2JqZWN0LFxuICAgICAgICByZWNlaXZlZDogdS5wYXJzZWRUeXBlXG4gICAgICB9KSwgdjtcbiAgICB9XG4gICAgY29uc3QgeyBzdGF0dXM6IG4sIGN0eDogcyB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpLCB7IHNoYXBlOiBhLCBrZXlzOiBpIH0gPSB0aGlzLl9nZXRDYWNoZWQoKSwgbyA9IFtdO1xuICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFggJiYgdGhpcy5fZGVmLnVua25vd25LZXlzID09PSBcInN0cmlwXCIpKVxuICAgICAgZm9yIChjb25zdCB1IGluIHMuZGF0YSlcbiAgICAgICAgaS5pbmNsdWRlcyh1KSB8fCBvLnB1c2godSk7XG4gICAgY29uc3QgYyA9IFtdO1xuICAgIGZvciAoY29uc3QgdSBvZiBpKSB7XG4gICAgICBjb25zdCBkID0gYVt1XSwgaCA9IHMuZGF0YVt1XTtcbiAgICAgIGMucHVzaCh7XG4gICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IHUgfSxcbiAgICAgICAgdmFsdWU6IGQuX3BhcnNlKG5ldyBCKHMsIGgsIHMucGF0aCwgdSkpLFxuICAgICAgICBhbHdheXNTZXQ6IHUgaW4gcy5kYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFgpIHtcbiAgICAgIGNvbnN0IHUgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICBpZiAodSA9PT0gXCJwYXNzdGhyb3VnaFwiKVxuICAgICAgICBmb3IgKGNvbnN0IGQgb2YgbylcbiAgICAgICAgICBjLnB1c2goe1xuICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogZCB9LFxuICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBzLmRhdGFbZF0gfVxuICAgICAgICAgIH0pO1xuICAgICAgZWxzZSBpZiAodSA9PT0gXCJzdHJpY3RcIilcbiAgICAgICAgby5sZW5ndGggPiAwICYmIChwKHMsIHtcbiAgICAgICAgICBjb2RlOiBmLnVucmVjb2duaXplZF9rZXlzLFxuICAgICAgICAgIGtleXM6IG9cbiAgICAgICAgfSksIG4uZGlydHkoKSk7XG4gICAgICBlbHNlIGlmICh1ICE9PSBcInN0cmlwXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHUgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICBmb3IgKGNvbnN0IGQgb2Ygbykge1xuICAgICAgICBjb25zdCBoID0gcy5kYXRhW2RdO1xuICAgICAgICBjLnB1c2goe1xuICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGQgfSxcbiAgICAgICAgICB2YWx1ZTogdS5fcGFyc2UoXG4gICAgICAgICAgICBuZXcgQihzLCBoLCBzLnBhdGgsIGQpXG4gICAgICAgICAgICAvLywgY3R4LmNoaWxkKGtleSksIHZhbHVlLCBnZXRQYXJzZWRUeXBlKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgYWx3YXlzU2V0OiBkIGluIHMuZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHMuY29tbW9uLmFzeW5jID8gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1ID0gW107XG4gICAgICBmb3IgKGNvbnN0IGQgb2YgYykge1xuICAgICAgICBjb25zdCBoID0gYXdhaXQgZC5rZXksIHkgPSBhd2FpdCBkLnZhbHVlO1xuICAgICAgICB1LnB1c2goe1xuICAgICAgICAgIGtleTogaCxcbiAgICAgICAgICB2YWx1ZTogeSxcbiAgICAgICAgICBhbHdheXNTZXQ6IGQuYWx3YXlzU2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHU7XG4gICAgfSkudGhlbigodSkgPT4gTi5tZXJnZU9iamVjdFN5bmMobiwgdSkpIDogTi5tZXJnZU9iamVjdFN5bmMobiwgYyk7XG4gIH1cbiAgZ2V0IHNoYXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgfVxuICBzdHJpY3QoZSkge1xuICAgIHJldHVybiBnLmVyclRvT2JqLCBuZXcgQyh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgIC4uLmUgIT09IHZvaWQgMCA/IHtcbiAgICAgICAgZXJyb3JNYXA6IChyLCBuKSA9PiB7XG4gICAgICAgICAgdmFyIHMsIGEsIGksIG87XG4gICAgICAgICAgY29uc3QgYyA9IChpID0gKGEgPSAocyA9IHRoaXMuX2RlZikuZXJyb3JNYXApID09PSBudWxsIHx8IGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGEuY2FsbChzLCByLCBuKS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBpICE9PSB2b2lkIDAgPyBpIDogbi5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgcmV0dXJuIHIuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiID8ge1xuICAgICAgICAgICAgbWVzc2FnZTogKG8gPSBnLmVyclRvT2JqKGUpLm1lc3NhZ2UpICE9PSBudWxsICYmIG8gIT09IHZvaWQgMCA/IG8gOiBjXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IDoge31cbiAgICB9KTtcbiAgfVxuICBzdHJpcCgpIHtcbiAgICByZXR1cm4gbmV3IEMoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIlxuICAgIH0pO1xuICB9XG4gIHBhc3N0aHJvdWdoKCkge1xuICAgIHJldHVybiBuZXcgQyh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiXG4gICAgfSk7XG4gIH1cbiAgLy8gY29uc3QgQXVnbWVudEZhY3RvcnkgPVxuICAvLyAgIDxEZWYgZXh0ZW5kcyBab2RPYmplY3REZWY+KGRlZjogRGVmKSA9PlxuICAvLyAgIDxBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZT4oXG4gIC8vICAgICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAvLyAgICk6IFpvZE9iamVjdDxcbiAgLy8gICAgIGV4dGVuZFNoYXBlPFJldHVyblR5cGU8RGVmW1wic2hhcGVcIl0+LCBBdWdtZW50YXRpb24+LFxuICAvLyAgICAgRGVmW1widW5rbm93bktleXNcIl0sXG4gIC8vICAgICBEZWZbXCJjYXRjaGFsbFwiXVxuICAvLyAgID4gPT4ge1xuICAvLyAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAvLyAgICAgICAuLi5kZWYsXG4gIC8vICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAvLyAgICAgICAgIC4uLmRlZi5zaGFwZSgpLFxuICAvLyAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgLy8gICAgICAgfSksXG4gIC8vICAgICB9KSBhcyBhbnk7XG4gIC8vICAgfTtcbiAgZXh0ZW5kKGUpIHtcbiAgICByZXR1cm4gbmV3IEMoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAuLi5lXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcmlvciB0byB6b2RAMS4wLjEyIHRoZXJlIHdhcyBhIGJ1ZyBpbiB0aGVcbiAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAqIHVwZ3JhZGUgaWYgeW91IGFyZSBleHBlcmllbmNpbmcgaXNzdWVzLlxuICAgKi9cbiAgbWVyZ2UoZSkge1xuICAgIHJldHVybiBuZXcgQyh7XG4gICAgICB1bmtub3duS2V5czogZS5fZGVmLnVua25vd25LZXlzLFxuICAgICAgY2F0Y2hhbGw6IGUuX2RlZi5jYXRjaGFsbCxcbiAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgLi4uZS5fZGVmLnNoYXBlKClcbiAgICAgIH0pLFxuICAgICAgdHlwZU5hbWU6IF8uWm9kT2JqZWN0XG4gICAgfSk7XG4gIH1cbiAgLy8gbWVyZ2U8XG4gIC8vICAgSW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3QsXG4gIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgSW5jb21pbmdbXCJzaGFwZVwiXSxcbiAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB7XG4gIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgLy8gICAgICAgPyBPdXRwdXRba11cbiAgLy8gICAgICAgOiBuZXZlcjtcbiAgLy8gICB9LFxuICAvLyAgIE5ld0lucHV0IGV4dGVuZHMge1xuICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gIC8vICAgICAgID8gSW5wdXRba11cbiAgLy8gICAgICAgOiBuZXZlcjtcbiAgLy8gICB9XG4gIC8vID4oXG4gIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgLy8gKTogWm9kT2JqZWN0PFxuICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXSxcbiAgLy8gICBOZXdPdXRwdXQsXG4gIC8vICAgTmV3SW5wdXRcbiAgLy8gPiB7XG4gIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAvLyAgICAgc2hhcGU6ICgpID0+XG4gIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAvLyAgIH0pIGFzIGFueTtcbiAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAvLyB9XG4gIHNldEtleShlLCByKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtlXTogciB9KTtcbiAgfVxuICAvLyBtZXJnZTxJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdD4oXG4gIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgLy8gKTogLy9ab2RPYmplY3Q8VCAmIEluY29taW5nW1wiX3NoYXBlXCJdLCBVbmtub3duS2V5cywgQ2F0Y2hhbGw+ID0gKG1lcmdpbmcpID0+IHtcbiAgLy8gWm9kT2JqZWN0PFxuICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXVxuICAvLyA+IHtcbiAgLy8gICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXG4gIC8vICAgLy8gICB0aGlzLl9kZWYuc2hhcGUoKSxcbiAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gIC8vICAgLy8gKTtcbiAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gIC8vICAgICBzaGFwZTogKCkgPT5cbiAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gIC8vICAgfSkgYXMgYW55O1xuICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gIC8vIH1cbiAgY2F0Y2hhbGwoZSkge1xuICAgIHJldHVybiBuZXcgQyh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjYXRjaGFsbDogZVxuICAgIH0pO1xuICB9XG4gIHBpY2soZSkge1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICByZXR1cm4geC5vYmplY3RLZXlzKGUpLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGVbbl0gJiYgdGhpcy5zaGFwZVtuXSAmJiAocltuXSA9IHRoaXMuc2hhcGVbbl0pO1xuICAgIH0pLCBuZXcgQyh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gclxuICAgIH0pO1xuICB9XG4gIG9taXQoZSkge1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICByZXR1cm4geC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGVbbl0gfHwgKHJbbl0gPSB0aGlzLnNoYXBlW25dKTtcbiAgICB9KSwgbmV3IEMoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IHJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGRlZXBQYXJ0aWFsKCkge1xuICAgIHJldHVybiBwZSh0aGlzKTtcbiAgfVxuICBwYXJ0aWFsKGUpIHtcbiAgICBjb25zdCByID0ge307XG4gICAgcmV0dXJuIHgub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBjb25zdCBzID0gdGhpcy5zaGFwZVtuXTtcbiAgICAgIGUgJiYgIWVbbl0gPyByW25dID0gcyA6IHJbbl0gPSBzLm9wdGlvbmFsKCk7XG4gICAgfSksIG5ldyBDKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHNoYXBlOiAoKSA9PiByXG4gICAgfSk7XG4gIH1cbiAgcmVxdWlyZWQoZSkge1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICByZXR1cm4geC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGlmIChlICYmICFlW25dKVxuICAgICAgICByW25dID0gdGhpcy5zaGFwZVtuXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgYSA9IHRoaXMuc2hhcGVbbl07XG4gICAgICAgIGZvciAoOyBhIGluc3RhbmNlb2YgejsgKVxuICAgICAgICAgIGEgPSBhLl9kZWYuaW5uZXJUeXBlO1xuICAgICAgICByW25dID0gYTtcbiAgICAgIH1cbiAgICB9KSwgbmV3IEMoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IHJcbiAgICB9KTtcbiAgfVxuICBrZXlvZigpIHtcbiAgICByZXR1cm4gbW4oeC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKTtcbiAgfVxufVxuQy5jcmVhdGUgPSAodCwgZSkgPT4gbmV3IEMoe1xuICBzaGFwZTogKCkgPT4gdCxcbiAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgY2F0Y2hhbGw6IFguY3JlYXRlKCksXG4gIHR5cGVOYW1lOiBfLlpvZE9iamVjdCxcbiAgLi4uYihlKVxufSk7XG5DLnN0cmljdENyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgQyh7XG4gIHNoYXBlOiAoKSA9PiB0LFxuICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgY2F0Y2hhbGw6IFguY3JlYXRlKCksXG4gIHR5cGVOYW1lOiBfLlpvZE9iamVjdCxcbiAgLi4uYihlKVxufSk7XG5DLmxhenljcmVhdGUgPSAodCwgZSkgPT4gbmV3IEMoe1xuICBzaGFwZTogdCxcbiAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgY2F0Y2hhbGw6IFguY3JlYXRlKCksXG4gIHR5cGVOYW1lOiBfLlpvZE9iamVjdCxcbiAgLi4uYihlKVxufSk7XG5jbGFzcyAkZSBleHRlbmRzIHcge1xuICBfcGFyc2UoZSkge1xuICAgIGNvbnN0IHsgY3R4OiByIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSksIG4gPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICBmdW5jdGlvbiBzKGEpIHtcbiAgICAgIGZvciAoY29uc3QgbyBvZiBhKVxuICAgICAgICBpZiAoby5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgcmV0dXJuIG8ucmVzdWx0O1xuICAgICAgZm9yIChjb25zdCBvIG9mIGEpXG4gICAgICAgIGlmIChvLnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICByZXR1cm4gci5jb21tb24uaXNzdWVzLnB1c2goLi4uby5jdHguY29tbW9uLmlzc3VlcyksIG8ucmVzdWx0O1xuICAgICAgY29uc3QgaSA9IGEubWFwKChvKSA9PiBuZXcgTChvLmN0eC5jb21tb24uaXNzdWVzKSk7XG4gICAgICByZXR1cm4gcChyLCB7XG4gICAgICAgIGNvZGU6IGYuaW52YWxpZF91bmlvbixcbiAgICAgICAgdW5pb25FcnJvcnM6IGlcbiAgICAgIH0pLCB2O1xuICAgIH1cbiAgICBpZiAoci5jb21tb24uYXN5bmMpXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwobi5tYXAoYXN5bmMgKGEpID0+IHtcbiAgICAgICAgY29uc3QgaSA9IHtcbiAgICAgICAgICAuLi5yLFxuICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgLi4uci5jb21tb24sXG4gICAgICAgICAgICBpc3N1ZXM6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXJlbnQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IGF3YWl0IGEuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgZGF0YTogci5kYXRhLFxuICAgICAgICAgICAgcGF0aDogci5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgY3R4OiBpXG4gICAgICAgIH07XG4gICAgICB9KSkudGhlbihzKTtcbiAgICB7XG4gICAgICBsZXQgYTtcbiAgICAgIGNvbnN0IGkgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgYyBvZiBuKSB7XG4gICAgICAgIGNvbnN0IHUgPSB7XG4gICAgICAgICAgLi4ucixcbiAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgIC4uLnIuY29tbW9uLFxuICAgICAgICAgICAgaXNzdWVzOiBbXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFyZW50OiBudWxsXG4gICAgICAgIH0sIGQgPSBjLl9wYXJzZVN5bmMoe1xuICAgICAgICAgIGRhdGE6IHIuZGF0YSxcbiAgICAgICAgICBwYXRoOiByLnBhdGgsXG4gICAgICAgICAgcGFyZW50OiB1XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZC5zdGF0dXMgPT09IFwidmFsaWRcIilcbiAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgZC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiAhYSAmJiAoYSA9IHsgcmVzdWx0OiBkLCBjdHg6IHUgfSksIHUuY29tbW9uLmlzc3Vlcy5sZW5ndGggJiYgaS5wdXNoKHUuY29tbW9uLmlzc3Vlcyk7XG4gICAgICB9XG4gICAgICBpZiAoYSlcbiAgICAgICAgcmV0dXJuIHIuY29tbW9uLmlzc3Vlcy5wdXNoKC4uLmEuY3R4LmNvbW1vbi5pc3N1ZXMpLCBhLnJlc3VsdDtcbiAgICAgIGNvbnN0IG8gPSBpLm1hcCgoYykgPT4gbmV3IEwoYykpO1xuICAgICAgcmV0dXJuIHAociwge1xuICAgICAgICBjb2RlOiBmLmludmFsaWRfdW5pb24sXG4gICAgICAgIHVuaW9uRXJyb3JzOiBvXG4gICAgICB9KSwgdjtcbiAgICB9XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICB9XG59XG4kZS5jcmVhdGUgPSAodCwgZSkgPT4gbmV3ICRlKHtcbiAgb3B0aW9uczogdCxcbiAgdHlwZU5hbWU6IF8uWm9kVW5pb24sXG4gIC4uLmIoZSlcbn0pO1xuY29uc3QgSiA9ICh0KSA9PiB0IGluc3RhbmNlb2YgWmUgPyBKKHQuc2NoZW1hKSA6IHQgaW5zdGFuY2VvZiBXID8gSih0LmlubmVyVHlwZSgpKSA6IHQgaW5zdGFuY2VvZiBVZSA/IFt0LnZhbHVlXSA6IHQgaW5zdGFuY2VvZiB0ZSA/IHQub3B0aW9ucyA6IHQgaW5zdGFuY2VvZiBXZSA/IHgub2JqZWN0VmFsdWVzKHQuZW51bSkgOiB0IGluc3RhbmNlb2YgcWUgPyBKKHQuX2RlZi5pbm5lclR5cGUpIDogdCBpbnN0YW5jZW9mIGplID8gW3ZvaWQgMF0gOiB0IGluc3RhbmNlb2YgTGUgPyBbbnVsbF0gOiB0IGluc3RhbmNlb2YgeiA/IFt2b2lkIDAsIC4uLkoodC51bndyYXAoKSldIDogdCBpbnN0YW5jZW9mIHJlID8gW251bGwsIC4uLkoodC51bndyYXAoKSldIDogdCBpbnN0YW5jZW9mIFl0IHx8IHQgaW5zdGFuY2VvZiBCZSA/IEoodC51bndyYXAoKSkgOiB0IGluc3RhbmNlb2YgemUgPyBKKHQuX2RlZi5pbm5lclR5cGUpIDogW107XG5jbGFzcyBmdCBleHRlbmRzIHcge1xuICBfcGFyc2UoZSkge1xuICAgIGNvbnN0IHsgY3R4OiByIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSk7XG4gICAgaWYgKHIucGFyc2VkVHlwZSAhPT0gbS5vYmplY3QpXG4gICAgICByZXR1cm4gcChyLCB7XG4gICAgICAgIGNvZGU6IGYuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbS5vYmplY3QsXG4gICAgICAgIHJlY2VpdmVkOiByLnBhcnNlZFR5cGVcbiAgICAgIH0pLCB2O1xuICAgIGNvbnN0IG4gPSB0aGlzLmRpc2NyaW1pbmF0b3IsIHMgPSByLmRhdGFbbl0sIGEgPSB0aGlzLm9wdGlvbnNNYXAuZ2V0KHMpO1xuICAgIHJldHVybiBhID8gci5jb21tb24uYXN5bmMgPyBhLl9wYXJzZUFzeW5jKHtcbiAgICAgIGRhdGE6IHIuZGF0YSxcbiAgICAgIHBhdGg6IHIucGF0aCxcbiAgICAgIHBhcmVudDogclxuICAgIH0pIDogYS5fcGFyc2VTeW5jKHtcbiAgICAgIGRhdGE6IHIuZGF0YSxcbiAgICAgIHBhdGg6IHIucGF0aCxcbiAgICAgIHBhcmVudDogclxuICAgIH0pIDogKHAociwge1xuICAgICAgY29kZTogZi5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxuICAgICAgcGF0aDogW25dXG4gICAgfSksIHYpO1xuICB9XG4gIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gIH1cbiAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zTWFwO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRpc2NyaW1pbmF0ZWQgdW5pb24gc2NoZW1hLiBJdHMgYmVoYXZpb3VyIGlzIHZlcnkgc2ltaWxhciB0byB0aGF0IG9mIHRoZSBub3JtYWwgei51bmlvbigpIGNvbnN0cnVjdG9yLlxuICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICogQHBhcmFtIGRpc2NyaW1pbmF0b3IgdGhlIG5hbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHlcbiAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoZSwgciwgbikge1xuICAgIGNvbnN0IHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgYSBvZiByKSB7XG4gICAgICBjb25zdCBpID0gSihhLnNoYXBlW2VdKTtcbiAgICAgIGlmICghaS5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBkaXNjcmltaW5hdG9yIHZhbHVlIGZvciBrZXkgXFxgJHtlfVxcYCBjb3VsZCBub3QgYmUgZXh0cmFjdGVkIGZyb20gYWxsIHNjaGVtYSBvcHRpb25zYCk7XG4gICAgICBmb3IgKGNvbnN0IG8gb2YgaSkge1xuICAgICAgICBpZiAocy5oYXMobykpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXNjcmltaW5hdG9yIHByb3BlcnR5ICR7U3RyaW5nKGUpfSBoYXMgZHVwbGljYXRlIHZhbHVlICR7U3RyaW5nKG8pfWApO1xuICAgICAgICBzLnNldChvLCBhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBmdCh7XG4gICAgICB0eXBlTmFtZTogXy5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICBkaXNjcmltaW5hdG9yOiBlLFxuICAgICAgb3B0aW9uczogcixcbiAgICAgIG9wdGlvbnNNYXA6IHMsXG4gICAgICAuLi5iKG4pXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEl0KHQsIGUpIHtcbiAgY29uc3QgciA9IFkodCksIG4gPSBZKGUpO1xuICBpZiAodCA9PT0gZSlcbiAgICByZXR1cm4geyB2YWxpZDogITAsIGRhdGE6IHQgfTtcbiAgaWYgKHIgPT09IG0ub2JqZWN0ICYmIG4gPT09IG0ub2JqZWN0KSB7XG4gICAgY29uc3QgcyA9IHgub2JqZWN0S2V5cyhlKSwgYSA9IHgub2JqZWN0S2V5cyh0KS5maWx0ZXIoKG8pID0+IHMuaW5kZXhPZihvKSAhPT0gLTEpLCBpID0geyAuLi50LCAuLi5lIH07XG4gICAgZm9yIChjb25zdCBvIG9mIGEpIHtcbiAgICAgIGNvbnN0IGMgPSBJdCh0W29dLCBlW29dKTtcbiAgICAgIGlmICghYy52YWxpZClcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6ICExIH07XG4gICAgICBpW29dID0gYy5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogITAsIGRhdGE6IGkgfTtcbiAgfSBlbHNlIGlmIChyID09PSBtLmFycmF5ICYmIG4gPT09IG0uYXJyYXkpIHtcbiAgICBpZiAodC5sZW5ndGggIT09IGUubGVuZ3RoKVxuICAgICAgcmV0dXJuIHsgdmFsaWQ6ICExIH07XG4gICAgY29uc3QgcyA9IFtdO1xuICAgIGZvciAobGV0IGEgPSAwOyBhIDwgdC5sZW5ndGg7IGErKykge1xuICAgICAgY29uc3QgaSA9IHRbYV0sIG8gPSBlW2FdLCBjID0gSXQoaSwgbyk7XG4gICAgICBpZiAoIWMudmFsaWQpXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiAhMSB9O1xuICAgICAgcy5wdXNoKGMuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB7IHZhbGlkOiAhMCwgZGF0YTogcyB9O1xuICB9IGVsc2VcbiAgICByZXR1cm4gciA9PT0gbS5kYXRlICYmIG4gPT09IG0uZGF0ZSAmJiArdCA9PSArZSA/IHsgdmFsaWQ6ICEwLCBkYXRhOiB0IH0gOiB7IHZhbGlkOiAhMSB9O1xufVxuY2xhc3MgTWUgZXh0ZW5kcyB3IHtcbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IHN0YXR1czogciwgY3R4OiBuIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSksIHMgPSAoYSwgaSkgPT4ge1xuICAgICAgaWYgKEF0KGEpIHx8IEF0KGkpKVxuICAgICAgICByZXR1cm4gdjtcbiAgICAgIGNvbnN0IG8gPSBJdChhLnZhbHVlLCBpLnZhbHVlKTtcbiAgICAgIHJldHVybiBvLnZhbGlkID8gKChOdChhKSB8fCBOdChpKSkgJiYgci5kaXJ0eSgpLCB7IHN0YXR1czogci52YWx1ZSwgdmFsdWU6IG8uZGF0YSB9KSA6IChwKG4sIHtcbiAgICAgICAgY29kZTogZi5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlc1xuICAgICAgfSksIHYpO1xuICAgIH07XG4gICAgcmV0dXJuIG4uY29tbW9uLmFzeW5jID8gUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICBkYXRhOiBuLmRhdGEsXG4gICAgICAgIHBhdGg6IG4ucGF0aCxcbiAgICAgICAgcGFyZW50OiBuXG4gICAgICB9KSxcbiAgICAgIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VBc3luYyh7XG4gICAgICAgIGRhdGE6IG4uZGF0YSxcbiAgICAgICAgcGF0aDogbi5wYXRoLFxuICAgICAgICBwYXJlbnQ6IG5cbiAgICAgIH0pXG4gICAgXSkudGhlbigoW2EsIGldKSA9PiBzKGEsIGkpKSA6IHModGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICBkYXRhOiBuLmRhdGEsXG4gICAgICBwYXRoOiBuLnBhdGgsXG4gICAgICBwYXJlbnQ6IG5cbiAgICB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZVN5bmMoe1xuICAgICAgZGF0YTogbi5kYXRhLFxuICAgICAgcGF0aDogbi5wYXRoLFxuICAgICAgcGFyZW50OiBuXG4gICAgfSkpO1xuICB9XG59XG5NZS5jcmVhdGUgPSAodCwgZSwgcikgPT4gbmV3IE1lKHtcbiAgbGVmdDogdCxcbiAgcmlnaHQ6IGUsXG4gIHR5cGVOYW1lOiBfLlpvZEludGVyc2VjdGlvbixcbiAgLi4uYihyKVxufSk7XG5jbGFzcyBWIGV4dGVuZHMgdyB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBzdGF0dXM6IHIsIGN0eDogbiB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChuLnBhcnNlZFR5cGUgIT09IG0uYXJyYXkpXG4gICAgICByZXR1cm4gcChuLCB7XG4gICAgICAgIGNvZGU6IGYuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbS5hcnJheSxcbiAgICAgICAgcmVjZWl2ZWQ6IG4ucGFyc2VkVHlwZVxuICAgICAgfSksIHY7XG4gICAgaWYgKG4uZGF0YS5sZW5ndGggPCB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKVxuICAgICAgcmV0dXJuIHAobiwge1xuICAgICAgICBjb2RlOiBmLnRvb19zbWFsbCxcbiAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgZXhhY3Q6ICExLFxuICAgICAgICB0eXBlOiBcImFycmF5XCJcbiAgICAgIH0pLCB2O1xuICAgICF0aGlzLl9kZWYucmVzdCAmJiBuLmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCAmJiAocChuLCB7XG4gICAgICBjb2RlOiBmLnRvb19iaWcsXG4gICAgICBtYXhpbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgIGV4YWN0OiAhMSxcbiAgICAgIHR5cGU6IFwiYXJyYXlcIlxuICAgIH0pLCByLmRpcnR5KCkpO1xuICAgIGNvbnN0IGEgPSBbLi4ubi5kYXRhXS5tYXAoKGksIG8pID0+IHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLl9kZWYuaXRlbXNbb10gfHwgdGhpcy5fZGVmLnJlc3Q7XG4gICAgICByZXR1cm4gYyA/IGMuX3BhcnNlKG5ldyBCKG4sIGksIG4ucGF0aCwgbykpIDogbnVsbDtcbiAgICB9KS5maWx0ZXIoKGkpID0+ICEhaSk7XG4gICAgcmV0dXJuIG4uY29tbW9uLmFzeW5jID8gUHJvbWlzZS5hbGwoYSkudGhlbigoaSkgPT4gTi5tZXJnZUFycmF5KHIsIGkpKSA6IE4ubWVyZ2VBcnJheShyLCBhKTtcbiAgfVxuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pdGVtcztcbiAgfVxuICByZXN0KGUpIHtcbiAgICByZXR1cm4gbmV3IFYoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgcmVzdDogZVxuICAgIH0pO1xuICB9XG59XG5WLmNyZWF0ZSA9ICh0LCBlKSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIHNjaGVtYXMgdG8gei50dXBsZShbIC4uLiBdKVwiKTtcbiAgcmV0dXJuIG5ldyBWKHtcbiAgICBpdGVtczogdCxcbiAgICB0eXBlTmFtZTogXy5ab2RUdXBsZSxcbiAgICByZXN0OiBudWxsLFxuICAgIC4uLmIoZSlcbiAgfSk7XG59O1xuY2xhc3MgRGUgZXh0ZW5kcyB3IHtcbiAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gIH1cbiAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICB9XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBzdGF0dXM6IHIsIGN0eDogbiB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChuLnBhcnNlZFR5cGUgIT09IG0ub2JqZWN0KVxuICAgICAgcmV0dXJuIHAobiwge1xuICAgICAgICBjb2RlOiBmLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IG0ub2JqZWN0LFxuICAgICAgICByZWNlaXZlZDogbi5wYXJzZWRUeXBlXG4gICAgICB9KSwgdjtcbiAgICBjb25zdCBzID0gW10sIGEgPSB0aGlzLl9kZWYua2V5VHlwZSwgaSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgZm9yIChjb25zdCBvIGluIG4uZGF0YSlcbiAgICAgIHMucHVzaCh7XG4gICAgICAgIGtleTogYS5fcGFyc2UobmV3IEIobiwgbywgbi5wYXRoLCBvKSksXG4gICAgICAgIHZhbHVlOiBpLl9wYXJzZShuZXcgQihuLCBuLmRhdGFbb10sIG4ucGF0aCwgbykpLFxuICAgICAgICBhbHdheXNTZXQ6IG8gaW4gbi5kYXRhXG4gICAgICB9KTtcbiAgICByZXR1cm4gbi5jb21tb24uYXN5bmMgPyBOLm1lcmdlT2JqZWN0QXN5bmMociwgcykgOiBOLm1lcmdlT2JqZWN0U3luYyhyLCBzKTtcbiAgfVxuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKGUsIHIsIG4pIHtcbiAgICByZXR1cm4gciBpbnN0YW5jZW9mIHcgPyBuZXcgRGUoe1xuICAgICAga2V5VHlwZTogZSxcbiAgICAgIHZhbHVlVHlwZTogcixcbiAgICAgIHR5cGVOYW1lOiBfLlpvZFJlY29yZCxcbiAgICAgIC4uLmIobilcbiAgICB9KSA6IG5ldyBEZSh7XG4gICAgICBrZXlUeXBlOiBaLmNyZWF0ZSgpLFxuICAgICAgdmFsdWVUeXBlOiBlLFxuICAgICAgdHlwZU5hbWU6IF8uWm9kUmVjb3JkLFxuICAgICAgLi4uYihyKVxuICAgIH0pO1xuICB9XG59XG5jbGFzcyB0dCBleHRlbmRzIHcge1xuICBnZXQga2V5U2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgfVxuICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IHN0YXR1czogciwgY3R4OiBuIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSk7XG4gICAgaWYgKG4ucGFyc2VkVHlwZSAhPT0gbS5tYXApXG4gICAgICByZXR1cm4gcChuLCB7XG4gICAgICAgIGNvZGU6IGYuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbS5tYXAsXG4gICAgICAgIHJlY2VpdmVkOiBuLnBhcnNlZFR5cGVcbiAgICAgIH0pLCB2O1xuICAgIGNvbnN0IHMgPSB0aGlzLl9kZWYua2V5VHlwZSwgYSA9IHRoaXMuX2RlZi52YWx1ZVR5cGUsIGkgPSBbLi4ubi5kYXRhLmVudHJpZXMoKV0ubWFwKChbbywgY10sIHUpID0+ICh7XG4gICAgICBrZXk6IHMuX3BhcnNlKG5ldyBCKG4sIG8sIG4ucGF0aCwgW3UsIFwia2V5XCJdKSksXG4gICAgICB2YWx1ZTogYS5fcGFyc2UobmV3IEIobiwgYywgbi5wYXRoLCBbdSwgXCJ2YWx1ZVwiXSkpXG4gICAgfSkpO1xuICAgIGlmIChuLmNvbW1vbi5hc3luYykge1xuICAgICAgY29uc3QgbyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBpKSB7XG4gICAgICAgICAgY29uc3QgdSA9IGF3YWl0IGMua2V5LCBkID0gYXdhaXQgYy52YWx1ZTtcbiAgICAgICAgICBpZiAodS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IGQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICh1LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IGQuc3RhdHVzID09PSBcImRpcnR5XCIpICYmIHIuZGlydHkoKSwgby5zZXQodS52YWx1ZSwgZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiByLnZhbHVlLCB2YWx1ZTogbyB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCBjIG9mIGkpIHtcbiAgICAgICAgY29uc3QgdSA9IGMua2V5LCBkID0gYy52YWx1ZTtcbiAgICAgICAgaWYgKHUuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCBkLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICh1LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IGQuc3RhdHVzID09PSBcImRpcnR5XCIpICYmIHIuZGlydHkoKSwgby5zZXQodS52YWx1ZSwgZC52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHIudmFsdWUsIHZhbHVlOiBvIH07XG4gICAgfVxuICB9XG59XG50dC5jcmVhdGUgPSAodCwgZSwgcikgPT4gbmV3IHR0KHtcbiAgdmFsdWVUeXBlOiBlLFxuICBrZXlUeXBlOiB0LFxuICB0eXBlTmFtZTogXy5ab2RNYXAsXG4gIC4uLmIocilcbn0pO1xuY2xhc3MgdWUgZXh0ZW5kcyB3IHtcbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IHN0YXR1czogciwgY3R4OiBuIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSk7XG4gICAgaWYgKG4ucGFyc2VkVHlwZSAhPT0gbS5zZXQpXG4gICAgICByZXR1cm4gcChuLCB7XG4gICAgICAgIGNvZGU6IGYuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbS5zZXQsXG4gICAgICAgIHJlY2VpdmVkOiBuLnBhcnNlZFR5cGVcbiAgICAgIH0pLCB2O1xuICAgIGNvbnN0IHMgPSB0aGlzLl9kZWY7XG4gICAgcy5taW5TaXplICE9PSBudWxsICYmIG4uZGF0YS5zaXplIDwgcy5taW5TaXplLnZhbHVlICYmIChwKG4sIHtcbiAgICAgIGNvZGU6IGYudG9vX3NtYWxsLFxuICAgICAgbWluaW11bTogcy5taW5TaXplLnZhbHVlLFxuICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBleGFjdDogITEsXG4gICAgICBtZXNzYWdlOiBzLm1pblNpemUubWVzc2FnZVxuICAgIH0pLCByLmRpcnR5KCkpLCBzLm1heFNpemUgIT09IG51bGwgJiYgbi5kYXRhLnNpemUgPiBzLm1heFNpemUudmFsdWUgJiYgKHAobiwge1xuICAgICAgY29kZTogZi50b29fYmlnLFxuICAgICAgbWF4aW11bTogcy5tYXhTaXplLnZhbHVlLFxuICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBleGFjdDogITEsXG4gICAgICBtZXNzYWdlOiBzLm1heFNpemUubWVzc2FnZVxuICAgIH0pLCByLmRpcnR5KCkpO1xuICAgIGNvbnN0IGEgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIGZ1bmN0aW9uIGkoYykge1xuICAgICAgY29uc3QgdSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IGQgb2YgYykge1xuICAgICAgICBpZiAoZC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBkLnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmIHIuZGlydHkoKSwgdS5hZGQoZC52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHIudmFsdWUsIHZhbHVlOiB1IH07XG4gICAgfVxuICAgIGNvbnN0IG8gPSBbLi4ubi5kYXRhLnZhbHVlcygpXS5tYXAoKGMsIHUpID0+IGEuX3BhcnNlKG5ldyBCKG4sIGMsIG4ucGF0aCwgdSkpKTtcbiAgICByZXR1cm4gbi5jb21tb24uYXN5bmMgPyBQcm9taXNlLmFsbChvKS50aGVuKChjKSA9PiBpKGMpKSA6IGkobyk7XG4gIH1cbiAgbWluKGUsIHIpIHtcbiAgICByZXR1cm4gbmV3IHVlKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1pblNpemU6IHsgdmFsdWU6IGUsIG1lc3NhZ2U6IGcudG9TdHJpbmcocikgfVxuICAgIH0pO1xuICB9XG4gIG1heChlLCByKSB7XG4gICAgcmV0dXJuIG5ldyB1ZSh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtYXhTaXplOiB7IHZhbHVlOiBlLCBtZXNzYWdlOiBnLnRvU3RyaW5nKHIpIH1cbiAgICB9KTtcbiAgfVxuICBzaXplKGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5taW4oZSwgcikubWF4KGUsIHIpO1xuICB9XG4gIG5vbmVtcHR5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5taW4oMSwgZSk7XG4gIH1cbn1cbnVlLmNyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgdWUoe1xuICB2YWx1ZVR5cGU6IHQsXG4gIG1pblNpemU6IG51bGwsXG4gIG1heFNpemU6IG51bGwsXG4gIHR5cGVOYW1lOiBfLlpvZFNldCxcbiAgLi4uYihlKVxufSk7XG5jbGFzcyBtZSBleHRlbmRzIHcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IGN0eDogciB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChyLnBhcnNlZFR5cGUgIT09IG0uZnVuY3Rpb24pXG4gICAgICByZXR1cm4gcChyLCB7XG4gICAgICAgIGNvZGU6IGYuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbS5mdW5jdGlvbixcbiAgICAgICAgcmVjZWl2ZWQ6IHIucGFyc2VkVHlwZVxuICAgICAgfSksIHY7XG4gICAgZnVuY3Rpb24gbihvLCBjKSB7XG4gICAgICByZXR1cm4gWGUoe1xuICAgICAgICBkYXRhOiBvLFxuICAgICAgICBwYXRoOiByLnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgIHIuY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICByLnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgIFllKCksXG4gICAgICAgICAgZ2VcbiAgICAgICAgXS5maWx0ZXIoKHUpID0+ICEhdSksXG4gICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgIGNvZGU6IGYuaW52YWxpZF9hcmd1bWVudHMsXG4gICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHMobywgYykge1xuICAgICAgcmV0dXJuIFhlKHtcbiAgICAgICAgZGF0YTogbyxcbiAgICAgICAgcGF0aDogci5wYXRoLFxuICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICByLmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgci5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICBZZSgpLFxuICAgICAgICAgIGdlXG4gICAgICAgIF0uZmlsdGVyKCh1KSA9PiAhIXUpLFxuICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICBjb2RlOiBmLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgcmV0dXJuVHlwZUVycm9yOiBjXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhID0geyBlcnJvck1hcDogci5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH0sIGkgPSByLmRhdGE7XG4gICAgaWYgKHRoaXMuX2RlZi5yZXR1cm5zIGluc3RhbmNlb2YgdmUpIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzO1xuICAgICAgcmV0dXJuIEkoYXN5bmMgZnVuY3Rpb24oLi4uYykge1xuICAgICAgICBjb25zdCB1ID0gbmV3IEwoW10pLCBkID0gYXdhaXQgby5fZGVmLmFyZ3MucGFyc2VBc3luYyhjLCBhKS5jYXRjaCgoaykgPT4ge1xuICAgICAgICAgIHRocm93IHUuYWRkSXNzdWUobihjLCBrKSksIHU7XG4gICAgICAgIH0pLCBoID0gYXdhaXQgUmVmbGVjdC5hcHBseShpLCB0aGlzLCBkKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG8uX2RlZi5yZXR1cm5zLl9kZWYudHlwZS5wYXJzZUFzeW5jKGgsIGEpLmNhdGNoKChrKSA9PiB7XG4gICAgICAgICAgdGhyb3cgdS5hZGRJc3N1ZShzKGgsIGspKSwgdTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbyA9IHRoaXM7XG4gICAgICByZXR1cm4gSShmdW5jdGlvbiguLi5jKSB7XG4gICAgICAgIGNvbnN0IHUgPSBvLl9kZWYuYXJncy5zYWZlUGFyc2UoYywgYSk7XG4gICAgICAgIGlmICghdS5zdWNjZXNzKVxuICAgICAgICAgIHRocm93IG5ldyBMKFtuKGMsIHUuZXJyb3IpXSk7XG4gICAgICAgIGNvbnN0IGQgPSBSZWZsZWN0LmFwcGx5KGksIHRoaXMsIHUuZGF0YSksIGggPSBvLl9kZWYucmV0dXJucy5zYWZlUGFyc2UoZCwgYSk7XG4gICAgICAgIGlmICghaC5zdWNjZXNzKVxuICAgICAgICAgIHRocm93IG5ldyBMKFtzKGQsIGguZXJyb3IpXSk7XG4gICAgICAgIHJldHVybiBoLmRhdGE7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcGFyYW1ldGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmFyZ3M7XG4gIH1cbiAgcmV0dXJuVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gIH1cbiAgYXJncyguLi5lKSB7XG4gICAgcmV0dXJuIG5ldyBtZSh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBhcmdzOiBWLmNyZWF0ZShlKS5yZXN0KGllLmNyZWF0ZSgpKVxuICAgIH0pO1xuICB9XG4gIHJldHVybnMoZSkge1xuICAgIHJldHVybiBuZXcgbWUoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgcmV0dXJuczogZVxuICAgIH0pO1xuICB9XG4gIGltcGxlbWVudChlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoZSk7XG4gIH1cbiAgc3RyaWN0SW1wbGVtZW50KGUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZShlKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKGUsIHIsIG4pIHtcbiAgICByZXR1cm4gbmV3IG1lKHtcbiAgICAgIGFyZ3M6IGUgfHwgVi5jcmVhdGUoW10pLnJlc3QoaWUuY3JlYXRlKCkpLFxuICAgICAgcmV0dXJuczogciB8fCBpZS5jcmVhdGUoKSxcbiAgICAgIHR5cGVOYW1lOiBfLlpvZEZ1bmN0aW9uLFxuICAgICAgLi4uYihuKVxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBaZSBleHRlbmRzIHcge1xuICBnZXQgc2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IGN0eDogciB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCkuX3BhcnNlKHsgZGF0YTogci5kYXRhLCBwYXRoOiByLnBhdGgsIHBhcmVudDogciB9KTtcbiAgfVxufVxuWmUuY3JlYXRlID0gKHQsIGUpID0+IG5ldyBaZSh7XG4gIGdldHRlcjogdCxcbiAgdHlwZU5hbWU6IF8uWm9kTGF6eSxcbiAgLi4uYihlKVxufSk7XG5jbGFzcyBVZSBleHRlbmRzIHcge1xuICBfcGFyc2UoZSkge1xuICAgIGlmIChlLmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgY29uc3QgciA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIHAociwge1xuICAgICAgICByZWNlaXZlZDogci5kYXRhLFxuICAgICAgICBjb2RlOiBmLmludmFsaWRfbGl0ZXJhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZVxuICAgICAgfSksIHY7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogZS5kYXRhIH07XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gIH1cbn1cblVlLmNyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgVWUoe1xuICB2YWx1ZTogdCxcbiAgdHlwZU5hbWU6IF8uWm9kTGl0ZXJhbCxcbiAgLi4uYihlKVxufSk7XG5mdW5jdGlvbiBtbih0LCBlKSB7XG4gIHJldHVybiBuZXcgdGUoe1xuICAgIHZhbHVlczogdCxcbiAgICB0eXBlTmFtZTogXy5ab2RFbnVtLFxuICAgIC4uLmIoZSlcbiAgfSk7XG59XG5jbGFzcyB0ZSBleHRlbmRzIHcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCBSZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGlmICh0eXBlb2YgZS5kYXRhICE9IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKSwgbiA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICByZXR1cm4gcChyLCB7XG4gICAgICAgIGV4cGVjdGVkOiB4LmpvaW5WYWx1ZXMobiksXG4gICAgICAgIHJlY2VpdmVkOiByLnBhcnNlZFR5cGUsXG4gICAgICAgIGNvZGU6IGYuaW52YWxpZF90eXBlXG4gICAgICB9KSwgdjtcbiAgICB9XG4gICAgaWYgKFFlKHRoaXMsIFJlLCBcImZcIikgfHwgZG4odGhpcywgUmUsIG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyksIFwiZlwiKSwgIVFlKHRoaXMsIFJlLCBcImZcIikuaGFzKGUuZGF0YSkpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKSwgbiA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICByZXR1cm4gcChyLCB7XG4gICAgICAgIHJlY2VpdmVkOiByLmRhdGEsXG4gICAgICAgIGNvZGU6IGYuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICBvcHRpb25zOiBuXG4gICAgICB9KSwgdjtcbiAgICB9XG4gICAgcmV0dXJuIEkoZS5kYXRhKTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgfVxuICBnZXQgZW51bSgpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgZm9yIChjb25zdCByIG9mIHRoaXMuX2RlZi52YWx1ZXMpXG4gICAgICBlW3JdID0gcjtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBnZXQgVmFsdWVzKCkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5fZGVmLnZhbHVlcylcbiAgICAgIGVbcl0gPSByO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBFbnVtKCkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5fZGVmLnZhbHVlcylcbiAgICAgIGVbcl0gPSByO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGV4dHJhY3QoZSwgciA9IHRoaXMuX2RlZikge1xuICAgIHJldHVybiB0ZS5jcmVhdGUoZSwge1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgLi4uclxuICAgIH0pO1xuICB9XG4gIGV4Y2x1ZGUoZSwgciA9IHRoaXMuX2RlZikge1xuICAgIHJldHVybiB0ZS5jcmVhdGUodGhpcy5vcHRpb25zLmZpbHRlcigobikgPT4gIWUuaW5jbHVkZXMobikpLCB7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAuLi5yXG4gICAgfSk7XG4gIH1cbn1cblJlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG50ZS5jcmVhdGUgPSBtbjtcbmNsYXNzIFdlIGV4dGVuZHMgdyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIE9lLnNldCh0aGlzLCB2b2lkIDApO1xuICB9XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgciA9IHguZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpLCBuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgaWYgKG4ucGFyc2VkVHlwZSAhPT0gbS5zdHJpbmcgJiYgbi5wYXJzZWRUeXBlICE9PSBtLm51bWJlcikge1xuICAgICAgY29uc3QgcyA9IHgub2JqZWN0VmFsdWVzKHIpO1xuICAgICAgcmV0dXJuIHAobiwge1xuICAgICAgICBleHBlY3RlZDogeC5qb2luVmFsdWVzKHMpLFxuICAgICAgICByZWNlaXZlZDogbi5wYXJzZWRUeXBlLFxuICAgICAgICBjb2RlOiBmLmludmFsaWRfdHlwZVxuICAgICAgfSksIHY7XG4gICAgfVxuICAgIGlmIChRZSh0aGlzLCBPZSwgXCJmXCIpIHx8IGRuKHRoaXMsIE9lLCBuZXcgU2V0KHguZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKSwgXCJmXCIpLCAhUWUodGhpcywgT2UsIFwiZlwiKS5oYXMoZS5kYXRhKSkge1xuICAgICAgY29uc3QgcyA9IHgub2JqZWN0VmFsdWVzKHIpO1xuICAgICAgcmV0dXJuIHAobiwge1xuICAgICAgICByZWNlaXZlZDogbi5kYXRhLFxuICAgICAgICBjb2RlOiBmLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgb3B0aW9uczogc1xuICAgICAgfSksIHY7XG4gICAgfVxuICAgIHJldHVybiBJKGUuZGF0YSk7XG4gIH1cbiAgZ2V0IGVudW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gIH1cbn1cbk9lID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5XZS5jcmVhdGUgPSAodCwgZSkgPT4gbmV3IFdlKHtcbiAgdmFsdWVzOiB0LFxuICB0eXBlTmFtZTogXy5ab2ROYXRpdmVFbnVtLFxuICAuLi5iKGUpXG59KTtcbmNsYXNzIHZlIGV4dGVuZHMgdyB7XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IGN0eDogciB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChyLnBhcnNlZFR5cGUgIT09IG0ucHJvbWlzZSAmJiByLmNvbW1vbi5hc3luYyA9PT0gITEpXG4gICAgICByZXR1cm4gcChyLCB7XG4gICAgICAgIGNvZGU6IGYuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbS5wcm9taXNlLFxuICAgICAgICByZWNlaXZlZDogci5wYXJzZWRUeXBlXG4gICAgICB9KSwgdjtcbiAgICBjb25zdCBuID0gci5wYXJzZWRUeXBlID09PSBtLnByb21pc2UgPyByLmRhdGEgOiBQcm9taXNlLnJlc29sdmUoci5kYXRhKTtcbiAgICByZXR1cm4gSShuLnRoZW4oKHMpID0+IHRoaXMuX2RlZi50eXBlLnBhcnNlQXN5bmMocywge1xuICAgICAgcGF0aDogci5wYXRoLFxuICAgICAgZXJyb3JNYXA6IHIuY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcFxuICAgIH0pKSk7XG4gIH1cbn1cbnZlLmNyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgdmUoe1xuICB0eXBlOiB0LFxuICB0eXBlTmFtZTogXy5ab2RQcm9taXNlLFxuICAuLi5iKGUpXG59KTtcbmNsYXNzIFcgZXh0ZW5kcyB3IHtcbiAgaW5uZXJUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hO1xuICB9XG4gIHNvdXJjZVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX2RlZi50eXBlTmFtZSA9PT0gXy5ab2RFZmZlY3RzID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKCkgOiB0aGlzLl9kZWYuc2NoZW1hO1xuICB9XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBzdGF0dXM6IHIsIGN0eDogbiB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpLCBzID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsLCBhID0ge1xuICAgICAgYWRkSXNzdWU6IChpKSA9PiB7XG4gICAgICAgIHAobiwgaSksIGkuZmF0YWwgPyByLmFib3J0KCkgOiByLmRpcnR5KCk7XG4gICAgICB9LFxuICAgICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiBuLnBhdGg7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoYS5hZGRJc3N1ZSA9IGEuYWRkSXNzdWUuYmluZChhKSwgcy50eXBlID09PSBcInByZXByb2Nlc3NcIikge1xuICAgICAgY29uc3QgaSA9IHMudHJhbnNmb3JtKG4uZGF0YSwgYSk7XG4gICAgICBpZiAobi5jb21tb24uYXN5bmMpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaSkudGhlbihhc3luYyAobykgPT4ge1xuICAgICAgICAgIGlmIChyLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIGNvbnN0IGMgPSBhd2FpdCB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgIGRhdGE6IG8sXG4gICAgICAgICAgICBwYXRoOiBuLnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IG5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gYy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiID8gdiA6IGMuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgci52YWx1ZSA9PT0gXCJkaXJ0eVwiID8gaGUoYy52YWx1ZSkgOiBjO1xuICAgICAgICB9KTtcbiAgICAgIHtcbiAgICAgICAgaWYgKHIudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjb25zdCBvID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICBkYXRhOiBpLFxuICAgICAgICAgIHBhdGg6IG4ucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgPyB2IDogby5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCByLnZhbHVlID09PSBcImRpcnR5XCIgPyBoZShvLnZhbHVlKSA6IG87XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzLnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XG4gICAgICBjb25zdCBpID0gKG8pID0+IHtcbiAgICAgICAgY29uc3QgYyA9IHMucmVmaW5lbWVudChvLCBhKTtcbiAgICAgICAgaWYgKG4uY29tbW9uLmFzeW5jKVxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYyk7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9O1xuICAgICAgaWYgKG4uY29tbW9uLmFzeW5jID09PSAhMSkge1xuICAgICAgICBjb25zdCBvID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICBkYXRhOiBuLmRhdGEsXG4gICAgICAgICAgcGF0aDogbi5wYXRoLFxuICAgICAgICAgIHBhcmVudDogblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG8uc3RhdHVzID09PSBcImFib3J0ZWRcIiA/IHYgOiAoby5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiByLmRpcnR5KCksIGkoby52YWx1ZSksIHsgc3RhdHVzOiByLnZhbHVlLCB2YWx1ZTogby52YWx1ZSB9KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7IGRhdGE6IG4uZGF0YSwgcGF0aDogbi5wYXRoLCBwYXJlbnQ6IG4gfSkudGhlbigobykgPT4gby5zdGF0dXMgPT09IFwiYWJvcnRlZFwiID8gdiA6IChvLnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmIHIuZGlydHkoKSwgaShvLnZhbHVlKS50aGVuKCgpID0+ICh7IHN0YXR1czogci52YWx1ZSwgdmFsdWU6IG8udmFsdWUgfSkpKSk7XG4gICAgfVxuICAgIGlmIChzLnR5cGUgPT09IFwidHJhbnNmb3JtXCIpXG4gICAgICBpZiAobi5jb21tb24uYXN5bmMgPT09ICExKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgIGRhdGE6IG4uZGF0YSxcbiAgICAgICAgICBwYXRoOiBuLnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBuXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW9lKGkpKVxuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICBjb25zdCBvID0gcy50cmFuc2Zvcm0oaS52YWx1ZSwgYSk7XG4gICAgICAgIGlmIChvIGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luY2hyb25vdXMgdHJhbnNmb3JtIGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiByLnZhbHVlLCB2YWx1ZTogbyB9O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogbi5kYXRhLCBwYXRoOiBuLnBhdGgsIHBhcmVudDogbiB9KS50aGVuKChpKSA9PiBvZShpKSA/IFByb21pc2UucmVzb2x2ZShzLnRyYW5zZm9ybShpLnZhbHVlLCBhKSkudGhlbigobykgPT4gKHsgc3RhdHVzOiByLnZhbHVlLCB2YWx1ZTogbyB9KSkgOiBpKTtcbiAgICB4LmFzc2VydE5ldmVyKHMpO1xuICB9XG59XG5XLmNyZWF0ZSA9ICh0LCBlLCByKSA9PiBuZXcgVyh7XG4gIHNjaGVtYTogdCxcbiAgdHlwZU5hbWU6IF8uWm9kRWZmZWN0cyxcbiAgZWZmZWN0OiBlLFxuICAuLi5iKHIpXG59KTtcblcuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAodCwgZSwgcikgPT4gbmV3IFcoe1xuICBzY2hlbWE6IGUsXG4gIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiB0IH0sXG4gIHR5cGVOYW1lOiBfLlpvZEVmZmVjdHMsXG4gIC4uLmIocilcbn0pO1xuY2xhc3MgeiBleHRlbmRzIHcge1xuICBfcGFyc2UoZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRUeXBlKGUpID09PSBtLnVuZGVmaW5lZCA/IEkodm9pZCAwKSA6IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGUpO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufVxuei5jcmVhdGUgPSAodCwgZSkgPT4gbmV3IHooe1xuICBpbm5lclR5cGU6IHQsXG4gIHR5cGVOYW1lOiBfLlpvZE9wdGlvbmFsLFxuICAuLi5iKGUpXG59KTtcbmNsYXNzIHJlIGV4dGVuZHMgdyB7XG4gIF9wYXJzZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFR5cGUoZSkgPT09IG0ubnVsbCA/IEkobnVsbCkgOiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShlKTtcbiAgfVxuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gIH1cbn1cbnJlLmNyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgcmUoe1xuICBpbm5lclR5cGU6IHQsXG4gIHR5cGVOYW1lOiBfLlpvZE51bGxhYmxlLFxuICAuLi5iKGUpXG59KTtcbmNsYXNzIHFlIGV4dGVuZHMgdyB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBjdHg6IHIgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKTtcbiAgICBsZXQgbiA9IHIuZGF0YTtcbiAgICByZXR1cm4gci5wYXJzZWRUeXBlID09PSBtLnVuZGVmaW5lZCAmJiAobiA9IHRoaXMuX2RlZi5kZWZhdWx0VmFsdWUoKSksIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgIGRhdGE6IG4sXG4gICAgICBwYXRoOiByLnBhdGgsXG4gICAgICBwYXJlbnQ6IHJcbiAgICB9KTtcbiAgfVxuICByZW1vdmVEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59XG5xZS5jcmVhdGUgPSAodCwgZSkgPT4gbmV3IHFlKHtcbiAgaW5uZXJUeXBlOiB0LFxuICB0eXBlTmFtZTogXy5ab2REZWZhdWx0LFxuICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBlLmRlZmF1bHQgPT0gXCJmdW5jdGlvblwiID8gZS5kZWZhdWx0IDogKCkgPT4gZS5kZWZhdWx0LFxuICAuLi5iKGUpXG59KTtcbmNsYXNzIHplIGV4dGVuZHMgdyB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBjdHg6IHIgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKSwgbiA9IHtcbiAgICAgIC4uLnIsXG4gICAgICBjb21tb246IHtcbiAgICAgICAgLi4uci5jb21tb24sXG4gICAgICAgIGlzc3VlczogW11cbiAgICAgIH1cbiAgICB9LCBzID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgZGF0YTogbi5kYXRhLFxuICAgICAgcGF0aDogbi5wYXRoLFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIC4uLm5cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gTmUocykgPyBzLnRoZW4oKGEpID0+ICh7XG4gICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgIHZhbHVlOiBhLnN0YXR1cyA9PT0gXCJ2YWxpZFwiID8gYS52YWx1ZSA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgTChuLmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICB9LFxuICAgICAgICBpbnB1dDogbi5kYXRhXG4gICAgICB9KVxuICAgIH0pKSA6IHtcbiAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgdmFsdWU6IHMuc3RhdHVzID09PSBcInZhbGlkXCIgPyBzLnZhbHVlIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMKG4uY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0OiBuLmRhdGFcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICByZW1vdmVDYXRjaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufVxuemUuY3JlYXRlID0gKHQsIGUpID0+IG5ldyB6ZSh7XG4gIGlubmVyVHlwZTogdCxcbiAgdHlwZU5hbWU6IF8uWm9kQ2F0Y2gsXG4gIGNhdGNoVmFsdWU6IHR5cGVvZiBlLmNhdGNoID09IFwiZnVuY3Rpb25cIiA/IGUuY2F0Y2ggOiAoKSA9PiBlLmNhdGNoLFxuICAuLi5iKGUpXG59KTtcbmNsYXNzIHJ0IGV4dGVuZHMgdyB7XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKHRoaXMuX2dldFR5cGUoZSkgIT09IG0ubmFuKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gcChuLCB7XG4gICAgICAgIGNvZGU6IGYuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbS5uYW4sXG4gICAgICAgIHJlY2VpdmVkOiBuLnBhcnNlZFR5cGVcbiAgICAgIH0pLCB2O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGUuZGF0YSB9O1xuICB9XG59XG5ydC5jcmVhdGUgPSAodCkgPT4gbmV3IHJ0KHtcbiAgdHlwZU5hbWU6IF8uWm9kTmFOLFxuICAuLi5iKHQpXG59KTtcbmNvbnN0IGhpID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xuY2xhc3MgWXQgZXh0ZW5kcyB3IHtcbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IGN0eDogciB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpLCBuID0gci5kYXRhO1xuICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgZGF0YTogbixcbiAgICAgIHBhdGg6IHIucGF0aCxcbiAgICAgIHBhcmVudDogclxuICAgIH0pO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbn1cbmNsYXNzIEZlIGV4dGVuZHMgdyB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBzdGF0dXM6IHIsIGN0eDogbiB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChuLmNvbW1vbi5hc3luYylcbiAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBhID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICBkYXRhOiBuLmRhdGEsXG4gICAgICAgICAgcGF0aDogbi5wYXRoLFxuICAgICAgICAgIHBhcmVudDogblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGEuc3RhdHVzID09PSBcImFib3J0ZWRcIiA/IHYgOiBhLnN0YXR1cyA9PT0gXCJkaXJ0eVwiID8gKHIuZGlydHkoKSwgaGUoYS52YWx1ZSkpIDogdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgZGF0YTogYS52YWx1ZSxcbiAgICAgICAgICBwYXRoOiBuLnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBuXG4gICAgICAgIH0pO1xuICAgICAgfSkoKTtcbiAgICB7XG4gICAgICBjb25zdCBzID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICBkYXRhOiBuLmRhdGEsXG4gICAgICAgIHBhdGg6IG4ucGF0aCxcbiAgICAgICAgcGFyZW50OiBuXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgPyB2IDogcy5zdGF0dXMgPT09IFwiZGlydHlcIiA/IChyLmRpcnR5KCksIHtcbiAgICAgICAgc3RhdHVzOiBcImRpcnR5XCIsXG4gICAgICAgIHZhbHVlOiBzLnZhbHVlXG4gICAgICB9KSA6IHRoaXMuX2RlZi5vdXQuX3BhcnNlU3luYyh7XG4gICAgICAgIGRhdGE6IHMudmFsdWUsXG4gICAgICAgIHBhdGg6IG4ucGF0aCxcbiAgICAgICAgcGFyZW50OiBuXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShlLCByKSB7XG4gICAgcmV0dXJuIG5ldyBGZSh7XG4gICAgICBpbjogZSxcbiAgICAgIG91dDogcixcbiAgICAgIHR5cGVOYW1lOiBfLlpvZFBpcGVsaW5lXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEJlIGV4dGVuZHMgdyB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgciA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGUpLCBuID0gKHMpID0+IChvZShzKSAmJiAocy52YWx1ZSA9IE9iamVjdC5mcmVlemUocy52YWx1ZSkpLCBzKTtcbiAgICByZXR1cm4gTmUocikgPyByLnRoZW4oKHMpID0+IG4ocykpIDogbihyKTtcbiAgfVxuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gIH1cbn1cbkJlLmNyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgQmUoe1xuICBpbm5lclR5cGU6IHQsXG4gIHR5cGVOYW1lOiBfLlpvZFJlYWRvbmx5LFxuICAuLi5iKGUpXG59KTtcbmZ1bmN0aW9uIHluKHQsIGUgPSB7fSwgcikge1xuICByZXR1cm4gdCA/IF9lLmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChuLCBzKSA9PiB7XG4gICAgdmFyIGEsIGk7XG4gICAgaWYgKCF0KG4pKSB7XG4gICAgICBjb25zdCBvID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZShuKSA6IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IGUgfSA6IGUsIGMgPSAoaSA9IChhID0gby5mYXRhbCkgIT09IG51bGwgJiYgYSAhPT0gdm9pZCAwID8gYSA6IHIpICE9PSBudWxsICYmIGkgIT09IHZvaWQgMCA/IGkgOiAhMCwgdSA9IHR5cGVvZiBvID09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IG8gfSA6IG87XG4gICAgICBzLmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4udSwgZmF0YWw6IGMgfSk7XG4gICAgfVxuICB9KSA6IF9lLmNyZWF0ZSgpO1xufVxuY29uc3QgbWkgPSB7XG4gIG9iamVjdDogQy5sYXp5Y3JlYXRlXG59O1xudmFyIF87XG4oZnVuY3Rpb24odCkge1xuICB0LlpvZFN0cmluZyA9IFwiWm9kU3RyaW5nXCIsIHQuWm9kTnVtYmVyID0gXCJab2ROdW1iZXJcIiwgdC5ab2ROYU4gPSBcIlpvZE5hTlwiLCB0LlpvZEJpZ0ludCA9IFwiWm9kQmlnSW50XCIsIHQuWm9kQm9vbGVhbiA9IFwiWm9kQm9vbGVhblwiLCB0LlpvZERhdGUgPSBcIlpvZERhdGVcIiwgdC5ab2RTeW1ib2wgPSBcIlpvZFN5bWJvbFwiLCB0LlpvZFVuZGVmaW5lZCA9IFwiWm9kVW5kZWZpbmVkXCIsIHQuWm9kTnVsbCA9IFwiWm9kTnVsbFwiLCB0LlpvZEFueSA9IFwiWm9kQW55XCIsIHQuWm9kVW5rbm93biA9IFwiWm9kVW5rbm93blwiLCB0LlpvZE5ldmVyID0gXCJab2ROZXZlclwiLCB0LlpvZFZvaWQgPSBcIlpvZFZvaWRcIiwgdC5ab2RBcnJheSA9IFwiWm9kQXJyYXlcIiwgdC5ab2RPYmplY3QgPSBcIlpvZE9iamVjdFwiLCB0LlpvZFVuaW9uID0gXCJab2RVbmlvblwiLCB0LlpvZERpc2NyaW1pbmF0ZWRVbmlvbiA9IFwiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCIsIHQuWm9kSW50ZXJzZWN0aW9uID0gXCJab2RJbnRlcnNlY3Rpb25cIiwgdC5ab2RUdXBsZSA9IFwiWm9kVHVwbGVcIiwgdC5ab2RSZWNvcmQgPSBcIlpvZFJlY29yZFwiLCB0LlpvZE1hcCA9IFwiWm9kTWFwXCIsIHQuWm9kU2V0ID0gXCJab2RTZXRcIiwgdC5ab2RGdW5jdGlvbiA9IFwiWm9kRnVuY3Rpb25cIiwgdC5ab2RMYXp5ID0gXCJab2RMYXp5XCIsIHQuWm9kTGl0ZXJhbCA9IFwiWm9kTGl0ZXJhbFwiLCB0LlpvZEVudW0gPSBcIlpvZEVudW1cIiwgdC5ab2RFZmZlY3RzID0gXCJab2RFZmZlY3RzXCIsIHQuWm9kTmF0aXZlRW51bSA9IFwiWm9kTmF0aXZlRW51bVwiLCB0LlpvZE9wdGlvbmFsID0gXCJab2RPcHRpb25hbFwiLCB0LlpvZE51bGxhYmxlID0gXCJab2ROdWxsYWJsZVwiLCB0LlpvZERlZmF1bHQgPSBcIlpvZERlZmF1bHRcIiwgdC5ab2RDYXRjaCA9IFwiWm9kQ2F0Y2hcIiwgdC5ab2RQcm9taXNlID0gXCJab2RQcm9taXNlXCIsIHQuWm9kQnJhbmRlZCA9IFwiWm9kQnJhbmRlZFwiLCB0LlpvZFBpcGVsaW5lID0gXCJab2RQaXBlbGluZVwiLCB0LlpvZFJlYWRvbmx5ID0gXCJab2RSZWFkb25seVwiO1xufSkoXyB8fCAoXyA9IHt9KSk7XG5jb25zdCB5aSA9ICh0LCBlID0ge1xuICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7dC5uYW1lfWBcbn0pID0+IHluKChyKSA9PiByIGluc3RhbmNlb2YgdCwgZSksIGduID0gWi5jcmVhdGUsIF9uID0gSy5jcmVhdGUsIGdpID0gcnQuY3JlYXRlLCBfaSA9IGVlLmNyZWF0ZSwgdm4gPSBJZS5jcmVhdGUsIHZpID0gY2UuY3JlYXRlLCBiaSA9IEtlLmNyZWF0ZSwgd2kgPSBqZS5jcmVhdGUsIHhpID0gTGUuY3JlYXRlLCBraSA9IF9lLmNyZWF0ZSwgVGkgPSBpZS5jcmVhdGUsIEVpID0gWC5jcmVhdGUsIENpID0gZXQuY3JlYXRlLCBSaSA9IFUuY3JlYXRlLCBPaSA9IEMuY3JlYXRlLCBTaSA9IEMuc3RyaWN0Q3JlYXRlLCBQaSA9ICRlLmNyZWF0ZSwgQWkgPSBmdC5jcmVhdGUsIE5pID0gTWUuY3JlYXRlLCBJaSA9IFYuY3JlYXRlLCBqaSA9IERlLmNyZWF0ZSwgTGkgPSB0dC5jcmVhdGUsICRpID0gdWUuY3JlYXRlLCBNaSA9IG1lLmNyZWF0ZSwgRGkgPSBaZS5jcmVhdGUsIFppID0gVWUuY3JlYXRlLCBVaSA9IHRlLmNyZWF0ZSwgV2kgPSBXZS5jcmVhdGUsIHFpID0gdmUuY3JlYXRlLCB2ciA9IFcuY3JlYXRlLCB6aSA9IHouY3JlYXRlLCBCaSA9IHJlLmNyZWF0ZSwgVmkgPSBXLmNyZWF0ZVdpdGhQcmVwcm9jZXNzLCBGaSA9IEZlLmNyZWF0ZSwgSGkgPSAoKSA9PiBnbigpLm9wdGlvbmFsKCksIEdpID0gKCkgPT4gX24oKS5vcHRpb25hbCgpLCBKaSA9ICgpID0+IHZuKCkub3B0aW9uYWwoKSwgWWkgPSB7XG4gIHN0cmluZzogKHQpID0+IFouY3JlYXRlKHsgLi4udCwgY29lcmNlOiAhMCB9KSxcbiAgbnVtYmVyOiAodCkgPT4gSy5jcmVhdGUoeyAuLi50LCBjb2VyY2U6ICEwIH0pLFxuICBib29sZWFuOiAodCkgPT4gSWUuY3JlYXRlKHtcbiAgICAuLi50LFxuICAgIGNvZXJjZTogITBcbiAgfSksXG4gIGJpZ2ludDogKHQpID0+IGVlLmNyZWF0ZSh7IC4uLnQsIGNvZXJjZTogITAgfSksXG4gIGRhdGU6ICh0KSA9PiBjZS5jcmVhdGUoeyAuLi50LCBjb2VyY2U6ICEwIH0pXG59LCBYaSA9IHY7XG52YXIgbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBkZWZhdWx0RXJyb3JNYXA6IGdlLFxuICBzZXRFcnJvck1hcDogVmEsXG4gIGdldEVycm9yTWFwOiBZZSxcbiAgbWFrZUlzc3VlOiBYZSxcbiAgRU1QVFlfUEFUSDogRmEsXG4gIGFkZElzc3VlVG9Db250ZXh0OiBwLFxuICBQYXJzZVN0YXR1czogTixcbiAgSU5WQUxJRDogdixcbiAgRElSVFk6IGhlLFxuICBPSzogSSxcbiAgaXNBYm9ydGVkOiBBdCxcbiAgaXNEaXJ0eTogTnQsXG4gIGlzVmFsaWQ6IG9lLFxuICBpc0FzeW5jOiBOZSxcbiAgZ2V0IHV0aWwoKSB7XG4gICAgcmV0dXJuIHg7XG4gIH0sXG4gIGdldCBvYmplY3RVdGlsKCkge1xuICAgIHJldHVybiBQdDtcbiAgfSxcbiAgWm9kUGFyc2VkVHlwZTogbSxcbiAgZ2V0UGFyc2VkVHlwZTogWSxcbiAgWm9kVHlwZTogdyxcbiAgZGF0ZXRpbWVSZWdleDogaG4sXG4gIFpvZFN0cmluZzogWixcbiAgWm9kTnVtYmVyOiBLLFxuICBab2RCaWdJbnQ6IGVlLFxuICBab2RCb29sZWFuOiBJZSxcbiAgWm9kRGF0ZTogY2UsXG4gIFpvZFN5bWJvbDogS2UsXG4gIFpvZFVuZGVmaW5lZDogamUsXG4gIFpvZE51bGw6IExlLFxuICBab2RBbnk6IF9lLFxuICBab2RVbmtub3duOiBpZSxcbiAgWm9kTmV2ZXI6IFgsXG4gIFpvZFZvaWQ6IGV0LFxuICBab2RBcnJheTogVSxcbiAgWm9kT2JqZWN0OiBDLFxuICBab2RVbmlvbjogJGUsXG4gIFpvZERpc2NyaW1pbmF0ZWRVbmlvbjogZnQsXG4gIFpvZEludGVyc2VjdGlvbjogTWUsXG4gIFpvZFR1cGxlOiBWLFxuICBab2RSZWNvcmQ6IERlLFxuICBab2RNYXA6IHR0LFxuICBab2RTZXQ6IHVlLFxuICBab2RGdW5jdGlvbjogbWUsXG4gIFpvZExhenk6IFplLFxuICBab2RMaXRlcmFsOiBVZSxcbiAgWm9kRW51bTogdGUsXG4gIFpvZE5hdGl2ZUVudW06IFdlLFxuICBab2RQcm9taXNlOiB2ZSxcbiAgWm9kRWZmZWN0czogVyxcbiAgWm9kVHJhbnNmb3JtZXI6IFcsXG4gIFpvZE9wdGlvbmFsOiB6LFxuICBab2ROdWxsYWJsZTogcmUsXG4gIFpvZERlZmF1bHQ6IHFlLFxuICBab2RDYXRjaDogemUsXG4gIFpvZE5hTjogcnQsXG4gIEJSQU5EOiBoaSxcbiAgWm9kQnJhbmRlZDogWXQsXG4gIFpvZFBpcGVsaW5lOiBGZSxcbiAgWm9kUmVhZG9ubHk6IEJlLFxuICBjdXN0b206IHluLFxuICBTY2hlbWE6IHcsXG4gIFpvZFNjaGVtYTogdyxcbiAgbGF0ZTogbWksXG4gIGdldCBab2RGaXJzdFBhcnR5VHlwZUtpbmQoKSB7XG4gICAgcmV0dXJuIF87XG4gIH0sXG4gIGNvZXJjZTogWWksXG4gIGFueToga2ksXG4gIGFycmF5OiBSaSxcbiAgYmlnaW50OiBfaSxcbiAgYm9vbGVhbjogdm4sXG4gIGRhdGU6IHZpLFxuICBkaXNjcmltaW5hdGVkVW5pb246IEFpLFxuICBlZmZlY3Q6IHZyLFxuICBlbnVtOiBVaSxcbiAgZnVuY3Rpb246IE1pLFxuICBpbnN0YW5jZW9mOiB5aSxcbiAgaW50ZXJzZWN0aW9uOiBOaSxcbiAgbGF6eTogRGksXG4gIGxpdGVyYWw6IFppLFxuICBtYXA6IExpLFxuICBuYW46IGdpLFxuICBuYXRpdmVFbnVtOiBXaSxcbiAgbmV2ZXI6IEVpLFxuICBudWxsOiB4aSxcbiAgbnVsbGFibGU6IEJpLFxuICBudW1iZXI6IF9uLFxuICBvYmplY3Q6IE9pLFxuICBvYm9vbGVhbjogSmksXG4gIG9udW1iZXI6IEdpLFxuICBvcHRpb25hbDogemksXG4gIG9zdHJpbmc6IEhpLFxuICBwaXBlbGluZTogRmksXG4gIHByZXByb2Nlc3M6IFZpLFxuICBwcm9taXNlOiBxaSxcbiAgcmVjb3JkOiBqaSxcbiAgc2V0OiAkaSxcbiAgc3RyaWN0T2JqZWN0OiBTaSxcbiAgc3RyaW5nOiBnbixcbiAgc3ltYm9sOiBiaSxcbiAgdHJhbnNmb3JtZXI6IHZyLFxuICB0dXBsZTogSWksXG4gIHVuZGVmaW5lZDogd2ksXG4gIHVuaW9uOiBQaSxcbiAgdW5rbm93bjogVGksXG4gIHZvaWQ6IENpLFxuICBORVZFUjogWGksXG4gIFpvZElzc3VlQ29kZTogZixcbiAgcXVvdGVsZXNzSnNvbjogQmEsXG4gIFpvZEVycm9yOiBMXG59KTtcbmNvbnN0IGJuID0gL14weFswLTlhLWZdKyQvaSwgd24gPSAvXlxcZCskLywgUWkgPSBsLnN0cmluZygpLm1pbigxLCBcIlRoZSBzaG9ydCBzdHJpbmcgY2Fubm90IGJlIGVtcHR5XCIpLm1heCgzMSwgXCJUaGUgc2hvcnQgc3RyaW5nIGNhbm5vdCBleGNlZWQgMzEgY2hhcmFjdGVyc1wiKS5yZWZpbmUoXG4gICh0KSA9PiAhYm4udGVzdCh0KSxcbiAgXCJUaGUgc2hvcnRTdHJpbmcgc2hvdWxkIG5vdCBiZSBhIGhleCBzdHJpbmdcIlxuKS5yZWZpbmUoXG4gICh0KSA9PiAhd24udGVzdCh0KSxcbiAgXCJUaGUgc2hvcnRTdHJpbmcgc2hvdWxkIG5vdCBiZSBhbiBpbnRlZ2VyIHN0cmluZ1wiXG4pLCBNID0gbC51bmlvbihbXG4gIGwuc3RyaW5nKCkucmVnZXgoXG4gICAgYm4sXG4gICAgXCJPbmx5IGhleCwgaW50ZWdlcnMgYW5kIGJpZ2ludCBhcmUgc3VwcG9ydGVkIGluIGNhbGxkYXRhXCJcbiAgKSxcbiAgbC5zdHJpbmcoKS5yZWdleChcbiAgICB3bixcbiAgICBcIk9ubHkgaGV4LCBpbnRlZ2VycyBhbmQgYmlnaW50IGFyZSBzdXBwb3J0ZWQgaW4gY2FsbGRhdGFcIlxuICApLFxuICBRaSxcbiAgbC5udW1iZXIoKS5pbnQoXCJPbmx5IGhleCwgaW50ZWdlcnMgYW5kIGJpZ2ludCBhcmUgc3VwcG9ydGVkIGluIGNhbGxkYXRhXCIpLFxuICBsLmJpZ2ludCgpXG5dKSwgVmUgPSBsLm9iamVjdCh7XG4gIGNvbnRyYWN0QWRkcmVzczogbC5zdHJpbmcoKSxcbiAgZW50cnlwb2ludDogbC5zdHJpbmcoKSxcbiAgY2FsbGRhdGE6IGwuYXJyYXkoTS5vcihsLmFycmF5KE0pKSkub3B0aW9uYWwoKVxufSksIGp0ID0gbC5hcnJheShWZSkubm9uZW1wdHkoKSwgeG4gPSBsLm9iamVjdCh7XG4gIHR5cGVzOiBsLnJlY29yZChcbiAgICBsLmFycmF5KFxuICAgICAgbC51bmlvbihbXG4gICAgICAgIGwub2JqZWN0KHtcbiAgICAgICAgICBuYW1lOiBsLnN0cmluZygpLFxuICAgICAgICAgIHR5cGU6IGwubGl0ZXJhbChcIm1lcmtsZXRyZWVcIiksXG4gICAgICAgICAgY29udGFpbnM6IGwuc3RyaW5nKClcbiAgICAgICAgfSksXG4gICAgICAgIGwub2JqZWN0KHtcbiAgICAgICAgICBuYW1lOiBsLnN0cmluZygpLFxuICAgICAgICAgIHR5cGU6IGwubGl0ZXJhbChcImVudW1cIiksXG4gICAgICAgICAgY29udGFpbnM6IGwuc3RyaW5nKClcbiAgICAgICAgfSksXG4gICAgICAgIGwub2JqZWN0KHtcbiAgICAgICAgICBuYW1lOiBsLnN0cmluZygpLFxuICAgICAgICAgIHR5cGU6IGwuc3RyaW5nKClcbiAgICAgICAgfSlcbiAgICAgIF0pXG4gICAgKVxuICApLFxuICBwcmltYXJ5VHlwZTogbC5zdHJpbmcoKSxcbiAgZG9tYWluOiBsLnJlY29yZChsLnVua25vd24oKSksXG4gIG1lc3NhZ2U6IGwucmVjb3JkKGwudW5rbm93bigpKS5vcihsLm9iamVjdCh7fSkpXG59KSwgTHQgPSBsLm9iamVjdCh7XG4gIHR5cGU6IGwubGl0ZXJhbChcIkVSQzIwXCIpLFxuICBvcHRpb25zOiBsLm9iamVjdCh7XG4gICAgYWRkcmVzczogbC5zdHJpbmcoKSxcbiAgICBzeW1ib2w6IGwuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBkZWNpbWFsczogbC5udW1iZXIoKS5vcHRpb25hbCgpLFxuICAgIGltYWdlOiBsLnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgbmFtZTogbC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gIH0pXG59KSwgS2kgPSBsLnVuaW9uKFtcbiAgbC5vYmplY3Qoe1xuICAgIGlkOiBsLnN0cmluZygpLFxuICAgIGNoYWluX2lkOiBsLnN0cmluZygpLFxuICAgIGNoYWluX25hbWU6IGwuc3RyaW5nKCksXG4gICAgcnBjX3VybHM6IGwuYXJyYXkobC5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICBuYXRpdmVfY3VycmVuY3k6IEx0Lm9wdGlvbmFsKCksXG4gICAgYmxvY2tfZXhwbG9yZXJfdXJsOiBsLmFycmF5KGwuc3RyaW5nKCkpLm9wdGlvbmFsKClcbiAgfSksXG4gIGwub2JqZWN0KHtcbiAgICBpZDogbC5zdHJpbmcoKSxcbiAgICBjaGFpbklkOiBsLnN0cmluZygpLFxuICAgIGNoYWluTmFtZTogbC5zdHJpbmcoKSxcbiAgICBycGNVcmxzOiBsLmFycmF5KGwuc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgbmF0aXZlQ3VycmVuY3k6IEx0Lm9wdGlvbmFsKCksXG4gICAgYmxvY2tFeHBsb3JlclVybDogbC5hcnJheShsLnN0cmluZygpKS5vcHRpb25hbCgpXG4gIH0pLnRyYW5zZm9ybSgodCkgPT4gKHtcbiAgICBpZDogdC5pZCxcbiAgICBjaGFpbl9pZDogdC5jaGFpbklkLFxuICAgIGNoYWluX25hbWU6IHQuY2hhaW5OYW1lLFxuICAgIHJwY191cmxzOiB0LnJwY1VybHMsXG4gICAgbmF0aXZlX2N1cnJlbmN5OiB0Lm5hdGl2ZUN1cnJlbmN5LFxuICAgIGJsb2NrX2V4cGxvcmVyX3VybDogdC5ibG9ja0V4cGxvcmVyVXJsXG4gIH0pKVxuXSksIGt0ID0ge1xuICBlbmFibGU6IGwudHVwbGUoW1xuICAgIGwub2JqZWN0KHtcbiAgICAgIHN0YXJrbmV0VmVyc2lvbjogbC51bmlvbihbbC5saXRlcmFsKFwidjNcIiksIGwubGl0ZXJhbChcInY0XCIpLCBsLmxpdGVyYWwoXCJ2NVwiKV0pLm9wdGlvbmFsKClcbiAgICB9KS5vcHRpb25hbCgpXG4gIF0pLm9yKGwudHVwbGUoW10pKSxcbiAgYWRkU3RhcmtuZXRDaGFpbjogbC50dXBsZShbS2ldKSxcbiAgc3dpdGNoU3RhcmtuZXRDaGFpbjogbC50dXBsZShbXG4gICAgbC5vYmplY3Qoe1xuICAgICAgY2hhaW5JZDogbC5zdHJpbmcoKVxuICAgIH0pXG4gIF0pLFxuICB3YXRjaEFzc2V0OiBsLnR1cGxlKFtMdF0pLFxuICByZXF1ZXN0QWNjb3VudHM6IGwudHVwbGUoW1xuICAgIGwub2JqZWN0KHtcbiAgICAgIHNpbGVudF9tb2RlOiBsLmJvb2xlYW4oKS5vcHRpb25hbCgpXG4gICAgfSlcbiAgXSksXG4gIGV4ZWN1dGU6IGwudHVwbGUoW1xuICAgIGp0Lm9yKFZlKSxcbiAgICBsLm9iamVjdCh7XG4gICAgICBub25jZTogTS5vcHRpb25hbCgpLFxuICAgICAgbWF4RmVlOiBNLm9wdGlvbmFsKCksXG4gICAgICB2ZXJzaW9uOiBNLm9wdGlvbmFsKClcbiAgICB9KS5vcHRpb25hbCgpXG4gIF0pLFxuICBzaWduTWVzc2FnZTogbC50dXBsZShbeG5dKVxufTtcbmwudHVwbGUoW1xuICBqdC5vcihWZSksXG4gIGwub2JqZWN0KHtcbiAgICBub25jZTogTS5vcHRpb25hbCgpLFxuICAgIG1heEZlZTogTS5vcHRpb25hbCgpLFxuICAgIHZlcnNpb246IE0ub3B0aW9uYWwoKVxuICB9KS5vcHRpb25hbCgpXG5dKS5vcihcbiAgbC50dXBsZShbXG4gICAganQub3IoVmUpLFxuICAgIGwuYXJyYXkobC5hbnkoKSkub3B0aW9uYWwoKSxcbiAgICBsLm9iamVjdCh7XG4gICAgICBub25jZTogTS5vcHRpb25hbCgpLFxuICAgICAgbWF4RmVlOiBNLm9wdGlvbmFsKCksXG4gICAgICB2ZXJzaW9uOiBNLm9wdGlvbmFsKClcbiAgICB9KS5vcHRpb25hbCgpXG4gIF0pXG4pO1xuY29uc3Qga24gPSBsLm9iamVjdCh7XG4gIGNvbnRyYWN0X2FkZHJlc3M6IGwuc3RyaW5nKCksXG4gIGVudHJ5X3BvaW50OiBsLnN0cmluZygpLFxuICBjYWxsZGF0YTogbC5hcnJheShNKS5vcHRpb25hbCgpXG59KS50cmFuc2Zvcm0oKHsgY29udHJhY3RfYWRkcmVzczogdCwgZW50cnlfcG9pbnQ6IGUsIGNhbGxkYXRhOiByIH0pID0+ICh7XG4gIGNvbnRyYWN0QWRkcmVzczogdCxcbiAgZW50cnlwb2ludDogZSxcbiAgY2FsbGRhdGE6IHIgfHwgW11cbn0pKSwgZW8gPSBsLmFycmF5KGtuKS5ub25lbXB0eSgpLCB0byA9IHtcbiAgWkVSTzogMCxcbiAgT05FOiAxXG59LCBybyA9IGwub2JqZWN0KHtcbiAgYWRkcmVzczogbC5zdHJpbmcoKSxcbiAgY2xhc3NfaGFzaDogbC5zdHJpbmcoKSxcbiAgc2FsdDogbC5zdHJpbmcoKSxcbiAgY2FsbGRhdGE6IGwuYXJyYXkobC5zdHJpbmcoKSksXG4gIHNpZ2RhdGE6IGwuYXJyYXkobC5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgLy92ZXJzaW9uOiB6LmxpdGVyYWwoWzAsIDFdKSxcbiAgdmVyc2lvbjogbC5uYXRpdmVFbnVtKHRvKVxuICAvLyBhbGxvdyBvbmx5IDAgfCAxLCB3b3JrYXJvdW5kIHNpbmNlIHpvZCBkb2Vzbid0IHN1cHBvcnQgbGl0ZXJhbHMgYXMgbnVtYmVyc1xufSksIG5vID0gbC5vYmplY3Qoe1xuICBjYWxsYmFja0RhdGE6IGwuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgYXBwcm92YWxSZXF1ZXN0czogbC5hcnJheShcbiAgICBsLm9iamVjdCh7XG4gICAgICB0b2tlbkFkZHJlc3M6IGwuc3RyaW5nKCksXG4gICAgICBhbW91bnQ6IGwuc3RyaW5nKCksXG4gICAgICBzcGVuZGVyOiBsLnN0cmluZygpXG4gICAgfSlcbiAgKSxcbiAgc2Vzc2lvblR5cGVkRGF0YTogeG5cbn0pLCBzbyA9IGwub2JqZWN0KHtcbiAgYWNjb3VudDogbC5zdHJpbmcoKS5hcnJheSgpLm9wdGlvbmFsKCksXG4gIGNoYWluSWQ6IGwuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgc2lnbmF0dXJlOiBsLnN0cmluZygpLmFycmF5KCkub3B0aW9uYWwoKSxcbiAgYXBwcm92YWxUcmFuc2FjdGlvbkhhc2g6IGwuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgZGVwbG95bWVudFBheWxvYWQ6IGwuYW55KCkub3B0aW9uYWwoKSxcbiAgYXBwcm92YWxSZXF1ZXN0c0NhbGxzOiBsLmFycmF5KFZlKS5vcHRpb25hbCgpLFxuICBlcnJvckNvZGU6IGwuZW51bShbXG4gICAgXCJVU0VSX1JFSkVDVEVEXCIsXG4gICAgXCJBQ0NPVU5UX05PVF9ERVBMT1lFRFwiLFxuICAgIFwiTk9UX0VOT1VHSF9CQUxBTkNFXCIsXG4gICAgXCJOT1RfRU5PVUdIX0JBTEFOQ0VfREVQTE9ZTUVOVFwiLFxuICAgIFwiR0VORVJJQ19FUlJPUlwiXG4gIF0pLm9wdGlvbmFsKClcbn0pLCBPID0gUHMuY3JlYXRlKHtcbiAgaXNTZXJ2ZXI6ICExLFxuICBhbGxvd091dHNpZGVPZlNlcnZlcjogITBcbn0pO1xubGV0ICR0ID0gVHIsIE10ID0gXCJcIiwgVG4gPSBcIlwiO1xuY29uc3QgRHQgPSAoe1xuICB3aWR0aDogdCA9IDc3NSxcbiAgaGVpZ2h0OiBlID0gMzg1LFxuICBvcmlnaW46IHIsXG4gIGxvY2F0aW9uOiBuLFxuICBhdExlZnRCb3R0b206IHMgPSAhMVxufSkgPT4ge1xuICBjb25zdCBhID0gd2luZG93Py5vdXRlcldpZHRoID8/IHdpbmRvdz8uaW5uZXJXaWR0aCA/PyB3aW5kb3c/LnNjcmVlbi53aWR0aCA/PyAwLCBpID0gd2luZG93Py5vdXRlckhlaWdodCA/PyB3aW5kb3c/LmlubmVySGVpZ2h0ID8/IHdpbmRvdz8uc2NyZWVuLmhlaWdodCA/PyAwLCBvID0gd2luZG93Py5zY3JlZW5MZWZ0ID8/IHdpbmRvdz8uc2NyZWVuWCA/PyAwLCBjID0gd2luZG93Py5zY3JlZW5Ub3AgPz8gd2luZG93Py5zY3JlZW5ZID8/IDAsIHUgPSBzID8gMCA6IG8gKyBhIC8gMiAtIHQgLyAyLCBkID0gcyA/IHdpbmRvdy5zY3JlZW4uYXZhaWxIZWlnaHQgKyAxMCA6IGMgKyBpIC8gMiAtIGUgLyAyO1xuICAkdCA9IHIgPz8gJHQsIE10ID0gbiA/PyBNdCwgVG4gPSBgd2lkdGg9JHt0fSxoZWlnaHQ9JHtlfSx0b3A9JHtkfSxsZWZ0PSR7dX0sdG9vbGJhcj1ubyxtZW51YmFyPW5vLHNjcm9sbGJhcnM9bm8sbG9jYXRpb249bm8sc3RhdHVzPW5vLHBvcHVwPTFgO1xufTtcbk8ucm91dGVyKHtcbiAgYXV0aG9yaXplOiBPLnByb2NlZHVyZS5vdXRwdXQobC5ib29sZWFuKCkpLm11dGF0aW9uKGFzeW5jICgpID0+ICEwKSxcbiAgY29ubmVjdDogTy5wcm9jZWR1cmUubXV0YXRpb24oYXN5bmMgKCkgPT4gXCJcIiksXG4gIGNvbm5lY3RXZWJ3YWxsZXQ6IE8ucHJvY2VkdXJlLmlucHV0KFxuICAgIGwub2JqZWN0KHtcbiAgICAgIHRoZW1lOiBsLmVudW0oW1wibGlnaHRcIiwgXCJkYXJrXCIsIFwiYXV0b1wiXSkub3B0aW9uYWwoKVxuICAgIH0pXG4gICkub3V0cHV0KFxuICAgIGwub2JqZWN0KHtcbiAgICAgIGFjY291bnQ6IGwuc3RyaW5nKCkuYXJyYXkoKS5vcHRpb25hbCgpLFxuICAgICAgY2hhaW5JZDogbC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgfSlcbiAgKS5tdXRhdGlvbihhc3luYyAoKSA9PiAoe30pKSxcbiAgY29ubmVjdFdlYndhbGxldFNTTzogTy5wcm9jZWR1cmUuaW5wdXQoXG4gICAgbC5vYmplY3QoeyB0b2tlbjogbC5zdHJpbmcoKSwgYXV0aG9yaXplZFBhcnR5SWQ6IGwuc3RyaW5nKCkub3B0aW9uYWwoKSB9KVxuICApLm91dHB1dChcbiAgICBsLm9iamVjdCh7XG4gICAgICBhY2NvdW50OiBsLnN0cmluZygpLmFycmF5KCkub3B0aW9uYWwoKSxcbiAgICAgIGNoYWluSWQ6IGwuc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgIH0pXG4gICkubXV0YXRpb24oYXN5bmMgKCkgPT4gKHt9KSksXG4gIGNvbm5lY3RBbmRTaWduU2Vzc2lvbjogTy5wcm9jZWR1cmUuaW5wdXQobm8pLm91dHB1dChzbykubXV0YXRpb24oYXN5bmMgKCkgPT4gKHt9KSksXG4gIGVuYWJsZTogTy5wcm9jZWR1cmUub3V0cHV0KGwuc3RyaW5nKCkpLm11dGF0aW9uKGFzeW5jICgpID0+IFwiXCIpLFxuICBleGVjdXRlOiBPLnByb2NlZHVyZS5pbnB1dChrdC5leGVjdXRlKS5vdXRwdXQobC5zdHJpbmcoKSkubXV0YXRpb24oYXN5bmMgKCkgPT4gXCJcIiksXG4gIHNpZ25NZXNzYWdlOiBPLnByb2NlZHVyZS5pbnB1dChrdC5zaWduTWVzc2FnZSkub3V0cHV0KGwuc3RyaW5nKCkuYXJyYXkoKSkubXV0YXRpb24oYXN5bmMgKCkgPT4gW10pLFxuICBnZXRMb2dpblN0YXR1czogTy5wcm9jZWR1cmUub3V0cHV0KFxuICAgIGwub2JqZWN0KHtcbiAgICAgIGlzTG9nZ2VkSW46IGwuYm9vbGVhbigpLFxuICAgICAgaGFzU2Vzc2lvbjogbC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgIGlzUHJlYXV0aG9yaXplZDogbC5ib29sZWFuKCkub3B0aW9uYWwoKVxuICAgIH0pXG4gICkubXV0YXRpb24oYXN5bmMgKCkgPT4gKHtcbiAgICBpc0xvZ2dlZEluOiAhMFxuICB9KSksXG4gIC8vIFJQQyBNZXNzYWdlc1xuICByZXF1ZXN0QWNjb3VudHM6IE8ucHJvY2VkdXJlLmlucHV0KGwub2JqZWN0KHsgc2lsZW50X21vZGU6IGwuYm9vbGVhbigpLm9wdGlvbmFsKCkgfSkpLm91dHB1dChsLnN0cmluZygpLmFycmF5KCkpLm11dGF0aW9uKGFzeW5jICgpID0+IFtdKSxcbiAgcmVxdWVzdENoYWluSWQ6IE8ucHJvY2VkdXJlLm91dHB1dChsLnN0cmluZygpKS5tdXRhdGlvbihhc3luYyAoKSA9PiBcIlwiKSxcbiAgc2lnblR5cGVkRGF0YTogTy5wcm9jZWR1cmUuaW5wdXQoa3Quc2lnbk1lc3NhZ2UpLm91dHB1dChsLnN0cmluZygpLmFycmF5KCkpLm11dGF0aW9uKGFzeW5jICgpID0+IFtdKSxcbiAgZ2V0UGVybWlzc2lvbnM6IE8ucHJvY2VkdXJlLm91dHB1dChsLmFycmF5KGwuZW51bShbQ3QuQUNDT1VOVFNdKSkpLm11dGF0aW9uKGFzeW5jICgpID0+IFtDdC5BQ0NPVU5UU10pLFxuICBhZGRJbnZva2VUcmFuc2FjdGlvbjogTy5wcm9jZWR1cmUuaW5wdXQoa24ub3IoZW8pKS5vdXRwdXQobC5zdHJpbmcoKSkubXV0YXRpb24oYXN5bmMgKHQpID0+IFwiXCIpLFxuICBhZGRTdGFya25ldENoYWluOiBPLnByb2NlZHVyZS5tdXRhdGlvbigodCkgPT4ge1xuICAgIHRocm93IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICB9KSxcbiAgc3dpdGNoU3RhcmtuZXRDaGFpbjogTy5wcm9jZWR1cmUubXV0YXRpb24oKHQpID0+IHtcbiAgICB0aHJvdyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfSksXG4gIHdhdGNoQXNzZXQ6IE8ucHJvY2VkdXJlLm11dGF0aW9uKCh0KSA9PiB7XG4gICAgdGhyb3cgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gIH0pLFxuICB1cGRhdGVNb2RhbDogTy5wcm9jZWR1cmUuc3Vic2NyaXB0aW9uKGFzeW5jICgpID0+IHtcbiAgfSksXG4gIGRlcGxveW1lbnREYXRhOiBPLnByb2NlZHVyZS5vdXRwdXQocm8pLm11dGF0aW9uKGFzeW5jICgpID0+ICh7XG4gICAgYWRkcmVzczogXCJcIixcbiAgICBjYWxsZGF0YTogW10sXG4gICAgdmVyc2lvbjogMCxcbiAgICBjbGFzc19oYXNoOiBcIlwiLFxuICAgIHNhbHQ6IFwiXCJcbiAgfSkpXG59KTtcbmNvbnN0IFR0ID0gKHtcbiAgaWZyYW1lOiB0XG59KSA9PiBtcyh7XG4gIGxpbmtzOiBbXG4gICAgbHMoe1xuICAgICAgZW5hYmxlZDogKGUpID0+IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIgJiYgdHlwZW9mIHdpbmRvdyA8IFwidVwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIgJiYgZS5kaXJlY3Rpb24gPT09IFwiZG93blwiICYmIGUucmVzdWx0IGluc3RhbmNlb2YgRXJyb3JcbiAgICB9KSxcbiAgICBYbih7XG4gICAgICBjb25kaXRpb24oZSkge1xuICAgICAgICBpZiAoIXQgJiYgZS50eXBlID09PSBcInN1YnNjcmlwdGlvblwiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwic3Vic2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCBhbiBpZnJhbWUgd2luZG93XCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gISF0O1xuICAgICAgfSxcbiAgICAgIHRydWU6IFJ0LndpbmRvd0xpbmsoe1xuICAgICAgICB3aW5kb3csXG4gICAgICAgIHBvc3RXaW5kb3c6IHQsXG4gICAgICAgIHBvc3RPcmlnaW46IFwiKlwiXG4gICAgICB9KSxcbiAgICAgIGZhbHNlOiBSdC5wb3B1cExpbmsoe1xuICAgICAgICBsaXN0ZW5XaW5kb3c6IHdpbmRvdyxcbiAgICAgICAgY3JlYXRlUG9wdXA6ICgpID0+IHtcbiAgICAgICAgICBsZXQgZSA9IG51bGw7XG4gICAgICAgICAgY29uc3QgciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgICAgaWYgKHIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCByLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgICAgICBlID0gd2luZG93Lm9wZW4oXG4gICAgICAgICAgICAgIGAkeyR0fSR7TXR9YCxcbiAgICAgICAgICAgICAgXCJwb3B1cFwiLFxuICAgICAgICAgICAgICBUblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSwgci5jbGljaygpLCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgZm9yICg7ICFlOyApXG4gICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChuKSA9PiBzZXRUaW1lb3V0KG4sIDEwMCkpO1xuICAgICAgICAgIH0pKCksICFlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IG9wZW4gcG9wdXBcIik7XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc3RPcmlnaW46IFwiKlwiXG4gICAgICB9KVxuICAgIH0pXG4gIF1cbn0pLCBHZSA9IFtdLCBhbyA9ICh0LCBlKSA9PiAoe1xuICAuLi50LFxuICBnZXRMb2dpblN0YXR1czogKCkgPT4gZS5nZXRMb2dpblN0YXR1cy5tdXRhdGUoKSxcbiAgY29ubmVjdFdlYndhbGxldDogKG4gPSB7fSkgPT4ge1xuICAgIGNvbnN0IHsgdGhlbWU6IHMgfSA9IG47XG4gICAgcmV0dXJuIGUuY29ubmVjdFdlYndhbGxldC5tdXRhdGUoe1xuICAgICAgdGhlbWU6IHNcbiAgICB9KTtcbiAgfSxcbiAgY29ubmVjdEFuZFNpZ25TZXNzaW9uOiAobikgPT4gZS5jb25uZWN0QW5kU2lnblNlc3Npb24ubXV0YXRlKG4pLFxuICBjb25uZWN0V2Vid2FsbGV0U1NPOiAobiwgcykgPT4gZS5jb25uZWN0V2Vid2FsbGV0U1NPLm11dGF0ZSh7IHRva2VuOiBuLCBhdXRob3JpemVkUGFydHlJZDogcyB9KSxcbiAgYXN5bmMgcmVxdWVzdChuKSB7XG4gICAgc3dpdGNoIChuLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzXCI6XG4gICAgICAgIHJldHVybiBlLnJlcXVlc3RBY2NvdW50cy5tdXRhdGUobi5wYXJhbXMpO1xuICAgICAgY2FzZSBcIndhbGxldF9zaWduVHlwZWREYXRhXCI6IHtcbiAgICAgICAgY29uc3QgcyA9IG4ucGFyYW1zLCBhID0gcz8ucHJpbWFyeVR5cGUgPT09IFwiU2Vzc2lvblwiICYmIHM/LmRvbWFpbi5uYW1lID09PSBcIlNlc3Npb25BY2NvdW50LnNlc3Npb25cIjtcbiAgICAgICAgRHQoe1xuICAgICAgICAgIHdpZHRoOiBXbixcbiAgICAgICAgICBoZWlnaHQ6IHFuLFxuICAgICAgICAgIGxvY2F0aW9uOiBhID8gXCIvc2lnblNlc3Npb25LZXlzXCIgOiBcIi9zaWduTWVzc2FnZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpID0gQXJyYXkuaXNBcnJheShuLnBhcmFtcykgPyBuLnBhcmFtcyA6IFtuLnBhcmFtc107XG4gICAgICAgIHJldHVybiBlLnNpZ25UeXBlZERhdGEubXV0YXRlKGkpO1xuICAgICAgfVxuICAgICAgY2FzZSBcIndhbGxldF9nZXRQZXJtaXNzaW9uc1wiOlxuICAgICAgICByZXR1cm4gZS5nZXRQZXJtaXNzaW9ucy5tdXRhdGUoKTtcbiAgICAgIGNhc2UgXCJ3YWxsZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIjoge1xuICAgICAgICBjb25zdCBzID0gbi5wYXJhbXMuY2FsbHM7XG4gICAgICAgIHJldHVybiBEdCh7XG4gICAgICAgICAgd2lkdGg6IFpuLFxuICAgICAgICAgIGhlaWdodDogVW4sXG4gICAgICAgICAgbG9jYXRpb246IFwiL3Jldmlld1wiXG4gICAgICAgIH0pLCB7IHRyYW5zYWN0aW9uX2hhc2g6IGF3YWl0IGUuYWRkSW52b2tlVHJhbnNhY3Rpb24ubXV0YXRlKHMpIH07XG4gICAgICB9XG4gICAgICBjYXNlIFwid2FsbGV0X3JlcXVlc3RDaGFpbklkXCI6XG4gICAgICAgIHJldHVybiBhd2FpdCBlLnJlcXVlc3RDaGFpbklkLm11dGF0ZSgpO1xuICAgICAgY2FzZSBcIndhbGxldF9hZGRTdGFya25ldENoYWluXCI6XG4gICAgICAgIHJldHVybiBlLmFkZFN0YXJrbmV0Q2hhaW4ubXV0YXRlKG4ucGFyYW1zKTtcbiAgICAgIGNhc2UgXCJ3YWxsZXRfc3dpdGNoU3RhcmtuZXRDaGFpblwiOlxuICAgICAgICByZXR1cm4gZS5zd2l0Y2hTdGFya25ldENoYWluLm11dGF0ZShuLnBhcmFtcyk7XG4gICAgICBjYXNlIFwid2FsbGV0X3dhdGNoQXNzZXRcIjpcbiAgICAgICAgcmV0dXJuIGUud2F0Y2hBc3NldC5tdXRhdGUoKTtcbiAgICAgIGNhc2UgXCJ3YWxsZXRfZGVwbG95bWVudERhdGFcIjpcbiAgICAgICAgcmV0dXJuIGUuZGVwbG95bWVudERhdGEubXV0YXRlKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICB9LFxuICBvbjogKG4sIHMpID0+IHtcbiAgICBpZiAobiA9PT0gXCJhY2NvdW50c0NoYW5nZWRcIilcbiAgICAgIEdlLnB1c2goe1xuICAgICAgICB0eXBlOiBuLFxuICAgICAgICBoYW5kbGVyOiBzXG4gICAgICB9KTtcbiAgICBlbHNlIGlmIChuID09PSBcIm5ldHdvcmtDaGFuZ2VkXCIpXG4gICAgICBHZS5wdXNoKHtcbiAgICAgICAgdHlwZTogbixcbiAgICAgICAgaGFuZGxlcjogc1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtud293biBldmVudDogJHtufWApO1xuICB9LFxuICBvZmY6IChuLCBzKSA9PiB7XG4gICAgaWYgKG4gIT09IFwiYWNjb3VudHNDaGFuZ2VkXCIgJiYgbiAhPT0gXCJuZXR3b3JrQ2hhbmdlZFwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtud293biBldmVudDogJHtufWApO1xuICAgIGNvbnN0IGEgPSBHZS5maW5kSW5kZXgoXG4gICAgICAoaSkgPT4gaS50eXBlID09PSBuICYmIGkuaGFuZGxlciA9PT0gc1xuICAgICk7XG4gICAgYSA+PSAwICYmIEdlLnNwbGljZShhLCAxKTtcbiAgfVxufSksIGlvID0gKHQpID0+IHtcbiAgdC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIHQuc3R5bGUuYm9yZGVyUmFkaXVzID0gXCI0MHB4XCIsIHQuc3R5bGUuaW5zZXQgPSBcIjBcIiwgdC5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIiwgdC5zdHlsZS50b3AgPSBcIjUwJVwiLCB0LnN0eWxlLmxlZnQgPSBcIjUwJVwiLCB0LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKC01MCUsIC01MCUpXCIsIHQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJ0cmFuc3BhcmVudFwiLCB0LnN0eWxlLnpJbmRleCA9IFwiOTk5OTk5XCIsIHQuc3R5bGUuaGVpZ2h0ID0gYCR7Qm59cHhgLCB0LnN0eWxlLndpZHRoID0gYCR7em59cHhgO1xufSwgb28gPSAodCwgZSkgPT4ge1xuICB0LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIGUuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbn0sIGNvID0gKHQsIGUpID0+IHtcbiAgdC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xufSwgdW8gPSAodCwgZSwgcikgPT4ge1xuICB0LnN0eWxlLndpZHRoID0gYCR7ZX1weGAsIHQuc3R5bGUuaGVpZ2h0ID0gYCR7cn1weGA7XG59LCBiciA9IFwiYXJnZW50LXdlYndhbGxldC1pZnJhbWVcIiwgbG8gPSBhc3luYyAodCwgZSkgPT4ge1xuICBjb25zdCByID0gXCJhcmdlbnQtd2Vid2FsbGV0LWJhY2tkcm9wXCIsIG4gPSBuZXcgVVJMKHQpO1xuICBuLnBhdGhuYW1lID0gXCIvaWZyYW1lcy9jb21tc1wiLCB0ID0gbi50b1N0cmluZygpO1xuICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgcy5zcmMgPSB0LCBzLmxvYWRpbmcgPSBcImVhZ2VyXCIsIHMuc2FuZGJveC5hZGQoXG4gICAgXCJhbGxvdy1zY3JpcHRzXCIsXG4gICAgXCJhbGxvdy1zYW1lLW9yaWdpblwiLFxuICAgIFwiYWxsb3ctZm9ybXNcIixcbiAgICBcImFsbG93LXRvcC1uYXZpZ2F0aW9uXCIsXG4gICAgXCJhbGxvdy1wb3B1cHNcIlxuICApLCBzLmFsbG93ID0gXCJjbGlwYm9hcmQtd3JpdGVcIiwgcy5pZCA9IGJyLCBzLnNldEF0dHJpYnV0ZShcImFsbG93dHJhbnNwYXJlbmN5XCIsIFwidHJ1ZVwiKSwgcy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc3BhcmVudFwiLCBcInRydWVcIiksIGlvKHMpLCBzLnN0eWxlLmRpc3BsYXkgPSBlID8gXCJibG9ja1wiIDogXCJub25lXCI7XG4gIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBhLmlkID0gciwgYS5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIiwgYS5zdHlsZS5pbnNldCA9IFwiMFwiLCBhLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicmdiYSgwLDAsMCwwLjUpXCIsIGEuc3R5bGUuekluZGV4ID0gXCI5OTk5OThcIiwgYS5zdHlsZS53aWR0aCA9IFwiMTAwZHZ3XCIsIGEuc3R5bGUuaGVpZ2h0ID0gXCIxMDBkdmhcIiwgYS5zdHlsZS5iYWNrZHJvcEZpbHRlciA9IFwiYmx1cig0cHgpXCI7XG4gIGNvbnN0IGkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChicik7XG4gIHJldHVybiBpICYmIChpLnJlbW92ZSgpLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyKT8ucmVtb3ZlKCkpLCB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzKSwgYXdhaXQgbmV3IFByb21pc2UoKG8sIGMpID0+IHtcbiAgICBjb25zdCB1ID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IGMobmV3IEVycm9yKFwiVGltZW91dCB3aGlsZSBsb2FkaW5nIGFuIGlmcmFtZVwiKSksXG4gICAgICAyZTRcbiAgICApO1xuICAgIHMuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHUpLCBvKCk7XG4gICAgfSk7XG4gIH0pLCB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKSwgeyBpZnJhbWU6IHMsIGJhY2tkcm9wOiBhIH07XG59LCBFdCA9IGFzeW5jICh0LCBlLCByKSA9PiB7XG4gIGNvbnN0IG4gPSB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gIGlmICghbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3aW5kb3cgaXMgbm90IGRlZmluZWRcIik7XG4gIGNvbnN0IHMgPSBhbyhcbiAgICB7XG4gICAgICBob3N0OiBuLmxvY2F0aW9uLm9yaWdpbixcbiAgICAgIGlkOiBcImFyZ2VudFdlYldhbGxldFwiLFxuICAgICAgaWNvbjogXCJodHRwczovL3d3dy5hcmdlbnQueHl6L2Zhdmljb24uaWNvXCIsXG4gICAgICBuYW1lOiBcIkFyZ2VudCBXZWIgV2FsbGV0XCIsXG4gICAgICB2ZXJzaW9uOiBcIjEuMC4wXCJcbiAgICB9LFxuICAgIGVcbiAgKTtcbiAgaWYgKHIpIHtcbiAgICBjb25zdCB7IGlmcmFtZTogYSwgYmFja2Ryb3A6IGkgfSA9IHI7XG4gICAgZS51cGRhdGVNb2RhbC5zdWJzY3JpYmUodm9pZCAwLCB7XG4gICAgICBvbkRhdGEobykge1xuICAgICAgICBzd2l0Y2ggKG8uYWN0aW9uKSB7XG4gICAgICAgICAgY2FzZSBcInNob3dcIjpcbiAgICAgICAgICAgIG9vKGEsIGkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImhpZGVcIjpcbiAgICAgICAgICAgIGNvKGEsIGkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInVwZGF0ZVNpemVcIjpcbiAgICAgICAgICAgIHVvKGEsIG8ud2lkdGgsIG8uaGVpZ2h0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHM7XG59LCB3ciA9IFwiYWxsb3dlZC1kYXBwc1wiLCBmbyA9IGFzeW5jICh0KSA9PiB7XG4gIGNvbnN0IGUgPSB0ID09PSB4ci5OZXR3b3JrTmFtZS5TTl9NQUlOID8gam4gOiBJbjtcbiAgdHJ5IHtcbiAgICBjb25zdCBuID0gYXdhaXQgKGF3YWl0IGNhY2hlcy5vcGVuKHdyKSkubWF0Y2goZSk7XG4gICAgaWYgKG4pIHtcbiAgICAgIGNvbnN0IHUgPSBwYXJzZUludChcbiAgICAgICAgbi5oZWFkZXJzLmdldChcIlgtQ2FjaGUtVGltZXN0YW1wXCIpID8/IFwiMFwiLFxuICAgICAgICAxMFxuICAgICAgKTtcbiAgICAgIGlmICgoKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSB1KSAvICgxZTMgKiA2MCAqIDYwKSA8IDI0KVxuICAgICAgICByZXR1cm4gbi5qc29uKCk7XG4gICAgfVxuICAgIGNvbnN0IHMgPSBhd2FpdCBmZXRjaChlKSwgYSA9IG5ldyBIZWFkZXJzKHMuaGVhZGVycyk7XG4gICAgYS5zZXQoXCJYLUNhY2hlLVRpbWVzdGFtcFwiLCAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKS50b1N0cmluZygpKTtcbiAgICBjb25zdCBpID0gYXdhaXQgcy5qc29uKCksIG8gPSBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoaSksIHtcbiAgICAgIHN0YXR1czogcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiBzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBhXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IChhd2FpdCBjYWNoZXMub3Blbih3cikpLnB1dChlLCBvKSwgaTtcbiAgfSBjYXRjaCAocikge1xuICAgIHRocm93IG5ldyBFcnJvcihyKTtcbiAgfVxufSwgcG8gPSBhc3luYyAodCkgPT4gbmV3IFByb21pc2UoKGUpID0+IHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBlKCExKTtcbiAgdHJ5IHtcbiAgICBuYXZpZ2F0b3Iud2Via2l0VGVtcG9yYXJ5U3RvcmFnZS5xdWVyeVVzYWdlQW5kUXVvdGEoXG4gICAgICAobiwgcykgPT4ge1xuICAgICAgICBlKFxuICAgICAgICAgIE1hdGgucm91bmQocyAvICgxMDI0ICogMTAyNCkpIDwgTWF0aC5yb3VuZChcbiAgICAgICAgICAgIChwZXJmb3JtYW5jZT8ubWVtb3J5Py5qc0hlYXBTaXplTGltaXQgPz8gMTA3Mzc0MTgyNCkgLyAoMTAyNCAqIDEwMjQpXG4gICAgICAgICAgKSAqIDJcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiBlKCExKVxuICAgICk7XG4gIH0gY2F0Y2gge1xuICAgIGUoITEpO1xuICB9XG59KSwgaG8gPSBhc3luYyAodCkgPT4ge1xuICBjb25zdCB7IHVzZXJBZ2VudDogZSB9ID0gbmF2aWdhdG9yLCByID0gISEobmF2aWdhdG9yLnZlbmRvciAmJiBuYXZpZ2F0b3IudmVuZG9yLmluZGV4T2YoXCJHb29nbGVcIikgPT09IDAgJiYgbmF2aWdhdG9yLmJyYXZlID09PSB2b2lkIDAgJiYgIWUubWF0Y2goL0VkZy8pICYmICFlLm1hdGNoKC9PUFIvKSksIG4gPSBhd2FpdCBwbyhyKTtcbiAgaWYgKCFyIHx8IG4pIHtcbiAgICBjb25zdCBpID0gVHQoe30pO1xuICAgIHJldHVybiBhd2FpdCBFdChcbiAgICAgIHQsXG4gICAgICBpLFxuICAgICAgdm9pZCAwXG4gICAgKTtcbiAgfVxuICBjb25zdCBzID0gRG4odCksIHsgYWxsb3dlZERhcHBzOiBhIH0gPSBhd2FpdCBmbyhzKTtcbiAgaWYgKGEuaW5jbHVkZXMod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKSkge1xuICAgIGNvbnN0IGkgPSBcImFyZ2VudC13ZWJ3YWxsZXQtYmFja2Ryb3BcIiwgbyA9IFwiYXJnZW50LXdlYndhbGxldC1pZnJhbWVcIiwgYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGkpLCB1ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobyk7XG4gICAgdSAmJiB1ICYmIGMgJiYgKHUucmVtb3ZlKCksIGMucmVtb3ZlKCkpO1xuICAgIGNvbnN0IHsgaWZyYW1lOiBkLCBiYWNrZHJvcDogaCB9ID0gYXdhaXQgbG8odCwgITEpLCB5ID0gVHQoe1xuICAgICAgaWZyYW1lOiBkLmNvbnRlbnRXaW5kb3cgPz8gdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IEV0KFxuICAgICAgdCxcbiAgICAgIHksXG4gICAgICB7IGlmcmFtZTogZCwgYmFja2Ryb3A6IGggfVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaSA9IFR0KHt9KTtcbiAgICByZXR1cm4gYXdhaXQgRXQoXG4gICAgICB0LFxuICAgICAgaSxcbiAgICAgIHZvaWQgMFxuICAgICk7XG4gIH1cbn0sIEVuID0gXCJ3ZWJ3YWxsZXRfbG9nb3V0XCI7XG5sZXQgRCA9IG51bGwsIGFlID0gbnVsbDtcbmNsYXNzIGJvIGV4dGVuZHMgQW4ge1xuICBjb25zdHJ1Y3RvcihyID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIFRlKHRoaXMsIFwiX3dhbGxldFwiLCBudWxsKTtcbiAgICBUZSh0aGlzLCBcIl9vcHRpb25zXCIpO1xuICAgIHRoaXMuX29wdGlvbnMgPSByO1xuICB9XG4gIGF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgYXN5bmMgcmVhZHkoKSB7XG4gICAgaWYgKHRoaXMuX3dhbGxldCB8fCBhd2FpdCB0aGlzLmVuc3VyZVdhbGxldCgpLCB0aGlzLl93YWxsZXQpXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuX3dhbGxldC5yZXF1ZXN0KHtcbiAgICAgICAgICB0eXBlOiBcIndhbGxldF9nZXRQZXJtaXNzaW9uc1wiXG4gICAgICAgIH0pKS5pbmNsdWRlcyhDdC5BQ0NPVU5UUyk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLl93YWxsZXQgPSBudWxsLCBhZSA9IG51bGwsICExO1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0ID0gRCwgdGhpcy5fd2FsbGV0Py5pZCB8fCBcImFyZ2VudFdlYldhbGxldFwiO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQgPSBELCB0aGlzLl93YWxsZXQ/Lm5hbWUgfHwgXCJBcmdlbnQgV2ViIFdhbGxldFwiO1xuICB9XG4gIGdldCBpY29uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaWdodDogcnIsXG4gICAgICBkYXJrOiByclxuICAgIH07XG4gIH1cbiAgZ2V0IHdhbGxldCgpIHtcbiAgICBpZiAoIXRoaXMuX3dhbGxldClcbiAgICAgIHRocm93IG5ldyBzZSgpO1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQ7XG4gIH1cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiBcIkVtYWlsXCI7XG4gIH1cbiAgZ2V0IHN1YnRpdGxlKCkge1xuICAgIHJldHVybiBcIlBvd2VyZWQgYnkgQXJnZW50XCI7XG4gIH1cbiAgYXN5bmMgY29ubmVjdEFuZFNpZ25TZXNzaW9uKHtcbiAgICBjYWxsYmFja0RhdGE6IHIsXG4gICAgYXBwcm92YWxSZXF1ZXN0czogbixcbiAgICBzZXNzaW9uVHlwZWREYXRhOiBzXG4gIH0pIHtcbiAgICBpZiAodGhpcy5fd2FsbGV0IHx8IGF3YWl0IHRoaXMuZW5zdXJlV2FsbGV0KCksICF0aGlzLl93YWxsZXQpXG4gICAgICB0aHJvdyBuZXcgaHQoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3dhbGxldC5jb25uZWN0QW5kU2lnblNlc3Npb24oe1xuICAgICAgICBjYWxsYmFja0RhdGE6IHIsXG4gICAgICAgIGFwcHJvdmFsUmVxdWVzdHM6IG4sXG4gICAgICAgIHNlc3Npb25UeXBlZERhdGE6IHMsXG4gICAgICAgIHRoZW1lOiB0aGlzLl9vcHRpb25zLnRoZW1lXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChhKSB7XG4gICAgICBpZiAoYSBpbnN0YW5jZW9mIEVycm9yICYmIChhLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiVFJQQ0NsaWVudEVycm9yXCIgfHwgYS5uYW1lID09PSBcIlRSUENDbGllbnRFcnJvclwiKSkge1xuICAgICAgICBjb25zdCBpID0gYSwgbyA9IGkuc2hhcGUuZGF0YS53ZWJ3YWxsZXRFcnJvck1lc3NhZ2UgfHwgaS5tZXNzYWdlLCBjID0gaS5zaGFwZS5kYXRhLndlYndhbGxldEVycm9yQ29kZSB8fCBpLnNoYXBlLm1lc3NhZ2U7XG4gICAgICAgIHRocm93IG5ldyBMbihvLCBjKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihhIGluc3RhbmNlb2YgRXJyb3IgPyBhLm1lc3NhZ2UgOiBTdHJpbmcoYSkpO1xuICAgIH1cbiAgfVxuICBhc3luYyBjb25uZWN0KHIgPSB7fSkge1xuICAgIGlmICh0aGlzLl93YWxsZXQgfHwgYXdhaXQgdGhpcy5lbnN1cmVXYWxsZXQoKSwgIXRoaXMuX3dhbGxldClcbiAgICAgIHRocm93IG5ldyBodCgpO1xuICAgIHRyeSB7XG4gICAgICBsZXQgbiwgcztcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNzb1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IGkgPSBhd2FpdCB0aGlzLl93YWxsZXQuY29ubmVjdFdlYndhbGxldFNTTyhcbiAgICAgICAgICB0aGlzLl9vcHRpb25zLnNzb1Rva2VuLFxuICAgICAgICAgIHRoaXMuX29wdGlvbnMuYXV0aG9yaXplZFBhcnR5SWRcbiAgICAgICAgKTtcbiAgICAgICAgbiA9IGkuYWNjb3VudCwgcyA9IGkuY2hhaW5JZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGkgPSBhd2FpdCB0aGlzLl93YWxsZXQuY29ubmVjdFdlYndhbGxldCh7XG4gICAgICAgICAgdGhlbWU6IHRoaXMuX29wdGlvbnMudGhlbWVcbiAgICAgICAgfSk7XG4gICAgICAgIG4gPSBpLmFjY291bnQsIHMgPSBpLmNoYWluSWQ7XG4gICAgICB9XG4gICAgICBpZiAoIW4gfHwgIXMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIGNvbnN0IGEgPSB0cihzKTtcbiAgICAgIHJldHVybiBhZSA9IG5bMF0sIHtcbiAgICAgICAgYWNjb3VudDogblswXSxcbiAgICAgICAgY2hhaW5JZDogQmlnSW50KGEpXG4gICAgICB9O1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IGVyKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlcXVlc3Qocikge1xuICAgIGlmICh0aGlzLl93YWxsZXQgfHwgYXdhaXQgdGhpcy5lbnN1cmVXYWxsZXQoKSwgIXRoaXMuX3dhbGxldClcbiAgICAgIHRocm93IG5ldyBzZSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fd2FsbGV0LnJlcXVlc3Qocik7XG4gICAgfSBjYXRjaCAobikge1xuICAgICAgaWYgKG4gaW5zdGFuY2VvZiBFcnJvciAmJiAobi5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlRSUENDbGllbnRFcnJvclwiIHx8IG4ubmFtZSA9PT0gXCJUUlBDQ2xpZW50RXJyb3JcIikpIHtcbiAgICAgICAgY29uc3QgcyA9IG4sIGEgPSBzLnNoYXBlLmRhdGEud2Vid2FsbGV0RXJyb3JNZXNzYWdlIHx8IHMubWVzc2FnZSwgaSA9IHMuc2hhcGUuZGF0YS53ZWJ3YWxsZXRFcnJvckNvZGUgfHwgcy5zaGFwZS5tZXNzYWdlO1xuICAgICAgICB0aHJvdyBpID09PSBcIlVTRVJfTE9HR0VEX09VVFwiICYmIChEID0gbnVsbCwgYWUgPSBudWxsLCB0aGlzLl93YWxsZXQgPSBudWxsLCBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFbikpKSwgbmV3ICRuKGEsIGkpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IGVyKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKCF0aGlzLmF2YWlsYWJsZSgpICYmICF0aGlzLl93YWxsZXQpXG4gICAgICB0aHJvdyBuZXcgaHQoKTtcbiAgICBEID0gbnVsbCwgYWUgPSBudWxsLCB0aGlzLl93YWxsZXQgPSBELCBObigpO1xuICB9XG4gIGFzeW5jIGFjY291bnQocikge1xuICAgIGlmICh0aGlzLl93YWxsZXQgPSBELCAhdGhpcy5fd2FsbGV0KVxuICAgICAgdGhyb3cgbmV3IHNlKCk7XG4gICAgaWYgKCFhZSlcbiAgICAgIHRocm93IG5ldyBzZSgpO1xuICAgIHJldHVybiBuZXcgUG4ociwgdGhpcy5fd2FsbGV0LCB2b2lkIDAsIGFlKTtcbiAgfVxuICBhc3luYyBjaGFpbklkKCkge1xuICAgIGlmICghdGhpcy5fd2FsbGV0KVxuICAgICAgdGhyb3cgbmV3IHNlKCk7XG4gICAgY29uc3QgciA9IGF3YWl0IHRoaXMuX3dhbGxldC5yZXF1ZXN0KHtcbiAgICAgIHR5cGU6IFwid2FsbGV0X3JlcXVlc3RDaGFpbklkXCJcbiAgICB9KSwgbiA9IHRyKHIpO1xuICAgIHJldHVybiBCaWdJbnQobik7XG4gIH1cbiAgYXN5bmMgaW5pdEV2ZW50TGlzdGVuZXIocikge1xuICAgIGlmICh0aGlzLl93YWxsZXQgPSBELCAhdGhpcy5fd2FsbGV0KVxuICAgICAgdGhyb3cgbmV3IHNlKCk7XG4gICAgdGhpcy5fd2FsbGV0Lm9uKFwiYWNjb3VudHNDaGFuZ2VkXCIsIHIpO1xuICB9XG4gIGFzeW5jIHJlbW92ZUV2ZW50TGlzdGVuZXIocikge1xuICAgIGlmICh0aGlzLl93YWxsZXQgPSBELCAhdGhpcy5fd2FsbGV0KVxuICAgICAgdGhyb3cgbmV3IHNlKCk7XG4gICAgdGhpcy5fd2FsbGV0Lm9mZihcImFjY291bnRzQ2hhbmdlZFwiLCByKSwgRCA9IG51bGwsIGFlID0gbnVsbCwgdGhpcy5fd2FsbGV0ID0gbnVsbDtcbiAgfVxuICBhc3luYyBlbnN1cmVXYWxsZXQoKSB7XG4gICAgY29uc3QgciA9IHRoaXMuX29wdGlvbnMudXJsIHx8IFRyO1xuICAgIER0KHtcbiAgICAgIG9yaWdpbjogcixcbiAgICAgIGxvY2F0aW9uOiBcIi9pbnRlcnN0aXRpYWxMb2dpblwiXG4gICAgfSksIEQgPSBhd2FpdCBobyhyKSA/PyBudWxsLCB0aGlzLl93YWxsZXQgPSBEO1xuICB9XG59XG5jb25zdCB3byA9ICh0KSA9PiB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoRW4sICgpID0+IHtcbiAgICB0KCk7XG4gIH0pO1xufTtcbmV4cG9ydCB7XG4gIExuIGFzIEMsXG4gIFRyIGFzIEQsXG4gIGJvIGFzIFcsXG4gIEVuIGFzIGEsXG4gICRuIGFzIGIsXG4gIHdvIGFzIGhcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-8edbd361.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-9bb48f8a.js":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-9bb48f8a.js ***!
  \***************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ l),\n/* harmony export */   I: () => (/* binding */ T)\n/* harmony export */ });\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! starknet */ \"(ssr)/./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lastConnected-e9351912.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/lastConnected-e9351912.js\");\nvar y = Object.defineProperty;\nvar O = (A, D, M) => D in A ? y(A, D, { enumerable: !0, configurable: !0, writable: !0, value: M }) : A[D] = M;\nvar i = (A, D, M) => (O(A, typeof D != \"symbol\" ? D + \"\" : D, M), M);\n\n\nconst l = \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iYmxhY2siLz4KPHBhdGggZD0iTTE4LjQwMTggNy41NTU1NkgxMy41OTgyQzEzLjQzNzcgNy41NTU1NiAxMy4zMDkxIDcuNjg3NDcgMTMuMzA1NiA3Ljg1MTQzQzEzLjIwODUgMTIuNDYwMyAxMC44NDg0IDE2LjgzNDcgNi43ODYwOCAxOS45MzMxQzYuNjU3MTEgMjAuMDMxNCA2LjYyNzczIDIwLjIxNjIgNi43MjIwMiAyMC4zNDkzTDkuNTMyNTMgMjQuMzE5NkM5LjYyODE1IDI0LjQ1NDggOS44MTQ0NCAyNC40ODUzIDkuOTQ1NTggMjQuMzg2QzEyLjQ4NTYgMjIuNDYxMyAxNC41Mjg3IDIwLjEzOTUgMTYgMTcuNTY2QzE3LjQ3MTMgMjAuMTM5NSAxOS41MTQ1IDIyLjQ2MTMgMjIuMDU0NSAyNC4zODZDMjIuMTg1NiAyNC40ODUzIDIyLjM3MTkgMjQuNDU0OCAyMi40Njc2IDI0LjMxOTZMMjUuMjc4MSAyMC4zNDkzQzI1LjM3MjMgMjAuMjE2MiAyNS4zNDI5IDIwLjAzMTQgMjUuMjE0IDE5LjkzMzFDMjEuMTUxNiAxNi44MzQ3IDE4Ljc5MTUgMTIuNDYwMyAxOC42OTQ2IDcuODUxNDNDMTguNjkxMSA3LjY4NzQ3IDE4LjU2MjMgNy41NTU1NiAxOC40MDE4IDcuNTU1NTZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjQuNzIzNiAxMC40OTJMMjQuMjIzMSA4LjkyNDM5QzI0LjEyMTMgOC42MDYxNCAyMy44NzM0IDguMzU4MjQgMjMuNTU3NyA4LjI2MDIzTDIyLjAwMzkgNy43NzU5NUMyMS43ODk1IDcuNzA5MDYgMjEuNzg3MyA3LjQwMTc3IDIyLjAwMTEgNy4zMzIwMUwyMy41NDY5IDYuODI0NjZDMjMuODYwOSA2LjcyMTQ2IDI0LjEwNiA2LjQ2OTUyIDI0LjIwMjcgNi4xNTAxMUwyNC42Nzk4IDQuNTc1MDJDMjQuNzQ1OCA0LjM1NzA5IDI1LjA0ODkgNC4zNTQ3NyAyNS4xMTgzIDQuNTcxNTZMMjUuNjE4OCA2LjEzOTE1QzI1LjcyMDYgNi40NTc0IDI1Ljk2ODYgNi43MDUzMSAyNi4yODQyIDYuODAzOUwyNy44MzggNy4yODc2MUMyOC4wNTI0IDcuMzU0NSAyOC4wNTQ3IDcuNjYxNzkgMjcuODQwOCA3LjczMjEzTDI2LjI5NSA4LjIzOTQ4QzI1Ljk4MTEgOC4zNDIxIDI1LjczNiA4LjU5NDA0IDI1LjYzOTMgOC45MTQwMkwyNS4xNjIxIDEwLjQ4ODVDMjUuMDk2MSAxMC43MDY1IDI0Ljc5MyAxMC43MDg4IDI0LjcyMzYgMTAuNDkyWiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg==\", E = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0iYmxhY2siPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+\", U = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0id2hpdGUiPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+Cg==\", L = {\n  argentX: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA2NS4xOTUwOCA1Ny43MzU2MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNjUuMTk1MDggNTcuNzM1NjI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRkY4NzVCO30KPC9zdHlsZT4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTQwLjk4NTkyLDBIMjQuMjA4ODhjLTAuNTYsMC0xLjAxMDAxLDAuNDUxMDItMS4wMjE5NywxLjAxMjAyCgljLTAuMzM4OTksMTUuNzU1LTguNTgyMDMsMzAuNzA4OTgtMjIuNzcwMDIsNDEuMzAwOTljLTAuNDUwMDEsMC4zMzcwMS0wLjU1Mjk4LDAuOTY3OTktMC4yMjQsMS40MjNsOS44MTU5OCwxMy41NzMKCWMwLjMzNDA1LDAuNDYyMDEsMC45ODUwNSwwLjU2NTk4LDEuNDQyOTksMC4yMjY5OWM4Ljg3MTAzLTYuNTc5MDEsMTYuMDA3MDItMTQuNTE3LDIxLjE0NjA2LTIzLjMxNQoJYzUuMTM4LDguNzk4LDEyLjI3Mzk5LDE2LjczNTk5LDIxLjE0NiwyMy4zMTVjMC40NTY5NywwLjMzODk5LDEuMTA3OTcsMC4yMzUwMiwxLjQ0MTk2LTAuMjI2OTlsOS44MTYwNC0xMy41NzMKCWMwLjMyODk4LTAuNDU1MDIsMC4yMjY5OS0xLjA4Ni0wLjIyNC0xLjQyM0M1MC41ODk4NiwzMS43MjEwMSw0Mi4zNDY4OCwxNi43NjcwMyw0Mi4wMDc4OSwxLjAxMjAyCglDNDEuOTk1ODcsMC40NTEwMiw0MS41NDY4OSwwLDQwLjk4NTkyLDAiLz4KPC9zdmc+Cg==\",\n  braavos: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAwIiBoZWlnaHQ9IjUwMCIgdmlld0JveD0iMCAwIDUwMCA1MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0zMjMuNDQgNDEuMzg4NkMzMjQuMTk4IDQyLjY3MjggMzIzLjE5NSA0NC4yNjAzIDMyMS43MDQgNDQuMjYwM0MyOTEuNTEgNDQuMjYwMyAyNjYuOTY1IDY4LjE2NTYgMjY2LjM4OSA5Ny44NzFDMjU2LjA1IDk1Ljk0MDcgMjQ1LjMzNyA5NS43OTU2IDIzNC43NTQgOTcuNTc4N0MyMzQuMDIzIDY4LjAwOSAyMDkuNTQgNDQuMjYwMyAxNzkuNDQ1IDQ0LjI2MDNDMTc3Ljk1MyA0NC4yNjAzIDE3Ni45NDkgNDIuNjcxNiAxNzcuNzA3IDQxLjM4NjVDMTkyLjMyMyAxNi42MzMgMjE5LjQ4MyAwIDI1MC41NzMgMEMyODEuNjY0IDAgMzA4LjgyNCAxNi42MzM5IDMyMy40NCA0MS4zODg2WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik00MTguNzU2IDIyNi44OTRDNDI2LjM3IDIyOS4yIDQzMy41ODEgMjIyLjUxNyA0MzEuMDM2IDIxNC45NzlDNDA0LjUwNyAxMzYuNDAxIDMxNi41MzUgMTA0LjM1OCAyNTAuMTU5IDEwNC4zNThDMTgzLjY3NCAxMDQuMzU4IDkzLjczOTEgMTM3LjQxOCA2OS4zMDUxIDIxNS4zMzFDNjYuOTU3NCAyMjIuODE4IDc0LjE0NjUgMjI5LjI3NSA4MS42NDc5IDIyNi45NzdMMjQ0LjI1IDE3Ny4xNTFDMjQ3LjU2OSAxNzYuMTM0IDI1MS4xMTYgMTc2LjEyOCAyNTQuNDM5IDE3Ny4xMzVMNDE4Ljc1NiAyMjYuODk0WiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik02OS43MTY1IDIzOS40MjZMMjQ0LjM3IDE4Ni40NTZDMjQ3LjY2OSAxODUuNDU2IDI1MS4xOTEgMTg1LjQ1MyAyNTQuNDkyIDE4Ni40NDhMNDMwLjIzMiAyMzkuNDUyQzQ0NC43NiAyNDMuODMzIDQ1NC43MDEgMjU3LjIxNiA0NTQuNzAxIDI3Mi4zOVY0MzAuNDgxQzQ1NC4wMjggNDY5LjA3IDQxOS4zNjIgNTAwIDM4MC43ODYgNTAwSDMxNi43MTJDMzEwLjM3OSA1MDAgMzA1LjI1IDQ5NC44NzcgMzA1LjI1IDQ4OC41NDNWNDMzLjExNUMzMDUuMjUgNDExLjI4OSAzMTguMTY3IDM5MS41MzUgMzM4LjE1NSAzODIuNzkyQzM2NC45NDkgMzcxLjA3MSAzOTYuNjQ2IDM1NS4yMTggNDAyLjYwOCAzMjMuNDA2QzQwNC41MzIgMzEzLjEzOCAzOTcuODM3IDMwMy4yMzQgMzg3LjU5NSAzMDEuMTk4QzM2MS42OTkgMjk2LjA1MSAzMzIuOTg5IDI5OC4wMzkgMzA4LjcxMSAzMDguODk4QzI4MS4xNSAzMjEuMjI1IDI3My45NCAzNDEuNzMxIDI3MS4yNzEgMzY5LjI3TDI2OC4wMzYgMzk4LjkzOEMyNjcuMDQ3IDQwOC4wMDUgMjU4LjU0NiA0MTQuOTUyIDI0OS40MjkgNDE0Ljk1MkMyMzkuOTk4IDQxNC45NTIgMjMyLjkyNiA0MDcuNzY5IDIzMS45MDMgMzk4LjM4OEwyMjguNzI4IDM2OS4yN0MyMjYuNDQyIDM0NS42ODEgMjIyLjI5OCAzMjIuNzY3IDE5Ny45MTIgMzExLjg2QzE3MC4wOTUgMjk5LjQxOSAxNDIuMTQxIDI5NS4yODcgMTEyLjQwNCAzMDEuMTk4QzEwMi4xNjIgMzAzLjIzNCA5NS40NjcgMzEzLjEzOCA5Ny4zOTEzIDMyMy40MDZDMTAzLjQwNSAzNTUuNDk1IDEzNC44NTQgMzcwLjk4NSAxNjEuODQ0IDM4Mi43OTJDMTgxLjgzMyAzOTEuNTM1IDE5NC43NSA0MTEuMjg5IDE5NC43NSA0MzMuMTE1VjQ4OC41MzNDMTk0Ljc1IDQ5NC44NjcgMTg5LjYyMiA1MDAgMTgzLjI4OSA1MDBIMTE5LjIxNEM4MC42Mzc0IDUwMCA0NS45NzE2IDQ2OS4wNyA0NS4yOTc5IDQzMC40ODFWMjcyLjM0OUM0NS4yOTc5IDI1Ny4xOTQgNTUuMjE0MiAyNDMuODI0IDY5LjcxNjUgMjM5LjQyNloiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl8yMzI0XzYxODY5KSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDJfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4=\",\n  keplr: \"data:image/png;base64,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\",\n  metamask: \"data:image/svg+xml;utf8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMTIiIGhlaWdodD0iMTg5IiB2aWV3Qm94PSIwIDAgMjEyIDE4OSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cG9seWdvbiBmaWxsPSIjQ0RCREIyIiBwb2ludHM9IjYwLjc1IDE3My4yNSA4OC4zMTMgMTgwLjU2MyA4OC4zMTMgMTcxIDkwLjU2MyAxNjguNzUgMTA2LjMxMyAxNjguNzUgMTA2LjMxMyAxODAgMTA2LjMxMyAxODcuODc1IDg5LjQzOCAxODcuODc1IDY4LjYyNSAxNzguODc1Ii8+PHBvbHlnb24gZmlsbD0iI0NEQkRCMiIgcG9pbnRzPSIxMDUuNzUgMTczLjI1IDEzMi43NSAxODAuNTYzIDEzMi43NSAxNzEgMTM1IDE2OC43NSAxNTAuNzUgMTY4Ljc1IDE1MC43NSAxODAgMTUwLjc1IDE4Ny44NzUgMTMzLjg3NSAxODcuODc1IDExMy4wNjMgMTc4Ljg3NSIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjU2LjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzEgOTEuMTI1IDE2OC43NSAxMjAuMzc1IDE2OC43NSAxMjMuNzUgMTcxIDEyMS41IDE1Mi40MzggMTE3IDE0OS42MjUgOTQuNSAxNTAuMTg4Ii8+PHBvbHlnb24gZmlsbD0iI0Y4OUMzNSIgcG9pbnRzPSI3NS4zNzUgMjcgODguODc1IDU4LjUgOTUuMDYzIDE1MC4xODggMTE3IDE1MC4xODggMTIzLjc1IDU4LjUgMTM2LjEyNSAyNyIvPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MC41NjMgMTUyLjQzOCIvPjxwb2x5Z29uIGZpbGw9IiNFQThFM0EiIHBvaW50cz0iOTIuMjUgMTAyLjM3NSA5NS4wNjMgMTUwLjE4OCA4Ni42MjUgMTI1LjcxOSIvPjxwb2x5Z29uIGZpbGw9IiNEODdDMzAiIHBvaW50cz0iMzkuMzc1IDEzOC45MzggNjUuMjUgMTM4LjM3NSA2MC43NSAxNzMuMjUiLz48cG9seWdvbiBmaWxsPSIjRUI4RjM1IiBwb2ludHM9IjEyLjkzOCAxODguNDM4IDYwLjc1IDE3My4yNSAzOS4zNzUgMTM4LjkzOCAuNTYzIDE0MS43NSIvPjxwb2x5Z29uIGZpbGw9IiNFODgyMUUiIHBvaW50cz0iODguODc1IDU4LjUgNjQuNjg4IDc4Ljc1IDQ2LjEyNSAxMDEuMjUgOTIuMjUgMTAyLjkzOCIvPjxwb2x5Z29uIGZpbGw9IiNERkNFQzMiIHBvaW50cz0iNjAuNzUgMTczLjI1IDkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzAuNDM4IDg4LjMxMyAxODAuNTYzIDY4LjA2MyAxNzYuNjI1Ii8+PHBvbHlnb24gZmlsbD0iI0RGQ0VDMyIgcG9pbnRzPSIxMjEuNSAxNzMuMjUgMTUwLjc1IDE1Mi40MzggMTQ4LjUgMTcwLjQzOCAxNDguNSAxODAuNTYzIDEyOC4yNSAxNzYuNjI1IiB0cmFuc2Zvcm09Im1hdHJpeCgtMSAwIDAgMSAyNzIuMjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PGcgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjExLjUgMCkiPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MCAxNTMiLz48cG9seWdvbiBmaWxsPSIjRUE4RTNBIiBwb2ludHM9IjkyLjI1IDEwMi4zNzUgOTUuMDYzIDE1MC4xODggODYuNjI1IDEyNS43MTkiLz48cG9seWdvbiBmaWxsPSIjRDg3QzMwIiBwb2ludHM9IjM5LjM3NSAxMzguOTM4IDY1LjI1IDEzOC4zNzUgNjAuNzUgMTczLjI1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSIxMi45MzggMTg4LjQzOCA2MC43NSAxNzMuMjUgMzkuMzc1IDEzOC45MzggLjU2MyAxNDEuNzUiLz48cG9seWdvbiBmaWxsPSIjRTg4MjFFIiBwb2ludHM9Ijg4Ljg3NSA1OC41IDY0LjY4OCA3OC43NSA0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi45MzgiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PC9nPjwvZz48L3N2Zz4=\",\n  fordefi: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzNDk0XzY2MjU0KSI+CjxwYXRoIGQ9Ik0xMC44NzY5IDE1LjYzNzhIMS41VjE4LjM5OUMxLjUgMTkuODAxMyAyLjYzNDQ3IDIwLjkzOCA0LjAzMzkyIDIwLjkzOEg4LjI0OTkyTDEwLjg3NjkgMTUuNjM3OFoiIGZpbGw9IiM3OTk0RkYiLz4KPHBhdGggZD0iTTEuNSA5Ljc3NTUxSDE5LjA1MTZMMTcuMDEzOSAxMy44NzExSDEuNVY5Ljc3NTUxWiIgZmlsbD0iIzQ4NkRGRiIvPgo8cGF0aCBkPSJNNy42NTk5NiAzSDEuNTI0NDFWOC4wMDcwNEgyMi40NjEyVjNIMTYuMzI1NlY2LjczOTQ0SDE1LjA2MDZWM0g4LjkyNTAyVjYuNzM5NDRINy42NTk5NlYzWiIgZmlsbD0iIzVDRDFGQSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzNDk0XzY2MjU0Ij4KPHJlY3Qgd2lkdGg9IjIxIiBoZWlnaHQ9IjE4IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS41IDMpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==\"\n};\nclass T extends _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.C {\n  constructor({ options: M }) {\n    super();\n    i(this, \"_wallet\");\n    i(this, \"_options\");\n    this._options = M;\n  }\n  static getInjectedWallet(M) {\n    return globalThis?.[`starknet_${M}`];\n  }\n  static isWalletInjected(M) {\n    return !!T.getInjectedWallet(M);\n  }\n  get id() {\n    return this._options.id;\n  }\n  get name() {\n    return this.ensureWallet(), this._options.name ?? this._wallet?.name ?? this._options.id;\n  }\n  get icon() {\n    this.ensureWallet();\n    const M = {\n      dark: L[this.id] || U,\n      light: L[this.id] || E\n    };\n    return this._options.icon || this._wallet?.icon || M;\n  }\n  available() {\n    return this.ensureWallet(), this._wallet !== void 0;\n  }\n  async chainId() {\n    this.ensureWallet();\n    const M = await this.isLocked();\n    if (!this._wallet || M)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.a();\n    try {\n      const I = await this.request({ type: \"wallet_requestChainId\" });\n      return BigInt(I);\n    } catch {\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.b();\n    }\n  }\n  async ready() {\n    return this.ensureWallet(), this._wallet ? (await this.request({\n      type: \"wallet_getPermissions\"\n    }))?.includes(_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.P.ACCOUNTS) : !1;\n  }\n  async account(M) {\n    if (this.ensureWallet(), await this.isLocked() || !this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.a();\n    const N = await this.request({\n      type: \"wallet_requestAccounts\",\n      params: { silent_mode: !0 }\n    });\n    return new starknet__WEBPACK_IMPORTED_MODULE_0__.WalletAccount(M, this._wallet, void 0, N[0]);\n  }\n  async connect(M = {}) {\n    if (this.ensureWallet(), !this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.b();\n    let I;\n    try {\n      I = await this.request({\n        type: \"wallet_requestAccounts\"\n      });\n    } catch {\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.U();\n    }\n    if (!I)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.U();\n    this._wallet.on(\"accountsChanged\", async (z) => {\n      await this.onAccountsChanged(z);\n    }), this._wallet.on(\"networkChanged\", (z, c) => {\n      this.onNetworkChanged(z, c);\n    }), await this.onAccountsChanged(I);\n    const [N] = I, j = await this.chainId();\n    return this.emit(\"connect\", { account: N, chainId: j }), {\n      account: N,\n      chainId: j\n    };\n  }\n  async disconnect() {\n    if (this.ensureWallet(), (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.r)(), !this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.b();\n    this.emit(\"disconnect\");\n  }\n  async request(M) {\n    if (this.ensureWallet(), !this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.a();\n    try {\n      return await this._wallet.request(M);\n    } catch {\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.U();\n    }\n  }\n  async isLocked() {\n    return (await this.request({\n      type: \"wallet_requestAccounts\",\n      params: { silent_mode: !0 }\n    })).length === 0;\n  }\n  ensureWallet() {\n    const M = T.getInjectedWallet(this._options.id);\n    M && (this._wallet = M);\n  }\n  async onAccountsChanged(M) {\n    if (!M)\n      this.emit(\"disconnect\");\n    else {\n      const [I] = M;\n      if (I) {\n        const N = await this.chainId();\n        this.emit(\"change\", { account: I, chainId: N });\n      } else\n        this.emit(\"disconnect\");\n    }\n  }\n  onNetworkChanged(M, I) {\n    if (M) {\n      const N = BigInt(M), [j] = I || [];\n      this.emit(\"change\", { chainId: N, account: j });\n    } else\n      this.emit(\"change\", {});\n  }\n  get wallet() {\n    if (!this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.a();\n    return this._wallet;\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9pbmRleC05YmI0OGY4YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQSx3Q0FBd0MsMERBQTBEO0FBQ2xHO0FBQzhDO0FBQytDO0FBQzdGLDhCQUE4QiwwcURBQTBxRCxraEJBQWtoQjtBQUMxdEUsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQix5QkFBeUI7QUFDekIsZ0NBQWdDLEtBQUs7QUFDckMsK0JBQStCO0FBQy9CO0FBQ0EsZ0JBQWdCLHlEQUFDO0FBQ2pCLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFDO0FBQ2pCO0FBQ0EscUNBQXFDLCtCQUErQjtBQUNwRTtBQUNBLE1BQU07QUFDTixnQkFBZ0IseURBQUM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssYUFBYSx5REFBQztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQUM7QUFDakI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0wsZUFBZSxtREFBQztBQUNoQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGdCQUFnQix5REFBQztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sZ0JBQWdCLHlEQUFDO0FBQ2pCO0FBQ0E7QUFDQSxnQkFBZ0IseURBQUM7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2REFBQztBQUM5QixnQkFBZ0IseURBQUM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQUM7QUFDakI7QUFDQTtBQUNBLE1BQU07QUFDTixnQkFBZ0IseURBQUM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRCxNQUFNO0FBQ04sNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBQztBQUNqQjtBQUNBO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0YXJrbmV0a2l0QDIuMTAuNF9idWZmZXJ1dGlsQDQuMC45X3N0YXJrbmV0QDYuMjQuMV9lbmNvZGluZ0AwLjEuMTNfX3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANi4wLjVfem9kQDMuMjUuNTAvbm9kZV9tb2R1bGVzL3N0YXJrbmV0a2l0L2Rpc3QvaW5kZXgtOWJiNDhmOGEuanM/MzVkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgeSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBPID0gKEEsIEQsIE0pID0+IEQgaW4gQSA/IHkoQSwgRCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogTSB9KSA6IEFbRF0gPSBNO1xudmFyIGkgPSAoQSwgRCwgTSkgPT4gKE8oQSwgdHlwZW9mIEQgIT0gXCJzeW1ib2xcIiA/IEQgKyBcIlwiIDogRCwgTSksIE0pO1xuaW1wb3J0IHsgV2FsbGV0QWNjb3VudCBhcyB0IH0gZnJvbSBcInN0YXJrbmV0XCI7XG5pbXBvcnQgeyBDIGFzIHMsIGEgYXMgZywgYiBhcyB3LCBQIGFzIHgsIFUgYXMgdSwgciBhcyBDIH0gZnJvbSBcIi4vbGFzdENvbm5lY3RlZC1lOTM1MTkxMi5qc1wiO1xuY29uc3QgbCA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTXpJaUlHaGxhV2RvZEQwaU16SWlJSFpwWlhkQ2IzZzlJakFnTUNBek1pQXpNaUlnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0S1BISmxZM1FnZDJsa2RHZzlJak15SWlCb1pXbG5hSFE5SWpNeUlpQnllRDBpT0NJZ1ptbHNiRDBpWW14aFkyc2lMejRLUEhCaGRHZ2daRDBpVFRFNExqUXdNVGdnTnk0MU5UVTFOa2d4TXk0MU9UZ3lRekV6TGpRek56Y2dOeTQxTlRVMU5pQXhNeTR6TURreElEY3VOamczTkRjZ01UTXVNekExTmlBM0xqZzFNVFF6UXpFekxqSXdPRFVnTVRJdU5EWXdNeUF4TUM0NE5EZzBJREUyTGpnek5EY2dOaTQzT0RZd09DQXhPUzQ1TXpNeFF6WXVOalUzTVRFZ01qQXVNRE14TkNBMkxqWXlOemN6SURJd0xqSXhOaklnTmk0M01qSXdNaUF5TUM0ek5Ea3pURGt1TlRNeU5UTWdNalF1TXpFNU5rTTVMall5T0RFMUlESTBMalExTkRnZ09TNDRNVFEwTkNBeU5DNDBPRFV6SURrdU9UUTFOVGdnTWpRdU16ZzJRekV5TGpRNE5UWWdNakl1TkRZeE15QXhOQzQxTWpnM0lESXdMakV6T1RVZ01UWWdNVGN1TlRZMlF6RTNMalEzTVRNZ01qQXVNVE01TlNBeE9TNDFNVFExSURJeUxqUTJNVE1nTWpJdU1EVTBOU0F5TkM0ek9EWkRNakl1TVRnMU5pQXlOQzQwT0RVeklESXlMak0zTVRrZ01qUXVORFUwT0NBeU1pNDBOamMySURJMExqTXhPVFpNTWpVdU1qYzRNU0F5TUM0ek5Ea3pRekkxTGpNM01qTWdNakF1TWpFMk1pQXlOUzR6TkRJNUlESXdMakF6TVRRZ01qVXVNakUwSURFNUxqa3pNekZETWpFdU1UVXhOaUF4Tmk0NE16UTNJREU0TGpjNU1UVWdNVEl1TkRZd015QXhPQzQyT1RRMklEY3VPRFV4TkRORE1UZ3VOamt4TVNBM0xqWTROelEzSURFNExqVTJNak1nTnk0MU5UVTFOaUF4T0M0ME1ERTRJRGN1TlRVMU5UWmFJaUJtYVd4c1BTSjNhR2wwWlNJdlBnbzhjR0YwYUNCa1BTSk5NalF1TnpJek5pQXhNQzQwT1RKTU1qUXVNakl6TVNBNExqa3lORE01UXpJMExqRXlNVE1nT0M0Mk1EWXhOQ0F5TXk0NE56TTBJRGd1TXpVNE1qUWdNak11TlRVM055QTRMakkyTURJelRESXlMakF3TXprZ055NDNOelU1TlVNeU1TNDNPRGsxSURjdU56QTVNRFlnTWpFdU56ZzNNeUEzTGpRd01UYzNJREl5TGpBd01URWdOeTR6TXpJd01Vd3lNeTQxTkRZNUlEWXVPREkwTmpaRE1qTXVPRFl3T1NBMkxqY3lNVFEySURJMExqRXdOaUEyTGpRMk9UVXlJREkwTGpJd01qY2dOaTR4TlRBeE1Vd3lOQzQyTnprNElEUXVOVGMxTURKRE1qUXVOelExT0NBMExqTTFOekE1SURJMUxqQTBPRGtnTkM0ek5UUTNOeUF5TlM0eE1UZ3pJRFF1TlRjeE5UWk1NalV1TmpFNE9DQTJMakV6T1RFMVF6STFMamN5TURZZ05pNDBOVGMwSURJMUxqazJPRFlnTmk0M01EVXpNU0F5Tmk0eU9EUXlJRFl1T0RBek9Vd3lOeTQ0TXpnZ055NHlPRGMyTVVNeU9DNHdOVEkwSURjdU16VTBOU0F5T0M0d05UUTNJRGN1TmpZeE56a2dNamN1T0RRd09DQTNMamN6TWpFelRESTJMakk1TlNBNExqSXpPVFE0UXpJMUxqazRNVEVnT0M0ek5ESXhJREkxTGpjek5pQTRMalU1TkRBMElESTFMall6T1RNZ09DNDVNVFF3TWt3eU5TNHhOakl4SURFd0xqUTRPRFZETWpVdU1EazJNU0F4TUM0M01EWTFJREkwTGpjNU15QXhNQzQzTURnNElESTBMamN5TXpZZ01UQXVORGt5V2lJZ1ptbHNiRDBpZDJocGRHVWlMejRLUEM5emRtYytDZz09XCIsIEUgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlHWnBiR3c5SW01dmJtVWlJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnYzNSeWIydGxMWGRwWkhSb1BTSXhMalVpSUhOMGNtOXJaVDBpWW14aFkyc2lQZ29nSUR4d1lYUm9JSE4wY205clpTMXNhVzVsWTJGd1BTSnliM1Z1WkNJZ2MzUnliMnRsTFd4cGJtVnFiMmx1UFNKeWIzVnVaQ0lnWkQwaVRUa3VPRGM1SURjdU5URTVZekV1TVRjeExURXVNREkxSURNdU1EY3hMVEV1TURJMUlEUXVNalF5SURBZ01TNHhOeklnTVM0d01qVWdNUzR4TnpJZ01pNDJPRGNnTUNBekxqY3hNaTB1TWpBekxqRTNPUzB1TkRNdU16STJMUzQyTnk0ME5ESXRMamMwTlM0ek5qRXRNUzQwTlM0NU9Ua3RNUzQwTlNBeExqZ3lOM1l1TnpWTk1qRWdNVEpoT1NBNUlEQWdNVEV0TVRnZ01DQTVJRGtnTUNBd01URTRJREI2YlMwNUlEVXVNalZvTGpBd09IWXVNREE0U0RFeWRpMHVNREE0ZWlJZ0x6NEtQQzl6ZG1jK1wiLCBVID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJR1pwYkd3OUltNXZibVVpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ2MzUnliMnRsTFhkcFpIUm9QU0l4TGpVaUlITjBjbTlyWlQwaWQyaHBkR1VpUGdvZ0lEeHdZWFJvSUhOMGNtOXJaUzFzYVc1bFkyRndQU0p5YjNWdVpDSWdjM1J5YjJ0bExXeHBibVZxYjJsdVBTSnliM1Z1WkNJZ1pEMGlUVGt1T0RjNUlEY3VOVEU1WXpFdU1UY3hMVEV1TURJMUlETXVNRGN4TFRFdU1ESTFJRFF1TWpReUlEQWdNUzR4TnpJZ01TNHdNalVnTVM0eE56SWdNaTQyT0RjZ01DQXpMamN4TWkwdU1qQXpMakUzT1MwdU5ETXVNekkyTFM0Mk55NDBOREl0TGpjME5TNHpOakV0TVM0ME5TNDVPVGt0TVM0ME5TQXhMamd5TjNZdU56Vk5NakVnTVRKaE9TQTVJREFnTVRFdE1UZ2dNQ0E1SURrZ01DQXdNVEU0SURCNmJTMDVJRFV1TWpWb0xqQXdPSFl1TURBNFNERXlkaTB1TURBNGVpSWdMejRLUEM5emRtYytDZz09XCIsIEwgPSB7XG4gIGFyZ2VudFg6IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpZFhSbUxUZ2lQejRLUENFdExTQkhaVzVsY21GMGIzSTZJRUZrYjJKbElFbHNiSFZ6ZEhKaGRHOXlJREkwTGpBdU1Td2dVMVpISUVWNGNHOXlkQ0JRYkhWbkxVbHVJQzRnVTFaSElGWmxjbk5wYjI0NklEWXVNREFnUW5WcGJHUWdNQ2tnSUMwdFBnbzhjM1puSUhabGNuTnBiMjQ5SWpFdU1TSWdhV1E5SWt4aGVXVnlYekVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUlnZUcxc2JuTTZlR3hwYm1zOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2ZUd4cGJtc2lJSGc5SWpCd2VDSWdlVDBpTUhCNElnb0pJSFpwWlhkQ2IzZzlJakFnTUNBMk5TNHhPVFV3T0NBMU55NDNNelUyTWlJZ2MzUjViR1U5SW1WdVlXSnNaUzFpWVdOclozSnZkVzVrT201bGR5QXdJREFnTmpVdU1UazFNRGdnTlRjdU56TTFOakk3SWlCNGJXdzZjM0JoWTJVOUluQnlaWE5sY25abElqNEtQSE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056SWo0S0NTNXpkREI3Wm1sc2JEb2pSa1k0TnpWQ08zMEtQQzl6ZEhsc1pUNEtQSEJoZEdnZ1kyeGhjM005SW5OME1DSWdaRDBpVFRRd0xqazROVGt5TERCSU1qUXVNakE0T0RoakxUQXVOVFlzTUMweExqQXhNREF4TERBdU5EVXhNREl0TVM0d01qRTVOeXd4TGpBeE1qQXlDZ2xqTFRBdU16TTRPVGtzTVRVdU56VTFMVGd1TlRneU1ETXNNekF1TnpBNE9UZ3RNakl1Tnpjd01ESXNOREV1TXpBd09UbGpMVEF1TkRVd01ERXNNQzR6TXpjd01TMHdMalUxTWprNExEQXVPVFkzT1RrdE1DNHlNalFzTVM0ME1qTnNPUzQ0TVRVNU9Dd3hNeTQxTnpNS0NXTXdMak16TkRBMUxEQXVORFl5TURFc01DNDVPRFV3TlN3d0xqVTJOVGs0TERFdU5EUXlPVGtzTUM0eU1qWTVPV000TGpnM01UQXpMVFl1TlRjNU1ERXNNVFl1TURBM01ESXRNVFF1TlRFM0xESXhMakUwTmpBMkxUSXpMak14TlFvSll6VXVNVE00TERndU56azRMREV5TGpJM016azVMREUyTGpjek5UazVMREl4TGpFME5pd3lNeTR6TVRWak1DNDBOVFk1Tnl3d0xqTXpPRGs1TERFdU1UQTNPVGNzTUM0eU16VXdNaXd4TGpRME1UazJMVEF1TWpJMk9UbHNPUzQ0TVRZd05DMHhNeTQxTnpNS0NXTXdMak15T0RrNExUQXVORFUxTURJc01DNHlNalk1T1MweExqQTROaTB3TGpJeU5DMHhMalF5TTBNMU1DNDFPRGs0Tml3ek1TNDNNakV3TVN3ME1pNHpORFk0T0N3eE5pNDNOamN3TXl3ME1pNHdNRGM0T1N3eExqQXhNakF5Q2dsRE5ERXVPVGsxT0Rjc01DNDBOVEV3TWl3ME1TNDFORFk0T1N3d0xEUXdMams0TlRreUxEQWlMejRLUEM5emRtYytDZz09XCIsXG4gIGJyYWF2b3M6IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTlRBd0lpQm9aV2xuYUhROUlqVXdNQ0lnZG1sbGQwSnZlRDBpTUNBd0lEVXdNQ0ExTURBaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStDanh3WVhSb0lHUTlJazB6TWpNdU5EUWdOREV1TXpnNE5rTXpNalF1TVRrNElEUXlMalkzTWpnZ016SXpMakU1TlNBME5DNHlOakF6SURNeU1TNDNNRFFnTkRRdU1qWXdNME15T1RFdU5URWdORFF1TWpZd015QXlOall1T1RZMUlEWTRMakUyTlRZZ01qWTJMak00T1NBNU55NDROekZETWpVMkxqQTFJRGsxTGprME1EY2dNalExTGpNek55QTVOUzQzT1RVMklESXpOQzQzTlRRZ09UY3VOVGM0TjBNeU16UXVNREl6SURZNExqQXdPU0F5TURrdU5UUWdORFF1TWpZd015QXhOemt1TkRRMUlEUTBMakkyTURORE1UYzNMamsxTXlBME5DNHlOakF6SURFM05pNDVORGtnTkRJdU5qY3hOaUF4TnpjdU56QTNJRFF4TGpNNE5qVkRNVGt5TGpNeU15QXhOaTQyTXpNZ01qRTVMalE0TXlBd0lESTFNQzQxTnpNZ01FTXlPREV1TmpZMElEQWdNekE0TGpneU5DQXhOaTQyTXpNNUlETXlNeTQwTkNBME1TNHpPRGcyV2lJZ1ptbHNiRDBpZFhKc0tDTndZV2x1ZERCZmJHbHVaV0Z5WHpJek1qUmZOakU0TmprcElpOCtDanh3WVhSb0lHUTlJazAwTVRndU56VTJJREl5Tmk0NE9UUkROREkyTGpNM0lESXlPUzR5SURRek15NDFPREVnTWpJeUxqVXhOeUEwTXpFdU1ETTJJREl4TkM0NU56bEROREEwTGpVd055QXhNell1TkRBeElETXhOaTQxTXpVZ01UQTBMak0xT0NBeU5UQXVNVFU1SURFd05DNHpOVGhETVRnekxqWTNOQ0F4TURRdU16VTRJRGt6TGpjek9URWdNVE0zTGpReE9DQTJPUzR6TURVeElESXhOUzR6TXpGRE5qWXVPVFUzTkNBeU1qSXVPREU0SURjMExqRTBOalVnTWpJNUxqSTNOU0E0TVM0Mk5EYzVJREl5Tmk0NU56ZE1NalEwTGpJMUlERTNOeTR4TlRGRE1qUTNMalUyT1NBeE56WXVNVE0wSURJMU1TNHhNVFlnTVRjMkxqRXlPQ0F5TlRRdU5ETTVJREUzTnk0eE16Vk1OREU0TGpjMU5pQXlNall1T0RrMFdpSWdabWxzYkQwaWRYSnNLQ053WVdsdWRERmZiR2x1WldGeVh6SXpNalJmTmpFNE5qa3BJaTgrQ2p4d1lYUm9JR1E5SWswMk9TNDNNVFkxSURJek9TNDBNalpNTWpRMExqTTNJREU0Tmk0ME5UWkRNalEzTGpZMk9TQXhPRFV1TkRVMklESTFNUzR4T1RFZ01UZzFMalExTXlBeU5UUXVORGt5SURFNE5pNDBORGhNTkRNd0xqSXpNaUF5TXprdU5EVXlRelEwTkM0M05pQXlORE11T0RNeklEUTFOQzQzTURFZ01qVTNMakl4TmlBME5UUXVOekF4SURJM01pNHpPVlkwTXpBdU5EZ3hRelExTkM0d01qZ2dORFk1TGpBM0lEUXhPUzR6TmpJZ05UQXdJRE00TUM0M09EWWdOVEF3U0RNeE5pNDNNVEpETXpFd0xqTTNPU0ExTURBZ016QTFMakkxSURRNU5DNDROemNnTXpBMUxqSTFJRFE0T0M0MU5ETldORE16TGpFeE5VTXpNRFV1TWpVZ05ERXhMakk0T1NBek1UZ3VNVFkzSURNNU1TNDFNelVnTXpNNExqRTFOU0F6T0RJdU56a3lRek0yTkM0NU5Ea2dNemN4TGpBM01TQXpPVFl1TmpRMklETTFOUzR5TVRnZ05EQXlMall3T0NBek1qTXVOREEyUXpRd05DNDFNeklnTXpFekxqRXpPQ0F6T1RjdU9ETTNJRE13TXk0eU16UWdNemczTGpVNU5TQXpNREV1TVRrNFF6TTJNUzQyT1RrZ01qazJMakExTVNBek16SXVPVGc1SURJNU9DNHdNemtnTXpBNExqY3hNU0F6TURndU9EazRRekk0TVM0eE5TQXpNakV1TWpJMUlESTNNeTQ1TkNBek5ERXVOek14SURJM01TNHlOekVnTXpZNUxqSTNUREkyT0M0d016WWdNems0TGprek9FTXlOamN1TURRM0lEUXdPQzR3TURVZ01qVTRMalUwTmlBME1UUXVPVFV5SURJME9TNDBNamtnTkRFMExqazFNa015TXprdU9UazRJRFF4TkM0NU5USWdNak15TGpreU5pQTBNRGN1TnpZNUlESXpNUzQ1TURNZ016azRMak00T0V3eU1qZ3VOekk0SURNMk9TNHlOME15TWpZdU5EUXlJRE0wTlM0Mk9ERWdNakl5TGpJNU9DQXpNakl1TnpZM0lERTVOeTQ1TVRJZ016RXhMamcyUXpFM01DNHdPVFVnTWprNUxqUXhPU0F4TkRJdU1UUXhJREk1TlM0eU9EY2dNVEV5TGpRd05DQXpNREV1TVRrNFF6RXdNaTR4TmpJZ016QXpMakl6TkNBNU5TNDBOamNnTXpFekxqRXpPQ0E1Tnk0ek9URXpJRE15TXk0ME1EWkRNVEF6TGpRd05TQXpOVFV1TkRrMUlERXpOQzQ0TlRRZ016Y3dMams0TlNBeE5qRXVPRFEwSURNNE1pNDNPVEpETVRneExqZ3pNeUF6T1RFdU5UTTFJREU1TkM0M05TQTBNVEV1TWpnNUlERTVOQzQzTlNBME16TXVNVEUxVmpRNE9DNDFNek5ETVRrMExqYzFJRFE1TkM0NE5qY2dNVGc1TGpZeU1pQTFNREFnTVRnekxqSTRPU0ExTURCSU1URTVMakl4TkVNNE1DNDJNemMwSURVd01DQTBOUzQ1TnpFMklEUTJPUzR3TnlBME5TNHlPVGM1SURRek1DNDBPREZXTWpjeUxqTTBPVU0wTlM0eU9UYzVJREkxTnk0eE9UUWdOVFV1TWpFME1pQXlORE11T0RJMElEWTVMamN4TmpVZ01qTTVMalF5TmxvaUlHWnBiR3c5SW5WeWJDZ2pjR0ZwYm5ReVgyeHBibVZoY2w4eU16STBYell4T0RZNUtTSXZQZ284WkdWbWN6NEtQR3hwYm1WaGNrZHlZV1JwWlc1MElHbGtQU0p3WVdsdWREQmZiR2x1WldGeVh6SXpNalJmTmpFNE5qa2lJSGd4UFNJeU5EVXVPVGcySWlCNU1UMGlMVEkzSWlCNE1qMGlOREkxTGpRNU5pSWdlVEk5SWpVd01pNHpOellpSUdkeVlXUnBaVzUwVlc1cGRITTlJblZ6WlhKVGNHRmpaVTl1VlhObElqNEtQSE4wYjNBZ2MzUnZjQzFqYjJ4dmNqMGlJMFkxUkRRMVJTSXZQZ284YzNSdmNDQnZabVp6WlhROUlqRWlJSE4wYjNBdFkyOXNiM0k5SWlOR1JqazJNREFpTHo0S1BDOXNhVzVsWVhKSGNtRmthV1Z1ZEQ0S1BHeHBibVZoY2tkeVlXUnBaVzUwSUdsa1BTSndZV2x1ZERGZmJHbHVaV0Z5WHpJek1qUmZOakU0TmpraUlIZ3hQU0l5TkRVdU9UZzJJaUI1TVQwaUxUSTNJaUI0TWowaU5ESTFMalE1TmlJZ2VUSTlJalV3TWk0ek56WWlJR2R5WVdScFpXNTBWVzVwZEhNOUluVnpaWEpUY0dGalpVOXVWWE5sSWo0S1BITjBiM0FnYzNSdmNDMWpiMnh2Y2owaUkwWTFSRFExUlNJdlBnbzhjM1J2Y0NCdlptWnpaWFE5SWpFaUlITjBiM0F0WTI5c2IzSTlJaU5HUmprMk1EQWlMejRLUEM5c2FXNWxZWEpIY21Ga2FXVnVkRDRLUEd4cGJtVmhja2R5WVdScFpXNTBJR2xrUFNKd1lXbHVkREpmYkdsdVpXRnlYekl6TWpSZk5qRTROamtpSUhneFBTSXlORFV1T1RnMklpQjVNVDBpTFRJM0lpQjRNajBpTkRJMUxqUTVOaUlnZVRJOUlqVXdNaTR6TnpZaUlHZHlZV1JwWlc1MFZXNXBkSE05SW5WelpYSlRjR0ZqWlU5dVZYTmxJajRLUEhOMGIzQWdjM1J2Y0MxamIyeHZjajBpSTBZMVJEUTFSU0l2UGdvOGMzUnZjQ0J2Wm1aelpYUTlJakVpSUhOMGIzQXRZMjlzYjNJOUlpTkdSamsyTURBaUx6NEtQQzlzYVc1bFlYSkhjbUZrYVdWdWRENEtQQzlrWldaelBnbzhMM04yWno0PVwiLFxuICBrZXBscjogXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUlBQUFBQ0FDQVlBQUFERFBtSExBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFDUGZTVVJCVkhnQnpWMEwwQjlWZFQ5bnZ5L3ZCNm5WT2c0R0V4L1ZFUjNBMWlxbzlhTXpGZ1d0b09oZ3NZYUhZTlYybE5FcXhBZGZtS0hUYWt1RFRnZTFGSksydHFPdEdxb1dGV3RpOFRGU3hHRHJpRlNiSUsrcWdCOTVoK1RiMDkzOTcrNDlyM3QzLzk5L0xUMHptLy9lOTkxN2Z1ZDN6cjI3U1JCK0ViS2QxZ0FjT2hGZy9rU1ltam9CaUo0SmhNc0I2TEhGSmV0Uyt3Zm9Bb3dPUU9LbnVtR1ZVZlNYKzIzQmEwdVJmRmFHc2g2cE5LRHFQMlB6UU41VGJOeHFqQWVxaTJDdVdMdXZBdVU3NGVUMU8rQVhJQWhEU2FYMGcrZkJGTDZ5bUhTaGZGaFQ1UnZka25OTHpzVEliK2NDaG16YjJPSnFKWThhUUc5Z2FBVVhhWExiT0gwZ0w0bVhtWEhDL0hZVXYxdGhFV3lEazliUHdRQXlPUUMySDF3SEdiMjl1TnRRZExjbUZKQnYyQXNGQVBWUUpEUVBsRkJZRkFDcHNvNytrRm0xN2cvOXNVZ3IzUUZXTkkzVnRRV08wS2FDR1hiREJMSndBRlNLejJjTGp0dmdsaE5GR21yNk5vbWd4RVFkVDFrWUs4TjB1ekJ3SDNib3NISm8zRUtrRDFaRzBYNmN0QUZFVzZjQUFpd1lDQXNEd00ySEw0ZTh0SHBhNDVhN05OMlVVYXhCbUZBUG1wZHQrckdEcTB6ZHJwUDJJNnlSaWcwNkFOSE5IdUF3anhsekZwNjdmaE9NS2VNQm9MVDZLYnkrR0hNR21rbHlTVm9zSkFPK2FqSzlMWDZVeGw1MWV5cVpwL3RZdlZjUGJSa2x5blE3YXU5MTNhYWVCd0xSeis2Q0RVNGRodzJ5dmhWaCsrRXpJY1B2Qk9YWGMrU1hKejNMTVZZZUVibE9ZeEtaTXgva0Y0VjcwYVpQditxKzdjZVVtYWl2SFR1MGhEU1dxendSV2E0ckFzVHRjT3V1TTZHbjlBUEF6WWZlVnN6c004VUFhem9WQ2dEajFERUxuZXFyQmdycS9pbHlLVUZ3RkUyUjhjWDhVQUJEMU9tYU94ODdwa3cxMzdneG9QOXNzcTkxeGZVWitQZGRsME1QNlFiQVZ3dC9Qdytib1krTUNRenNxdU5ZNlZoQ0hVb0dOZVk0ZlVLalZMUjlKZElDOElreGtUcnFrZXJWUHNOc0h4Q2sxN1JVUHRGc3RKdzZ0RTJSZk5BUGwzNUNzN1hyU0hjR2hXUEhBREJXSUpqMjVYSjhpcGJKY1VtbFpSMDFGcytiaDB2ZytldWpCaHdIUU9uem9hRDlwRkFpMjVaaEQyWHpQS21ITkFBUXlDL3pIYkNlbEZOR2ljQlBweFA4alpGQTBFbDM3eHlhSEE4b3FtOHVCR2ZCODladjg0cDhBSlRSUHVEMjRtNGRwS1NMQWRoUFBHS3Y4d3g0KzFsOGRPL3Z0VldMMVB2UUtNSUl4T3RGbzNWS0t5OXk0Sk5ta2JvZmxlZjJONUs1Z2dsTzhuWUhmZ3hBaGZKSHdRUWtMOUVtWGdmSHFOY25Ma0JTd1dBUEVVRmZyRzNYczZrOGIrZGc2Nk42UnBTN0ROTXZBcCt2d1RYckIyTHQ3ZHF1Z1dtNEhoeXhBTmhlK1AyVTVmY0JReTBtWWgrbm50T21MMEJjb01SRUs4dk5yOHVpQ2duS2tBRWl4SU81Wm80MUlPS0tyZ1BOV0Z2dzFsaXVWRFdIdk5pK2YvTkhzNkJFcm1kSi9UbnVndDVDbGhsNW1WUGRVbkNrTG5NaGZWd0M4aFV6NWM2OXFpZm00dllCTHJXVDI4NUpxN2FVZEFPTTR1dDAyeWNBa0xFQ2lsZ0diMSsxbmFOY3VnTEpBUFBGMWlGbGlkN0Z4bWpINlZPM1I5OWQyemRPd2EyaytnTnBOVkdHY09iYzV2UFJFeFp2S0Z3eGphaExpbDFvbEdmN3FkMERnV0lYak0rNUhidXNnMnN5eE12VlU5UlNXdi9SL3Ridld5VWZsTVpvUTlZd0U2dmZoeEhLMWVuc3kzSEM2Rmx5cEc1Nml4Wm5CREoxYmYvMk93UGVVOFF5ZWg2bjVrRHJHeFpvR1NBN0NyTWlxUEV1YmpGZEY1dFRuemJHa3Jrb3krTDVIZ3NsR1NieVBHNFFSODVZVHA3UEFCaTEwc2JxVFRCSXltOFQyam5wdnNWOEVFd1E2RWhHOEhhK1p0WEhISGprOE0raHIxRDdSMVRRSzFmdHVtSUF0STFOdW8rVnB3K0dBSG9kOHJSNXFYU3FYNW1PV3ppeGNwYW5ySU04UmhMOXlQNlV6TTBmTGxqZzFQVnpJd1k0Y3VqTVRvdnVRQlZRRDJ0bmMrenkyeW5HNk5vR2RqSkJiTzVRV3hkb2E0YW9qOWZId2w0NmpJTUJYNlRxdDgrai9Ed0VpeGNzd05zVEpOWVN3eFZremFJbGNGNTVVd0VBYzl3d0ZnQThaVVFuWU90MkFjTjFiNG15YnZDaDdJTjZVSDh6THgyZ2dWY25uWTY2QnFwbnhkY0lMRENhWjNEbjMvUksvbk5KQUdON0VVeTlzbGtUd0JzUGVYWmhKRTNKdW9pY05uNDdqSmhsbHd2b1ZlNVJ1YUo1TXo3YXZnQ0hUWnV0bkJxenkwVTBlWGJsS0dJbFJ1YU9ITW5YVDhPTkIyZDZCbys5SmVhZVRKMkJ5OXB5WHNsYlE4UlJBVVU2b0k2OHNkT2xwa2lra1NRSVJ4b1BMNGRhZG1nVVNxSHpVUkg1dWthT2lxUVMxa3hQdzRuVFdma0ZML1dEVEVyNnhSNXhCWTZ2OU5HcW9GZUpFdTA4QmRjckhvRExGcjdLUTlucDJHbHYvRUtSU0FZb0NKUUVEMEdEWDJRNXdPWUthakF1b1c1NU41VVhBS0E4bTFtSStqdmJVTCs2Q3dHRUtGZEtRbEhEbVlSck5XQkFnWU16QWJaV0c1SUlaSUFTR3BHVForZUZkWEVQR3NmNnlaczF3RVVuVEJlSll6cmJtWnlPd1dnTUJSWnk3WWxMNEExcnAyRWg4bThQenNOcDM5eWZyT01xRTVpNzZGSzBsMWQwK3RIalY4SHJqMTBLUThoMzl4MkJrMi81V1Jpc1pDUTJIclhLVTdHQ21LRE02U3BDbUM5Y1FBN3J1czI1bjNURkVnTU5ZOFU4bUVyRVhJSzJVT1p2RWRLMHZ2RXBLd1pUL2wySDV1R2MyeDhTN0tESFF6RlBhRE9DMjFMbHZEQ3FGMXhUbXQwNnNYMUpBTWswaDhucURBYUlDT09ncDJCV2lCMjBHWnZmWlU5YkFSdWZ1aHlHa0ZMNXA5LzZJTng5S0hkZXpUYjdFd2ZoZFF4QUtWOUxYcWFRZGRPZGYzVXUwbmRLTUlFZXQ1OGVZSXNLQmV1SVdUN1A4c293MFVhenhHVy91bnc0NVI4c2xQL3RCK0hIeFc4N21Bb01VYk9CbVo0VC9ZNGgweWtBalNQaitQeHgyM2FPclFPdlVtS2dBTWRWZWF4WEJ3aWNKYzVkdXdRMlBtMFk1VDk4bE9EbGhlWGZVeWkvc1h4eXFGOXMvMktVTGdKaGdMUlBsREtOT1N4SUpxSi9WR1VUTUlEeGdhUXNHc2FacTdRMDN1N1p4MHpETlNlc2dpR2tWUDRadHhTV2Z5QUhIbnNZUDY4V0JoTmw0TlFFVlpNemMzTTNQWlN2NzFPM25ZQWVjeElYVUxkSE01WmZyeTFEVnBIUzh6NXUrUlI4L3VUT3pWSnZPZmZiUDRmdjdUa2EzN0syV1U1K205T2YrakZ4TnozcEtlQkNxWDlTMmhkOWVYU2ZHcXUxTnBUYktyUzN4eTJmaHMrZHNocU9XVFRNak4vNjNUM3c5UWNmc1N3SXZySTlSV09QT24zRkJvRWRnajBRTTU3U2FUSXdFTGpiejlZMUNEZmdMektLb3RGTjJlZmFGVlB3dVJlc0xrRFEvMi9RcFdUajkvYkNQOXg5VUc0eDdVd2dyc1QrOUU4OFZhMERnYmZKbXg0alhwQXQzV0VUWlRoZW03SEVZWUNrd2duYzdUTFBPMll4d3VkZU9KenkvL1RPL2ZEUlhRZXFJY0xjbW9ITkRFMFp1ZVd4OXM3YWxtOEJIWWFieUFYRUxEcGVGbWszcVJzYTB3V2txTGRSem1kZmRNeGd5di9BRC9iREJ3c0E4TEREem1ZaGpGRFhFZUJOMUZVZ0wyVjZuTVZmcUwrdnltSTBIV1BEdmxLNmdKeDNxRzRKQlBMZE9TajV5K2V1TEtMK0tSaENLdVhmc2IrZVErcGhWWmxRRmdvcVQwdnNZY25OTWpGQVdzbHhJdXBMOFVOYlArL0R1b0RFK0NZK0dNbTdqMThHcjN2U1loaENQdmFqZy9CbjM5Ky9ZSXZYUkk5T2J1dnIyZk9rbklMR3oxZ3VJQWtPaXRkRGIyVG9acFErZ3F4ckZKRVBxMk9zeVZKKytRRHZLcFQvcm1jdWd5SGtFM2NkZ3ZmZHZxK3cvQkJVc2dGSFd6eU1XN3dzOElIYk1vTW9HeStvRmd6UTIvcjFBa2RhbU1sQmhEVW1kUUV4OXhKSmUyVVhQMzFwQllBaDVCc1BISUczM2JxWCtmd0k5VmNnQUlndVFLVlFDNGFrdEgwbUs3VjNDd3NDbzBFWFEyc1BsNEEwaWViTnNHWU1jZTlGL3JXYzgrUWxjT1ZKd3h6eGZtOXVIczcvK3NNT0tCTmIwSmE3MWNLYUpyVnlxV01yMXJtczRlbDdCb0hVTDZwM3dKcXl4RFp2b0YyQVR1dkFTNE9nekg3MkwwL0JsYzhaeHZMdjNwL0RxM2ZNd2Q0anNmVUtHdkxqSXpVNWNwdUNIOVdTMnZ6M2srNGdNTktabXgxakJvdzlzR3kzWU1uQjNlTTIvaklHd3JVck05ajZvcFd3ZW9CVHZsTDVaMjkvR1BZZXB0YnZWMk01b0F1VEpWdHU2dFFaM2lrT0YxN2Y2MU1VQnVsMkFXUWpVbGNjSmNjVWpCRXFYcERVTVlBT3NxSWdxQmYzdUpVSW4zbkpxdUswYi9LOWZxbjgxM3psWWJoMy96eDduc2FlTy9id1ZSV0t6bHZXZzNqTVlJTE0yR2dvdWhydmJXREtyOGRpUkhUeXF1ZGxkREVCQTNEbDYwKy9ZaUE0cnJEOFQ3OWs1V0RLZisyL0t1WHJTTDJPenNFdHI2SENsSXVSZWlFdlpqWVV0ZjVZaTQ0WWdFd1NJL1ZpYzlLQkhqcGJ0RWxab0YxYmgvS2I4Wm82cTRzajN1dG5WbFQwUDZuc0tYejlhNy84TU55emIvUmFGMU5iM2ZZb2xzUmNSYjB1Nm1mWnNuTTFtaGM3UkNUeE1pZ1IrRVdzV2hVbjY2RXBtRUI0bjZSY0RGdXNNdnRETDF3T3ozck01S2Q4bGZKdktpeC9iMTcxRytpVmZWNnV3YzcraE9SeGpaL3kyazI2aE5ZRkpJSUMzNmV6UXhWajNZNUZNQ3NRbGp1QllQMWRCYmJqZ3V0VHIzaitNbmpwY1l0Z0NMbG8rMTc0L29QejduZDhNZDl2bE92UnZpY0MxRjNCSGlXVHVvdHBvOHkrbEJ6MTdiYU91Q1dISVlhSUFUekxaK2wzUEdjcFhIVDhFaGhDM3ZuMS9mQ3QrNCtNTEY4eGRnQWl0aWR6ZGNwbkJVMzdWUCtCRG5ORzFsTm05dEFlYTFNd1FJL1Y5NmlNMmo5a0ZUWXpURVQvVlhwQ3k5ZjltTU9lT3Y4ZHY3YTBBc0FRY3NVdEIrQlQvM1VZbXRNOWQwd0JDdC8zRzhPSldRN1BvUTdyOVBydWtNNkRJRDUzdDh3SlVQU3pTTFRLdjdTWjZyK1hsRzM1T1FESmVWMzA3TVVWQUlhUXE3OXpFTGI4NXlGQng5amhreEY0WFQ1cHYzNmI3OUk3aG5nbnNSR0lkMndYZW94M0FheU9nMmpaM3FlOU5Pb1hMc2lCeGVaNTJ2cEZzT21VWVU3NXJyN3RZQVdBQ3RBODRGVi9kNi9aaWlhZnRmbVhQN2hsZU91UlVtYVh0V3RkdTliYTR4ekF0L0lJZ2lNVEVxRFJ3ZG9BNHNVQXp5cU9lRGZQREtmOEQ5MTJjT1R6WGNybi81U0wzUkx6OHdrTkRMSEFyblZUWE5rT1FIb0RvcForTDROVW9PaTVxMEFLNFVtTkZYajV6UU5PSURvR1dMc3FnMnRmdGdKV0w1bWNZcTcvajhQdzRWc1B5cmtuQWs3c0Vmd2h2MGtDbys0UElLM3NDYmJXdlQ4S3hXWWtQUUVGRHI1SW9oNlN6VWZtUmhZcTVaQjVtRmVwL0UrZVdaenlyWnBjK1ovNndTTnc1VGNPbUlDUEs1VXJRZE84TGpmSDVSN3RxL1Z6clI1N1dqcDI0OEVGQUVaSEJwKzJzUXVOWkE1a21yb1k2N09udEJaWlhFODhwbEQrV1lYeVYwK3UvSEtQZitsWDl0Zi9oZzYwSUJCS00wcUg1RllVMmJ0NkdhK1E3RU5YYU9xeGNVVStSTVNOQTZURVhZQkFJRVZIQ2RiQUtLOHBZL215N3VobWNqWFYvUllnWHIwVTRkb3pWZ3ltL05kdjJ4dU9xVnZGMWt6QXgzWmpnamd6K0Z0VkJ4aWUyM0RjZ0pPTVp6cTY5b05BZEZwUnBMaFJwcUg4MEJ4VlE1ekFaeG1wcmYrcTMxNEd4ejl1OHZQOThtajM5ejY5Ri9ZVnIzVXpWM0hzWC81Q2N0MkJPWWwwUUNIU0FPNjJEMk1LaitRRHFERk5waFgvSElCc0QrZ2tSZ01wQ3hlS2w0NHNnSVRFUzVwSmR3T1h6eXlGMDU0eStSSHZ2WHRxNVIraTRKb1Npa1QyU2RjNGxzLzdBa2dEdyt0TDVJc09ySWkrSFZFeGdLVngyNU5VWkpYV2ZsRGVLUDlQSmc4bUFNREphNmVxYTFJcGxmK0dUKzJGKy9ia1lsR3h5N3FoaVE5QUtDcG0rZTVhNlRZQUZnaU5MYVdBd0NjVkVWMDgzZWU3UEk5U3hMK3BLdzI5MWE0Si9QakhKZWozKzJoSXBmeC9ySldQMnUrRHExaFVBUEhLWXVXZWN0SHo5NW9obW55QXhPdDNuUUZKU1c0RHZVRmE2elo1amRoUG9NVkpuV0VGR3V4QWFDR3lwL0QxR3o3SkxGOXQ5YmppVzR0bnJCVllRSXFYajJPVUo5TnMvRlQ5VUMrT2d2UkJrTFpzdFJ1d0wzc1VNSnlJMzdpRFIxdjVueWlVUDFlLzAvZG9uOEFjNzdiMUhJWXc3Vm01VHJmMTZ6dzNKcWc3Y2xsQVZKYUNySjVmT0pMNE9VQ2tONDlpV2xad0pzYi9RVVNKOWtTODhYOGs3N254QVB6Z0ovUEd2eU9BcEc2ZVgyWTBaY3lIeDJJRm5RYVF5a0h6S2hqNnV3TUFQNDVJQ2dwZzlOb0dKZzkvcVAzRCtSS0hWRDBJcjBiNXhCOEZGaWkvM3IzamY0NVdad2llZnhmV0Q1RDA5YTJ5bFFGWUprRC9sYmhqK2JGWDU5NkhJY2JhZTRPaC9NZWlTd0NvQytlaE9sNGRYYXE4M3JhTjhxbTZxa1drdW0xOVZTOUYybnFoSGEvZmxqOEtBRmhWdkNmWThycFZjT3pxckpwRFZzOG5xK2ZFNThmdm0zcTZMTXRaK3lwZC84UE1PYnRZbTB6VWxlTm5UVjdSSmlONU5YMWx1Zy9UTnVnQ0tYNkZEMEkwWExSL053bDFJb2FxVFBoNmFKbkM5N09QQWdJS09iWTRPdjd3cTFiQ0JYOC8ydnNMeXVhL25yVTdaZHpDT1hVYnQ4QWVWN0FGNE5pN2dTcmZOWFhHRUlubHphcU9hdXQxTGIyeDNQYXFtWUZrbmJZTll3M09BTWdZQWR1Nk1HSUVlUFRrNlkrZmd1dCtkMVgxNWpCbEtmd0tMSURxaXRmTlRGc1lXWFJqMllSaWZRd0xHVXUycklDQ0xTUkRHSlpvcnVpRGFyZFFLVDBvdnFIN0FKWVJNQ1RkdzBqQlJLRys2UC9SM1FJMlVvTGcybk5YVlorTWUvUnU2RDhIVitHWnFoZExZOTRvWGJxY3pPbXJBVXFqNkt5OXdLWCtCaXllc2wyQWVqR0FWVG9KcFFzcmRoVGZ4K3BGalBEL0JBUlhuYjB5NmRkRG1WUUF0OUE0Q0xpRjJqcVpVbHhidDdMdWlEVWJoVHV4UXRjbHFaN0VGVk42VUhSUVBIREZwNnplQXdVc1hPNjRmeDYrZi84OERDRy8vcVJwbUgzRmluZ1FTTUZ5ZFZuTWVsdjNrUHQxTXQxM3prRENyVGZYMXV3Rmg3N1ZaNmtMNjBnZUdtVzJTclJLaDFaeGRYMitFTXpxZ1MyQXNmcTJIaXViZ0FIMkZNSGJIMzU4UDl6Nzh4eUdrRmVjc0JobWYyZUZRLy9vQUVKWnNpckxjblFaUkxLRFZiaTIrTWE2VzR0MkFDS0F3aThPUWtJRG5HZ013SlhlQm5RMFVpSm5BUkVjRXNuOFBGZzlWemFxc2tuamdQc2Vtb2Z6cnQwN0dBaGVYb0RnOGxlc2dOamF1TDdVL01ZQnd4bkZBNFoyTjBnV1NKbkRLQzFRdUlMcmVJRmZncm1pTVlCNFFNa1F5SlFJdWRvVmlMWVVLSjlOUGpCRnpRaVRTTjN2ZlEvbGNQNkFJRGpqeE1Yd3h0OWM1aXN1QjBQUG9VenVDREtLVzczSUYrNUVLWThzblRjTWsrVUlPcjdJSEhDYXF3RUVLTC9mWHRvMWtLTjRrb29QOXlSY0JPaWdFU1FvSnBFcWZxakh2di9CSEM3NFdIRzJQeEFJM2ppekZONzQ0aG9FNEFSdHBDOFV5dFRLRGI0YmJLRFlLTFRELzR2dG4xS21yL0FJOWJjdUlNRUFNdUFEcS9oY0tyNWhBN3NiZ1BiOEFFdytUSHdReEszeS9vSUpMaHdRQkJjV0lMaHdacG1sYVFERGJENkZCK1dpVm00dWxlcUNoN1QvdDB3USttdDJEZkpzd21PRnBBdW9KajhQTXVCempvYTE0amtiaUxnaDRpSmFNTUVFNGl4NnlRU1gvTTArMk52dmY4UHJsQXNLRUpSWGJIZFFMUzRnV0tyblFaaFZidU15TEJNRVY0Q09xOGhVZkNBT2toUXI2Q05odXd0dzZCK2FxNlovc3dWa3dEQ2dZRlJ2M0VEYm5rTHcxL1E3Z1FqM1U0OTk1ejFINGVLUDdCME1CT2VmdXJTNmhQVlEzT0pIMXRWWTk3anVBTVVPUWxwdmVNZmdzZ0NyWitnK1YrOG1tbk1BN3hJK3VzM2pBSkZsd2JyRHdaQmVtUFpVa0VBeXdhUUFhSU5OdVJPNTg5Nmo4S1pyOWd3R2d2TUtBSnczc3hRczdhTlJCRHI1emZzRHoySzV4V2RrQVdiOFBtbUx0a2ZCYU9vNGw5N3p5MzIrV2xoQjdhQmlBZ3BSUFhHcnArQkNDTXdad0tUL1ZGejdRaWFYVE5NbzZNNTc1K0dxR3c3QVVMTGh0NWJDMlNjdkVSUWUvTHdDZ1lrRHdGVjhBSVYxSVhySElHTUllWENVUlJTT0ZHZUY2RGVCM2p2bThMNmF3THdiYnhPMUlwRGk3OVJydjg4L3JWcXdLT3RxeHVGZjRIeitsc05WM3Z2UFdRRkR5RnRPWHdiN0R4TGNkTnNqY2x3SXoxakZCTTM4MENzUGVjMWJSUGttRXNYM0VxRk1mUWRRajFHbDFiY0NxZGlxS1J0OUVOSVJoWWxQdDdneTYzUlllRklnWUFDcEc5aDhHTUFGS0NXd3F4bmpYd29RbEQ3NXZRT0I0STlldmJ3YTk4dTNIYkVnWUFyd2xPb3FHcVNTdVVxMDhrMVo4d2RaVlhhb3R2eDdBUlJWZ1B0UmFHUEZsWVJUUFBjTFdvS0FGTmJPV3NHRWJvRENMeUk0Q2hsZEpSTTg0WmN5dVBDMFlmN1c4RHZQWGw2QTZpQjgrZHVQK0IrUEFnY2hHb1lTeXRmTUlmSXRTTUk5Q21QVWRVRFV0eVZqL1ljUm96SXlkYzFYc3Z5dlNDdEFoSVZpakRDSi9nbUVTMEdTOHgzOS9mMlF2dTRMbzcvcGU4RkFJSGpUeTVmQ3J2dm1ZZGY5ODFieGFnNTh2YXEvVkFKNkRSMkd3S0JnelJ5aFRwMHYxaEU3cmI4c04rOEMrTmwrQ041VTlDKzJleEJlOURTQklJQTVPV3kyWitMN0FEN2Vnb1ZFMEtkM01QeVZkcE4zL1kwSDRmb3ZIb1FoWk1WU2hEKzVlQVU4NVFsVElaS3YxNGVmM2FNTzNrZ0hmRjRnaDg3QlVOZ3BpTE1CRStTcE1ja1BEalBnUjc3OERFQXAwTDRRSXJHZnQ5RS8yRjBFQTVtb040RlVGdVBzd1ZHTjFjeWRnMkRMRjRZRHdSOWZ0QUtlM0lJQVJPUXRsUVJXK1kxQ25RTWdwTEI3MERzRkFZaGNiVG5OaGU2VmdUcjRRWGJ4TXY1Q1NDeXVPQ0NTZFRXckNPWHp3eWVZUUp3eHROWEp2QURhTFFVSXR0NDRFQWlXSVZ4NWNRQ0JWblF6UG45TEdCU3JMZHdIaUdZQzhXMENlMmJ6SWFuYVJzcVRRSFZVS0E2RW5QeVdFYmhiaUIzd2NFcldib0lyYmxJaENsU2Z4NnhmNTQzcWx3RDQ0aTJQd0JCU2d1RFNEY3ZnVjRwQXM2RjFDUUtiMW04QkF6QmlwNFhPc1M4SFJmMWhpS2R3dlJhamd5Q2xjTzl3SjV6MU0wYmdsdCtBcGUySGpKc1E0TkJ0SndTQmZEQUM4Y2taZ1hOVUxLOFAvTjArK05KQUlDaVZmOFh2TDY5K28weEFNWXJXMW94dUhYdFNLTm1BdXhPUEVUZ3pSRjRIZy9rdXdHVUVRYW5FM0FVWXl2Zm9INWlybUVTUUhNWWhBUDFObzExZ2FPZjd3Yi9kQnpkOWF6Z1FiSHJ6Y25pOEFBRTZ2dHVDSSs0S0dEdTB2NUhYeDhTL0o5QWcwaTZnVWFhNitDTHFLRitrMlk3QSs5UUx5YmJuakRHWThzbTNMQjZmZUdYQkhRQjg1Si8ydzMvZk04ejNoWThybEgvNW0yTk00TGdDQnh3eUtQUjNBclpmWndlUWcvOTJNSGQyQWVhTm9GSW9HQVZEUy90aW05ZlN2MVlFbUx5SjR3Qkh1VDRvMUd0clZiYi9BTUc3cnQ0ekhBZ2VnL0QrTjZmZGdXVUNUOW1KZEM0QllkbUFNWUw3UVFoSlduUS9CcW51TFVCUXZEQUNOeDdnZnIvcHg3eTltMUFhQlJyUVVvd1ZLRkpHY0tBQXdhV2Jod1hCZTkvQ1FlQlRzc3NFMEFVR1NDaWV2eDIwNDRXM2dXTGh5Rkk4VzlTVXUvQi8vWDVNWDBOSTJTZlVEd2tzbHVGajFMOHRHMmhnMUhYS0Z6MVhmbXd2L09TaEhJYVFFZ1R2ZWVzeVdMbE1XWHZ6YnNBREkzUUVnRENxazBIY0RSaFhRRFlZemJRQzJyTnpUOGtxeVBLVUxIOTljQmhXbUVRb2J1a2NDTGJNQVVFZThuNzZRQTd2K1lzOThOTUhod0hCWXdzUVhGYUFvRHcwYXRZNDZnckF1Z1Y3VnVERkRkNUJrV1FZODMxZzZ4ZHpiYWxrWXdMUTBUNjVqQkM3dENzUlkwMGcyREdtUGdyV3ROK0NFemdRQUg1V2dPQzltNGNEd1hISFpuRHBIeXdkZ1VBb2F3U0trVlZiS3BkV2ExbkQyMUZrQWhUeTdJQWJvMzhPSUJUbXB6bGxCbjlQQ1RZZzhXMmdZSklKcEgzNTFHSHQwSUpQUGhOL0JnMktCZ1R2SzVqZ1p3T0M0TjB0Q094Y3BjOW1iQUdTOHZsMkwyN3B1bS9yQ3Z4UHd0aiszck5ZZXdJWWdqbVA4bU9BR1dRWFFCSGFCM0RCNW9PRURHQjQrb0VDQk8rL2F1OWdJRmhiZ09DY1Z5MXVsWlVCUklFcmxhcVZ6K1lMVU1jVUdKZ0VBbmd5VlNmVWpWSStXTXYzam9VVGx3U0JCZEVnN3dJZ05oYytqbElzT0NBd2VTU0E4RUNoL0E5Y3M2L2FKUXdocC96R0ZKeC83aEpCK1JpTkEvd2o1ZkJNWGY0ZkFXUHZCTFFGeFpTb0Y5WmpCemZxaHlZUEpPM3phMEp4VC9yRUFrbGxncU5ncnZTWW03anI3bm5ZVkREQlVDQTQrWGxUc09IY3hjNmNPWDJqZWphVVZrL3hqMGhqU2hkdXdRdjhZb0VhWndZYzgxZmNLMlZNSkZ4NVJCQm5KUkpqNnp3TmVydExHTjJYSUxqaXovZkNVRktDNERXdlhoUVVDUmJFYmt4QVV2a2NJUG90b2EzRHlvb0gzdTFaUFRwNW5pTGR4UWE1OENpWUlMS3JtRlRhY1NuUU9UZ1dMaFNzcUIrMDBsVWY5ZjJQQ3hCOGRNdHdYeHFmT2pNTnA1OCt6ZWljV3pGakJZaTRBYkl1aEZ0OWlBVlFYN3ZMZnladWJxVFJrYkRQL1VJZSt4WUplVDdWZWFvTWRWLzh2djU4ekMxYm9BaEtiQzhLSDAzVmN4dDlpa1dqNy9OSTFlVjU2UFRKODRvL2J2N0dJMVg2NHZPSCtWL0hHd0I4OGZQenphekR1b0plMjhBRUlWWGZJNjlYMzVHL3hzVlQ3eTZDdy9uYk1XTDFiY1BtWG04UkFhSk00WldqWWduay9TOVlTTEtPK3ZYZFFxUU5ZeEZ4RDR4QjJQM1hDaEI4L0pQRGZGQlN5c3NLRUx6MGpHbGg4ZGJhSStjQ0FHYUw2QVdHZ2lIeS9PR3NlS1c0MDZWd0FCc1E2YlJTWm5wUldUMXc2aTVRQW0wejViRGYwUmhlR2RrMGdPTWluR2RqYy83U1RZZGgyMmNQdzFEeTB0T25BZ2owQlpITDFMVUhRNTVyQU1JZDB6bmd6b3lVMXNsU2h2bnlsNlZqNHJrQ1lCTnZaTS8rSE83NzZYeTBmVXIyN2E4blFlMGZvQWl3bmp1TmJ1cWZvSFJGcDhoQTFicUZoSXNvL3JqaG53OVY5eTg0WmJFYVBTNllTRC8xYVJuY1JQVlh4c2ptUno3MWh6ejJKL3J6NEhtTHB2S2R1RzVtMTVwc2VzbXVJcjNHcTlUbWFkK0NjdEhNd09vWDBWbGtaR2xXbnFHdGg2cGVwVGplRG1zS0ZHMHc1TE04WGNlazJYMW04b01Td2ozS09sNjZYWXRZSFFCUTlTVUFyTExsM3lhU29PZS90c1pJTmwyVFliWjd4L3E1QXV3N1k5Ry9qZ09pOUI2aGVvejFCWDdmeVBMUnFSL0dJdkMzZHFCMklIbzhTcnNDZldZQWNtN1lzUWF5TDVBdVZkTTU4WHJvVUgxc080YzlLVitlQmFnMk84bzVqZjVQSk1wdmNNOERZTFNsRXVjQXdPNzVyOG9YNXdjUStndmJOQ2V0RlJnQkEwL0xReWV2UGpsZ0lxVTRzbU5xY0xDMlFubnFYZ05ES3BxeEIwSEV2N3ZLa3VXaWowaDlKMSt1N2Z6V0ZnQjVmbVJMa1RtbkF4eU1LTVN6K0NnTEVGdFEzWi9wdndubU5JaVlZc0FmcHdHRHp6QWVPTHd6Z2NBQzRPUVp4VU1jQ0ViSm50SkFycldzTHlrZjFUb21sUThnM0lCM3dkS3BiZEFBWU9RRzhxM3RiQnhsY2FvVzlNN3kzYllBVVFXaW8waXRxRkdhQWlNNWZjcmZVRTh6aFFVUEJ3YUZjZlhZb01iUXo5ejJFUUdDa3pkcWczN2RwcitZd2dFaVNzWjJIVk5YY1FDMFpYWXp6cFYxMi85bUs0ZnB6UkE1eXhjVzJUeTVkZ2NnVC9oU0N0TWc4S3phV25lakZQNGlTUzIrQUE2NTRJalJMd2VCMTU5djVXVDZjRUhpNU1WbzM1YWpWVFFIUTlzTzNlZnlybm1FVGMxMFdnRHMzdkdFM1FVTXRvSVc5UkRJSHloeEwzd21CNFVCaVYzd3VIV3JjWUFpbGcydFF0SDBUZkxabU9XM3o4anJzZXFCdGtrQ0JkU0Nld3BJNVpFY1c1ZURVcXFwcDBBQ3JMMW1rdUo0ZWN2c1IzQjM4MHppUDlxYmgvbFo1TEVBRzdCZERBVUU5UElCWEVzV3ltRldhUmdGNHN4aDVpUDZDR054QU5xNUJLMEt5b1V3TDQ4QldyQ1FiTWZuNHdKQjVSbFdhTXZRZFJWQ3ljejZnWHdseC9zQU9ESVZyTDhVQVlBaUZ0aGRMT2JWWW1ZZUdOUkRnMTRNRHd6azFJbUFKU2pPV1NtbEtNL2l2YjVRSzFnd0I1bTZmTHltSEozbjVuMjU2K1BWQjNCWklaUmhXRE9Tb05kMTY5cm1BZ0RETURuUkptNzlBTXFnR25ucWkrL2VYalNZTWY5dENXdlJEdEtrRVVVZHJNc1drbllQZnJDMmdsUmRWaStMNU1mU21YZkFnL1dIR1R3UE1ISXdOSHJEbGpvUUFxOHZpTmVYT3dGTzgrd2VmZnAzOUxaNzQxOWw2MVVSdVAvWDZqUWVQYi80RWE2Z2xaWU9RM3IwR3l3V0RhM3J1dklYWTFadDZ2Ym9VeWNjSm1pRXh3ZzhOaENmbEVGaVR2d1ptb1MyZmdMcjM1WGxvMWZHV0ZOYXZRb0tIUmZndUlUZGVBUlBCVWRjQU54UnVBTEs2SHllaHg0UTJIMHpJVkI1RFRWRFQxRHdoNVY5Z1BYdGpyakJIdWhGaklIWVdnOVhncndub1RUcEVxeGl0U0VaWlh2UDB0WkJvVlQzZVZRN25sL005SkxMdGtqcWJ5VDZ2eTMvYU1keDI0andFcjNPR0VPL3A4aUV4UXN3Z08zVHQydzJYbFVXd0tUSEc2WEptUWRaVm1qbXE4cUU4a0R1TmpRUUJVQ2JiSzF3WFljL2syS0Y2RE1EdUZzL0R5QjE1VTBiL3hxM1FVU1MvOTMyRDI5KzR1WmlEVGVCWS8zSmV3OGtHa2c4RVdNSFNQUXRXSUhNWXN1K25jN0lCMm1VYVVpMmJjY2luL2xpbGc5T0hqcGxta1VBNHBhdUpldzBhTk5sMTA3TlFrSTYvNy8xSDM1dDdTeVdJTkNLaWQwbjhqeW1BRkw1ZGFiZXc3dDllUU42SUhSY0RqcHRrZnordUZXN2xxeVVqbzV5WFo5ZjVhRnNDdzZMSkl3SEk3OEVkTWxsMTZXVlgwb25BRXE1c3dCQmNVcHdWdEh0Ym5NNnFCWWVlMW92bjJ5OHJucjZTRCtoM0JzY2hPTENIQzNkaTA0cGJYMWNYSkI2Rmg1Ym00aVNmZHFIbGlGMC8vWHZIT1Y0MXNicnBqWkREK2tGZ0ZMdXZIbjl0bXhxL3RRUkNFQStnSGdLaWl0SUM3TitqTlZYeWtxQ0JxUTdrUDZRbEtKNUc5dVhsNWU4RjJtUFVmdzJ4dUpUY3dNSHlCd1E1U3ZlSEUvYXVDWHU4N3Y2N3lYUGVPRmRzOFhHK2ZLMkUyU1RRcDdIUG9SbzZ0Uy9zWDA4cjh0L1J4OW1vTzNEMUJtTjIvY2NvSzBIM3BrQXFuYmUzcjlKaDdMbXIzRzE5STcrZmo5anRYZzVBUG9mbE1UdjU0cUE5K3JMdG5SVHZwYmVETURsanE4OXFRREEvUG9DY2x1cmpKVGxRc1EzUjlqQml4TU1QWnR4cEJXaHgwTHVMN2tXNlFwbm1RZ2J1YTVBbDNmV3c3WThaWjJCQlhETEk0UW5MVVQ1dko4Rnl6Tm1kcTNEUEpzdHJPYVZ4WnpYOE0vRHBOV2pZZ2VJbnZqcE9wbXlXdkFZQXNQaVpxNjFnM1A2SjYzYnNvRzEvQXhpK2Q1cDN1aGhzb2hGQythQTBJYW5RYlNESnJmOGltdnJQR1NiWnlQNys3NHlNUUFhS2I4dFhBNVRaeFlkYmlpdW1hcHpBUUFJeDhXdVlpRHFCbHBxYjh2UkFvQ2xGd1lBcFNnMjU2QllId0NaVU9Ta0FKQy9EQUFGemNQTzR1NkdvNUJ0S1JRL0J3UElZQURROHF5WlhUTVpaQ2NXKzRVWEY2T3N5WkRXRlErOERxS0tXVGdBTWhjSTR3SEFLTGF0RSt3dUNvQzZMSzVjRHdDb0FDYktkeGQ5RmdyR25jVXJuTnRIdjlNN2gxSTZsLzhGQVZPMnltNURQU0lBQUFBQVNVVk9SSzVDWUlJPVwiLFxuICBtZXRhbWFzazogXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmODtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1USWlJR2hsYVdkb2REMGlNVGc1SWlCMmFXVjNRbTk0UFNJd0lEQWdNakV5SURFNE9TSStQR2NnWm1sc2JEMGlibTl1WlNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lqNDhjRzlzZVdkdmJpQm1hV3hzUFNJalEwUkNSRUl5SWlCd2IybHVkSE05SWpZd0xqYzFJREUzTXk0eU5TQTRPQzR6TVRNZ01UZ3dMalUyTXlBNE9DNHpNVE1nTVRjeElEa3dMalUyTXlBeE5qZ3VOelVnTVRBMkxqTXhNeUF4TmpndU56VWdNVEEyTGpNeE15QXhPREFnTVRBMkxqTXhNeUF4T0RjdU9EYzFJRGc1TGpRek9DQXhPRGN1T0RjMUlEWTRMall5TlNBeE56Z3VPRGMxSWk4K1BIQnZiSGxuYjI0Z1ptbHNiRDBpSTBORVFrUkNNaUlnY0c5cGJuUnpQU0l4TURVdU56VWdNVGN6TGpJMUlERXpNaTQzTlNBeE9EQXVOVFl6SURFek1pNDNOU0F4TnpFZ01UTTFJREUyT0M0M05TQXhOVEF1TnpVZ01UWTRMamMxSURFMU1DNDNOU0F4T0RBZ01UVXdMamMxSURFNE55NDROelVnTVRNekxqZzNOU0F4T0RjdU9EYzFJREV4TXk0d05qTWdNVGM0TGpnM05TSWdkSEpoYm5ObWIzSnRQU0p0WVhSeWFYZ29MVEVnTUNBd0lERWdNalUyTGpVZ01Da2lMejQ4Y0c5c2VXZHZiaUJtYVd4c1BTSWpNemt6T1RNNUlpQndiMmx1ZEhNOUlqa3dMalUyTXlBeE5USXVORE00SURnNExqTXhNeUF4TnpFZ09URXVNVEkxSURFMk9DNDNOU0F4TWpBdU16YzFJREUyT0M0M05TQXhNak11TnpVZ01UY3hJREV5TVM0MUlERTFNaTQwTXpnZ01URTNJREUwT1M0Mk1qVWdPVFF1TlNBeE5UQXVNVGc0SWk4K1BIQnZiSGxuYjI0Z1ptbHNiRDBpSTBZNE9VTXpOU0lnY0c5cGJuUnpQU0kzTlM0ek56VWdNamNnT0RndU9EYzFJRFU0TGpVZ09UVXVNRFl6SURFMU1DNHhPRGdnTVRFM0lERTFNQzR4T0RnZ01USXpMamMxSURVNExqVWdNVE0yTGpFeU5TQXlOeUl2UGp4d2IyeDVaMjl1SUdacGJHdzlJaU5HT0RsRU16VWlJSEJ2YVc1MGN6MGlNVFl1TXpFeklEazJMakU0T0NBdU5UWXpJREUwTVM0M05TQXpPUzQ1TXpnZ01UTTVMalVnTmpVdU1qVWdNVE01TGpVZ05qVXVNalVnTVRFNUxqZ3hNeUEyTkM0eE1qVWdOemt1TXpFeklEVTRMalVnT0RNdU9ERXpJaTgrUEhCdmJIbG5iMjRnWm1sc2JEMGlJMFE0TjBNek1DSWdjRzlwYm5SelBTSTBOaTR4TWpVZ01UQXhMakkxSURreUxqSTFJREV3TWk0ek56VWdPRGN1TVRnNElERXlOaUEyTlM0eU5TQXhNakF1TXpjMUlpOCtQSEJ2YkhsbmIyNGdabWxzYkQwaUkwVkJPRVF6UVNJZ2NHOXBiblJ6UFNJME5pNHhNalVnTVRBeExqZ3hNeUEyTlM0eU5TQXhNVGt1T0RFeklEWTFMakkxSURFek55NDRNVE1pTHo0OGNHOXNlV2R2YmlCbWFXeHNQU0lqUmpnNVJETTFJaUJ3YjJsdWRITTlJalkxTGpJMUlERXlNQzR6TnpVZ09EY3VOelVnTVRJMklEazFMakEyTXlBeE5UQXVNVGc0SURrd0lERTFNeUEyTlM0eU5TQXhNemd1TXpjMUlpOCtQSEJ2YkhsbmIyNGdabWxzYkQwaUkwVkNPRVl6TlNJZ2NHOXBiblJ6UFNJMk5TNHlOU0F4TXpndU16YzFJRFl3TGpjMUlERTNNeTR5TlNBNU1DNDFOak1nTVRVeUxqUXpPQ0l2UGp4d2IyeDVaMjl1SUdacGJHdzlJaU5GUVRoRk0wRWlJSEJ2YVc1MGN6MGlPVEl1TWpVZ01UQXlMak0zTlNBNU5TNHdOak1nTVRVd0xqRTRPQ0E0Tmk0Mk1qVWdNVEkxTGpjeE9TSXZQanh3YjJ4NVoyOXVJR1pwYkd3OUlpTkVPRGRETXpBaUlIQnZhVzUwY3owaU16a3VNemMxSURFek9DNDVNemdnTmpVdU1qVWdNVE00TGpNM05TQTJNQzQzTlNBeE56TXVNalVpTHo0OGNHOXNlV2R2YmlCbWFXeHNQU0lqUlVJNFJqTTFJaUJ3YjJsdWRITTlJakV5TGprek9DQXhPRGd1TkRNNElEWXdMamMxSURFM015NHlOU0F6T1M0ek56VWdNVE00TGprek9DQXVOVFl6SURFME1TNDNOU0l2UGp4d2IyeDVaMjl1SUdacGJHdzlJaU5GT0RneU1VVWlJSEJ2YVc1MGN6MGlPRGd1T0RjMUlEVTRMalVnTmpRdU5qZzRJRGM0TGpjMUlEUTJMakV5TlNBeE1ERXVNalVnT1RJdU1qVWdNVEF5TGprek9DSXZQanh3YjJ4NVoyOXVJR1pwYkd3OUlpTkVSa05GUXpNaUlIQnZhVzUwY3owaU5qQXVOelVnTVRjekxqSTFJRGt3TGpVMk15QXhOVEl1TkRNNElEZzRMak14TXlBeE56QXVORE00SURnNExqTXhNeUF4T0RBdU5UWXpJRFk0TGpBMk15QXhOell1TmpJMUlpOCtQSEJ2YkhsbmIyNGdabWxzYkQwaUkwUkdRMFZETXlJZ2NHOXBiblJ6UFNJeE1qRXVOU0F4TnpNdU1qVWdNVFV3TGpjMUlERTFNaTQwTXpnZ01UUTRMalVnTVRjd0xqUXpPQ0F4TkRndU5TQXhPREF1TlRZeklERXlPQzR5TlNBeE56WXVOakkxSWlCMGNtRnVjMlp2Y20wOUltMWhkSEpwZUNndE1TQXdJREFnTVNBeU56SXVNalVnTUNraUx6NDhjRzlzZVdkdmJpQm1hV3hzUFNJak16a3pPVE01SWlCd2IybHVkSE05SWpjd0xqTXhNeUF4TVRJdU5TQTJOQzR4TWpVZ01USTFMalF6T0NBNE5pNHdOak1nTVRFNUxqZ3hNeUlnZEhKaGJuTm1iM0p0UFNKdFlYUnlhWGdvTFRFZ01DQXdJREVnTVRVd0xqRTRPQ0F3S1NJdlBqeHdiMng1WjI5dUlHWnBiR3c5SWlORk9EaEdNelVpSUhCdmFXNTBjejBpTVRJdU16YzFJQzQxTmpNZ09EZ3VPRGMxSURVNExqVWdOelV1T1RNNElESTNJaTgrUEhCaGRHZ2dabWxzYkQwaUl6aEZOVUV6TUNJZ1pEMGlUVEV5TGpNM05UQXdNRElzTUM0MU5qSTFNREF3TURnZ1RESXVNalV3TURBd01ETXNNekV1TlRBd01EQXdOU0JNTnk0NE56VXdNREF4TWl3Mk5TNHlOVEF3TURFZ1RETXVPVE0zTlRBd01EWXNOamN1TlRBd01EQXhJRXc1TGpVMk1qVXdNREUwTERjeUxqVTJNalVnVERVdU1EWXlOVEF3TURnc056WXVOVEF3TURBeE1TQk1NVEV1TWpVc09ESXVNVEkxTURBeE1pQk1OeTR6TVRJMU1EQXhNU3c0TlM0MU1EQXdNREV6SUV3eE5pNHpNVEkxTURBeUxEazJMamMxTURBd01UUWdURFU0TGpVd01EQXdNRGtzT0RNdU9ERXlOVEF4TWlCRE56a3VNVEkxTURBeE1pdzJOeTR6TVRJMU1EQTBJRGc1TGpJMU1EQXdNVE1zTlRndU9EYzFNREF3TXlBNE9DNDROelV3TURFekxEVTRMalV3TURBd01Ea2dRemc0TGpVd01EQXdNVE1zTlRndU1USTFNREF3T1NBMk15NHdNREF3TURBNUxETTRMamd4TWpVd01EWWdNVEl1TXpjMU1EQXdNaXd3TGpVMk1qVXdNREF3T0NCYUlpOCtQR2NnZEhKaGJuTm1iM0p0UFNKdFlYUnlhWGdvTFRFZ01DQXdJREVnTWpFeExqVWdNQ2tpUGp4d2IyeDVaMjl1SUdacGJHdzlJaU5HT0RsRU16VWlJSEJ2YVc1MGN6MGlNVFl1TXpFeklEazJMakU0T0NBdU5UWXpJREUwTVM0M05TQXpPUzQ1TXpnZ01UTTVMalVnTmpVdU1qVWdNVE01TGpVZ05qVXVNalVnTVRFNUxqZ3hNeUEyTkM0eE1qVWdOemt1TXpFeklEVTRMalVnT0RNdU9ERXpJaTgrUEhCdmJIbG5iMjRnWm1sc2JEMGlJMFE0TjBNek1DSWdjRzlwYm5SelBTSTBOaTR4TWpVZ01UQXhMakkxSURreUxqSTFJREV3TWk0ek56VWdPRGN1TVRnNElERXlOaUEyTlM0eU5TQXhNakF1TXpjMUlpOCtQSEJ2YkhsbmIyNGdabWxzYkQwaUkwVkJPRVF6UVNJZ2NHOXBiblJ6UFNJME5pNHhNalVnTVRBeExqZ3hNeUEyTlM0eU5TQXhNVGt1T0RFeklEWTFMakkxSURFek55NDRNVE1pTHo0OGNHOXNlV2R2YmlCbWFXeHNQU0lqUmpnNVJETTFJaUJ3YjJsdWRITTlJalkxTGpJMUlERXlNQzR6TnpVZ09EY3VOelVnTVRJMklEazFMakEyTXlBeE5UQXVNVGc0SURrd0lERTFNeUEyTlM0eU5TQXhNemd1TXpjMUlpOCtQSEJ2YkhsbmIyNGdabWxzYkQwaUkwVkNPRVl6TlNJZ2NHOXBiblJ6UFNJMk5TNHlOU0F4TXpndU16YzFJRFl3TGpjMUlERTNNeTR5TlNBNU1DQXhOVE1pTHo0OGNHOXNlV2R2YmlCbWFXeHNQU0lqUlVFNFJUTkJJaUJ3YjJsdWRITTlJamt5TGpJMUlERXdNaTR6TnpVZ09UVXVNRFl6SURFMU1DNHhPRGdnT0RZdU5qSTFJREV5TlM0M01Ua2lMejQ4Y0c5c2VXZHZiaUJtYVd4c1BTSWpSRGczUXpNd0lpQndiMmx1ZEhNOUlqTTVMak0zTlNBeE16Z3VPVE00SURZMUxqSTFJREV6T0M0ek56VWdOakF1TnpVZ01UY3pMakkxSWk4K1BIQnZiSGxuYjI0Z1ptbHNiRDBpSTBWQ09FWXpOU0lnY0c5cGJuUnpQU0l4TWk0NU16Z2dNVGc0TGpRek9DQTJNQzQzTlNBeE56TXVNalVnTXprdU16YzFJREV6T0M0NU16Z2dMalUyTXlBeE5ERXVOelVpTHo0OGNHOXNlV2R2YmlCbWFXeHNQU0lqUlRnNE1qRkZJaUJ3YjJsdWRITTlJamc0TGpnM05TQTFPQzQxSURZMExqWTRPQ0EzT0M0M05TQTBOaTR4TWpVZ01UQXhMakkxSURreUxqSTFJREV3TWk0NU16Z2lMejQ4Y0c5c2VXZHZiaUJtYVd4c1BTSWpNemt6T1RNNUlpQndiMmx1ZEhNOUlqY3dMak14TXlBeE1USXVOU0EyTkM0eE1qVWdNVEkxTGpRek9DQTROaTR3TmpNZ01URTVMamd4TXlJZ2RISmhibk5tYjNKdFBTSnRZWFJ5YVhnb0xURWdNQ0F3SURFZ01UVXdMakU0T0NBd0tTSXZQanh3YjJ4NVoyOXVJR1pwYkd3OUlpTkZPRGhHTXpVaUlIQnZhVzUwY3owaU1USXVNemMxSUM0MU5qTWdPRGd1T0RjMUlEVTRMalVnTnpVdU9UTTRJREkzSWk4K1BIQmhkR2dnWm1sc2JEMGlJemhGTlVFek1DSWdaRDBpVFRFeUxqTTNOVEF3TURJc01DNDFOakkxTURBd01EZ2dUREl1TWpVd01EQXdNRE1zTXpFdU5UQXdNREF3TlNCTU55NDROelV3TURBeE1pdzJOUzR5TlRBd01ERWdURE11T1RNM05UQXdNRFlzTmpjdU5UQXdNREF4SUV3NUxqVTJNalV3TURFMExEY3lMalUyTWpVZ1REVXVNRFl5TlRBd01EZ3NOell1TlRBd01EQXhNU0JNTVRFdU1qVXNPREl1TVRJMU1EQXhNaUJNTnk0ek1USTFNREF4TVN3NE5TNDFNREF3TURFeklFd3hOaTR6TVRJMU1EQXlMRGsyTGpjMU1EQXdNVFFnVERVNExqVXdNREF3TURrc09ETXVPREV5TlRBeE1pQkROemt1TVRJMU1EQXhNaXcyTnk0ek1USTFNREEwSURnNUxqSTFNREF3TVRNc05UZ3VPRGMxTURBd015QTRPQzQ0TnpVd01ERXpMRFU0TGpVd01EQXdNRGtnUXpnNExqVXdNREF3TVRNc05UZ3VNVEkxTURBd09TQTJNeTR3TURBd01EQTVMRE00TGpneE1qVXdNRFlnTVRJdU16YzFNREF3TWl3d0xqVTJNalV3TURBd09DQmFJaTgrUEM5blBqd3ZaejQ4TDNOMlp6ND1cIixcbiAgZm9yZGVmaTogXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNalFpSUdobGFXZG9kRDBpTWpRaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajRLUEdjZ1kyeHBjQzF3WVhSb1BTSjFjbXdvSTJOc2FYQXdYekV6TkRrMFh6WTJNalUwS1NJK0NqeHdZWFJvSUdROUlrMHhNQzQ0TnpZNUlERTFMall6TnpoSU1TNDFWakU0TGpNNU9VTXhMalVnTVRrdU9EQXhNeUF5TGpZek5EUTNJREl3TGprek9DQTBMakF6TXpreUlESXdMamt6T0VnNExqSTBPVGt5VERFd0xqZzNOamtnTVRVdU5qTTNPRm9pSUdacGJHdzlJaU0zT1RrMFJrWWlMejRLUEhCaGRHZ2daRDBpVFRFdU5TQTVMamMzTlRVeFNERTVMakExTVRaTU1UY3VNREV6T1NBeE15NDROekV4U0RFdU5WWTVMamMzTlRVeFdpSWdabWxzYkQwaUl6UTROa1JHUmlJdlBnbzhjR0YwYUNCa1BTSk5OeTQyTlRrNU5pQXpTREV1TlRJME5ERldPQzR3TURjd05FZ3lNaTQwTmpFeVZqTklNVFl1TXpJMU5sWTJMamN6T1RRMFNERTFMakEyTURaV00wZzRMamt5TlRBeVZqWXVOek01TkRSSU55NDJOVGs1TmxZeldpSWdabWxzYkQwaUl6VkRSREZHUVNJdlBnbzhMMmMrQ2p4a1pXWnpQZ284WTJ4cGNGQmhkR2dnYVdROUltTnNhWEF3WHpFek5EazBYelkyTWpVMElqNEtQSEpsWTNRZ2QybGtkR2c5SWpJeElpQm9aV2xuYUhROUlqRTRJaUJtYVd4c1BTSjNhR2wwWlNJZ2RISmhibk5tYjNKdFBTSjBjbUZ1YzJ4aGRHVW9NUzQxSURNcElpOCtDand2WTJ4cGNGQmhkR2crQ2p3dlpHVm1jejRLUEM5emRtYytDZz09XCJcbn07XG5jbGFzcyBUIGV4dGVuZHMgcyB7XG4gIGNvbnN0cnVjdG9yKHsgb3B0aW9uczogTSB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBpKHRoaXMsIFwiX3dhbGxldFwiKTtcbiAgICBpKHRoaXMsIFwiX29wdGlvbnNcIik7XG4gICAgdGhpcy5fb3B0aW9ucyA9IE07XG4gIH1cbiAgc3RhdGljIGdldEluamVjdGVkV2FsbGV0KE0pIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcz8uW2BzdGFya25ldF8ke019YF07XG4gIH1cbiAgc3RhdGljIGlzV2FsbGV0SW5qZWN0ZWQoTSkge1xuICAgIHJldHVybiAhIVQuZ2V0SW5qZWN0ZWRXYWxsZXQoTSk7XG4gIH1cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmlkO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmVuc3VyZVdhbGxldCgpLCB0aGlzLl9vcHRpb25zLm5hbWUgPz8gdGhpcy5fd2FsbGV0Py5uYW1lID8/IHRoaXMuX29wdGlvbnMuaWQ7XG4gIH1cbiAgZ2V0IGljb24oKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBjb25zdCBNID0ge1xuICAgICAgZGFyazogTFt0aGlzLmlkXSB8fCBVLFxuICAgICAgbGlnaHQ6IExbdGhpcy5pZF0gfHwgRVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuaWNvbiB8fCB0aGlzLl93YWxsZXQ/Lmljb24gfHwgTTtcbiAgfVxuICBhdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5zdXJlV2FsbGV0KCksIHRoaXMuX3dhbGxldCAhPT0gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGNoYWluSWQoKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBjb25zdCBNID0gYXdhaXQgdGhpcy5pc0xvY2tlZCgpO1xuICAgIGlmICghdGhpcy5fd2FsbGV0IHx8IE0pXG4gICAgICB0aHJvdyBuZXcgZygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBJID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHsgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdENoYWluSWRcIiB9KTtcbiAgICAgIHJldHVybiBCaWdJbnQoSSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgdygpO1xuICAgIH1cbiAgfVxuICBhc3luYyByZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnN1cmVXYWxsZXQoKSwgdGhpcy5fd2FsbGV0ID8gKGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICB0eXBlOiBcIndhbGxldF9nZXRQZXJtaXNzaW9uc1wiXG4gICAgfSkpPy5pbmNsdWRlcyh4LkFDQ09VTlRTKSA6ICExO1xuICB9XG4gIGFzeW5jIGFjY291bnQoTSkge1xuICAgIGlmICh0aGlzLmVuc3VyZVdhbGxldCgpLCBhd2FpdCB0aGlzLmlzTG9ja2VkKCkgfHwgIXRoaXMuX3dhbGxldClcbiAgICAgIHRocm93IG5ldyBnKCk7XG4gICAgY29uc3QgTiA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICB0eXBlOiBcIndhbGxldF9yZXF1ZXN0QWNjb3VudHNcIixcbiAgICAgIHBhcmFtczogeyBzaWxlbnRfbW9kZTogITAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgdChNLCB0aGlzLl93YWxsZXQsIHZvaWQgMCwgTlswXSk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChNID0ge30pIHtcbiAgICBpZiAodGhpcy5lbnN1cmVXYWxsZXQoKSwgIXRoaXMuX3dhbGxldClcbiAgICAgIHRocm93IG5ldyB3KCk7XG4gICAgbGV0IEk7XG4gICAgdHJ5IHtcbiAgICAgIEkgPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICB0eXBlOiBcIndhbGxldF9yZXF1ZXN0QWNjb3VudHNcIlxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgdSgpO1xuICAgIH1cbiAgICBpZiAoIUkpXG4gICAgICB0aHJvdyBuZXcgdSgpO1xuICAgIHRoaXMuX3dhbGxldC5vbihcImFjY291bnRzQ2hhbmdlZFwiLCBhc3luYyAoeikgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5vbkFjY291bnRzQ2hhbmdlZCh6KTtcbiAgICB9KSwgdGhpcy5fd2FsbGV0Lm9uKFwibmV0d29ya0NoYW5nZWRcIiwgKHosIGMpID0+IHtcbiAgICAgIHRoaXMub25OZXR3b3JrQ2hhbmdlZCh6LCBjKTtcbiAgICB9KSwgYXdhaXQgdGhpcy5vbkFjY291bnRzQ2hhbmdlZChJKTtcbiAgICBjb25zdCBbTl0gPSBJLCBqID0gYXdhaXQgdGhpcy5jaGFpbklkKCk7XG4gICAgcmV0dXJuIHRoaXMuZW1pdChcImNvbm5lY3RcIiwgeyBhY2NvdW50OiBOLCBjaGFpbklkOiBqIH0pLCB7XG4gICAgICBhY2NvdW50OiBOLFxuICAgICAgY2hhaW5JZDogalxuICAgIH07XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5lbnN1cmVXYWxsZXQoKSwgQygpLCAhdGhpcy5fd2FsbGV0KVxuICAgICAgdGhyb3cgbmV3IHcoKTtcbiAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIpO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QoTSkge1xuICAgIGlmICh0aGlzLmVuc3VyZVdhbGxldCgpLCAhdGhpcy5fd2FsbGV0KVxuICAgICAgdGhyb3cgbmV3IGcoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3dhbGxldC5yZXF1ZXN0KE0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IHUoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaXNMb2NrZWQoKSB7XG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzXCIsXG4gICAgICBwYXJhbXM6IHsgc2lsZW50X21vZGU6ICEwIH1cbiAgICB9KSkubGVuZ3RoID09PSAwO1xuICB9XG4gIGVuc3VyZVdhbGxldCgpIHtcbiAgICBjb25zdCBNID0gVC5nZXRJbmplY3RlZFdhbGxldCh0aGlzLl9vcHRpb25zLmlkKTtcbiAgICBNICYmICh0aGlzLl93YWxsZXQgPSBNKTtcbiAgfVxuICBhc3luYyBvbkFjY291bnRzQ2hhbmdlZChNKSB7XG4gICAgaWYgKCFNKVxuICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IFtJXSA9IE07XG4gICAgICBpZiAoSSkge1xuICAgICAgICBjb25zdCBOID0gYXdhaXQgdGhpcy5jaGFpbklkKCk7XG4gICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB7IGFjY291bnQ6IEksIGNoYWluSWQ6IE4gfSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiKTtcbiAgICB9XG4gIH1cbiAgb25OZXR3b3JrQ2hhbmdlZChNLCBJKSB7XG4gICAgaWYgKE0pIHtcbiAgICAgIGNvbnN0IE4gPSBCaWdJbnQoTSksIFtqXSA9IEkgfHwgW107XG4gICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgeyBjaGFpbklkOiBOLCBhY2NvdW50OiBqIH0pO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHt9KTtcbiAgfVxuICBnZXQgd2FsbGV0KCkge1xuICAgIGlmICghdGhpcy5fd2FsbGV0KVxuICAgICAgdGhyb3cgbmV3IGcoKTtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0O1xuICB9XG59XG5leHBvcnQge1xuICBsIGFzIEEsXG4gIFQgYXMgSVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-9bb48f8a.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-d4f30f2e.js":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-d4f30f2e.js ***!
  \***************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ U),\n/* harmony export */   a: () => (/* binding */ G),\n/* harmony export */   i: () => (/* binding */ B),\n/* harmony export */   r: () => (/* binding */ p)\n/* harmony export */ });\n/* harmony import */ var _core_d21d2e96_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core-d21d2e96.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/core-d21d2e96.js\");\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! starknet */ \"(ssr)/./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lastConnected-e9351912.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/lastConnected-e9351912.js\");\n/* harmony import */ var _getStarknetChainId_7c4b3163_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getStarknetChainId-7c4b3163.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/getStarknetChainId-7c4b3163.js\");\n/* harmony import */ var _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index-9bb48f8a.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-9bb48f8a.js\");\nvar N = Object.defineProperty;\nvar v = (e, n, t) => n in e ? N(e, n, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[n] = t;\nvar l = (e, n, t) => (v(e, typeof n != \"symbol\" ? n + \"\" : n, t), t);\n\n\n\n\n\nconst L = {\n  mainnet: \"https://starknet-mainnet.public.blastapi.io\",\n  testnet: \"https://starknet-sepolia.public.blastapi.io\"\n}, O = {\n  mainnet: \"https://rpc.starknet.lava.build\",\n  testnet: \"https://rpc.starknet-sepolia.lava.build\"\n}, d = [L, O];\nfunction q() {\n  const e = Math.floor(Math.random() * d.length);\n  return d[e];\n}\nconst W = () => Object.keys(localStorage).some(\n  (e) => e === \"walletconnect\" || e.startsWith(\"wc@2:\")\n), p = () => {\n  if (W()) {\n    delete localStorage.walletconnect;\n    for (const e in localStorage)\n      e.startsWith(\"wc@2:\") && delete localStorage[e];\n  }\n}, _ = \"f2e613881f7a0e811295cdd57999e31b\", g = `<svg\n    width=\"32\"\n    height=\"32\"\n    viewBox=\"0 0 32 32\"\n    fill=\"none\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <rect width=\"32\" height=\"32\" rx=\"8\" fill=\"#FF875B\" />\n    <path\n      d=\"M18.316 8H13.684C13.5292 8 13.4052 8.1272 13.4018 8.28531C13.3082 12.7296 11.0323 16.9477 7.11513 19.9355C6.99077 20.0303 6.96243 20.2085 7.05335 20.3369L9.76349 24.1654C9.85569 24.2957 10.0353 24.3251 10.1618 24.2294C12.6111 22.3734 14.5812 20.1345 16 17.6529C17.4187 20.1345 19.389 22.3734 21.8383 24.2294C21.9646 24.3251 22.1443 24.2957 22.2366 24.1654L24.9467 20.3369C25.0375 20.2085 25.0092 20.0303 24.885 19.9355C20.9676 16.9477 18.6918 12.7296 18.5983 8.28531C18.5949 8.1272 18.4708 8 18.316 8Z\"\n      fill=\"white\"\n    />\n  </svg>`, B = () => typeof window > \"u\" || !window?.starknet_argentX ? !1 : window?.starknet_argentX?.isInAppBrowser;\nclass U extends _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.C {\n  constructor(t) {\n    super();\n    l(this, \"_wallet\", null);\n    l(this, \"_options\");\n    this._options = t;\n  }\n  available() {\n    return !0;\n  }\n  async ready() {\n    if (!this._wallet)\n      return !1;\n    try {\n      return (await this._wallet.request({\n        type: \"wallet_getPermissions\"\n      })).includes(_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.P.ACCOUNTS);\n    } catch {\n      return !1;\n    }\n  }\n  get id() {\n    return \"argentMobile\";\n  }\n  get name() {\n    return \"Argent (mobile)\";\n  }\n  get icon() {\n    return {\n      dark: g,\n      light: g\n    };\n  }\n  get wallet() {\n    if (!this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.a();\n    return this._wallet;\n  }\n  async connect(t = {}) {\n    if (await this.ensureWallet(), !this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.b();\n    const o = await this._wallet.request({\n      type: \"wallet_requestAccounts\"\n    }), s = await this.chainId();\n    return {\n      account: o[0],\n      chainId: s\n    };\n  }\n  async disconnect() {\n    if (await this._wallet.disable(), p(), !this.available() && !this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.b();\n    this._wallet = null;\n  }\n  async account(t) {\n    if (!this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.a();\n    const o = await this._wallet.request({\n      type: \"wallet_requestAccounts\",\n      params: { silent_mode: !0 }\n    });\n    return new starknet__WEBPACK_IMPORTED_MODULE_1__.WalletAccount(t, this._wallet, void 0, o[0]);\n  }\n  async chainId() {\n    if (!this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.a();\n    const t = await this._wallet.request({\n      type: \"wallet_requestChainId\"\n    }), o = (0,_getStarknetChainId_7c4b3163_js__WEBPACK_IMPORTED_MODULE_3__.g)(t);\n    return BigInt(o);\n  }\n  async request(t) {\n    if (!this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.a();\n    try {\n      return await this._wallet.request(t);\n    } catch {\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.U();\n    }\n  }\n  // needed, methods required by starknet-react. Otherwise an exception is throwd\n  async initEventListener(t) {\n    if (!this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.a();\n    this._wallet.on(\"accountsChanged\", t);\n  }\n  // needed, methods required by starknet-react. Otherwise an exception is throwd\n  async removeEventListener(t) {\n    if (!this._wallet)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.a();\n    this._wallet.off(\"accountsChanged\", t), this._wallet = null;\n  }\n  async ensureWallet() {\n    const { getStarknetWindowObject: t } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50\").then(__webpack_require__.bind(__webpack_require__, /*! ./index-1c1d2b10.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-1c1d2b10.js\")), { chainId: o, projectId: s, dappName: f, description: C, url: m, icons: I, rpcUrl: b } = this._options, r = q(), y = b ?? (!o || o === starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName.SN_MAIN ? r.mainnet : r.testnet), A = {\n      chainId: o ?? starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName.SN_MAIN,\n      name: f,\n      projectId: s ?? _,\n      description: C,\n      url: m,\n      icons: I,\n      rpcUrl: y\n    };\n    s === _ && (console.log(\"========= NOTICE =========\"), console.log(\n      \"While your application will continue to function, we highly recommended\"\n    ), console.log(\"signing up for your own API keys.\"), console.log(\n      \"Go to WalletConnect Cloud (https://cloud.walletconnect.com) and create a new account.\"\n    ), console.log(\n      \"Once your account is created, create a new project and collect the Project ID\"\n    ), console.log(\"==========================\"));\n    const i = await t(A);\n    if (!i)\n      throw new _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.U();\n    this._wallet = i;\n    const c = this._wallet;\n    await c.enable(), c.client.on(\"session_delete\", () => {\n      p(), this._wallet = null, (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_2__.r)(), document.dispatchEvent(new Event(\"wallet_disconnected\"));\n    });\n  }\n}\nclass G {\n  static init({\n    options: n,\n    inAppBrowserOptions: t\n  }) {\n    return B() ? new _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_4__.I({\n      options: { id: \"argentX\", ...t }\n    }) : new U(n);\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9pbmRleC1kNGYzMGYyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLHdDQUF3QywwREFBMEQ7QUFDbEc7QUFDNEI7QUFDa0M7QUFDcUI7QUFDekI7QUFDYjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFDO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sWUFBWSx5REFBQztBQUNwQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBQztBQUNqQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsZ0JBQWdCLHlEQUFDO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQUM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQUM7QUFDakI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0wsZUFBZSxtREFBQztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQUM7QUFDakI7QUFDQTtBQUNBLEtBQUssT0FBTyxrRUFBQztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFDO0FBQ2pCO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZ0JBQWdCLHlEQUFDO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQUM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBQztBQUNqQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QixRQUFRLGljQUE2QixJQUFJLHFGQUFxRixnREFBZ0QsK0NBQUM7QUFDeE4sb0JBQW9CLCtDQUFDO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFDO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2REFBQztBQUNqQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHFCQUFxQixpREFBQztBQUN0QixpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFNRSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0YXJrbmV0a2l0QDIuMTAuNF9idWZmZXJ1dGlsQDQuMC45X3N0YXJrbmV0QDYuMjQuMV9lbmNvZGluZ0AwLjEuMTNfX3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANi4wLjVfem9kQDMuMjUuNTAvbm9kZV9tb2R1bGVzL3N0YXJrbmV0a2l0L2Rpc3QvaW5kZXgtZDRmMzBmMmUuanM/ZDYwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciB2ID0gKGUsIG4sIHQpID0+IG4gaW4gZSA/IE4oZSwgbiwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IGVbbl0gPSB0O1xudmFyIGwgPSAoZSwgbiwgdCkgPT4gKHYoZSwgdHlwZW9mIG4gIT0gXCJzeW1ib2xcIiA/IG4gKyBcIlwiIDogbiwgdCksIHQpO1xuaW1wb3J0IFwiLi9jb3JlLWQyMWQyZTk2LmpzXCI7XG5pbXBvcnQgeyBXYWxsZXRBY2NvdW50IGFzIGssIGNvbnN0YW50cyBhcyB3IH0gZnJvbSBcInN0YXJrbmV0XCI7XG5pbXBvcnQgeyBDIGFzIEUsIFAsIGEsIGIgYXMgaCwgVSBhcyB1LCByIGFzIE0gfSBmcm9tIFwiLi9sYXN0Q29ubmVjdGVkLWU5MzUxOTEyLmpzXCI7XG5pbXBvcnQgeyBnIGFzIFIgfSBmcm9tIFwiLi9nZXRTdGFya25ldENoYWluSWQtN2M0YjMxNjMuanNcIjtcbmltcG9ydCB7IEkgYXMgUyB9IGZyb20gXCIuL2luZGV4LTliYjQ4ZjhhLmpzXCI7XG5jb25zdCBMID0ge1xuICBtYWlubmV0OiBcImh0dHBzOi8vc3RhcmtuZXQtbWFpbm5ldC5wdWJsaWMuYmxhc3RhcGkuaW9cIixcbiAgdGVzdG5ldDogXCJodHRwczovL3N0YXJrbmV0LXNlcG9saWEucHVibGljLmJsYXN0YXBpLmlvXCJcbn0sIE8gPSB7XG4gIG1haW5uZXQ6IFwiaHR0cHM6Ly9ycGMuc3RhcmtuZXQubGF2YS5idWlsZFwiLFxuICB0ZXN0bmV0OiBcImh0dHBzOi8vcnBjLnN0YXJrbmV0LXNlcG9saWEubGF2YS5idWlsZFwiXG59LCBkID0gW0wsIE9dO1xuZnVuY3Rpb24gcSgpIHtcbiAgY29uc3QgZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGQubGVuZ3RoKTtcbiAgcmV0dXJuIGRbZV07XG59XG5jb25zdCBXID0gKCkgPT4gT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKS5zb21lKFxuICAoZSkgPT4gZSA9PT0gXCJ3YWxsZXRjb25uZWN0XCIgfHwgZS5zdGFydHNXaXRoKFwid2NAMjpcIilcbiksIHAgPSAoKSA9PiB7XG4gIGlmIChXKCkpIHtcbiAgICBkZWxldGUgbG9jYWxTdG9yYWdlLndhbGxldGNvbm5lY3Q7XG4gICAgZm9yIChjb25zdCBlIGluIGxvY2FsU3RvcmFnZSlcbiAgICAgIGUuc3RhcnRzV2l0aChcIndjQDI6XCIpICYmIGRlbGV0ZSBsb2NhbFN0b3JhZ2VbZV07XG4gIH1cbn0sIF8gPSBcImYyZTYxMzg4MWY3YTBlODExMjk1Y2RkNTc5OTllMzFiXCIsIGcgPSBgPHN2Z1xuICAgIHdpZHRoPVwiMzJcIlxuICAgIGhlaWdodD1cIjMyXCJcbiAgICB2aWV3Qm94PVwiMCAwIDMyIDMyXCJcbiAgICBmaWxsPVwibm9uZVwiXG4gICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gID5cbiAgICA8cmVjdCB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiByeD1cIjhcIiBmaWxsPVwiI0ZGODc1QlwiIC8+XG4gICAgPHBhdGhcbiAgICAgIGQ9XCJNMTguMzE2IDhIMTMuNjg0QzEzLjUyOTIgOCAxMy40MDUyIDguMTI3MiAxMy40MDE4IDguMjg1MzFDMTMuMzA4MiAxMi43Mjk2IDExLjAzMjMgMTYuOTQ3NyA3LjExNTEzIDE5LjkzNTVDNi45OTA3NyAyMC4wMzAzIDYuOTYyNDMgMjAuMjA4NSA3LjA1MzM1IDIwLjMzNjlMOS43NjM0OSAyNC4xNjU0QzkuODU1NjkgMjQuMjk1NyAxMC4wMzUzIDI0LjMyNTEgMTAuMTYxOCAyNC4yMjk0QzEyLjYxMTEgMjIuMzczNCAxNC41ODEyIDIwLjEzNDUgMTYgMTcuNjUyOUMxNy40MTg3IDIwLjEzNDUgMTkuMzg5IDIyLjM3MzQgMjEuODM4MyAyNC4yMjk0QzIxLjk2NDYgMjQuMzI1MSAyMi4xNDQzIDI0LjI5NTcgMjIuMjM2NiAyNC4xNjU0TDI0Ljk0NjcgMjAuMzM2OUMyNS4wMzc1IDIwLjIwODUgMjUuMDA5MiAyMC4wMzAzIDI0Ljg4NSAxOS45MzU1QzIwLjk2NzYgMTYuOTQ3NyAxOC42OTE4IDEyLjcyOTYgMTguNTk4MyA4LjI4NTMxQzE4LjU5NDkgOC4xMjcyIDE4LjQ3MDggOCAxOC4zMTYgOFpcIlxuICAgICAgZmlsbD1cIndoaXRlXCJcbiAgICAvPlxuICA8L3N2Zz5gLCBCID0gKCkgPT4gdHlwZW9mIHdpbmRvdyA+IFwidVwiIHx8ICF3aW5kb3c/LnN0YXJrbmV0X2FyZ2VudFggPyAhMSA6IHdpbmRvdz8uc3RhcmtuZXRfYXJnZW50WD8uaXNJbkFwcEJyb3dzZXI7XG5jbGFzcyBVIGV4dGVuZHMgRSB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcigpO1xuICAgIGwodGhpcywgXCJfd2FsbGV0XCIsIG51bGwpO1xuICAgIGwodGhpcywgXCJfb3B0aW9uc1wiKTtcbiAgICB0aGlzLl9vcHRpb25zID0gdDtcbiAgfVxuICBhdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGFzeW5jIHJlYWR5KCkge1xuICAgIGlmICghdGhpcy5fd2FsbGV0KVxuICAgICAgcmV0dXJuICExO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGF3YWl0IHRoaXMuX3dhbGxldC5yZXF1ZXN0KHtcbiAgICAgICAgdHlwZTogXCJ3YWxsZXRfZ2V0UGVybWlzc2lvbnNcIlxuICAgICAgfSkpLmluY2x1ZGVzKFAuQUNDT1VOVFMpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIFwiYXJnZW50TW9iaWxlXCI7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIFwiQXJnZW50IChtb2JpbGUpXCI7XG4gIH1cbiAgZ2V0IGljb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhcms6IGcsXG4gICAgICBsaWdodDogZ1xuICAgIH07XG4gIH1cbiAgZ2V0IHdhbGxldCgpIHtcbiAgICBpZiAoIXRoaXMuX3dhbGxldClcbiAgICAgIHRocm93IG5ldyBhKCk7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldDtcbiAgfVxuICBhc3luYyBjb25uZWN0KHQgPSB7fSkge1xuICAgIGlmIChhd2FpdCB0aGlzLmVuc3VyZVdhbGxldCgpLCAhdGhpcy5fd2FsbGV0KVxuICAgICAgdGhyb3cgbmV3IGgoKTtcbiAgICBjb25zdCBvID0gYXdhaXQgdGhpcy5fd2FsbGV0LnJlcXVlc3Qoe1xuICAgICAgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzXCJcbiAgICB9KSwgcyA9IGF3YWl0IHRoaXMuY2hhaW5JZCgpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50OiBvWzBdLFxuICAgICAgY2hhaW5JZDogc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAoYXdhaXQgdGhpcy5fd2FsbGV0LmRpc2FibGUoKSwgcCgpLCAhdGhpcy5hdmFpbGFibGUoKSAmJiAhdGhpcy5fd2FsbGV0KVxuICAgICAgdGhyb3cgbmV3IGgoKTtcbiAgICB0aGlzLl93YWxsZXQgPSBudWxsO1xuICB9XG4gIGFzeW5jIGFjY291bnQodCkge1xuICAgIGlmICghdGhpcy5fd2FsbGV0KVxuICAgICAgdGhyb3cgbmV3IGEoKTtcbiAgICBjb25zdCBvID0gYXdhaXQgdGhpcy5fd2FsbGV0LnJlcXVlc3Qoe1xuICAgICAgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzXCIsXG4gICAgICBwYXJhbXM6IHsgc2lsZW50X21vZGU6ICEwIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IGsodCwgdGhpcy5fd2FsbGV0LCB2b2lkIDAsIG9bMF0pO1xuICB9XG4gIGFzeW5jIGNoYWluSWQoKSB7XG4gICAgaWYgKCF0aGlzLl93YWxsZXQpXG4gICAgICB0aHJvdyBuZXcgYSgpO1xuICAgIGNvbnN0IHQgPSBhd2FpdCB0aGlzLl93YWxsZXQucmVxdWVzdCh7XG4gICAgICB0eXBlOiBcIndhbGxldF9yZXF1ZXN0Q2hhaW5JZFwiXG4gICAgfSksIG8gPSBSKHQpO1xuICAgIHJldHVybiBCaWdJbnQobyk7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdCh0KSB7XG4gICAgaWYgKCF0aGlzLl93YWxsZXQpXG4gICAgICB0aHJvdyBuZXcgYSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fd2FsbGV0LnJlcXVlc3QodCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgdSgpO1xuICAgIH1cbiAgfVxuICAvLyBuZWVkZWQsIG1ldGhvZHMgcmVxdWlyZWQgYnkgc3RhcmtuZXQtcmVhY3QuIE90aGVyd2lzZSBhbiBleGNlcHRpb24gaXMgdGhyb3dkXG4gIGFzeW5jIGluaXRFdmVudExpc3RlbmVyKHQpIHtcbiAgICBpZiAoIXRoaXMuX3dhbGxldClcbiAgICAgIHRocm93IG5ldyBhKCk7XG4gICAgdGhpcy5fd2FsbGV0Lm9uKFwiYWNjb3VudHNDaGFuZ2VkXCIsIHQpO1xuICB9XG4gIC8vIG5lZWRlZCwgbWV0aG9kcyByZXF1aXJlZCBieSBzdGFya25ldC1yZWFjdC4gT3RoZXJ3aXNlIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd2RcbiAgYXN5bmMgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0KSB7XG4gICAgaWYgKCF0aGlzLl93YWxsZXQpXG4gICAgICB0aHJvdyBuZXcgYSgpO1xuICAgIHRoaXMuX3dhbGxldC5vZmYoXCJhY2NvdW50c0NoYW5nZWRcIiwgdCksIHRoaXMuX3dhbGxldCA9IG51bGw7XG4gIH1cbiAgYXN5bmMgZW5zdXJlV2FsbGV0KCkge1xuICAgIGNvbnN0IHsgZ2V0U3RhcmtuZXRXaW5kb3dPYmplY3Q6IHQgfSA9IGF3YWl0IGltcG9ydChcIi4vaW5kZXgtMWMxZDJiMTAuanNcIiksIHsgY2hhaW5JZDogbywgcHJvamVjdElkOiBzLCBkYXBwTmFtZTogZiwgZGVzY3JpcHRpb246IEMsIHVybDogbSwgaWNvbnM6IEksIHJwY1VybDogYiB9ID0gdGhpcy5fb3B0aW9ucywgciA9IHEoKSwgeSA9IGIgPz8gKCFvIHx8IG8gPT09IHcuTmV0d29ya05hbWUuU05fTUFJTiA/IHIubWFpbm5ldCA6IHIudGVzdG5ldCksIEEgPSB7XG4gICAgICBjaGFpbklkOiBvID8/IHcuTmV0d29ya05hbWUuU05fTUFJTixcbiAgICAgIG5hbWU6IGYsXG4gICAgICBwcm9qZWN0SWQ6IHMgPz8gXyxcbiAgICAgIGRlc2NyaXB0aW9uOiBDLFxuICAgICAgdXJsOiBtLFxuICAgICAgaWNvbnM6IEksXG4gICAgICBycGNVcmw6IHlcbiAgICB9O1xuICAgIHMgPT09IF8gJiYgKGNvbnNvbGUubG9nKFwiPT09PT09PT09IE5PVElDRSA9PT09PT09PT1cIiksIGNvbnNvbGUubG9nKFxuICAgICAgXCJXaGlsZSB5b3VyIGFwcGxpY2F0aW9uIHdpbGwgY29udGludWUgdG8gZnVuY3Rpb24sIHdlIGhpZ2hseSByZWNvbW1lbmRlZFwiXG4gICAgKSwgY29uc29sZS5sb2coXCJzaWduaW5nIHVwIGZvciB5b3VyIG93biBBUEkga2V5cy5cIiksIGNvbnNvbGUubG9nKFxuICAgICAgXCJHbyB0byBXYWxsZXRDb25uZWN0IENsb3VkIChodHRwczovL2Nsb3VkLndhbGxldGNvbm5lY3QuY29tKSBhbmQgY3JlYXRlIGEgbmV3IGFjY291bnQuXCJcbiAgICApLCBjb25zb2xlLmxvZyhcbiAgICAgIFwiT25jZSB5b3VyIGFjY291bnQgaXMgY3JlYXRlZCwgY3JlYXRlIGEgbmV3IHByb2plY3QgYW5kIGNvbGxlY3QgdGhlIFByb2plY3QgSURcIlxuICAgICksIGNvbnNvbGUubG9nKFwiPT09PT09PT09PT09PT09PT09PT09PT09PT1cIikpO1xuICAgIGNvbnN0IGkgPSBhd2FpdCB0KEEpO1xuICAgIGlmICghaSlcbiAgICAgIHRocm93IG5ldyB1KCk7XG4gICAgdGhpcy5fd2FsbGV0ID0gaTtcbiAgICBjb25zdCBjID0gdGhpcy5fd2FsbGV0O1xuICAgIGF3YWl0IGMuZW5hYmxlKCksIGMuY2xpZW50Lm9uKFwic2Vzc2lvbl9kZWxldGVcIiwgKCkgPT4ge1xuICAgICAgcCgpLCB0aGlzLl93YWxsZXQgPSBudWxsLCBNKCksIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwid2FsbGV0X2Rpc2Nvbm5lY3RlZFwiKSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEcge1xuICBzdGF0aWMgaW5pdCh7XG4gICAgb3B0aW9uczogbixcbiAgICBpbkFwcEJyb3dzZXJPcHRpb25zOiB0XG4gIH0pIHtcbiAgICByZXR1cm4gQigpID8gbmV3IFMoe1xuICAgICAgb3B0aW9uczogeyBpZDogXCJhcmdlbnRYXCIsIC4uLnQgfVxuICAgIH0pIDogbmV3IFUobik7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFUgYXMgQSxcbiAgRyBhcyBhLFxuICBCIGFzIGksXG4gIHAgYXMgclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-d4f30f2e.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/injectedConnector.js":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/injectedConnector.js ***!
  \******************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InjectedConnector: () => (/* reexport safe */ _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_2__.I)\n/* harmony export */ });\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! starknet */ \"(ssr)/./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lastConnected-e9351912.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/lastConnected-e9351912.js\");\n/* harmony import */ var _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-9bb48f8a.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-9bb48f8a.js\");\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9pbmplY3RlZENvbm5lY3Rvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtCO0FBQ21CO0FBQ1E7QUFHM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdGFya25ldGtpdEAyLjEwLjRfYnVmZmVydXRpbEA0LjAuOV9zdGFya25ldEA2LjI0LjFfZW5jb2RpbmdAMC4xLjEzX190eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDYuMC41X3pvZEAzLjI1LjUwL25vZGVfbW9kdWxlcy9zdGFya25ldGtpdC9kaXN0L2luamVjdGVkQ29ubmVjdG9yLmpzPzgyOTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwic3RhcmtuZXRcIjtcbmltcG9ydCBcIi4vbGFzdENvbm5lY3RlZC1lOTM1MTkxMi5qc1wiO1xuaW1wb3J0IHsgSSBhcyBtIH0gZnJvbSBcIi4vaW5kZXgtOWJiNDhmOGEuanNcIjtcbmV4cG9ydCB7XG4gIG0gYXMgSW5qZWN0ZWRDb25uZWN0b3Jcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/injectedConnector.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/lastConnected-e9351912.js":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/lastConnected-e9351912.js ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ R),\n/* harmony export */   P: () => (/* binding */ T),\n/* harmony export */   U: () => (/* binding */ q),\n/* harmony export */   a: () => (/* binding */ U),\n/* harmony export */   b: () => (/* binding */ W),\n/* harmony export */   c: () => (/* binding */ A),\n/* harmony export */   d: () => (/* binding */ L),\n/* harmony export */   g: () => (/* binding */ S),\n/* harmony export */   r: () => (/* binding */ M),\n/* harmony export */   s: () => (/* binding */ F)\n/* harmony export */ });\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! starknet */ \"(ssr)/./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs\");\nvar x = Object.defineProperty;\nvar O = (s, a, o) => a in s ? x(s, a, { enumerable: !0, configurable: !0, writable: !0, value: o }) : s[a] = o;\nvar m = (s, a, o) => (O(s, typeof a != \"symbol\" ? a + \"\" : a, o), o);\n\nvar A = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction L(s) {\n  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, \"default\") ? s.default : s;\n}\nfunction S(s) {\n  if (s.__esModule)\n    return s;\n  var a = s.default;\n  if (typeof a == \"function\") {\n    var o = function v() {\n      return this instanceof v ? Reflect.construct(a, arguments, this.constructor) : a.apply(this, arguments);\n    };\n    o.prototype = a.prototype;\n  } else\n    o = {};\n  return Object.defineProperty(o, \"__esModule\", { value: !0 }), Object.keys(s).forEach(function(v) {\n    var g = Object.getOwnPropertyDescriptor(s, v);\n    Object.defineProperty(o, v, g.get ? g : {\n      enumerable: !0,\n      get: function() {\n        return s[v];\n      }\n    });\n  }), o;\n}\nvar E = { exports: {} };\n(function(s) {\n  var a = Object.prototype.hasOwnProperty, o = \"~\";\n  function v() {\n  }\n  Object.create && (v.prototype = /* @__PURE__ */ Object.create(null), new v().__proto__ || (o = !1));\n  function g(c, t, n) {\n    this.fn = c, this.context = t, this.once = n || !1;\n  }\n  function C(c, t, n, r, p) {\n    if (typeof n != \"function\")\n      throw new TypeError(\"The listener must be a function\");\n    var l = new g(n, r || c, p), i = o ? o + t : t;\n    return c._events[i] ? c._events[i].fn ? c._events[i] = [c._events[i], l] : c._events[i].push(l) : (c._events[i] = l, c._eventsCount++), c;\n  }\n  function b(c, t) {\n    --c._eventsCount === 0 ? c._events = new v() : delete c._events[t];\n  }\n  function u() {\n    this._events = new v(), this._eventsCount = 0;\n  }\n  u.prototype.eventNames = function() {\n    var t = [], n, r;\n    if (this._eventsCount === 0)\n      return t;\n    for (r in n = this._events)\n      a.call(n, r) && t.push(o ? r.slice(1) : r);\n    return Object.getOwnPropertySymbols ? t.concat(Object.getOwnPropertySymbols(n)) : t;\n  }, u.prototype.listeners = function(t) {\n    var n = o ? o + t : t, r = this._events[n];\n    if (!r)\n      return [];\n    if (r.fn)\n      return [r.fn];\n    for (var p = 0, l = r.length, i = new Array(l); p < l; p++)\n      i[p] = r[p].fn;\n    return i;\n  }, u.prototype.listenerCount = function(t) {\n    var n = o ? o + t : t, r = this._events[n];\n    return r ? r.fn ? 1 : r.length : 0;\n  }, u.prototype.emit = function(t, n, r, p, l, i) {\n    var h = o ? o + t : t;\n    if (!this._events[h])\n      return !1;\n    var e = this._events[h], d = arguments.length, y, f;\n    if (e.fn) {\n      switch (e.once && this.removeListener(t, e.fn, void 0, !0), d) {\n        case 1:\n          return e.fn.call(e.context), !0;\n        case 2:\n          return e.fn.call(e.context, n), !0;\n        case 3:\n          return e.fn.call(e.context, n, r), !0;\n        case 4:\n          return e.fn.call(e.context, n, r, p), !0;\n        case 5:\n          return e.fn.call(e.context, n, r, p, l), !0;\n        case 6:\n          return e.fn.call(e.context, n, r, p, l, i), !0;\n      }\n      for (f = 1, y = new Array(d - 1); f < d; f++)\n        y[f - 1] = arguments[f];\n      e.fn.apply(e.context, y);\n    } else {\n      var w = e.length, _;\n      for (f = 0; f < w; f++)\n        switch (e[f].once && this.removeListener(t, e[f].fn, void 0, !0), d) {\n          case 1:\n            e[f].fn.call(e[f].context);\n            break;\n          case 2:\n            e[f].fn.call(e[f].context, n);\n            break;\n          case 3:\n            e[f].fn.call(e[f].context, n, r);\n            break;\n          case 4:\n            e[f].fn.call(e[f].context, n, r, p);\n            break;\n          default:\n            if (!y)\n              for (_ = 1, y = new Array(d - 1); _ < d; _++)\n                y[_ - 1] = arguments[_];\n            e[f].fn.apply(e[f].context, y);\n        }\n    }\n    return !0;\n  }, u.prototype.on = function(t, n, r) {\n    return C(this, t, n, r, !1);\n  }, u.prototype.once = function(t, n, r) {\n    return C(this, t, n, r, !0);\n  }, u.prototype.removeListener = function(t, n, r, p) {\n    var l = o ? o + t : t;\n    if (!this._events[l])\n      return this;\n    if (!n)\n      return b(this, l), this;\n    var i = this._events[l];\n    if (i.fn)\n      i.fn === n && (!p || i.once) && (!r || i.context === r) && b(this, l);\n    else {\n      for (var h = 0, e = [], d = i.length; h < d; h++)\n        (i[h].fn !== n || p && !i[h].once || r && i[h].context !== r) && e.push(i[h]);\n      e.length ? this._events[l] = e.length === 1 ? e[0] : e : b(this, l);\n    }\n    return this;\n  }, u.prototype.removeAllListeners = function(t) {\n    var n;\n    return t ? (n = o ? o + t : t, this._events[n] && b(this, n)) : (this._events = new v(), this._eventsCount = 0), this;\n  }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = o, u.EventEmitter = u, s.exports = u;\n})(E);\nvar j = E.exports;\nconst P = /* @__PURE__ */ L(j);\nclass R extends P {\n}\nconst T = {\n  ACCOUNTS: \"accounts\"\n};\nclass U extends Error {\n  constructor() {\n    super(...arguments);\n    m(this, \"name\", \"ConnectorNotConnectedError\");\n    m(this, \"message\", \"Connector not connected\");\n  }\n}\nclass W extends Error {\n  constructor() {\n    super(...arguments);\n    m(this, \"name\", \"ConnectorNotFoundError\");\n    m(this, \"message\", \"Connector not found\");\n  }\n}\nclass q extends Error {\n  constructor() {\n    super(...arguments);\n    m(this, \"name\", \"UserRejectedRequestError\");\n    m(this, \"message\", \"User rejected request\");\n  }\n}\nconst F = (s) => {\n  localStorage.setItem(\"starknetLastConnectedWallet\", s);\n}, M = () => {\n  localStorage.removeItem(\"starknetLastConnectedWallet\");\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9sYXN0Q29ubmVjdGVkLWU5MzUxOTEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSx3Q0FBd0MsMERBQTBEO0FBQ2xHO0FBQ2tCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBWUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdGFya25ldGtpdEAyLjEwLjRfYnVmZmVydXRpbEA0LjAuOV9zdGFya25ldEA2LjI0LjFfZW5jb2RpbmdAMC4xLjEzX190eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDYuMC41X3pvZEAzLjI1LjUwL25vZGVfbW9kdWxlcy9zdGFya25ldGtpdC9kaXN0L2xhc3RDb25uZWN0ZWQtZTkzNTE5MTIuanM/OGYzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgeCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBPID0gKHMsIGEsIG8pID0+IGEgaW4gcyA/IHgocywgYSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogbyB9KSA6IHNbYV0gPSBvO1xudmFyIG0gPSAocywgYSwgbykgPT4gKE8ocywgdHlwZW9mIGEgIT0gXCJzeW1ib2xcIiA/IGEgKyBcIlwiIDogYSwgbyksIG8pO1xuaW1wb3J0IFwic3RhcmtuZXRcIjtcbnZhciBBID0gdHlwZW9mIGdsb2JhbFRoaXMgPCBcInVcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA8IFwidVwiID8gc2VsZiA6IHt9O1xuZnVuY3Rpb24gTChzKSB7XG4gIHJldHVybiBzICYmIHMuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgXCJkZWZhdWx0XCIpID8gcy5kZWZhdWx0IDogcztcbn1cbmZ1bmN0aW9uIFMocykge1xuICBpZiAocy5fX2VzTW9kdWxlKVxuICAgIHJldHVybiBzO1xuICB2YXIgYSA9IHMuZGVmYXVsdDtcbiAgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBvID0gZnVuY3Rpb24gdigpIHtcbiAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgdiA/IFJlZmxlY3QuY29uc3RydWN0KGEsIGFyZ3VtZW50cywgdGhpcy5jb25zdHJ1Y3RvcikgOiBhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBvLnByb3RvdHlwZSA9IGEucHJvdG90eXBlO1xuICB9IGVsc2VcbiAgICBvID0ge307XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBPYmplY3Qua2V5cyhzKS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgZyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iocywgdik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIHYsIGcuZ2V0ID8gZyA6IHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNbdl07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLCBvO1xufVxudmFyIEUgPSB7IGV4cG9ydHM6IHt9IH07XG4oZnVuY3Rpb24ocykge1xuICB2YXIgYSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIG8gPSBcIn5cIjtcbiAgZnVuY3Rpb24gdigpIHtcbiAgfVxuICBPYmplY3QuY3JlYXRlICYmICh2LnByb3RvdHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCBuZXcgdigpLl9fcHJvdG9fXyB8fCAobyA9ICExKSk7XG4gIGZ1bmN0aW9uIGcoYywgdCwgbikge1xuICAgIHRoaXMuZm4gPSBjLCB0aGlzLmNvbnRleHQgPSB0LCB0aGlzLm9uY2UgPSBuIHx8ICExO1xuICB9XG4gIGZ1bmN0aW9uIEMoYywgdCwgbiwgciwgcCkge1xuICAgIGlmICh0eXBlb2YgbiAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICB2YXIgbCA9IG5ldyBnKG4sIHIgfHwgYywgcCksIGkgPSBvID8gbyArIHQgOiB0O1xuICAgIHJldHVybiBjLl9ldmVudHNbaV0gPyBjLl9ldmVudHNbaV0uZm4gPyBjLl9ldmVudHNbaV0gPSBbYy5fZXZlbnRzW2ldLCBsXSA6IGMuX2V2ZW50c1tpXS5wdXNoKGwpIDogKGMuX2V2ZW50c1tpXSA9IGwsIGMuX2V2ZW50c0NvdW50KyspLCBjO1xuICB9XG4gIGZ1bmN0aW9uIGIoYywgdCkge1xuICAgIC0tYy5fZXZlbnRzQ291bnQgPT09IDAgPyBjLl9ldmVudHMgPSBuZXcgdigpIDogZGVsZXRlIGMuX2V2ZW50c1t0XTtcbiAgfVxuICBmdW5jdGlvbiB1KCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyB2KCksIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuICB1LnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBbXSwgbiwgcjtcbiAgICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICByZXR1cm4gdDtcbiAgICBmb3IgKHIgaW4gbiA9IHRoaXMuX2V2ZW50cylcbiAgICAgIGEuY2FsbChuLCByKSAmJiB0LnB1c2gobyA/IHIuc2xpY2UoMSkgOiByKTtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA/IHQuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobikpIDogdDtcbiAgfSwgdS5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBuID0gbyA/IG8gKyB0IDogdCwgciA9IHRoaXMuX2V2ZW50c1tuXTtcbiAgICBpZiAoIXIpXG4gICAgICByZXR1cm4gW107XG4gICAgaWYgKHIuZm4pXG4gICAgICByZXR1cm4gW3IuZm5dO1xuICAgIGZvciAodmFyIHAgPSAwLCBsID0gci5sZW5ndGgsIGkgPSBuZXcgQXJyYXkobCk7IHAgPCBsOyBwKyspXG4gICAgICBpW3BdID0gcltwXS5mbjtcbiAgICByZXR1cm4gaTtcbiAgfSwgdS5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbiA9IG8gPyBvICsgdCA6IHQsIHIgPSB0aGlzLl9ldmVudHNbbl07XG4gICAgcmV0dXJuIHIgPyByLmZuID8gMSA6IHIubGVuZ3RoIDogMDtcbiAgfSwgdS5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHQsIG4sIHIsIHAsIGwsIGkpIHtcbiAgICB2YXIgaCA9IG8gPyBvICsgdCA6IHQ7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbaF0pXG4gICAgICByZXR1cm4gITE7XG4gICAgdmFyIGUgPSB0aGlzLl9ldmVudHNbaF0sIGQgPSBhcmd1bWVudHMubGVuZ3RoLCB5LCBmO1xuICAgIGlmIChlLmZuKSB7XG4gICAgICBzd2l0Y2ggKGUub25jZSAmJiB0aGlzLnJlbW92ZUxpc3RlbmVyKHQsIGUuZm4sIHZvaWQgMCwgITApLCBkKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gZS5mbi5jYWxsKGUuY29udGV4dCksICEwO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIGUuZm4uY2FsbChlLmNvbnRleHQsIG4pLCAhMDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBlLmZuLmNhbGwoZS5jb250ZXh0LCBuLCByKSwgITA7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gZS5mbi5jYWxsKGUuY29udGV4dCwgbiwgciwgcCksICEwO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIGUuZm4uY2FsbChlLmNvbnRleHQsIG4sIHIsIHAsIGwpLCAhMDtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiBlLmZuLmNhbGwoZS5jb250ZXh0LCBuLCByLCBwLCBsLCBpKSwgITA7XG4gICAgICB9XG4gICAgICBmb3IgKGYgPSAxLCB5ID0gbmV3IEFycmF5KGQgLSAxKTsgZiA8IGQ7IGYrKylcbiAgICAgICAgeVtmIC0gMV0gPSBhcmd1bWVudHNbZl07XG4gICAgICBlLmZuLmFwcGx5KGUuY29udGV4dCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB3ID0gZS5sZW5ndGgsIF87XG4gICAgICBmb3IgKGYgPSAwOyBmIDwgdzsgZisrKVxuICAgICAgICBzd2l0Y2ggKGVbZl0ub25jZSAmJiB0aGlzLnJlbW92ZUxpc3RlbmVyKHQsIGVbZl0uZm4sIHZvaWQgMCwgITApLCBkKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgZVtmXS5mbi5jYWxsKGVbZl0uY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBlW2ZdLmZuLmNhbGwoZVtmXS5jb250ZXh0LCBuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGVbZl0uZm4uY2FsbChlW2ZdLmNvbnRleHQsIG4sIHIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgZVtmXS5mbi5jYWxsKGVbZl0uY29udGV4dCwgbiwgciwgcCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF5KVxuICAgICAgICAgICAgICBmb3IgKF8gPSAxLCB5ID0gbmV3IEFycmF5KGQgLSAxKTsgXyA8IGQ7IF8rKylcbiAgICAgICAgICAgICAgICB5W18gLSAxXSA9IGFyZ3VtZW50c1tfXTtcbiAgICAgICAgICAgIGVbZl0uZm4uYXBwbHkoZVtmXS5jb250ZXh0LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH0sIHUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odCwgbiwgcikge1xuICAgIHJldHVybiBDKHRoaXMsIHQsIG4sIHIsICExKTtcbiAgfSwgdS5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHQsIG4sIHIpIHtcbiAgICByZXR1cm4gQyh0aGlzLCB0LCBuLCByLCAhMCk7XG4gIH0sIHUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odCwgbiwgciwgcCkge1xuICAgIHZhciBsID0gbyA/IG8gKyB0IDogdDtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1tsXSlcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybiBiKHRoaXMsIGwpLCB0aGlzO1xuICAgIHZhciBpID0gdGhpcy5fZXZlbnRzW2xdO1xuICAgIGlmIChpLmZuKVxuICAgICAgaS5mbiA9PT0gbiAmJiAoIXAgfHwgaS5vbmNlKSAmJiAoIXIgfHwgaS5jb250ZXh0ID09PSByKSAmJiBiKHRoaXMsIGwpO1xuICAgIGVsc2Uge1xuICAgICAgZm9yICh2YXIgaCA9IDAsIGUgPSBbXSwgZCA9IGkubGVuZ3RoOyBoIDwgZDsgaCsrKVxuICAgICAgICAoaVtoXS5mbiAhPT0gbiB8fCBwICYmICFpW2hdLm9uY2UgfHwgciAmJiBpW2hdLmNvbnRleHQgIT09IHIpICYmIGUucHVzaChpW2hdKTtcbiAgICAgIGUubGVuZ3RoID8gdGhpcy5fZXZlbnRzW2xdID0gZS5sZW5ndGggPT09IDEgPyBlWzBdIDogZSA6IGIodGhpcywgbCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LCB1LnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIG47XG4gICAgcmV0dXJuIHQgPyAobiA9IG8gPyBvICsgdCA6IHQsIHRoaXMuX2V2ZW50c1tuXSAmJiBiKHRoaXMsIG4pKSA6ICh0aGlzLl9ldmVudHMgPSBuZXcgdigpLCB0aGlzLl9ldmVudHNDb3VudCA9IDApLCB0aGlzO1xuICB9LCB1LnByb3RvdHlwZS5vZmYgPSB1LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciwgdS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSB1LnByb3RvdHlwZS5vbiwgdS5wcmVmaXhlZCA9IG8sIHUuRXZlbnRFbWl0dGVyID0gdSwgcy5leHBvcnRzID0gdTtcbn0pKEUpO1xudmFyIGogPSBFLmV4cG9ydHM7XG5jb25zdCBQID0gLyogQF9fUFVSRV9fICovIEwoaik7XG5jbGFzcyBSIGV4dGVuZHMgUCB7XG59XG5jb25zdCBUID0ge1xuICBBQ0NPVU5UUzogXCJhY2NvdW50c1wiXG59O1xuY2xhc3MgVSBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBtKHRoaXMsIFwibmFtZVwiLCBcIkNvbm5lY3Rvck5vdENvbm5lY3RlZEVycm9yXCIpO1xuICAgIG0odGhpcywgXCJtZXNzYWdlXCIsIFwiQ29ubmVjdG9yIG5vdCBjb25uZWN0ZWRcIik7XG4gIH1cbn1cbmNsYXNzIFcgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgbSh0aGlzLCBcIm5hbWVcIiwgXCJDb25uZWN0b3JOb3RGb3VuZEVycm9yXCIpO1xuICAgIG0odGhpcywgXCJtZXNzYWdlXCIsIFwiQ29ubmVjdG9yIG5vdCBmb3VuZFwiKTtcbiAgfVxufVxuY2xhc3MgcSBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBtKHRoaXMsIFwibmFtZVwiLCBcIlVzZXJSZWplY3RlZFJlcXVlc3RFcnJvclwiKTtcbiAgICBtKHRoaXMsIFwibWVzc2FnZVwiLCBcIlVzZXIgcmVqZWN0ZWQgcmVxdWVzdFwiKTtcbiAgfVxufVxuY29uc3QgRiA9IChzKSA9PiB7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwic3RhcmtuZXRMYXN0Q29ubmVjdGVkV2FsbGV0XCIsIHMpO1xufSwgTSA9ICgpID0+IHtcbiAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJzdGFya25ldExhc3RDb25uZWN0ZWRXYWxsZXRcIik7XG59O1xuZXhwb3J0IHtcbiAgUiBhcyBDLFxuICBUIGFzIFAsXG4gIHEgYXMgVSxcbiAgVSBhcyBhLFxuICBXIGFzIGIsXG4gIEEgYXMgYyxcbiAgTCBhcyBkLFxuICBTIGFzIGcsXG4gIE0gYXMgcixcbiAgRiBhcyBzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/lastConnected-e9351912.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/starknetkit.js":
/*!************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/starknetkit.js ***!
  \************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connect: () => (/* binding */ It),\n/* harmony export */   disconnect: () => (/* binding */ $t),\n/* harmony export */   getSelectedConnectorWallet: () => (/* binding */ Yt),\n/* harmony export */   useStarknetkitConnectModal: () => (/* binding */ Kt)\n/* harmony export */ });\n/* harmony import */ var _core_d21d2e96_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core-d21d2e96.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/core-d21d2e96.js\");\n/* harmony import */ var _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lastConnected-e9351912.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/lastConnected-e9351912.js\");\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! starknet */ \"(ssr)/./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var _index_8edbd361_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index-8edbd361.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-8edbd361.js\");\n/* harmony import */ var _index_d4f30f2e_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index-d4f30f2e.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-d4f30f2e.js\");\n/* harmony import */ var _braavosMobile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./braavosMobile.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/braavosMobile.js\");\n/* harmony import */ var _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./index-9bb48f8a.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-9bb48f8a.js\");\n/* harmony import */ var _getStarknetChainId_7c4b3163_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getStarknetChainId-7c4b3163.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/getStarknetChainId-7c4b3163.js\");\nvar Ee = Object.defineProperty;\nvar Pe = (t, e, r) => e in t ? Ee(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;\nvar J = (t, e, r) => (Pe(t, typeof e != \"symbol\" ? e + \"\" : e, r), r);\n\n\n\n\n\n\n\n\nconst Re = () => {\n  const t = navigator.userAgent.toLowerCase(), e = /android|webos|iphone|ipad|ipod|blackberry|windows phone/.test(t), r = \"ontouchstart\" in window || navigator.maxTouchPoints > 0, n = window.innerWidth <= 768;\n  return e && (r || n);\n}, Ie = ({\n  argentMobileOptions: t,\n  webWalletUrl: e\n}) => {\n  const r = typeof window < \"u\" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1, n = [];\n  return r || (n.push(\n    new _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__.I({ options: { id: \"argentX\" } })\n  ), n.push(\n    new _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__.I({ options: { id: \"braavos\" } })\n  ), _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__.I.isWalletInjected(\"metamask\") && n.push(\n    new _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__.I({ options: { id: \"metamask\" } })\n  ), _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__.I.isWalletInjected(\"fordefi\") && n.push(\n    new _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__.I({ options: { id: \"fordefi\" } })\n  ), _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__.I.isWalletInjected(\"keplr\") && n.push(\n    new _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__.I({ options: { id: \"keplr\" } })\n  )), n.push(new _index_d4f30f2e_js__WEBPACK_IMPORTED_MODULE_4__.A(t)), Re() && n.push(new _braavosMobile_js__WEBPACK_IMPORTED_MODULE_5__.BraavosMobileBaseConnector()), n.push(new _index_8edbd361_js__WEBPACK_IMPORTED_MODULE_3__.W({ url: e })), n;\n}, Ve = {\n  \"Amazon Silk\": \"amazon_silk\",\n  \"Android Browser\": \"android\",\n  Bada: \"bada\",\n  BlackBerry: \"blackberry\",\n  Chrome: \"chrome\",\n  Chromium: \"chromium\",\n  Electron: \"electron\",\n  Epiphany: \"epiphany\",\n  Firefox: \"firefox\",\n  Focus: \"focus\",\n  Generic: \"generic\",\n  \"Google Search\": \"google_search\",\n  Googlebot: \"googlebot\",\n  \"Internet Explorer\": \"ie\",\n  \"K-Meleon\": \"k_meleon\",\n  Maxthon: \"maxthon\",\n  \"Microsoft Edge\": \"edge\",\n  \"MZ Browser\": \"mz\",\n  \"NAVER Whale Browser\": \"naver\",\n  Opera: \"opera\",\n  \"Opera Coast\": \"opera_coast\",\n  PhantomJS: \"phantomjs\",\n  Puffin: \"puffin\",\n  QupZilla: \"qupzilla\",\n  QQ: \"qq\",\n  QQLite: \"qqlite\",\n  Safari: \"safari\",\n  Sailfish: \"sailfish\",\n  \"Samsung Internet for Android\": \"samsung_internet\",\n  SeaMonkey: \"seamonkey\",\n  Sleipnir: \"sleipnir\",\n  Swing: \"swing\",\n  Tizen: \"tizen\",\n  \"UC Browser\": \"uc\",\n  Vivaldi: \"vivaldi\",\n  \"WebOS Browser\": \"webos\",\n  WeChat: \"wechat\",\n  \"Yandex Browser\": \"yandex\",\n  Roku: \"roku\"\n}, be = {\n  amazon_silk: \"Amazon Silk\",\n  android: \"Android Browser\",\n  bada: \"Bada\",\n  blackberry: \"BlackBerry\",\n  chrome: \"Chrome\",\n  chromium: \"Chromium\",\n  electron: \"Electron\",\n  epiphany: \"Epiphany\",\n  firefox: \"Firefox\",\n  focus: \"Focus\",\n  generic: \"Generic\",\n  googlebot: \"Googlebot\",\n  google_search: \"Google Search\",\n  ie: \"Internet Explorer\",\n  k_meleon: \"K-Meleon\",\n  maxthon: \"Maxthon\",\n  edge: \"Microsoft Edge\",\n  mz: \"MZ Browser\",\n  naver: \"NAVER Whale Browser\",\n  opera: \"Opera\",\n  opera_coast: \"Opera Coast\",\n  phantomjs: \"PhantomJS\",\n  puffin: \"Puffin\",\n  qupzilla: \"QupZilla\",\n  qq: \"QQ Browser\",\n  qqlite: \"QQ Browser Lite\",\n  safari: \"Safari\",\n  sailfish: \"Sailfish\",\n  samsung_internet: \"Samsung Internet for Android\",\n  seamonkey: \"SeaMonkey\",\n  sleipnir: \"Sleipnir\",\n  swing: \"Swing\",\n  tizen: \"Tizen\",\n  uc: \"UC Browser\",\n  vivaldi: \"Vivaldi\",\n  webos: \"WebOS Browser\",\n  wechat: \"WeChat\",\n  yandex: \"Yandex Browser\"\n}, M = {\n  tablet: \"tablet\",\n  mobile: \"mobile\",\n  desktop: \"desktop\",\n  tv: \"tv\"\n}, F = {\n  WindowsPhone: \"Windows Phone\",\n  Windows: \"Windows\",\n  MacOS: \"macOS\",\n  iOS: \"iOS\",\n  Android: \"Android\",\n  WebOS: \"WebOS\",\n  BlackBerry: \"BlackBerry\",\n  Bada: \"Bada\",\n  Tizen: \"Tizen\",\n  Linux: \"Linux\",\n  ChromeOS: \"Chrome OS\",\n  PlayStation4: \"PlayStation 4\",\n  Roku: \"Roku\"\n}, P = {\n  EdgeHTML: \"EdgeHTML\",\n  Blink: \"Blink\",\n  Trident: \"Trident\",\n  Presto: \"Presto\",\n  Gecko: \"Gecko\",\n  WebKit: \"WebKit\"\n};\nclass i {\n  /**\n   * Get first matched item for a string\n   * @param {RegExp} regexp\n   * @param {String} ua\n   * @return {Array|{index: number, input: string}|*|boolean|string}\n   */\n  static getFirstMatch(e, r) {\n    const n = r.match(e);\n    return n && n.length > 0 && n[1] || \"\";\n  }\n  /**\n   * Get second matched item for a string\n   * @param regexp\n   * @param {String} ua\n   * @return {Array|{index: number, input: string}|*|boolean|string}\n   */\n  static getSecondMatch(e, r) {\n    const n = r.match(e);\n    return n && n.length > 1 && n[2] || \"\";\n  }\n  /**\n   * Match a regexp and return a constant or undefined\n   * @param {RegExp} regexp\n   * @param {String} ua\n   * @param {*} _const Any const that will be returned if regexp matches the string\n   * @return {*}\n   */\n  static matchAndReturnConst(e, r, n) {\n    if (e.test(r))\n      return n;\n  }\n  static getWindowsVersionName(e) {\n    switch (e) {\n      case \"NT\":\n        return \"NT\";\n      case \"XP\":\n        return \"XP\";\n      case \"NT 5.0\":\n        return \"2000\";\n      case \"NT 5.1\":\n        return \"XP\";\n      case \"NT 5.2\":\n        return \"2003\";\n      case \"NT 6.0\":\n        return \"Vista\";\n      case \"NT 6.1\":\n        return \"7\";\n      case \"NT 6.2\":\n        return \"8\";\n      case \"NT 6.3\":\n        return \"8.1\";\n      case \"NT 10.0\":\n        return \"10\";\n      default:\n        return;\n    }\n  }\n  /**\n   * Get macOS version name\n   *    10.5 - Leopard\n   *    10.6 - Snow Leopard\n   *    10.7 - Lion\n   *    10.8 - Mountain Lion\n   *    10.9 - Mavericks\n   *    10.10 - Yosemite\n   *    10.11 - El Capitan\n   *    10.12 - Sierra\n   *    10.13 - High Sierra\n   *    10.14 - Mojave\n   *    10.15 - Catalina\n   *\n   * @example\n   *   getMacOSVersionName(\"10.14\") // 'Mojave'\n   *\n   * @param  {string} version\n   * @return {string} versionName\n   */\n  static getMacOSVersionName(e) {\n    const r = e.split(\".\").splice(0, 2).map((n) => parseInt(n, 10) || 0);\n    if (r.push(0), r[0] === 10)\n      switch (r[1]) {\n        case 5:\n          return \"Leopard\";\n        case 6:\n          return \"Snow Leopard\";\n        case 7:\n          return \"Lion\";\n        case 8:\n          return \"Mountain Lion\";\n        case 9:\n          return \"Mavericks\";\n        case 10:\n          return \"Yosemite\";\n        case 11:\n          return \"El Capitan\";\n        case 12:\n          return \"Sierra\";\n        case 13:\n          return \"High Sierra\";\n        case 14:\n          return \"Mojave\";\n        case 15:\n          return \"Catalina\";\n        default:\n          return;\n      }\n  }\n  /**\n   * Get Android version name\n   *    1.5 - Cupcake\n   *    1.6 - Donut\n   *    2.0 - Eclair\n   *    2.1 - Eclair\n   *    2.2 - Froyo\n   *    2.x - Gingerbread\n   *    3.x - Honeycomb\n   *    4.0 - Ice Cream Sandwich\n   *    4.1 - Jelly Bean\n   *    4.4 - KitKat\n   *    5.x - Lollipop\n   *    6.x - Marshmallow\n   *    7.x - Nougat\n   *    8.x - Oreo\n   *    9.x - Pie\n   *\n   * @example\n   *   getAndroidVersionName(\"7.0\") // 'Nougat'\n   *\n   * @param  {string} version\n   * @return {string} versionName\n   */\n  static getAndroidVersionName(e) {\n    const r = e.split(\".\").splice(0, 2).map((n) => parseInt(n, 10) || 0);\n    if (r.push(0), !(r[0] === 1 && r[1] < 5)) {\n      if (r[0] === 1 && r[1] < 6)\n        return \"Cupcake\";\n      if (r[0] === 1 && r[1] >= 6)\n        return \"Donut\";\n      if (r[0] === 2 && r[1] < 2)\n        return \"Eclair\";\n      if (r[0] === 2 && r[1] === 2)\n        return \"Froyo\";\n      if (r[0] === 2 && r[1] > 2)\n        return \"Gingerbread\";\n      if (r[0] === 3)\n        return \"Honeycomb\";\n      if (r[0] === 4 && r[1] < 1)\n        return \"Ice Cream Sandwich\";\n      if (r[0] === 4 && r[1] < 4)\n        return \"Jelly Bean\";\n      if (r[0] === 4 && r[1] >= 4)\n        return \"KitKat\";\n      if (r[0] === 5)\n        return \"Lollipop\";\n      if (r[0] === 6)\n        return \"Marshmallow\";\n      if (r[0] === 7)\n        return \"Nougat\";\n      if (r[0] === 8)\n        return \"Oreo\";\n      if (r[0] === 9)\n        return \"Pie\";\n    }\n  }\n  /**\n   * Get version precisions count\n   *\n   * @example\n   *   getVersionPrecision(\"1.10.3\") // 3\n   *\n   * @param  {string} version\n   * @return {number}\n   */\n  static getVersionPrecision(e) {\n    return e.split(\".\").length;\n  }\n  /**\n   * Calculate browser version weight\n   *\n   * @example\n   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1\n   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1\n   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0\n   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1\n   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0\n   *\n   * @param {String} versionA versions versions to compare\n   * @param {String} versionB versions versions to compare\n   * @param {boolean} [isLoose] enable loose comparison\n   * @return {Number} comparison result: -1 when versionA is lower,\n   * 1 when versionA is bigger, 0 when both equal\n   */\n  /* eslint consistent-return: 1 */\n  static compareVersions(e, r, n = !1) {\n    const o = i.getVersionPrecision(e), s = i.getVersionPrecision(r);\n    let d = Math.max(o, s), h = 0;\n    const w = i.map([e, r], (l) => {\n      const a = d - i.getVersionPrecision(l), g = l + new Array(a + 1).join(\".0\");\n      return i.map(g.split(\".\"), (y) => new Array(20 - y.length).join(\"0\") + y).reverse();\n    });\n    for (n && (h = d - Math.min(o, s)), d -= 1; d >= h; ) {\n      if (w[0][d] > w[1][d])\n        return 1;\n      if (w[0][d] === w[1][d]) {\n        if (d === h)\n          return 0;\n        d -= 1;\n      } else if (w[0][d] < w[1][d])\n        return -1;\n    }\n  }\n  /**\n   * Array::map polyfill\n   *\n   * @param  {Array} arr\n   * @param  {Function} iterator\n   * @return {Array}\n   */\n  static map(e, r) {\n    const n = [];\n    let o;\n    if (Array.prototype.map)\n      return Array.prototype.map.call(e, r);\n    for (o = 0; o < e.length; o += 1)\n      n.push(r(e[o]));\n    return n;\n  }\n  /**\n   * Array::find polyfill\n   *\n   * @param  {Array} arr\n   * @param  {Function} predicate\n   * @return {Array}\n   */\n  static find(e, r) {\n    let n, o;\n    if (Array.prototype.find)\n      return Array.prototype.find.call(e, r);\n    for (n = 0, o = e.length; n < o; n += 1) {\n      const s = e[n];\n      if (r(s, n))\n        return s;\n    }\n  }\n  /**\n   * Object::assign polyfill\n   *\n   * @param  {Object} obj\n   * @param  {Object} ...objs\n   * @return {Object}\n   */\n  static assign(e, ...r) {\n    const n = e;\n    let o, s;\n    if (Object.assign)\n      return Object.assign(e, ...r);\n    for (o = 0, s = r.length; o < s; o += 1) {\n      const d = r[o];\n      typeof d == \"object\" && d !== null && Object.keys(d).forEach((w) => {\n        n[w] = d[w];\n      });\n    }\n    return e;\n  }\n  /**\n   * Get short version/alias for a browser name\n   *\n   * @example\n   *   getBrowserAlias('Microsoft Edge') // edge\n   *\n   * @param  {string} browserName\n   * @return {string}\n   */\n  static getBrowserAlias(e) {\n    return Ve[e];\n  }\n  /**\n   * Get short version/alias for a browser name\n   *\n   * @example\n   *   getBrowserAlias('edge') // Microsoft Edge\n   *\n   * @param  {string} browserAlias\n   * @return {string}\n   */\n  static getBrowserTypeByAlias(e) {\n    return be[e] || \"\";\n  }\n}\nconst k = /version\\/(\\d+(\\.?_?\\d+)+)/i, De = [\n  /* Googlebot */\n  {\n    test: [/googlebot/i],\n    describe(t) {\n      const e = {\n        name: \"Googlebot\"\n      }, r = i.getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i, t) || i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  /* Opera < 13.0 */\n  {\n    test: [/opera/i],\n    describe(t) {\n      const e = {\n        name: \"Opera\"\n      }, r = i.getFirstMatch(k, t) || i.getFirstMatch(/(?:opera)[\\s/](\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  /* Opera > 13.0 */\n  {\n    test: [/opr\\/|opios/i],\n    describe(t) {\n      const e = {\n        name: \"Opera\"\n      }, r = i.getFirstMatch(/(?:opr|opios)[\\s/](\\S+)/i, t) || i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/SamsungBrowser/i],\n    describe(t) {\n      const e = {\n        name: \"Samsung Internet for Android\"\n      }, r = i.getFirstMatch(k, t) || i.getFirstMatch(/(?:SamsungBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/Whale/i],\n    describe(t) {\n      const e = {\n        name: \"NAVER Whale Browser\"\n      }, r = i.getFirstMatch(k, t) || i.getFirstMatch(/(?:whale)[\\s/](\\d+(?:\\.\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/MZBrowser/i],\n    describe(t) {\n      const e = {\n        name: \"MZ Browser\"\n      }, r = i.getFirstMatch(/(?:MZBrowser)[\\s/](\\d+(?:\\.\\d+)+)/i, t) || i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/focus/i],\n    describe(t) {\n      const e = {\n        name: \"Focus\"\n      }, r = i.getFirstMatch(/(?:focus)[\\s/](\\d+(?:\\.\\d+)+)/i, t) || i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/swing/i],\n    describe(t) {\n      const e = {\n        name: \"Swing\"\n      }, r = i.getFirstMatch(/(?:swing)[\\s/](\\d+(?:\\.\\d+)+)/i, t) || i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/coast/i],\n    describe(t) {\n      const e = {\n        name: \"Opera Coast\"\n      }, r = i.getFirstMatch(k, t) || i.getFirstMatch(/(?:coast)[\\s/](\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/opt\\/\\d+(?:.?_?\\d+)+/i],\n    describe(t) {\n      const e = {\n        name: \"Opera Touch\"\n      }, r = i.getFirstMatch(/(?:opt)[\\s/](\\d+(\\.?_?\\d+)+)/i, t) || i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/yabrowser/i],\n    describe(t) {\n      const e = {\n        name: \"Yandex Browser\"\n      }, r = i.getFirstMatch(/(?:yabrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i, t) || i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/ucbrowser/i],\n    describe(t) {\n      const e = {\n        name: \"UC Browser\"\n      }, r = i.getFirstMatch(k, t) || i.getFirstMatch(/(?:ucbrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/Maxthon|mxios/i],\n    describe(t) {\n      const e = {\n        name: \"Maxthon\"\n      }, r = i.getFirstMatch(k, t) || i.getFirstMatch(/(?:Maxthon|mxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/epiphany/i],\n    describe(t) {\n      const e = {\n        name: \"Epiphany\"\n      }, r = i.getFirstMatch(k, t) || i.getFirstMatch(/(?:epiphany)[\\s/](\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/puffin/i],\n    describe(t) {\n      const e = {\n        name: \"Puffin\"\n      }, r = i.getFirstMatch(k, t) || i.getFirstMatch(/(?:puffin)[\\s/](\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/sleipnir/i],\n    describe(t) {\n      const e = {\n        name: \"Sleipnir\"\n      }, r = i.getFirstMatch(k, t) || i.getFirstMatch(/(?:sleipnir)[\\s/](\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/k-meleon/i],\n    describe(t) {\n      const e = {\n        name: \"K-Meleon\"\n      }, r = i.getFirstMatch(k, t) || i.getFirstMatch(/(?:k-meleon)[\\s/](\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/micromessenger/i],\n    describe(t) {\n      const e = {\n        name: \"WeChat\"\n      }, r = i.getFirstMatch(/(?:micromessenger)[\\s/](\\d+(\\.?_?\\d+)+)/i, t) || i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/qqbrowser/i],\n    describe(t) {\n      const e = {\n        name: /qqbrowserlite/i.test(t) ? \"QQ Browser Lite\" : \"QQ Browser\"\n      }, r = i.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\\d+(\\.?_?\\d+)+)/i, t) || i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/msie|trident/i],\n    describe(t) {\n      const e = {\n        name: \"Internet Explorer\"\n      }, r = i.getFirstMatch(/(?:msie |rv:)(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/\\sedg\\//i],\n    describe(t) {\n      const e = {\n        name: \"Microsoft Edge\"\n      }, r = i.getFirstMatch(/\\sedg\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/edg([ea]|ios)/i],\n    describe(t) {\n      const e = {\n        name: \"Microsoft Edge\"\n      }, r = i.getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/vivaldi/i],\n    describe(t) {\n      const e = {\n        name: \"Vivaldi\"\n      }, r = i.getFirstMatch(/vivaldi\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/seamonkey/i],\n    describe(t) {\n      const e = {\n        name: \"SeaMonkey\"\n      }, r = i.getFirstMatch(/seamonkey\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/sailfish/i],\n    describe(t) {\n      const e = {\n        name: \"Sailfish\"\n      }, r = i.getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/silk/i],\n    describe(t) {\n      const e = {\n        name: \"Amazon Silk\"\n      }, r = i.getFirstMatch(/silk\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/phantom/i],\n    describe(t) {\n      const e = {\n        name: \"PhantomJS\"\n      }, r = i.getFirstMatch(/phantomjs\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/slimerjs/i],\n    describe(t) {\n      const e = {\n        name: \"SlimerJS\"\n      }, r = i.getFirstMatch(/slimerjs\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/blackberry|\\bbb\\d+/i, /rim\\stablet/i],\n    describe(t) {\n      const e = {\n        name: \"BlackBerry\"\n      }, r = i.getFirstMatch(k, t) || i.getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/(web|hpw)[o0]s/i],\n    describe(t) {\n      const e = {\n        name: \"WebOS Browser\"\n      }, r = i.getFirstMatch(k, t) || i.getFirstMatch(/w(?:eb)?[o0]sbrowser\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/bada/i],\n    describe(t) {\n      const e = {\n        name: \"Bada\"\n      }, r = i.getFirstMatch(/dolfin\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/tizen/i],\n    describe(t) {\n      const e = {\n        name: \"Tizen\"\n      }, r = i.getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.?_?\\d+)+)/i, t) || i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/qupzilla/i],\n    describe(t) {\n      const e = {\n        name: \"QupZilla\"\n      }, r = i.getFirstMatch(/(?:qupzilla)[\\s/](\\d+(\\.?_?\\d+)+)/i, t) || i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/firefox|iceweasel|fxios/i],\n    describe(t) {\n      const e = {\n        name: \"Firefox\"\n      }, r = i.getFirstMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/electron/i],\n    describe(t) {\n      const e = {\n        name: \"Electron\"\n      }, r = i.getFirstMatch(/(?:electron)\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/MiuiBrowser/i],\n    describe(t) {\n      const e = {\n        name: \"Miui\"\n      }, r = i.getFirstMatch(/(?:MiuiBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/chromium/i],\n    describe(t) {\n      const e = {\n        name: \"Chromium\"\n      }, r = i.getFirstMatch(/(?:chromium)[\\s/](\\d+(\\.?_?\\d+)+)/i, t) || i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/chrome|crios|crmo/i],\n    describe(t) {\n      const e = {\n        name: \"Chrome\"\n      }, r = i.getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  {\n    test: [/GSA/i],\n    describe(t) {\n      const e = {\n        name: \"Google Search\"\n      }, r = i.getFirstMatch(/(?:GSA)\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  /* Android Browser */\n  {\n    test(t) {\n      const e = !t.test(/like android/i), r = t.test(/android/i);\n      return e && r;\n    },\n    describe(t) {\n      const e = {\n        name: \"Android Browser\"\n      }, r = i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  /* PlayStation 4 */\n  {\n    test: [/playstation 4/i],\n    describe(t) {\n      const e = {\n        name: \"PlayStation 4\"\n      }, r = i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  /* Safari */\n  {\n    test: [/safari|applewebkit/i],\n    describe(t) {\n      const e = {\n        name: \"Safari\"\n      }, r = i.getFirstMatch(k, t);\n      return r && (e.version = r), e;\n    }\n  },\n  /* Something else */\n  {\n    test: [/.*/i],\n    describe(t) {\n      const e = /^(.*)\\/(.*) /, r = /^(.*)\\/(.*)[ \\t]\\((.*)/, o = t.search(\"\\\\(\") !== -1 ? r : e;\n      return {\n        name: i.getFirstMatch(o, t),\n        version: i.getSecondMatch(o, t)\n      };\n    }\n  }\n], qe = [\n  /* Roku */\n  {\n    test: [/Roku\\/DVP/],\n    describe(t) {\n      const e = i.getFirstMatch(/Roku\\/DVP-(\\d+\\.\\d+)/i, t);\n      return {\n        name: F.Roku,\n        version: e\n      };\n    }\n  },\n  /* Windows Phone */\n  {\n    test: [/windows phone/i],\n    describe(t) {\n      const e = i.getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i, t);\n      return {\n        name: F.WindowsPhone,\n        version: e\n      };\n    }\n  },\n  /* Windows */\n  {\n    test: [/windows /i],\n    describe(t) {\n      const e = i.getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i, t), r = i.getWindowsVersionName(e);\n      return {\n        name: F.Windows,\n        version: e,\n        versionName: r\n      };\n    }\n  },\n  /* Firefox on iPad */\n  {\n    test: [/Macintosh(.*?) FxiOS(.*?)\\//],\n    describe(t) {\n      const e = {\n        name: F.iOS\n      }, r = i.getSecondMatch(/(Version\\/)(\\d[\\d.]+)/, t);\n      return r && (e.version = r), e;\n    }\n  },\n  /* macOS */\n  {\n    test: [/macintosh/i],\n    describe(t) {\n      const e = i.getFirstMatch(/mac os x (\\d+(\\.?_?\\d+)+)/i, t).replace(/[_\\s]/g, \".\"), r = i.getMacOSVersionName(e), n = {\n        name: F.MacOS,\n        version: e\n      };\n      return r && (n.versionName = r), n;\n    }\n  },\n  /* iOS */\n  {\n    test: [/(ipod|iphone|ipad)/i],\n    describe(t) {\n      const e = i.getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i, t).replace(/[_\\s]/g, \".\");\n      return {\n        name: F.iOS,\n        version: e\n      };\n    }\n  },\n  /* Android */\n  {\n    test(t) {\n      const e = !t.test(/like android/i), r = t.test(/android/i);\n      return e && r;\n    },\n    describe(t) {\n      const e = i.getFirstMatch(/android[\\s/-](\\d+(\\.\\d+)*)/i, t), r = i.getAndroidVersionName(e), n = {\n        name: F.Android,\n        version: e\n      };\n      return r && (n.versionName = r), n;\n    }\n  },\n  /* WebOS */\n  {\n    test: [/(web|hpw)[o0]s/i],\n    describe(t) {\n      const e = i.getFirstMatch(/(?:web|hpw)[o0]s\\/(\\d+(\\.\\d+)*)/i, t), r = {\n        name: F.WebOS\n      };\n      return e && e.length && (r.version = e), r;\n    }\n  },\n  /* BlackBerry */\n  {\n    test: [/blackberry|\\bbb\\d+/i, /rim\\stablet/i],\n    describe(t) {\n      const e = i.getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i, t) || i.getFirstMatch(/blackberry\\d+\\/(\\d+([_\\s]\\d+)*)/i, t) || i.getFirstMatch(/\\bbb(\\d+)/i, t);\n      return {\n        name: F.BlackBerry,\n        version: e\n      };\n    }\n  },\n  /* Bada */\n  {\n    test: [/bada/i],\n    describe(t) {\n      const e = i.getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i, t);\n      return {\n        name: F.Bada,\n        version: e\n      };\n    }\n  },\n  /* Tizen */\n  {\n    test: [/tizen/i],\n    describe(t) {\n      const e = i.getFirstMatch(/tizen[/\\s](\\d+(\\.\\d+)*)/i, t);\n      return {\n        name: F.Tizen,\n        version: e\n      };\n    }\n  },\n  /* Linux */\n  {\n    test: [/linux/i],\n    describe() {\n      return {\n        name: F.Linux\n      };\n    }\n  },\n  /* Chrome OS */\n  {\n    test: [/CrOS/],\n    describe() {\n      return {\n        name: F.ChromeOS\n      };\n    }\n  },\n  /* Playstation 4 */\n  {\n    test: [/PlayStation 4/],\n    describe(t) {\n      const e = i.getFirstMatch(/PlayStation 4[/\\s](\\d+(\\.\\d+)*)/i, t);\n      return {\n        name: F.PlayStation4,\n        version: e\n      };\n    }\n  }\n], Ge = [\n  /* Googlebot */\n  {\n    test: [/googlebot/i],\n    describe() {\n      return {\n        type: \"bot\",\n        vendor: \"Google\"\n      };\n    }\n  },\n  /* Huawei */\n  {\n    test: [/huawei/i],\n    describe(t) {\n      const e = i.getFirstMatch(/(can-l01)/i, t) && \"Nova\", r = {\n        type: M.mobile,\n        vendor: \"Huawei\"\n      };\n      return e && (r.model = e), r;\n    }\n  },\n  /* Nexus Tablet */\n  {\n    test: [/nexus\\s*(?:7|8|9|10).*/i],\n    describe() {\n      return {\n        type: M.tablet,\n        vendor: \"Nexus\"\n      };\n    }\n  },\n  /* iPad */\n  {\n    test: [/ipad/i],\n    describe() {\n      return {\n        type: M.tablet,\n        vendor: \"Apple\",\n        model: \"iPad\"\n      };\n    }\n  },\n  /* Firefox on iPad */\n  {\n    test: [/Macintosh(.*?) FxiOS(.*?)\\//],\n    describe() {\n      return {\n        type: M.tablet,\n        vendor: \"Apple\",\n        model: \"iPad\"\n      };\n    }\n  },\n  /* Amazon Kindle Fire */\n  {\n    test: [/kftt build/i],\n    describe() {\n      return {\n        type: M.tablet,\n        vendor: \"Amazon\",\n        model: \"Kindle Fire HD 7\"\n      };\n    }\n  },\n  /* Another Amazon Tablet with Silk */\n  {\n    test: [/silk/i],\n    describe() {\n      return {\n        type: M.tablet,\n        vendor: \"Amazon\"\n      };\n    }\n  },\n  /* Tablet */\n  {\n    test: [/tablet(?! pc)/i],\n    describe() {\n      return {\n        type: M.tablet\n      };\n    }\n  },\n  /* iPod/iPhone */\n  {\n    test(t) {\n      const e = t.test(/ipod|iphone/i), r = t.test(/like (ipod|iphone)/i);\n      return e && !r;\n    },\n    describe(t) {\n      const e = i.getFirstMatch(/(ipod|iphone)/i, t);\n      return {\n        type: M.mobile,\n        vendor: \"Apple\",\n        model: e\n      };\n    }\n  },\n  /* Nexus Mobile */\n  {\n    test: [/nexus\\s*[0-6].*/i, /galaxy nexus/i],\n    describe() {\n      return {\n        type: M.mobile,\n        vendor: \"Nexus\"\n      };\n    }\n  },\n  /* Mobile */\n  {\n    test: [/[^-]mobi/i],\n    describe() {\n      return {\n        type: M.mobile\n      };\n    }\n  },\n  /* BlackBerry */\n  {\n    test(t) {\n      return t.getBrowserName(!0) === \"blackberry\";\n    },\n    describe() {\n      return {\n        type: M.mobile,\n        vendor: \"BlackBerry\"\n      };\n    }\n  },\n  /* Bada */\n  {\n    test(t) {\n      return t.getBrowserName(!0) === \"bada\";\n    },\n    describe() {\n      return {\n        type: M.mobile\n      };\n    }\n  },\n  /* Windows Phone */\n  {\n    test(t) {\n      return t.getBrowserName() === \"windows phone\";\n    },\n    describe() {\n      return {\n        type: M.mobile,\n        vendor: \"Microsoft\"\n      };\n    }\n  },\n  /* Android Tablet */\n  {\n    test(t) {\n      const e = Number(String(t.getOSVersion()).split(\".\")[0]);\n      return t.getOSName(!0) === \"android\" && e >= 3;\n    },\n    describe() {\n      return {\n        type: M.tablet\n      };\n    }\n  },\n  /* Android Mobile */\n  {\n    test(t) {\n      return t.getOSName(!0) === \"android\";\n    },\n    describe() {\n      return {\n        type: M.mobile\n      };\n    }\n  },\n  /* desktop */\n  {\n    test(t) {\n      return t.getOSName(!0) === \"macos\";\n    },\n    describe() {\n      return {\n        type: M.desktop,\n        vendor: \"Apple\"\n      };\n    }\n  },\n  /* Windows */\n  {\n    test(t) {\n      return t.getOSName(!0) === \"windows\";\n    },\n    describe() {\n      return {\n        type: M.desktop\n      };\n    }\n  },\n  /* Linux */\n  {\n    test(t) {\n      return t.getOSName(!0) === \"linux\";\n    },\n    describe() {\n      return {\n        type: M.desktop\n      };\n    }\n  },\n  /* PlayStation 4 */\n  {\n    test(t) {\n      return t.getOSName(!0) === \"playstation 4\";\n    },\n    describe() {\n      return {\n        type: M.tv\n      };\n    }\n  },\n  /* Roku */\n  {\n    test(t) {\n      return t.getOSName(!0) === \"roku\";\n    },\n    describe() {\n      return {\n        type: M.tv\n      };\n    }\n  }\n], Qe = [\n  /* EdgeHTML */\n  {\n    test(t) {\n      return t.getBrowserName(!0) === \"microsoft edge\";\n    },\n    describe(t) {\n      if (/\\sedg\\//i.test(t))\n        return {\n          name: P.Blink\n        };\n      const r = i.getFirstMatch(/edge\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return {\n        name: P.EdgeHTML,\n        version: r\n      };\n    }\n  },\n  /* Trident */\n  {\n    test: [/trident/i],\n    describe(t) {\n      const e = {\n        name: P.Trident\n      }, r = i.getFirstMatch(/trident\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  /* Presto */\n  {\n    test(t) {\n      return t.test(/presto/i);\n    },\n    describe(t) {\n      const e = {\n        name: P.Presto\n      }, r = i.getFirstMatch(/presto\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  /* Gecko */\n  {\n    test(t) {\n      const e = t.test(/gecko/i), r = t.test(/like gecko/i);\n      return e && !r;\n    },\n    describe(t) {\n      const e = {\n        name: P.Gecko\n      }, r = i.getFirstMatch(/gecko\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  },\n  /* Blink */\n  {\n    test: [/(apple)?webkit\\/537\\.36/i],\n    describe() {\n      return {\n        name: P.Blink\n      };\n    }\n  },\n  /* WebKit */\n  {\n    test: [/(apple)?webkit/i],\n    describe(t) {\n      const e = {\n        name: P.WebKit\n      }, r = i.getFirstMatch(/webkit\\/(\\d+(\\.?_?\\d+)+)/i, t);\n      return r && (e.version = r), e;\n    }\n  }\n];\nclass se {\n  /**\n   * Create instance of Parser\n   *\n   * @param {String} UA User-Agent string\n   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance\n   * improvements if you need to make a more particular parsing\n   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}\n   *\n   * @throw {Error} in case of empty UA String\n   *\n   * @constructor\n   */\n  constructor(e, r = !1) {\n    if (e == null || e === \"\")\n      throw new Error(\"UserAgent parameter can't be empty\");\n    this._ua = e, this.parsedResult = {}, r !== !0 && this.parse();\n  }\n  /**\n   * Get UserAgent string of current Parser instance\n   * @return {String} User-Agent String of the current <Parser> object\n   *\n   * @public\n   */\n  getUA() {\n    return this._ua;\n  }\n  /**\n   * Test a UA string for a regexp\n   * @param {RegExp} regex\n   * @return {Boolean}\n   */\n  test(e) {\n    return e.test(this._ua);\n  }\n  /**\n   * Get parsed browser object\n   * @return {Object}\n   */\n  parseBrowser() {\n    this.parsedResult.browser = {};\n    const e = i.find(De, (r) => {\n      if (typeof r.test == \"function\")\n        return r.test(this);\n      if (r.test instanceof Array)\n        return r.test.some((n) => this.test(n));\n      throw new Error(\"Browser's test function is not valid\");\n    });\n    return e && (this.parsedResult.browser = e.describe(this.getUA())), this.parsedResult.browser;\n  }\n  /**\n   * Get parsed browser object\n   * @return {Object}\n   *\n   * @public\n   */\n  getBrowser() {\n    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();\n  }\n  /**\n   * Get browser's name\n   * @return {String} Browser's name or an empty string\n   *\n   * @public\n   */\n  getBrowserName(e) {\n    return e ? String(this.getBrowser().name).toLowerCase() || \"\" : this.getBrowser().name || \"\";\n  }\n  /**\n   * Get browser's version\n   * @return {String} version of browser\n   *\n   * @public\n   */\n  getBrowserVersion() {\n    return this.getBrowser().version;\n  }\n  /**\n   * Get OS\n   * @return {Object}\n   *\n   * @example\n   * this.getOS();\n   * {\n   *   name: 'macOS',\n   *   version: '10.11.12'\n   * }\n   */\n  getOS() {\n    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();\n  }\n  /**\n   * Parse OS and save it to this.parsedResult.os\n   * @return {*|{}}\n   */\n  parseOS() {\n    this.parsedResult.os = {};\n    const e = i.find(qe, (r) => {\n      if (typeof r.test == \"function\")\n        return r.test(this);\n      if (r.test instanceof Array)\n        return r.test.some((n) => this.test(n));\n      throw new Error(\"Browser's test function is not valid\");\n    });\n    return e && (this.parsedResult.os = e.describe(this.getUA())), this.parsedResult.os;\n  }\n  /**\n   * Get OS name\n   * @param {Boolean} [toLowerCase] return lower-cased value\n   * @return {String} name of the OS  macOS, Windows, Linux, etc.\n   */\n  getOSName(e) {\n    const { name: r } = this.getOS();\n    return e ? String(r).toLowerCase() || \"\" : r || \"\";\n  }\n  /**\n   * Get OS version\n   * @return {String} full version with dots ('10.11.12', '5.6', etc)\n   */\n  getOSVersion() {\n    return this.getOS().version;\n  }\n  /**\n   * Get parsed platform\n   * @return {{}}\n   */\n  getPlatform() {\n    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();\n  }\n  /**\n   * Get platform name\n   * @param {Boolean} [toLowerCase=false]\n   * @return {*}\n   */\n  getPlatformType(e = !1) {\n    const { type: r } = this.getPlatform();\n    return e ? String(r).toLowerCase() || \"\" : r || \"\";\n  }\n  /**\n   * Get parsed platform\n   * @return {{}}\n   */\n  parsePlatform() {\n    this.parsedResult.platform = {};\n    const e = i.find(Ge, (r) => {\n      if (typeof r.test == \"function\")\n        return r.test(this);\n      if (r.test instanceof Array)\n        return r.test.some((n) => this.test(n));\n      throw new Error(\"Browser's test function is not valid\");\n    });\n    return e && (this.parsedResult.platform = e.describe(this.getUA())), this.parsedResult.platform;\n  }\n  /**\n   * Get parsed engine\n   * @return {{}}\n   */\n  getEngine() {\n    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();\n  }\n  /**\n   * Get engines's name\n   * @return {String} Engines's name or an empty string\n   *\n   * @public\n   */\n  getEngineName(e) {\n    return e ? String(this.getEngine().name).toLowerCase() || \"\" : this.getEngine().name || \"\";\n  }\n  /**\n   * Get parsed platform\n   * @return {{}}\n   */\n  parseEngine() {\n    this.parsedResult.engine = {};\n    const e = i.find(Qe, (r) => {\n      if (typeof r.test == \"function\")\n        return r.test(this);\n      if (r.test instanceof Array)\n        return r.test.some((n) => this.test(n));\n      throw new Error(\"Browser's test function is not valid\");\n    });\n    return e && (this.parsedResult.engine = e.describe(this.getUA())), this.parsedResult.engine;\n  }\n  /**\n   * Parse full information about the browser\n   * @returns {Parser}\n   */\n  parse() {\n    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;\n  }\n  /**\n   * Get parsed result\n   * @return {ParsedResult}\n   */\n  getResult() {\n    return i.assign({}, this.parsedResult);\n  }\n  /**\n   * Check if parsed browser matches certain conditions\n   *\n   * @param {Object} checkTree It's one or two layered object,\n   * which can include a platform or an OS on the first layer\n   * and should have browsers specs on the bottom-laying layer\n   *\n   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.\n   * Returns `undefined` when the browser is no described in the checkTree object.\n   *\n   * @example\n   * const browser = Bowser.getParser(window.navigator.userAgent);\n   * if (browser.satisfies({chrome: '>118.01.1322' }))\n   * // or with os\n   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))\n   * // or with platforms\n   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))\n   */\n  satisfies(e) {\n    const r = {};\n    let n = 0;\n    const o = {};\n    let s = 0;\n    if (Object.keys(e).forEach((h) => {\n      const w = e[h];\n      typeof w == \"string\" ? (o[h] = w, s += 1) : typeof w == \"object\" && (r[h] = w, n += 1);\n    }), n > 0) {\n      const h = Object.keys(r), w = i.find(h, (a) => this.isOS(a));\n      if (w) {\n        const a = this.satisfies(r[w]);\n        if (a !== void 0)\n          return a;\n      }\n      const l = i.find(\n        h,\n        (a) => this.isPlatform(a)\n      );\n      if (l) {\n        const a = this.satisfies(r[l]);\n        if (a !== void 0)\n          return a;\n      }\n    }\n    if (s > 0) {\n      const h = Object.keys(o), w = i.find(h, (l) => this.isBrowser(l, !0));\n      if (w !== void 0)\n        return this.compareVersion(o[w]);\n    }\n  }\n  /**\n   * Check if the browser name equals the passed string\n   * @param browserName The string to compare with the browser name\n   * @param [includingAlias=false] The flag showing whether alias will be included into comparison\n   * @returns {boolean}\n   */\n  isBrowser(e, r = !1) {\n    const n = this.getBrowserName().toLowerCase();\n    let o = e.toLowerCase();\n    const s = i.getBrowserTypeByAlias(o);\n    return r && s && (o = s.toLowerCase()), o === n;\n  }\n  compareVersion(e) {\n    let r = [0], n = e, o = !1;\n    const s = this.getBrowserVersion();\n    if (typeof s == \"string\")\n      return e[0] === \">\" || e[0] === \"<\" ? (n = e.substr(1), e[1] === \"=\" ? (o = !0, n = e.substr(2)) : r = [], e[0] === \">\" ? r.push(1) : r.push(-1)) : e[0] === \"=\" ? n = e.substr(1) : e[0] === \"~\" && (o = !0, n = e.substr(1)), r.indexOf(\n        i.compareVersions(s, n, o)\n      ) > -1;\n  }\n  isOS(e) {\n    return this.getOSName(!0) === String(e).toLowerCase();\n  }\n  isPlatform(e) {\n    return this.getPlatformType(!0) === String(e).toLowerCase();\n  }\n  isEngine(e) {\n    return this.getEngineName(!0) === String(e).toLowerCase();\n  }\n  /**\n   * Is anything? Check if the browser is called \"anything\",\n   * the OS called \"anything\" or the platform called \"anything\"\n   * @param {String} anything\n   * @param [includingAlias=false] The flag showing whether alias will be included into comparison\n   * @returns {Boolean}\n   */\n  is(e, r = !1) {\n    return this.isBrowser(e, r) || this.isOS(e) || this.isPlatform(e);\n  }\n  /**\n   * Check if any of the given values satisfies this.is(anything)\n   * @param {String[]} anythings\n   * @returns {Boolean}\n   */\n  some(e = []) {\n    return e.some((r) => this.is(r));\n  }\n}\n/*!\n * Bowser - a browser detector\n * https://github.com/lancedikson/bowser\n * MIT License | (c) Dustin Diaz 2012-2015\n * MIT License | (c) Denis Demchenko 2015-2019\n */\nclass Xe {\n  /**\n   * Creates a {@link Parser} instance\n   *\n   * @param {String} UA UserAgent string\n   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it\n   * explicitly. Same as `skipParsing` for {@link Parser}.\n   * @returns {Parser}\n   * @throws {Error} when UA is not a String\n   *\n   * @example\n   * const parser = Bowser.getParser(window.navigator.userAgent);\n   * const result = parser.getResult();\n   */\n  static getParser(e, r = !1) {\n    if (typeof e != \"string\")\n      throw new Error(\"UserAgent should be a string\");\n    return new se(e, r);\n  }\n  /**\n   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately\n   *\n   * @param UA\n   * @return {ParsedResult}\n   *\n   * @example\n   * const result = Bowser.parse(window.navigator.userAgent);\n   */\n  static parse(e) {\n    return new se(e).getResult();\n  }\n  static get BROWSER_MAP() {\n    return be;\n  }\n  static get ENGINE_MAP() {\n    return P;\n  }\n  static get OS_MAP() {\n    return F;\n  }\n  static get PLATFORMS_MAP() {\n    return M;\n  }\n}\nconst ae = typeof window < \"u\" ? window : null;\nfunction He() {\n  if (!ae)\n    return null;\n  switch (Xe.getParser(ae.navigator.userAgent).getBrowserName()?.toLowerCase()) {\n    case \"firefox\":\n      return \"firefox\";\n    case \"microsoft edge\":\n      return \"edge\";\n    case \"android browser\":\n    case \"chrome\":\n    case \"chromium\":\n    case \"electron\":\n    case \"opera\":\n    case \"vivaldi\":\n      return \"chrome\";\n    default:\n      return null;\n  }\n}\nvar Ue = typeof global == \"object\" && global && global.Object === Object && global;\nconst Ze = Ue;\nvar Ke = typeof self == \"object\" && self && self.Object === Object && self, Ye = Ze || Ke || Function(\"return this\")();\nconst $e = Ye;\nvar Je = $e.Symbol;\nconst Y = Je;\nvar me = Object.prototype, et = me.hasOwnProperty, tt = me.toString, G = Y ? Y.toStringTag : void 0;\nfunction rt(t) {\n  var e = et.call(t, G), r = t[G];\n  try {\n    t[G] = void 0;\n    var n = !0;\n  } catch {\n  }\n  var o = tt.call(t);\n  return n && (e ? t[G] = r : delete t[G]), o;\n}\nvar nt = Object.prototype, it = nt.toString;\nfunction ot(t) {\n  return it.call(t);\n}\nvar st = \"[object Null]\", at = \"[object Undefined]\", ce = Y ? Y.toStringTag : void 0;\nfunction ct(t) {\n  return t == null ? t === void 0 ? at : st : ce && ce in Object(t) ? rt(t) : ot(t);\n}\nfunction lt(t) {\n  return t != null && typeof t == \"object\";\n}\nvar dt = Array.isArray;\nconst ut = dt;\nvar ft = \"[object String]\";\nfunction te(t) {\n  return typeof t == \"string\" || !ut(t) && lt(t) && ct(t) == ft;\n}\nconst wt = ({\n  availableConnectors: t,\n  installedWallets: e,\n  discoveryWallets: r,\n  storeVersion: n,\n  customOrder: o\n}) => {\n  if (window?.starknet_argentX?.isInAppBrowser)\n    return [];\n  const h = e.map(\n    (a) => t.find((g) => g.id === a.id)\n  );\n  return (o ? t : [\n    ...t.filter((a) => h.includes(a)),\n    ...t.filter((a) => !h.includes(a))\n  ]).map((a) => {\n    const g = e.find((f) => f.id === a.id);\n    if (g) {\n      const f = g.id === \"argentX\" ? { light: _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__.A, dark: _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__.A } : te(g.icon) ? { light: g.icon, dark: g.icon } : g.icon;\n      return {\n        name: g.name,\n        id: g.id,\n        icon: f,\n        connector: a\n      };\n    }\n    const y = r.filter(\n      (f) => !!f.downloads[n]\n    ).find((f) => f.id === a.id);\n    if (y) {\n      const { downloads: f } = y, b = y.id === \"argentX\" ? _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__.A : y.icon;\n      return {\n        name: y.name,\n        id: y.id,\n        icon: { light: b, dark: b },\n        connector: a,\n        download: f[n]\n      };\n    }\n    return !a || !a.id || !a.name ? null : {\n      name: a.name,\n      id: a.id,\n      icon: a.icon,\n      connector: a,\n      title: \"title\" in a && te(a.title) ? a.title : void 0,\n      subtitle: \"subtitle\" in a && te(a.subtitle) ? a.subtitle : void 0\n    };\n  }).filter((a) => a !== null);\n};\nfunction R() {\n}\nfunction ve(t) {\n  return t();\n}\nfunction le() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction j(t) {\n  t.forEach(ve);\n}\nfunction ye(t) {\n  return typeof t == \"function\";\n}\nfunction ke(t, e) {\n  return t != t ? e == e : t !== e || t && typeof t == \"object\" || typeof t == \"function\";\n}\nlet U;\nfunction _e(t, e) {\n  return t === e ? !0 : (U || (U = document.createElement(\"a\")), U.href = e, t === U.href);\n}\nfunction gt(t) {\n  return Object.keys(t).length === 0;\n}\nfunction _(t, e) {\n  t.appendChild(e);\n}\nfunction W(t, e, r) {\n  t.insertBefore(e, r || null);\n}\nfunction E(t) {\n  t.parentNode && t.parentNode.removeChild(t);\n}\nfunction ht(t, e) {\n  for (let r = 0; r < t.length; r += 1)\n    t[r] && t[r].d(e);\n}\nfunction B(t) {\n  return document.createElement(t);\n}\nfunction I(t) {\n  return document.createTextNode(t);\n}\nfunction z() {\n  return I(\" \");\n}\nfunction xe() {\n  return I(\"\");\n}\nfunction O(t, e, r, n) {\n  return t.addEventListener(e, r, n), () => t.removeEventListener(e, r, n);\n}\nfunction p(t, e, r) {\n  r == null ? t.removeAttribute(e) : t.getAttribute(e) !== r && t.setAttribute(e, r);\n}\nfunction pt(t) {\n  return Array.from(t.childNodes);\n}\nfunction $(t, e) {\n  e = \"\" + e, t.data !== e && (t.data = /** @type {string} */\n  e);\n}\nfunction Me(t, e, r, n) {\n  r == null ? t.style.removeProperty(e) : t.style.setProperty(e, r, n ? \"important\" : \"\");\n}\nlet X;\nfunction Q(t) {\n  X = t;\n}\nfunction bt() {\n  if (!X)\n    throw new Error(\"Function called outside component initialization\");\n  return X;\n}\nfunction mt(t) {\n  bt().$$.on_mount.push(t);\n}\nconst D = [], de = [];\nlet q = [];\nconst ue = [], vt = /* @__PURE__ */ Promise.resolve();\nlet ne = !1;\nfunction yt() {\n  ne || (ne = !0, vt.then(Se));\n}\nfunction ie(t) {\n  q.push(t);\n}\nconst re = /* @__PURE__ */ new Set();\nlet V = 0;\nfunction Se() {\n  if (V !== 0)\n    return;\n  const t = X;\n  do {\n    try {\n      for (; V < D.length; ) {\n        const e = D[V];\n        V++, Q(e), kt(e.$$);\n      }\n    } catch (e) {\n      throw D.length = 0, V = 0, e;\n    }\n    for (Q(null), D.length = 0, V = 0; de.length; )\n      de.pop()();\n    for (let e = 0; e < q.length; e += 1) {\n      const r = q[e];\n      re.has(r) || (re.add(r), r());\n    }\n    q.length = 0;\n  } while (D.length);\n  for (; ue.length; )\n    ue.pop()();\n  ne = !1, re.clear(), Q(t);\n}\nfunction kt(t) {\n  if (t.fragment !== null) {\n    t.update(), j(t.before_update);\n    const e = t.dirty;\n    t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(ie);\n  }\n}\nfunction _t(t) {\n  const e = [], r = [];\n  q.forEach((n) => t.indexOf(n) === -1 ? e.push(n) : r.push(n)), r.forEach((n) => n()), q = e;\n}\nconst K = /* @__PURE__ */ new Set();\nlet T;\nfunction Be() {\n  T = {\n    r: 0,\n    c: [],\n    p: T\n    // parent group\n  };\n}\nfunction Fe() {\n  T.r || j(T.c), T = T.p;\n}\nfunction L(t, e) {\n  t && t.i && (K.delete(t), t.i(e));\n}\nfunction H(t, e, r, n) {\n  if (t && t.o) {\n    if (K.has(t))\n      return;\n    K.add(t), T.c.push(() => {\n      K.delete(t), n && (r && t.d(1), n());\n    }), t.o(e);\n  } else\n    n && n();\n}\nfunction fe(t) {\n  return t?.length !== void 0 ? t : Array.from(t);\n}\nfunction xt(t) {\n  t && t.c();\n}\nfunction Ce(t, e, r) {\n  const { fragment: n, after_update: o } = t.$$;\n  n && n.m(e, r), ie(() => {\n    const s = t.$$.on_mount.map(ve).filter(ye);\n    t.$$.on_destroy ? t.$$.on_destroy.push(...s) : j(s), t.$$.on_mount = [];\n  }), o.forEach(ie);\n}\nfunction Ae(t, e) {\n  const r = t.$$;\n  r.fragment !== null && (_t(r.after_update), j(r.on_destroy), r.fragment && r.fragment.d(e), r.on_destroy = r.fragment = null, r.ctx = []);\n}\nfunction Mt(t, e) {\n  t.$$.dirty[0] === -1 && (D.push(t), yt(), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31;\n}\nfunction Oe(t, e, r, n, o, s, d = null, h = [-1]) {\n  const w = X;\n  Q(t);\n  const l = t.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props: s,\n    update: R,\n    not_equal: o,\n    bound: le(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(e.context || (w ? w.$$.context : [])),\n    // everything else\n    callbacks: le(),\n    dirty: h,\n    skip_bound: !1,\n    root: e.target || w.$$.root\n  };\n  d && d(l.root);\n  let a = !1;\n  if (l.ctx = r ? r(t, e.props || {}, (g, y, ...f) => {\n    const b = f.length ? f[0] : y;\n    return l.ctx && o(l.ctx[g], l.ctx[g] = b) && (!l.skip_bound && l.bound[g] && l.bound[g](b), a && Mt(t, g)), y;\n  }) : [], l.update(), a = !0, j(l.before_update), l.fragment = n ? n(l.ctx) : !1, e.target) {\n    if (e.hydrate) {\n      const g = pt(e.target);\n      l.fragment && l.fragment.l(g), g.forEach(E);\n    } else\n      l.fragment && l.fragment.c();\n    e.intro && L(t.$$.fragment), Ce(t, e.target, e.anchor), Se();\n  }\n  Q(w);\n}\nclass Ne {\n  constructor() {\n    /**\n     * ### PRIVATE API\n     *\n     * Do not use, may change at any time\n     *\n     * @type {any}\n     */\n    J(this, \"$$\");\n    /**\n     * ### PRIVATE API\n     *\n     * Do not use, may change at any time\n     *\n     * @type {any}\n     */\n    J(this, \"$$set\");\n  }\n  /** @returns {void} */\n  $destroy() {\n    Ae(this, 1), this.$destroy = R;\n  }\n  /**\n   * @template {Extract<keyof Events, string>} K\n   * @param {K} type\n   * @param {((e: Events[K]) => void) | null | undefined} callback\n   * @returns {() => void}\n   */\n  $on(e, r) {\n    if (!ye(r))\n      return R;\n    const n = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);\n    return n.push(r), () => {\n      const o = n.indexOf(r);\n      o !== -1 && n.splice(o, 1);\n    };\n  }\n  /**\n   * @param {Partial<Props>} props\n   * @returns {void}\n   */\n  $set(e) {\n    this.$$set && !gt(e) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1);\n  }\n}\nconst St = \"4\";\ntypeof window < \"u\" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(St);\nfunction Bt(t) {\n  let e, r, n, o, s, d = (\n    /*wallet*/\n    (t[0].title ?? /*wallet*/\n    t[0].name) + \"\"\n  ), h, w, l, a = (\n    /*wallet*/\n    (t[0].subtitle ?? \"\") + \"\"\n  ), g, y, f, b;\n  function x(v, u) {\n    return (\n      /*loadingItem*/\n      v[2] === /*wallet*/\n      v[0]?.id ? Ot : (\n        /*isSvg*/\n        v[4] ? At : Ct\n      )\n    );\n  }\n  let m = x(t), c = m(t);\n  return {\n    c() {\n      e = B(\"li\"), r = B(\"span\"), n = z(), o = B(\"div\"), s = B(\"p\"), h = I(d), w = z(), l = B(\"p\"), g = I(a), y = z(), c.c(), p(r, \"class\", \"w-8 h-8\"), p(s, \"class\", \"font-semibold text-base p\"), p(l, \"class\", \"l2 p\"), Me(l, \"text-align\", \"center\"), p(o, \"class\", \"flex flex-col justify-center items-center\"), p(e, \"class\", `flex flex-row-reverse justify-between items-center \n            p-3 rounded-md cursor-pointer shadow-list-item \n            dark:shadow-none dark:bg-neutral-800 dark:text-white \n          hover:bg-neutral-100 dark:hover:bg-neutral-700 \n          focus:outline-none focus:ring-2 \n        focus:ring-neutral-200 dark:focus:ring-neutral-700 \n          transition-colors`), p(e, \"role\", \"button\"), p(e, \"tabindex\", \"0\");\n    },\n    m(v, u) {\n      W(v, e, u), _(e, r), _(e, n), _(e, o), _(o, s), _(s, h), _(o, w), _(o, l), _(l, g), _(e, y), c.m(e, null), f || (b = [\n        O(\n          e,\n          \"click\",\n          /*click_handler_1*/\n          t[8]\n        ),\n        O(\n          e,\n          \"keyup\",\n          /*keyup_handler_1*/\n          t[9]\n        )\n      ], f = !0);\n    },\n    p(v, u) {\n      u & /*wallet*/\n      1 && d !== (d = /*wallet*/\n      (v[0].title ?? /*wallet*/\n      v[0].name) + \"\") && $(h, d), u & /*wallet*/\n      1 && a !== (a = /*wallet*/\n      (v[0].subtitle ?? \"\") + \"\") && $(g, a), m === (m = x(v)) && c ? c.p(v, u) : (c.d(1), c = m(v), c && (c.c(), c.m(e, null)));\n    },\n    d(v) {\n      v && E(e), c.d(), f = !1, j(b);\n    }\n  };\n}\nfunction Ft(t) {\n  let e, r, n, o, s, d, h = (\n    /*wallet*/\n    t[0].name + \"\"\n  ), w, l, a, g, y, f, b, x, m;\n  return {\n    c() {\n      e = B(\"a\"), r = B(\"li\"), n = B(\"span\"), o = z(), s = B(\"p\"), d = I(\"Install \"), w = I(h), l = z(), a = B(\"img\"), p(n, \"class\", \"w-8 h-8\"), p(s, \"class\", \"font-semibold text-base p\"), p(a, \"alt\", g = /*wallet*/\n      t[0].name), _e(a.src, y = /*icon*/\n      t[3]) || p(a, \"src\", y), p(a, \"class\", \"w-8 h-8 rounded-full\"), p(r, \"class\", `flex flex-row-reverse justify-between items-center \n              p-3 rounded-md cursor-pointer shadow-list-item \n              dark:shadow-none dark:bg-neutral-800 dark:text-white \n            hover:bg-neutral-100 dark:hover:bg-neutral-700`), p(e, \"aria-label\", f = /*wallet*/\n      t[0].name + \" download link\"), p(e, \"href\", b = /*wallet*/\n      t[0].download), p(e, \"target\", \"_blank\"), p(e, \"rel\", \"noopener noreferrer\"), p(e, \"class\", `rounded-md focus:outline-none  focus:ring-2 \n    focus:ring-neutral-200  dark:focus:ring-neutral-700 transition-colors`);\n    },\n    m(c, v) {\n      W(c, e, v), _(e, r), _(r, n), _(r, o), _(r, s), _(s, d), _(s, w), _(r, l), _(r, a), x || (m = [\n        O(\n          r,\n          \"click\",\n          /*click_handler*/\n          t[6]\n        ),\n        O(\n          r,\n          \"keyup\",\n          /*keyup_handler*/\n          t[7]\n        )\n      ], x = !0);\n    },\n    p(c, v) {\n      v & /*wallet*/\n      1 && h !== (h = /*wallet*/\n      c[0].name + \"\") && $(w, h), v & /*wallet*/\n      1 && g !== (g = /*wallet*/\n      c[0].name) && p(a, \"alt\", g), v & /*wallet*/\n      1 && f !== (f = /*wallet*/\n      c[0].name + \" download link\") && p(e, \"aria-label\", f), v & /*wallet*/\n      1 && b !== (b = /*wallet*/\n      c[0].download) && p(e, \"href\", b);\n    },\n    d(c) {\n      c && E(e), x = !1, j(m);\n    }\n  };\n}\nfunction Ct(t) {\n  let e, r, n;\n  return {\n    c() {\n      e = B(\"img\"), p(e, \"alt\", r = /*wallet*/\n      t[0]?.name), _e(e.src, n = /*icon*/\n      t[3]) || p(e, \"src\", n), p(e, \"class\", \"w-8 h-8 rounded\");\n    },\n    m(o, s) {\n      W(o, e, s);\n    },\n    p(o, s) {\n      s & /*wallet*/\n      1 && r !== (r = /*wallet*/\n      o[0]?.name) && p(e, \"alt\", r);\n    },\n    d(o) {\n      o && E(e);\n    }\n  };\n}\nfunction At(t) {\n  let e;\n  return {\n    c() {\n      e = B(\"div\"), Me(e, \"position\", \"relative\");\n    },\n    m(r, n) {\n      W(r, e, n), e.innerHTML = /*icon*/\n      t[3];\n    },\n    p: R,\n    d(r) {\n      r && E(e);\n    }\n  };\n}\nfunction Ot(t) {\n  let e;\n  return {\n    c() {\n      e = B(\"div\"), e.innerHTML = '<svg aria-hidden=\"true\" class=\"w-8 h-8 text-neutral-300 animate-spin dark:text-neutral-600 fill-neutral-600 dark:fill-neutral-300\" viewBox=\"0 0 100 101\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z\" fill=\"currentColor\"></path><path d=\"M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z\" fill=\"currentFill\"></path></svg> <span class=\"sr-only\">Loading...</span>', p(e, \"role\", \"status\");\n    },\n    m(r, n) {\n      W(r, e, n);\n    },\n    p: R,\n    d(r) {\n      r && E(e);\n    }\n  };\n}\nfunction Nt(t) {\n  let e;\n  function r(s, d) {\n    return (\n      /*wallet*/\n      s[0].download ? Ft : Bt\n    );\n  }\n  let n = r(t), o = n(t);\n  return {\n    c() {\n      o.c(), e = xe();\n    },\n    m(s, d) {\n      o.m(s, d), W(s, e, d);\n    },\n    p(s, [d]) {\n      n === (n = r(s)) && o ? o.p(s, d) : (o.d(1), o = n(s), o && (o.c(), o.m(e.parentNode, e)));\n    },\n    i: R,\n    o: R,\n    d(s) {\n      s && E(e), o.d(s);\n    }\n  };\n}\nfunction Et(t, e, r) {\n  let { wallet: n } = e, { theme: o = null } = e, { cb: s = async () => {\n  } } = e, { loadingItem: d = !1 } = e;\n  const h = typeof n.icon == \"string\" ? n.icon : o === \"dark\" ? n.icon.dark : n.icon.light, w = h?.startsWith(\"<svg\"), l = () => {\n    s(null);\n  }, a = (f) => {\n    f.key === \"Enter\" && s(null);\n  }, g = async () => {\n    s(n.connector);\n  }, y = async (f) => {\n    f.key === \"Enter\" && s(n.connector);\n  };\n  return t.$$set = (f) => {\n    \"wallet\" in f && r(0, n = f.wallet), \"theme\" in f && r(5, o = f.theme), \"cb\" in f && r(1, s = f.cb), \"loadingItem\" in f && r(2, d = f.loadingItem);\n  }, [\n    n,\n    s,\n    d,\n    h,\n    w,\n    o,\n    l,\n    a,\n    g,\n    y\n  ];\n}\nclass Pt extends Ne {\n  constructor(e) {\n    super(), Oe(this, e, Et, Nt, ke, {\n      wallet: 0,\n      theme: 5,\n      cb: 1,\n      loadingItem: 2\n    });\n  }\n}\nfunction we(t, e, r) {\n  const n = t.slice();\n  return n[16] = e[r], n;\n}\nfunction ge(t) {\n  let e, r, n, o, s, d, h, w, l, a, g, y, f, b, x, m = fe(\n    /*modalWallets*/\n    t[1]\n  ), c = [];\n  for (let u = 0; u < m.length; u += 1)\n    c[u] = he(we(t, m, u));\n  const v = (u) => H(c[u], 1, 1, () => {\n    c[u] = null;\n  });\n  return {\n    c() {\n      e = B(\"div\"), r = B(\"main\"), n = B(\"header\"), o = B(\"h2\"), o.textContent = \"Connect to\", s = z(), d = B(\"h1\"), h = I(\n        /*dappName*/\n        t[0]\n      ), w = z(), l = B(\"span\"), l.innerHTML = '<svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.77275 3.02275C9.99242 2.80308 9.99242 2.44692 9.77275 2.22725C9.55308 2.00758 9.19692 2.00758 8.97725 2.22725L6 5.20451L3.02275 2.22725C2.80308 2.00758 2.44692 2.00758 2.22725 2.22725C2.00758 2.44692 2.00758 2.80308 2.22725 3.02275L5.20451 6L2.22725 8.97725C2.00758 9.19692 2.00758 9.55308 2.22725 9.77275C2.44692 9.99242 2.80308 9.99242 3.02275 9.77275L6 6.79549L8.97725 9.77275C9.19692 9.99242 9.55308 9.99242 9.77275 9.77275C9.99242 9.55308 9.99242 9.19692 9.77275 8.97725L6.79549 6L9.77275 3.02275Z\" fill=\"currentColor\"></path></svg>', a = z(), g = B(\"ul\");\n      for (let u = 0; u < c.length; u += 1)\n        c[u].c();\n      p(o, \"class\", \"text-sm text-gray-400 font-semibold\"), p(d, \"class\", `text-xl font-semibold mb-6 \n                  max-w-[240px] overflow-hidden \n                  whitespace-nowrap text-ellipsis`), p(l, \"class\", `absolute top-0 right-0 p-2 cursor-pointer\n                  rounded-full bg-neutral-100 dark:bg-neutral-800\n                  text-neutral-400 dark:text-white\n                  hover:bg-neutral-100 dark:hover:bg-neutral-700\n                  focus:outline-none focus:ring-2\n                focus:ring-neutral-200 dark:focus:ring-neutral-700\n                  transition-colors`), p(l, \"role\", \"button\"), p(l, \"tabindex\", \"0\"), p(l, \"aria-label\", \"Close\"), p(n, \"class\", \"flex items-center justify-center flex-col mb-2 relative\"), p(g, \"class\", \"flex flex-col gap-3\"), p(r, \"role\", \"dialog\"), p(r, \"class\", `rounded-3xl shadow-modal dark:shadow-none \n              w-full max-w-[380px] z-50 \n              mx-6 p-6 pb-8 text-center \n              bg-slate-50 dark:bg-neutral-900 \n            text-neutral-900 dark:text-white`), p(e, \"part\", \"starknetkit-modal\"), p(e, \"class\", y = `modal-font backdrop-blur-sm fixed inset-0 flex items-center \n            justify-center bg-black/25 z-[9999] ${/*darkModeControlClass*/\n      t[4]}`);\n    },\n    m(u, C) {\n      W(u, e, C), _(e, r), _(r, n), _(n, o), _(n, s), _(n, d), _(d, h), _(n, w), _(n, l), _(r, a), _(r, g);\n      for (let S = 0; S < c.length; S += 1)\n        c[S] && c[S].m(g, null);\n      f = !0, b || (x = [\n        O(\n          l,\n          \"click\",\n          /*click_handler*/\n          t[8]\n        ),\n        O(\n          l,\n          \"keyup\",\n          /*keyup_handler*/\n          t[9]\n        ),\n        O(r, \"click\", Lt),\n        O(r, \"keyup\", jt),\n        O(\n          e,\n          \"click\",\n          /*click_handler_2*/\n          t[10]\n        ),\n        O(\n          e,\n          \"keyup\",\n          /*keyup_handler_2*/\n          t[11]\n        )\n      ], b = !0);\n    },\n    p(u, C) {\n      if ((!f || C & /*dappName*/\n      1) && $(\n        h,\n        /*dappName*/\n        u[0]\n      ), C & /*modalWallets, loadingItem, cb, theme*/\n      78) {\n        m = fe(\n          /*modalWallets*/\n          u[1]\n        );\n        let S;\n        for (S = 0; S < m.length; S += 1) {\n          const oe = we(u, m, S);\n          c[S] ? (c[S].p(oe, C), L(c[S], 1)) : (c[S] = he(oe), c[S].c(), L(c[S], 1), c[S].m(g, null));\n        }\n        for (Be(), S = m.length; S < c.length; S += 1)\n          v(S);\n        Fe();\n      }\n      (!f || C & /*darkModeControlClass*/\n      16 && y !== (y = `modal-font backdrop-blur-sm fixed inset-0 flex items-center \n            justify-center bg-black/25 z-[9999] ${/*darkModeControlClass*/\n      u[4]}`)) && p(e, \"class\", y);\n    },\n    i(u) {\n      if (!f) {\n        for (let C = 0; C < m.length; C += 1)\n          L(c[C]);\n        f = !0;\n      }\n    },\n    o(u) {\n      c = c.filter(Boolean);\n      for (let C = 0; C < c.length; C += 1)\n        H(c[C]);\n      f = !1;\n    },\n    d(u) {\n      u && E(e), ht(c, u), b = !1, j(x);\n    }\n  };\n}\nfunction he(t) {\n  let e, r;\n  return e = new Pt({\n    props: {\n      wallet: (\n        /*wallet*/\n        t[16]\n      ),\n      loadingItem: (\n        /*loadingItem*/\n        t[3]\n      ),\n      cb: (\n        /*cb*/\n        t[6]\n      ),\n      theme: (\n        /*theme*/\n        t[2]\n      )\n    }\n  }), {\n    c() {\n      xt(e.$$.fragment);\n    },\n    m(n, o) {\n      Ce(e, n, o), r = !0;\n    },\n    p(n, o) {\n      const s = {};\n      o & /*modalWallets*/\n      2 && (s.wallet = /*wallet*/\n      n[16]), o & /*loadingItem*/\n      8 && (s.loadingItem = /*loadingItem*/\n      n[3]), o & /*theme*/\n      4 && (s.theme = /*theme*/\n      n[2]), e.$set(s);\n    },\n    i(n) {\n      r || (L(e.$$.fragment, n), r = !0);\n    },\n    o(n) {\n      H(e.$$.fragment, n), r = !1;\n    },\n    d(n) {\n      Ae(e, n);\n    }\n  };\n}\nfunction zt(t) {\n  let e, r, n = !/*isInAppBrowser*/\n  t[5] && /*modalWallets*/\n  t[1].length > 1 && ge(t);\n  return {\n    c() {\n      n && n.c(), e = xe();\n    },\n    m(o, s) {\n      n && n.m(o, s), W(o, e, s), r = !0;\n    },\n    p(o, [s]) {\n      !/*isInAppBrowser*/\n      o[5] && /*modalWallets*/\n      o[1].length > 1 ? n ? (n.p(o, s), s & /*modalWallets*/\n      2 && L(n, 1)) : (n = ge(o), n.c(), L(n, 1), n.m(e.parentNode, e)) : n && (Be(), H(n, 1, 1, () => {\n        n = null;\n      }), Fe());\n    },\n    i(o) {\n      r || (L(n), r = !0);\n    },\n    o(o) {\n      H(n), r = !1;\n    },\n    d(o) {\n      o && E(e), n && n.d(o);\n    }\n  };\n}\nconst Lt = (t) => t.stopPropagation(), jt = (t) => {\n  t.stopPropagation();\n};\nfunction Wt(t, e, r) {\n  let { dappName: n = window?.document.title ?? \"\" } = e, { modalWallets: o } = e, { callback: s = async () => {\n  } } = e, { theme: d = null } = e, h = !1, l = window?.starknet_argentX?.isInAppBrowser;\n  const g = navigator.userAgent.toLowerCase().includes(\"braavos\"), y = (u) => {\n    r(3, h = u);\n  };\n  let f = async (u) => {\n    y(u?.id ?? !1);\n    try {\n      await s(u ?? null);\n    } finally {\n      y(!1);\n    }\n  }, b = d === \"dark\" ? \"dark\" : \"\";\n  mt(async () => {\n    if (d === \"dark\" || d === null && window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? r(4, b = \"dark\") : r(4, b = \"\"), l && window?.starknet_argentX) {\n      try {\n        s(new _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__.I({ options: { id: \"argentX\" } }));\n      } catch {\n      }\n      return;\n    }\n    if (g && window?.starknet_braavos) {\n      try {\n        s(new _index_9bb48f8a_js__WEBPACK_IMPORTED_MODULE_6__.I({ options: { id: \"braavos\" } }));\n      } catch {\n      }\n      return;\n    }\n    if (o.length === 1)\n      try {\n        const [u] = o;\n        await s(u.connector);\n      } catch (u) {\n        console.error(u);\n      }\n  });\n  const x = () => f(null), m = (u) => {\n    u.key === \"Enter\" && f(null);\n  }, c = () => f(null), v = (u) => {\n    u.key === \"Escape\" && f(null);\n  };\n  return t.$$set = (u) => {\n    \"dappName\" in u && r(0, n = u.dappName), \"modalWallets\" in u && r(1, o = u.modalWallets), \"callback\" in u && r(7, s = u.callback), \"theme\" in u && r(2, d = u.theme);\n  }, [\n    n,\n    o,\n    d,\n    h,\n    b,\n    l,\n    f,\n    s,\n    x,\n    m,\n    c,\n    v\n  ];\n}\nclass Tt extends Ne {\n  constructor(e) {\n    super(), Oe(this, e, Wt, zt, ke, {\n      dappName: 0,\n      modalWallets: 1,\n      callback: 7,\n      theme: 2\n    });\n  }\n}\nconst Rt = `@import\"https://fonts.googleapis.com/css2?family=Barlow:wght@500;600&display=swap\";.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.visible{visibility:visible}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.inset-0{inset:0}.right-0{right:0}.top-0{top:0}.z-50{z-index:50}.z-\\\\[9999\\\\]{z-index:9999}.mx-6{margin-left:1.5rem;margin-right:1.5rem}.mb-2{margin-bottom:.5rem}.mb-6{margin-bottom:1.5rem}.block{display:block}.inline{display:inline}.flex{display:flex}.h-8{height:2rem}.w-8{width:2rem}.w-full{width:100%}.max-w-\\\\[240px\\\\]{max-width:240px}.max-w-\\\\[380px\\\\]{max-width:380px}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes spin{to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite}.cursor-pointer{cursor:pointer}.flex-row-reverse{flex-direction:row-reverse}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-3{gap:.75rem}.overflow-hidden{overflow:hidden}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.rounded{border-radius:.25rem}.rounded-3xl{border-radius:1.5rem}.rounded-full{border-radius:9999px}.rounded-md{border-radius:.375rem}.border{border-width:1px}.bg-black\\\\/25{background-color:#00000040}.bg-neutral-100{--tw-bg-opacity: 1;background-color:rgb(245 245 245 / var(--tw-bg-opacity, 1))}.bg-slate-50{--tw-bg-opacity: 1;background-color:rgb(248 250 252 / var(--tw-bg-opacity, 1))}.fill-neutral-600{fill:#525252}.p-2{padding:.5rem}.p-3{padding:.75rem}.p-6{padding:1.5rem}.pb-8{padding-bottom:2rem}.text-center{text-align:center}.text-base{font-size:1rem;line-height:1.5rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-semibold{font-weight:600}.text-gray-400{--tw-text-opacity: 1;color:rgb(156 163 175 / var(--tw-text-opacity, 1))}.text-neutral-300{--tw-text-opacity: 1;color:rgb(212 212 212 / var(--tw-text-opacity, 1))}.text-neutral-400{--tw-text-opacity: 1;color:rgb(163 163 163 / var(--tw-text-opacity, 1))}.text-neutral-900{--tw-text-opacity: 1;color:rgb(23 23 23 / var(--tw-text-opacity, 1))}.shadow-list-item{--tw-shadow: 0px 2px 12px rgba(0, 0, 0, .12);--tw-shadow-colored: 0px 2px 12px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-modal{--tw-shadow: 0px 4px 20px rgba(0, 0, 0, .5);--tw-shadow-colored: 0px 4px 20px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline{outline-style:solid}.blur{--tw-blur: blur(8px);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop-blur-sm{--tw-backdrop-blur: blur(4px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: \"\"}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",Segoe UI Symbol,\"Noto Color Emoji\";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.modal-font{font-family:Barlow,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-webkit-text-size-adjust:100%;-moz-text-size-adjust:100%;text-size-adjust:100%;font-feature-settings:\"kern\"}.l2{color:#8c8c8c;font-size:12px;font-weight:500;line-height:14px;letter-spacing:0em;text-align:left}.p{margin:0}.hover\\\\:bg-neutral-100:hover{--tw-bg-opacity: 1;background-color:rgb(245 245 245 / var(--tw-bg-opacity, 1))}.focus\\\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\\\\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\\\:ring-neutral-200:focus{--tw-ring-opacity: 1;--tw-ring-color: rgb(229 229 229 / var(--tw-ring-opacity, 1))}.dark\\\\:bg-neutral-800:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(38 38 38 / var(--tw-bg-opacity, 1))}.dark\\\\:bg-neutral-900:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(23 23 23 / var(--tw-bg-opacity, 1))}.dark\\\\:fill-neutral-300:is(.dark *){fill:#d4d4d4}.dark\\\\:text-neutral-600:is(.dark *){--tw-text-opacity: 1;color:rgb(82 82 82 / var(--tw-text-opacity, 1))}.dark\\\\:text-white:is(.dark *){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.dark\\\\:shadow-none:is(.dark *){--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.dark\\\\:hover\\\\:bg-neutral-700:hover:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(64 64 64 / var(--tw-bg-opacity, 1))}.dark\\\\:focus\\\\:ring-neutral-700:focus:is(.dark *){--tw-ring-opacity: 1;--tw-ring-color: rgb(64 64 64 / var(--tw-ring-opacity, 1))}\n`, Kt = (t) => ({\n  starknetkitConnectModal: async () => await It({\n    ...t,\n    resultType: t?.resultType ?? \"connector\"\n  })\n});\nlet N = null;\nconst It = async ({\n  modalMode: t = \"canAsk\",\n  storeVersion: e = He(),\n  modalTheme: r,\n  dappName: n,\n  resultType: o = \"wallet\",\n  ...s\n}) => {\n  const { webWalletUrl: d = _index_8edbd361_js__WEBPACK_IMPORTED_MODULE_3__.D, argentMobileOptions: h } = s, { connectors: w } = s;\n  N = null;\n  const l = !w || w.length === 0 ? Ie({\n    argentMobileOptions: h,\n    webWalletUrl: d\n  }) : w, a = localStorage.getItem(\"starknetLastConnectedWallet\");\n  if (t === \"neverAsk\")\n    try {\n      const b = l.find((m) => m.id === a) ?? null;\n      let x = null;\n      return b && o === \"wallet\" && (x = await b.connect()), {\n        connector: b,\n        wallet: b?.wallet ?? null,\n        connectorData: x\n      };\n    } catch (b) {\n      throw (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.r)(), new Error(b);\n    }\n  const g = await _core_d21d2e96_js__WEBPACK_IMPORTED_MODULE_0__.m.getAvailableWallets(s);\n  if (t === \"canAsk\" && a && ((await _core_d21d2e96_js__WEBPACK_IMPORTED_MODULE_0__.m.getAuthorizedWallets(s)).find((m) => m.id === a) ?? g.length === 1 ? g[0] : void 0)) {\n    const m = l.find((v) => v.id === a);\n    let c = null;\n    return o === \"wallet\" && (c = await m?.connect() ?? null), m && (N = m), {\n      connector: N,\n      connectorData: c,\n      wallet: m?.wallet ?? null\n    };\n  }\n  const y = wt({\n    availableConnectors: l,\n    installedWallets: g,\n    discoveryWallets: await _core_d21d2e96_js__WEBPACK_IMPORTED_MODULE_0__.m.getDiscoveryWallets(s),\n    storeVersion: e,\n    customOrder: w ? w?.length > 0 : !1\n  }), f = () => {\n    const b = \"starknetkit-modal-container\", x = document.getElementById(b);\n    if (x) {\n      if (x.shadowRoot)\n        return x.shadowRoot;\n      x.remove();\n    }\n    const m = document.createElement(\"div\");\n    m.id = b, document.body.appendChild(m);\n    const c = m.attachShadow({ mode: \"open\" });\n    return c.innerHTML = `<style>${Rt}</style>`, c;\n  };\n  return new Promise((b, x) => {\n    const m = new Tt({\n      target: f(),\n      props: {\n        dappName: n,\n        callback: async (c) => {\n          try {\n            if (N = c, o === \"wallet\") {\n              const v = await c?.connect() ?? null;\n              c !== null && (0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.s)(c.id), b({\n                connector: c,\n                connectorData: v,\n                wallet: c?.wallet ?? null\n              });\n            } else\n              b({\n                connector: c,\n                wallet: null,\n                connectorData: null\n              });\n          } catch (v) {\n            x(v);\n          } finally {\n            setTimeout(() => m.$destroy());\n          }\n        },\n        theme: r === \"system\" ? null : r ?? null,\n        modalWallets: y\n      }\n    });\n  });\n}, Yt = () => N ? N.wallet : null, $t = async (t = {}) => ((0,_lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__.r)(), N && await N.disconnect(), N = null, _core_d21d2e96_js__WEBPACK_IMPORTED_MODULE_0__.m.disconnect(t));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9zdGFya25ldGtpdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDNEM7QUFDbUI7QUFDN0M7QUFDcUM7QUFDVDtBQUN3QjtBQUNoQjtBQUNaO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxRQUFRLGlEQUFDLEdBQUcsV0FBVyxpQkFBaUI7QUFDeEM7QUFDQSxRQUFRLGlEQUFDLEdBQUcsV0FBVyxpQkFBaUI7QUFDeEMsS0FBSyxpREFBQztBQUNOLFFBQVEsaURBQUMsR0FBRyxXQUFXLGtCQUFrQjtBQUN6QyxLQUFLLGlEQUFDO0FBQ04sUUFBUSxpREFBQyxHQUFHLFdBQVcsaUJBQWlCO0FBQ3hDLEtBQUssaURBQUM7QUFDTixRQUFRLGlEQUFDLEdBQUcsV0FBVyxlQUFlO0FBQ3RDLGlCQUFpQixpREFBRSx5QkFBeUIseUVBQUUsZ0JBQWdCLGlEQUFFLEdBQUcsUUFBUTtBQUMzRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFNBQVMsV0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0JBQStCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGFBQWEsR0FBRztBQUNoQixhQUFhLDZDQUE2QztBQUMxRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsOEJBQThCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVksT0FBTyxrQkFBa0IsT0FBTztBQUNwRCxNQUFNLE9BQU8sc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7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cUMsYUFBYSxxQ0FBcUMscUJBQXFCLGdEQUFnRCwrQkFBK0IscUJBQXFCLG1EQUFtRCxnQ0FBZ0MsdUJBQXVCLCtCQUErQixxR0FBcUcsaURBQWlELG1CQUFtQix5REFBeUQsbURBQW1ELHFCQUFxQjtBQUMzZ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsVUFBVSxrQkFBa0IsaURBQUUsMkJBQTJCLE9BQU8sZ0JBQWdCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixZQUFZLDZEQUFFO0FBQ2Q7QUFDQSxrQkFBa0IsZ0RBQUM7QUFDbkIscUNBQXFDLGdEQUFDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQUM7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsbUNBQW1DLEdBQUc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkRBQUU7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUMsb0RBQW9ELE1BQU0sNkRBQUUseUNBQXlDLGdEQUFDO0FBTXJHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC9zdGFya25ldGtpdC5qcz85MTZhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBFZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBQZSA9ICh0LCBlLCByKSA9PiBlIGluIHQgPyBFZSh0LCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiByIH0pIDogdFtlXSA9IHI7XG52YXIgSiA9ICh0LCBlLCByKSA9PiAoUGUodCwgdHlwZW9mIGUgIT0gXCJzeW1ib2xcIiA/IGUgKyBcIlwiIDogZSwgciksIHIpO1xuaW1wb3J0IHsgbSBhcyBaIH0gZnJvbSBcIi4vY29yZS1kMjFkMmU5Ni5qc1wiO1xuaW1wb3J0IHsgciBhcyBwZSwgcyBhcyB6ZSB9IGZyb20gXCIuL2xhc3RDb25uZWN0ZWQtZTkzNTE5MTIuanNcIjtcbmltcG9ydCBcInN0YXJrbmV0XCI7XG5pbXBvcnQgeyBXIGFzIExlLCBEIGFzIGplIH0gZnJvbSBcIi4vaW5kZXgtOGVkYmQzNjEuanNcIjtcbmltcG9ydCB7IEEgYXMgV2UgfSBmcm9tIFwiLi9pbmRleC1kNGYzMGYyZS5qc1wiO1xuaW1wb3J0IHsgQnJhYXZvc01vYmlsZUJhc2VDb25uZWN0b3IgYXMgVGUgfSBmcm9tIFwiLi9icmFhdm9zTW9iaWxlLmpzXCI7XG5pbXBvcnQgeyBJIGFzIEEsIEEgYXMgZWUgfSBmcm9tIFwiLi9pbmRleC05YmI0OGY4YS5qc1wiO1xuaW1wb3J0IFwiLi9nZXRTdGFya25ldENoYWluSWQtN2M0YjMxNjMuanNcIjtcbmNvbnN0IFJlID0gKCkgPT4ge1xuICBjb25zdCB0ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLCBlID0gL2FuZHJvaWR8d2Vib3N8aXBob25lfGlwYWR8aXBvZHxibGFja2JlcnJ5fHdpbmRvd3MgcGhvbmUvLnRlc3QodCksIHIgPSBcIm9udG91Y2hzdGFydFwiIGluIHdpbmRvdyB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwLCBuID0gd2luZG93LmlubmVyV2lkdGggPD0gNzY4O1xuICByZXR1cm4gZSAmJiAociB8fCBuKTtcbn0sIEllID0gKHtcbiAgYXJnZW50TW9iaWxlT3B0aW9uczogdCxcbiAgd2ViV2FsbGV0VXJsOiBlXG59KSA9PiB7XG4gIGNvbnN0IHIgPSB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIDogITEsIG4gPSBbXTtcbiAgcmV0dXJuIHIgfHwgKG4ucHVzaChcbiAgICBuZXcgQSh7IG9wdGlvbnM6IHsgaWQ6IFwiYXJnZW50WFwiIH0gfSlcbiAgKSwgbi5wdXNoKFxuICAgIG5ldyBBKHsgb3B0aW9uczogeyBpZDogXCJicmFhdm9zXCIgfSB9KVxuICApLCBBLmlzV2FsbGV0SW5qZWN0ZWQoXCJtZXRhbWFza1wiKSAmJiBuLnB1c2goXG4gICAgbmV3IEEoeyBvcHRpb25zOiB7IGlkOiBcIm1ldGFtYXNrXCIgfSB9KVxuICApLCBBLmlzV2FsbGV0SW5qZWN0ZWQoXCJmb3JkZWZpXCIpICYmIG4ucHVzaChcbiAgICBuZXcgQSh7IG9wdGlvbnM6IHsgaWQ6IFwiZm9yZGVmaVwiIH0gfSlcbiAgKSwgQS5pc1dhbGxldEluamVjdGVkKFwia2VwbHJcIikgJiYgbi5wdXNoKFxuICAgIG5ldyBBKHsgb3B0aW9uczogeyBpZDogXCJrZXBsclwiIH0gfSlcbiAgKSksIG4ucHVzaChuZXcgV2UodCkpLCBSZSgpICYmIG4ucHVzaChuZXcgVGUoKSksIG4ucHVzaChuZXcgTGUoeyB1cmw6IGUgfSkpLCBuO1xufSwgVmUgPSB7XG4gIFwiQW1hem9uIFNpbGtcIjogXCJhbWF6b25fc2lsa1wiLFxuICBcIkFuZHJvaWQgQnJvd3NlclwiOiBcImFuZHJvaWRcIixcbiAgQmFkYTogXCJiYWRhXCIsXG4gIEJsYWNrQmVycnk6IFwiYmxhY2tiZXJyeVwiLFxuICBDaHJvbWU6IFwiY2hyb21lXCIsXG4gIENocm9taXVtOiBcImNocm9taXVtXCIsXG4gIEVsZWN0cm9uOiBcImVsZWN0cm9uXCIsXG4gIEVwaXBoYW55OiBcImVwaXBoYW55XCIsXG4gIEZpcmVmb3g6IFwiZmlyZWZveFwiLFxuICBGb2N1czogXCJmb2N1c1wiLFxuICBHZW5lcmljOiBcImdlbmVyaWNcIixcbiAgXCJHb29nbGUgU2VhcmNoXCI6IFwiZ29vZ2xlX3NlYXJjaFwiLFxuICBHb29nbGVib3Q6IFwiZ29vZ2xlYm90XCIsXG4gIFwiSW50ZXJuZXQgRXhwbG9yZXJcIjogXCJpZVwiLFxuICBcIkstTWVsZW9uXCI6IFwia19tZWxlb25cIixcbiAgTWF4dGhvbjogXCJtYXh0aG9uXCIsXG4gIFwiTWljcm9zb2Z0IEVkZ2VcIjogXCJlZGdlXCIsXG4gIFwiTVogQnJvd3NlclwiOiBcIm16XCIsXG4gIFwiTkFWRVIgV2hhbGUgQnJvd3NlclwiOiBcIm5hdmVyXCIsXG4gIE9wZXJhOiBcIm9wZXJhXCIsXG4gIFwiT3BlcmEgQ29hc3RcIjogXCJvcGVyYV9jb2FzdFwiLFxuICBQaGFudG9tSlM6IFwicGhhbnRvbWpzXCIsXG4gIFB1ZmZpbjogXCJwdWZmaW5cIixcbiAgUXVwWmlsbGE6IFwicXVwemlsbGFcIixcbiAgUVE6IFwicXFcIixcbiAgUVFMaXRlOiBcInFxbGl0ZVwiLFxuICBTYWZhcmk6IFwic2FmYXJpXCIsXG4gIFNhaWxmaXNoOiBcInNhaWxmaXNoXCIsXG4gIFwiU2Ftc3VuZyBJbnRlcm5ldCBmb3IgQW5kcm9pZFwiOiBcInNhbXN1bmdfaW50ZXJuZXRcIixcbiAgU2VhTW9ua2V5OiBcInNlYW1vbmtleVwiLFxuICBTbGVpcG5pcjogXCJzbGVpcG5pclwiLFxuICBTd2luZzogXCJzd2luZ1wiLFxuICBUaXplbjogXCJ0aXplblwiLFxuICBcIlVDIEJyb3dzZXJcIjogXCJ1Y1wiLFxuICBWaXZhbGRpOiBcInZpdmFsZGlcIixcbiAgXCJXZWJPUyBCcm93c2VyXCI6IFwid2Vib3NcIixcbiAgV2VDaGF0OiBcIndlY2hhdFwiLFxuICBcIllhbmRleCBCcm93c2VyXCI6IFwieWFuZGV4XCIsXG4gIFJva3U6IFwicm9rdVwiXG59LCBiZSA9IHtcbiAgYW1hem9uX3NpbGs6IFwiQW1hem9uIFNpbGtcIixcbiAgYW5kcm9pZDogXCJBbmRyb2lkIEJyb3dzZXJcIixcbiAgYmFkYTogXCJCYWRhXCIsXG4gIGJsYWNrYmVycnk6IFwiQmxhY2tCZXJyeVwiLFxuICBjaHJvbWU6IFwiQ2hyb21lXCIsXG4gIGNocm9taXVtOiBcIkNocm9taXVtXCIsXG4gIGVsZWN0cm9uOiBcIkVsZWN0cm9uXCIsXG4gIGVwaXBoYW55OiBcIkVwaXBoYW55XCIsXG4gIGZpcmVmb3g6IFwiRmlyZWZveFwiLFxuICBmb2N1czogXCJGb2N1c1wiLFxuICBnZW5lcmljOiBcIkdlbmVyaWNcIixcbiAgZ29vZ2xlYm90OiBcIkdvb2dsZWJvdFwiLFxuICBnb29nbGVfc2VhcmNoOiBcIkdvb2dsZSBTZWFyY2hcIixcbiAgaWU6IFwiSW50ZXJuZXQgRXhwbG9yZXJcIixcbiAga19tZWxlb246IFwiSy1NZWxlb25cIixcbiAgbWF4dGhvbjogXCJNYXh0aG9uXCIsXG4gIGVkZ2U6IFwiTWljcm9zb2Z0IEVkZ2VcIixcbiAgbXo6IFwiTVogQnJvd3NlclwiLFxuICBuYXZlcjogXCJOQVZFUiBXaGFsZSBCcm93c2VyXCIsXG4gIG9wZXJhOiBcIk9wZXJhXCIsXG4gIG9wZXJhX2NvYXN0OiBcIk9wZXJhIENvYXN0XCIsXG4gIHBoYW50b21qczogXCJQaGFudG9tSlNcIixcbiAgcHVmZmluOiBcIlB1ZmZpblwiLFxuICBxdXB6aWxsYTogXCJRdXBaaWxsYVwiLFxuICBxcTogXCJRUSBCcm93c2VyXCIsXG4gIHFxbGl0ZTogXCJRUSBCcm93c2VyIExpdGVcIixcbiAgc2FmYXJpOiBcIlNhZmFyaVwiLFxuICBzYWlsZmlzaDogXCJTYWlsZmlzaFwiLFxuICBzYW1zdW5nX2ludGVybmV0OiBcIlNhbXN1bmcgSW50ZXJuZXQgZm9yIEFuZHJvaWRcIixcbiAgc2VhbW9ua2V5OiBcIlNlYU1vbmtleVwiLFxuICBzbGVpcG5pcjogXCJTbGVpcG5pclwiLFxuICBzd2luZzogXCJTd2luZ1wiLFxuICB0aXplbjogXCJUaXplblwiLFxuICB1YzogXCJVQyBCcm93c2VyXCIsXG4gIHZpdmFsZGk6IFwiVml2YWxkaVwiLFxuICB3ZWJvczogXCJXZWJPUyBCcm93c2VyXCIsXG4gIHdlY2hhdDogXCJXZUNoYXRcIixcbiAgeWFuZGV4OiBcIllhbmRleCBCcm93c2VyXCJcbn0sIE0gPSB7XG4gIHRhYmxldDogXCJ0YWJsZXRcIixcbiAgbW9iaWxlOiBcIm1vYmlsZVwiLFxuICBkZXNrdG9wOiBcImRlc2t0b3BcIixcbiAgdHY6IFwidHZcIlxufSwgRiA9IHtcbiAgV2luZG93c1Bob25lOiBcIldpbmRvd3MgUGhvbmVcIixcbiAgV2luZG93czogXCJXaW5kb3dzXCIsXG4gIE1hY09TOiBcIm1hY09TXCIsXG4gIGlPUzogXCJpT1NcIixcbiAgQW5kcm9pZDogXCJBbmRyb2lkXCIsXG4gIFdlYk9TOiBcIldlYk9TXCIsXG4gIEJsYWNrQmVycnk6IFwiQmxhY2tCZXJyeVwiLFxuICBCYWRhOiBcIkJhZGFcIixcbiAgVGl6ZW46IFwiVGl6ZW5cIixcbiAgTGludXg6IFwiTGludXhcIixcbiAgQ2hyb21lT1M6IFwiQ2hyb21lIE9TXCIsXG4gIFBsYXlTdGF0aW9uNDogXCJQbGF5U3RhdGlvbiA0XCIsXG4gIFJva3U6IFwiUm9rdVwiXG59LCBQID0ge1xuICBFZGdlSFRNTDogXCJFZGdlSFRNTFwiLFxuICBCbGluazogXCJCbGlua1wiLFxuICBUcmlkZW50OiBcIlRyaWRlbnRcIixcbiAgUHJlc3RvOiBcIlByZXN0b1wiLFxuICBHZWNrbzogXCJHZWNrb1wiLFxuICBXZWJLaXQ6IFwiV2ViS2l0XCJcbn07XG5jbGFzcyBpIHtcbiAgLyoqXG4gICAqIEdldCBmaXJzdCBtYXRjaGVkIGl0ZW0gZm9yIGEgc3RyaW5nXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVhXG4gICAqIEByZXR1cm4ge0FycmF5fHtpbmRleDogbnVtYmVyLCBpbnB1dDogc3RyaW5nfXwqfGJvb2xlYW58c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldEZpcnN0TWF0Y2goZSwgcikge1xuICAgIGNvbnN0IG4gPSByLm1hdGNoKGUpO1xuICAgIHJldHVybiBuICYmIG4ubGVuZ3RoID4gMCAmJiBuWzFdIHx8IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBzZWNvbmQgbWF0Y2hlZCBpdGVtIGZvciBhIHN0cmluZ1xuICAgKiBAcGFyYW0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1YVxuICAgKiBAcmV0dXJuIHtBcnJheXx7aW5kZXg6IG51bWJlciwgaW5wdXQ6IHN0cmluZ318Knxib29sZWFufHN0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXRTZWNvbmRNYXRjaChlLCByKSB7XG4gICAgY29uc3QgbiA9IHIubWF0Y2goZSk7XG4gICAgcmV0dXJuIG4gJiYgbi5sZW5ndGggPiAxICYmIG5bMl0gfHwgXCJcIjtcbiAgfVxuICAvKipcbiAgICogTWF0Y2ggYSByZWdleHAgYW5kIHJldHVybiBhIGNvbnN0YW50IG9yIHVuZGVmaW5lZFxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1YVxuICAgKiBAcGFyYW0geyp9IF9jb25zdCBBbnkgY29uc3QgdGhhdCB3aWxsIGJlIHJldHVybmVkIGlmIHJlZ2V4cCBtYXRjaGVzIHRoZSBzdHJpbmdcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHN0YXRpYyBtYXRjaEFuZFJldHVybkNvbnN0KGUsIHIsIG4pIHtcbiAgICBpZiAoZS50ZXN0KHIpKVxuICAgICAgcmV0dXJuIG47XG4gIH1cbiAgc3RhdGljIGdldFdpbmRvd3NWZXJzaW9uTmFtZShlKSB7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIFwiTlRcIjpcbiAgICAgICAgcmV0dXJuIFwiTlRcIjtcbiAgICAgIGNhc2UgXCJYUFwiOlxuICAgICAgICByZXR1cm4gXCJYUFwiO1xuICAgICAgY2FzZSBcIk5UIDUuMFwiOlxuICAgICAgICByZXR1cm4gXCIyMDAwXCI7XG4gICAgICBjYXNlIFwiTlQgNS4xXCI6XG4gICAgICAgIHJldHVybiBcIlhQXCI7XG4gICAgICBjYXNlIFwiTlQgNS4yXCI6XG4gICAgICAgIHJldHVybiBcIjIwMDNcIjtcbiAgICAgIGNhc2UgXCJOVCA2LjBcIjpcbiAgICAgICAgcmV0dXJuIFwiVmlzdGFcIjtcbiAgICAgIGNhc2UgXCJOVCA2LjFcIjpcbiAgICAgICAgcmV0dXJuIFwiN1wiO1xuICAgICAgY2FzZSBcIk5UIDYuMlwiOlxuICAgICAgICByZXR1cm4gXCI4XCI7XG4gICAgICBjYXNlIFwiTlQgNi4zXCI6XG4gICAgICAgIHJldHVybiBcIjguMVwiO1xuICAgICAgY2FzZSBcIk5UIDEwLjBcIjpcbiAgICAgICAgcmV0dXJuIFwiMTBcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCBtYWNPUyB2ZXJzaW9uIG5hbWVcbiAgICogICAgMTAuNSAtIExlb3BhcmRcbiAgICogICAgMTAuNiAtIFNub3cgTGVvcGFyZFxuICAgKiAgICAxMC43IC0gTGlvblxuICAgKiAgICAxMC44IC0gTW91bnRhaW4gTGlvblxuICAgKiAgICAxMC45IC0gTWF2ZXJpY2tzXG4gICAqICAgIDEwLjEwIC0gWW9zZW1pdGVcbiAgICogICAgMTAuMTEgLSBFbCBDYXBpdGFuXG4gICAqICAgIDEwLjEyIC0gU2llcnJhXG4gICAqICAgIDEwLjEzIC0gSGlnaCBTaWVycmFcbiAgICogICAgMTAuMTQgLSBNb2phdmVcbiAgICogICAgMTAuMTUgLSBDYXRhbGluYVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGdldE1hY09TVmVyc2lvbk5hbWUoXCIxMC4xNFwiKSAvLyAnTW9qYXZlJ1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZlcnNpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSB2ZXJzaW9uTmFtZVxuICAgKi9cbiAgc3RhdGljIGdldE1hY09TVmVyc2lvbk5hbWUoZSkge1xuICAgIGNvbnN0IHIgPSBlLnNwbGl0KFwiLlwiKS5zcGxpY2UoMCwgMikubWFwKChuKSA9PiBwYXJzZUludChuLCAxMCkgfHwgMCk7XG4gICAgaWYgKHIucHVzaCgwKSwgclswXSA9PT0gMTApXG4gICAgICBzd2l0Y2ggKHJbMV0pIHtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBcIkxlb3BhcmRcIjtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiBcIlNub3cgTGVvcGFyZFwiO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIFwiTGlvblwiO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIFwiTW91bnRhaW4gTGlvblwiO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcmV0dXJuIFwiTWF2ZXJpY2tzXCI7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIFwiWW9zZW1pdGVcIjtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICByZXR1cm4gXCJFbCBDYXBpdGFuXCI7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcmV0dXJuIFwiU2llcnJhXCI7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIFwiSGlnaCBTaWVycmFcIjtcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICByZXR1cm4gXCJNb2phdmVcIjtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZXR1cm4gXCJDYXRhbGluYVwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IEFuZHJvaWQgdmVyc2lvbiBuYW1lXG4gICAqICAgIDEuNSAtIEN1cGNha2VcbiAgICogICAgMS42IC0gRG9udXRcbiAgICogICAgMi4wIC0gRWNsYWlyXG4gICAqICAgIDIuMSAtIEVjbGFpclxuICAgKiAgICAyLjIgLSBGcm95b1xuICAgKiAgICAyLnggLSBHaW5nZXJicmVhZFxuICAgKiAgICAzLnggLSBIb25leWNvbWJcbiAgICogICAgNC4wIC0gSWNlIENyZWFtIFNhbmR3aWNoXG4gICAqICAgIDQuMSAtIEplbGx5IEJlYW5cbiAgICogICAgNC40IC0gS2l0S2F0XG4gICAqICAgIDUueCAtIExvbGxpcG9wXG4gICAqICAgIDYueCAtIE1hcnNobWFsbG93XG4gICAqICAgIDcueCAtIE5vdWdhdFxuICAgKiAgICA4LnggLSBPcmVvXG4gICAqICAgIDkueCAtIFBpZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGdldEFuZHJvaWRWZXJzaW9uTmFtZShcIjcuMFwiKSAvLyAnTm91Z2F0J1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZlcnNpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSB2ZXJzaW9uTmFtZVxuICAgKi9cbiAgc3RhdGljIGdldEFuZHJvaWRWZXJzaW9uTmFtZShlKSB7XG4gICAgY29uc3QgciA9IGUuc3BsaXQoXCIuXCIpLnNwbGljZSgwLCAyKS5tYXAoKG4pID0+IHBhcnNlSW50KG4sIDEwKSB8fCAwKTtcbiAgICBpZiAoci5wdXNoKDApLCAhKHJbMF0gPT09IDEgJiYgclsxXSA8IDUpKSB7XG4gICAgICBpZiAoclswXSA9PT0gMSAmJiByWzFdIDwgNilcbiAgICAgICAgcmV0dXJuIFwiQ3VwY2FrZVwiO1xuICAgICAgaWYgKHJbMF0gPT09IDEgJiYgclsxXSA+PSA2KVxuICAgICAgICByZXR1cm4gXCJEb251dFwiO1xuICAgICAgaWYgKHJbMF0gPT09IDIgJiYgclsxXSA8IDIpXG4gICAgICAgIHJldHVybiBcIkVjbGFpclwiO1xuICAgICAgaWYgKHJbMF0gPT09IDIgJiYgclsxXSA9PT0gMilcbiAgICAgICAgcmV0dXJuIFwiRnJveW9cIjtcbiAgICAgIGlmIChyWzBdID09PSAyICYmIHJbMV0gPiAyKVxuICAgICAgICByZXR1cm4gXCJHaW5nZXJicmVhZFwiO1xuICAgICAgaWYgKHJbMF0gPT09IDMpXG4gICAgICAgIHJldHVybiBcIkhvbmV5Y29tYlwiO1xuICAgICAgaWYgKHJbMF0gPT09IDQgJiYgclsxXSA8IDEpXG4gICAgICAgIHJldHVybiBcIkljZSBDcmVhbSBTYW5kd2ljaFwiO1xuICAgICAgaWYgKHJbMF0gPT09IDQgJiYgclsxXSA8IDQpXG4gICAgICAgIHJldHVybiBcIkplbGx5IEJlYW5cIjtcbiAgICAgIGlmIChyWzBdID09PSA0ICYmIHJbMV0gPj0gNClcbiAgICAgICAgcmV0dXJuIFwiS2l0S2F0XCI7XG4gICAgICBpZiAoclswXSA9PT0gNSlcbiAgICAgICAgcmV0dXJuIFwiTG9sbGlwb3BcIjtcbiAgICAgIGlmIChyWzBdID09PSA2KVxuICAgICAgICByZXR1cm4gXCJNYXJzaG1hbGxvd1wiO1xuICAgICAgaWYgKHJbMF0gPT09IDcpXG4gICAgICAgIHJldHVybiBcIk5vdWdhdFwiO1xuICAgICAgaWYgKHJbMF0gPT09IDgpXG4gICAgICAgIHJldHVybiBcIk9yZW9cIjtcbiAgICAgIGlmIChyWzBdID09PSA5KVxuICAgICAgICByZXR1cm4gXCJQaWVcIjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB2ZXJzaW9uIHByZWNpc2lvbnMgY291bnRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICBnZXRWZXJzaW9uUHJlY2lzaW9uKFwiMS4xMC4zXCIpIC8vIDNcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB2ZXJzaW9uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXRWZXJzaW9uUHJlY2lzaW9uKGUpIHtcbiAgICByZXR1cm4gZS5zcGxpdChcIi5cIikubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYnJvd3NlciB2ZXJzaW9uIHdlaWdodFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGNvbXBhcmVWZXJzaW9ucygnMS4xMC4yLjEnLCAgJzEuOC4yLjEuOTAnKSAgICAvLyAxXG4gICAqICAgY29tcGFyZVZlcnNpb25zKCcxLjAxMC4yLjEnLCAnMS4wOS4yLjEuOTAnKTsgIC8vIDFcbiAgICogICBjb21wYXJlVmVyc2lvbnMoJzEuMTAuMi4xJywgICcxLjEwLjIuMScpOyAgICAgLy8gMFxuICAgKiAgIGNvbXBhcmVWZXJzaW9ucygnMS4xMC4yLjEnLCAgJzEuMDgwMC4yJyk7ICAgICAvLyAtMVxuICAgKiAgIGNvbXBhcmVWZXJzaW9ucygnMS4xMC4yLjEnLCAgJzEuMTAnLCAgdHJ1ZSk7ICAvLyAwXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2ZXJzaW9uQSB2ZXJzaW9ucyB2ZXJzaW9ucyB0byBjb21wYXJlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2ZXJzaW9uQiB2ZXJzaW9ucyB2ZXJzaW9ucyB0byBjb21wYXJlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIGVuYWJsZSBsb29zZSBjb21wYXJpc29uXG4gICAqIEByZXR1cm4ge051bWJlcn0gY29tcGFyaXNvbiByZXN1bHQ6IC0xIHdoZW4gdmVyc2lvbkEgaXMgbG93ZXIsXG4gICAqIDEgd2hlbiB2ZXJzaW9uQSBpcyBiaWdnZXIsIDAgd2hlbiBib3RoIGVxdWFsXG4gICAqL1xuICAvKiBlc2xpbnQgY29uc2lzdGVudC1yZXR1cm46IDEgKi9cbiAgc3RhdGljIGNvbXBhcmVWZXJzaW9ucyhlLCByLCBuID0gITEpIHtcbiAgICBjb25zdCBvID0gaS5nZXRWZXJzaW9uUHJlY2lzaW9uKGUpLCBzID0gaS5nZXRWZXJzaW9uUHJlY2lzaW9uKHIpO1xuICAgIGxldCBkID0gTWF0aC5tYXgobywgcyksIGggPSAwO1xuICAgIGNvbnN0IHcgPSBpLm1hcChbZSwgcl0sIChsKSA9PiB7XG4gICAgICBjb25zdCBhID0gZCAtIGkuZ2V0VmVyc2lvblByZWNpc2lvbihsKSwgZyA9IGwgKyBuZXcgQXJyYXkoYSArIDEpLmpvaW4oXCIuMFwiKTtcbiAgICAgIHJldHVybiBpLm1hcChnLnNwbGl0KFwiLlwiKSwgKHkpID0+IG5ldyBBcnJheSgyMCAtIHkubGVuZ3RoKS5qb2luKFwiMFwiKSArIHkpLnJldmVyc2UoKTtcbiAgICB9KTtcbiAgICBmb3IgKG4gJiYgKGggPSBkIC0gTWF0aC5taW4obywgcykpLCBkIC09IDE7IGQgPj0gaDsgKSB7XG4gICAgICBpZiAod1swXVtkXSA+IHdbMV1bZF0pXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKHdbMF1bZF0gPT09IHdbMV1bZF0pIHtcbiAgICAgICAgaWYgKGQgPT09IGgpXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGQgLT0gMTtcbiAgICAgIH0gZWxzZSBpZiAod1swXVtkXSA8IHdbMV1bZF0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFycmF5OjptYXAgcG9seWZpbGxcbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbWFwKGUsIHIpIHtcbiAgICBjb25zdCBuID0gW107XG4gICAgbGV0IG87XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5tYXApXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGUsIHIpO1xuICAgIGZvciAobyA9IDA7IG8gPCBlLmxlbmd0aDsgbyArPSAxKVxuICAgICAgbi5wdXNoKHIoZVtvXSkpO1xuICAgIHJldHVybiBuO1xuICB9XG4gIC8qKlxuICAgKiBBcnJheTo6ZmluZCBwb2x5ZmlsbFxuICAgKlxuICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgZmluZChlLCByKSB7XG4gICAgbGV0IG4sIG87XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKVxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwoZSwgcik7XG4gICAgZm9yIChuID0gMCwgbyA9IGUubGVuZ3RoOyBuIDwgbzsgbiArPSAxKSB7XG4gICAgICBjb25zdCBzID0gZVtuXTtcbiAgICAgIGlmIChyKHMsIG4pKVxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9iamVjdDo6YXNzaWduIHBvbHlmaWxsXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqXG4gICAqIEBwYXJhbSAge09iamVjdH0gLi4ub2Jqc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgYXNzaWduKGUsIC4uLnIpIHtcbiAgICBjb25zdCBuID0gZTtcbiAgICBsZXQgbywgcztcbiAgICBpZiAoT2JqZWN0LmFzc2lnbilcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGUsIC4uLnIpO1xuICAgIGZvciAobyA9IDAsIHMgPSByLmxlbmd0aDsgbyA8IHM7IG8gKz0gMSkge1xuICAgICAgY29uc3QgZCA9IHJbb107XG4gICAgICB0eXBlb2YgZCA9PSBcIm9iamVjdFwiICYmIGQgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoZCkuZm9yRWFjaCgodykgPT4ge1xuICAgICAgICBuW3ddID0gZFt3XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICAvKipcbiAgICogR2V0IHNob3J0IHZlcnNpb24vYWxpYXMgZm9yIGEgYnJvd3NlciBuYW1lXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgZ2V0QnJvd3NlckFsaWFzKCdNaWNyb3NvZnQgRWRnZScpIC8vIGVkZ2VcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBicm93c2VyTmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0QnJvd3NlckFsaWFzKGUpIHtcbiAgICByZXR1cm4gVmVbZV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBzaG9ydCB2ZXJzaW9uL2FsaWFzIGZvciBhIGJyb3dzZXIgbmFtZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGdldEJyb3dzZXJBbGlhcygnZWRnZScpIC8vIE1pY3Jvc29mdCBFZGdlXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYnJvd3NlckFsaWFzXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXRCcm93c2VyVHlwZUJ5QWxpYXMoZSkge1xuICAgIHJldHVybiBiZVtlXSB8fCBcIlwiO1xuICB9XG59XG5jb25zdCBrID0gL3ZlcnNpb25cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIERlID0gW1xuICAvKiBHb29nbGVib3QgKi9cbiAge1xuICAgIHRlc3Q6IFsvZ29vZ2xlYm90L2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiR29vZ2xlYm90XCJcbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goL2dvb2dsZWJvdFxcLyhcXGQrKFxcLlxcZCspKS9pLCB0KSB8fCBpLmdldEZpcnN0TWF0Y2goaywgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9LFxuICAvKiBPcGVyYSA8IDEzLjAgKi9cbiAge1xuICAgIHRlc3Q6IFsvb3BlcmEvaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogXCJPcGVyYVwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKGssIHQpIHx8IGkuZ2V0Rmlyc3RNYXRjaCgvKD86b3BlcmEpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIC8qIE9wZXJhID4gMTMuMCAqL1xuICB7XG4gICAgdGVzdDogWy9vcHJcXC98b3Bpb3MvaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogXCJPcGVyYVwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKC8oPzpvcHJ8b3Bpb3MpW1xccy9dKFxcUyspL2ksIHQpIHx8IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL1NhbXN1bmdCcm93c2VyL2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiU2Ftc3VuZyBJbnRlcm5ldCBmb3IgQW5kcm9pZFwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKGssIHQpIHx8IGkuZ2V0Rmlyc3RNYXRjaCgvKD86U2Ftc3VuZ0Jyb3dzZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL1doYWxlL2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiTkFWRVIgV2hhbGUgQnJvd3NlclwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKGssIHQpIHx8IGkuZ2V0Rmlyc3RNYXRjaCgvKD86d2hhbGUpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHRlc3Q6IFsvTVpCcm93c2VyL2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiTVogQnJvd3NlclwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKC8oPzpNWkJyb3dzZXIpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksIHQpIHx8IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL2ZvY3VzL2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiRm9jdXNcIlxuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaCgvKD86Zm9jdXMpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksIHQpIHx8IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL3N3aW5nL2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiU3dpbmdcIlxuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaCgvKD86c3dpbmcpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksIHQpIHx8IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL2NvYXN0L2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiT3BlcmEgQ29hc3RcIlxuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KSB8fCBpLmdldEZpcnN0TWF0Y2goLyg/OmNvYXN0KVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdGVzdDogWy9vcHRcXC9cXGQrKD86Lj9fP1xcZCspKy9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIk9wZXJhIFRvdWNoXCJcbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goLyg/Om9wdClbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHQpIHx8IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL3lhYnJvd3Nlci9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIllhbmRleCBCcm93c2VyXCJcbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goLyg/OnlhYnJvd3NlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHQpIHx8IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL3VjYnJvd3Nlci9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIlVDIEJyb3dzZXJcIlxuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KSB8fCBpLmdldEZpcnN0TWF0Y2goLyg/OnVjYnJvd3NlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHRlc3Q6IFsvTWF4dGhvbnxteGlvcy9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIk1heHRob25cIlxuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KSB8fCBpLmdldEZpcnN0TWF0Y2goLyg/Ok1heHRob258bXhpb3MpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL2VwaXBoYW55L2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiRXBpcGhhbnlcIlxuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KSB8fCBpLmdldEZpcnN0TWF0Y2goLyg/OmVwaXBoYW55KVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdGVzdDogWy9wdWZmaW4vaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogXCJQdWZmaW5cIlxuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KSB8fCBpLmdldEZpcnN0TWF0Y2goLyg/OnB1ZmZpbilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHRlc3Q6IFsvc2xlaXBuaXIvaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogXCJTbGVpcG5pclwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKGssIHQpIHx8IGkuZ2V0Rmlyc3RNYXRjaCgvKD86c2xlaXBuaXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL2stbWVsZW9uL2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiSy1NZWxlb25cIlxuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KSB8fCBpLmdldEZpcnN0TWF0Y2goLyg/OmstbWVsZW9uKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdGVzdDogWy9taWNyb21lc3Nlbmdlci9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIldlQ2hhdFwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKC8oPzptaWNyb21lc3NlbmdlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHQpIHx8IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL3FxYnJvd3Nlci9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiAvcXFicm93c2VybGl0ZS9pLnRlc3QodCkgPyBcIlFRIEJyb3dzZXIgTGl0ZVwiIDogXCJRUSBCcm93c2VyXCJcbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goLyg/OnFxYnJvd3NlcmxpdGV8cXFicm93c2VyKVsvXShcXGQrKFxcLj9fP1xcZCspKykvaSwgdCkgfHwgaS5nZXRGaXJzdE1hdGNoKGssIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHRlc3Q6IFsvbXNpZXx0cmlkZW50L2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiSW50ZXJuZXQgRXhwbG9yZXJcIlxuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaCgvKD86bXNpZSB8cnY6KShcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdGVzdDogWy9cXHNlZGdcXC8vaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogXCJNaWNyb3NvZnQgRWRnZVwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKC9cXHNlZGdcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHRlc3Q6IFsvZWRnKFtlYV18aW9zKS9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIk1pY3Jvc29mdCBFZGdlXCJcbiAgICAgIH0sIHIgPSBpLmdldFNlY29uZE1hdGNoKC9lZGcoW2VhXXxpb3MpXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL3ZpdmFsZGkvaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogXCJWaXZhbGRpXCJcbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goL3ZpdmFsZGlcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHRlc3Q6IFsvc2VhbW9ua2V5L2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiU2VhTW9ua2V5XCJcbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goL3NlYW1vbmtleVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdGVzdDogWy9zYWlsZmlzaC9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIlNhaWxmaXNoXCJcbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goL3NhaWxmaXNoXFxzP2Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pL2ksIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHRlc3Q6IFsvc2lsay9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIkFtYXpvbiBTaWxrXCJcbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goL3NpbGtcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHRlc3Q6IFsvcGhhbnRvbS9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIlBoYW50b21KU1wiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKC9waGFudG9tanNcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHRlc3Q6IFsvc2xpbWVyanMvaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogXCJTbGltZXJKU1wiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKC9zbGltZXJqc1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdGVzdDogWy9ibGFja2JlcnJ5fFxcYmJiXFxkKy9pLCAvcmltXFxzdGFibGV0L2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiQmxhY2tCZXJyeVwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKGssIHQpIHx8IGkuZ2V0Rmlyc3RNYXRjaCgvYmxhY2tiZXJyeVtcXGRdK1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdGVzdDogWy8od2VifGhwdylbbzBdcy9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIldlYk9TIEJyb3dzZXJcIlxuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KSB8fCBpLmdldEZpcnN0TWF0Y2goL3coPzplYik/W28wXXNicm93c2VyXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL2JhZGEvaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogXCJCYWRhXCJcbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goL2RvbGZpblxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdGVzdDogWy90aXplbi9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIlRpemVuXCJcbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goLyg/OnRpemVuXFxzPyk/YnJvd3NlclxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdCkgfHwgaS5nZXRGaXJzdE1hdGNoKGssIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHRlc3Q6IFsvcXVwemlsbGEvaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogXCJRdXBaaWxsYVwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKC8oPzpxdXB6aWxsYSlbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHQpIHx8IGkuZ2V0Rmlyc3RNYXRjaChrLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiRmlyZWZveFwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKC8oPzpmaXJlZm94fGljZXdlYXNlbHxmeGlvcylbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHRlc3Q6IFsvZWxlY3Ryb24vaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogXCJFbGVjdHJvblwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKC8oPzplbGVjdHJvbilcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHRlc3Q6IFsvTWl1aUJyb3dzZXIvaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogXCJNaXVpXCJcbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goLyg/Ok1pdWlCcm93c2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdGVzdDogWy9jaHJvbWl1bS9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIkNocm9taXVtXCJcbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goLyg/OmNocm9taXVtKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSwgdCkgfHwgaS5nZXRGaXJzdE1hdGNoKGssIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHRlc3Q6IFsvY2hyb21lfGNyaW9zfGNybW8vaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogXCJDaHJvbWVcIlxuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21lfGNyaW9zfGNybW8pXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLCB0KTtcbiAgICAgIHJldHVybiByICYmIChlLnZlcnNpb24gPSByKSwgZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0ZXN0OiBbL0dTQS9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIkdvb2dsZSBTZWFyY2hcIlxuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaCgvKD86R1NBKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9LFxuICAvKiBBbmRyb2lkIEJyb3dzZXIgKi9cbiAge1xuICAgIHRlc3QodCkge1xuICAgICAgY29uc3QgZSA9ICF0LnRlc3QoL2xpa2UgYW5kcm9pZC9pKSwgciA9IHQudGVzdCgvYW5kcm9pZC9pKTtcbiAgICAgIHJldHVybiBlICYmIHI7XG4gICAgfSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIkFuZHJvaWQgQnJvd3NlclwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKGssIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAgLyogUGxheVN0YXRpb24gNCAqL1xuICB7XG4gICAgdGVzdDogWy9wbGF5c3RhdGlvbiA0L2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFwiUGxheVN0YXRpb24gNFwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKGssIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAgLyogU2FmYXJpICovXG4gIHtcbiAgICB0ZXN0OiBbL3NhZmFyaXxhcHBsZXdlYmtpdC9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBcIlNhZmFyaVwiXG4gICAgICB9LCByID0gaS5nZXRGaXJzdE1hdGNoKGssIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAgLyogU29tZXRoaW5nIGVsc2UgKi9cbiAge1xuICAgIHRlc3Q6IFsvLiovaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IC9eKC4qKVxcLyguKikgLywgciA9IC9eKC4qKVxcLyguKilbIFxcdF1cXCgoLiopLywgbyA9IHQuc2VhcmNoKFwiXFxcXChcIikgIT09IC0xID8gciA6IGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBpLmdldEZpcnN0TWF0Y2gobywgdCksXG4gICAgICAgIHZlcnNpb246IGkuZ2V0U2Vjb25kTWF0Y2gobywgdClcbiAgICAgIH07XG4gICAgfVxuICB9XG5dLCBxZSA9IFtcbiAgLyogUm9rdSAqL1xuICB7XG4gICAgdGVzdDogWy9Sb2t1XFwvRFZQL10sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IGkuZ2V0Rmlyc3RNYXRjaCgvUm9rdVxcL0RWUC0oXFxkK1xcLlxcZCspL2ksIHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogRi5Sb2t1LFxuICAgICAgICB2ZXJzaW9uOiBlXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLyogV2luZG93cyBQaG9uZSAqL1xuICB7XG4gICAgdGVzdDogWy93aW5kb3dzIHBob25lL2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSBpLmdldEZpcnN0TWF0Y2goL3dpbmRvd3MgcGhvbmUgKD86b3MpP1xccz8oXFxkKyhcXC5cXGQrKSopL2ksIHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogRi5XaW5kb3dzUGhvbmUsXG4gICAgICAgIHZlcnNpb246IGVcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAvKiBXaW5kb3dzICovXG4gIHtcbiAgICB0ZXN0OiBbL3dpbmRvd3MgL2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSBpLmdldEZpcnN0TWF0Y2goL1dpbmRvd3MgKChOVHxYUCkoIFxcZFxcZD8uXFxkKT8pL2ksIHQpLCByID0gaS5nZXRXaW5kb3dzVmVyc2lvbk5hbWUoZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBGLldpbmRvd3MsXG4gICAgICAgIHZlcnNpb246IGUsXG4gICAgICAgIHZlcnNpb25OYW1lOiByXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLyogRmlyZWZveCBvbiBpUGFkICovXG4gIHtcbiAgICB0ZXN0OiBbL01hY2ludG9zaCguKj8pIEZ4aU9TKC4qPylcXC8vXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBuYW1lOiBGLmlPU1xuICAgICAgfSwgciA9IGkuZ2V0U2Vjb25kTWF0Y2goLyhWZXJzaW9uXFwvKShcXGRbXFxkLl0rKS8sIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAgLyogbWFjT1MgKi9cbiAge1xuICAgIHRlc3Q6IFsvbWFjaW50b3NoL2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSBpLmdldEZpcnN0TWF0Y2goL21hYyBvcyB4IChcXGQrKFxcLj9fP1xcZCspKykvaSwgdCkucmVwbGFjZSgvW19cXHNdL2csIFwiLlwiKSwgciA9IGkuZ2V0TWFjT1NWZXJzaW9uTmFtZShlKSwgbiA9IHtcbiAgICAgICAgbmFtZTogRi5NYWNPUyxcbiAgICAgICAgdmVyc2lvbjogZVxuICAgICAgfTtcbiAgICAgIHJldHVybiByICYmIChuLnZlcnNpb25OYW1lID0gciksIG47XG4gICAgfVxuICB9LFxuICAvKiBpT1MgKi9cbiAge1xuICAgIHRlc3Q6IFsvKGlwb2R8aXBob25lfGlwYWQpL2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSBpLmdldEZpcnN0TWF0Y2goL29zIChcXGQrKFtfXFxzXVxcZCspKikgbGlrZSBtYWMgb3MgeC9pLCB0KS5yZXBsYWNlKC9bX1xcc10vZywgXCIuXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogRi5pT1MsXG4gICAgICAgIHZlcnNpb246IGVcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAvKiBBbmRyb2lkICovXG4gIHtcbiAgICB0ZXN0KHQpIHtcbiAgICAgIGNvbnN0IGUgPSAhdC50ZXN0KC9saWtlIGFuZHJvaWQvaSksIHIgPSB0LnRlc3QoL2FuZHJvaWQvaSk7XG4gICAgICByZXR1cm4gZSAmJiByO1xuICAgIH0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IGkuZ2V0Rmlyc3RNYXRjaCgvYW5kcm9pZFtcXHMvLV0oXFxkKyhcXC5cXGQrKSopL2ksIHQpLCByID0gaS5nZXRBbmRyb2lkVmVyc2lvbk5hbWUoZSksIG4gPSB7XG4gICAgICAgIG5hbWU6IEYuQW5kcm9pZCxcbiAgICAgICAgdmVyc2lvbjogZVxuICAgICAgfTtcbiAgICAgIHJldHVybiByICYmIChuLnZlcnNpb25OYW1lID0gciksIG47XG4gICAgfVxuICB9LFxuICAvKiBXZWJPUyAqL1xuICB7XG4gICAgdGVzdDogWy8od2VifGhwdylbbzBdcy9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0gaS5nZXRGaXJzdE1hdGNoKC8oPzp3ZWJ8aHB3KVtvMF1zXFwvKFxcZCsoXFwuXFxkKykqKS9pLCB0KSwgciA9IHtcbiAgICAgICAgbmFtZTogRi5XZWJPU1xuICAgICAgfTtcbiAgICAgIHJldHVybiBlICYmIGUubGVuZ3RoICYmIChyLnZlcnNpb24gPSBlKSwgcjtcbiAgICB9XG4gIH0sXG4gIC8qIEJsYWNrQmVycnkgKi9cbiAge1xuICAgIHRlc3Q6IFsvYmxhY2tiZXJyeXxcXGJiYlxcZCsvaSwgL3JpbVxcc3RhYmxldC9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0gaS5nZXRGaXJzdE1hdGNoKC9yaW1cXHN0YWJsZXRcXHNvc1xccyhcXGQrKFxcLlxcZCspKikvaSwgdCkgfHwgaS5nZXRGaXJzdE1hdGNoKC9ibGFja2JlcnJ5XFxkK1xcLyhcXGQrKFtfXFxzXVxcZCspKikvaSwgdCkgfHwgaS5nZXRGaXJzdE1hdGNoKC9cXGJiYihcXGQrKS9pLCB0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IEYuQmxhY2tCZXJyeSxcbiAgICAgICAgdmVyc2lvbjogZVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qIEJhZGEgKi9cbiAge1xuICAgIHRlc3Q6IFsvYmFkYS9pXSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBjb25zdCBlID0gaS5nZXRGaXJzdE1hdGNoKC9iYWRhXFwvKFxcZCsoXFwuXFxkKykqKS9pLCB0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IEYuQmFkYSxcbiAgICAgICAgdmVyc2lvbjogZVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qIFRpemVuICovXG4gIHtcbiAgICB0ZXN0OiBbL3RpemVuL2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSBpLmdldEZpcnN0TWF0Y2goL3RpemVuWy9cXHNdKFxcZCsoXFwuXFxkKykqKS9pLCB0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IEYuVGl6ZW4sXG4gICAgICAgIHZlcnNpb246IGVcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAvKiBMaW51eCAqL1xuICB7XG4gICAgdGVzdDogWy9saW51eC9pXSxcbiAgICBkZXNjcmliZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IEYuTGludXhcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAvKiBDaHJvbWUgT1MgKi9cbiAge1xuICAgIHRlc3Q6IFsvQ3JPUy9dLFxuICAgIGRlc2NyaWJlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogRi5DaHJvbWVPU1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qIFBsYXlzdGF0aW9uIDQgKi9cbiAge1xuICAgIHRlc3Q6IFsvUGxheVN0YXRpb24gNC9dLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSBpLmdldEZpcnN0TWF0Y2goL1BsYXlTdGF0aW9uIDRbL1xcc10oXFxkKyhcXC5cXGQrKSopL2ksIHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogRi5QbGF5U3RhdGlvbjQsXG4gICAgICAgIHZlcnNpb246IGVcbiAgICAgIH07XG4gICAgfVxuICB9XG5dLCBHZSA9IFtcbiAgLyogR29vZ2xlYm90ICovXG4gIHtcbiAgICB0ZXN0OiBbL2dvb2dsZWJvdC9pXSxcbiAgICBkZXNjcmliZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYm90XCIsXG4gICAgICAgIHZlbmRvcjogXCJHb29nbGVcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qIEh1YXdlaSAqL1xuICB7XG4gICAgdGVzdDogWy9odWF3ZWkvaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IGkuZ2V0Rmlyc3RNYXRjaCgvKGNhbi1sMDEpL2ksIHQpICYmIFwiTm92YVwiLCByID0ge1xuICAgICAgICB0eXBlOiBNLm1vYmlsZSxcbiAgICAgICAgdmVuZG9yOiBcIkh1YXdlaVwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGUgJiYgKHIubW9kZWwgPSBlKSwgcjtcbiAgICB9XG4gIH0sXG4gIC8qIE5leHVzIFRhYmxldCAqL1xuICB7XG4gICAgdGVzdDogWy9uZXh1c1xccyooPzo3fDh8OXwxMCkuKi9pXSxcbiAgICBkZXNjcmliZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE0udGFibGV0LFxuICAgICAgICB2ZW5kb3I6IFwiTmV4dXNcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qIGlQYWQgKi9cbiAge1xuICAgIHRlc3Q6IFsvaXBhZC9pXSxcbiAgICBkZXNjcmliZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE0udGFibGV0LFxuICAgICAgICB2ZW5kb3I6IFwiQXBwbGVcIixcbiAgICAgICAgbW9kZWw6IFwiaVBhZFwiXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLyogRmlyZWZveCBvbiBpUGFkICovXG4gIHtcbiAgICB0ZXN0OiBbL01hY2ludG9zaCguKj8pIEZ4aU9TKC4qPylcXC8vXSxcbiAgICBkZXNjcmliZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE0udGFibGV0LFxuICAgICAgICB2ZW5kb3I6IFwiQXBwbGVcIixcbiAgICAgICAgbW9kZWw6IFwiaVBhZFwiXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLyogQW1hem9uIEtpbmRsZSBGaXJlICovXG4gIHtcbiAgICB0ZXN0OiBbL2tmdHQgYnVpbGQvaV0sXG4gICAgZGVzY3JpYmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBNLnRhYmxldCxcbiAgICAgICAgdmVuZG9yOiBcIkFtYXpvblwiLFxuICAgICAgICBtb2RlbDogXCJLaW5kbGUgRmlyZSBIRCA3XCJcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAvKiBBbm90aGVyIEFtYXpvbiBUYWJsZXQgd2l0aCBTaWxrICovXG4gIHtcbiAgICB0ZXN0OiBbL3NpbGsvaV0sXG4gICAgZGVzY3JpYmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBNLnRhYmxldCxcbiAgICAgICAgdmVuZG9yOiBcIkFtYXpvblwiXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLyogVGFibGV0ICovXG4gIHtcbiAgICB0ZXN0OiBbL3RhYmxldCg/ISBwYykvaV0sXG4gICAgZGVzY3JpYmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBNLnRhYmxldFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qIGlQb2QvaVBob25lICovXG4gIHtcbiAgICB0ZXN0KHQpIHtcbiAgICAgIGNvbnN0IGUgPSB0LnRlc3QoL2lwb2R8aXBob25lL2kpLCByID0gdC50ZXN0KC9saWtlIChpcG9kfGlwaG9uZSkvaSk7XG4gICAgICByZXR1cm4gZSAmJiAhcjtcbiAgICB9LFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSBpLmdldEZpcnN0TWF0Y2goLyhpcG9kfGlwaG9uZSkvaSwgdCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBNLm1vYmlsZSxcbiAgICAgICAgdmVuZG9yOiBcIkFwcGxlXCIsXG4gICAgICAgIG1vZGVsOiBlXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLyogTmV4dXMgTW9iaWxlICovXG4gIHtcbiAgICB0ZXN0OiBbL25leHVzXFxzKlswLTZdLiovaSwgL2dhbGF4eSBuZXh1cy9pXSxcbiAgICBkZXNjcmliZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE0ubW9iaWxlLFxuICAgICAgICB2ZW5kb3I6IFwiTmV4dXNcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qIE1vYmlsZSAqL1xuICB7XG4gICAgdGVzdDogWy9bXi1dbW9iaS9pXSxcbiAgICBkZXNjcmliZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE0ubW9iaWxlXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLyogQmxhY2tCZXJyeSAqL1xuICB7XG4gICAgdGVzdCh0KSB7XG4gICAgICByZXR1cm4gdC5nZXRCcm93c2VyTmFtZSghMCkgPT09IFwiYmxhY2tiZXJyeVwiO1xuICAgIH0sXG4gICAgZGVzY3JpYmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBNLm1vYmlsZSxcbiAgICAgICAgdmVuZG9yOiBcIkJsYWNrQmVycnlcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qIEJhZGEgKi9cbiAge1xuICAgIHRlc3QodCkge1xuICAgICAgcmV0dXJuIHQuZ2V0QnJvd3Nlck5hbWUoITApID09PSBcImJhZGFcIjtcbiAgICB9LFxuICAgIGRlc2NyaWJlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTS5tb2JpbGVcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAvKiBXaW5kb3dzIFBob25lICovXG4gIHtcbiAgICB0ZXN0KHQpIHtcbiAgICAgIHJldHVybiB0LmdldEJyb3dzZXJOYW1lKCkgPT09IFwid2luZG93cyBwaG9uZVwiO1xuICAgIH0sXG4gICAgZGVzY3JpYmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBNLm1vYmlsZSxcbiAgICAgICAgdmVuZG9yOiBcIk1pY3Jvc29mdFwiXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLyogQW5kcm9pZCBUYWJsZXQgKi9cbiAge1xuICAgIHRlc3QodCkge1xuICAgICAgY29uc3QgZSA9IE51bWJlcihTdHJpbmcodC5nZXRPU1ZlcnNpb24oKSkuc3BsaXQoXCIuXCIpWzBdKTtcbiAgICAgIHJldHVybiB0LmdldE9TTmFtZSghMCkgPT09IFwiYW5kcm9pZFwiICYmIGUgPj0gMztcbiAgICB9LFxuICAgIGRlc2NyaWJlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTS50YWJsZXRcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAvKiBBbmRyb2lkIE1vYmlsZSAqL1xuICB7XG4gICAgdGVzdCh0KSB7XG4gICAgICByZXR1cm4gdC5nZXRPU05hbWUoITApID09PSBcImFuZHJvaWRcIjtcbiAgICB9LFxuICAgIGRlc2NyaWJlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTS5tb2JpbGVcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAvKiBkZXNrdG9wICovXG4gIHtcbiAgICB0ZXN0KHQpIHtcbiAgICAgIHJldHVybiB0LmdldE9TTmFtZSghMCkgPT09IFwibWFjb3NcIjtcbiAgICB9LFxuICAgIGRlc2NyaWJlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTS5kZXNrdG9wLFxuICAgICAgICB2ZW5kb3I6IFwiQXBwbGVcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qIFdpbmRvd3MgKi9cbiAge1xuICAgIHRlc3QodCkge1xuICAgICAgcmV0dXJuIHQuZ2V0T1NOYW1lKCEwKSA9PT0gXCJ3aW5kb3dzXCI7XG4gICAgfSxcbiAgICBkZXNjcmliZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE0uZGVza3RvcFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qIExpbnV4ICovXG4gIHtcbiAgICB0ZXN0KHQpIHtcbiAgICAgIHJldHVybiB0LmdldE9TTmFtZSghMCkgPT09IFwibGludXhcIjtcbiAgICB9LFxuICAgIGRlc2NyaWJlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTS5kZXNrdG9wXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLyogUGxheVN0YXRpb24gNCAqL1xuICB7XG4gICAgdGVzdCh0KSB7XG4gICAgICByZXR1cm4gdC5nZXRPU05hbWUoITApID09PSBcInBsYXlzdGF0aW9uIDRcIjtcbiAgICB9LFxuICAgIGRlc2NyaWJlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTS50dlxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qIFJva3UgKi9cbiAge1xuICAgIHRlc3QodCkge1xuICAgICAgcmV0dXJuIHQuZ2V0T1NOYW1lKCEwKSA9PT0gXCJyb2t1XCI7XG4gICAgfSxcbiAgICBkZXNjcmliZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE0udHZcbiAgICAgIH07XG4gICAgfVxuICB9XG5dLCBRZSA9IFtcbiAgLyogRWRnZUhUTUwgKi9cbiAge1xuICAgIHRlc3QodCkge1xuICAgICAgcmV0dXJuIHQuZ2V0QnJvd3Nlck5hbWUoITApID09PSBcIm1pY3Jvc29mdCBlZGdlXCI7XG4gICAgfSxcbiAgICBkZXNjcmliZSh0KSB7XG4gICAgICBpZiAoL1xcc2VkZ1xcLy9pLnRlc3QodCkpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogUC5CbGlua1xuICAgICAgICB9O1xuICAgICAgY29uc3QgciA9IGkuZ2V0Rmlyc3RNYXRjaCgvZWRnZVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBQLkVkZ2VIVE1MLFxuICAgICAgICB2ZXJzaW9uOiByXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLyogVHJpZGVudCAqL1xuICB7XG4gICAgdGVzdDogWy90cmlkZW50L2ldLFxuICAgIGRlc2NyaWJlKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIG5hbWU6IFAuVHJpZGVudFxuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaCgvdHJpZGVudFxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9LFxuICAvKiBQcmVzdG8gKi9cbiAge1xuICAgIHRlc3QodCkge1xuICAgICAgcmV0dXJuIHQudGVzdCgvcHJlc3RvL2kpO1xuICAgIH0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogUC5QcmVzdG9cbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goL3ByZXN0b1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9LFxuICAvKiBHZWNrbyAqL1xuICB7XG4gICAgdGVzdCh0KSB7XG4gICAgICBjb25zdCBlID0gdC50ZXN0KC9nZWNrby9pKSwgciA9IHQudGVzdCgvbGlrZSBnZWNrby9pKTtcbiAgICAgIHJldHVybiBlICYmICFyO1xuICAgIH0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogUC5HZWNrb1xuICAgICAgfSwgciA9IGkuZ2V0Rmlyc3RNYXRjaCgvZ2Vja29cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHQpO1xuICAgICAgcmV0dXJuIHIgJiYgKGUudmVyc2lvbiA9IHIpLCBlO1xuICAgIH1cbiAgfSxcbiAgLyogQmxpbmsgKi9cbiAge1xuICAgIHRlc3Q6IFsvKGFwcGxlKT93ZWJraXRcXC81MzdcXC4zNi9pXSxcbiAgICBkZXNjcmliZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IFAuQmxpbmtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAvKiBXZWJLaXQgKi9cbiAge1xuICAgIHRlc3Q6IFsvKGFwcGxlKT93ZWJraXQvaV0sXG4gICAgZGVzY3JpYmUodCkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgbmFtZTogUC5XZWJLaXRcbiAgICAgIH0sIHIgPSBpLmdldEZpcnN0TWF0Y2goL3dlYmtpdFxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdCk7XG4gICAgICByZXR1cm4gciAmJiAoZS52ZXJzaW9uID0gciksIGU7XG4gICAgfVxuICB9XG5dO1xuY2xhc3Mgc2Uge1xuICAvKipcbiAgICogQ3JlYXRlIGluc3RhbmNlIG9mIFBhcnNlclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gVUEgVXNlci1BZ2VudCBzdHJpbmdcbiAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcFBhcnNpbmc9ZmFsc2VdIHBhcnNlciBjYW4gc2tpcCBwYXJzaW5nIGluIHB1cnBvc2Ugb2YgcGVyZm9ybWFuY2VcbiAgICogaW1wcm92ZW1lbnRzIGlmIHlvdSBuZWVkIHRvIG1ha2UgYSBtb3JlIHBhcnRpY3VsYXIgcGFyc2luZ1xuICAgKiBsaWtlIHtAbGluayBQYXJzZXIjcGFyc2VCcm93c2VyfSBvciB7QGxpbmsgUGFyc2VyI3BhcnNlUGxhdGZvcm19XG4gICAqXG4gICAqIEB0aHJvdyB7RXJyb3J9IGluIGNhc2Ugb2YgZW1wdHkgVUEgU3RyaW5nXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgciA9ICExKSB7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID09PSBcIlwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlckFnZW50IHBhcmFtZXRlciBjYW4ndCBiZSBlbXB0eVwiKTtcbiAgICB0aGlzLl91YSA9IGUsIHRoaXMucGFyc2VkUmVzdWx0ID0ge30sIHIgIT09ICEwICYmIHRoaXMucGFyc2UoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IFVzZXJBZ2VudCBzdHJpbmcgb2YgY3VycmVudCBQYXJzZXIgaW5zdGFuY2VcbiAgICogQHJldHVybiB7U3RyaW5nfSBVc2VyLUFnZW50IFN0cmluZyBvZiB0aGUgY3VycmVudCA8UGFyc2VyPiBvYmplY3RcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0VUEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VhO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0IGEgVUEgc3RyaW5nIGZvciBhIHJlZ2V4cFxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHRlc3QoZSkge1xuICAgIHJldHVybiBlLnRlc3QodGhpcy5fdWEpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgcGFyc2VkIGJyb3dzZXIgb2JqZWN0XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHBhcnNlQnJvd3NlcigpIHtcbiAgICB0aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyID0ge307XG4gICAgY29uc3QgZSA9IGkuZmluZChEZSwgKHIpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygci50ZXN0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHIudGVzdCh0aGlzKTtcbiAgICAgIGlmIChyLnRlc3QgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgcmV0dXJuIHIudGVzdC5zb21lKChuKSA9PiB0aGlzLnRlc3QobikpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBlICYmICh0aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyID0gZS5kZXNjcmliZSh0aGlzLmdldFVBKCkpKSwgdGhpcy5wYXJzZWRSZXN1bHQuYnJvd3NlcjtcbiAgfVxuICAvKipcbiAgICogR2V0IHBhcnNlZCBicm93c2VyIG9iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEJyb3dzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VkUmVzdWx0LmJyb3dzZXIgPyB0aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyIDogdGhpcy5wYXJzZUJyb3dzZXIoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGJyb3dzZXIncyBuYW1lXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQnJvd3NlcidzIG5hbWUgb3IgYW4gZW1wdHkgc3RyaW5nXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEJyb3dzZXJOYW1lKGUpIHtcbiAgICByZXR1cm4gZSA/IFN0cmluZyh0aGlzLmdldEJyb3dzZXIoKS5uYW1lKS50b0xvd2VyQ2FzZSgpIHx8IFwiXCIgOiB0aGlzLmdldEJyb3dzZXIoKS5uYW1lIHx8IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBicm93c2VyJ3MgdmVyc2lvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHZlcnNpb24gb2YgYnJvd3NlclxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRCcm93c2VyVmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCcm93c2VyKCkudmVyc2lvbjtcbiAgfVxuICAvKipcbiAgICogR2V0IE9TXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5nZXRPUygpO1xuICAgKiB7XG4gICAqICAgbmFtZTogJ21hY09TJyxcbiAgICogICB2ZXJzaW9uOiAnMTAuMTEuMTInXG4gICAqIH1cbiAgICovXG4gIGdldE9TKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlZFJlc3VsdC5vcyA/IHRoaXMucGFyc2VkUmVzdWx0Lm9zIDogdGhpcy5wYXJzZU9TKCk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIE9TIGFuZCBzYXZlIGl0IHRvIHRoaXMucGFyc2VkUmVzdWx0Lm9zXG4gICAqIEByZXR1cm4geyp8e319XG4gICAqL1xuICBwYXJzZU9TKCkge1xuICAgIHRoaXMucGFyc2VkUmVzdWx0Lm9zID0ge307XG4gICAgY29uc3QgZSA9IGkuZmluZChxZSwgKHIpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygci50ZXN0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHIudGVzdCh0aGlzKTtcbiAgICAgIGlmIChyLnRlc3QgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgcmV0dXJuIHIudGVzdC5zb21lKChuKSA9PiB0aGlzLnRlc3QobikpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBlICYmICh0aGlzLnBhcnNlZFJlc3VsdC5vcyA9IGUuZGVzY3JpYmUodGhpcy5nZXRVQSgpKSksIHRoaXMucGFyc2VkUmVzdWx0Lm9zO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgT1MgbmFtZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0b0xvd2VyQ2FzZV0gcmV0dXJuIGxvd2VyLWNhc2VkIHZhbHVlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gbmFtZSBvZiB0aGUgT1Mg4oCUIG1hY09TLCBXaW5kb3dzLCBMaW51eCwgZXRjLlxuICAgKi9cbiAgZ2V0T1NOYW1lKGUpIHtcbiAgICBjb25zdCB7IG5hbWU6IHIgfSA9IHRoaXMuZ2V0T1MoKTtcbiAgICByZXR1cm4gZSA/IFN0cmluZyhyKS50b0xvd2VyQ2FzZSgpIHx8IFwiXCIgOiByIHx8IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBPUyB2ZXJzaW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gZnVsbCB2ZXJzaW9uIHdpdGggZG90cyAoJzEwLjExLjEyJywgJzUuNicsIGV0YylcbiAgICovXG4gIGdldE9TVmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPUygpLnZlcnNpb247XG4gIH1cbiAgLyoqXG4gICAqIEdldCBwYXJzZWQgcGxhdGZvcm1cbiAgICogQHJldHVybiB7e319XG4gICAqL1xuICBnZXRQbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm0gPyB0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybSA6IHRoaXMucGFyc2VQbGF0Zm9ybSgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgcGxhdGZvcm0gbmFtZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0b0xvd2VyQ2FzZT1mYWxzZV1cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldFBsYXRmb3JtVHlwZShlID0gITEpIHtcbiAgICBjb25zdCB7IHR5cGU6IHIgfSA9IHRoaXMuZ2V0UGxhdGZvcm0oKTtcbiAgICByZXR1cm4gZSA/IFN0cmluZyhyKS50b0xvd2VyQ2FzZSgpIHx8IFwiXCIgOiByIHx8IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBwYXJzZWQgcGxhdGZvcm1cbiAgICogQHJldHVybiB7e319XG4gICAqL1xuICBwYXJzZVBsYXRmb3JtKCkge1xuICAgIHRoaXMucGFyc2VkUmVzdWx0LnBsYXRmb3JtID0ge307XG4gICAgY29uc3QgZSA9IGkuZmluZChHZSwgKHIpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygci50ZXN0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHIudGVzdCh0aGlzKTtcbiAgICAgIGlmIChyLnRlc3QgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgcmV0dXJuIHIudGVzdC5zb21lKChuKSA9PiB0aGlzLnRlc3QobikpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBlICYmICh0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybSA9IGUuZGVzY3JpYmUodGhpcy5nZXRVQSgpKSksIHRoaXMucGFyc2VkUmVzdWx0LnBsYXRmb3JtO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgcGFyc2VkIGVuZ2luZVxuICAgKiBAcmV0dXJuIHt7fX1cbiAgICovXG4gIGdldEVuZ2luZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lID8gdGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lIDogdGhpcy5wYXJzZUVuZ2luZSgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgZW5naW5lcydzIG5hbWVcbiAgICogQHJldHVybiB7U3RyaW5nfSBFbmdpbmVzJ3MgbmFtZSBvciBhbiBlbXB0eSBzdHJpbmdcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0RW5naW5lTmFtZShlKSB7XG4gICAgcmV0dXJuIGUgPyBTdHJpbmcodGhpcy5nZXRFbmdpbmUoKS5uYW1lKS50b0xvd2VyQ2FzZSgpIHx8IFwiXCIgOiB0aGlzLmdldEVuZ2luZSgpLm5hbWUgfHwgXCJcIjtcbiAgfVxuICAvKipcbiAgICogR2V0IHBhcnNlZCBwbGF0Zm9ybVxuICAgKiBAcmV0dXJuIHt7fX1cbiAgICovXG4gIHBhcnNlRW5naW5lKCkge1xuICAgIHRoaXMucGFyc2VkUmVzdWx0LmVuZ2luZSA9IHt9O1xuICAgIGNvbnN0IGUgPSBpLmZpbmQoUWUsIChyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHIudGVzdCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiByLnRlc3QodGhpcyk7XG4gICAgICBpZiAoci50ZXN0IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgIHJldHVybiByLnRlc3Quc29tZSgobikgPT4gdGhpcy50ZXN0KG4pKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJyb3dzZXIncyB0ZXN0IGZ1bmN0aW9uIGlzIG5vdCB2YWxpZFwiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZSAmJiAodGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lID0gZS5kZXNjcmliZSh0aGlzLmdldFVBKCkpKSwgdGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBmdWxsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBicm93c2VyXG4gICAqIEByZXR1cm5zIHtQYXJzZXJ9XG4gICAqL1xuICBwYXJzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUJyb3dzZXIoKSwgdGhpcy5wYXJzZU9TKCksIHRoaXMucGFyc2VQbGF0Zm9ybSgpLCB0aGlzLnBhcnNlRW5naW5lKCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBwYXJzZWQgcmVzdWx0XG4gICAqIEByZXR1cm4ge1BhcnNlZFJlc3VsdH1cbiAgICovXG4gIGdldFJlc3VsdCgpIHtcbiAgICByZXR1cm4gaS5hc3NpZ24oe30sIHRoaXMucGFyc2VkUmVzdWx0KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcGFyc2VkIGJyb3dzZXIgbWF0Y2hlcyBjZXJ0YWluIGNvbmRpdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoZWNrVHJlZSBJdCdzIG9uZSBvciB0d28gbGF5ZXJlZCBvYmplY3QsXG4gICAqIHdoaWNoIGNhbiBpbmNsdWRlIGEgcGxhdGZvcm0gb3IgYW4gT1Mgb24gdGhlIGZpcnN0IGxheWVyXG4gICAqIGFuZCBzaG91bGQgaGF2ZSBicm93c2VycyBzcGVjcyBvbiB0aGUgYm90dG9tLWxheWluZyBsYXllclxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbnx1bmRlZmluZWR9IFdoZXRoZXIgdGhlIGJyb3dzZXIgc2F0aXNmaWVzIHRoZSBzZXQgY29uZGl0aW9ucyBvciBub3QuXG4gICAqIFJldHVybnMgYHVuZGVmaW5lZGAgd2hlbiB0aGUgYnJvd3NlciBpcyBubyBkZXNjcmliZWQgaW4gdGhlIGNoZWNrVHJlZSBvYmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGJyb3dzZXIgPSBCb3dzZXIuZ2V0UGFyc2VyKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICogaWYgKGJyb3dzZXIuc2F0aXNmaWVzKHtjaHJvbWU6ICc+MTE4LjAxLjEzMjInIH0pKVxuICAgKiAvLyBvciB3aXRoIG9zXG4gICAqIGlmIChicm93c2VyLnNhdGlzZmllcyh7d2luZG93czogeyBjaHJvbWU6ICc+MTE4LjAxLjEzMjInIH0gfSkpXG4gICAqIC8vIG9yIHdpdGggcGxhdGZvcm1zXG4gICAqIGlmIChicm93c2VyLnNhdGlzZmllcyh7ZGVza3RvcDogeyBjaHJvbWU6ICc+MTE4LjAxLjEzMjInIH0gfSkpXG4gICAqL1xuICBzYXRpc2ZpZXMoZSkge1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICBsZXQgbiA9IDA7XG4gICAgY29uc3QgbyA9IHt9O1xuICAgIGxldCBzID0gMDtcbiAgICBpZiAoT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoaCkgPT4ge1xuICAgICAgY29uc3QgdyA9IGVbaF07XG4gICAgICB0eXBlb2YgdyA9PSBcInN0cmluZ1wiID8gKG9baF0gPSB3LCBzICs9IDEpIDogdHlwZW9mIHcgPT0gXCJvYmplY3RcIiAmJiAocltoXSA9IHcsIG4gKz0gMSk7XG4gICAgfSksIG4gPiAwKSB7XG4gICAgICBjb25zdCBoID0gT2JqZWN0LmtleXMociksIHcgPSBpLmZpbmQoaCwgKGEpID0+IHRoaXMuaXNPUyhhKSk7XG4gICAgICBpZiAodykge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5zYXRpc2ZpZXMoclt3XSk7XG4gICAgICAgIGlmIChhICE9PSB2b2lkIDApXG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgICBjb25zdCBsID0gaS5maW5kKFxuICAgICAgICBoLFxuICAgICAgICAoYSkgPT4gdGhpcy5pc1BsYXRmb3JtKGEpXG4gICAgICApO1xuICAgICAgaWYgKGwpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuc2F0aXNmaWVzKHJbbF0pO1xuICAgICAgICBpZiAoYSAhPT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocyA+IDApIHtcbiAgICAgIGNvbnN0IGggPSBPYmplY3Qua2V5cyhvKSwgdyA9IGkuZmluZChoLCAobCkgPT4gdGhpcy5pc0Jyb3dzZXIobCwgITApKTtcbiAgICAgIGlmICh3ICE9PSB2b2lkIDApXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVWZXJzaW9uKG9bd10pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGJyb3dzZXIgbmFtZSBlcXVhbHMgdGhlIHBhc3NlZCBzdHJpbmdcbiAgICogQHBhcmFtIGJyb3dzZXJOYW1lIFRoZSBzdHJpbmcgdG8gY29tcGFyZSB3aXRoIHRoZSBicm93c2VyIG5hbWVcbiAgICogQHBhcmFtIFtpbmNsdWRpbmdBbGlhcz1mYWxzZV0gVGhlIGZsYWcgc2hvd2luZyB3aGV0aGVyIGFsaWFzIHdpbGwgYmUgaW5jbHVkZWQgaW50byBjb21wYXJpc29uXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNCcm93c2VyKGUsIHIgPSAhMSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldEJyb3dzZXJOYW1lKCkudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgbyA9IGUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBzID0gaS5nZXRCcm93c2VyVHlwZUJ5QWxpYXMobyk7XG4gICAgcmV0dXJuIHIgJiYgcyAmJiAobyA9IHMudG9Mb3dlckNhc2UoKSksIG8gPT09IG47XG4gIH1cbiAgY29tcGFyZVZlcnNpb24oZSkge1xuICAgIGxldCByID0gWzBdLCBuID0gZSwgbyA9ICExO1xuICAgIGNvbnN0IHMgPSB0aGlzLmdldEJyb3dzZXJWZXJzaW9uKCk7XG4gICAgaWYgKHR5cGVvZiBzID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gZVswXSA9PT0gXCI+XCIgfHwgZVswXSA9PT0gXCI8XCIgPyAobiA9IGUuc3Vic3RyKDEpLCBlWzFdID09PSBcIj1cIiA/IChvID0gITAsIG4gPSBlLnN1YnN0cigyKSkgOiByID0gW10sIGVbMF0gPT09IFwiPlwiID8gci5wdXNoKDEpIDogci5wdXNoKC0xKSkgOiBlWzBdID09PSBcIj1cIiA/IG4gPSBlLnN1YnN0cigxKSA6IGVbMF0gPT09IFwiflwiICYmIChvID0gITAsIG4gPSBlLnN1YnN0cigxKSksIHIuaW5kZXhPZihcbiAgICAgICAgaS5jb21wYXJlVmVyc2lvbnMocywgbiwgbylcbiAgICAgICkgPiAtMTtcbiAgfVxuICBpc09TKGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPU05hbWUoITApID09PSBTdHJpbmcoZSkudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBpc1BsYXRmb3JtKGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQbGF0Zm9ybVR5cGUoITApID09PSBTdHJpbmcoZSkudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBpc0VuZ2luZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW5naW5lTmFtZSghMCkgPT09IFN0cmluZyhlKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIC8qKlxuICAgKiBJcyBhbnl0aGluZz8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgaXMgY2FsbGVkIFwiYW55dGhpbmdcIixcbiAgICogdGhlIE9TIGNhbGxlZCBcImFueXRoaW5nXCIgb3IgdGhlIHBsYXRmb3JtIGNhbGxlZCBcImFueXRoaW5nXCJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFueXRoaW5nXG4gICAqIEBwYXJhbSBbaW5jbHVkaW5nQWxpYXM9ZmFsc2VdIFRoZSBmbGFnIHNob3dpbmcgd2hldGhlciBhbGlhcyB3aWxsIGJlIGluY2x1ZGVkIGludG8gY29tcGFyaXNvblxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGlzKGUsIHIgPSAhMSkge1xuICAgIHJldHVybiB0aGlzLmlzQnJvd3NlcihlLCByKSB8fCB0aGlzLmlzT1MoZSkgfHwgdGhpcy5pc1BsYXRmb3JtKGUpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbnkgb2YgdGhlIGdpdmVuIHZhbHVlcyBzYXRpc2ZpZXMgdGhpcy5pcyhhbnl0aGluZylcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0gYW55dGhpbmdzXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgc29tZShlID0gW10pIHtcbiAgICByZXR1cm4gZS5zb21lKChyKSA9PiB0aGlzLmlzKHIpKTtcbiAgfVxufVxuLyohXG4gKiBCb3dzZXIgLSBhIGJyb3dzZXIgZGV0ZWN0b3JcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9sYW5jZWRpa3Nvbi9ib3dzZXJcbiAqIE1JVCBMaWNlbnNlIHwgKGMpIER1c3RpbiBEaWF6IDIwMTItMjAxNVxuICogTUlUIExpY2Vuc2UgfCAoYykgRGVuaXMgRGVtY2hlbmtvIDIwMTUtMjAxOVxuICovXG5jbGFzcyBYZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEge0BsaW5rIFBhcnNlcn0gaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFVBIFVzZXJBZ2VudCBzdHJpbmdcbiAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcFBhcnNpbmc9ZmFsc2VdIFdpbGwgbWFrZSB0aGUgUGFyc2VyIHBvc3Rwb25lIHBhcnNpbmcgdW50aWwgeW91IGFzayBpdFxuICAgKiBleHBsaWNpdGx5LiBTYW1lIGFzIGBza2lwUGFyc2luZ2AgZm9yIHtAbGluayBQYXJzZXJ9LlxuICAgKiBAcmV0dXJucyB7UGFyc2VyfVxuICAgKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBVQSBpcyBub3QgYSBTdHJpbmdcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcGFyc2VyID0gQm93c2VyLmdldFBhcnNlcih3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAqIGNvbnN0IHJlc3VsdCA9IHBhcnNlci5nZXRSZXN1bHQoKTtcbiAgICovXG4gIHN0YXRpYyBnZXRQYXJzZXIoZSwgciA9ICExKSB7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyQWdlbnQgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO1xuICAgIHJldHVybiBuZXcgc2UoZSwgcik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB7QGxpbmsgUGFyc2VyfSBpbnN0YW5jZSBhbmQgcnVucyB7QGxpbmsgUGFyc2VyLmdldFJlc3VsdH0gaW1tZWRpYXRlbHlcbiAgICpcbiAgICogQHBhcmFtIFVBXG4gICAqIEByZXR1cm4ge1BhcnNlZFJlc3VsdH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcmVzdWx0ID0gQm93c2VyLnBhcnNlKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICovXG4gIHN0YXRpYyBwYXJzZShlKSB7XG4gICAgcmV0dXJuIG5ldyBzZShlKS5nZXRSZXN1bHQoKTtcbiAgfVxuICBzdGF0aWMgZ2V0IEJST1dTRVJfTUFQKCkge1xuICAgIHJldHVybiBiZTtcbiAgfVxuICBzdGF0aWMgZ2V0IEVOR0lORV9NQVAoKSB7XG4gICAgcmV0dXJuIFA7XG4gIH1cbiAgc3RhdGljIGdldCBPU19NQVAoKSB7XG4gICAgcmV0dXJuIEY7XG4gIH1cbiAgc3RhdGljIGdldCBQTEFURk9STVNfTUFQKCkge1xuICAgIHJldHVybiBNO1xuICB9XG59XG5jb25zdCBhZSA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IG51bGw7XG5mdW5jdGlvbiBIZSgpIHtcbiAgaWYgKCFhZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgc3dpdGNoIChYZS5nZXRQYXJzZXIoYWUubmF2aWdhdG9yLnVzZXJBZ2VudCkuZ2V0QnJvd3Nlck5hbWUoKT8udG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJmaXJlZm94XCI6XG4gICAgICByZXR1cm4gXCJmaXJlZm94XCI7XG4gICAgY2FzZSBcIm1pY3Jvc29mdCBlZGdlXCI6XG4gICAgICByZXR1cm4gXCJlZGdlXCI7XG4gICAgY2FzZSBcImFuZHJvaWQgYnJvd3NlclwiOlxuICAgIGNhc2UgXCJjaHJvbWVcIjpcbiAgICBjYXNlIFwiY2hyb21pdW1cIjpcbiAgICBjYXNlIFwiZWxlY3Ryb25cIjpcbiAgICBjYXNlIFwib3BlcmFcIjpcbiAgICBjYXNlIFwidml2YWxkaVwiOlxuICAgICAgcmV0dXJuIFwiY2hyb21lXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG52YXIgVWUgPSB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5jb25zdCBaZSA9IFVlO1xudmFyIEtlID0gdHlwZW9mIHNlbGYgPT0gXCJvYmplY3RcIiAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZiwgWWUgPSBaZSB8fCBLZSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG5jb25zdCAkZSA9IFllO1xudmFyIEplID0gJGUuU3ltYm9sO1xuY29uc3QgWSA9IEplO1xudmFyIG1lID0gT2JqZWN0LnByb3RvdHlwZSwgZXQgPSBtZS5oYXNPd25Qcm9wZXJ0eSwgdHQgPSBtZS50b1N0cmluZywgRyA9IFkgPyBZLnRvU3RyaW5nVGFnIDogdm9pZCAwO1xuZnVuY3Rpb24gcnQodCkge1xuICB2YXIgZSA9IGV0LmNhbGwodCwgRyksIHIgPSB0W0ddO1xuICB0cnkge1xuICAgIHRbR10gPSB2b2lkIDA7XG4gICAgdmFyIG4gPSAhMDtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgdmFyIG8gPSB0dC5jYWxsKHQpO1xuICByZXR1cm4gbiAmJiAoZSA/IHRbR10gPSByIDogZGVsZXRlIHRbR10pLCBvO1xufVxudmFyIG50ID0gT2JqZWN0LnByb3RvdHlwZSwgaXQgPSBudC50b1N0cmluZztcbmZ1bmN0aW9uIG90KHQpIHtcbiAgcmV0dXJuIGl0LmNhbGwodCk7XG59XG52YXIgc3QgPSBcIltvYmplY3QgTnVsbF1cIiwgYXQgPSBcIltvYmplY3QgVW5kZWZpbmVkXVwiLCBjZSA9IFkgPyBZLnRvU3RyaW5nVGFnIDogdm9pZCAwO1xuZnVuY3Rpb24gY3QodCkge1xuICByZXR1cm4gdCA9PSBudWxsID8gdCA9PT0gdm9pZCAwID8gYXQgOiBzdCA6IGNlICYmIGNlIGluIE9iamVjdCh0KSA/IHJ0KHQpIDogb3QodCk7XG59XG5mdW5jdGlvbiBsdCh0KSB7XG4gIHJldHVybiB0ICE9IG51bGwgJiYgdHlwZW9mIHQgPT0gXCJvYmplY3RcIjtcbn1cbnZhciBkdCA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCB1dCA9IGR0O1xudmFyIGZ0ID0gXCJbb2JqZWN0IFN0cmluZ11cIjtcbmZ1bmN0aW9uIHRlKHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgfHwgIXV0KHQpICYmIGx0KHQpICYmIGN0KHQpID09IGZ0O1xufVxuY29uc3Qgd3QgPSAoe1xuICBhdmFpbGFibGVDb25uZWN0b3JzOiB0LFxuICBpbnN0YWxsZWRXYWxsZXRzOiBlLFxuICBkaXNjb3ZlcnlXYWxsZXRzOiByLFxuICBzdG9yZVZlcnNpb246IG4sXG4gIGN1c3RvbU9yZGVyOiBvXG59KSA9PiB7XG4gIGlmICh3aW5kb3c/LnN0YXJrbmV0X2FyZ2VudFg/LmlzSW5BcHBCcm93c2VyKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgaCA9IGUubWFwKFxuICAgIChhKSA9PiB0LmZpbmQoKGcpID0+IGcuaWQgPT09IGEuaWQpXG4gICk7XG4gIHJldHVybiAobyA/IHQgOiBbXG4gICAgLi4udC5maWx0ZXIoKGEpID0+IGguaW5jbHVkZXMoYSkpLFxuICAgIC4uLnQuZmlsdGVyKChhKSA9PiAhaC5pbmNsdWRlcyhhKSlcbiAgXSkubWFwKChhKSA9PiB7XG4gICAgY29uc3QgZyA9IGUuZmluZCgoZikgPT4gZi5pZCA9PT0gYS5pZCk7XG4gICAgaWYgKGcpIHtcbiAgICAgIGNvbnN0IGYgPSBnLmlkID09PSBcImFyZ2VudFhcIiA/IHsgbGlnaHQ6IGVlLCBkYXJrOiBlZSB9IDogdGUoZy5pY29uKSA/IHsgbGlnaHQ6IGcuaWNvbiwgZGFyazogZy5pY29uIH0gOiBnLmljb247XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBnLm5hbWUsXG4gICAgICAgIGlkOiBnLmlkLFxuICAgICAgICBpY29uOiBmLFxuICAgICAgICBjb25uZWN0b3I6IGFcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHkgPSByLmZpbHRlcihcbiAgICAgIChmKSA9PiAhIWYuZG93bmxvYWRzW25dXG4gICAgKS5maW5kKChmKSA9PiBmLmlkID09PSBhLmlkKTtcbiAgICBpZiAoeSkge1xuICAgICAgY29uc3QgeyBkb3dubG9hZHM6IGYgfSA9IHksIGIgPSB5LmlkID09PSBcImFyZ2VudFhcIiA/IGVlIDogeS5pY29uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogeS5uYW1lLFxuICAgICAgICBpZDogeS5pZCxcbiAgICAgICAgaWNvbjogeyBsaWdodDogYiwgZGFyazogYiB9LFxuICAgICAgICBjb25uZWN0b3I6IGEsXG4gICAgICAgIGRvd25sb2FkOiBmW25dXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gIWEgfHwgIWEuaWQgfHwgIWEubmFtZSA/IG51bGwgOiB7XG4gICAgICBuYW1lOiBhLm5hbWUsXG4gICAgICBpZDogYS5pZCxcbiAgICAgIGljb246IGEuaWNvbixcbiAgICAgIGNvbm5lY3RvcjogYSxcbiAgICAgIHRpdGxlOiBcInRpdGxlXCIgaW4gYSAmJiB0ZShhLnRpdGxlKSA/IGEudGl0bGUgOiB2b2lkIDAsXG4gICAgICBzdWJ0aXRsZTogXCJzdWJ0aXRsZVwiIGluIGEgJiYgdGUoYS5zdWJ0aXRsZSkgPyBhLnN1YnRpdGxlIDogdm9pZCAwXG4gICAgfTtcbiAgfSkuZmlsdGVyKChhKSA9PiBhICE9PSBudWxsKTtcbn07XG5mdW5jdGlvbiBSKCkge1xufVxuZnVuY3Rpb24gdmUodCkge1xuICByZXR1cm4gdCgpO1xufVxuZnVuY3Rpb24gbGUoKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cbmZ1bmN0aW9uIGoodCkge1xuICB0LmZvckVhY2godmUpO1xufVxuZnVuY3Rpb24geWUodCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24ga2UodCwgZSkge1xuICByZXR1cm4gdCAhPSB0ID8gZSA9PSBlIDogdCAhPT0gZSB8fCB0ICYmIHR5cGVvZiB0ID09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiO1xufVxubGV0IFU7XG5mdW5jdGlvbiBfZSh0LCBlKSB7XG4gIHJldHVybiB0ID09PSBlID8gITAgOiAoVSB8fCAoVSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpKSwgVS5ocmVmID0gZSwgdCA9PT0gVS5ocmVmKTtcbn1cbmZ1bmN0aW9uIGd0KHQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIF8odCwgZSkge1xuICB0LmFwcGVuZENoaWxkKGUpO1xufVxuZnVuY3Rpb24gVyh0LCBlLCByKSB7XG4gIHQuaW5zZXJ0QmVmb3JlKGUsIHIgfHwgbnVsbCk7XG59XG5mdW5jdGlvbiBFKHQpIHtcbiAgdC5wYXJlbnROb2RlICYmIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KTtcbn1cbmZ1bmN0aW9uIGh0KHQsIGUpIHtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgciArPSAxKVxuICAgIHRbcl0gJiYgdFtyXS5kKGUpO1xufVxuZnVuY3Rpb24gQih0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHQpO1xufVxuZnVuY3Rpb24gSSh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0KTtcbn1cbmZ1bmN0aW9uIHooKSB7XG4gIHJldHVybiBJKFwiIFwiKTtcbn1cbmZ1bmN0aW9uIHhlKCkge1xuICByZXR1cm4gSShcIlwiKTtcbn1cbmZ1bmN0aW9uIE8odCwgZSwgciwgbikge1xuICByZXR1cm4gdC5hZGRFdmVudExpc3RlbmVyKGUsIHIsIG4pLCAoKSA9PiB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgciwgbik7XG59XG5mdW5jdGlvbiBwKHQsIGUsIHIpIHtcbiAgciA9PSBudWxsID8gdC5yZW1vdmVBdHRyaWJ1dGUoZSkgOiB0LmdldEF0dHJpYnV0ZShlKSAhPT0gciAmJiB0LnNldEF0dHJpYnV0ZShlLCByKTtcbn1cbmZ1bmN0aW9uIHB0KHQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20odC5jaGlsZE5vZGVzKTtcbn1cbmZ1bmN0aW9uICQodCwgZSkge1xuICBlID0gXCJcIiArIGUsIHQuZGF0YSAhPT0gZSAmJiAodC5kYXRhID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIGUpO1xufVxuZnVuY3Rpb24gTWUodCwgZSwgciwgbikge1xuICByID09IG51bGwgPyB0LnN0eWxlLnJlbW92ZVByb3BlcnR5KGUpIDogdC5zdHlsZS5zZXRQcm9wZXJ0eShlLCByLCBuID8gXCJpbXBvcnRhbnRcIiA6IFwiXCIpO1xufVxubGV0IFg7XG5mdW5jdGlvbiBRKHQpIHtcbiAgWCA9IHQ7XG59XG5mdW5jdGlvbiBidCgpIHtcbiAgaWYgKCFYKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGNhbGxlZCBvdXRzaWRlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvblwiKTtcbiAgcmV0dXJuIFg7XG59XG5mdW5jdGlvbiBtdCh0KSB7XG4gIGJ0KCkuJCQub25fbW91bnQucHVzaCh0KTtcbn1cbmNvbnN0IEQgPSBbXSwgZGUgPSBbXTtcbmxldCBxID0gW107XG5jb25zdCB1ZSA9IFtdLCB2dCA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmxldCBuZSA9ICExO1xuZnVuY3Rpb24geXQoKSB7XG4gIG5lIHx8IChuZSA9ICEwLCB2dC50aGVuKFNlKSk7XG59XG5mdW5jdGlvbiBpZSh0KSB7XG4gIHEucHVzaCh0KTtcbn1cbmNvbnN0IHJlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmxldCBWID0gMDtcbmZ1bmN0aW9uIFNlKCkge1xuICBpZiAoViAhPT0gMClcbiAgICByZXR1cm47XG4gIGNvbnN0IHQgPSBYO1xuICBkbyB7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoOyBWIDwgRC5sZW5ndGg7ICkge1xuICAgICAgICBjb25zdCBlID0gRFtWXTtcbiAgICAgICAgVisrLCBRKGUpLCBrdChlLiQkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBELmxlbmd0aCA9IDAsIFYgPSAwLCBlO1xuICAgIH1cbiAgICBmb3IgKFEobnVsbCksIEQubGVuZ3RoID0gMCwgViA9IDA7IGRlLmxlbmd0aDsgKVxuICAgICAgZGUucG9wKCkoKTtcbiAgICBmb3IgKGxldCBlID0gMDsgZSA8IHEubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgIGNvbnN0IHIgPSBxW2VdO1xuICAgICAgcmUuaGFzKHIpIHx8IChyZS5hZGQociksIHIoKSk7XG4gICAgfVxuICAgIHEubGVuZ3RoID0gMDtcbiAgfSB3aGlsZSAoRC5sZW5ndGgpO1xuICBmb3IgKDsgdWUubGVuZ3RoOyApXG4gICAgdWUucG9wKCkoKTtcbiAgbmUgPSAhMSwgcmUuY2xlYXIoKSwgUSh0KTtcbn1cbmZ1bmN0aW9uIGt0KHQpIHtcbiAgaWYgKHQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICB0LnVwZGF0ZSgpLCBqKHQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgY29uc3QgZSA9IHQuZGlydHk7XG4gICAgdC5kaXJ0eSA9IFstMV0sIHQuZnJhZ21lbnQgJiYgdC5mcmFnbWVudC5wKHQuY3R4LCBlKSwgdC5hZnRlcl91cGRhdGUuZm9yRWFjaChpZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIF90KHQpIHtcbiAgY29uc3QgZSA9IFtdLCByID0gW107XG4gIHEuZm9yRWFjaCgobikgPT4gdC5pbmRleE9mKG4pID09PSAtMSA/IGUucHVzaChuKSA6IHIucHVzaChuKSksIHIuZm9yRWFjaCgobikgPT4gbigpKSwgcSA9IGU7XG59XG5jb25zdCBLID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmxldCBUO1xuZnVuY3Rpb24gQmUoKSB7XG4gIFQgPSB7XG4gICAgcjogMCxcbiAgICBjOiBbXSxcbiAgICBwOiBUXG4gICAgLy8gcGFyZW50IGdyb3VwXG4gIH07XG59XG5mdW5jdGlvbiBGZSgpIHtcbiAgVC5yIHx8IGooVC5jKSwgVCA9IFQucDtcbn1cbmZ1bmN0aW9uIEwodCwgZSkge1xuICB0ICYmIHQuaSAmJiAoSy5kZWxldGUodCksIHQuaShlKSk7XG59XG5mdW5jdGlvbiBIKHQsIGUsIHIsIG4pIHtcbiAgaWYgKHQgJiYgdC5vKSB7XG4gICAgaWYgKEsuaGFzKHQpKVxuICAgICAgcmV0dXJuO1xuICAgIEsuYWRkKHQpLCBULmMucHVzaCgoKSA9PiB7XG4gICAgICBLLmRlbGV0ZSh0KSwgbiAmJiAociAmJiB0LmQoMSksIG4oKSk7XG4gICAgfSksIHQubyhlKTtcbiAgfSBlbHNlXG4gICAgbiAmJiBuKCk7XG59XG5mdW5jdGlvbiBmZSh0KSB7XG4gIHJldHVybiB0Py5sZW5ndGggIT09IHZvaWQgMCA/IHQgOiBBcnJheS5mcm9tKHQpO1xufVxuZnVuY3Rpb24geHQodCkge1xuICB0ICYmIHQuYygpO1xufVxuZnVuY3Rpb24gQ2UodCwgZSwgcikge1xuICBjb25zdCB7IGZyYWdtZW50OiBuLCBhZnRlcl91cGRhdGU6IG8gfSA9IHQuJCQ7XG4gIG4gJiYgbi5tKGUsIHIpLCBpZSgoKSA9PiB7XG4gICAgY29uc3QgcyA9IHQuJCQub25fbW91bnQubWFwKHZlKS5maWx0ZXIoeWUpO1xuICAgIHQuJCQub25fZGVzdHJveSA/IHQuJCQub25fZGVzdHJveS5wdXNoKC4uLnMpIDogaihzKSwgdC4kJC5vbl9tb3VudCA9IFtdO1xuICB9KSwgby5mb3JFYWNoKGllKTtcbn1cbmZ1bmN0aW9uIEFlKHQsIGUpIHtcbiAgY29uc3QgciA9IHQuJCQ7XG4gIHIuZnJhZ21lbnQgIT09IG51bGwgJiYgKF90KHIuYWZ0ZXJfdXBkYXRlKSwgaihyLm9uX2Rlc3Ryb3kpLCByLmZyYWdtZW50ICYmIHIuZnJhZ21lbnQuZChlKSwgci5vbl9kZXN0cm95ID0gci5mcmFnbWVudCA9IG51bGwsIHIuY3R4ID0gW10pO1xufVxuZnVuY3Rpb24gTXQodCwgZSkge1xuICB0LiQkLmRpcnR5WzBdID09PSAtMSAmJiAoRC5wdXNoKHQpLCB5dCgpLCB0LiQkLmRpcnR5LmZpbGwoMCkpLCB0LiQkLmRpcnR5W2UgLyAzMSB8IDBdIHw9IDEgPDwgZSAlIDMxO1xufVxuZnVuY3Rpb24gT2UodCwgZSwgciwgbiwgbywgcywgZCA9IG51bGwsIGggPSBbLTFdKSB7XG4gIGNvbnN0IHcgPSBYO1xuICBRKHQpO1xuICBjb25zdCBsID0gdC4kJCA9IHtcbiAgICBmcmFnbWVudDogbnVsbCxcbiAgICBjdHg6IFtdLFxuICAgIC8vIHN0YXRlXG4gICAgcHJvcHM6IHMsXG4gICAgdXBkYXRlOiBSLFxuICAgIG5vdF9lcXVhbDogbyxcbiAgICBib3VuZDogbGUoKSxcbiAgICAvLyBsaWZlY3ljbGVcbiAgICBvbl9tb3VudDogW10sXG4gICAgb25fZGVzdHJveTogW10sXG4gICAgb25fZGlzY29ubmVjdDogW10sXG4gICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICBjb250ZXh0OiBuZXcgTWFwKGUuY29udGV4dCB8fCAodyA/IHcuJCQuY29udGV4dCA6IFtdKSksXG4gICAgLy8gZXZlcnl0aGluZyBlbHNlXG4gICAgY2FsbGJhY2tzOiBsZSgpLFxuICAgIGRpcnR5OiBoLFxuICAgIHNraXBfYm91bmQ6ICExLFxuICAgIHJvb3Q6IGUudGFyZ2V0IHx8IHcuJCQucm9vdFxuICB9O1xuICBkICYmIGQobC5yb290KTtcbiAgbGV0IGEgPSAhMTtcbiAgaWYgKGwuY3R4ID0gciA/IHIodCwgZS5wcm9wcyB8fCB7fSwgKGcsIHksIC4uLmYpID0+IHtcbiAgICBjb25zdCBiID0gZi5sZW5ndGggPyBmWzBdIDogeTtcbiAgICByZXR1cm4gbC5jdHggJiYgbyhsLmN0eFtnXSwgbC5jdHhbZ10gPSBiKSAmJiAoIWwuc2tpcF9ib3VuZCAmJiBsLmJvdW5kW2ddICYmIGwuYm91bmRbZ10oYiksIGEgJiYgTXQodCwgZykpLCB5O1xuICB9KSA6IFtdLCBsLnVwZGF0ZSgpLCBhID0gITAsIGoobC5iZWZvcmVfdXBkYXRlKSwgbC5mcmFnbWVudCA9IG4gPyBuKGwuY3R4KSA6ICExLCBlLnRhcmdldCkge1xuICAgIGlmIChlLmh5ZHJhdGUpIHtcbiAgICAgIGNvbnN0IGcgPSBwdChlLnRhcmdldCk7XG4gICAgICBsLmZyYWdtZW50ICYmIGwuZnJhZ21lbnQubChnKSwgZy5mb3JFYWNoKEUpO1xuICAgIH0gZWxzZVxuICAgICAgbC5mcmFnbWVudCAmJiBsLmZyYWdtZW50LmMoKTtcbiAgICBlLmludHJvICYmIEwodC4kJC5mcmFnbWVudCksIENlKHQsIGUudGFyZ2V0LCBlLmFuY2hvciksIFNlKCk7XG4gIH1cbiAgUSh3KTtcbn1cbmNsYXNzIE5lIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogIyMjIFBSSVZBVEUgQVBJXG4gICAgICpcbiAgICAgKiBEbyBub3QgdXNlLCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lXG4gICAgICpcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqL1xuICAgIEoodGhpcywgXCIkJFwiKTtcbiAgICAvKipcbiAgICAgKiAjIyMgUFJJVkFURSBBUElcbiAgICAgKlxuICAgICAqIERvIG5vdCB1c2UsIG1heSBjaGFuZ2UgYXQgYW55IHRpbWVcbiAgICAgKlxuICAgICAqIEB0eXBlIHthbnl9XG4gICAgICovXG4gICAgSih0aGlzLCBcIiQkc2V0XCIpO1xuICB9XG4gIC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbiAgJGRlc3Ryb3koKSB7XG4gICAgQWUodGhpcywgMSksIHRoaXMuJGRlc3Ryb3kgPSBSO1xuICB9XG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge0V4dHJhY3Q8a2V5b2YgRXZlbnRzLCBzdHJpbmc+fSBLXG4gICAqIEBwYXJhbSB7S30gdHlwZVxuICAgKiBAcGFyYW0geygoZTogRXZlbnRzW0tdKSA9PiB2b2lkKSB8IG51bGwgfCB1bmRlZmluZWR9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICAgKi9cbiAgJG9uKGUsIHIpIHtcbiAgICBpZiAoIXllKHIpKVxuICAgICAgcmV0dXJuIFI7XG4gICAgY29uc3QgbiA9IHRoaXMuJCQuY2FsbGJhY2tzW2VdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1tlXSA9IFtdKTtcbiAgICByZXR1cm4gbi5wdXNoKHIpLCAoKSA9PiB7XG4gICAgICBjb25zdCBvID0gbi5pbmRleE9mKHIpO1xuICAgICAgbyAhPT0gLTEgJiYgbi5zcGxpY2UobywgMSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtQYXJ0aWFsPFByb3BzPn0gcHJvcHNcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICAkc2V0KGUpIHtcbiAgICB0aGlzLiQkc2V0ICYmICFndChlKSAmJiAodGhpcy4kJC5za2lwX2JvdW5kID0gITAsIHRoaXMuJCRzZXQoZSksIHRoaXMuJCQuc2tpcF9ib3VuZCA9ICExKTtcbiAgfVxufVxuY29uc3QgU3QgPSBcIjRcIjtcbnR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiAod2luZG93Ll9fc3ZlbHRlIHx8ICh3aW5kb3cuX19zdmVsdGUgPSB7IHY6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkgfSkpLnYuYWRkKFN0KTtcbmZ1bmN0aW9uIEJ0KHQpIHtcbiAgbGV0IGUsIHIsIG4sIG8sIHMsIGQgPSAoXG4gICAgLyp3YWxsZXQqL1xuICAgICh0WzBdLnRpdGxlID8/IC8qd2FsbGV0Ki9cbiAgICB0WzBdLm5hbWUpICsgXCJcIlxuICApLCBoLCB3LCBsLCBhID0gKFxuICAgIC8qd2FsbGV0Ki9cbiAgICAodFswXS5zdWJ0aXRsZSA/PyBcIlwiKSArIFwiXCJcbiAgKSwgZywgeSwgZiwgYjtcbiAgZnVuY3Rpb24geCh2LCB1KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qbG9hZGluZ0l0ZW0qL1xuICAgICAgdlsyXSA9PT0gLyp3YWxsZXQqL1xuICAgICAgdlswXT8uaWQgPyBPdCA6IChcbiAgICAgICAgLyppc1N2ZyovXG4gICAgICAgIHZbNF0gPyBBdCA6IEN0XG4gICAgICApXG4gICAgKTtcbiAgfVxuICBsZXQgbSA9IHgodCksIGMgPSBtKHQpO1xuICByZXR1cm4ge1xuICAgIGMoKSB7XG4gICAgICBlID0gQihcImxpXCIpLCByID0gQihcInNwYW5cIiksIG4gPSB6KCksIG8gPSBCKFwiZGl2XCIpLCBzID0gQihcInBcIiksIGggPSBJKGQpLCB3ID0geigpLCBsID0gQihcInBcIiksIGcgPSBJKGEpLCB5ID0geigpLCBjLmMoKSwgcChyLCBcImNsYXNzXCIsIFwidy04IGgtOFwiKSwgcChzLCBcImNsYXNzXCIsIFwiZm9udC1zZW1pYm9sZCB0ZXh0LWJhc2UgcFwiKSwgcChsLCBcImNsYXNzXCIsIFwibDIgcFwiKSwgTWUobCwgXCJ0ZXh0LWFsaWduXCIsIFwiY2VudGVyXCIpLCBwKG8sIFwiY2xhc3NcIiwgXCJmbGV4IGZsZXgtY29sIGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlclwiKSwgcChlLCBcImNsYXNzXCIsIGBmbGV4IGZsZXgtcm93LXJldmVyc2UganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlciBcbiAgICAgICAgICAgIHAtMyByb3VuZGVkLW1kIGN1cnNvci1wb2ludGVyIHNoYWRvdy1saXN0LWl0ZW0gXG4gICAgICAgICAgICBkYXJrOnNoYWRvdy1ub25lIGRhcms6YmctbmV1dHJhbC04MDAgZGFyazp0ZXh0LXdoaXRlIFxuICAgICAgICAgIGhvdmVyOmJnLW5ldXRyYWwtMTAwIGRhcms6aG92ZXI6YmctbmV1dHJhbC03MDAgXG4gICAgICAgICAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBcbiAgICAgICAgZm9jdXM6cmluZy1uZXV0cmFsLTIwMCBkYXJrOmZvY3VzOnJpbmctbmV1dHJhbC03MDAgXG4gICAgICAgICAgdHJhbnNpdGlvbi1jb2xvcnNgKSwgcChlLCBcInJvbGVcIiwgXCJidXR0b25cIiksIHAoZSwgXCJ0YWJpbmRleFwiLCBcIjBcIik7XG4gICAgfSxcbiAgICBtKHYsIHUpIHtcbiAgICAgIFcodiwgZSwgdSksIF8oZSwgciksIF8oZSwgbiksIF8oZSwgbyksIF8obywgcyksIF8ocywgaCksIF8obywgdyksIF8obywgbCksIF8obCwgZyksIF8oZSwgeSksIGMubShlLCBudWxsKSwgZiB8fCAoYiA9IFtcbiAgICAgICAgTyhcbiAgICAgICAgICBlLFxuICAgICAgICAgIFwiY2xpY2tcIixcbiAgICAgICAgICAvKmNsaWNrX2hhbmRsZXJfMSovXG4gICAgICAgICAgdFs4XVxuICAgICAgICApLFxuICAgICAgICBPKFxuICAgICAgICAgIGUsXG4gICAgICAgICAgXCJrZXl1cFwiLFxuICAgICAgICAgIC8qa2V5dXBfaGFuZGxlcl8xKi9cbiAgICAgICAgICB0WzldXG4gICAgICAgIClcbiAgICAgIF0sIGYgPSAhMCk7XG4gICAgfSxcbiAgICBwKHYsIHUpIHtcbiAgICAgIHUgJiAvKndhbGxldCovXG4gICAgICAxICYmIGQgIT09IChkID0gLyp3YWxsZXQqL1xuICAgICAgKHZbMF0udGl0bGUgPz8gLyp3YWxsZXQqL1xuICAgICAgdlswXS5uYW1lKSArIFwiXCIpICYmICQoaCwgZCksIHUgJiAvKndhbGxldCovXG4gICAgICAxICYmIGEgIT09IChhID0gLyp3YWxsZXQqL1xuICAgICAgKHZbMF0uc3VidGl0bGUgPz8gXCJcIikgKyBcIlwiKSAmJiAkKGcsIGEpLCBtID09PSAobSA9IHgodikpICYmIGMgPyBjLnAodiwgdSkgOiAoYy5kKDEpLCBjID0gbSh2KSwgYyAmJiAoYy5jKCksIGMubShlLCBudWxsKSkpO1xuICAgIH0sXG4gICAgZCh2KSB7XG4gICAgICB2ICYmIEUoZSksIGMuZCgpLCBmID0gITEsIGooYik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gRnQodCkge1xuICBsZXQgZSwgciwgbiwgbywgcywgZCwgaCA9IChcbiAgICAvKndhbGxldCovXG4gICAgdFswXS5uYW1lICsgXCJcIlxuICApLCB3LCBsLCBhLCBnLCB5LCBmLCBiLCB4LCBtO1xuICByZXR1cm4ge1xuICAgIGMoKSB7XG4gICAgICBlID0gQihcImFcIiksIHIgPSBCKFwibGlcIiksIG4gPSBCKFwic3BhblwiKSwgbyA9IHooKSwgcyA9IEIoXCJwXCIpLCBkID0gSShcIkluc3RhbGwgXCIpLCB3ID0gSShoKSwgbCA9IHooKSwgYSA9IEIoXCJpbWdcIiksIHAobiwgXCJjbGFzc1wiLCBcInctOCBoLThcIiksIHAocywgXCJjbGFzc1wiLCBcImZvbnQtc2VtaWJvbGQgdGV4dC1iYXNlIHBcIiksIHAoYSwgXCJhbHRcIiwgZyA9IC8qd2FsbGV0Ki9cbiAgICAgIHRbMF0ubmFtZSksIF9lKGEuc3JjLCB5ID0gLyppY29uKi9cbiAgICAgIHRbM10pIHx8IHAoYSwgXCJzcmNcIiwgeSksIHAoYSwgXCJjbGFzc1wiLCBcInctOCBoLTggcm91bmRlZC1mdWxsXCIpLCBwKHIsIFwiY2xhc3NcIiwgYGZsZXggZmxleC1yb3ctcmV2ZXJzZSBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIFxuICAgICAgICAgICAgICBwLTMgcm91bmRlZC1tZCBjdXJzb3ItcG9pbnRlciBzaGFkb3ctbGlzdC1pdGVtIFxuICAgICAgICAgICAgICBkYXJrOnNoYWRvdy1ub25lIGRhcms6YmctbmV1dHJhbC04MDAgZGFyazp0ZXh0LXdoaXRlIFxuICAgICAgICAgICAgaG92ZXI6YmctbmV1dHJhbC0xMDAgZGFyazpob3ZlcjpiZy1uZXV0cmFsLTcwMGApLCBwKGUsIFwiYXJpYS1sYWJlbFwiLCBmID0gLyp3YWxsZXQqL1xuICAgICAgdFswXS5uYW1lICsgXCIgZG93bmxvYWQgbGlua1wiKSwgcChlLCBcImhyZWZcIiwgYiA9IC8qd2FsbGV0Ki9cbiAgICAgIHRbMF0uZG93bmxvYWQpLCBwKGUsIFwidGFyZ2V0XCIsIFwiX2JsYW5rXCIpLCBwKGUsIFwicmVsXCIsIFwibm9vcGVuZXIgbm9yZWZlcnJlclwiKSwgcChlLCBcImNsYXNzXCIsIGByb3VuZGVkLW1kIGZvY3VzOm91dGxpbmUtbm9uZSAgZm9jdXM6cmluZy0yIFxuICAgIGZvY3VzOnJpbmctbmV1dHJhbC0yMDAgIGRhcms6Zm9jdXM6cmluZy1uZXV0cmFsLTcwMCB0cmFuc2l0aW9uLWNvbG9yc2ApO1xuICAgIH0sXG4gICAgbShjLCB2KSB7XG4gICAgICBXKGMsIGUsIHYpLCBfKGUsIHIpLCBfKHIsIG4pLCBfKHIsIG8pLCBfKHIsIHMpLCBfKHMsIGQpLCBfKHMsIHcpLCBfKHIsIGwpLCBfKHIsIGEpLCB4IHx8IChtID0gW1xuICAgICAgICBPKFxuICAgICAgICAgIHIsXG4gICAgICAgICAgXCJjbGlja1wiLFxuICAgICAgICAgIC8qY2xpY2tfaGFuZGxlciovXG4gICAgICAgICAgdFs2XVxuICAgICAgICApLFxuICAgICAgICBPKFxuICAgICAgICAgIHIsXG4gICAgICAgICAgXCJrZXl1cFwiLFxuICAgICAgICAgIC8qa2V5dXBfaGFuZGxlciovXG4gICAgICAgICAgdFs3XVxuICAgICAgICApXG4gICAgICBdLCB4ID0gITApO1xuICAgIH0sXG4gICAgcChjLCB2KSB7XG4gICAgICB2ICYgLyp3YWxsZXQqL1xuICAgICAgMSAmJiBoICE9PSAoaCA9IC8qd2FsbGV0Ki9cbiAgICAgIGNbMF0ubmFtZSArIFwiXCIpICYmICQodywgaCksIHYgJiAvKndhbGxldCovXG4gICAgICAxICYmIGcgIT09IChnID0gLyp3YWxsZXQqL1xuICAgICAgY1swXS5uYW1lKSAmJiBwKGEsIFwiYWx0XCIsIGcpLCB2ICYgLyp3YWxsZXQqL1xuICAgICAgMSAmJiBmICE9PSAoZiA9IC8qd2FsbGV0Ki9cbiAgICAgIGNbMF0ubmFtZSArIFwiIGRvd25sb2FkIGxpbmtcIikgJiYgcChlLCBcImFyaWEtbGFiZWxcIiwgZiksIHYgJiAvKndhbGxldCovXG4gICAgICAxICYmIGIgIT09IChiID0gLyp3YWxsZXQqL1xuICAgICAgY1swXS5kb3dubG9hZCkgJiYgcChlLCBcImhyZWZcIiwgYik7XG4gICAgfSxcbiAgICBkKGMpIHtcbiAgICAgIGMgJiYgRShlKSwgeCA9ICExLCBqKG0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIEN0KHQpIHtcbiAgbGV0IGUsIHIsIG47XG4gIHJldHVybiB7XG4gICAgYygpIHtcbiAgICAgIGUgPSBCKFwiaW1nXCIpLCBwKGUsIFwiYWx0XCIsIHIgPSAvKndhbGxldCovXG4gICAgICB0WzBdPy5uYW1lKSwgX2UoZS5zcmMsIG4gPSAvKmljb24qL1xuICAgICAgdFszXSkgfHwgcChlLCBcInNyY1wiLCBuKSwgcChlLCBcImNsYXNzXCIsIFwidy04IGgtOCByb3VuZGVkXCIpO1xuICAgIH0sXG4gICAgbShvLCBzKSB7XG4gICAgICBXKG8sIGUsIHMpO1xuICAgIH0sXG4gICAgcChvLCBzKSB7XG4gICAgICBzICYgLyp3YWxsZXQqL1xuICAgICAgMSAmJiByICE9PSAociA9IC8qd2FsbGV0Ki9cbiAgICAgIG9bMF0/Lm5hbWUpICYmIHAoZSwgXCJhbHRcIiwgcik7XG4gICAgfSxcbiAgICBkKG8pIHtcbiAgICAgIG8gJiYgRShlKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBBdCh0KSB7XG4gIGxldCBlO1xuICByZXR1cm4ge1xuICAgIGMoKSB7XG4gICAgICBlID0gQihcImRpdlwiKSwgTWUoZSwgXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpO1xuICAgIH0sXG4gICAgbShyLCBuKSB7XG4gICAgICBXKHIsIGUsIG4pLCBlLmlubmVySFRNTCA9IC8qaWNvbiovXG4gICAgICB0WzNdO1xuICAgIH0sXG4gICAgcDogUixcbiAgICBkKHIpIHtcbiAgICAgIHIgJiYgRShlKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBPdCh0KSB7XG4gIGxldCBlO1xuICByZXR1cm4ge1xuICAgIGMoKSB7XG4gICAgICBlID0gQihcImRpdlwiKSwgZS5pbm5lckhUTUwgPSAnPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInctOCBoLTggdGV4dC1uZXV0cmFsLTMwMCBhbmltYXRlLXNwaW4gZGFyazp0ZXh0LW5ldXRyYWwtNjAwIGZpbGwtbmV1dHJhbC02MDAgZGFyazpmaWxsLW5ldXRyYWwtMzAwXCIgdmlld0JveD1cIjAgMCAxMDAgMTAxXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0xMDAgNTAuNTkwOEMxMDAgNzguMjA1MSA3Ny42MTQyIDEwMC41OTEgNTAgMTAwLjU5MUMyMi4zODU4IDEwMC41OTEgMCA3OC4yMDUxIDAgNTAuNTkwOEMwIDIyLjk3NjYgMjIuMzg1OCAwLjU5MDgyIDUwIDAuNTkwODJDNzcuNjE0MiAwLjU5MDgyIDEwMCAyMi45NzY2IDEwMCA1MC41OTA4Wk05LjA4MTQ0IDUwLjU5MDhDOS4wODE0NCA3My4xODk1IDI3LjQwMTMgOTEuNTA5NCA1MCA5MS41MDk0QzcyLjU5ODcgOTEuNTA5NCA5MC45MTg2IDczLjE4OTUgOTAuOTE4NiA1MC41OTA4QzkwLjkxODYgMjcuOTkyMSA3Mi41OTg3IDkuNjcyMjYgNTAgOS42NzIyNkMyNy40MDEzIDkuNjcyMjYgOS4wODE0NCAyNy45OTIxIDkuMDgxNDQgNTAuNTkwOFpcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+PC9wYXRoPjxwYXRoIGQ9XCJNOTMuOTY3NiAzOS4wNDA5Qzk2LjM5MyAzOC40MDM4IDk3Ljg2MjQgMzUuOTExNiA5Ny4wMDc5IDMzLjU1MzlDOTUuMjkzMiAyOC44MjI3IDkyLjg3MSAyNC4zNjkyIDg5LjgxNjcgMjAuMzQ4Qzg1Ljg0NTIgMTUuMTE5MiA4MC44ODI2IDEwLjcyMzggNzUuMjEyNCA3LjQxMjg5QzY5LjU0MjIgNC4xMDE5NCA2My4yNzU0IDEuOTQwMjUgNTYuNzY5OCAxLjA1MTI0QzUxLjc2NjYgMC4zNjc1NDEgNDYuNjk3NiAwLjQ0Njg0MyA0MS43MzQ1IDEuMjc4NzNDMzkuMjYxMyAxLjY5MzI4IDM3LjgxMyA0LjE5Nzc4IDM4LjQ1MDEgNi42MjMyNkMzOS4wODczIDkuMDQ4NzQgNDEuNTY5NCAxMC40NzE3IDQ0LjA1MDUgMTAuMTA3MUM0Ny44NTExIDkuNTQ4NTUgNTEuNzE5MSA5LjUyNjg5IDU1LjU0MDIgMTAuMDQ5MUM2MC44NjQyIDEwLjc3NjYgNjUuOTkyOCAxMi41NDU3IDcwLjYzMzEgMTUuMjU1MkM3NS4yNzM1IDE3Ljk2NDggNzkuMzM0NyAyMS41NjE5IDgyLjU4NDkgMjUuODQxQzg0LjkxNzUgMjguOTEyMSA4Ni43OTk3IDMyLjI5MTMgODguMTgxMSAzNS44NzU4Qzg5LjA4MyAzOC4yMTU4IDkxLjU0MjEgMzkuNjc4MSA5My45Njc2IDM5LjA0MDlaXCIgZmlsbD1cImN1cnJlbnRGaWxsXCI+PC9wYXRoPjwvc3ZnPiA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIj5Mb2FkaW5nLi4uPC9zcGFuPicsIHAoZSwgXCJyb2xlXCIsIFwic3RhdHVzXCIpO1xuICAgIH0sXG4gICAgbShyLCBuKSB7XG4gICAgICBXKHIsIGUsIG4pO1xuICAgIH0sXG4gICAgcDogUixcbiAgICBkKHIpIHtcbiAgICAgIHIgJiYgRShlKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBOdCh0KSB7XG4gIGxldCBlO1xuICBmdW5jdGlvbiByKHMsIGQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgc1swXS5kb3dubG9hZCA/IEZ0IDogQnRcbiAgICApO1xuICB9XG4gIGxldCBuID0gcih0KSwgbyA9IG4odCk7XG4gIHJldHVybiB7XG4gICAgYygpIHtcbiAgICAgIG8uYygpLCBlID0geGUoKTtcbiAgICB9LFxuICAgIG0ocywgZCkge1xuICAgICAgby5tKHMsIGQpLCBXKHMsIGUsIGQpO1xuICAgIH0sXG4gICAgcChzLCBbZF0pIHtcbiAgICAgIG4gPT09IChuID0gcihzKSkgJiYgbyA/IG8ucChzLCBkKSA6IChvLmQoMSksIG8gPSBuKHMpLCBvICYmIChvLmMoKSwgby5tKGUucGFyZW50Tm9kZSwgZSkpKTtcbiAgICB9LFxuICAgIGk6IFIsXG4gICAgbzogUixcbiAgICBkKHMpIHtcbiAgICAgIHMgJiYgRShlKSwgby5kKHMpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIEV0KHQsIGUsIHIpIHtcbiAgbGV0IHsgd2FsbGV0OiBuIH0gPSBlLCB7IHRoZW1lOiBvID0gbnVsbCB9ID0gZSwgeyBjYjogcyA9IGFzeW5jICgpID0+IHtcbiAgfSB9ID0gZSwgeyBsb2FkaW5nSXRlbTogZCA9ICExIH0gPSBlO1xuICBjb25zdCBoID0gdHlwZW9mIG4uaWNvbiA9PSBcInN0cmluZ1wiID8gbi5pY29uIDogbyA9PT0gXCJkYXJrXCIgPyBuLmljb24uZGFyayA6IG4uaWNvbi5saWdodCwgdyA9IGg/LnN0YXJ0c1dpdGgoXCI8c3ZnXCIpLCBsID0gKCkgPT4ge1xuICAgIHMobnVsbCk7XG4gIH0sIGEgPSAoZikgPT4ge1xuICAgIGYua2V5ID09PSBcIkVudGVyXCIgJiYgcyhudWxsKTtcbiAgfSwgZyA9IGFzeW5jICgpID0+IHtcbiAgICBzKG4uY29ubmVjdG9yKTtcbiAgfSwgeSA9IGFzeW5jIChmKSA9PiB7XG4gICAgZi5rZXkgPT09IFwiRW50ZXJcIiAmJiBzKG4uY29ubmVjdG9yKTtcbiAgfTtcbiAgcmV0dXJuIHQuJCRzZXQgPSAoZikgPT4ge1xuICAgIFwid2FsbGV0XCIgaW4gZiAmJiByKDAsIG4gPSBmLndhbGxldCksIFwidGhlbWVcIiBpbiBmICYmIHIoNSwgbyA9IGYudGhlbWUpLCBcImNiXCIgaW4gZiAmJiByKDEsIHMgPSBmLmNiKSwgXCJsb2FkaW5nSXRlbVwiIGluIGYgJiYgcigyLCBkID0gZi5sb2FkaW5nSXRlbSk7XG4gIH0sIFtcbiAgICBuLFxuICAgIHMsXG4gICAgZCxcbiAgICBoLFxuICAgIHcsXG4gICAgbyxcbiAgICBsLFxuICAgIGEsXG4gICAgZyxcbiAgICB5XG4gIF07XG59XG5jbGFzcyBQdCBleHRlbmRzIE5lIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIE9lKHRoaXMsIGUsIEV0LCBOdCwga2UsIHtcbiAgICAgIHdhbGxldDogMCxcbiAgICAgIHRoZW1lOiA1LFxuICAgICAgY2I6IDEsXG4gICAgICBsb2FkaW5nSXRlbTogMlxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiB3ZSh0LCBlLCByKSB7XG4gIGNvbnN0IG4gPSB0LnNsaWNlKCk7XG4gIHJldHVybiBuWzE2XSA9IGVbcl0sIG47XG59XG5mdW5jdGlvbiBnZSh0KSB7XG4gIGxldCBlLCByLCBuLCBvLCBzLCBkLCBoLCB3LCBsLCBhLCBnLCB5LCBmLCBiLCB4LCBtID0gZmUoXG4gICAgLyptb2RhbFdhbGxldHMqL1xuICAgIHRbMV1cbiAgKSwgYyA9IFtdO1xuICBmb3IgKGxldCB1ID0gMDsgdSA8IG0ubGVuZ3RoOyB1ICs9IDEpXG4gICAgY1t1XSA9IGhlKHdlKHQsIG0sIHUpKTtcbiAgY29uc3QgdiA9ICh1KSA9PiBIKGNbdV0sIDEsIDEsICgpID0+IHtcbiAgICBjW3VdID0gbnVsbDtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYygpIHtcbiAgICAgIGUgPSBCKFwiZGl2XCIpLCByID0gQihcIm1haW5cIiksIG4gPSBCKFwiaGVhZGVyXCIpLCBvID0gQihcImgyXCIpLCBvLnRleHRDb250ZW50ID0gXCJDb25uZWN0IHRvXCIsIHMgPSB6KCksIGQgPSBCKFwiaDFcIiksIGggPSBJKFxuICAgICAgICAvKmRhcHBOYW1lKi9cbiAgICAgICAgdFswXVxuICAgICAgKSwgdyA9IHooKSwgbCA9IEIoXCJzcGFuXCIpLCBsLmlubmVySFRNTCA9ICc8c3ZnIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCIxMlwiIHZpZXdCb3g9XCIwIDAgMTIgMTJcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTkuNzcyNzUgMy4wMjI3NUM5Ljk5MjQyIDIuODAzMDggOS45OTI0MiAyLjQ0NjkyIDkuNzcyNzUgMi4yMjcyNUM5LjU1MzA4IDIuMDA3NTggOS4xOTY5MiAyLjAwNzU4IDguOTc3MjUgMi4yMjcyNUw2IDUuMjA0NTFMMy4wMjI3NSAyLjIyNzI1QzIuODAzMDggMi4wMDc1OCAyLjQ0NjkyIDIuMDA3NTggMi4yMjcyNSAyLjIyNzI1QzIuMDA3NTggMi40NDY5MiAyLjAwNzU4IDIuODAzMDggMi4yMjcyNSAzLjAyMjc1TDUuMjA0NTEgNkwyLjIyNzI1IDguOTc3MjVDMi4wMDc1OCA5LjE5NjkyIDIuMDA3NTggOS41NTMwOCAyLjIyNzI1IDkuNzcyNzVDMi40NDY5MiA5Ljk5MjQyIDIuODAzMDggOS45OTI0MiAzLjAyMjc1IDkuNzcyNzVMNiA2Ljc5NTQ5TDguOTc3MjUgOS43NzI3NUM5LjE5NjkyIDkuOTkyNDIgOS41NTMwOCA5Ljk5MjQyIDkuNzcyNzUgOS43NzI3NUM5Ljk5MjQyIDkuNTUzMDggOS45OTI0MiA5LjE5NjkyIDkuNzcyNzUgOC45NzcyNUw2Ljc5NTQ5IDZMOS43NzI3NSAzLjAyMjc1WlwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj48L3BhdGg+PC9zdmc+JywgYSA9IHooKSwgZyA9IEIoXCJ1bFwiKTtcbiAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgYy5sZW5ndGg7IHUgKz0gMSlcbiAgICAgICAgY1t1XS5jKCk7XG4gICAgICBwKG8sIFwiY2xhc3NcIiwgXCJ0ZXh0LXNtIHRleHQtZ3JheS00MDAgZm9udC1zZW1pYm9sZFwiKSwgcChkLCBcImNsYXNzXCIsIGB0ZXh0LXhsIGZvbnQtc2VtaWJvbGQgbWItNiBcbiAgICAgICAgICAgICAgICAgIG1heC13LVsyNDBweF0gb3ZlcmZsb3ctaGlkZGVuIFxuICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZS1ub3dyYXAgdGV4dC1lbGxpcHNpc2ApLCBwKGwsIFwiY2xhc3NcIiwgYGFic29sdXRlIHRvcC0wIHJpZ2h0LTAgcC0yIGN1cnNvci1wb2ludGVyXG4gICAgICAgICAgICAgICAgICByb3VuZGVkLWZ1bGwgYmctbmV1dHJhbC0xMDAgZGFyazpiZy1uZXV0cmFsLTgwMFxuICAgICAgICAgICAgICAgICAgdGV4dC1uZXV0cmFsLTQwMCBkYXJrOnRleHQtd2hpdGVcbiAgICAgICAgICAgICAgICAgIGhvdmVyOmJnLW5ldXRyYWwtMTAwIGRhcms6aG92ZXI6YmctbmV1dHJhbC03MDBcbiAgICAgICAgICAgICAgICAgIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTJcbiAgICAgICAgICAgICAgICBmb2N1czpyaW5nLW5ldXRyYWwtMjAwIGRhcms6Zm9jdXM6cmluZy1uZXV0cmFsLTcwMFxuICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbi1jb2xvcnNgKSwgcChsLCBcInJvbGVcIiwgXCJidXR0b25cIiksIHAobCwgXCJ0YWJpbmRleFwiLCBcIjBcIiksIHAobCwgXCJhcmlhLWxhYmVsXCIsIFwiQ2xvc2VcIiksIHAobiwgXCJjbGFzc1wiLCBcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGZsZXgtY29sIG1iLTIgcmVsYXRpdmVcIiksIHAoZywgXCJjbGFzc1wiLCBcImZsZXggZmxleC1jb2wgZ2FwLTNcIiksIHAociwgXCJyb2xlXCIsIFwiZGlhbG9nXCIpLCBwKHIsIFwiY2xhc3NcIiwgYHJvdW5kZWQtM3hsIHNoYWRvdy1tb2RhbCBkYXJrOnNoYWRvdy1ub25lIFxuICAgICAgICAgICAgICB3LWZ1bGwgbWF4LXctWzM4MHB4XSB6LTUwIFxuICAgICAgICAgICAgICBteC02IHAtNiBwYi04IHRleHQtY2VudGVyIFxuICAgICAgICAgICAgICBiZy1zbGF0ZS01MCBkYXJrOmJnLW5ldXRyYWwtOTAwIFxuICAgICAgICAgICAgdGV4dC1uZXV0cmFsLTkwMCBkYXJrOnRleHQtd2hpdGVgKSwgcChlLCBcInBhcnRcIiwgXCJzdGFya25ldGtpdC1tb2RhbFwiKSwgcChlLCBcImNsYXNzXCIsIHkgPSBgbW9kYWwtZm9udCBiYWNrZHJvcC1ibHVyLXNtIGZpeGVkIGluc2V0LTAgZmxleCBpdGVtcy1jZW50ZXIgXG4gICAgICAgICAgICBqdXN0aWZ5LWNlbnRlciBiZy1ibGFjay8yNSB6LVs5OTk5XSAkey8qZGFya01vZGVDb250cm9sQ2xhc3MqL1xuICAgICAgdFs0XX1gKTtcbiAgICB9LFxuICAgIG0odSwgQykge1xuICAgICAgVyh1LCBlLCBDKSwgXyhlLCByKSwgXyhyLCBuKSwgXyhuLCBvKSwgXyhuLCBzKSwgXyhuLCBkKSwgXyhkLCBoKSwgXyhuLCB3KSwgXyhuLCBsKSwgXyhyLCBhKSwgXyhyLCBnKTtcbiAgICAgIGZvciAobGV0IFMgPSAwOyBTIDwgYy5sZW5ndGg7IFMgKz0gMSlcbiAgICAgICAgY1tTXSAmJiBjW1NdLm0oZywgbnVsbCk7XG4gICAgICBmID0gITAsIGIgfHwgKHggPSBbXG4gICAgICAgIE8oXG4gICAgICAgICAgbCxcbiAgICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgICAgLypjbGlja19oYW5kbGVyKi9cbiAgICAgICAgICB0WzhdXG4gICAgICAgICksXG4gICAgICAgIE8oXG4gICAgICAgICAgbCxcbiAgICAgICAgICBcImtleXVwXCIsXG4gICAgICAgICAgLyprZXl1cF9oYW5kbGVyKi9cbiAgICAgICAgICB0WzldXG4gICAgICAgICksXG4gICAgICAgIE8ociwgXCJjbGlja1wiLCBMdCksXG4gICAgICAgIE8ociwgXCJrZXl1cFwiLCBqdCksXG4gICAgICAgIE8oXG4gICAgICAgICAgZSxcbiAgICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgICAgLypjbGlja19oYW5kbGVyXzIqL1xuICAgICAgICAgIHRbMTBdXG4gICAgICAgICksXG4gICAgICAgIE8oXG4gICAgICAgICAgZSxcbiAgICAgICAgICBcImtleXVwXCIsXG4gICAgICAgICAgLyprZXl1cF9oYW5kbGVyXzIqL1xuICAgICAgICAgIHRbMTFdXG4gICAgICAgIClcbiAgICAgIF0sIGIgPSAhMCk7XG4gICAgfSxcbiAgICBwKHUsIEMpIHtcbiAgICAgIGlmICgoIWYgfHwgQyAmIC8qZGFwcE5hbWUqL1xuICAgICAgMSkgJiYgJChcbiAgICAgICAgaCxcbiAgICAgICAgLypkYXBwTmFtZSovXG4gICAgICAgIHVbMF1cbiAgICAgICksIEMgJiAvKm1vZGFsV2FsbGV0cywgbG9hZGluZ0l0ZW0sIGNiLCB0aGVtZSovXG4gICAgICA3OCkge1xuICAgICAgICBtID0gZmUoXG4gICAgICAgICAgLyptb2RhbFdhbGxldHMqL1xuICAgICAgICAgIHVbMV1cbiAgICAgICAgKTtcbiAgICAgICAgbGV0IFM7XG4gICAgICAgIGZvciAoUyA9IDA7IFMgPCBtLmxlbmd0aDsgUyArPSAxKSB7XG4gICAgICAgICAgY29uc3Qgb2UgPSB3ZSh1LCBtLCBTKTtcbiAgICAgICAgICBjW1NdID8gKGNbU10ucChvZSwgQyksIEwoY1tTXSwgMSkpIDogKGNbU10gPSBoZShvZSksIGNbU10uYygpLCBMKGNbU10sIDEpLCBjW1NdLm0oZywgbnVsbCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoQmUoKSwgUyA9IG0ubGVuZ3RoOyBTIDwgYy5sZW5ndGg7IFMgKz0gMSlcbiAgICAgICAgICB2KFMpO1xuICAgICAgICBGZSgpO1xuICAgICAgfVxuICAgICAgKCFmIHx8IEMgJiAvKmRhcmtNb2RlQ29udHJvbENsYXNzKi9cbiAgICAgIDE2ICYmIHkgIT09ICh5ID0gYG1vZGFsLWZvbnQgYmFja2Ryb3AtYmx1ci1zbSBmaXhlZCBpbnNldC0wIGZsZXggaXRlbXMtY2VudGVyIFxuICAgICAgICAgICAganVzdGlmeS1jZW50ZXIgYmctYmxhY2svMjUgei1bOTk5OV0gJHsvKmRhcmtNb2RlQ29udHJvbENsYXNzKi9cbiAgICAgIHVbNF19YCkpICYmIHAoZSwgXCJjbGFzc1wiLCB5KTtcbiAgICB9LFxuICAgIGkodSkge1xuICAgICAgaWYgKCFmKSB7XG4gICAgICAgIGZvciAobGV0IEMgPSAwOyBDIDwgbS5sZW5ndGg7IEMgKz0gMSlcbiAgICAgICAgICBMKGNbQ10pO1xuICAgICAgICBmID0gITA7XG4gICAgICB9XG4gICAgfSxcbiAgICBvKHUpIHtcbiAgICAgIGMgPSBjLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIGZvciAobGV0IEMgPSAwOyBDIDwgYy5sZW5ndGg7IEMgKz0gMSlcbiAgICAgICAgSChjW0NdKTtcbiAgICAgIGYgPSAhMTtcbiAgICB9LFxuICAgIGQodSkge1xuICAgICAgdSAmJiBFKGUpLCBodChjLCB1KSwgYiA9ICExLCBqKHgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGhlKHQpIHtcbiAgbGV0IGUsIHI7XG4gIHJldHVybiBlID0gbmV3IFB0KHtcbiAgICBwcm9wczoge1xuICAgICAgd2FsbGV0OiAoXG4gICAgICAgIC8qd2FsbGV0Ki9cbiAgICAgICAgdFsxNl1cbiAgICAgICksXG4gICAgICBsb2FkaW5nSXRlbTogKFxuICAgICAgICAvKmxvYWRpbmdJdGVtKi9cbiAgICAgICAgdFszXVxuICAgICAgKSxcbiAgICAgIGNiOiAoXG4gICAgICAgIC8qY2IqL1xuICAgICAgICB0WzZdXG4gICAgICApLFxuICAgICAgdGhlbWU6IChcbiAgICAgICAgLyp0aGVtZSovXG4gICAgICAgIHRbMl1cbiAgICAgIClcbiAgICB9XG4gIH0pLCB7XG4gICAgYygpIHtcbiAgICAgIHh0KGUuJCQuZnJhZ21lbnQpO1xuICAgIH0sXG4gICAgbShuLCBvKSB7XG4gICAgICBDZShlLCBuLCBvKSwgciA9ICEwO1xuICAgIH0sXG4gICAgcChuLCBvKSB7XG4gICAgICBjb25zdCBzID0ge307XG4gICAgICBvICYgLyptb2RhbFdhbGxldHMqL1xuICAgICAgMiAmJiAocy53YWxsZXQgPSAvKndhbGxldCovXG4gICAgICBuWzE2XSksIG8gJiAvKmxvYWRpbmdJdGVtKi9cbiAgICAgIDggJiYgKHMubG9hZGluZ0l0ZW0gPSAvKmxvYWRpbmdJdGVtKi9cbiAgICAgIG5bM10pLCBvICYgLyp0aGVtZSovXG4gICAgICA0ICYmIChzLnRoZW1lID0gLyp0aGVtZSovXG4gICAgICBuWzJdKSwgZS4kc2V0KHMpO1xuICAgIH0sXG4gICAgaShuKSB7XG4gICAgICByIHx8IChMKGUuJCQuZnJhZ21lbnQsIG4pLCByID0gITApO1xuICAgIH0sXG4gICAgbyhuKSB7XG4gICAgICBIKGUuJCQuZnJhZ21lbnQsIG4pLCByID0gITE7XG4gICAgfSxcbiAgICBkKG4pIHtcbiAgICAgIEFlKGUsIG4pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHp0KHQpIHtcbiAgbGV0IGUsIHIsIG4gPSAhLyppc0luQXBwQnJvd3NlciovXG4gIHRbNV0gJiYgLyptb2RhbFdhbGxldHMqL1xuICB0WzFdLmxlbmd0aCA+IDEgJiYgZ2UodCk7XG4gIHJldHVybiB7XG4gICAgYygpIHtcbiAgICAgIG4gJiYgbi5jKCksIGUgPSB4ZSgpO1xuICAgIH0sXG4gICAgbShvLCBzKSB7XG4gICAgICBuICYmIG4ubShvLCBzKSwgVyhvLCBlLCBzKSwgciA9ICEwO1xuICAgIH0sXG4gICAgcChvLCBbc10pIHtcbiAgICAgICEvKmlzSW5BcHBCcm93c2VyKi9cbiAgICAgIG9bNV0gJiYgLyptb2RhbFdhbGxldHMqL1xuICAgICAgb1sxXS5sZW5ndGggPiAxID8gbiA/IChuLnAobywgcyksIHMgJiAvKm1vZGFsV2FsbGV0cyovXG4gICAgICAyICYmIEwobiwgMSkpIDogKG4gPSBnZShvKSwgbi5jKCksIEwobiwgMSksIG4ubShlLnBhcmVudE5vZGUsIGUpKSA6IG4gJiYgKEJlKCksIEgobiwgMSwgMSwgKCkgPT4ge1xuICAgICAgICBuID0gbnVsbDtcbiAgICAgIH0pLCBGZSgpKTtcbiAgICB9LFxuICAgIGkobykge1xuICAgICAgciB8fCAoTChuKSwgciA9ICEwKTtcbiAgICB9LFxuICAgIG8obykge1xuICAgICAgSChuKSwgciA9ICExO1xuICAgIH0sXG4gICAgZChvKSB7XG4gICAgICBvICYmIEUoZSksIG4gJiYgbi5kKG8pO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEx0ID0gKHQpID0+IHQuc3RvcFByb3BhZ2F0aW9uKCksIGp0ID0gKHQpID0+IHtcbiAgdC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5mdW5jdGlvbiBXdCh0LCBlLCByKSB7XG4gIGxldCB7IGRhcHBOYW1lOiBuID0gd2luZG93Py5kb2N1bWVudC50aXRsZSA/PyBcIlwiIH0gPSBlLCB7IG1vZGFsV2FsbGV0czogbyB9ID0gZSwgeyBjYWxsYmFjazogcyA9IGFzeW5jICgpID0+IHtcbiAgfSB9ID0gZSwgeyB0aGVtZTogZCA9IG51bGwgfSA9IGUsIGggPSAhMSwgbCA9IHdpbmRvdz8uc3RhcmtuZXRfYXJnZW50WD8uaXNJbkFwcEJyb3dzZXI7XG4gIGNvbnN0IGcgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJicmFhdm9zXCIpLCB5ID0gKHUpID0+IHtcbiAgICByKDMsIGggPSB1KTtcbiAgfTtcbiAgbGV0IGYgPSBhc3luYyAodSkgPT4ge1xuICAgIHkodT8uaWQgPz8gITEpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzKHUgPz8gbnVsbCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHkoITEpO1xuICAgIH1cbiAgfSwgYiA9IGQgPT09IFwiZGFya1wiID8gXCJkYXJrXCIgOiBcIlwiO1xuICBtdChhc3luYyAoKSA9PiB7XG4gICAgaWYgKGQgPT09IFwiZGFya1wiIHx8IGQgPT09IG51bGwgJiYgd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIpLm1hdGNoZXMgPyByKDQsIGIgPSBcImRhcmtcIikgOiByKDQsIGIgPSBcIlwiKSwgbCAmJiB3aW5kb3c/LnN0YXJrbmV0X2FyZ2VudFgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHMobmV3IEEoeyBvcHRpb25zOiB7IGlkOiBcImFyZ2VudFhcIiB9IH0pKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZyAmJiB3aW5kb3c/LnN0YXJrbmV0X2JyYWF2b3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHMobmV3IEEoeyBvcHRpb25zOiB7IGlkOiBcImJyYWF2b3NcIiB9IH0pKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoby5sZW5ndGggPT09IDEpXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBbdV0gPSBvO1xuICAgICAgICBhd2FpdCBzKHUuY29ubmVjdG9yKTtcbiAgICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcih1KTtcbiAgICAgIH1cbiAgfSk7XG4gIGNvbnN0IHggPSAoKSA9PiBmKG51bGwpLCBtID0gKHUpID0+IHtcbiAgICB1LmtleSA9PT0gXCJFbnRlclwiICYmIGYobnVsbCk7XG4gIH0sIGMgPSAoKSA9PiBmKG51bGwpLCB2ID0gKHUpID0+IHtcbiAgICB1LmtleSA9PT0gXCJFc2NhcGVcIiAmJiBmKG51bGwpO1xuICB9O1xuICByZXR1cm4gdC4kJHNldCA9ICh1KSA9PiB7XG4gICAgXCJkYXBwTmFtZVwiIGluIHUgJiYgcigwLCBuID0gdS5kYXBwTmFtZSksIFwibW9kYWxXYWxsZXRzXCIgaW4gdSAmJiByKDEsIG8gPSB1Lm1vZGFsV2FsbGV0cyksIFwiY2FsbGJhY2tcIiBpbiB1ICYmIHIoNywgcyA9IHUuY2FsbGJhY2spLCBcInRoZW1lXCIgaW4gdSAmJiByKDIsIGQgPSB1LnRoZW1lKTtcbiAgfSwgW1xuICAgIG4sXG4gICAgbyxcbiAgICBkLFxuICAgIGgsXG4gICAgYixcbiAgICBsLFxuICAgIGYsXG4gICAgcyxcbiAgICB4LFxuICAgIG0sXG4gICAgYyxcbiAgICB2XG4gIF07XG59XG5jbGFzcyBUdCBleHRlbmRzIE5lIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIE9lKHRoaXMsIGUsIFd0LCB6dCwga2UsIHtcbiAgICAgIGRhcHBOYW1lOiAwLFxuICAgICAgbW9kYWxXYWxsZXRzOiAxLFxuICAgICAgY2FsbGJhY2s6IDcsXG4gICAgICB0aGVtZTogMlxuICAgIH0pO1xuICB9XG59XG5jb25zdCBSdCA9IGBAaW1wb3J0XCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/ZmFtaWx5PUJhcmxvdzp3Z2h0QDUwMDs2MDAmZGlzcGxheT1zd2FwXCI7LnNyLW9ubHl7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MXB4O2hlaWdodDoxcHg7cGFkZGluZzowO21hcmdpbjotMXB4O292ZXJmbG93OmhpZGRlbjtjbGlwOnJlY3QoMCwwLDAsMCk7d2hpdGUtc3BhY2U6bm93cmFwO2JvcmRlci13aWR0aDowfS52aXNpYmxle3Zpc2liaWxpdHk6dmlzaWJsZX0uc3RhdGlje3Bvc2l0aW9uOnN0YXRpY30uZml4ZWR7cG9zaXRpb246Zml4ZWR9LmFic29sdXRle3Bvc2l0aW9uOmFic29sdXRlfS5yZWxhdGl2ZXtwb3NpdGlvbjpyZWxhdGl2ZX0uaW5zZXQtMHtpbnNldDowfS5yaWdodC0we3JpZ2h0OjB9LnRvcC0we3RvcDowfS56LTUwe3otaW5kZXg6NTB9LnotXFxcXFs5OTk5XFxcXF17ei1pbmRleDo5OTk5fS5teC02e21hcmdpbi1sZWZ0OjEuNXJlbTttYXJnaW4tcmlnaHQ6MS41cmVtfS5tYi0ye21hcmdpbi1ib3R0b206LjVyZW19Lm1iLTZ7bWFyZ2luLWJvdHRvbToxLjVyZW19LmJsb2Nre2Rpc3BsYXk6YmxvY2t9LmlubGluZXtkaXNwbGF5OmlubGluZX0uZmxleHtkaXNwbGF5OmZsZXh9LmgtOHtoZWlnaHQ6MnJlbX0udy04e3dpZHRoOjJyZW19LnctZnVsbHt3aWR0aDoxMDAlfS5tYXgtdy1cXFxcWzI0MHB4XFxcXF17bWF4LXdpZHRoOjI0MHB4fS5tYXgtdy1cXFxcWzM4MHB4XFxcXF17bWF4LXdpZHRoOjM4MHB4fS50cmFuc2Zvcm17dHJhbnNmb3JtOnRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tldyh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSl9QGtleWZyYW1lcyBzcGlue3Rve3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19LmFuaW1hdGUtc3BpbnthbmltYXRpb246c3BpbiAxcyBsaW5lYXIgaW5maW5pdGV9LmN1cnNvci1wb2ludGVye2N1cnNvcjpwb2ludGVyfS5mbGV4LXJvdy1yZXZlcnNle2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfS5mbGV4LWNvbHtmbGV4LWRpcmVjdGlvbjpjb2x1bW59Lml0ZW1zLWNlbnRlcnthbGlnbi1pdGVtczpjZW50ZXJ9Lmp1c3RpZnktY2VudGVye2p1c3RpZnktY29udGVudDpjZW50ZXJ9Lmp1c3RpZnktYmV0d2VlbntqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn0uZ2FwLTN7Z2FwOi43NXJlbX0ub3ZlcmZsb3ctaGlkZGVue292ZXJmbG93OmhpZGRlbn0udGV4dC1lbGxpcHNpc3t0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS53aGl0ZXNwYWNlLW5vd3JhcHt3aGl0ZS1zcGFjZTpub3dyYXB9LnJvdW5kZWR7Ym9yZGVyLXJhZGl1czouMjVyZW19LnJvdW5kZWQtM3hse2JvcmRlci1yYWRpdXM6MS41cmVtfS5yb3VuZGVkLWZ1bGx7Ym9yZGVyLXJhZGl1czo5OTk5cHh9LnJvdW5kZWQtbWR7Ym9yZGVyLXJhZGl1czouMzc1cmVtfS5ib3JkZXJ7Ym9yZGVyLXdpZHRoOjFweH0uYmctYmxhY2tcXFxcLzI1e2JhY2tncm91bmQtY29sb3I6IzAwMDAwMDQwfS5iZy1uZXV0cmFsLTEwMHstLXR3LWJnLW9wYWNpdHk6IDE7YmFja2dyb3VuZC1jb2xvcjpyZ2IoMjQ1IDI0NSAyNDUgLyB2YXIoLS10dy1iZy1vcGFjaXR5LCAxKSl9LmJnLXNsYXRlLTUwey0tdHctYmctb3BhY2l0eTogMTtiYWNrZ3JvdW5kLWNvbG9yOnJnYigyNDggMjUwIDI1MiAvIHZhcigtLXR3LWJnLW9wYWNpdHksIDEpKX0uZmlsbC1uZXV0cmFsLTYwMHtmaWxsOiM1MjUyNTJ9LnAtMntwYWRkaW5nOi41cmVtfS5wLTN7cGFkZGluZzouNzVyZW19LnAtNntwYWRkaW5nOjEuNXJlbX0ucGItOHtwYWRkaW5nLWJvdHRvbToycmVtfS50ZXh0LWNlbnRlcnt0ZXh0LWFsaWduOmNlbnRlcn0udGV4dC1iYXNle2ZvbnQtc2l6ZToxcmVtO2xpbmUtaGVpZ2h0OjEuNXJlbX0udGV4dC1zbXtmb250LXNpemU6Ljg3NXJlbTtsaW5lLWhlaWdodDoxLjI1cmVtfS50ZXh0LXhse2ZvbnQtc2l6ZToxLjI1cmVtO2xpbmUtaGVpZ2h0OjEuNzVyZW19LmZvbnQtc2VtaWJvbGR7Zm9udC13ZWlnaHQ6NjAwfS50ZXh0LWdyYXktNDAwey0tdHctdGV4dC1vcGFjaXR5OiAxO2NvbG9yOnJnYigxNTYgMTYzIDE3NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSwgMSkpfS50ZXh0LW5ldXRyYWwtMzAwey0tdHctdGV4dC1vcGFjaXR5OiAxO2NvbG9yOnJnYigyMTIgMjEyIDIxMiAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSwgMSkpfS50ZXh0LW5ldXRyYWwtNDAwey0tdHctdGV4dC1vcGFjaXR5OiAxO2NvbG9yOnJnYigxNjMgMTYzIDE2MyAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSwgMSkpfS50ZXh0LW5ldXRyYWwtOTAwey0tdHctdGV4dC1vcGFjaXR5OiAxO2NvbG9yOnJnYigyMyAyMyAyMyAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSwgMSkpfS5zaGFkb3ctbGlzdC1pdGVtey0tdHctc2hhZG93OiAwcHggMnB4IDEycHggcmdiYSgwLCAwLCAwLCAuMTIpOy0tdHctc2hhZG93LWNvbG9yZWQ6IDBweCAycHggMTJweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpO2JveC1zaGFkb3c6dmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLHZhcigtLXR3LXNoYWRvdyl9LnNoYWRvdy1tb2RhbHstLXR3LXNoYWRvdzogMHB4IDRweCAyMHB4IHJnYmEoMCwgMCwgMCwgLjUpOy0tdHctc2hhZG93LWNvbG9yZWQ6IDBweCA0cHggMjBweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpO2JveC1zaGFkb3c6dmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLHZhcigtLXR3LXNoYWRvdyl9Lm91dGxpbmV7b3V0bGluZS1zdHlsZTpzb2xpZH0uYmx1cnstLXR3LWJsdXI6IGJsdXIoOHB4KTtmaWx0ZXI6dmFyKC0tdHctYmx1cikgdmFyKC0tdHctYnJpZ2h0bmVzcykgdmFyKC0tdHctY29udHJhc3QpIHZhcigtLXR3LWdyYXlzY2FsZSkgdmFyKC0tdHctaHVlLXJvdGF0ZSkgdmFyKC0tdHctaW52ZXJ0KSB2YXIoLS10dy1zYXR1cmF0ZSkgdmFyKC0tdHctc2VwaWEpIHZhcigtLXR3LWRyb3Atc2hhZG93KX0uZmlsdGVye2ZpbHRlcjp2YXIoLS10dy1ibHVyKSB2YXIoLS10dy1icmlnaHRuZXNzKSB2YXIoLS10dy1jb250cmFzdCkgdmFyKC0tdHctZ3JheXNjYWxlKSB2YXIoLS10dy1odWUtcm90YXRlKSB2YXIoLS10dy1pbnZlcnQpIHZhcigtLXR3LXNhdHVyYXRlKSB2YXIoLS10dy1zZXBpYSkgdmFyKC0tdHctZHJvcC1zaGFkb3cpfS5iYWNrZHJvcC1ibHVyLXNtey0tdHctYmFja2Ryb3AtYmx1cjogYmx1cig0cHgpOy13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOnZhcigtLXR3LWJhY2tkcm9wLWJsdXIpIHZhcigtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3MpIHZhcigtLXR3LWJhY2tkcm9wLWNvbnRyYXN0KSB2YXIoLS10dy1iYWNrZHJvcC1ncmF5c2NhbGUpIHZhcigtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGUpIHZhcigtLXR3LWJhY2tkcm9wLWludmVydCkgdmFyKC0tdHctYmFja2Ryb3Atb3BhY2l0eSkgdmFyKC0tdHctYmFja2Ryb3Atc2F0dXJhdGUpIHZhcigtLXR3LWJhY2tkcm9wLXNlcGlhKTtiYWNrZHJvcC1maWx0ZXI6dmFyKC0tdHctYmFja2Ryb3AtYmx1cikgdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcykgdmFyKC0tdHctYmFja2Ryb3AtY29udHJhc3QpIHZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSkgdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSkgdmFyKC0tdHctYmFja2Ryb3AtaW52ZXJ0KSB2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5KSB2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSkgdmFyKC0tdHctYmFja2Ryb3Atc2VwaWEpfS50cmFuc2l0aW9uLWNvbG9yc3t0cmFuc2l0aW9uLXByb3BlcnR5OmNvbG9yLGJhY2tncm91bmQtY29sb3IsYm9yZGVyLWNvbG9yLHRleHQtZGVjb3JhdGlvbi1jb2xvcixmaWxsLHN0cm9rZTt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjQsMCwuMiwxKTt0cmFuc2l0aW9uLWR1cmF0aW9uOi4xNXN9Kiw6YmVmb3JlLDphZnRlcnstLXR3LWJvcmRlci1zcGFjaW5nLXg6IDA7LS10dy1ib3JkZXItc3BhY2luZy15OiAwOy0tdHctdHJhbnNsYXRlLXg6IDA7LS10dy10cmFuc2xhdGUteTogMDstLXR3LXJvdGF0ZTogMDstLXR3LXNrZXcteDogMDstLXR3LXNrZXcteTogMDstLXR3LXNjYWxlLXg6IDE7LS10dy1zY2FsZS15OiAxOy0tdHctcGFuLXg6IDstLXR3LXBhbi15OiA7LS10dy1waW5jaC16b29tOiA7LS10dy1zY3JvbGwtc25hcC1zdHJpY3RuZXNzOiBwcm94aW1pdHk7LS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uOiA7LS10dy1ncmFkaWVudC12aWEtcG9zaXRpb246IDstLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uOiA7LS10dy1vcmRpbmFsOiA7LS10dy1zbGFzaGVkLXplcm86IDstLXR3LW51bWVyaWMtZmlndXJlOiA7LS10dy1udW1lcmljLXNwYWNpbmc6IDstLXR3LW51bWVyaWMtZnJhY3Rpb246IDstLXR3LXJpbmctaW5zZXQ6IDstLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAwcHg7LS10dy1yaW5nLW9mZnNldC1jb2xvcjogI2ZmZjstLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gLjUpOy0tdHctcmluZy1vZmZzZXQtc2hhZG93OiAwIDAgIzAwMDA7LS10dy1yaW5nLXNoYWRvdzogMCAwICMwMDAwOy0tdHctc2hhZG93OiAwIDAgIzAwMDA7LS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwOy0tdHctYmx1cjogOy0tdHctYnJpZ2h0bmVzczogOy0tdHctY29udHJhc3Q6IDstLXR3LWdyYXlzY2FsZTogOy0tdHctaHVlLXJvdGF0ZTogOy0tdHctaW52ZXJ0OiA7LS10dy1zYXR1cmF0ZTogOy0tdHctc2VwaWE6IDstLXR3LWRyb3Atc2hhZG93OiA7LS10dy1iYWNrZHJvcC1ibHVyOiA7LS10dy1iYWNrZHJvcC1icmlnaHRuZXNzOiA7LS10dy1iYWNrZHJvcC1jb250cmFzdDogOy0tdHctYmFja2Ryb3AtZ3JheXNjYWxlOiA7LS10dy1iYWNrZHJvcC1odWUtcm90YXRlOiA7LS10dy1iYWNrZHJvcC1pbnZlcnQ6IDstLXR3LWJhY2tkcm9wLW9wYWNpdHk6IDstLXR3LWJhY2tkcm9wLXNhdHVyYXRlOiA7LS10dy1iYWNrZHJvcC1zZXBpYTogOy0tdHctY29udGFpbi1zaXplOiA7LS10dy1jb250YWluLWxheW91dDogOy0tdHctY29udGFpbi1wYWludDogOy0tdHctY29udGFpbi1zdHlsZTogfTo6YmFja2Ryb3B7LS10dy1ib3JkZXItc3BhY2luZy14OiAwOy0tdHctYm9yZGVyLXNwYWNpbmcteTogMDstLXR3LXRyYW5zbGF0ZS14OiAwOy0tdHctdHJhbnNsYXRlLXk6IDA7LS10dy1yb3RhdGU6IDA7LS10dy1za2V3LXg6IDA7LS10dy1za2V3LXk6IDA7LS10dy1zY2FsZS14OiAxOy0tdHctc2NhbGUteTogMTstLXR3LXBhbi14OiA7LS10dy1wYW4teTogOy0tdHctcGluY2gtem9vbTogOy0tdHctc2Nyb2xsLXNuYXAtc3RyaWN0bmVzczogcHJveGltaXR5Oy0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbjogOy0tdHctZ3JhZGllbnQtdmlhLXBvc2l0aW9uOiA7LS10dy1ncmFkaWVudC10by1wb3NpdGlvbjogOy0tdHctb3JkaW5hbDogOy0tdHctc2xhc2hlZC16ZXJvOiA7LS10dy1udW1lcmljLWZpZ3VyZTogOy0tdHctbnVtZXJpYy1zcGFjaW5nOiA7LS10dy1udW1lcmljLWZyYWN0aW9uOiA7LS10dy1yaW5nLWluc2V0OiA7LS10dy1yaW5nLW9mZnNldC13aWR0aDogMHB4Oy0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmZmY7LS10dy1yaW5nLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIC41KTstLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogMCAwICMwMDAwOy0tdHctcmluZy1zaGFkb3c6IDAgMCAjMDAwMDstLXR3LXNoYWRvdzogMCAwICMwMDAwOy0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMCAjMDAwMDstLXR3LWJsdXI6IDstLXR3LWJyaWdodG5lc3M6IDstLXR3LWNvbnRyYXN0OiA7LS10dy1ncmF5c2NhbGU6IDstLXR3LWh1ZS1yb3RhdGU6IDstLXR3LWludmVydDogOy0tdHctc2F0dXJhdGU6IDstLXR3LXNlcGlhOiA7LS10dy1kcm9wLXNoYWRvdzogOy0tdHctYmFja2Ryb3AtYmx1cjogOy0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzczogOy0tdHctYmFja2Ryb3AtY29udHJhc3Q6IDstLXR3LWJhY2tkcm9wLWdyYXlzY2FsZTogOy0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZTogOy0tdHctYmFja2Ryb3AtaW52ZXJ0OiA7LS10dy1iYWNrZHJvcC1vcGFjaXR5OiA7LS10dy1iYWNrZHJvcC1zYXR1cmF0ZTogOy0tdHctYmFja2Ryb3Atc2VwaWE6IDstLXR3LWNvbnRhaW4tc2l6ZTogOy0tdHctY29udGFpbi1sYXlvdXQ6IDstLXR3LWNvbnRhaW4tcGFpbnQ6IDstLXR3LWNvbnRhaW4tc3R5bGU6IH0qLDpiZWZvcmUsOmFmdGVye2JveC1zaXppbmc6Ym9yZGVyLWJveDtib3JkZXItd2lkdGg6MDtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLWNvbG9yOiNlNWU3ZWJ9OmJlZm9yZSw6YWZ0ZXJ7LS10dy1jb250ZW50OiBcIlwifWh0bWwsOmhvc3R7bGluZS1oZWlnaHQ6MS41Oy13ZWJraXQtdGV4dC1zaXplLWFkanVzdDoxMDAlOy1tb3otdGFiLXNpemU6NDstby10YWItc2l6ZTo0O3RhYi1zaXplOjQ7Zm9udC1mYW1pbHk6dWktc2Fucy1zZXJpZixzeXN0ZW0tdWksc2Fucy1zZXJpZixcIkFwcGxlIENvbG9yIEVtb2ppXCIsXCJTZWdvZSBVSSBFbW9qaVwiLFNlZ29lIFVJIFN5bWJvbCxcIk5vdG8gQ29sb3IgRW1vamlcIjtmb250LWZlYXR1cmUtc2V0dGluZ3M6bm9ybWFsO2ZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOm5vcm1hbDstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6dHJhbnNwYXJlbnR9Ym9keXttYXJnaW46MDtsaW5lLWhlaWdodDppbmhlcml0fWhye2hlaWdodDowO2NvbG9yOmluaGVyaXQ7Ym9yZGVyLXRvcC13aWR0aDoxcHh9YWJicjp3aGVyZShbdGl0bGVdKXstd2Via2l0LXRleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmUgZG90dGVkO3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmUgZG90dGVkfWgxLGgyLGgzLGg0LGg1LGg2e2ZvbnQtc2l6ZTppbmhlcml0O2ZvbnQtd2VpZ2h0OmluaGVyaXR9YXtjb2xvcjppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0fWIsc3Ryb25ne2ZvbnQtd2VpZ2h0OmJvbGRlcn1jb2RlLGtiZCxzYW1wLHByZXtmb250LWZhbWlseTp1aS1tb25vc3BhY2UsU0ZNb25vLVJlZ3VsYXIsTWVubG8sTW9uYWNvLENvbnNvbGFzLExpYmVyYXRpb24gTW9ubyxDb3VyaWVyIE5ldyxtb25vc3BhY2U7Zm9udC1mZWF0dXJlLXNldHRpbmdzOm5vcm1hbDtmb250LXZhcmlhdGlvbi1zZXR0aW5nczpub3JtYWw7Zm9udC1zaXplOjFlbX1zbWFsbHtmb250LXNpemU6ODAlfXN1YixzdXB7Zm9udC1zaXplOjc1JTtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXN1Yntib3R0b206LS4yNWVtfXN1cHt0b3A6LS41ZW19dGFibGV7dGV4dC1pbmRlbnQ6MDtib3JkZXItY29sb3I6aW5oZXJpdDtib3JkZXItY29sbGFwc2U6Y29sbGFwc2V9YnV0dG9uLGlucHV0LG9wdGdyb3VwLHNlbGVjdCx0ZXh0YXJlYXtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtZmVhdHVyZS1zZXR0aW5nczppbmhlcml0O2ZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOmluaGVyaXQ7Zm9udC1zaXplOjEwMCU7Zm9udC13ZWlnaHQ6aW5oZXJpdDtsaW5lLWhlaWdodDppbmhlcml0O2xldHRlci1zcGFjaW5nOmluaGVyaXQ7Y29sb3I6aW5oZXJpdDttYXJnaW46MDtwYWRkaW5nOjB9YnV0dG9uLHNlbGVjdHt0ZXh0LXRyYW5zZm9ybTpub25lfWJ1dHRvbixpbnB1dDp3aGVyZShbdHlwZT1idXR0b25dKSxpbnB1dDp3aGVyZShbdHlwZT1yZXNldF0pLGlucHV0OndoZXJlKFt0eXBlPXN1Ym1pdF0pey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b247YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtiYWNrZ3JvdW5kLWltYWdlOm5vbmV9Oi1tb3otZm9jdXNyaW5ne291dGxpbmU6YXV0b306LW1vei11aS1pbnZhbGlke2JveC1zaGFkb3c6bm9uZX1wcm9ncmVzc3t2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZX06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9ue2hlaWdodDphdXRvfVt0eXBlPXNlYXJjaF17LXdlYmtpdC1hcHBlYXJhbmNlOnRleHRmaWVsZDtvdXRsaW5lLW9mZnNldDotMnB4fTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbnstd2Via2l0LWFwcGVhcmFuY2U6bm9uZX06Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b247Zm9udDppbmhlcml0fXN1bW1hcnl7ZGlzcGxheTpsaXN0LWl0ZW19YmxvY2txdW90ZSxkbCxkZCxoMSxoMixoMyxoNCxoNSxoNixocixmaWd1cmUscCxwcmV7bWFyZ2luOjB9ZmllbGRzZXR7bWFyZ2luOjA7cGFkZGluZzowfWxlZ2VuZHtwYWRkaW5nOjB9b2wsdWwsbWVudXtsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowfWRpYWxvZ3twYWRkaW5nOjB9dGV4dGFyZWF7cmVzaXplOnZlcnRpY2FsfWlucHV0OjotbW96LXBsYWNlaG9sZGVyLHRleHRhcmVhOjotbW96LXBsYWNlaG9sZGVye29wYWNpdHk6MTtjb2xvcjojOWNhM2FmfWlucHV0OjpwbGFjZWhvbGRlcix0ZXh0YXJlYTo6cGxhY2Vob2xkZXJ7b3BhY2l0eToxO2NvbG9yOiM5Y2EzYWZ9YnV0dG9uLFtyb2xlPWJ1dHRvbl17Y3Vyc29yOnBvaW50ZXJ9OmRpc2FibGVke2N1cnNvcjpkZWZhdWx0fWltZyxzdmcsdmlkZW8sY2FudmFzLGF1ZGlvLGlmcmFtZSxlbWJlZCxvYmplY3R7ZGlzcGxheTpibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9aW1nLHZpZGVve21heC13aWR0aDoxMDAlO2hlaWdodDphdXRvfVtoaWRkZW5dOndoZXJlKDpub3QoW2hpZGRlbj11bnRpbC1mb3VuZF0pKXtkaXNwbGF5Om5vbmV9Lm1vZGFsLWZvbnR7Zm9udC1mYW1pbHk6QmFybG93LC1hcHBsZS1zeXN0ZW0sQmxpbmtNYWNTeXN0ZW1Gb250LFNlZ29lIFVJLFJvYm90byxPeHlnZW4sVWJ1bnR1LENhbnRhcmVsbCxGaXJhIFNhbnMsRHJvaWQgU2FucyxIZWx2ZXRpY2EgTmV1ZSxzYW5zLXNlcmlmOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7dGV4dC1yZW5kZXJpbmc6b3B0aW1pemVMZWdpYmlsaXR5Oy13ZWJraXQtdGV4dC1zaXplLWFkanVzdDoxMDAlOy1tb3otdGV4dC1zaXplLWFkanVzdDoxMDAlO3RleHQtc2l6ZS1hZGp1c3Q6MTAwJTtmb250LWZlYXR1cmUtc2V0dGluZ3M6XCJrZXJuXCJ9Lmwye2NvbG9yOiM4YzhjOGM7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NTAwO2xpbmUtaGVpZ2h0OjE0cHg7bGV0dGVyLXNwYWNpbmc6MGVtO3RleHQtYWxpZ246bGVmdH0ucHttYXJnaW46MH0uaG92ZXJcXFxcOmJnLW5ldXRyYWwtMTAwOmhvdmVyey0tdHctYmctb3BhY2l0eTogMTtiYWNrZ3JvdW5kLWNvbG9yOnJnYigyNDUgMjQ1IDI0NSAvIHZhcigtLXR3LWJnLW9wYWNpdHksIDEpKX0uZm9jdXNcXFxcOm91dGxpbmUtbm9uZTpmb2N1c3tvdXRsaW5lOjJweCBzb2xpZCB0cmFuc3BhcmVudDtvdXRsaW5lLW9mZnNldDoycHh9LmZvY3VzXFxcXDpyaW5nLTI6Zm9jdXN7LS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQpIDAgMCAwIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSB2YXIoLS10dy1yaW5nLW9mZnNldC1jb2xvcik7LS10dy1yaW5nLXNoYWRvdzogdmFyKC0tdHctcmluZy1pbnNldCkgMCAwIDAgY2FsYygycHggKyB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkpIHZhcigtLXR3LXJpbmctY29sb3IpO2JveC1zaGFkb3c6dmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSx2YXIoLS10dy1yaW5nLXNoYWRvdyksdmFyKC0tdHctc2hhZG93LCAwIDAgIzAwMDApfS5mb2N1c1xcXFw6cmluZy1uZXV0cmFsLTIwMDpmb2N1c3stLXR3LXJpbmctb3BhY2l0eTogMTstLXR3LXJpbmctY29sb3I6IHJnYigyMjkgMjI5IDIyOSAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSwgMSkpfS5kYXJrXFxcXDpiZy1uZXV0cmFsLTgwMDppcyguZGFyayAqKXstLXR3LWJnLW9wYWNpdHk6IDE7YmFja2dyb3VuZC1jb2xvcjpyZ2IoMzggMzggMzggLyB2YXIoLS10dy1iZy1vcGFjaXR5LCAxKSl9LmRhcmtcXFxcOmJnLW5ldXRyYWwtOTAwOmlzKC5kYXJrICopey0tdHctYmctb3BhY2l0eTogMTtiYWNrZ3JvdW5kLWNvbG9yOnJnYigyMyAyMyAyMyAvIHZhcigtLXR3LWJnLW9wYWNpdHksIDEpKX0uZGFya1xcXFw6ZmlsbC1uZXV0cmFsLTMwMDppcyguZGFyayAqKXtmaWxsOiNkNGQ0ZDR9LmRhcmtcXFxcOnRleHQtbmV1dHJhbC02MDA6aXMoLmRhcmsgKil7LS10dy10ZXh0LW9wYWNpdHk6IDE7Y29sb3I6cmdiKDgyIDgyIDgyIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5LCAxKSl9LmRhcmtcXFxcOnRleHQtd2hpdGU6aXMoLmRhcmsgKil7LS10dy10ZXh0LW9wYWNpdHk6IDE7Y29sb3I6cmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5LCAxKSl9LmRhcmtcXFxcOnNoYWRvdy1ub25lOmlzKC5kYXJrICopey0tdHctc2hhZG93OiAwIDAgIzAwMDA7LS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwO2JveC1zaGFkb3c6dmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLHZhcigtLXR3LXNoYWRvdyl9LmRhcmtcXFxcOmhvdmVyXFxcXDpiZy1uZXV0cmFsLTcwMDpob3ZlcjppcyguZGFyayAqKXstLXR3LWJnLW9wYWNpdHk6IDE7YmFja2dyb3VuZC1jb2xvcjpyZ2IoNjQgNjQgNjQgLyB2YXIoLS10dy1iZy1vcGFjaXR5LCAxKSl9LmRhcmtcXFxcOmZvY3VzXFxcXDpyaW5nLW5ldXRyYWwtNzAwOmZvY3VzOmlzKC5kYXJrICopey0tdHctcmluZy1vcGFjaXR5OiAxOy0tdHctcmluZy1jb2xvcjogcmdiKDY0IDY0IDY0IC8gdmFyKC0tdHctcmluZy1vcGFjaXR5LCAxKSl9XG5gLCBLdCA9ICh0KSA9PiAoe1xuICBzdGFya25ldGtpdENvbm5lY3RNb2RhbDogYXN5bmMgKCkgPT4gYXdhaXQgSXQoe1xuICAgIC4uLnQsXG4gICAgcmVzdWx0VHlwZTogdD8ucmVzdWx0VHlwZSA/PyBcImNvbm5lY3RvclwiXG4gIH0pXG59KTtcbmxldCBOID0gbnVsbDtcbmNvbnN0IEl0ID0gYXN5bmMgKHtcbiAgbW9kYWxNb2RlOiB0ID0gXCJjYW5Bc2tcIixcbiAgc3RvcmVWZXJzaW9uOiBlID0gSGUoKSxcbiAgbW9kYWxUaGVtZTogcixcbiAgZGFwcE5hbWU6IG4sXG4gIHJlc3VsdFR5cGU6IG8gPSBcIndhbGxldFwiLFxuICAuLi5zXG59KSA9PiB7XG4gIGNvbnN0IHsgd2ViV2FsbGV0VXJsOiBkID0gamUsIGFyZ2VudE1vYmlsZU9wdGlvbnM6IGggfSA9IHMsIHsgY29ubmVjdG9yczogdyB9ID0gcztcbiAgTiA9IG51bGw7XG4gIGNvbnN0IGwgPSAhdyB8fCB3Lmxlbmd0aCA9PT0gMCA/IEllKHtcbiAgICBhcmdlbnRNb2JpbGVPcHRpb25zOiBoLFxuICAgIHdlYldhbGxldFVybDogZFxuICB9KSA6IHcsIGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN0YXJrbmV0TGFzdENvbm5lY3RlZFdhbGxldFwiKTtcbiAgaWYgKHQgPT09IFwibmV2ZXJBc2tcIilcbiAgICB0cnkge1xuICAgICAgY29uc3QgYiA9IGwuZmluZCgobSkgPT4gbS5pZCA9PT0gYSkgPz8gbnVsbDtcbiAgICAgIGxldCB4ID0gbnVsbDtcbiAgICAgIHJldHVybiBiICYmIG8gPT09IFwid2FsbGV0XCIgJiYgKHggPSBhd2FpdCBiLmNvbm5lY3QoKSksIHtcbiAgICAgICAgY29ubmVjdG9yOiBiLFxuICAgICAgICB3YWxsZXQ6IGI/LndhbGxldCA/PyBudWxsLFxuICAgICAgICBjb25uZWN0b3JEYXRhOiB4XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGIpIHtcbiAgICAgIHRocm93IHBlKCksIG5ldyBFcnJvcihiKTtcbiAgICB9XG4gIGNvbnN0IGcgPSBhd2FpdCBaLmdldEF2YWlsYWJsZVdhbGxldHMocyk7XG4gIGlmICh0ID09PSBcImNhbkFza1wiICYmIGEgJiYgKChhd2FpdCBaLmdldEF1dGhvcml6ZWRXYWxsZXRzKHMpKS5maW5kKChtKSA9PiBtLmlkID09PSBhKSA/PyBnLmxlbmd0aCA9PT0gMSA/IGdbMF0gOiB2b2lkIDApKSB7XG4gICAgY29uc3QgbSA9IGwuZmluZCgodikgPT4gdi5pZCA9PT0gYSk7XG4gICAgbGV0IGMgPSBudWxsO1xuICAgIHJldHVybiBvID09PSBcIndhbGxldFwiICYmIChjID0gYXdhaXQgbT8uY29ubmVjdCgpID8/IG51bGwpLCBtICYmIChOID0gbSksIHtcbiAgICAgIGNvbm5lY3RvcjogTixcbiAgICAgIGNvbm5lY3RvckRhdGE6IGMsXG4gICAgICB3YWxsZXQ6IG0/LndhbGxldCA/PyBudWxsXG4gICAgfTtcbiAgfVxuICBjb25zdCB5ID0gd3Qoe1xuICAgIGF2YWlsYWJsZUNvbm5lY3RvcnM6IGwsXG4gICAgaW5zdGFsbGVkV2FsbGV0czogZyxcbiAgICBkaXNjb3ZlcnlXYWxsZXRzOiBhd2FpdCBaLmdldERpc2NvdmVyeVdhbGxldHMocyksXG4gICAgc3RvcmVWZXJzaW9uOiBlLFxuICAgIGN1c3RvbU9yZGVyOiB3ID8gdz8ubGVuZ3RoID4gMCA6ICExXG4gIH0pLCBmID0gKCkgPT4ge1xuICAgIGNvbnN0IGIgPSBcInN0YXJrbmV0a2l0LW1vZGFsLWNvbnRhaW5lclwiLCB4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7XG4gICAgaWYgKHgpIHtcbiAgICAgIGlmICh4LnNoYWRvd1Jvb3QpXG4gICAgICAgIHJldHVybiB4LnNoYWRvd1Jvb3Q7XG4gICAgICB4LnJlbW92ZSgpO1xuICAgIH1cbiAgICBjb25zdCBtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBtLmlkID0gYiwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtKTtcbiAgICBjb25zdCBjID0gbS5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICByZXR1cm4gYy5pbm5lckhUTUwgPSBgPHN0eWxlPiR7UnR9PC9zdHlsZT5gLCBjO1xuICB9O1xuICByZXR1cm4gbmV3IFByb21pc2UoKGIsIHgpID0+IHtcbiAgICBjb25zdCBtID0gbmV3IFR0KHtcbiAgICAgIHRhcmdldDogZigpLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZGFwcE5hbWU6IG4sXG4gICAgICAgIGNhbGxiYWNrOiBhc3luYyAoYykgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoTiA9IGMsIG8gPT09IFwid2FsbGV0XCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgdiA9IGF3YWl0IGM/LmNvbm5lY3QoKSA/PyBudWxsO1xuICAgICAgICAgICAgICBjICE9PSBudWxsICYmIHplKGMuaWQpLCBiKHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3I6IGMsXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yRGF0YTogdixcbiAgICAgICAgICAgICAgICB3YWxsZXQ6IGM/LndhbGxldCA/PyBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGIoe1xuICAgICAgICAgICAgICAgIGNvbm5lY3RvcjogYyxcbiAgICAgICAgICAgICAgICB3YWxsZXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yRGF0YTogbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoICh2KSB7XG4gICAgICAgICAgICB4KHYpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG0uJGRlc3Ryb3koKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aGVtZTogciA9PT0gXCJzeXN0ZW1cIiA/IG51bGwgOiByID8/IG51bGwsXG4gICAgICAgIG1vZGFsV2FsbGV0czogeVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0sIFl0ID0gKCkgPT4gTiA/IE4ud2FsbGV0IDogbnVsbCwgJHQgPSBhc3luYyAodCA9IHt9KSA9PiAocGUoKSwgTiAmJiBhd2FpdCBOLmRpc2Nvbm5lY3QoKSwgTiA9IG51bGwsIFouZGlzY29ubmVjdCh0KSk7XG5leHBvcnQge1xuICBJdCBhcyBjb25uZWN0LFxuICAkdCBhcyBkaXNjb25uZWN0LFxuICBZdCBhcyBnZXRTZWxlY3RlZENvbm5lY3RvcldhbGxldCxcbiAgS3QgYXMgdXNlU3RhcmtuZXRraXRDb25uZWN0TW9kYWxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/starknetkit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/webwalletConnector.js":
/*!*******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/webwalletConnector.js ***!
  \*******************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectAndSignSessionError: () => (/* reexport safe */ _index_8edbd361_js__WEBPACK_IMPORTED_MODULE_3__.C),\n/* harmony export */   WEBWALLET_LOGOUT_EVENT: () => (/* reexport safe */ _index_8edbd361_js__WEBPACK_IMPORTED_MODULE_3__.a),\n/* harmony export */   WebWalletConnector: () => (/* reexport safe */ _index_8edbd361_js__WEBPACK_IMPORTED_MODULE_3__.W),\n/* harmony export */   WebwalletError: () => (/* reexport safe */ _index_8edbd361_js__WEBPACK_IMPORTED_MODULE_3__.b),\n/* harmony export */   handleWebwalletLogoutEvent: () => (/* reexport safe */ _index_8edbd361_js__WEBPACK_IMPORTED_MODULE_3__.h)\n/* harmony export */ });\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! starknet */ \"(ssr)/./node_modules/.pnpm/starknet@6.24.1_encoding@0.1.13/node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var _lastConnected_e9351912_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lastConnected-e9351912.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/lastConnected-e9351912.js\");\n/* harmony import */ var _getStarknetChainId_7c4b3163_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getStarknetChainId-7c4b3163.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/getStarknetChainId-7c4b3163.js\");\n/* harmony import */ var _index_8edbd361_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index-8edbd361.js */ \"(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/index-8edbd361.js\");\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RhcmtuZXRraXRAMi4xMC40X2J1ZmZlcnV0aWxANC4wLjlfc3RhcmtuZXRANi4yNC4xX2VuY29kaW5nQDAuMS4xM19fdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA2LjAuNV96b2RAMy4yNS41MC9ub2RlX21vZHVsZXMvc3RhcmtuZXRraXQvZGlzdC93ZWJ3YWxsZXRDb25uZWN0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWtCO0FBQ21CO0FBQ0s7QUFDbUM7QUFPM0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdGFya25ldGtpdEAyLjEwLjRfYnVmZmVydXRpbEA0LjAuOV9zdGFya25ldEA2LjI0LjFfZW5jb2RpbmdAMC4xLjEzX190eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDYuMC41X3pvZEAzLjI1LjUwL25vZGVfbW9kdWxlcy9zdGFya25ldGtpdC9kaXN0L3dlYndhbGxldENvbm5lY3Rvci5qcz9kYzFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcInN0YXJrbmV0XCI7XG5pbXBvcnQgXCIuL2xhc3RDb25uZWN0ZWQtZTkzNTE5MTIuanNcIjtcbmltcG9ydCBcIi4vZ2V0U3RhcmtuZXRDaGFpbklkLTdjNGIzMTYzLmpzXCI7XG5pbXBvcnQgeyBDIGFzIG4sIGEgYXMgbCwgVyBhcyBzLCBiIGFzIEUsIGggYXMgVyB9IGZyb20gXCIuL2luZGV4LThlZGJkMzYxLmpzXCI7XG5leHBvcnQge1xuICBuIGFzIENvbm5lY3RBbmRTaWduU2Vzc2lvbkVycm9yLFxuICBsIGFzIFdFQldBTExFVF9MT0dPVVRfRVZFTlQsXG4gIHMgYXMgV2ViV2FsbGV0Q29ubmVjdG9yLFxuICBFIGFzIFdlYndhbGxldEVycm9yLFxuICBXIGFzIGhhbmRsZVdlYndhbGxldExvZ291dEV2ZW50XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/starknetkit@2.10.4_bufferutil@4.0.9_starknet@6.24.1_encoding@0.1.13__typescript@5.8.3_utf-8-validate@6.0.5_zod@3.25.50/node_modules/starknetkit/dist/webwalletConnector.js\n");

/***/ })

};
;