"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@scure+starknet@1.1.0";
exports.ids = ["vendor-chunks/@scure+starknet@1.1.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@scure+starknet@1.1.0/node_modules/@scure/starknet/lib/esm/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@scure+starknet@1.1.0/node_modules/@scure/starknet/lib/esm/index.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   Fp251: () => (/* binding */ Fp251),\n/* harmony export */   MAX_VALUE: () => (/* binding */ MAX_VALUE),\n/* harmony export */   ProjectivePoint: () => (/* binding */ ProjectivePoint),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   _poseidonMDS: () => (/* binding */ _poseidonMDS),\n/* harmony export */   _starkCurve: () => (/* binding */ _starkCurve),\n/* harmony export */   computeHashOnElements: () => (/* binding */ computeHashOnElements),\n/* harmony export */   ethSigToPrivate: () => (/* binding */ ethSigToPrivate),\n/* harmony export */   getAccountPath: () => (/* binding */ getAccountPath),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   getStarkKey: () => (/* binding */ getStarkKey),\n/* harmony export */   grindKey: () => (/* binding */ grindKey),\n/* harmony export */   keccak: () => (/* binding */ keccak),\n/* harmony export */   normalizePrivateKey: () => (/* binding */ normalizePrivateKey),\n/* harmony export */   pedersen: () => (/* binding */ pedersen),\n/* harmony export */   poseidonBasic: () => (/* binding */ poseidonBasic),\n/* harmony export */   poseidonCreate: () => (/* binding */ poseidonCreate),\n/* harmony export */   poseidonHash: () => (/* binding */ poseidonHash),\n/* harmony export */   poseidonHashFunc: () => (/* binding */ poseidonHashFunc),\n/* harmony export */   poseidonHashMany: () => (/* binding */ poseidonHashMany),\n/* harmony export */   poseidonHashSingle: () => (/* binding */ poseidonHashSingle),\n/* harmony export */   poseidonSmall: () => (/* binding */ poseidonSmall),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.6.0/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.6.0/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.6.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.7.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.7.0/node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.7.0/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.7.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _noble_curves_shortw_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/_shortw_utils */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.7.0/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! scure-starknet - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\n\nconst CURVE_ORDER = BigInt('3618502788666131213697322783095070105526743751716087489154079457884512865583');\n// 2**251, limit for msgHash and Signature.r\nconst MAX_VALUE = BigInt('0x800000000000000000000000000000000000000000000000000000000000000');\nconst nBitLength = 252;\nfunction bits2int(bytes) {\n    while (bytes[0] === 0)\n        bytes = bytes.subarray(1); // strip leading 0s\n    // Copy-pasted from weierstrass.ts\n    const delta = bytes.length * 8 - nBitLength;\n    const num = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction hex0xToBytes(hex) {\n    if (typeof hex === 'string') {\n        hex = strip0x(hex); // allow 0x prefix\n        if (hex.length & 1)\n            hex = '0' + hex; // allow unpadded hex\n    }\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(hex);\n}\nconst curve = (0,_noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__.weierstrass)({\n    a: BigInt(1), // Params: a, b\n    b: BigInt('3141592653589793238462643383279502884197169399375105820974944592307816406665'),\n    // Field over which we'll do calculations; 2n**251n + 17n * 2n**192n + 1n\n    // There is no efficient sqrt for field (P%4==1)\n    Fp: (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field)(BigInt('0x800000000000011000000000000000000000000000000000000000000000001')),\n    n: CURVE_ORDER, // Curve order, total count of valid points in the field.\n    nBitLength, // len(bin(N).replace('0b',''))\n    // Base point (x, y) aka generator point\n    Gx: BigInt('874739451078007766457464989774322083649278607533249481151382481072868806602'),\n    Gy: BigInt('152666792071518830868575557812948353041420400780739481342941381225525861407'),\n    h: BigInt(1), // cofactor\n    lowS: false, // Allow high-s signatures\n    ...(0,_noble_curves_shortw_utils__WEBPACK_IMPORTED_MODULE_3__.getHash)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256),\n    // Custom truncation routines for stark curve\n    bits2int,\n    bits2int_modN: (bytes) => {\n        // 2102820b232636d200cb21f1d330f20d096cae09d1bf3edb1cc333ddee11318 =>\n        // 2102820b232636d200cb21f1d330f20d096cae09d1bf3edb1cc333ddee113180\n        const hex = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes).toString(16); // toHex unpadded\n        if (hex.length === 63)\n            bytes = hex0xToBytes(hex + '0'); // append trailing 0\n        return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(bits2int(bytes), CURVE_ORDER);\n    },\n});\nconst _starkCurve = curve;\nfunction ensureBytes(hex) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.ensureBytes('', typeof hex === 'string' ? hex0xToBytes(hex) : hex);\n}\nfunction normalizePrivateKey(privKey) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(ensureBytes(privKey)).padStart(64, '0');\n}\nfunction getPublicKey(privKey, isCompressed = false) {\n    return curve.getPublicKey(normalizePrivateKey(privKey), isCompressed);\n}\nfunction getSharedSecret(privKeyA, pubKeyB) {\n    return curve.getSharedSecret(normalizePrivateKey(privKeyA), pubKeyB);\n}\nfunction checkSignature(signature) {\n    // Signature.s checked inside weierstrass\n    const { r, s } = signature;\n    if (r < 0n || r >= MAX_VALUE)\n        throw new Error(`Signature.r should be [1, ${MAX_VALUE})`);\n    const w = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.invert)(s, CURVE_ORDER);\n    if (w < 0n || w >= MAX_VALUE)\n        throw new Error(`inv(Signature.s) should be [1, ${MAX_VALUE})`);\n}\nfunction checkMessage(msgHash) {\n    const bytes = ensureBytes(msgHash);\n    const num = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes);\n    // num < 0 impossible here\n    if (num >= MAX_VALUE)\n        throw new Error(`msgHash should be [0, ${MAX_VALUE})`);\n    return bytes;\n}\nfunction sign(msgHash, privKey, opts) {\n    const sig = curve.sign(checkMessage(msgHash), normalizePrivateKey(privKey), opts);\n    checkSignature(sig);\n    return sig;\n}\nfunction verify(signature, msgHash, pubKey) {\n    if (!(signature instanceof Signature)) {\n        const bytes = ensureBytes(signature);\n        try {\n            signature = Signature.fromDER(bytes);\n        }\n        catch (derError) {\n            if (!(derError instanceof _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__.DER.Err))\n                throw derError;\n            signature = Signature.fromCompact(bytes);\n        }\n    }\n    checkSignature(signature);\n    return curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey));\n}\nconst { CURVE, ProjectivePoint, Signature, utils } = curve;\n\nfunction extractX(bytes) {\n    const hex = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(bytes.subarray(1));\n    const stripped = hex.replace(/^0+/gm, ''); // strip leading 0s\n    return `0x${stripped}`;\n}\nfunction strip0x(hex) {\n    return hex.replace(/^0x/i, '');\n}\n// seed generation\nfunction grindKey(seed) {\n    const _seed = ensureBytes(seed);\n    const sha256mask = 2n ** 256n;\n    const limit = sha256mask - (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(sha256mask, CURVE_ORDER);\n    for (let i = 0;; i++) {\n        const key = sha256Num(_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes(_seed, _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.numberToVarBytesBE(BigInt(i))));\n        if (key < limit)\n            return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(key, CURVE_ORDER).toString(16); // key should be in [0, limit)\n        if (i === 100000)\n            throw new Error('grindKey is broken: tried 100k vals'); // prevent dos\n    }\n}\nfunction getStarkKey(privateKey) {\n    return extractX(getPublicKey(privateKey, true));\n}\nfunction ethSigToPrivate(signature) {\n    signature = strip0x(signature);\n    if (signature.length !== 130)\n        throw new Error('Wrong ethereum signature');\n    return grindKey(signature.substring(0, 64));\n}\nconst MASK_31 = 2n ** 31n - 1n;\nconst int31 = (n) => Number(n & MASK_31);\nfunction getAccountPath(layer, application, ethereumAddress, index) {\n    const layerNum = int31(sha256Num(layer));\n    const applicationNum = int31(sha256Num(application));\n    const eth = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.hexToNumber(strip0x(ethereumAddress));\n    return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth >> 31n)}'/${index}`;\n}\n// The Pedersen hash uses five different points on the curve.\n// This is critical to ensure that they have been generated in a way\n// that nobody knows the discrete logarithm of one point regarding another.\n//\n// Starknet utilizes nothing-up-my-sleeve technique:\n// The parameters of the Pedersen hash are generated from the constant ùúã.\n// The x-coordinate of each point is a chunk of 76 decimal digit of ùúã modulo ùëù.\n// If it is a quadratic residue then the point is valid\n// else the x-coordinate coordinate is incremented by one.\n// https://docs.starkware.co/starkex/pedersen-hash-function.html\n// https://github.com/starkware-libs/starkex-for-spot-trading/blob/607f0b4ce507e1d95cd018d206a2797f6ba4aab4/src/starkware/crypto/starkware/crypto/signature/nothing_up_my_sleeve_gen.py\nconst PEDERSEN_POINTS = [\n    new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),\n    new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),\n    new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),\n    new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),\n    new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n),\n];\nfunction pedersenPrecompute(p1, p2) {\n    const out = [];\n    let p = p1;\n    for (let i = 0; i < 248; i++) {\n        out.push(p);\n        p = p.double();\n    }\n    // NOTE: we cannot use wNAF here, because last 4 bits will require full 248 bits multiplication\n    // We can add support for this to wNAF, but it will complicate wNAF.\n    p = p2;\n    for (let i = 0; i < 4; i++) {\n        out.push(p);\n        p = p.double();\n    }\n    return out;\n}\nconst PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);\nconst PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);\nfunction pedersenArg(arg) {\n    let value;\n    if (typeof arg === 'bigint') {\n        value = arg;\n    }\n    else if (typeof arg === 'number') {\n        if (!Number.isSafeInteger(arg))\n            throw new Error(`Invalid pedersenArg: ${arg}`);\n        value = BigInt(arg);\n    }\n    else {\n        value = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(ensureBytes(arg));\n    }\n    if (!(0n <= value && value < curve.CURVE.Fp.ORDER))\n        throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`); // [0..Fp)\n    return value;\n}\n/**\n * Warning: Not algorithmic constant-time.\n */\nfunction pedersenSingle(point, value, constants) {\n    let x = pedersenArg(value);\n    for (let j = 0; j < 252; j++) {\n        const pt = constants[j];\n        if (!pt)\n            throw new Error('invalid constant index');\n        if (pt.equals(point))\n            throw new Error('Same point');\n        if ((x & 1n) !== 0n)\n            point = point.add(pt);\n        x >>= 1n;\n    }\n    return point;\n}\n// shift_point + x_low * P_0 + x_high * P1 + y_low * P2  + y_high * P3\nfunction pedersen(x, y) {\n    let point = PEDERSEN_POINTS[0];\n    point = pedersenSingle(point, x, PEDERSEN_POINTS1);\n    point = pedersenSingle(point, y, PEDERSEN_POINTS2);\n    return extractX(point.toRawBytes(true));\n}\n// Same as hashChain, but computes hash even for single element and order is not revesed\nconst computeHashOnElements = (data, fn = pedersen) => [0, ...data, data.length].reduce((x, y) => fn(x, y));\nconst MASK_250 = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bitMask(250);\nconst keccak = (data) => _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_5__.keccak_256)(data)) & MASK_250;\nconst sha256Num = (data) => _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(data));\n// Poseidon hash\n// Unused for now\n// export const Fp253 = Field(\n//   BigInt('14474011154664525231415395255581126252639794253786371766033694892385558855681')\n// ); // 2^253 + 2^199 + 1\nconst Fp251 = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field)(BigInt('3618502788666131213697322783095070105623107215331596699973092056135872020481')); // 2^251 + 17 * 2^192 + 1\nfunction poseidonRoundConstant(Fp, name, idx) {\n    const val = Fp.fromBytes((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.utf8ToBytes)(`${name}${idx}`)));\n    return Fp.create(val);\n}\n// NOTE: doesn't check eiginvalues and possible can create unsafe matrix. But any filtration here will break compatibility with starknet\n// Please use only if you really know what you doing.\n// https://eprint.iacr.org/2019/458.pdf Section 2.3 (Avoiding Insecure Matrices)\nfunction _poseidonMDS(Fp, name, m, attempt = 0) {\n    const x_values = [];\n    const y_values = [];\n    for (let i = 0; i < m; i++) {\n        x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));\n        y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));\n    }\n    if (new Set([...x_values, ...y_values]).size !== 2 * m)\n        throw new Error('X and Y values are not distinct');\n    return x_values.map((x) => y_values.map((y) => Fp.inv(Fp.sub(x, y))));\n}\nconst MDS_SMALL = [\n    [3, 1, 1],\n    [1, -1, 1],\n    [1, 1, -2],\n].map((i) => i.map(BigInt));\nfunction poseidonBasic(opts, mds) {\n    (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.validateField)(opts.Fp);\n    if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity))\n        throw new Error(`Wrong poseidon opts: ${opts}`);\n    const m = opts.rate + opts.capacity;\n    const rounds = opts.roundsFull + opts.roundsPartial;\n    const roundConstants = [];\n    for (let i = 0; i < rounds; i++) {\n        const row = [];\n        for (let j = 0; j < m; j++)\n            row.push(poseidonRoundConstant(opts.Fp, 'Hades', m * i + j));\n        roundConstants.push(row);\n    }\n    const res = (0,_noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_7__.poseidon)({\n        ...opts,\n        t: m,\n        sboxPower: 3,\n        reversePartialPowIdx: true, // Why?!\n        mds,\n        roundConstants,\n    });\n    res.m = m;\n    res.rate = opts.rate;\n    res.capacity = opts.capacity;\n    return res;\n}\nfunction poseidonCreate(opts, mdsAttempt = 0) {\n    const m = opts.rate + opts.capacity;\n    if (!Number.isSafeInteger(mdsAttempt))\n        throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);\n    return poseidonBasic(opts, _poseidonMDS(opts.Fp, 'HadesMDS', m, mdsAttempt));\n}\nconst poseidonSmall = poseidonBasic({ Fp: Fp251, rate: 2, capacity: 1, roundsFull: 8, roundsPartial: 83 }, MDS_SMALL);\nfunction poseidonHash(x, y, fn = poseidonSmall) {\n    return fn([x, y, 2n])[0];\n}\nfunction poseidonHashFunc(x, y, fn = poseidonSmall) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.numberToVarBytesBE(poseidonHash(_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(x), _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(y), fn));\n}\nfunction poseidonHashSingle(x, fn = poseidonSmall) {\n    return fn([x, 0n, 1n])[0];\n}\nfunction poseidonHashMany(values, fn = poseidonSmall) {\n    const { m, rate } = fn;\n    if (!Array.isArray(values))\n        throw new Error('bigint array expected in values');\n    const padded = Array.from(values); // copy\n    padded.push(1n);\n    while (padded.length % rate !== 0)\n        padded.push(0n);\n    let state = new Array(m).fill(0n);\n    for (let i = 0; i < padded.length; i += rate) {\n        for (let j = 0; j < rate; j++) {\n            const item = padded[i + j];\n            if (typeof item === 'undefined')\n                throw new Error('invalid index');\n            if (typeof state[j] === 'undefined')\n                throw new Error('state[j] is undefined');\n            state[j] = state[j] + item;\n        }\n        state = fn(state);\n    }\n    return state[0];\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNjdXJlK3N0YXJrbmV0QDEuMS4wL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ2dEO0FBQ0Y7QUFDSTtBQUNpQztBQUN4QjtBQUNXO0FBQ3BCO0FBQ0k7QUFDdEQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxnQkFBZ0IseUVBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsV0FBVyxvRUFBWTtBQUN2QjtBQUNBLGNBQWMsK0VBQVc7QUFDekI7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBLFFBQVEscUVBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sbUVBQU8sQ0FBQyx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlFQUFpQixzQkFBc0I7QUFDM0Q7QUFDQSw2Q0FBNkM7QUFDN0MsZUFBZSxtRUFBRztBQUNsQixLQUFLO0FBQ0wsQ0FBQztBQUNNO0FBQ1A7QUFDQSxXQUFXLHFFQUFhO0FBQ3hCO0FBQ087QUFDUCxXQUFXLG9FQUFZO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLHFEQUFxRCxVQUFVO0FBQy9ELGNBQWMsc0VBQU07QUFDcEI7QUFDQSwwREFBMEQsVUFBVTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUVBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7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Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2N1cmUrc3RhcmtuZXRAMS4xLjAvbm9kZV9tb2R1bGVzL0BzY3VyZS9zdGFya25ldC9saWIvZXNtL2luZGV4LmpzP2M0ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNjdXJlLXN0YXJrbmV0IC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEzJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHV0ZjhUb0J5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCB2YWxpZGF0ZUZpZWxkLCBpbnZlcnQgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuaW1wb3J0IHsgcG9zZWlkb24gfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3Bvc2VpZG9uJztcbmltcG9ydCB7IHdlaWVyc3RyYXNzLCBERVIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3dlaWVyc3RyYXNzJztcbmltcG9ydCAqIGFzIHUgZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscyc7XG5pbXBvcnQgeyBnZXRIYXNoIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9fc2hvcnR3X3V0aWxzJztcbmNvbnN0IENVUlZFX09SREVSID0gQmlnSW50KCczNjE4NTAyNzg4NjY2MTMxMjEzNjk3MzIyNzgzMDk1MDcwMTA1NTI2NzQzNzUxNzE2MDg3NDg5MTU0MDc5NDU3ODg0NTEyODY1NTgzJyk7XG4vLyAyKioyNTEsIGxpbWl0IGZvciBtc2dIYXNoIGFuZCBTaWduYXR1cmUuclxuZXhwb3J0IGNvbnN0IE1BWF9WQUxVRSA9IEJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTtcbmNvbnN0IG5CaXRMZW5ndGggPSAyNTI7XG5mdW5jdGlvbiBiaXRzMmludChieXRlcykge1xuICAgIHdoaWxlIChieXRlc1swXSA9PT0gMClcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zdWJhcnJheSgxKTsgLy8gc3RyaXAgbGVhZGluZyAwc1xuICAgIC8vIENvcHktcGFzdGVkIGZyb20gd2VpZXJzdHJhc3MudHNcbiAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBuQml0TGVuZ3RoO1xuICAgIGNvbnN0IG51bSA9IHUuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG59XG5mdW5jdGlvbiBoZXgweFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IHN0cmlwMHgoaGV4KTsgLy8gYWxsb3cgMHggcHJlZml4XG4gICAgICAgIGlmIChoZXgubGVuZ3RoICYgMSlcbiAgICAgICAgICAgIGhleCA9ICcwJyArIGhleDsgLy8gYWxsb3cgdW5wYWRkZWQgaGV4XG4gICAgfVxuICAgIHJldHVybiB1LmhleFRvQnl0ZXMoaGV4KTtcbn1cbmNvbnN0IGN1cnZlID0gd2VpZXJzdHJhc3Moe1xuICAgIGE6IEJpZ0ludCgxKSwgLy8gUGFyYW1zOiBhLCBiXG4gICAgYjogQmlnSW50KCczMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTAyODg0MTk3MTY5Mzk5Mzc1MTA1ODIwOTc0OTQ0NTkyMzA3ODE2NDA2NjY1JyksXG4gICAgLy8gRmllbGQgb3ZlciB3aGljaCB3ZSdsbCBkbyBjYWxjdWxhdGlvbnM7IDJuKioyNTFuICsgMTduICogMm4qKjE5Mm4gKyAxblxuICAgIC8vIFRoZXJlIGlzIG5vIGVmZmljaWVudCBzcXJ0IGZvciBmaWVsZCAoUCU0PT0xKVxuICAgIEZwOiBGaWVsZChCaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDExMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJykpLFxuICAgIG46IENVUlZFX09SREVSLCAvLyBDdXJ2ZSBvcmRlciwgdG90YWwgY291bnQgb2YgdmFsaWQgcG9pbnRzIGluIHRoZSBmaWVsZC5cbiAgICBuQml0TGVuZ3RoLCAvLyBsZW4oYmluKE4pLnJlcGxhY2UoJzBiJywnJykpXG4gICAgLy8gQmFzZSBwb2ludCAoeCwgeSkgYWthIGdlbmVyYXRvciBwb2ludFxuICAgIEd4OiBCaWdJbnQoJzg3NDczOTQ1MTA3ODAwNzc2NjQ1NzQ2NDk4OTc3NDMyMjA4MzY0OTI3ODYwNzUzMzI0OTQ4MTE1MTM4MjQ4MTA3Mjg2ODgwNjYwMicpLFxuICAgIEd5OiBCaWdJbnQoJzE1MjY2Njc5MjA3MTUxODgzMDg2ODU3NTU1NzgxMjk0ODM1MzA0MTQyMDQwMDc4MDczOTQ4MTM0Mjk0MTM4MTIyNTUyNTg2MTQwNycpLFxuICAgIGg6IEJpZ0ludCgxKSwgLy8gY29mYWN0b3JcbiAgICBsb3dTOiBmYWxzZSwgLy8gQWxsb3cgaGlnaC1zIHNpZ25hdHVyZXNcbiAgICAuLi5nZXRIYXNoKHNoYTI1NiksXG4gICAgLy8gQ3VzdG9tIHRydW5jYXRpb24gcm91dGluZXMgZm9yIHN0YXJrIGN1cnZlXG4gICAgYml0czJpbnQsXG4gICAgYml0czJpbnRfbW9kTjogKGJ5dGVzKSA9PiB7XG4gICAgICAgIC8vIDIxMDI4MjBiMjMyNjM2ZDIwMGNiMjFmMWQzMzBmMjBkMDk2Y2FlMDlkMWJmM2VkYjFjYzMzM2RkZWUxMTMxOCA9PlxuICAgICAgICAvLyAyMTAyODIwYjIzMjYzNmQyMDBjYjIxZjFkMzMwZjIwZDA5NmNhZTA5ZDFiZjNlZGIxY2MzMzNkZGVlMTEzMTgwXG4gICAgICAgIGNvbnN0IGhleCA9IHUuYnl0ZXNUb051bWJlckJFKGJ5dGVzKS50b1N0cmluZygxNik7IC8vIHRvSGV4IHVucGFkZGVkXG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA2MylcbiAgICAgICAgICAgIGJ5dGVzID0gaGV4MHhUb0J5dGVzKGhleCArICcwJyk7IC8vIGFwcGVuZCB0cmFpbGluZyAwXG4gICAgICAgIHJldHVybiBtb2QoYml0czJpbnQoYnl0ZXMpLCBDVVJWRV9PUkRFUik7XG4gICAgfSxcbn0pO1xuZXhwb3J0IGNvbnN0IF9zdGFya0N1cnZlID0gY3VydmU7XG5mdW5jdGlvbiBlbnN1cmVCeXRlcyhoZXgpIHtcbiAgICByZXR1cm4gdS5lbnN1cmVCeXRlcygnJywgdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoZXgweFRvQnl0ZXMoaGV4KSA6IGhleCk7XG59XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUHJpdmF0ZUtleShwcml2S2V5KSB7XG4gICAgcmV0dXJuIHUuYnl0ZXNUb0hleChlbnN1cmVCeXRlcyhwcml2S2V5KSkucGFkU3RhcnQoNjQsICcwJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZLZXksIGlzQ29tcHJlc3NlZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGN1cnZlLmdldFB1YmxpY0tleShub3JtYWxpemVQcml2YXRlS2V5KHByaXZLZXkpLCBpc0NvbXByZXNzZWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2S2V5QSwgcHViS2V5Qikge1xuICAgIHJldHVybiBjdXJ2ZS5nZXRTaGFyZWRTZWNyZXQobm9ybWFsaXplUHJpdmF0ZUtleShwcml2S2V5QSksIHB1YktleUIpO1xufVxuZnVuY3Rpb24gY2hlY2tTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgLy8gU2lnbmF0dXJlLnMgY2hlY2tlZCBpbnNpZGUgd2VpZXJzdHJhc3NcbiAgICBjb25zdCB7IHIsIHMgfSA9IHNpZ25hdHVyZTtcbiAgICBpZiAociA8IDBuIHx8IHIgPj0gTUFYX1ZBTFVFKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpZ25hdHVyZS5yIHNob3VsZCBiZSBbMSwgJHtNQVhfVkFMVUV9KWApO1xuICAgIGNvbnN0IHcgPSBpbnZlcnQocywgQ1VSVkVfT1JERVIpO1xuICAgIGlmICh3IDwgMG4gfHwgdyA+PSBNQVhfVkFMVUUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52KFNpZ25hdHVyZS5zKSBzaG91bGQgYmUgWzEsICR7TUFYX1ZBTFVFfSlgKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTWVzc2FnZShtc2dIYXNoKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhtc2dIYXNoKTtcbiAgICBjb25zdCBudW0gPSB1LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgLy8gbnVtIDwgMCBpbXBvc3NpYmxlIGhlcmVcbiAgICBpZiAobnVtID49IE1BWF9WQUxVRSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtc2dIYXNoIHNob3VsZCBiZSBbMCwgJHtNQVhfVkFMVUV9KWApO1xuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpIHtcbiAgICBjb25zdCBzaWcgPSBjdXJ2ZS5zaWduKGNoZWNrTWVzc2FnZShtc2dIYXNoKSwgbm9ybWFsaXplUHJpdmF0ZUtleShwcml2S2V5KSwgb3B0cyk7XG4gICAgY2hlY2tTaWduYXR1cmUoc2lnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YktleSkge1xuICAgIGlmICghKHNpZ25hdHVyZSBpbnN0YW5jZW9mIFNpZ25hdHVyZSkpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhzaWduYXR1cmUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21ERVIoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChieXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gY3VydmUudmVyaWZ5KHNpZ25hdHVyZSwgY2hlY2tNZXNzYWdlKG1zZ0hhc2gpLCBlbnN1cmVCeXRlcyhwdWJLZXkpKTtcbn1cbmNvbnN0IHsgQ1VSVkUsIFByb2plY3RpdmVQb2ludCwgU2lnbmF0dXJlLCB1dGlscyB9ID0gY3VydmU7XG5leHBvcnQgeyBDVVJWRSwgUHJvamVjdGl2ZVBvaW50LCBTaWduYXR1cmUsIHV0aWxzIH07XG5mdW5jdGlvbiBleHRyYWN0WChieXRlcykge1xuICAgIGNvbnN0IGhleCA9IHUuYnl0ZXNUb0hleChieXRlcy5zdWJhcnJheSgxKSk7XG4gICAgY29uc3Qgc3RyaXBwZWQgPSBoZXgucmVwbGFjZSgvXjArL2dtLCAnJyk7IC8vIHN0cmlwIGxlYWRpbmcgMHNcbiAgICByZXR1cm4gYDB4JHtzdHJpcHBlZH1gO1xufVxuZnVuY3Rpb24gc3RyaXAweChoZXgpIHtcbiAgICByZXR1cm4gaGV4LnJlcGxhY2UoL14weC9pLCAnJyk7XG59XG4vLyBzZWVkIGdlbmVyYXRpb25cbmV4cG9ydCBmdW5jdGlvbiBncmluZEtleShzZWVkKSB7XG4gICAgY29uc3QgX3NlZWQgPSBlbnN1cmVCeXRlcyhzZWVkKTtcbiAgICBjb25zdCBzaGEyNTZtYXNrID0gMm4gKiogMjU2bjtcbiAgICBjb25zdCBsaW1pdCA9IHNoYTI1Nm1hc2sgLSBtb2Qoc2hhMjU2bWFzaywgQ1VSVkVfT1JERVIpO1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHNoYTI1Nk51bSh1LmNvbmNhdEJ5dGVzKF9zZWVkLCB1Lm51bWJlclRvVmFyQnl0ZXNCRShCaWdJbnQoaSkpKSk7XG4gICAgICAgIGlmIChrZXkgPCBsaW1pdClcbiAgICAgICAgICAgIHJldHVybiBtb2Qoa2V5LCBDVVJWRV9PUkRFUikudG9TdHJpbmcoMTYpOyAvLyBrZXkgc2hvdWxkIGJlIGluIFswLCBsaW1pdClcbiAgICAgICAgaWYgKGkgPT09IDEwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ3JpbmRLZXkgaXMgYnJva2VuOiB0cmllZCAxMDBrIHZhbHMnKTsgLy8gcHJldmVudCBkb3NcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhcmtLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBleHRyYWN0WChnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgdHJ1ZSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV0aFNpZ1RvUHJpdmF0ZShzaWduYXR1cmUpIHtcbiAgICBzaWduYXR1cmUgPSBzdHJpcDB4KHNpZ25hdHVyZSk7XG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBldGhlcmV1bSBzaWduYXR1cmUnKTtcbiAgICByZXR1cm4gZ3JpbmRLZXkoc2lnbmF0dXJlLnN1YnN0cmluZygwLCA2NCkpO1xufVxuY29uc3QgTUFTS18zMSA9IDJuICoqIDMxbiAtIDFuO1xuY29uc3QgaW50MzEgPSAobikgPT4gTnVtYmVyKG4gJiBNQVNLXzMxKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2NvdW50UGF0aChsYXllciwgYXBwbGljYXRpb24sIGV0aGVyZXVtQWRkcmVzcywgaW5kZXgpIHtcbiAgICBjb25zdCBsYXllck51bSA9IGludDMxKHNoYTI1Nk51bShsYXllcikpO1xuICAgIGNvbnN0IGFwcGxpY2F0aW9uTnVtID0gaW50MzEoc2hhMjU2TnVtKGFwcGxpY2F0aW9uKSk7XG4gICAgY29uc3QgZXRoID0gdS5oZXhUb051bWJlcihzdHJpcDB4KGV0aGVyZXVtQWRkcmVzcykpO1xuICAgIHJldHVybiBgbS8yNjQ1Jy8ke2xheWVyTnVtfScvJHthcHBsaWNhdGlvbk51bX0nLyR7aW50MzEoZXRoKX0nLyR7aW50MzEoZXRoID4+IDMxbil9Jy8ke2luZGV4fWA7XG59XG4vLyBUaGUgUGVkZXJzZW4gaGFzaCB1c2VzIGZpdmUgZGlmZmVyZW50IHBvaW50cyBvbiB0aGUgY3VydmUuXG4vLyBUaGlzIGlzIGNyaXRpY2FsIHRvIGVuc3VyZSB0aGF0IHRoZXkgaGF2ZSBiZWVuIGdlbmVyYXRlZCBpbiBhIHdheVxuLy8gdGhhdCBub2JvZHkga25vd3MgdGhlIGRpc2NyZXRlIGxvZ2FyaXRobSBvZiBvbmUgcG9pbnQgcmVnYXJkaW5nIGFub3RoZXIuXG4vL1xuLy8gU3RhcmtuZXQgdXRpbGl6ZXMgbm90aGluZy11cC1teS1zbGVldmUgdGVjaG5pcXVlOlxuLy8gVGhlIHBhcmFtZXRlcnMgb2YgdGhlIFBlZGVyc2VuIGhhc2ggYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBjb25zdGFudCDwnZyLLlxuLy8gVGhlIHgtY29vcmRpbmF0ZSBvZiBlYWNoIHBvaW50IGlzIGEgY2h1bmsgb2YgNzYgZGVjaW1hbCBkaWdpdCBvZiDwnZyLIG1vZHVsbyDwnZGdLlxuLy8gSWYgaXQgaXMgYSBxdWFkcmF0aWMgcmVzaWR1ZSB0aGVuIHRoZSBwb2ludCBpcyB2YWxpZFxuLy8gZWxzZSB0aGUgeC1jb29yZGluYXRlIGNvb3JkaW5hdGUgaXMgaW5jcmVtZW50ZWQgYnkgb25lLlxuLy8gaHR0cHM6Ly9kb2NzLnN0YXJrd2FyZS5jby9zdGFya2V4L3BlZGVyc2VuLWhhc2gtZnVuY3Rpb24uaHRtbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrZXgtZm9yLXNwb3QtdHJhZGluZy9ibG9iLzYwN2YwYjRjZTUwN2UxZDk1Y2QwMThkMjA2YTI3OTdmNmJhNGFhYjQvc3JjL3N0YXJrd2FyZS9jcnlwdG8vc3Rhcmt3YXJlL2NyeXB0by9zaWduYXR1cmUvbm90aGluZ191cF9teV9zbGVldmVfZ2VuLnB5XG5jb25zdCBQRURFUlNFTl9QT0lOVFMgPSBbXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0biwgMTcxMzkzMTMyOTU0MDY2MDM3NzAyMzQwNjEwOTE5OTQxMDQxNDgxMDcwNTg2NzI2MDgwMjA3ODE4NzA4MjM0NTUyOTIwNzY5NDk4Nm4sIDFuKSxcbiAgICBuZXcgUHJvamVjdGl2ZVBvaW50KDk5Njc4MTIwNTgzMzAwODc3NDUxNDUwMDA4MjM3Njc4MzI0OTEwMjM5NjAyMzY2MzQ1NDgxMzQ0NzQyMzE0Nzk3NzM5NzIzMjc2M24sIDE2Njg1MDM2NzY3ODYzNzc3MjU4MDU0ODkzNDQ3NzEwMjM5MjEwNzkxMjY1NTIwMTkxNjAxNTY5MjA2MzQ2MTkyNTU5NzA0ODU3ODFuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMjUxNTYzMjc0NDg5NzUwNTM1MTE3ODg2NDI2NTMzMjIyNDM1Mjk0MDQ2NDI4MzQ3MzI5MjAzNjI3MDIxMjQ5MTY5NjE2MTg0MTg0biwgMTc5ODcxNjAwNzU2MjcyODkwNTI5NTQ4MDY3OTc4OTUyNjMyMjE3NTg2ODMyODA2MjQyMDIzNzQxOTE0MzU5MzAyMTY3NDk5Mjk3M24sIDFuKSxcbiAgICBuZXcgUHJvamVjdGl2ZVBvaW50KDIxMzg0MTQ2OTUxOTQxNTExNjA5NDMzMDU3MjcwMzY1NzU5NTkxOTUzMDkyMTg2MTE3MzgxOTMyNjExNzkzMTA1MTE4NTQ4MDc0NDduLCAxMTM0MTAyNzY3MzAwNjQ0ODYyNTUxMDIwOTM4NDY1NDAxMzM3ODQ4NjUyODY5MjkwNTI0MjY5MzE0NzQxMDYzOTYxMzUwNzIxNTZuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMzc5OTYyNzQ5NTY3MzUxODg1NzUyNzI0ODkxMjI3OTM4MTgzMDExOTQ5MTI5ODMzNjczMzYyNDQwNjU2NjQzMDg2MDIxMzk0OTQ2biwgNzc2NDk2NDUzNjMzMjk4MTc1NDgzOTg1Mzk4NjQ4NzU4NTg2NTI1OTMzODEyNTM2NjUzMDg5NDAxOTA1MjkyMDYzNzA4ODE2NDIybiwgMW4pLFxuXTtcbmZ1bmN0aW9uIHBlZGVyc2VuUHJlY29tcHV0ZShwMSwgcDIpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcCA9IHAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjQ4OyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2gocCk7XG4gICAgICAgIHAgPSBwLmRvdWJsZSgpO1xuICAgIH1cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgdXNlIHdOQUYgaGVyZSwgYmVjYXVzZSBsYXN0IDQgYml0cyB3aWxsIHJlcXVpcmUgZnVsbCAyNDggYml0cyBtdWx0aXBsaWNhdGlvblxuICAgIC8vIFdlIGNhbiBhZGQgc3VwcG9ydCBmb3IgdGhpcyB0byB3TkFGLCBidXQgaXQgd2lsbCBjb21wbGljYXRlIHdOQUYuXG4gICAgcCA9IHAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoKHApO1xuICAgICAgICBwID0gcC5kb3VibGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmNvbnN0IFBFREVSU0VOX1BPSU5UUzEgPSBwZWRlcnNlblByZWNvbXB1dGUoUEVERVJTRU5fUE9JTlRTWzFdLCBQRURFUlNFTl9QT0lOVFNbMl0pO1xuY29uc3QgUEVERVJTRU5fUE9JTlRTMiA9IHBlZGVyc2VuUHJlY29tcHV0ZShQRURFUlNFTl9QT0lOVFNbM10sIFBFREVSU0VOX1BPSU5UU1s0XSk7XG5mdW5jdGlvbiBwZWRlcnNlbkFyZyhhcmcpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHZhbHVlID0gYXJnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGFyZykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGVkZXJzZW5Bcmc6ICR7YXJnfWApO1xuICAgICAgICB2YWx1ZSA9IEJpZ0ludChhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB1LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcyhhcmcpKTtcbiAgICB9XG4gICAgaWYgKCEoMG4gPD0gdmFsdWUgJiYgdmFsdWUgPCBjdXJ2ZS5DVVJWRS5GcC5PUkRFUikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGVkZXJzZW5Bcmcgc2hvdWxkIGJlIDAgPD0gdmFsdWUgPCBDVVJWRS5QOiAke3ZhbHVlfWApOyAvLyBbMC4uRnApXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBXYXJuaW5nOiBOb3QgYWxnb3JpdGhtaWMgY29uc3RhbnQtdGltZS5cbiAqL1xuZnVuY3Rpb24gcGVkZXJzZW5TaW5nbGUocG9pbnQsIHZhbHVlLCBjb25zdGFudHMpIHtcbiAgICBsZXQgeCA9IHBlZGVyc2VuQXJnKHZhbHVlKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI1MjsgaisrKSB7XG4gICAgICAgIGNvbnN0IHB0ID0gY29uc3RhbnRzW2pdO1xuICAgICAgICBpZiAoIXB0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNvbnN0YW50IGluZGV4Jyk7XG4gICAgICAgIGlmIChwdC5lcXVhbHMocG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTYW1lIHBvaW50Jyk7XG4gICAgICAgIGlmICgoeCAmIDFuKSAhPT0gMG4pXG4gICAgICAgICAgICBwb2ludCA9IHBvaW50LmFkZChwdCk7XG4gICAgICAgIHggPj49IDFuO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnQ7XG59XG4vLyBzaGlmdF9wb2ludCArIHhfbG93ICogUF8wICsgeF9oaWdoICogUDEgKyB5X2xvdyAqIFAyICArIHlfaGlnaCAqIFAzXG5leHBvcnQgZnVuY3Rpb24gcGVkZXJzZW4oeCwgeSkge1xuICAgIGxldCBwb2ludCA9IFBFREVSU0VOX1BPSU5UU1swXTtcbiAgICBwb2ludCA9IHBlZGVyc2VuU2luZ2xlKHBvaW50LCB4LCBQRURFUlNFTl9QT0lOVFMxKTtcbiAgICBwb2ludCA9IHBlZGVyc2VuU2luZ2xlKHBvaW50LCB5LCBQRURFUlNFTl9QT0lOVFMyKTtcbiAgICByZXR1cm4gZXh0cmFjdFgocG9pbnQudG9SYXdCeXRlcyh0cnVlKSk7XG59XG4vLyBTYW1lIGFzIGhhc2hDaGFpbiwgYnV0IGNvbXB1dGVzIGhhc2ggZXZlbiBmb3Igc2luZ2xlIGVsZW1lbnQgYW5kIG9yZGVyIGlzIG5vdCByZXZlc2VkXG5leHBvcnQgY29uc3QgY29tcHV0ZUhhc2hPbkVsZW1lbnRzID0gKGRhdGEsIGZuID0gcGVkZXJzZW4pID0+IFswLCAuLi5kYXRhLCBkYXRhLmxlbmd0aF0ucmVkdWNlKCh4LCB5KSA9PiBmbih4LCB5KSk7XG5jb25zdCBNQVNLXzI1MCA9IHUuYml0TWFzaygyNTApO1xuZXhwb3J0IGNvbnN0IGtlY2NhayA9IChkYXRhKSA9PiB1LmJ5dGVzVG9OdW1iZXJCRShrZWNjYWtfMjU2KGRhdGEpKSAmIE1BU0tfMjUwO1xuY29uc3Qgc2hhMjU2TnVtID0gKGRhdGEpID0+IHUuYnl0ZXNUb051bWJlckJFKHNoYTI1NihkYXRhKSk7XG4vLyBQb3NlaWRvbiBoYXNoXG4vLyBVbnVzZWQgZm9yIG5vd1xuLy8gZXhwb3J0IGNvbnN0IEZwMjUzID0gRmllbGQoXG4vLyAgIEJpZ0ludCgnMTQ0NzQwMTExNTQ2NjQ1MjUyMzE0MTUzOTUyNTU1ODExMjYyNTI2Mzk3OTQyNTM3ODYzNzE3NjYwMzM2OTQ4OTIzODU1NTg4NTU2ODEnKVxuLy8gKTsgLy8gMl4yNTMgKyAyXjE5OSArIDFcbmV4cG9ydCBjb25zdCBGcDI1MSA9IEZpZWxkKEJpZ0ludCgnMzYxODUwMjc4ODY2NjEzMTIxMzY5NzMyMjc4MzA5NTA3MDEwNTYyMzEwNzIxNTMzMTU5NjY5OTk3MzA5MjA1NjEzNTg3MjAyMDQ4MScpKTsgLy8gMl4yNTEgKyAxNyAqIDJeMTkyICsgMVxuZnVuY3Rpb24gcG9zZWlkb25Sb3VuZENvbnN0YW50KEZwLCBuYW1lLCBpZHgpIHtcbiAgICBjb25zdCB2YWwgPSBGcC5mcm9tQnl0ZXMoc2hhMjU2KHV0ZjhUb0J5dGVzKGAke25hbWV9JHtpZHh9YCkpKTtcbiAgICByZXR1cm4gRnAuY3JlYXRlKHZhbCk7XG59XG4vLyBOT1RFOiBkb2Vzbid0IGNoZWNrIGVpZ2ludmFsdWVzIGFuZCBwb3NzaWJsZSBjYW4gY3JlYXRlIHVuc2FmZSBtYXRyaXguIEJ1dCBhbnkgZmlsdHJhdGlvbiBoZXJlIHdpbGwgYnJlYWsgY29tcGF0aWJpbGl0eSB3aXRoIHN0YXJrbmV0XG4vLyBQbGVhc2UgdXNlIG9ubHkgaWYgeW91IHJlYWxseSBrbm93IHdoYXQgeW91IGRvaW5nLlxuLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxOS80NTgucGRmIFNlY3Rpb24gMi4zIChBdm9pZGluZyBJbnNlY3VyZSBNYXRyaWNlcylcbmV4cG9ydCBmdW5jdGlvbiBfcG9zZWlkb25NRFMoRnAsIG5hbWUsIG0sIGF0dGVtcHQgPSAwKSB7XG4gICAgY29uc3QgeF92YWx1ZXMgPSBbXTtcbiAgICBjb25zdCB5X3ZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgIHhfdmFsdWVzLnB1c2gocG9zZWlkb25Sb3VuZENvbnN0YW50KEZwLCBgJHtuYW1lfXhgLCBhdHRlbXB0ICogbSArIGkpKTtcbiAgICAgICAgeV92YWx1ZXMucHVzaChwb3NlaWRvblJvdW5kQ29uc3RhbnQoRnAsIGAke25hbWV9eWAsIGF0dGVtcHQgKiBtICsgaSkpO1xuICAgIH1cbiAgICBpZiAobmV3IFNldChbLi4ueF92YWx1ZXMsIC4uLnlfdmFsdWVzXSkuc2l6ZSAhPT0gMiAqIG0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWCBhbmQgWSB2YWx1ZXMgYXJlIG5vdCBkaXN0aW5jdCcpO1xuICAgIHJldHVybiB4X3ZhbHVlcy5tYXAoKHgpID0+IHlfdmFsdWVzLm1hcCgoeSkgPT4gRnAuaW52KEZwLnN1Yih4LCB5KSkpKTtcbn1cbmNvbnN0IE1EU19TTUFMTCA9IFtcbiAgICBbMywgMSwgMV0sXG4gICAgWzEsIC0xLCAxXSxcbiAgICBbMSwgMSwgLTJdLFxuXS5tYXAoKGkpID0+IGkubWFwKEJpZ0ludCkpO1xuZXhwb3J0IGZ1bmN0aW9uIHBvc2VpZG9uQmFzaWMob3B0cywgbWRzKSB7XG4gICAgdmFsaWRhdGVGaWVsZChvcHRzLkZwKTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdHMucmF0ZSkgfHwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdHMuY2FwYWNpdHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2VpZG9uIG9wdHM6ICR7b3B0c31gKTtcbiAgICBjb25zdCBtID0gb3B0cy5yYXRlICsgb3B0cy5jYXBhY2l0eTtcbiAgICBjb25zdCByb3VuZHMgPSBvcHRzLnJvdW5kc0Z1bGwgKyBvcHRzLnJvdW5kc1BhcnRpYWw7XG4gICAgY29uc3Qgcm91bmRDb25zdGFudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKylcbiAgICAgICAgICAgIHJvdy5wdXNoKHBvc2VpZG9uUm91bmRDb25zdGFudChvcHRzLkZwLCAnSGFkZXMnLCBtICogaSArIGopKTtcbiAgICAgICAgcm91bmRDb25zdGFudHMucHVzaChyb3cpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBwb3NlaWRvbih7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIHQ6IG0sXG4gICAgICAgIHNib3hQb3dlcjogMyxcbiAgICAgICAgcmV2ZXJzZVBhcnRpYWxQb3dJZHg6IHRydWUsIC8vIFdoeT8hXG4gICAgICAgIG1kcyxcbiAgICAgICAgcm91bmRDb25zdGFudHMsXG4gICAgfSk7XG4gICAgcmVzLm0gPSBtO1xuICAgIHJlcy5yYXRlID0gb3B0cy5yYXRlO1xuICAgIHJlcy5jYXBhY2l0eSA9IG9wdHMuY2FwYWNpdHk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkNyZWF0ZShvcHRzLCBtZHNBdHRlbXB0ID0gMCkge1xuICAgIGNvbnN0IG0gPSBvcHRzLnJhdGUgKyBvcHRzLmNhcGFjaXR5O1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobWRzQXR0ZW1wdCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgbWRzQXR0ZW1wdD0ke21kc0F0dGVtcHR9YCk7XG4gICAgcmV0dXJuIHBvc2VpZG9uQmFzaWMob3B0cywgX3Bvc2VpZG9uTURTKG9wdHMuRnAsICdIYWRlc01EUycsIG0sIG1kc0F0dGVtcHQpKTtcbn1cbmV4cG9ydCBjb25zdCBwb3NlaWRvblNtYWxsID0gcG9zZWlkb25CYXNpYyh7IEZwOiBGcDI1MSwgcmF0ZTogMiwgY2FwYWNpdHk6IDEsIHJvdW5kc0Z1bGw6IDgsIHJvdW5kc1BhcnRpYWw6IDgzIH0sIE1EU19TTUFMTCk7XG5leHBvcnQgZnVuY3Rpb24gcG9zZWlkb25IYXNoKHgsIHksIGZuID0gcG9zZWlkb25TbWFsbCkge1xuICAgIHJldHVybiBmbihbeCwgeSwgMm5dKVswXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkhhc2hGdW5jKHgsIHksIGZuID0gcG9zZWlkb25TbWFsbCkge1xuICAgIHJldHVybiB1Lm51bWJlclRvVmFyQnl0ZXNCRShwb3NlaWRvbkhhc2godS5ieXRlc1RvTnVtYmVyQkUoeCksIHUuYnl0ZXNUb051bWJlckJFKHkpLCBmbikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc2VpZG9uSGFzaFNpbmdsZSh4LCBmbiA9IHBvc2VpZG9uU21hbGwpIHtcbiAgICByZXR1cm4gZm4oW3gsIDBuLCAxbl0pWzBdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc2VpZG9uSGFzaE1hbnkodmFsdWVzLCBmbiA9IHBvc2VpZG9uU21hbGwpIHtcbiAgICBjb25zdCB7IG0sIHJhdGUgfSA9IGZuO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBhcnJheSBleHBlY3RlZCBpbiB2YWx1ZXMnKTtcbiAgICBjb25zdCBwYWRkZWQgPSBBcnJheS5mcm9tKHZhbHVlcyk7IC8vIGNvcHlcbiAgICBwYWRkZWQucHVzaCgxbik7XG4gICAgd2hpbGUgKHBhZGRlZC5sZW5ndGggJSByYXRlICE9PSAwKVxuICAgICAgICBwYWRkZWQucHVzaCgwbik7XG4gICAgbGV0IHN0YXRlID0gbmV3IEFycmF5KG0pLmZpbGwoMG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGVkLmxlbmd0aDsgaSArPSByYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmF0ZTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gcGFkZGVkW2kgKyBqXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluZGV4Jyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlW2pdID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXRlW2pdIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgc3RhdGVbal0gPSBzdGF0ZVtqXSArIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSBmbihzdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZVswXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@scure+starknet@1.1.0/node_modules/@scure/starknet/lib/esm/index.js\n");

/***/ })

};
;